['pragma solidity ^0.8.0; \n', '\n', 'import "SafeMath.sol";\n', 'import "Ownable.sol";\n', '\n', '/*\n', ' SPDX-License-Identifier: MIT\n', '*/\n', '\n', 'contract Minter is Ownable {\n', '    address payable public mintingowner;\n', '    address payable internal newMintingOwner;\n', '\n', '    event MintingOwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() {\n', '        mintingowner = payable(msg.sender);\n', '        emit MintingOwnershipTransferred(address(0), mintingowner);\n', '    }\n', '\n', '    modifier onlyMintingOwner {\n', '        require(msg.sender == mintingowner);\n', '        _;\n', '    }\n', '\n', '    function transferMintingOwnership(address payable _newMintingOwner) public onlyOwner {\n', '        newMintingOwner = _newMintingOwner;\n', '    }\n', '\n', '    //this flow is to prevent transferring ownership to wrong wallet by mistake\n', '    function acceptMintingOwnership() public {\n', '        require(msg.sender == newMintingOwner);\n', '        emit MintingOwnershipTransferred(mintingowner, newMintingOwner);\n', '        mintingowner = newMintingOwner;\n', '        newMintingOwner = payable(address(0));\n', '    }\n', '}\n', '\n', 'contract ROSA is Ownable, Minter {\n', '\n', '    //--- Token variables ---------------//\n', '\n', '    using SafeMath for uint256;\n', '    string constant private _name = "ROSA";\n', '    string constant private _symbol = "ROSA";\n', '    uint256 constant private _decimals = 18;\n', '    uint256 private _totalSupply = 0;\n', '    bool public safeguard;  //putting safeguard on will halt all non-owner functions\n', '\n', '    // This creates a mapping with all data storage\n', '    mapping (address => uint256) private _balanceOf;\n', '    mapping (address => mapping (address => uint256)) private _allowance;\n', '    //User wallet freezing/blacklisting\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    //---  EVENTS -----------------------//\n', '\n', '    // This generates a public event of token transfer\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // This generates a public event for frozen (blacklisting) accounts\n', '    event FrozenAccounts(address target, bool frozen);\n', '\n', '    // This will log approval of token Transfer\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '\n', '    /*======================================\n', '    =       STANDARD ERC20 FUNCTIONS       =\n', '    ======================================*/\n', '\n', '    /**\n', '     * Returns name of token\n', '     */\n', '    function name() public pure returns(string memory){\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * Returns symbol of token\n', '     */\n', '    function symbol() public pure returns(string memory){\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * Returns decimals of token\n', '     */\n', '    function decimals()  public pure returns(uint256){\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * Returns totalSupply of token.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns balance of token\n', '     */\n', '    function balanceOf(address user) public view returns(uint256){\n', '        return _balanceOf[user];\n', '    }\n', '\n', '    /**\n', '     * Returns allowance of token\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowance[owner][spender];\n', '    }\n', '\n', '    /**\n', '        * Transfer tokens\n', '        *\n', '        * Send `_value` tokens to `_to` from your account\n', '        *\n', '        * @param _to The address of the recipient\n', '        * @param _value the amount to send\n', '        */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        //no need to check for input validations, as that is ruled by SafeMath\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '\n', '        //checking conditions\n', '        require(!safeguard);\n', '        require(_from != address(0), "ERC20: transfer from the zero address");\n', '        require(_to != address(0), "ERC20: transfer to the zero address");\n', "        require(!frozenAccount[_from], 'blacklisted account');          // Check if sender is frozen\n", "        require(!frozenAccount[_to], 'blacklisted account');            // Check if recipient is frozen\n", '        \n', '        _beforeTokenTransfer(_from, _to, _value);\n', '         \n', '        // overflow and undeflow checked by SafeMath Library\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);        // Add the same to the recipient\n', '\n', '        // emit Transfer event\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '\n', '    /**\n', '        * Transfer tokens from other address\n', '        *\n', '        * Send `_value` tokens to `_to` in behalf of `_from`\n', '        *\n', '        * @param _from The address of the sender\n', '        * @param _to The address of the recipient\n', '        * @param _value the amount to send\n', '        */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        //checking of allowance and token value is done by SafeMath\n', '        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        * Set allowance for other address\n', '        *\n', '        * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '        *\n', '        * @param _spender The address authorized to spend\n', '        * @param _value the max amount they can spend\n', '        */\n', '    function approve(address _spender, uint256 _value)  public returns (bool success) {\n', '\n', '        require(_spender != address(0), "ERC20: approve to the zero address");    \n', '        require(!safeguard);\n', '        _allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to increase the allowance by.\n', '     */\n', '    function increase_allowance(address spender, uint256 value) public returns (bool) {\n', '        require(!safeguard);\n', '        require(spender != address(0), "ERC20: approve to the zero address"); \n', '        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\n', '        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decrease_allowance(address spender, uint256 value) public returns (bool) {\n', '        require(!safeguard);\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\n', '        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal { }\n', '    \n', '\n', '    /**\n', '        * Destroy tokens\n', '        *\n', '        * Remove `_value` tokens from the system irreversibly\n', '        *\n', '        * @param _value the amount of money to burn\n', '        */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(!safeguard);\n', "        require(!frozenAccount[msg.sender], 'blacklisted account');\n", '        \n', '        _beforeTokenTransfer(msg.sender, address(0), _value);\n', '        \n', '        //checking of enough token balance is done by SafeMath\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\n', '        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        * @notice Create `mintedAmount` tokens and send it to `target`\n', '        * @param target Address to receive the tokens\n', '        * @param mintedAmount the amount of tokens it will receive\n', '        */\n', '    function mint(address target, uint256 mintedAmount) public onlyMintingOwner {\n', '        require(target != address(0), "ERC20: mint to the zero address");\n', '        \n', '        _beforeTokenTransfer(address(0), target, mintedAmount);\n', '         \n', '        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\n', '        _totalSupply = _totalSupply.add(mintedAmount);\n', '        emit Transfer(address(0), target, mintedAmount);\n', '    }\n', '\n', '    /**\n', '        * Owner can transfer tokens from contract to owner address\n', '        */\n', '\n', '    function manualWithdrawTokens(uint256 tokenAmount) public onlyOwner {\n', '        // no need for overflow checking as that will be done in transfer function\n', '        _transfer(address(this), owner, tokenAmount);\n', '    }\n', '\n', '    /**\n', '        * Owner can transfer Ether from contract to owner address\n', '        */    \n', '\n', '    function manualWithdrawEther() public onlyOwner {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '    /** \n', '        * @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '        * @param target Address to be frozen\n', '        * @param freeze either to freeze it or not\n', '        */\n', '    function freezeAccount(address target, bool freeze) public onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenAccounts(target, freeze);\n', '    }\n', '    \n', '    /**\n', '        * Change safeguard status on or off\n', '        *\n', '        * When safeguard is true, then all the non-owner functions will stop working.\n', '        * When safeguard is false, then all the functions will resume working back again!\n', '        */\n', '    function changeSafeguardStatus() public onlyOwner{\n', '        if (safeguard == false){\n', '            safeguard = true;\n', '        }\n', '        else{\n', '            safeguard = false;\n', '        }\n', '    }\n', '}']