['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-04\n', '*/\n', '\n', 'pragma solidity ^0.4.26;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Mathematical functions to check for overflows\n', ' */\n', 'contract SafeMath {\n', '\tfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\tuint256 c = a - b;\n', '\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', 'contract TetherToken is SafeMath {\n', '\t// Public variables of the token\n', '\tstring public name = "Tether USD";\t\t\t\t\t\t\t\t\t// Token name\n', '\tstring public symbol = "USDT";\t\t\t\t\t\t\t\t\t\t// Token symbol\n', '\tuint8 public decimals = 6;\t\t\t\t\t\t\t\t\t\t\t// Token amount of decimals\n', '\tuint256 public totalSupply = 24416147047969263;\t\t\t\t\t\t// Token supply\n', '\taddress public Tether = this;\t\t\t\t\t\t\t\t\t\t// Token address\n', '\n', '\t// Creates array with balances\n', '\tmapping (address => uint256) public balances;\n', '\tmapping (address => mapping (address => uint256)) public allowances;\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * @dev Constructor function - Deploy the contract\n', '\t */\n', '\tconstructor() public {\n', '\t\t// Give the creator all initial tokens\n', '\t\tbalances[msg.sender] = totalSupply;\n', '\t}\n', '\n', '\t/**\n', '\t * @param _owner The address from which the balance will be retrieved\n', '\t * @return The balance\n', '\t */\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Allows `_spender` to spend no more than `_value` tokens in msg.sender behalf\n', '\t * @param _owner The address of the account owning tokens\n', '\t * @param _spender The address of the account able to transfer the tokens\n', '\t * @return Amount of remaining tokens allowed to spent\n', '\t */\t\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '\t\treturn allowances[_owner][_spender];\n', '\t}\n', '\n', '\t/**\n', '\t * @notice send `_value` token to `_to` from `msg.sender`\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount of token to be transferred\n', '\t * @return Whether the transfer was successful or not\n', '\t */\t\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n', '\t\t// Prevent transfer to 0x0 (empty) address, use burn() instead\n', '\t\trequire(_to != 0x0);\n', '\n', '\t\t// Prevent empty transactions\n', '\t\trequire(_value > 0);\n', '\n', '\t\t// Check if sender has enough\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\n', '\t\t// Subtract the amount from the sender\n', '\t\tbalances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\n', '\t\t// Add the same amount to the recipient\n', '\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\n', '\t\t// Generate the public transfer event and return success\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount of token to be transferred\n', '\t * @return Whether the transfer was successful or not\n', '\t */\t\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t\t// Prevent transfer to 0x0 (empty) address\n', '\t\trequire(_to != 0x0);\n', '\n', '\t\t// Prevent empty transactions\n', '\t\trequire(_value > 0);\n', '\n', '\t\t// Check if sender is allowed to spend the amount\n', '\t\trequire(allowances[_from][msg.sender] >= _value);\n', '\n', '\t\t// Check if token owner has enough\n', '\t\trequire(balances[_from] >= _value);\n', '\n', '\t\t// Subtract the amount from the sender\n', '\t\tallowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\n', '\n', '\t\t// Subtract the amount from the token owner\n', '\t\tbalances[_from] = safeSub(balances[_from], _value);\n', '\n', '\t\t// Add the same amount to the recipient\n', '\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\n', '\t\t// Generate the public transfer event and return success\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '\t * @param _spender The address of the account able to transfer the tokens\n', '\t * @param _value The amount of tokens to be approved for transfer\n', '\t * @return Whether the approval was successful or not\n', '\t */\t\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\t// The amount has to be bigger or equal to 0\n', '\t\trequire(_value >= 0);\n', '\n', '\t\tallowances[msg.sender][_spender] = _value;\n', '\n', '\t\t// Generate the public approval event and return success\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Remove `_value` tokens from the system irreversibly\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t\t// Check if value is less than 0\n', '\t\trequire(_value > 0);\n', '\n', '\t\t// Check if the owner has enough tokens\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\n', '\t\t// Subtract the value from the owner\n', '\t\tbalances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\n', '\t\t// Subtract the value from the Total Balance\n', '\t\ttotalSupply = safeSub(totalSupply, _value);\n', '\n', '\t\t// Generate the public burn event and return success\n', '\t\temit Burn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Public events on the blockchain to notify clients\n', '\tevent Transfer(address indexed _owner, address indexed _to, uint256 _value);\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\tevent Burn(address indexed _owner, uint256 _value);\n', '}']