['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '  function initialize() external;\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address account) external view returns (uint);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint);\n', '  function approve(address spender, uint amount) external returns (bool);\n', '  function mint(address account, uint amount) external;\n', '  function burn(address account, uint amount) external;\n', '  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() {\n', '    owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), owner);\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == owner;\n', '  }\n', '\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(owner, address(0));\n', '    owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20 is Ownable {\n', '\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '  mapping (address => uint) public balanceOf;\n', '  mapping (address => mapping (address => uint)) public allowance;\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '  uint public totalSupply;\n', '\n', '  constructor(\n', '    string memory _name,\n', '    string memory _symbol,\n', '    uint8 _decimals\n', '  ) {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '    require(decimals > 0, "decimals");\n', '  }\n', '\n', '  function transfer(address _recipient, uint _amount) public returns (bool) {\n', '    _transfer(msg.sender, _recipient, _amount);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint _amount) public returns (bool) {\n', '    _approve(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _sender, address _recipient, uint _amount) public returns (bool) {\n', '    require(allowance[_sender][msg.sender] >= _amount, "ERC20: insufficient approval");\n', '    _transfer(_sender, _recipient, _amount);\n', '    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);\n', '    return true;\n', '  }\n', '\n', '  function _transfer(address _sender, address _recipient, uint _amount) internal {\n', '    require(_sender != address(0), "ERC20: transfer from the zero address");\n', '    require(_recipient != address(0), "ERC20: transfer to the zero address");\n', '    require(balanceOf[_sender] >= _amount, "ERC20: insufficient funds");\n', '\n', '    balanceOf[_sender] -= _amount;\n', '    balanceOf[_recipient] += _amount;\n', '    emit Transfer(_sender, _recipient, _amount);\n', '  }\n', '\n', '  function mint(address _account, uint _amount) public onlyOwner {\n', '    _mint(_account, _amount);\n', '  }\n', '\n', '  function burn(address _account, uint _amount) public onlyOwner {\n', '    _burn(_account, _amount);\n', '  }\n', '\n', '  function _mint(address _account, uint _amount) internal {\n', '    require(_account != address(0), "ERC20: mint to the zero address");\n', '\n', '    totalSupply += _amount;\n', '    balanceOf[_account] += _amount;\n', '    emit Transfer(address(0), _account, _amount);\n', '  }\n', '\n', '  function _burn(address _account, uint _amount) internal {\n', '    require(_account != address(0), "ERC20: burn from the zero address");\n', '\n', '    balanceOf[_account] -= _amount;\n', '    totalSupply -= _amount;\n', '    emit Transfer(_account, address(0), _amount);\n', '  }\n', '\n', '  function _approve(address _owner, address _spender, uint _amount) internal {\n', '    require(_owner != address(0), "ERC20: approve from the zero address");\n', '    require(_spender != address(0), "ERC20: approve to the zero address");\n', '\n', '    allowance[_owner][_spender] = _amount;\n', '    emit Approval(_owner, _spender, _amount);\n', '  }\n', '}\n', '\n', 'contract AutoStaking is ERC20("xWILD", "xWILD", 18) {\n', '\n', '  IERC20 public wild;\n', '\n', '  event Deposit(uint wildAmount, uint shareAmount);\n', '  event Withdraw(uint wildAmount, uint shareAmount);\n', '\n', '  constructor(IERC20 _wild) {\n', '    wild = _wild;\n', '  }\n', '\n', '  function deposit(uint _wildAmount) public {\n', '    uint poolWILD = wild.balanceOf(address(this));\n', '    uint shareAmount;\n', '\n', '    if (totalSupply == 0 || poolWILD == 0) {\n', '      _mint(msg.sender, _wildAmount);\n', '    } else {\n', '      shareAmount = _wildAmount * totalSupply / poolWILD;\n', '      _mint(msg.sender, shareAmount);\n', '    }\n', '\n', '    wild.transferFrom(msg.sender, address(this), _wildAmount);\n', '\n', '    emit Deposit(_wildAmount, shareAmount);\n', '  }\n', '\n', '  function withdraw(uint _share) public {\n', '    uint wildAmount = _share * wild.balanceOf(address(this)) / totalSupply;\n', '    _burn(msg.sender, _share);\n', '    wild.transfer(msg.sender, wildAmount);\n', '\n', '    emit Deposit(wildAmount, _share);\n', '  }\n', '}']