['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-20\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library SafeMath\n', '{\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract OwnerHelper\n', '{\n', '    address public owner;\n', '    address public manager;\n', '\n', '    event ChangeOwner(address indexed _from, address indexed _to);\n', '    event ChangeManager(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public\n', '    {\n', '        require(_to != owner);\n', '        require(_to != manager);\n', '        require(_to != address(0x0));\n', '\n', '        address from = owner;\n', '        owner = _to;\n', '\n', '        emit ChangeOwner(from, _to);\n', '    }\n', '\n', '    function transferManager(address _to) onlyOwner public\n', '    {\n', '        require(_to != owner);\n', '        require(_to != manager);\n', '        require(_to != address(0x0));\n', '\n', '        address from = manager;\n', '        manager = _to;\n', '\n', '        emit ChangeManager(from, _to);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Interface\n', '{\n', '    event Transfer( address indexed _from, address indexed _to, uint _value);\n', '    event Approval( address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function totalSupply() view virtual public returns (uint _supply);\n', '    function balanceOf( address _who ) virtual public view returns (uint _value);\n', '    function transfer( address _to, uint _value) virtual public returns (bool _success);\n', '    function approve( address _spender, uint _value ) virtual public returns (bool _success);\n', '    function allowance( address _owner, address _spender ) virtual public view returns (uint _allowance);\n', '    function transferFrom( address _from, address _to, uint _value) virtual public returns (bool _success);\n', '}\n', '\n', 'contract FAVE is ERC20Interface, OwnerHelper\n', '{\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    uint public decimals;\n', '    string public symbol;\n', '\n', '    uint constant private E18 = 1000000000000000000;\n', '    uint constant private month = 2592000;\n', '\n', '    // Total                                  10,000,000,000\n', '    uint constant public maxTotalSupply     = 1000000000 * E18;\n', '    // Sale                                   100,000,000 (10%)\n', '    uint constant public maxSaleSupply      = 100000000 * E18;\n', '    // Marketing                              300,000,000 (30%)\n', '    uint constant public maxMktSupply       = 300000000 * E18;\n', '    // Development                            200,000,000 (20%)\n', '    uint constant public maxDevSupply       = 200000000 * E18;\n', '    // EcoSystem                              150,000,000 (15%)\n', '    uint constant public maxEcoSupply       = 150000000 * E18;\n', '    // Team                                   100,000,000 (10%)\n', '    uint constant public maxTeamSupply      = 100000000 * E18;\n', '    // Advisors                               50,000,000 (5%)\n', '    uint constant public maxAdvisorSupply   = 50000000 * E18;\n', '    // Reserve                                100,000,000 (10%)\n', '    uint constant public maxReserveSupply   = 100000000 * E18;\n', '\n', '    // Lock\n', '    uint constant public teamVestingSupply = 10000000 * E18;\n', '    uint constant public teamVestingLockDate =  12 * month;\n', '    uint constant public teamVestingTime = 10;\n', '\n', '    uint constant public advisorVestingSupply = 12500000 * E18;\n', '    uint constant public advisorVestingLockDate = 12 * month;\n', '    uint constant public advisorVestingTime = 4;\n', '\n', '    uint public totalTokenSupply;\n', '    uint public tokenIssuedSale;\n', '    uint public tokenIssuedMkt;\n', '    uint public tokenIssuedDev;\n', '    uint public tokenIssuedEco;\n', '    uint public tokenIssuedTeam;\n', '    uint public tokenIssuedAdv;\n', '    uint public tokenIssuedRsv;\n', '\n', '    uint public burnTokenSupply;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => mapping ( address => uint )) public approvals;\n', '\n', '    mapping (uint => uint) public tmVestingTimer;\n', '    mapping (uint => uint) public tmVestingBalances;\n', '    mapping (uint => uint) public advVestingTimer;\n', '    mapping (uint => uint) public advVestingBalances;\n', '\n', '    bool public tokenLock = true;\n', '    bool public saleTime = true;\n', '    uint public endSaleTime = 0;\n', '\n', '    event SaleIssue(address indexed _to, uint _tokens);\n', '    event DevIssue(address indexed _to, uint _tokens);\n', '    event EcoIssue(address indexed _to, uint _tokens);\n', '    event MktIssue(address indexed _to, uint _tokens);\n', '    event RsvIssue(address indexed _to, uint _tokens);\n', '    event TeamIssue(address indexed _to, uint _tokens);\n', '    event AdvIssue(address indexed _to, uint _tokens);\n', '\n', '    event Burn(address indexed _from, uint _tokens);\n', '\n', '    event TokenUnlock(address indexed _to, uint _tokens);\n', '    event EndSale(uint _date);\n', '\n', '    constructor()\n', '    {\n', '        name        = "FAVE";\n', '        decimals    = 18;\n', '        symbol      = "FAVE";\n', '\n', '        totalTokenSupply = maxTotalSupply;\n', '        balances[owner] = totalTokenSupply;\n', '\n', '        tokenIssuedSale     = 0;\n', '        tokenIssuedDev      = 0;\n', '        tokenIssuedEco      = 0;\n', '        tokenIssuedMkt      = 0;\n', '        tokenIssuedRsv      = 0;\n', '        tokenIssuedTeam     = 0;\n', '        tokenIssuedAdv      = 0;\n', '\n', '        burnTokenSupply     = 0;\n', '\n', '        require(maxTeamSupply == teamVestingSupply.mul(teamVestingTime));\n', '        require(maxAdvisorSupply == advisorVestingSupply.mul(advisorVestingTime));\n', '\n', '        require(maxTotalSupply == maxSaleSupply + maxDevSupply + maxEcoSupply + maxMktSupply + maxReserveSupply + maxTeamSupply + maxAdvisorSupply);\n', '    }\n', '\n', '    function totalSupply() view override public returns (uint)\n', '    {\n', '        return totalTokenSupply;\n', '    }\n', '\n', '    function balanceOf(address _who) view override public returns (uint)\n', '    {\n', '        return balances[_who];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        approvals[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) view override public returns (uint)\n', '    {\n', '        return approvals[_owner][_spender];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[_from] >= _value);\n', '        require(approvals[_from][msg.sender] >= _value);\n', '\n', '        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to]  = balances[_to].add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function saleIssue(address _to) onlyOwner public\n', '    {\n', '        require(tokenIssuedSale == 0);\n', '        uint tokens = maxSaleSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '\n', '        tokenIssuedSale = tokenIssuedSale.add(tokens);\n', '\n', '        emit SaleIssue(_to, tokens);\n', '    }\n', '\n', '    function devIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedDev == 0);\n', '\n', '        uint tokens = maxDevSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '\n', '        tokenIssuedDev = tokenIssuedDev.add(tokens);\n', '\n', '        emit DevIssue(_to, tokens);\n', '    }\n', '\n', '    function ecoIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedEco == 0);\n', '\n', '        uint tokens = maxEcoSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '\n', '        tokenIssuedEco = tokenIssuedEco.add(tokens);\n', '\n', '        emit EcoIssue(_to, tokens);\n', '    }\n', '\n', '    function mktIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedMkt == 0);\n', '\n', '        uint tokens = maxMktSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '\n', '        tokenIssuedMkt = tokenIssuedMkt.add(tokens);\n', '\n', '        emit MktIssue(_to, tokens);\n', '    }\n', '\n', '    function rsvIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedRsv == 0);\n', '\n', '        uint tokens = maxReserveSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '\n', '        tokenIssuedRsv = tokenIssuedRsv.add(tokens);\n', '\n', '        emit RsvIssue(_to, tokens);\n', '    }\n', '\n', '    function teamIssue(address _to, uint _time /* 몇 번째 지급인지 */) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require( _time < teamVestingTime);\n', '\n', '        uint nowTime = block.timestamp;\n', '        require( nowTime > tmVestingTimer[_time] );\n', '\n', '        uint tokens = teamVestingSupply;\n', '\n', '        require(tokens == tmVestingBalances[_time]);\n', '        require(maxTeamSupply >= tokenIssuedTeam.add(tokens));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '        tmVestingBalances[_time] = 0;\n', '\n', '        tokenIssuedTeam = tokenIssuedTeam.add(tokens);\n', '\n', '        emit TeamIssue(_to, tokens);\n', '    }\n', '\n', '    function advisorIssue(address _to, uint _time) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require( _time < advisorVestingTime);\n', '\n', '        uint nowTime = block.timestamp;\n', '        require( nowTime > advVestingTimer[_time] );\n', '\n', '        uint tokens = advisorVestingSupply;\n', '\n', '        require(tokens == advVestingBalances[_time]);\n', '        require(maxAdvisorSupply >= tokenIssuedAdv.add(tokens));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        balances[_to] = balances[_to].add(tokens);\n', '        advVestingBalances[_time] = 0;\n', '\n', '        tokenIssuedAdv = tokenIssuedAdv.add(tokens);\n', '\n', '        emit AdvIssue(_to, tokens);\n', '    }\n', '\n', '    function isTransferable() private view returns (bool)\n', '    {\n', '        if(tokenLock == false)\n', '        {\n', '            return true;\n', '        }\n', '        else if(msg.sender == owner)\n', '        {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function setTokenUnlock() onlyManager public\n', '    {\n', '        require(tokenLock == true);\n', '        require(saleTime == false);\n', '\n', '        tokenLock = false;\n', '    }\n', '\n', '    function setTokenLock() onlyManager public\n', '    {\n', '        require(tokenLock == false);\n', '\n', '        tokenLock = true;\n', '    }\n', '\n', '    function endSale() onlyOwner public\n', '    {\n', '        require(saleTime == true);\n', '        require(maxSaleSupply == tokenIssuedSale);\n', '\n', '        saleTime = false;\n', '\n', '        uint nowTime = block.timestamp;\n', '        endSaleTime = nowTime;\n', '\n', '        for(uint i = 0; i < teamVestingTime; i++)\n', '        {\n', '            tmVestingTimer[i] = endSaleTime + teamVestingLockDate + (i * month);\n', '            tmVestingBalances[i] = teamVestingSupply;\n', '        }\n', '\n', '        for(uint i = 0; i < advisorVestingTime; i++)\n', '        {\n', '            advVestingTimer[i] = endSaleTime + advisorVestingLockDate + (3 * i * month);\n', '            advVestingBalances[i] = advisorVestingSupply;\n', '        }\n', '\n', '        emit EndSale(endSaleTime);\n', '    }\n', '\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) onlyOwner public returns (bool success)\n', '    {\n', '        return ERC20Interface(tokenAddress).transfer(manager, tokens);\n', '    }\n', '\n', '    function burnToken(uint _value) onlyManager public\n', '    {\n', '        uint tokens = _value * E18;\n', '\n', '        require(balances[msg.sender] >= tokens);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\n', '        burnTokenSupply = burnTokenSupply.add(tokens);\n', '        totalTokenSupply = totalTokenSupply.sub(tokens);\n', '\n', '        emit Burn(msg.sender, tokens);\n', '    }\n', '\n', '    function close() onlyOwner public\n', '    {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '}']