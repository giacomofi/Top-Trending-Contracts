['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-29\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'contract GDT {\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    string public constant name = "GDT";\n', '    string public constant symbol = "GDT";\n', '    uint8 public constant decimals = 8;\n', '    address private immutable initial_address;\n', '    uint256 public totalSupply = 400_000_000 * (uint256(10) ** decimals);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    \n', '    modifier validAddress(address addr) {\n', '        require(addr != address(0), "Address cannot be 0x0");\n', '        require(addr != address(this), "Address cannot be contract address");\n', '        _;\n', '    }\n', '\n', '    constructor(address manager) validAddress(manager) {\n', '        initial_address = manager;\n', '        balanceOf[manager] = totalSupply;\n', '        emit Transfer(address(0), manager, totalSupply);\n', '    }\n', '\n', '    function transfer(address to, uint256 value) external validAddress(to) returns (bool success) {\n', '        uint256 senderBalance = balanceOf[msg.sender];\n', '        require(senderBalance >= value, "ERC20: insufficient balance for transfer");\n', "        balanceOf[msg.sender] = senderBalance - value; // deduct from sender's balance\n", "        balanceOf[to] += value; // add to recipient's balance\n", '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 value)\n', '        public\n', '        validAddress(spender)\n', '        returns (bool success)\n', '    {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        external\n', '        validAddress(to)\n', '        returns (bool success)\n', '    {\n', '        uint256 balanceFrom = balanceOf[from];\n', '        uint256 allowanceSender = allowance[from][msg.sender];\n', '        require(value <= balanceFrom, "ERC20: insufficient balance for transferFrom");\n', '        require(value <= allowanceSender, "ERC20: unauthorized transferFrom");\n', '        balanceOf[from] = balanceFrom - value;\n', '        balanceOf[to] += value;\n', '        allowance[from][msg.sender] = allowanceSender - value;\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 amount)\n', '        external\n', '        returns (bool success)\n', '    {\n', "        require(msg.sender==initial_address,'ERC20: burn not authorized.');\n", '        uint256 accountBalance = balanceOf[msg.sender];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        balanceOf[msg.sender] = accountBalance - amount;\n', '        totalSupply -= amount;\n', '        emit Transfer(msg.sender, address(0), amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        external\n', '        validAddress(spender)\n', '        returns (bool)\n', '    {\n', '        approve(spender, allowance[msg.sender][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        external\n', '        validAddress(spender)\n', '        returns (bool)\n', '    {\n', '        uint256 currentAllowance = allowance[msg.sender][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        approve(spender, currentAllowance - subtractedValue);\n', '        return true;\n', '    }\n', '}']