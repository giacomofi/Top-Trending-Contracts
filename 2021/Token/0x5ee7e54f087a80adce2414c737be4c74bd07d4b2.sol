['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-12\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-12\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    \n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface ICourtStake{\n', '\n', '    function lockedStake(uint256 amount, address beneficiar,  uint256 StartReleasingTime, uint256 batchCount, uint256 batchPeriod) external;\n', '\n', '}\n', '\n', '\n', 'contract HT_Claim is ICourtStake{\n', '    using SafeMath for uint256;\n', '    \n', '    \n', '    IERC20 public courtToken = IERC20(0x0538A9b4f4dcB0CB01A7fA34e17C0AC947c22553); \n', '    uint8 public courtDecimals = 18;\n', '    \n', '    IERC20 public usdtToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n', '\n', '    uint256 public usdtDecimals = 6;\n', '    \n', '\n', '    uint256 public numerator = 100;\n', '    uint256 public denominator = 1; // usdt is 6 decimals so 1 usdt = 1e12 other \n', '    \n', '    \n', '    mapping(address => bool) hasPermissionToCallLockedStake;\n', '    address public owner;\n', '    \n', '    constructor() public{\n', '        owner = msg.sender ;\n', '    }\n', '    \n', '    function changeParameters(address courtAddress, address usdtAddress, uint256 decimals,uint256 _numerator, uint256 _denominator) public{\n', '        require(msg.sender == owner, "only owner can change Numerator and Denominator");\n', '        require(denominator != 0, "denominator can not be 0"); //can not div by zero\n', '        courtToken = IERC20(courtAddress);\n', '        usdtToken = IERC20(usdtAddress);\n', '        usdtDecimals = decimals;\n', '        numerator = _numerator;\n', '        denominator = _denominator;\n', '    }\n', '    \n', '    \n', '    function lockedStake(uint256 courtAmount, address beneficiar,  uint256, uint256, uint256) public{\n', '        require(hasPermissionToCallLockedStake[msg.sender] == true, "caller has no permission to call courtAmount");\n', '        \n', '        courtToken.transferFrom(msg.sender,address(this), courtAmount); // msg sender here is the HTStake contracte\n', '        \n', '        uint256 usdtAmount = getRequiredAmount(courtAmount);\n', '        \n', '        usdtToken.transferFrom(beneficiar,address(this),usdtAmount); // user need to approve this contract \n', '        usdtToken.transfer(owner,usdtAmount);\n', '        \n', '        courtToken.transfer(beneficiar,courtAmount); //beneficiar the one who claim court\n', '    }\n', '    \n', '    function getRequiredAmount(uint256 amount) public view returns(uint256){\n', '        return amount.mul(numerator).div(denominator.mul(10 ** (courtDecimals - usdtDecimals) ));\n', '    }\n', '    \n', '    \n', '    function setLockedStakePermission(address account, bool permissionFlag) public{\n', '        require(msg.sender == owner, "only owner can change Numerator and Denominator");\n', '        hasPermissionToCallLockedStake[account] = permissionFlag;\n', '    }\n', '    \n', '}']