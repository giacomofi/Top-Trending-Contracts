['pragma solidity ^0.4.23;\n', '\n', "import './erc20interface.sol';\n", "import './owned.sol';\n", '\n', 'contract ERC20DMEC is ERC20Interface,owned{\n', '     mapping(address => uint256) public balanceOf;\n', '     mapping(address => mapping(address => uint256)) allowed;\n', '    mapping(address => bool) public frozenAccount;\n', '    event AddSupply(uint amount);\n', '    event FrozenFunds(address target,bool frozen);\n', '    event Burn(address target,uint amount);\n', '     \n', '     constructor () public{\n', '             name = "Digital Medical Chain";\n', '             symbol = "DMEC";\n', '             decimals = 18;\n', '             totalSupply = 100000000000000000000000000;\n', '             balanceOf[msg.sender] = totalSupply;\n', '     }\n', '    \n', '    function mine(address target,uint amount) public onlyowner{\n', '        \n', '        totalSupply += amount;\n', '        balanceOf[target] += amount;\n', '        emit AddSupply(amount);\n', '        emit Transfer(0,target,amount);\n', '    }\n', '    function freezeAccount(address target,bool freeze) public onlyowner{\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target,freeze);\n', '        \n', '    }\n', '    \n', '    function transfer(address _to,uint256 _value) returns (bool success){\n', '             require(_to != address(0));\n', '             require(!frozenAccount[msg.sender]);\n', '             \n', '             require(balanceOf[msg.sender] >= _value);\n', '             require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '             balanceOf[msg.sender] -= _value;\n', '             balanceOf[_to] += _value;\n', '             emit Transfer(msg.sender,_to,_value);\n', '             return true;\n', '        \n', '    }\n', '    function transferFrom(address _from,address _to,uint256 _value) returns(bool success){\n', '        \n', '             require(_to != address(0));\n', '             \n', '             require(!frozenAccount[_from]);\n', '             \n', '             require(allowed[_from][msg.sender] >= _value);\n', '             require(balanceOf[_from] >= _value);\n', '             require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '             balanceOf[_from] -= _value;\n', '             balanceOf[_to] += _value;\n', '             allowed[_from][msg.sender] -= _value;\n', '             emit Transfer(msg.sender,_to,_value);\n', '             return true;\n', '        \n', '        \n', '    }\n', '    function burn(uint256 _value) public returns(bool success){\n', '             require(balanceOf[msg.sender] >= _value);\n', '             totalSupply -= _value;\n', '             balanceOf[msg.sender] -= _value;\n', '             emit Burn(msg.sender,_value);\n', '             return true;\n', '             \n', '    }\n', '    function burnFrom(address _from,uint256 _value) public returns(bool success){\n', '        \n', '             require(balanceOf[_from] >= _value);\n', '             require(allowed[_from][msg.sender] >= _value);\n', '             \n', '             totalSupply -= _value;\n', '             balanceOf[msg.sender] -= _value;\n', '             allowed[_from][msg.sender] -= _value;\n', '             \n', '             emit Burn(msg.sender,_value);\n', '             return true;\n', '        \n', '    }\n', '    function approve(address _spender,uint256 _value) returns (bool success){\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender,_spender,_value);\n', '        return true;\n', '        \n', '    }\n', '    function allowance(address _owner,address _spender) view returns(uint256 remaining){\n', '        \n', '        return allowed[_owner][_spender];\n', '        \n', '    }\n', '    \n', '}']