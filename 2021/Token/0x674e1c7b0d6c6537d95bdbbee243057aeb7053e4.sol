['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-10\n', '*/\n', '\n', '/**\n', 'ARIRANG\n', '*/\n', '\n', 'pragma solidity 0.4.11;\n', '\n', 'contract SafeMath {\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  // mitigate short address attack\n', '  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '  // TODO: doublecheck implication of >= compared to ==\n', '  modifier onlyPayloadSize(uint numWords) {\n', '     assert(msg.data.length >= numWords * 32 + 4);\n', '     _;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Token { // ERC20 standard\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    // TODO: update tests to expect throw\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value && _value > 0);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // TODO: update tests to expect throw\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // To change the approve amount you first have to reduce the addresses'\n", "    //  allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _oldValue);\n', '        allowed[msg.sender][_spender] = _newValue;\n', '        Approval(msg.sender, _spender, _newValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '}\n', '\n', '\n', '/*------------------------------------\n', 'ARIRANG\n', ' SYMBOL : ARI\n', ' decimal : 8 \n', ' issue amount :  1,000,000,000 \n', '--------------------------------------*/\n', '\n', 'contract ARIRANG  is StandardToken { \n', '\n', '    /* Public variables of the token */\n', '\n', '    string public name;                   // \n', '    uint8 public decimals;                // \n', '    string public symbol;                 // \n', "    string public version = 'C1.0';  \n", '    uint256 public unitsOneEthCanBuy;     \n', '    uint256 public totalEthInWei;         \n', '    address public fundsWallet;          \n', '\n', '   \n', '\n', '    function ARIRANG() {                        //** funtion name **/\n', '        balances[msg.sender] = 100000000000000000;          \n', '        totalSupply = 100000000000000000;              \n', '        name = "ARIRANG";                                 \n', '        decimals = 8 ;                                  \n', '        symbol = "ARI";                               \n', '        unitsOneEthCanBuy = 10;                        \n', '        fundsWallet = msg.sender;                     \n', '    }\n', '\n', '\n', '    function() payable{\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        require(balances[fundsWallet] >= amount);\n', '\n', '        balances[fundsWallet] = balances[fundsWallet] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        //Transfer ether to fundsWallet\n', '        fundsWallet.transfer(msg.value);                               \n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }\n', '        return true;\n', '    }\n', '}']