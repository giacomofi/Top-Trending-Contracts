['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.2;\n', '\n', 'import "./Pausable.sol";\n', 'import "./BlackList.sol";\n', 'import "./Votable.sol";\n', 'import "./UpgradedStandardToken.sol";\n', 'import "./ERC20WithFeeAndRouter.sol";\n', '\n', 'contract CNHCToken is ERC20WithFeeAndRouter, BlackList, Votable, Pausable {\n', '\n', '    address public upgradedAddress;\n', '\n', '    bool public deprecated;\n', '\n', '    constructor(uint256 _initialSupply, uint8 _decimals) public ERC20WithFeeAndRouter("CNHC Token","CNHC") {\n', '        _setupDecimals(_decimals);\n', '        _mint(_msgSender(), _initialSupply);\n', '    }\n', '\n', '    event DestroyedBlackFunds(address indexed blackListedUser, uint256 balance);\n', '\n', '    event Deprecate(address newAddress);\n', '\n', '    // functions users can call\n', '    // make compatible if deprecated\n', '    function balanceOf(address account) public override view returns (uint256) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).balanceOf(account);\n', '        } else {\n', '            return super.balanceOf(account);\n', '        }\n', '    }\n', '\n', '    function totalSupply() public override view returns (uint256) {\n', '        if (deprecated) {\n', '            return IERC20(upgradedAddress).totalSupply();\n', '        } else {\n', '            return super.totalSupply();\n', '        }\n', '    }\n', '\n', '    function allowance(address owner, address spender) public override view returns (uint256 remaining) {\n', '        if (deprecated) {\n', '            return IERC20(upgradedAddress).allowance(owner, spender);\n', '        } else {\n', '            return super.allowance(owner, spender);\n', '        }\n', '    }\n', '\n', '    // Allow checks of balance at time of deprecation\n', '    function oldBalanceOf(address account) public view returns (uint256) {\n', '        require(deprecated, "CNHCToken: contract NOT deprecated");\n', '        return super.balanceOf(account);\n', '    }\n', '\n', '    // normal functions\n', '    function transfer(address recipient, uint256 amount) public override isNotBlackUser(_msgSender()) returns (bool) {\n', '        require(!isBlackListUser(recipient), "BlackList: recipient address is in blacklist");\n', '\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferByLegacy(_msgSender(), recipient, amount);\n', '        } else {\n', '            return super.transfer(recipient, amount);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override isNotBlackUser(_msgSender()) returns (bool) {\n', '        require(!isBlackListUser(sender), "BlackList: sender address is in blacklist");\n', '        require(!isBlackListUser(recipient), "BlackList: recipient address is in blacklist");\n', '\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(_msgSender(), sender, recipient, amount);\n', '        } else {\n', '            return super.transferFrom(sender, recipient, amount);\n', '        }\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override isNotBlackUser(_msgSender()) returns (bool) {\n', '        require(!isBlackListUser(spender), "BlackList: spender address is in blacklist");\n', '\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).approveByLegacy(_msgSender(), spender, amount);\n', '        } else {\n', '            return super.approve(spender, amount);\n', '        }\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public override isNotBlackUser(_msgSender()) returns (bool) {\n', '        require(!isBlackListUser(spender), "BlackList: spender address is in blacklist");\n', '\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).increaseApprovalByLegacy(_msgSender(), spender, addedValue);\n', '        } else {\n', '            return super.increaseAllowance(spender, addedValue);\n', '        }\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public override isNotBlackUser(_msgSender()) returns (bool) {\n', '        require(!isBlackListUser(spender), "BlackList: spender address is in blacklist");\n', '\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).decreaseApprovalByLegacy(_msgSender(), spender, subtractedValue);\n', '        } else {\n', '            return super.decreaseAllowance(spender, subtractedValue);\n', '        }\n', '    }\n', '\n', '    function burn(uint256 amount) public {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        super._burn(_msgSender(), amount);\n', '    }\n', '\n', '    // functions only owner can call\n', '    // open proposals\n', '    function openMintProposal(address _account, uint256 _amount) external onlyOwner{\n', '        _openProposal(abi.encodeWithSignature("mint(address,uint256)", _account, _amount));\n', '    }\n', '\n', '    function openDestroyBlackFundsProposal(address _user) external onlyOwner{\n', '        _openProposal(abi.encodeWithSignature("destroyBlackFunds(address)", _user));\n', '    }\n', '\n', '    // onlySelf: mint & burn\n', '    function mint(address _account, uint256 _amount) public onlySelf {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        super._mint(_account, _amount);\n', '    }\n', '\n', '    function destroyBlackFunds(address _user) public onlySelf {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        require(isBlackListUser(_user), "CNHCToken: only fund in blacklist address can be destroy");\n', '        uint256 dirtyFunds = balanceOf(_user);\n', '        super._burn(_user, dirtyFunds);\n', '        emit DestroyedBlackFunds(_user, dirtyFunds);\n', '    }\n', '\n', '    // pause\n', '    function pause() public onlyOwner {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        super._pause();\n', '    }\n', '\n', '    function unpause() public onlyOwner {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        super._unpause();\n', '    }\n', '\n', '    // deprecate\n', '    function deprecate(address _upgradedAddress) public onlyOwner {\n', '        require(!deprecated, "CNHCToken: contract was deprecated");\n', '        require(_upgradedAddress != address(0));\n', '        deprecated = true;\n', '        upgradedAddress = _upgradedAddress;\n', '        emit Deprecate(_upgradedAddress);\n', '    }\n', '\n', '    // hook before _transfer()/_mint()/_burn()\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, amount);\n', '\n', '        require(!paused(), "Pausable: token transfer while paused");\n', '    }\n', '\n', '    function transferByBatch(address[] memory _recipients, uint256[] memory _amounts) public isNotBlackUser(_msgSender()) {\n', '        if (deprecated) {\n', '            for(uint256 i=0; i<_recipients.length; i++){\n', '                if(!isBlackListUser(_recipients[i])){\n', '                    return UpgradedStandardToken(upgradedAddress).transferByBatchEachByLegacy(_recipients[i], _amounts[i]);\n', '                }\n', '            }\n', '        } else {\n', '            for(uint256 i=0; i<_recipients.length; i++){\n', '                if(!isBlackListUser(_recipients[i])){\n', '                    return super.transferByBatchEach(_recipients[i], _amounts[i]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferFromByBatch(address[] memory _senders, address[] memory _recipients, uint256[] memory _amounts) public isNotBlackUser(_msgSender()){\n', '        if (deprecated) {\n', '            for(uint256 i=0; i<_senders.length; i++){\n', '                if(!isBlackListUser(_senders[i]) && !isBlackListUser(_recipients[i])){\n', '                    UpgradedStandardToken(upgradedAddress).transferFromByBatchEachByLegacy(_msgSender(), _senders[i], _recipients[i], _amounts[i]);\n', '                }\n', '            }\n', '        } else {\n', '            for(uint256 i=0; i<_senders.length; i++){\n', '                if(!isBlackListUser(_senders[i]) && !isBlackListUser(_recipients[i])){\n', '                    super.transferFromByBatchEach(_senders[i], _recipients[i], _amounts[i]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferFromByRouter(address[] memory _from,address[] memory _to,uint256[] memory _value,bytes32[] memory _r,bytes32[] memory _s,uint8[] memory _v) public onlyRouter{\n', '        if (deprecated) {\n', '            for(uint256 i=0; i<_from.length; i++){\n', '                if(!isBlackListUser(_from[i]) && !isBlackListUser(_to[i])){\n', '                    UpgradedStandardToken(upgradedAddress).transferFromByRouterEachByLegacy(_msgSender(), _from[i], _to[i], _value[i],_r[i],_s[i],_v[i]);\n', '                }\n', '            }\n', '        } else {\n', '            for(uint256 i=0; i<_from.length; i++){\n', '                if(!isBlackListUser(_from[i]) && !isBlackListUser(_to[i])){\n', '                    super.transferFromByRouterEach(_from[i], _to[i], _value[i],_r[i],_s[i],_v[i]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '}']