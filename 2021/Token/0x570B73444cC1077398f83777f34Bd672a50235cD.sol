['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-14\n', '*/\n', '\n', 'pragma abicoder v2;\n', 'pragma solidity ^0.7.0;\n', '\n', 'contract BulkTokenMetadataV2 {\n', '  struct Token {\n', '    address token_address;\n', '    uint totalSupply;\n', '    uint decimals;\n', '    string symbol;\n', '    string name;\n', '  }\n', '  struct TotalSupply {\n', '    address token_address;\n', '    uint totalSupply;\n', '  }\n', '  struct Decimals {\n', '    address token_address;\n', '    uint decimals;\n', '  }\n', '  struct Symbol {\n', '    address token_address;\n', '    string symbol;\n', '  }\n', '  struct Name {\n', '    address token_address;\n', '    string name;\n', '  }\n', '\n', '  function getTokens(address[] calldata tokenAddresses) external view returns (Token[] memory tokens) {\n', '    tokens = new Token[](tokenAddresses.length);\n', '    \n', '    for(uint i = 0; i < tokenAddresses.length; i++) {\n', '      if(isAContract(tokenAddresses[i])) {\n', '        try this.getTokenInfo(tokenAddresses[i]) returns (Token memory token) {\n', '          tokens[i] = token;\n', '        } catch {\n', '          tokens[i] = Token(address(0), 0, 0, "", "");  \n', '        }\n', '      } else {\n', '        tokens[i] = Token(address(0), 0, 0, "", "");   \n', '      }\n', '    }\n', '    return tokens;\n', '  }\n', '  \n', '  function getTokensTotalSupply(address[] calldata tokenAddresses) external view returns (TotalSupply[] memory tokens) {\n', '    tokens = new TotalSupply[](tokenAddresses.length);\n', '    \n', '    for(uint i = 0; i < tokenAddresses.length; i++) {\n', '      if(isAContract(tokenAddresses[i])) {\n', '        try this.getTokenTotalSupply(tokenAddresses[i]) returns (TotalSupply memory token) {\n', '          tokens[i] = token;\n', '        } catch {\n', '          tokens[i] = TotalSupply(address(0), 0);  \n', '        }\n', '      } else {\n', '        tokens[i] = TotalSupply(address(0), 0);   \n', '      }\n', '    }\n', '    return tokens;\n', '  }\n', '  \n', '  function getTokensDecimals(address[] calldata tokenAddresses) external view returns (Decimals[] memory tokens) {\n', '    tokens = new Decimals[](tokenAddresses.length);\n', '    \n', '    for(uint i = 0; i < tokenAddresses.length; i++) {\n', '      if(isAContract(tokenAddresses[i])) {\n', '        try this.getTokenDecimals(tokenAddresses[i]) returns (Decimals memory token) {\n', '          tokens[i] = token;\n', '        } catch {\n', '          tokens[i] = Decimals(address(0), 0);  \n', '        }\n', '      } else {\n', '        tokens[i] = Decimals(address(0), 0);   \n', '      }\n', '    }\n', '    return tokens;\n', '  }\n', '  \n', '  function getTokensSymbol(address[] calldata tokenAddresses) external view returns (Symbol[] memory tokens) {\n', '    tokens = new Symbol[](tokenAddresses.length);\n', '    \n', '    for(uint i = 0; i < tokenAddresses.length; i++) {\n', '      if(isAContract(tokenAddresses[i])) {\n', '        try this.getTokenSymbol(tokenAddresses[i]) returns (Symbol memory token) {\n', '          tokens[i] = token;\n', '        } catch {\n', '          tokens[i] = Symbol(address(0), "");  \n', '        }\n', '      } else {\n', '        tokens[i] = Symbol(address(0), "");   \n', '      }\n', '    }\n', '    return tokens;\n', '  }\n', '  \n', '  function getTokensName(address[] calldata tokenAddresses) external view returns (Name[] memory tokens) {\n', '    tokens = new Name[](tokenAddresses.length);\n', '    \n', '    for(uint i = 0; i < tokenAddresses.length; i++) {\n', '      if(isAContract(tokenAddresses[i])) {\n', '        try this.getTokenName(tokenAddresses[i]) returns (Name memory token) {\n', '          tokens[i] = token;\n', '        } catch {\n', '          tokens[i] = Name(address(0), "");  \n', '        }\n', '      } else {\n', '        tokens[i] = Name(address(0), "");   \n', '      }\n', '    }\n', '    return tokens;\n', '  }\n', '  \n', '  function getTokenInfo(address tokenAddress) public view returns (Token memory token) {\n', '    token = Token(tokenAddress, ERC20(tokenAddress).totalSupply(), ERC20(tokenAddress).decimals(), ERC20(tokenAddress).symbol(), ERC20(tokenAddress).name());\n', '  }\n', '  \n', '  function getTokenTotalSupply(address tokenAddress) public view returns (TotalSupply memory token) {\n', '    token = TotalSupply(tokenAddress, ERC20(tokenAddress).totalSupply());\n', '  }\n', '  \n', '  function getTokenDecimals(address tokenAddress) public view returns (Decimals memory token) {\n', '    token = Decimals(tokenAddress, ERC20(tokenAddress).decimals());\n', '  }\n', '  \n', '  function getTokenSymbol(address tokenAddress) public view returns (Symbol memory token) {\n', '    token = Symbol(tokenAddress, ERC20(tokenAddress).symbol());\n', '  }\n', '  \n', '  function getTokenName(address tokenAddress) public view returns (Name memory token) {\n', '    token = Name(tokenAddress, ERC20(tokenAddress).name());\n', '  }\n', '    \n', "  // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\n", '  function isAContract(address contractAddr) internal view returns (bool) {\n', '    uint256 codeSize;\n', '    assembly { codeSize := extcodesize(contractAddr) } // contract code size\n', '    return codeSize > 0; \n', "    // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \n", '  }\n', '}\n', '\n', 'interface ERC20 {\n', '  function totalSupply() external view returns (uint supply);\n', '  function balanceOf(address _owner) external view returns (uint balance);\n', '  function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '  function decimals() external view returns(uint digits);\n', '  function symbol() external view returns (string memory);\n', '  function name() external view returns (string memory);\n', '}']