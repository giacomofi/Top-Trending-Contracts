['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./ehash_library.sol";\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        require((allowance(_msgSender(), spender) == 0) || (amount == 0), "ERC20: change allowance use increaseAllowance or decreaseAllowance instead");\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract Pausable is Context {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', 'contract EHashBaseToken is ERC20, Pausable, Ownable {\n', '    /**\n', '     * @dev Initialize the contract give all tokens to the deployer\n', '     */\n', '    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        _mint(_msgSender(), _initialSupply * (10 ** uint256(_decimals)));\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '    \n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function mint(address account, uint256 amount) public onlyOwner {\n', '        _mint(account,amount);\n', '    }\n', '     \n', '    /**\n', "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n", '     * allowance.\n', '     *\n', '     * See {ERC20-_burn} and {ERC20-allowance}.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have allowance for ``accounts``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public {\n', '        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "EHashToken: burn amount exceeds allowance");\n', '\n', '        _approve(account, _msgSender(), decreasedAllowance);\n', '        _burn(account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     * @notice only Owner call\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     * @notice only Owner call\n', '     */\n', '    function unpause() public onlyOwner {\n', '        _unpause();\n', '    }\n', '    \n', '    /**\n', '     * @dev Batch transfer amount to recipient\n', '     * @notice that excessive gas consumption causes transaction revert\n', '     */\n', '    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public {\n', '        require(recipients.length > 0, "EHashToken: least one recipient address");\n', '        require(recipients.length == amounts.length, "EHashToken: number of recipient addresses does not match the number of tokens");\n', '\n', '        for(uint256 i = 0; i < recipients.length; ++i) {\n', '            _transfer(_msgSender(), recipients[i], amounts[i]);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract EHashToken is EHashBaseToken, ReentrancyGuard{\n', '    using SafeMath for uint256;\n', '    using Address for address payable;\n', '\n', '    // @dev a revenue share multiplier to avert divison downflow.\n', '    uint256 internal constant REVENUE_SHARE_MULTIPLIER = 1e18;\n', '    \n', '    // @dev update period in secs for revenue distribution.\n', '    uint256 public updatePeriod = 30;\n', '\n', "    // @dev for tracking of holders' claimable revenue.\n", '    mapping (address => uint256) internal _revenueBalance;\n', '    \n', "    // @dev for tracking of holders' claimed revenue.\n", '    mapping (address => uint256) internal _revenueClaimed;\n', '    \n', '    /// @dev RoundData always kept for each round.\n', '    struct RoundData {\n', '        uint256 accTokenShare;     // accumulated unit ehash share for each settlement.\n', '        uint256 roundEthers;    // total ethers received in this round. \n', '    }\n', '    \n', '    /// @dev round index mapping to RoundData.\n', '    mapping (uint => RoundData) private _rounds;\n', '    \n', "    /// @dev mark token holders' highest settled revenue round.\n", '    mapping (address => uint) private _settledRevenueRounds;\n', '    \n', '    /// @dev a monotonic increasing round index, STARTS FROM 1\n', '    uint private _currentRound = 1;\n', '    \n', '    /// @dev expected next update time\n', '    uint private _nextUpdate = block.timestamp + updatePeriod;\n', '\n', "    /// @dev manager's address\n", '    address payable managerAddress;\n', '\n', '    /// @dev Revenue Claiming log\n', '    event Claim(address indexed account, uint256 amount);\n', '    \n', '    /// @dev Update log\n', '    event Update(uint256 AccTokenShare, uint256 RoundEthers);\n', '\n', '    /// @dev Received log\n', '    event Received(address indexed account, uint256 amount);\n', '    \n', '    /// @dev Settle Log\n', '    event Settle(address indexed account, uint LastSettledRound, uint256 Revenue);\n', '    \n', '    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) \n', '        EHashBaseToken(_name, _symbol, _decimals, _initialSupply)\n', '        public {\n', '    }\n', '    \n', '    // @dev tryUpdate function\n', '    modifier tryUpdate() {\n', '        if (block.timestamp > _nextUpdate) {\n', '            update();\n', '        }\n', '        _;\n', '    }\n', '    \n', '    /**\n', "     * @notice set manager's address\n", '     */\n', '    function setManagerAddress(address payable account) external onlyOwner {\n', '        require (account != address(0), "0 address");\n', '        managerAddress = account;\n', '    }\n', '    \n', '    /** \n', '     * @notice set update period\n', '     */\n', '    function setUpdatePeriod(uint nsecs) external onlyOwner {\n', '        require (nsecs > 0," period should be positive");\n', '        updatePeriod = nsecs;\n', '    }\n', '    \n', '    /**\n', "     * @notice get manager's address\n", '     */\n', '     function getManagerAddress() external view returns(address) {\n', '         return managerAddress;\n', '     }\n', '    \n', '    /**\n', '     * @notice default ether receiving function \n', '     */\n', '    receive() external payable tryUpdate {\n', '        _rounds[_currentRound].roundEthers += msg.value;\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * @notice check unclaimed revenue \n', '     */\n', '    function checkUnclaimedRevenue(address account) public view returns(uint256 revenue) {\n', '        uint256 accountTokens = balanceOf(account);\n', '        uint lastSettledRound = _settledRevenueRounds[account];\n', '\n', '        uint256 roundRevenue = _rounds[_currentRound-1].accTokenShare.sub(_rounds[lastSettledRound].accTokenShare)\n', '                                    .mul(accountTokens)\n', '                                    .div(REVENUE_SHARE_MULTIPLIER);  // NOTE: div by REVENUE_SHARE_MULTIPLIER\n', '\n', '        return _revenueBalance[account].add(roundRevenue);\n', '    }\n', '    \n', '    /**\n', "     * @notice get user's life-time gain\n", '     */\n', '    function checkTotalRevenue(address account) external view returns(uint256 revenue) {\n', '        return checkUnclaimedRevenue(account) + _revenueClaimed[account];\n', '    }\n', '    \n', '    /**\n', '     * @notice get round N information\n', '     */\n', '    function getRoundData(uint round) external view returns(uint256 accTokenShare, uint256 roundEthers) {\n', '        return (_rounds[round].accTokenShare, _rounds[round].roundEthers);\n', '    }\n', '    \n', '    /**\n', '     * @notice get current round\n', '     */\n', '    function getCurrentRound() external view returns(uint round) {\n', '        return _currentRound;\n', '    }\n', '\n', '    /**\n', '     * @notice token holders claim revenue\n', '     */\n', '    function claim() external whenNotPaused {\n', '        // settle un-distributed revenue in rounds to _revenueBalance;\n', '        _settleRevenue(msg.sender);\n', '\n', '        // revenue balance change\n', '        uint256 revenue = _revenueBalance[msg.sender];\n', "        _revenueBalance[msg.sender] = 0; // zero sender's balance\n", '        \n', '        // transfer ETH to msg.sender\n', '        msg.sender.sendValue(revenue);\n', '        \n', '        // record claimed revenue\n', '        _revenueClaimed[msg.sender] += revenue;\n', '        \n', '        // log\n', '        emit Claim(msg.sender, revenue);\n', '    }\n', '    \n', '     /**\n', '     * @notice settle revenue in rounds to _revenueBalance, \n', '     * settle revenue happens before any token exchange such as ERC20-transfer,mint,burn,\n', '     * and active claim();\n', '     */\n', '    function _settleRevenue(address account) internal tryUpdate {\n', '        uint256 accountTokens = balanceOf(account);\n', '        uint lastSettledRound = _settledRevenueRounds[account];\n', '        \n', '        uint256 roundRevenue = _rounds[_currentRound-1].accTokenShare.sub(_rounds[lastSettledRound].accTokenShare)\n', '                                    .mul(accountTokens)\n', '                                    .div(REVENUE_SHARE_MULTIPLIER);  // NOTE: div by REVENUE_SHARE_MULTIPLIER\n', '\n', '        // mark highest settled round revenue claimed.\n', '        _settledRevenueRounds[account] = _currentRound - 1;\n', '        // set back balance to storage\n', '        _revenueBalance[account] += roundRevenue;\n', '        // log\n', '        emit Settle(account, _settledRevenueRounds[account], _revenueBalance[account]);\n', '    }\n', '    \n', '    /**\n', '     * @dev See {ERC20-_beforeTokenTransfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the contract must not be paused.\n', '     * - accounts must not trigger the locked `amount` during the locked period.\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n', '        require(!paused(), "EHash: token transfer while paused");\n', '        \n', '        // handle revenue settlement before token number changes.\n', '        if (from != address(0)) {\n', '            _settleRevenue(from);\n', '        }\n', '        \n', '        if (to != address(0)) {\n', '            _settleRevenue(to);\n', '        }\n', '        \n', '        super._beforeTokenTransfer(from, to, amount);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev update function to settle rounds shifting and rounds share.\n', '     */\n', '    function update() internal nonReentrant {\n', '        require (block.timestamp > _nextUpdate, "period not expired");\n', '        require (managerAddress != address(0), "manager address has not set");\n', '        \n', '        // rules:\n', '        // 80% of ethers in this round belongs to all token holders\n', '        //  roundEthers * 80% / totalSupply()\n', '        // and, 20% of ethers belongs to manager\n', '        uint256 roundEthers = _rounds[_currentRound].roundEthers;\n', '        uint256 managerRevenue = roundEthers.mul(20).div(100);\n', '        uint256 holdersEthers = roundEthers.sub(managerRevenue);\n', '        \n', '        // send to manager\n', '        managerAddress.sendValue(managerRevenue);\n', '        \n', "        // substract manager's revenue\n", '        \n', "        // set accmulated holder's share\n", '        _rounds[_currentRound].accTokenShare = _rounds[_currentRound-1].accTokenShare\n', '                                                .add(\n', '                                                    holdersEthers\n', '                                                    .mul(REVENUE_SHARE_MULTIPLIER) // NOTE: multiplied by REVENUE_SHARE_MULTIPLIER here\n', '                                                    .div(totalSupply())\n', '                                                );\n', '\n', '        // log                                            \n', '        emit Update(_rounds[_currentRound].accTokenShare, _rounds[_currentRound].roundEthers);\n', '        \n', '        // next round setting                                 \n', '        _currentRound++;\n', '        _nextUpdate = block.timestamp + updatePeriod;\n', '    }\n', '}']