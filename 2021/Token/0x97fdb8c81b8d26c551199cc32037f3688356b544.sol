['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-08\n', '*/\n', '\n', 'pragma solidity ^0.8.1;\n', '\n', 'contract ClockBoxContract {\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    // lockedBalances of sender\n', '    mapping(address => uint256) internal _lockedBalances;\n', '\n', '    mapping(bytes32 => Keeper) internal keepers;\n', '\n', '    uint256 internal feePercentage;\n', '\n', '    // address to pay fee to\n', '    address payable internal feeAddress;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    address public admin;\n', '\n', '    struct Keeper {\n', '        address sender;\n', '        uint256 value;\n', '        address recipient;\n', '        uint256 dateLocked;\n', '        uint256 lockUntill;\n', '    }\n', '\n', '    event NewKeeper(\n', '        address indexed sender,\n', '        uint256 value,\n', '        address indexed recipient,\n', '        uint256 dateLocked, // block.timestamp\n', '        uint256 indexed lockUntill, // timestamp (millisecond)\n', '        bytes32 hash\n', '    );\n', '\n', '    event Transfer(address from, address to, uint256 value);\n', '\n', '    event Approval(address from, address recipient, uint256 amount);\n', '\n', '    constructor(address _admin, address _feeAddress) {\n', '        _name = "ClockBox";\n', '        _symbol = "CLOCK";\n', '        _decimals = 16;\n', '        admin = _admin;\n', '        mint(100000000 * 10**decimals());\n', '\n', '        // 0.25% of value stored in the contract\n', '        feePercentage = 25;\n', '        feeAddress = payable(_feeAddress);\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /// Transfer value from sender to recipient\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// Returns the amount of value a spender is allowed to spend on behalf of the owner\n', '    function allowance(address _owner, address spender) public view returns (uint256) {\n', '        return _allowances[_owner][spender];\n', '    }\n', '\n', '    // Set amount that a spender is allowed to spend on behalf of the sender\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// Allows spender transfer from owner using allowance\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][msg.sender];\n', '        require(currentAllowance >= amount, "Amount exceeds allowance");\n', '        _approve(sender, msg.sender, currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        uint256 currentAllowance = _allowances[msg.sender][spender];\n', '        _approve(msg.sender, spender, currentAllowance + addedValue);\n', '        return true;\n', '    }\n', '\n', '    // Create new token\n', '    function mint(uint256 _amount) public onlyAdmin returns (bool) {\n', '        _mint(msg.sender, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // destroy tokens\n', '    function burn(uint256 _amount) public onlyAdmin returns (bool) {\n', '        _burn(msg.sender, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        uint256 currentAllowance = _allowances[msg.sender][spender];\n', '        require(currentAllowance >= subtractedValue, "Decreased allowance below zero");\n', '        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// Set amount a spender can spend on behalf of the owner\n', '    function _approve(\n', '        address _owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) internal {\n', '        require(_owner != address(0), "Approve from zero address");\n', '        require(spender != address(0), "Approve to zero address");\n', '\n', '        _allowances[_owner][spender] = amount;\n', '        emit Approval(_owner, spender, amount);\n', '    }\n', '\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) internal {\n', '        require(sender != address(0), "Transfering from zero address");\n', '        require(recipient != address(0), "Transfering to zero address");\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "Insuffiencet balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /// create new tokens and emit event from the zero address\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "Mint to the zero address");\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /// Destroy tokens - Send amount\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "Burn from the zero address");\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "Burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /*\n', '        ## Overview\n', '\n', '        Accept ETH from users, deduct 0.25% from the value sent\n', '        store the new amount in the smart contract (vault).\n', '        Emits a NewKeeper event for every new storage to the vault\n', '        When the lock time elapses, the stored value is sent to the intended recipient\n', '        The withdraw function is called by the dapp and this is trigger by outside schecdular\n', '        A `Transfer` event is also emited after every withdrawal\n', '\n', '        The smart contract is uses an owner priviliage to prevent anyone from sending ETH out.\n', '        Only the smart contract creator has priviliage to send ETH out.\n', '    */\n', '\n', '    // recieves ether from recipient\n', '    function vault(address _recipient, uint256 _lockTime) external payable {\n', '        uint256 fee = calculateFee(msg.value);\n', '        uint256 value = deductFeeFromValue(msg.value);\n', '        _lockedBalances[msg.sender] += value;\n', '\n', '        bytes32 hash = makeHash(msg.sender, _recipient, _lockTime);\n', '\n', '        // register keeper\n', '        keepers[hash] = (Keeper(msg.sender, value, _recipient, block.timestamp, _lockTime));\n', '\n', '        feeAddress.transfer(fee);\n', '        emit NewKeeper(msg.sender, value, _recipient, block.timestamp, _lockTime, hash);\n', '    }\n', '\n', '    function calculateFee(uint256 _valueSent) public view largerThen10000wie(_valueSent) returns (uint256) {\n', '        uint256 fee = (_valueSent * feePercentage) / 10000;\n', '\n', '        return fee;\n', '    }\n', '\n', '    function deductFeeFromValue(uint256 _valueSent) public view largerThen10000wie(_valueSent) returns (uint256) {\n', '        uint256 _value = _valueSent - calculateFee(_valueSent);\n', '\n', '        return _value;\n', '    }\n', '\n', '    function makeHash(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _lockTime\n', '    ) internal pure returns (bytes32) {\n', '        bytes32 hash = keccak256(abi.encode(_sender, _recipient, _lockTime));\n', '\n', '        return hash;\n', '    }\n', '\n', '    /// Returns sender locked balance\n', '    function balanceOfInValut() external view returns (uint256) {\n', '        return _lockedBalances[msg.sender];\n', '    }\n', '\n', '    /// Returns balance in the vault after fee has been deducted\n', '    function balanceOfvault() external view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /// Returns  the balnce of the address fees are been paid to\n', '    /// restricted to onlyOwner\n', '    function balanceOfFeeAddress() external view onlyAdmin returns (uint256) {\n', '        return address(feeAddress).balance;\n', '    }\n', '\n', '    /// Returns the record of a keeper\n', '    function getKeeper(bytes32 _hash) external view returns (Keeper memory) {\n', '        return keepers[_hash];\n', '    }\n', '\n', '    /// withdraw from the vault. Restricted to onlyOwner\n', '    function withdraw(bytes32 _hash) external onlyAdmin returns (bool) {\n', '        _withdrawFromvault(_hash);\n', '\n', '        return true;\n', '    }\n', '\n', '    // transfer ether from this smart contract to recipient\n', '    function _withdrawFromvault(bytes32 _hash) internal returns (bool) {\n', '        address to = keepers[_hash].recipient;\n', '        address payable recipient = payable(to);\n', '        address from = keepers[_hash].sender;\n', '        uint256 value = keepers[_hash].value;\n', '\n', '        // delete the record from valut - prevent double withdrawal(spending)\n', '        delete keepers[_hash];\n', '        /// @Review: should the record be deleted or should a field be updated that it has been withdrawn??\n', '\n', '        // transfer the value to the recipient\n', '        recipient.transfer(value);\n', '\n', '        emit Transfer(from, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    modifier largerThen10000wie(uint256 _value) {\n', '        require((_value / 10000) * 10000 == _value, "Amount is too low.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin, "Only owner can perform this operation");\n', '\n', '        _;\n', '    }\n', '}']