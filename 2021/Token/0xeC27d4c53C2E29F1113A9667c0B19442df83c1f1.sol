['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "../interface/IERC20.sol";\n', 'import "../interface/ILToken.sol";\n', 'import "./ERC20.sol";\n', 'import "../math/UnsignedSafeMath.sol";\n', '\n', '/**\n', ' * @title Deri Protocol liquidity provider token implementation\n', ' */\n', 'contract LToken is IERC20, ILToken, ERC20 {\n', '\n', '    using UnsignedSafeMath for uint256;\n', '\n', '    // Pool address this LToken associated with\n', '    address private _pool;\n', '\n', '    modifier _pool_() {\n', '        require(msg.sender == _pool, "LToken: called by non-associative pool, probably the original pool has been migrated");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token\n', '     */\n', '    constructor(string memory name_, string memory symbol_, address pool_) ERC20(name_, symbol_) {\n', '        require(pool_ != address(0), "LToken: construct with 0 address pool");\n', '        _pool = pool_;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ILToken}.{setPool}\n', '     */\n', '    function setPool(address newPool) public override {\n', '        require(newPool != address(0), "LToken: setPool to 0 address");\n', '        require(msg.sender == _pool, "LToken: setPool caller is not current pool");\n', '        _pool = newPool;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ILToken}.{pool}\n', '     */\n', '    function pool() public view override returns (address) {\n', '        return _pool;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ILToken}.{mint}\n', '     */\n', '    function mint(address account, uint256 amount) public override _pool_ {\n', '        require(account != address(0), "LToken: mint to 0 address");\n', '\n', '        _balances[account] = _balances[account].add(amount);\n', '        _totalSupply = _totalSupply.add(amount);\n', '\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ILToken}.{burn}\n', '     */\n', '    function burn(address account, uint256 amount) public override _pool_ {\n', '        require(account != address(0), "LToken: burn from 0 address");\n', '        require(_balances[account] >= amount, "LToken: burn amount exceeds balance");\n', '\n', '        _balances[account] = _balances[account].sub(amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `amount` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '\n', '    /**\n', '     * @dev Emitted when `amount` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `amount` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the name.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `to`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n', "     * `amount` is then deducted from the caller's allowance.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "./IERC20.sol";\n', '\n', '/**\n', ' * @title Deri Protocol liquidity provider token interface\n', ' */\n', 'interface ILToken is IERC20 {\n', '\n', '    /**\n', '     * @dev Set the pool address of this LToken\n', '     * pool is the only controller of this contract\n', '     * can only be called by current pool\n', '     */\n', '    function setPool(address newPool) external;\n', '\n', '    /**\n', '     * @dev Returns address of pool\n', '     */\n', '    function pool() external view returns (address);\n', '\n', '    /**\n', '     * @dev Mint LToken to `account` of `amount`\n', '     *\n', '     * Can only be called by pool\n', '     * `account` cannot be zero address\n', '     */\n', '    function mint(address account, uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Burn `amount` LToken of `account`\n', '     *\n', '     * Can only be called by pool\n', '     * `account` cannot be zero address\n', '     * `account` must owns at least `amount` LToken\n', '     */\n', '    function burn(address account, uint256 amount) external;\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../interface/IERC20.sol";\n', 'import "../math/UnsignedSafeMath.sol";\n', '\n', '/**\n', ' * @title ERC20 Implementation\n', ' */\n', 'contract ERC20 is IERC20 {\n', '\n', '    using UnsignedSafeMath for uint256;\n', '\n', '    string _name;\n', '    string _symbol;\n', '    uint8 _decimals = 18;\n', '    uint256 _totalSupply;\n', '\n', '    mapping (address => uint256) _balances;\n', '    mapping (address => mapping (address => uint256)) _allowances;\n', '\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{name}\n', '     */\n', '    function name() public view override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{symbol}\n', '     */\n', '    function symbol() public view override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{decimals}\n', '     */\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{totalSupply}\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{balanceOf}\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{allowance}\n', '     */\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{approve}\n', '     */\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        require(spender != address(0), "ERC20: approve to 0 address");\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{transfer}\n', '     */\n', '    function transfer(address to, uint256 amount) public override returns (bool) {\n', '        require(to != address(0), "ERC20: transfer to 0 address");\n', '        require(_balances[msg.sender] >= amount, "ERC20: transfer amount exceeds balance");\n', '        _transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20}.{transferFrom}\n', '     */\n', '    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n', '        require(to != address(0), "ERC20: transferFrom to 0 address");\n', '        if (_allowances[from][msg.sender] != uint256(-1)) {\n', '            require(_allowances[from][msg.sender] >= amount, "ERC20: transferFrom not approved");\n', '            _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(amount);\n', '        }\n', '        _transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`.\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Parameters check should be carried out before calling this function.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `from` to `to`.\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Parameters check should be carried out before calling this function.\n', '     */\n', '    function _transfer(address from, address to, uint256 amount) internal {\n', '        _balances[from] = _balances[from].sub(amount);\n', '        _balances[to] = _balances[to].add(amount);\n', '        emit Transfer(from, to, amount);\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title Unsigned safe math\n', ' */\n', 'library UnsignedSafeMath {\n', '\n', '    /**\n', '     * @dev Addition of unsigned integers, counterpart to `+`\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "UnsignedSafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtraction of unsigned integers, counterpart to `-`\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(a >= b, "UnsignedSafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplication of unsigned integers, counterpart to `*`\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero,\n", "        // but the benefit is lost if 'b' is also tested\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "UnsignedSafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Division of unsigned integers, counterpart to `/`\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "UnsignedSafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Modulo of unsigned integers, counterpart to `%`\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "UnsignedSafeMath: modulo by zero");\n', '        uint256 c = a % b;\n', '        return c;\n', '    }\n', '\n', '}']