['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract OwnerHelper\n', '{\n', '    address public owner;\n', '    address public manager;\n', '\n', '    event ChangeOwner(address indexed _from, address indexed _to);\n', '    event ChangeManager(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner, "ERROR: Not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(msg.sender == manager, "ERROR: Not manager");\n', '        _;\n', '    }\n', '\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _to) onlyOwner public\n', '    {\n', '        require(_to != owner);\n', '        require(_to != manager);\n', '        require(_to != address(0x0));\n', '\n', '        address from = owner;\n', '        owner = _to;\n', '\n', '        emit ChangeOwner(from, _to);\n', '    }\n', '\n', '    function transferManager(address _to) onlyOwner public\n', '    {\n', '        require(_to != owner);\n', '        require(_to != manager);\n', '        require(_to != address(0x0));\n', '\n', '        address from = manager;\n', '        manager = _to;\n', '\n', '        emit ChangeManager(from, _to);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Interface\n', '{\n', '    event Transfer( address indexed _from, address indexed _to, uint _value);\n', '    event Approval( address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function totalSupply() view virtual public returns (uint _supply);\n', '    function balanceOf( address _who ) virtual public view returns (uint _value);\n', '    function transfer( address _to, uint _value) virtual public returns (bool _success);\n', '    function approve( address _spender, uint _value ) virtual public returns (bool _success);\n', '    function allowance( address _owner, address _spender ) virtual public view returns (uint _allowance);\n', '    function transferFrom( address _from, address _to, uint _value) virtual public returns (bool _success);\n', '}\n', '\n', 'contract ARTIC is ERC20Interface, OwnerHelper\n', '{\n', '    string public name;\n', '    uint public decimals;\n', '    string public symbol;\n', '\n', '    uint constant private E18 = 1000000000000000000;\n', '    uint constant private month = 2592000;\n', '\n', '    // Total                                         100,000,000\n', '    uint constant public maxTotalSupply           = 100000000 * E18;\n', '    // Sale                                         10,000,000 (10%)\n', '    uint constant public maxSaleSupply            = 10000000 * E18;\n', '    // Marketing                                    25,000,000 (25%)\n', '    uint constant public maxMktSupply             = 25000000 * E18;\n', '    // Development                                  12,000,000 (12%)\n', '    uint constant public maxDevSupply             = 12000000 * E18;\n', '    // EcoSystem                                    20,000,000 (20%)\n', '    uint constant public maxEcoSupply             = 20000000 * E18;\n', '    // Legal & Compliance                           15,000,000 (15%)\n', '    uint constant public maxLegalComplianceSupply = 15000000 * E18;\n', '    // Team                                         5,000,000 (5%)\n', '    uint constant public maxTeamSupply            = 5000000 * E18;\n', '    // Advisors                                     3,000,000 (3%)\n', '    uint constant public maxAdvisorSupply         = 3000000 * E18;\n', '    // Reserve                                      10,000,000 (10%)\n', '    uint constant public maxReserveSupply         = 10000000 * E18;\n', '\n', '    // Lock\n', '    uint constant public teamVestingSupply = 500000 * E18;\n', '    uint constant public teamVestingLockDate =  12 * month;\n', '    uint constant public teamVestingTime = 10;\n', '\n', '    uint constant public advisorVestingSupply = 750000 * E18;\n', '    uint constant public advisorVestingTime = 4;\n', '\n', '    uint public totalTokenSupply;\n', '    uint public tokenIssuedSale;\n', '    uint public tokenIssuedMkt;\n', '    uint public tokenIssuedDev;\n', '    uint public tokenIssuedEco;\n', '    uint public tokenIssuedLegalCompliance;\n', '    uint public tokenIssuedTeam;\n', '    uint public tokenIssuedAdv;\n', '    uint public tokenIssuedRsv;\n', '\n', '    uint public burnTokenSupply;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => mapping ( address => uint )) public approvals;\n', '\n', '    mapping (uint => uint) public tmVestingTimer;\n', '    mapping (uint => uint) public tmVestingBalances;\n', '    mapping (uint => uint) public advVestingTimer;\n', '    mapping (uint => uint) public advVestingBalances;\n', '\n', '    bool public tokenLock = true;\n', '    bool public saleTime = true;\n', '    uint public endSaleTime = 0;\n', '\n', '    event SaleIssue(address indexed _to, uint _tokens);\n', '    event DevIssue(address indexed _to, uint _tokens);\n', '    event EcoIssue(address indexed _to, uint _tokens);\n', '    event LegalComplianceIssue(address indexed _to, uint _tokens);\n', '    event MktIssue(address indexed _to, uint _tokens);\n', '    event RsvIssue(address indexed _to, uint _tokens);\n', '    event TeamIssue(address indexed _to, uint _tokens);\n', '    event AdvIssue(address indexed _to, uint _tokens);\n', '\n', '    event Burn(address indexed _from, uint _tokens);\n', '\n', '    event TokenUnlock(address indexed _to, uint _tokens);\n', '    event EndSale(uint _date);\n', '\n', '    constructor()\n', '    {\n', '        name        = "ARTIC";\n', '        decimals    = 18;\n', '        symbol      = "ARTIC";\n', '\n', '        totalTokenSupply = maxTotalSupply;\n', '        balances[owner] = totalTokenSupply;\n', '\n', '        tokenIssuedSale     = 0;\n', '        tokenIssuedDev      = 0;\n', '        tokenIssuedEco      = 0;\n', '        tokenIssuedLegalCompliance = 0;\n', '        tokenIssuedMkt      = 0;\n', '        tokenIssuedRsv      = 0;\n', '        tokenIssuedTeam     = 0;\n', '        tokenIssuedAdv      = 0;\n', '\n', '        burnTokenSupply     = 0;\n', '\n', '        require(maxTeamSupply == teamVestingSupply * teamVestingTime, "ERROR: MaxTeamSupply");\n', '        require(maxAdvisorSupply == advisorVestingSupply * advisorVestingTime, "ERROR: MaxAdvisorSupply");\n', '        require(maxTotalSupply == maxSaleSupply + maxDevSupply + maxEcoSupply + maxMktSupply + maxReserveSupply + maxTeamSupply + maxAdvisorSupply + maxLegalComplianceSupply, "ERROR: MaxTotalSupply");\n', '    }\n', '\n', '    function totalSupply() view override public returns (uint)\n', '    {\n', '        return totalTokenSupply;\n', '    }\n', '\n', '    function balanceOf(address _who) view override public returns (uint)\n', '    {\n', '        return balances[_who];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        approvals[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) view override public returns (uint)\n', '    {\n', '        return approvals[_owner][_spender];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) override public returns (bool)\n', '    {\n', '        require(isTransferable() == true);\n', '        require(balances[_from] >= _value);\n', '        require(approvals[_from][msg.sender] >= _value);\n', '\n', '        approvals[_from][msg.sender] = approvals[_from][msg.sender] - _value;\n', '        balances[_from] = balances[_from] - _value;\n', '        balances[_to]  = balances[_to] + _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function saleIssue(address _to) onlyOwner public\n', '    {\n', '        require(tokenIssuedSale == 0);\n', '        uint tokens = maxSaleSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedSale = tokenIssuedSale + tokens;\n', '\n', '        emit SaleIssue(_to, tokens);\n', '    }\n', '\n', '    function devIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedDev == 0);\n', '\n', '        uint tokens = maxDevSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedDev = tokenIssuedDev + tokens;\n', '\n', '        emit DevIssue(_to, tokens);\n', '    }\n', '\n', '    function ecoIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedEco == 0);\n', '\n', '        uint tokens = maxEcoSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedEco = tokenIssuedEco + tokens;\n', '\n', '        emit EcoIssue(_to, tokens);\n', '    }\n', '\n', '    function mktIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedMkt == 0);\n', '\n', '        uint tokens = maxMktSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedMkt = tokenIssuedMkt + tokens;\n', '\n', '        emit MktIssue(_to, tokens);\n', '    }\n', '\n', '    function legalComplianceIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedLegalCompliance == 0);\n', '\n', '        uint tokens = maxLegalComplianceSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedLegalCompliance = tokenIssuedLegalCompliance + tokens;\n', '\n', '        emit LegalComplianceIssue(_to, tokens);\n', '    }\n', '\n', '    function rsvIssue(address _to) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require(tokenIssuedRsv == 0);\n', '\n', '        uint tokens = maxReserveSupply;\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '\n', '        tokenIssuedRsv = tokenIssuedRsv + tokens;\n', '\n', '        emit RsvIssue(_to, tokens);\n', '    }\n', '\n', '    function teamIssue(address _to, uint _time /* 몇 번째 지급인지 */) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require( _time < teamVestingTime);\n', '\n', '        uint nowTime = block.timestamp;\n', '        require( nowTime > tmVestingTimer[_time] );\n', '\n', '        uint tokens = teamVestingSupply;\n', '\n', '        require(tokens == tmVestingBalances[_time]);\n', '        require(maxTeamSupply >= tokenIssuedTeam + tokens);\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '        tmVestingBalances[_time] = 0;\n', '\n', '        tokenIssuedTeam = tokenIssuedTeam + tokens;\n', '\n', '        emit TeamIssue(_to, tokens);\n', '    }\n', '\n', '    function advisorIssue(address _to, uint _time) onlyOwner public\n', '    {\n', '        require(saleTime == false);\n', '        require( _time < advisorVestingTime);\n', '\n', '        uint nowTime = block.timestamp;\n', '        require( nowTime > advVestingTimer[_time] );\n', '\n', '        uint tokens = advisorVestingSupply;\n', '\n', '        require(tokens == advVestingBalances[_time]);\n', '        require(maxAdvisorSupply >= tokenIssuedAdv + tokens);\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        balances[_to] = balances[_to] + tokens;\n', '        advVestingBalances[_time] = 0;\n', '\n', '        tokenIssuedAdv = tokenIssuedAdv + tokens;\n', '\n', '        emit AdvIssue(_to, tokens);\n', '    }\n', '\n', '    function isTransferable() private view returns (bool)\n', '    {\n', '        if(tokenLock == false)\n', '        {\n', '            return true;\n', '        }\n', '        else if(msg.sender == owner)\n', '        {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function setTokenUnlock() onlyManager public\n', '    {\n', '        require(tokenLock == true);\n', '        require(saleTime == false);\n', '\n', '        tokenLock = false;\n', '    }\n', '\n', '    function setTokenLock() onlyManager public\n', '    {\n', '        require(tokenLock == false);\n', '        tokenLock = true;\n', '    }\n', '\n', '    function endSale() onlyOwner public\n', '    {\n', '        require(saleTime == true);\n', '        require(maxSaleSupply == tokenIssuedSale);\n', '\n', '        saleTime = false;\n', '\n', '        uint nowTime = block.timestamp;\n', '        endSaleTime = nowTime;\n', '\n', '        for(uint i = 0; i < teamVestingTime; i++)\n', '        {\n', '            tmVestingTimer[i] = endSaleTime + teamVestingLockDate + (i * month);\n', '            tmVestingBalances[i] = teamVestingSupply;\n', '        }\n', '\n', '        for(uint i = 0; i < advisorVestingTime; i++)\n', '        {\n', '            advVestingTimer[i] = endSaleTime + (3 * i * month);\n', '            advVestingBalances[i] = advisorVestingSupply;\n', '        }\n', '\n', '        emit EndSale(endSaleTime);\n', '    }\n', '\n', '    function burnToken(uint _value) onlyManager public\n', '    {\n', '        uint tokens = _value * E18;\n', '\n', '        require(balances[msg.sender] >= tokens);\n', '\n', '        balances[msg.sender] = balances[msg.sender] - tokens;\n', '\n', '        burnTokenSupply = burnTokenSupply + tokens;\n', '        totalTokenSupply = totalTokenSupply - tokens;\n', '\n', '        emit Burn(msg.sender, tokens);\n', '    }\n', '\n', '    function close() onlyOwner public\n', '    {\n', '        selfdestruct(payable(msg.sender));\n', '    }\n', '}']