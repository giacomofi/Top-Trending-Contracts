['pragma solidity ^0.5.0;\n', '\n', '/// @title Provides helper functions to determine the validity of passed signatures.\n', '/// @author Noah Zinsmeister\n', '/// @dev Supports both prefixed and un-prefixed signatures.\n', 'contract SignatureVerifier {\n', '    /// @notice Determines whether the passed signature of `messageHash` was made by the private key of `_address`.\n', '    /// @param _address The address that may or may not have signed the passed messageHash.\n', '    /// @param messageHash The messageHash that may or may not have been signed.\n', '    /// @param v The v component of the signature.\n', '    /// @param r The r component of the signature.\n', '    /// @param s The s component of the signature.\n', '    /// @return true if the signature can be verified, false otherwise.\n', '    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\n', '        return _isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s);\n', '    }\n', '\n', '    /// @dev Checks unprefixed signatures.\n', '    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal pure returns (bool)\n', '    {\n', '        return ecrecover(messageHash, v, r, s) == _address;\n', '    }\n', '\n', '    /// @dev Checks prefixed signatures.\n', '    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        internal pure returns (bool)\n', '    {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        return _isSigned(_address, keccak256(abi.encodePacked(prefix, messageHash)), v, r, s);\n', '    }\n', '}\n', '\n', '/// @title An implementation of the set data structure for addresses.\n', '/// @author Noah Zinsmeister\n', '/// @dev O(1) insertion, removal, contains, and length functions.\n', 'library AddressSet {\n', '    struct Set {\n', '        address[] members;\n', '        mapping(address => uint) memberIndices;\n', '    }\n', '\n', '    /// @dev Inserts an element into a set. If the element already exists in the set, the function is a no-op.\n', '    /// @param self The set to insert into.\n', '    /// @param other The element to insert.\n', '    function insert(Set storage self, address other) internal {\n', '        if (!contains(self, other)) {\n', '            self.memberIndices[other] = self.members.push(other);\n', '        }\n', '    }\n', '\n', '    /// @dev Removes an element from a set. If the element does not exist in the set, the function is a no-op.\n', '    /// @param self The set to remove from.\n', '    /// @param other The element to remove.\n', '    function remove(Set storage self, address other) internal {\n', '        if (contains(self, other)) {\n', '            // replace other with the last element\n', '            self.members[self.memberIndices[other] - 1] = self.members[length(self) - 1];\n', '            // reflect this change in the indices\n', '            self.memberIndices[self.members[self.memberIndices[other] - 1]] = self.memberIndices[other];\n', '            delete self.memberIndices[other];\n', '            // remove the last element\n', '            self.members.pop();\n', '        }\n', '    }\n', '\n', '    /// @dev Checks set membership.\n', '    /// @param self The set to check membership in.\n', '    /// @param other The element to check membership of.\n', '    /// @return true if the element is in the set, false otherwise.\n', '    function contains(Set storage self, address other) internal view returns (bool) {\n', '        return ( // solium-disable-line operator-whitespace\n', '            self.memberIndices[other] > 0 && \n', '            self.members.length >= self.memberIndices[other] && \n', '            self.members[self.memberIndices[other] - 1] == other\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the number of elements in a set.\n', '    /// @param self The set to check the length of.\n', '    /// @return The number of elements in the set.\n', '    function length(Set storage self) internal view returns (uint) {\n', '        return self.members.length;\n', '    }\n', '}\n', '\n', '/// @title The ERC-1484 Identity Registry.\n', '/// @author Noah Zinsmeister\n', '/// @author Andy Chorlian\n', 'contract IdentityRegistry is SignatureVerifier {\n', '    using AddressSet for AddressSet.Set;\n', '\n', '\n', '    // Identity Data Structure and Parameters //////////////////////////////////////////////////////////////////////////\n', '\n', '    struct Identity {\n', '        address recoveryAddress;\n', '        AddressSet.Set associatedAddresses;\n', '        AddressSet.Set providers;\n', '        AddressSet.Set resolvers;\n', '    }\n', '\n', '    mapping (uint => Identity) private identityDirectory;\n', '    mapping (address => uint) private associatedAddressDirectory;\n', '\n', '    uint public nextEIN = 1;\n', '    uint public maxAssociatedAddresses = 50;\n', '\n', '\n', '    // Signature Timeout ///////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    uint public signatureTimeout = 1 days;\n', '\n', '    /// @dev Enforces that the passed timestamp is within signatureTimeout seconds of now.\n', '    /// @param timestamp The timestamp to check the validity of.\n', '    modifier ensureSignatureTimeValid(uint timestamp) {\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp >= timestamp && block.timestamp < timestamp + signatureTimeout, "Timestamp is not valid."\n', '        );\n', '        _;\n', '    }\n', '\n', '\n', '    // Recovery Address Change Logging /////////////////////////////////////////////////////////////////////////////////\n', '\n', '    struct RecoveryAddressChange {\n', '        uint timestamp;\n', '        address oldRecoveryAddress;\n', '    }\n', '\n', '    mapping (uint => RecoveryAddressChange) private recoveryAddressChangeLogs;\n', '\n', '\n', '    // Recovery Logging ////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    struct Recovery {\n', '        uint timestamp;\n', '        bytes32 hashedOldAssociatedAddresses;\n', '    }\n', '\n', '    mapping (uint => Recovery) private recoveryLogs;\n', '\n', '\n', '    // Recovery Timeout ////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    uint public recoveryTimeout = 2 weeks;\n', '\n', '    /// @dev Checks if the passed EIN has changed their recovery address within recoveryTimeout seconds of now.\n', '    function canChangeRecoveryAddress(uint ein) private view returns (bool) {\n', '        // solium-disable-next-line security/no-block-members\n', '        return block.timestamp > recoveryAddressChangeLogs[ein].timestamp + recoveryTimeout;\n', '    }\n', '\n', '    /// @dev Checks if the passed EIN has recovered within recoveryTimeout seconds of now.\n', '    function canRecover(uint ein) private view returns (bool) {\n', '        // solium-disable-next-line security/no-block-members\n', '        return block.timestamp > recoveryLogs[ein].timestamp + recoveryTimeout;\n', '    }\n', '\n', '\n', '    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    /// @notice Checks if the passed EIN exists.\n', '    /// @dev Does not throw.\n', '    /// @param ein The EIN to check the existence of.\n', '    /// @return true if the passed EIN exists, false otherwise.\n', '    function identityExists(uint ein) public view returns (bool) {\n', '        return ein < nextEIN && ein > 0;\n', '    }\n', '\n', '    /// @dev Ensures that the passed EIN exists.\n', '    /// @param ein The EIN to check the existence of.\n', '    modifier _identityExists(uint ein) {\n', '        require(identityExists(ein), "The identity does not exist.");\n', '        _;\n', '    }\n', '\n', '    /// @notice Checks if the passed address is associated with an Identity.\n', '    /// @dev Does not throw.\n', '    /// @param _address The address to check.\n', '    /// @return true if the passed address is associated with an Identity, false otherwise.\n', '    function hasIdentity(address _address) public view returns (bool) {\n', '        return identityExists(associatedAddressDirectory[_address]);\n', '    }\n', '\n', '    /// @dev Ensures that the passed address is or is not associated with an Identity.\n', '    /// @param _address The address to check.\n', '    /// @param check If true, ensures that the address has an Identity, if false, vice versa.\n', '    /// @return true if the associated status is equal to check, false otherwise.\n', '    modifier _hasIdentity(address _address, bool check) {\n', '        require(\n', '            hasIdentity(_address) == check,\n', '            check ?\n', '                "The passed address does not have an identity but should." :\n', '                "The passed address has an identity but should not."\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @notice Gets the EIN associated with the passed address.\n', '    /// @dev Throws if the address is not associated with an Identity.\n', '    /// @param _address The address to check.\n', '    /// @return The associated EIN.\n', '    function getEIN(address _address) public view _hasIdentity(_address, true) returns (uint ein) {\n', '        return associatedAddressDirectory[_address];\n', '    }\n', '\n', '    /// @notice Checks whether the passed EIN is associated with the passed address.\n', '    /// @dev Does not throw.\n', '    /// @param ein The EIN to check.\n', '    /// @param _address The address to check.\n', '    /// @return true if the passed address is associated with the passed EIN, false otherwise.\n', '    function isAssociatedAddressFor(uint ein, address _address) public view returns (bool) {\n', '        return identityDirectory[ein].associatedAddresses.contains(_address);\n', '    }\n', '\n', '    /// @notice Checks whether the passed provider is set for the passed EIN.\n', '    /// @dev Does not throw.\n', '    /// @param ein The EIN to check.\n', '    /// @param provider The provider to check.\n', '    /// @return true if the provider is set for the passed EIN, false otherwise.\n', '    function isProviderFor(uint ein, address provider) public view returns (bool) {\n', '        return identityDirectory[ein].providers.contains(provider);\n', '    }\n', '\n', '    /// @dev Ensures that the msg.sender is a provider for the passed EIN.\n', '    /// @param ein The EIN to check.\n', '    modifier _isProviderFor(uint ein) {\n', '        require(isProviderFor(ein, msg.sender), "The identity has not set the passed provider.");\n', '        _;\n', '    }\n', '\n', '    /// @notice Checks whether the passed resolver is set for the passed EIN.\n', '    /// @dev Does not throw.\n', '    /// @param ein The EIN to check.\n', '    /// @param resolver The resolver to check.\n', '    /// @return true if the resolver is set for the passed EIN, false otherwise.\n', '    function isResolverFor(uint ein, address resolver) public view returns (bool) {\n', '        return identityDirectory[ein].resolvers.contains(resolver);\n', '    }\n', '\n', '    /// @notice Gets all identity-related information for the passed EIN.\n', '    /// @dev Throws if the passed EIN does not exist.\n', '    /// @param ein The EIN to get information for.\n', '    /// @return All the information for the Identity denominated by the passed EIN.\n', '    function getIdentity(uint ein) public view _identityExists(ein)\n', '        returns (\n', '            address recoveryAddress,\n', '            address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\n', '        )\n', '    {\n', '        Identity storage _identity = identityDirectory[ein];\n', '\n', '        return (\n', '            _identity.recoveryAddress,\n', '            _identity.associatedAddresses.members,\n', '            _identity.providers.members,\n', '            _identity.resolvers.members\n', '        );\n', '    }\n', '\n', '\n', '    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\n', '\n', '    /// @notice Create an new Identity for the transaction sender.\n', '    /// @dev Sets the msg.sender as the only associatedAddress.\n', '    /// @param recoveryAddress A recovery address to set for the new Identity.\n', '    /// @param providers A list of providers to set for the new Identity.\n', '    /// @param resolvers A list of resolvers to set for the new Identity.\n', '    /// @return The EIN of the new Identity.\n', '    function createIdentity(address recoveryAddress, address[] memory providers, address[] memory resolvers)\n', '        public returns (uint ein)\n', '    {\n', '        return createIdentity(recoveryAddress, msg.sender, providers, resolvers, false);\n', '    }\n', '\n', '    /// @notice Allows creation of a new Identity for the passed associatedAddress.\n', '    /// @param recoveryAddress A recovery address to set for the new Identity.\n', '    /// @param associatedAddress An associated address to set for the new Identity (must have produced the signature).\n', '    /// @param providers A list of providers to set for the new Identity.\n', '    /// @param resolvers A list of resolvers to set for the new Identity.\n', '    /// @param v The v component of the signature.\n', '    /// @param r The r component of the signature.\n', '    /// @param s The s component of the signature.\n', '    /// @param timestamp The timestamp of the signature.\n', '    /// @return The EIN of the new Identity.\n', '    function createIdentityDelegated(\n', '        address recoveryAddress, address associatedAddress, address[] memory providers, address[] memory resolvers,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp) returns (uint ein)\n', '    {\n', '        require(\n', '            isSigned(\n', '                associatedAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize the creation of an Identity on my behalf.",\n', '                        recoveryAddress, associatedAddress, providers, resolvers, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        return createIdentity(recoveryAddress, associatedAddress, providers, resolvers, true);\n', '    }\n', '\n', '    /// @dev Common logic for all identity creation.\n', '    function createIdentity(\n', '        address recoveryAddress,\n', '        address associatedAddress, address[] memory providers, address[] memory resolvers, bool delegated\n', '    )\n', '        private _hasIdentity(associatedAddress, false) returns (uint)\n', '    {\n', '        uint ein = nextEIN++;\n', '        Identity storage _identity = identityDirectory[ein];\n', '\n', '        _identity.recoveryAddress = recoveryAddress;\n', '        addAssociatedAddress(ein, associatedAddress);\n', '        addProviders(ein, providers, delegated);\n', '        addResolvers(ein, resolvers, delegated);\n', '\n', '        emit IdentityCreated(msg.sender, ein, recoveryAddress, associatedAddress, providers, resolvers, delegated);\n', '\n', '        return ein;\n', '    }\n', '\n', '\n', '    /// @notice Allows an associated address to add another associated address to its Identity.\n', '    /// @param approvingAddress An associated address for an Identity.\n', '    /// @param addressToAdd A new address to set for the Identity of the sender.\n', '    /// @param v The v component of the signature.\n', '    /// @param r The r component of the signature.\n', '    /// @param s The s component of the signature.\n', '    /// @param timestamp The timestamp of the signature.\n', '    function addAssociatedAddress(\n', '        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp)\n', '    {\n', '        bool fromApprovingAddress = msg.sender == approvingAddress;\n', '        require(\n', '            fromApprovingAddress || msg.sender == addressToAdd, "One or both of the passed addresses are malformed."\n', '        );\n', '\n', '        uint ein = getEIN(approvingAddress);\n', '\n', '        require(\n', '            isSigned(\n', '                fromApprovingAddress ? addressToAdd : approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        fromApprovingAddress ?\n', '                            "I authorize being added to this Identity." :\n', '                            "I authorize adding this address to my Identity.",\n', '                        ein, addressToAdd, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        addAssociatedAddress(ein, addressToAdd);\n', '\n', '        emit AssociatedAddressAdded(msg.sender, ein, approvingAddress, addressToAdd, false);\n', '    }\n', '\n', '    /// @notice Allows addition of an associated address to an Identity.\n', '    /// @dev The first signature must be that of the approvingAddress.\n', '    /// @param approvingAddress An associated address for an Identity.\n', '    /// @param addressToAdd A new address to set for the Identity of approvingAddress.\n', '    /// @param v The v component of the signatures.\n', '    /// @param r The r component of the signatures.\n', '    /// @param s The s component of the signatures.\n', '    /// @param timestamp The timestamp of the signatures.\n', '    function addAssociatedAddressDelegated(\n', '        address approvingAddress, address addressToAdd,\n', '        uint8[2] memory v, bytes32[2] memory r, bytes32[2] memory s, uint[2] memory timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp[0]) ensureSignatureTimeValid(timestamp[1])\n', '    {\n', '        uint ein = getEIN(approvingAddress);\n', '\n', '        require(\n', '            isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize adding this address to my Identity.",\n', '                        ein, addressToAdd, timestamp[0]\n', '                    )\n', '                ),\n', '                v[0], r[0], s[0]\n', '            ),\n', '            "Permission denied from approving address."\n', '        );\n', '        require(\n', '            isSigned(\n', '                addressToAdd,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize being added to this Identity.",\n', '                        ein, addressToAdd, timestamp[1]\n', '                    )\n', '                ),\n', '                v[1], r[1], s[1]\n', '            ),\n', '            "Permission denied from address to add."\n', '        );\n', '\n', '        addAssociatedAddress(ein, addressToAdd);\n', '\n', '        emit AssociatedAddressAdded(msg.sender, ein, approvingAddress, addressToAdd, true);\n', '    }\n', '\n', '    /// @dev Common logic for all address addition.\n', '    function addAssociatedAddress(uint ein, address addressToAdd) private _hasIdentity(addressToAdd, false) {\n', '        require(\n', '            identityDirectory[ein].associatedAddresses.length() < maxAssociatedAddresses, "Too many addresses."\n', '        );\n', '\n', '        identityDirectory[ein].associatedAddresses.insert(addressToAdd);\n', '        associatedAddressDirectory[addressToAdd] = ein;\n', '    }\n', '\n', '    /// @notice Allows an associated address to remove itself from its Identity.\n', '    function removeAssociatedAddress() public {\n', '        uint ein = getEIN(msg.sender);\n', '\n', '        removeAssociatedAddress(ein, msg.sender);\n', '\n', '        emit AssociatedAddressRemoved(msg.sender, ein, msg.sender, false);\n', '    }\n', '\n', '    /// @notice Allows removal of an associated address from an Identity.\n', '    /// @param addressToRemove An associated address to remove from its Identity.\n', '    /// @param v The v component of the signature.\n', '    /// @param r The r component of the signature.\n', '    /// @param s The s component of the signature.\n', '    /// @param timestamp The timestamp of the signature.\n', '    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\n', '        public ensureSignatureTimeValid(timestamp)\n', '    {\n', '        uint ein = getEIN(addressToRemove);\n', '\n', '        require(\n', '            isSigned(\n', '                addressToRemove,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize removing this address from my Identity.",\n', '                        ein, addressToRemove, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        removeAssociatedAddress(ein, addressToRemove);\n', '\n', '        emit AssociatedAddressRemoved(msg.sender, ein, addressToRemove, true);\n', '    }\n', '\n', '    /// @dev Common logic for all address removal.\n', '    function removeAssociatedAddress(uint ein, address addressToRemove) private {\n', '        identityDirectory[ein].associatedAddresses.remove(addressToRemove);\n', '        delete associatedAddressDirectory[addressToRemove];\n', '    }\n', '\n', '\n', '    /// @notice Allows an associated address to add providers to its Identity.\n', '    /// @param providers A list of providers.\n', '    function addProviders(address[] memory providers) public {\n', '        addProviders(getEIN(msg.sender), providers, false);\n', '    }\n', '\n', '    /// @notice Allows providers to add providers to an Identity.\n', '    /// @param ein The EIN to add providers to.\n', '    /// @param providers A list of providers.\n', '    function addProvidersFor(uint ein, address[] memory providers) public _isProviderFor(ein) {\n', '        addProviders(ein, providers, true);\n', '    }\n', '\n', '    /// @dev Common logic for all provider adding.\n', '    function addProviders(uint ein, address[] memory providers, bool delegated) private {\n', '        Identity storage _identity = identityDirectory[ein];\n', '        for (uint i; i < providers.length; i++) {\n', '            _identity.providers.insert(providers[i]);\n', '            emit ProviderAdded(msg.sender, ein, providers[i], delegated);\n', '        }\n', '    }\n', '\n', '    /// @notice Allows an associated address to remove providers from its Identity.\n', '    /// @param providers A list of providers.\n', '    function removeProviders(address[] memory providers) public {\n', '        removeProviders(getEIN(msg.sender), providers, false);\n', '    }\n', '\n', '    /// @notice Allows providers to remove providers to an Identity.\n', '    /// @param ein The EIN to remove providers from.\n', '    /// @param providers A list of providers.\n', '    function removeProvidersFor(uint ein, address[] memory providers) public _isProviderFor(ein) {\n', '        removeProviders(ein, providers, true);\n', '    }\n', '\n', '    /// @dev Common logic for all provider removal.\n', '    function removeProviders(uint ein, address[] memory providers, bool delegated) private {\n', '        Identity storage _identity = identityDirectory[ein];\n', '        for (uint i; i < providers.length; i++) {\n', '            _identity.providers.remove(providers[i]);\n', '            emit ProviderRemoved(msg.sender, ein, providers[i], delegated);\n', '        }\n', '    }\n', '\n', '    /// @notice Allows an associated address to add resolvers to its Identity.\n', '    /// @param resolvers A list of resolvers.\n', '    function addResolvers(address[] memory resolvers) public {\n', '        addResolvers(getEIN(msg.sender), resolvers, false);\n', '    }\n', '\n', '    /// @notice Allows providers to add resolvers to an Identity.\n', '    /// @param ein The EIN to add resolvers to.\n', '    /// @param resolvers A list of resolvers.\n', '    function addResolversFor(uint ein, address[] memory resolvers) public _isProviderFor(ein) {\n', '        addResolvers(ein, resolvers, true);\n', '    }\n', '\n', '    /// @dev Common logic for all resolver adding.\n', '    function addResolvers(uint ein, address[] memory resolvers, bool delegated) private {\n', '        Identity storage _identity = identityDirectory[ein];\n', '        for (uint i; i < resolvers.length; i++) {\n', '            _identity.resolvers.insert(resolvers[i]);\n', '            emit ResolverAdded(msg.sender, ein, resolvers[i], delegated);\n', '        }\n', '    }\n', '\n', '    /// @notice Allows an associated address to remove resolvers from its Identity.\n', '    /// @param resolvers A list of resolvers.\n', '    function removeResolvers(address[] memory resolvers) public {\n', '        removeResolvers(getEIN(msg.sender), resolvers, true);\n', '    }\n', '\n', '    /// @notice Allows providers to remove resolvers from an Identity.\n', '    /// @param ein The EIN to remove resolvers from.\n', '    /// @param resolvers A list of resolvers.\n', '    function removeResolversFor(uint ein, address[] memory resolvers) public _isProviderFor(ein) {\n', '        removeResolvers(ein, resolvers, true);\n', '    }\n', '\n', '    /// @dev Common logic for all resolver removal.\n', '    function removeResolvers(uint ein, address[] memory resolvers, bool delegated) private {\n', '        Identity storage _identity = identityDirectory[ein];\n', '        for (uint i; i < resolvers.length; i++) {\n', '            _identity.resolvers.remove(resolvers[i]);\n', '            emit ResolverRemoved(msg.sender, ein, resolvers[i], delegated);\n', '        }\n', '    }\n', '\n', '\n', '    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\n', '\n', '    /// @notice Allows an associated address to change the recovery address for its Identity.\n', '    /// @dev Recovery addresses can be changed at most once every recoveryTimeout seconds.\n', '    /// @param newRecoveryAddress A recovery address to set for the sender&#39;s EIN.\n', '    function triggerRecoveryAddressChange(address newRecoveryAddress) public {\n', '        triggerRecoveryAddressChange(getEIN(msg.sender), newRecoveryAddress, false);\n', '    }\n', '\n', '    /// @notice Allows providers to change the recovery address for an Identity.\n', '    /// @dev Recovery addresses can be changed at most once every recoveryTimeout seconds.\n', '    /// @param ein The EIN to set the recovery address of.\n', '    /// @param newRecoveryAddress A recovery address to set for the passed EIN.\n', '    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) public _isProviderFor(ein) {\n', '        triggerRecoveryAddressChange(ein, newRecoveryAddress, true);\n', '    }\n', '\n', '    /// @dev Common logic for all recovery address changes.\n', '    function triggerRecoveryAddressChange(uint ein, address newRecoveryAddress, bool delegated) private {\n', '        Identity storage _identity = identityDirectory[ein];\n', '\n', '        require(canChangeRecoveryAddress(ein), "Cannot trigger a change in recovery address yet.");\n', '\n', '         // solium-disable-next-line security/no-block-members\n', '        recoveryAddressChangeLogs[ein] = RecoveryAddressChange(block.timestamp, _identity.recoveryAddress);\n', '\n', '        emit RecoveryAddressChangeTriggered(msg.sender, ein, _identity.recoveryAddress, newRecoveryAddress, delegated);\n', '\n', '        _identity.recoveryAddress = newRecoveryAddress;\n', '    }\n', '\n', '    /// @notice Allows recovery addresses to trigger the recovery process for an Identity.\n', '    /// @dev msg.sender must be current recovery address, or the old one if it was changed recently.\n', '    /// @param ein The EIN to trigger recovery for.\n', '    /// @param newAssociatedAddress A recovery address to set for the passed EIN.\n', '    /// @param v The v component of the signature.\n', '    /// @param r The r component of the signature.\n', '    /// @param s The s component of the signature.\n', '    /// @param timestamp The timestamp of the signature.\n', '    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\n', '        public _identityExists(ein) _hasIdentity(newAssociatedAddress, false) ensureSignatureTimeValid(timestamp)\n', '    {\n', '        require(canRecover(ein), "Cannot trigger recovery yet.");\n', '        Identity storage _identity = identityDirectory[ein];\n', '\n', '        // ensure the sender is the recovery address/old recovery address if there&#39;s been a recent change\n', '        if (canChangeRecoveryAddress(ein)) {\n', '            require(\n', '                msg.sender == _identity.recoveryAddress, "Only the current recovery address can trigger recovery."\n', '            );\n', '        } else {\n', '            require(\n', '                msg.sender == recoveryAddressChangeLogs[ein].oldRecoveryAddress,\n', '                "Only the recently removed recovery address can trigger recovery."\n', '            );\n', '        }\n', '\n', '        require(\n', '            isSigned(\n', '                newAssociatedAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize being added to this Identity via recovery.",\n', '                        ein, newAssociatedAddress, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        // log the old associated addresses to facilitate destruction if necessary\n', '        recoveryLogs[ein] = Recovery(\n', '            block.timestamp, // solium-disable-line security/no-block-members\n', '            keccak256(abi.encodePacked(_identity.associatedAddresses.members))\n', '        );\n', '\n', '        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);\n', '\n', '        // remove identity data, and add the new address as the sole associated address\n', '        resetIdentityData(_identity, msg.sender, false);\n', '        addAssociatedAddress(ein, newAssociatedAddress);\n', '    }\n', '\n', '    /// @notice Allows associated addresses recently removed via recovery to permanently disable their old Identity.\n', '    /// @param ein The EIN to trigger destruction of.\n', '    /// @param firstChunk The array of addresses before the msg.sender in the pre-recovery associated addresses array.\n', '    /// @param lastChunk The array of addresses after the msg.sender in the pre-recovery associated addresses array.\n', '    /// @param resetResolvers true if the destroyer wants resolvers to be removed, false otherwise.\n', '    function triggerDestruction(uint ein, address[] memory firstChunk, address[] memory lastChunk, bool resetResolvers)\n', '        public _identityExists(ein)\n', '    {\n', '        require(!canRecover(ein), "Recovery has not recently been triggered.");\n', '        Identity storage _identity = identityDirectory[ein];\n', '\n', '        // ensure that the msg.sender was an old associated address for the referenced identity\n', '        address payable[1] memory middleChunk = [msg.sender];\n', '        require(\n', '            keccak256(\n', '                abi.encodePacked(firstChunk, middleChunk, lastChunk)\n', '            ) == recoveryLogs[ein].hashedOldAssociatedAddresses,\n', '            "Cannot destroy an EIN from an address that was not recently removed from said EIN via recovery."\n', '        );\n', '\n', '        emit IdentityDestroyed(msg.sender, ein, _identity.recoveryAddress, resetResolvers);\n', '\n', '        resetIdentityData(_identity, address(0), resetResolvers);\n', '    }\n', '\n', '    /// @dev Common logic for clearing the data of an Identity.\n', '    function resetIdentityData(Identity storage identity, address newRecoveryAddress, bool resetResolvers) private {\n', '        for (uint i; i < identity.associatedAddresses.members.length; i++) {\n', '            delete associatedAddressDirectory[identity.associatedAddresses.members[i]];\n', '        }\n', '        delete identity.associatedAddresses;\n', '        delete identity.providers;\n', '        if (resetResolvers) delete identity.resolvers;\n', '        identity.recoveryAddress = newRecoveryAddress;\n', '    }\n', '\n', '\n', '    // Events //////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '    event IdentityCreated(\n', '        address indexed initiator, uint indexed ein,\n', '        address recoveryAddress, address associatedAddress, address[] providers, address[] resolvers, bool delegated\n', '    );\n', '    event AssociatedAddressAdded(\n', '        address indexed initiator, uint indexed ein, address approvingAddress, address addedAddress, bool delegated\n', '    );\n', '    event AssociatedAddressRemoved(address indexed initiator, uint indexed ein, address removedAddress, bool delegated);\n', '    event ProviderAdded(address indexed initiator, uint indexed ein, address provider, bool delegated);\n', '    event ProviderRemoved(address indexed initiator, uint indexed ein, address provider, bool delegated);\n', '    event ResolverAdded(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\n', '    event ResolverRemoved(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\n', '    event RecoveryAddressChangeTriggered(\n', '        address indexed initiator, uint indexed ein,\n', '        address oldRecoveryAddress, address newRecoveryAddress, bool delegated\n', '    );\n', '    event RecoveryTriggered(\n', '        address indexed initiator, uint indexed ein, address[] oldAssociatedAddresses, address newAssociatedAddress\n', '    );\n', '    event IdentityDestroyed(address indexed initiator, uint indexed ein, address recoveryAddress, bool resolversReset);\n', '}']