['pragma solidity ^0.4.24;\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/// @notice Standard interface for `RegulatorService`s\n', 'contract RegulatorServiceI {\n', '\n', '  /*\n', '   * @notice This method *MUST* be called by `RegulatedToken`s during `transfer()` and `transferFrom()`.\n', '   *         The implementation *SHOULD* check whether or not a transfer can be approved.\n', '   *\n', '   * @dev    This method *MAY* call back to the token contract specified by `_token` for\n', '   *         more information needed to enforce trade approval.\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return uint8 The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *               to assign meaning.\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title  On-chain RegulatorService implementation for approving trades\n', ' * @author Originally Bob Remeika, modified by TokenSoft Inc\n', ' * @dev Orignal source: https://github.com/harborhq/r-token/blob/master/contracts/TokenRegulatorService.sol\n', ' */\n', 'contract RegulatorService is RegulatorServiceI, Ownable {\n', '  /**\n', '   * @dev Throws if called by any account other than the admin\n', '   */\n', '  modifier onlyAdmins() {\n', '    require(msg.sender == admin || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /// @dev Settings that affect token trading at a global level\n', '  struct Settings {\n', '\n', '    /**\n', '     * @dev Toggle for locking/unlocking trades at a token level.\n', '     *      The default behavior of the zero memory state for locking will be unlocked.\n', '     */\n', '    bool locked;\n', '\n', '    /**\n', '     * @dev Toggle for allowing/disallowing fractional token trades at a token level.\n', '     *      The default state when this contract is created `false` (or no partial\n', '     *      transfers allowed).\n', '     */\n', '    bool partialTransfers;\n', '  }\n', '\n', '  // @dev Check success code & message\n', '  uint8 constant private CHECK_SUCCESS = 0;\n', '  string constant private SUCCESS_MESSAGE = &#39;Success&#39;;\n', '\n', '  // @dev Check error reason: Token is locked\n', '  uint8 constant private CHECK_ELOCKED = 1;\n', '  string constant private ELOCKED_MESSAGE = &#39;Token is locked&#39;;\n', '\n', '  // @dev Check error reason: Token can not trade partial amounts\n', '  uint8 constant private CHECK_EDIVIS = 2;\n', '  string constant private EDIVIS_MESSAGE = &#39;Token can not trade partial amounts&#39;;\n', '\n', '  // @dev Check error reason: Sender is not allowed to send the token\n', '  uint8 constant private CHECK_ESEND = 3;\n', '  string constant private ESEND_MESSAGE = &#39;Sender is not allowed to send the token&#39;;\n', '\n', '  // @dev Check error reason: Receiver is not allowed to receive the token\n', '  uint8 constant private CHECK_ERECV = 4;\n', '  string constant private ERECV_MESSAGE = &#39;Receiver is not allowed to receive the token&#39;;\n', '\n', '  /// @dev Permission bits for allowing a participant to send tokens\n', '  uint8 constant private PERM_SEND = 0x1;\n', '\n', '  /// @dev Permission bits for allowing a participant to receive tokens\n', '  uint8 constant private PERM_RECEIVE = 0x2;\n', '\n', '  // @dev Address of the administrator\n', '  address public admin;\n', '\n', '  /// @notice Permissions that allow/disallow token trades on a per token level\n', '  mapping(address => Settings) private settings;\n', '\n', '  /// @dev Permissions that allow/disallow token trades on a per participant basis.\n', '  ///      The format for key based access is `participants[tokenAddress][participantAddress]`\n', '  ///      which returns the permission bits of a participant for a particular token.\n', '  mapping(address => mapping(address => uint8)) private participants;\n', '\n', '  /// @dev Event raised when a token&#39;s locked setting is set\n', '  event LogLockSet(address indexed token, bool locked);\n', '\n', '  /// @dev Event raised when a token&#39;s partial transfer setting is set\n', '  event LogPartialTransferSet(address indexed token, bool enabled);\n', '\n', '  /// @dev Event raised when a participant permissions are set for a token\n', '  event LogPermissionSet(address indexed token, address indexed participant, uint8 permission);\n', '\n', '  /// @dev Event raised when the admin address changes\n', '  event LogTransferAdmin(address indexed oldAdmin, address indexed newAdmin);\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the ability to trade a token\n', '   *\n', '   * @dev    This method can only be called by this contract&#39;s owner\n', '   *\n', '   * @param  _token The address of the token to lock\n', '   */\n', '  function setLocked(address _token, bool _locked) onlyOwner public {\n', '    settings[_token].locked = _locked;\n', '\n', '    emit LogLockSet(_token, _locked);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the ability to trade a fraction of a token\n', '   *\n', '   * @dev    This method can only be called by this contract&#39;s owner\n', '   *\n', '   * @param  _token The address of the token to allow partial transfers\n', '   */\n', '  function setPartialTransfers(address _token, bool _enabled) onlyOwner public {\n', '   settings[_token].partialTransfers = _enabled;\n', '\n', '   emit LogPartialTransferSet(_token, _enabled);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the trade permissions for a participant on a token\n', '   *\n', '   * @dev    The `_permission` bits overwrite the previous trade permissions and can\n', '   *         only be called by the contract&#39;s owner.  `_permissions` can be bitwise\n', '   *         `|`&#39;d together to allow for more than one permission bit to be set.\n', '   *\n', '   * @param  _token The address of the token\n', '   * @param  _participant The address of the trade participant\n', '   * @param  _permission Permission bits to be set\n', '   */\n', '  function setPermission(address _token, address _participant, uint8 _permission) onlyAdmins public {\n', '    participants[_token][_participant] = _permission;\n', '\n', '    emit LogPermissionSet(_token, _participant, _permission);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to transfer admin controls to newAdmin.\n', '   *\n', '   * @param newAdmin The address to transfer admin rights to.\n', '   */\n', '  function transferAdmin(address newAdmin) onlyOwner public {\n', '    require(newAdmin != address(0));\n', '\n', '    address oldAdmin = admin;\n', '    admin = newAdmin;\n', '\n', '    emit LogTransferAdmin(oldAdmin, newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether or not a trade should be approved\n', '   *\n', '   * @dev    This method calls back to the token contract specified by `_token` for\n', '   *         information needed to enforce trade approval if needed\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token (unused in this implementation)\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return `true` if the trade should be approved and `false` if the trade should not be approved\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8) {\n', '    if (settings[_token].locked) {\n', '      return CHECK_ELOCKED;\n', '    }\n', '\n', '    if (participants[_token][_from] & PERM_SEND == 0) {\n', '      return CHECK_ESEND;\n', '    }\n', '\n', '    if (participants[_token][_to] & PERM_RECEIVE == 0) {\n', '      return CHECK_ERECV;\n', '    }\n', '\n', '    if (!settings[_token].partialTransfers && _amount % _wholeToken(_token) != 0) {\n', '      return CHECK_EDIVIS;\n', '    }\n', '\n', '    return CHECK_SUCCESS;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the error message for a passed failed check reason\n', '   *\n', '   * @param  _reason The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *                 to assign meaning.\n', '   *\n', '   * @return The human-readable mesage string\n', '   */\n', '  function messageForReason (uint8 _reason) public pure returns (string) {\n', '    if (_reason == CHECK_ELOCKED) {\n', '      return ELOCKED_MESSAGE;\n', '    }\n', '    \n', '    if (_reason == CHECK_ESEND) {\n', '      return ESEND_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_ERECV) {\n', '      return ERECV_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_EDIVIS) {\n', '      return EDIVIS_MESSAGE;\n', '    }\n', '\n', '    return SUCCESS_MESSAGE;\n', '  }\n', '\n', '  /**\n', '   * @notice Retrieves the whole token value from a token that this `RegulatorService` manages\n', '   *\n', '   * @param  _token The token address of the managed token\n', '   *\n', '   * @return The uint256 value that represents a single whole token\n', '   */\n', '  function _wholeToken(address _token) view private returns (uint256) {\n', '    return uint256(10)**DetailedERC20(_token).decimals();\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/// @notice Standard interface for `RegulatorService`s\n', 'contract RegulatorServiceI {\n', '\n', '  /*\n', '   * @notice This method *MUST* be called by `RegulatedToken`s during `transfer()` and `transferFrom()`.\n', '   *         The implementation *SHOULD* check whether or not a transfer can be approved.\n', '   *\n', '   * @dev    This method *MAY* call back to the token contract specified by `_token` for\n', '   *         more information needed to enforce trade approval.\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return uint8 The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *               to assign meaning.\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title  On-chain RegulatorService implementation for approving trades\n', ' * @author Originally Bob Remeika, modified by TokenSoft Inc\n', ' * @dev Orignal source: https://github.com/harborhq/r-token/blob/master/contracts/TokenRegulatorService.sol\n', ' */\n', 'contract RegulatorService is RegulatorServiceI, Ownable {\n', '  /**\n', '   * @dev Throws if called by any account other than the admin\n', '   */\n', '  modifier onlyAdmins() {\n', '    require(msg.sender == admin || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /// @dev Settings that affect token trading at a global level\n', '  struct Settings {\n', '\n', '    /**\n', '     * @dev Toggle for locking/unlocking trades at a token level.\n', '     *      The default behavior of the zero memory state for locking will be unlocked.\n', '     */\n', '    bool locked;\n', '\n', '    /**\n', '     * @dev Toggle for allowing/disallowing fractional token trades at a token level.\n', '     *      The default state when this contract is created `false` (or no partial\n', '     *      transfers allowed).\n', '     */\n', '    bool partialTransfers;\n', '  }\n', '\n', '  // @dev Check success code & message\n', '  uint8 constant private CHECK_SUCCESS = 0;\n', "  string constant private SUCCESS_MESSAGE = 'Success';\n", '\n', '  // @dev Check error reason: Token is locked\n', '  uint8 constant private CHECK_ELOCKED = 1;\n', "  string constant private ELOCKED_MESSAGE = 'Token is locked';\n", '\n', '  // @dev Check error reason: Token can not trade partial amounts\n', '  uint8 constant private CHECK_EDIVIS = 2;\n', "  string constant private EDIVIS_MESSAGE = 'Token can not trade partial amounts';\n", '\n', '  // @dev Check error reason: Sender is not allowed to send the token\n', '  uint8 constant private CHECK_ESEND = 3;\n', "  string constant private ESEND_MESSAGE = 'Sender is not allowed to send the token';\n", '\n', '  // @dev Check error reason: Receiver is not allowed to receive the token\n', '  uint8 constant private CHECK_ERECV = 4;\n', "  string constant private ERECV_MESSAGE = 'Receiver is not allowed to receive the token';\n", '\n', '  /// @dev Permission bits for allowing a participant to send tokens\n', '  uint8 constant private PERM_SEND = 0x1;\n', '\n', '  /// @dev Permission bits for allowing a participant to receive tokens\n', '  uint8 constant private PERM_RECEIVE = 0x2;\n', '\n', '  // @dev Address of the administrator\n', '  address public admin;\n', '\n', '  /// @notice Permissions that allow/disallow token trades on a per token level\n', '  mapping(address => Settings) private settings;\n', '\n', '  /// @dev Permissions that allow/disallow token trades on a per participant basis.\n', '  ///      The format for key based access is `participants[tokenAddress][participantAddress]`\n', '  ///      which returns the permission bits of a participant for a particular token.\n', '  mapping(address => mapping(address => uint8)) private participants;\n', '\n', "  /// @dev Event raised when a token's locked setting is set\n", '  event LogLockSet(address indexed token, bool locked);\n', '\n', "  /// @dev Event raised when a token's partial transfer setting is set\n", '  event LogPartialTransferSet(address indexed token, bool enabled);\n', '\n', '  /// @dev Event raised when a participant permissions are set for a token\n', '  event LogPermissionSet(address indexed token, address indexed participant, uint8 permission);\n', '\n', '  /// @dev Event raised when the admin address changes\n', '  event LogTransferAdmin(address indexed oldAdmin, address indexed newAdmin);\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the ability to trade a token\n', '   *\n', "   * @dev    This method can only be called by this contract's owner\n", '   *\n', '   * @param  _token The address of the token to lock\n', '   */\n', '  function setLocked(address _token, bool _locked) onlyOwner public {\n', '    settings[_token].locked = _locked;\n', '\n', '    emit LogLockSet(_token, _locked);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the ability to trade a fraction of a token\n', '   *\n', "   * @dev    This method can only be called by this contract's owner\n", '   *\n', '   * @param  _token The address of the token to allow partial transfers\n', '   */\n', '  function setPartialTransfers(address _token, bool _enabled) onlyOwner public {\n', '   settings[_token].partialTransfers = _enabled;\n', '\n', '   emit LogPartialTransferSet(_token, _enabled);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the trade permissions for a participant on a token\n', '   *\n', '   * @dev    The `_permission` bits overwrite the previous trade permissions and can\n', "   *         only be called by the contract's owner.  `_permissions` can be bitwise\n", "   *         `|`'d together to allow for more than one permission bit to be set.\n", '   *\n', '   * @param  _token The address of the token\n', '   * @param  _participant The address of the trade participant\n', '   * @param  _permission Permission bits to be set\n', '   */\n', '  function setPermission(address _token, address _participant, uint8 _permission) onlyAdmins public {\n', '    participants[_token][_participant] = _permission;\n', '\n', '    emit LogPermissionSet(_token, _participant, _permission);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to transfer admin controls to newAdmin.\n', '   *\n', '   * @param newAdmin The address to transfer admin rights to.\n', '   */\n', '  function transferAdmin(address newAdmin) onlyOwner public {\n', '    require(newAdmin != address(0));\n', '\n', '    address oldAdmin = admin;\n', '    admin = newAdmin;\n', '\n', '    emit LogTransferAdmin(oldAdmin, newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether or not a trade should be approved\n', '   *\n', '   * @dev    This method calls back to the token contract specified by `_token` for\n', '   *         information needed to enforce trade approval if needed\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token (unused in this implementation)\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return `true` if the trade should be approved and `false` if the trade should not be approved\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8) {\n', '    if (settings[_token].locked) {\n', '      return CHECK_ELOCKED;\n', '    }\n', '\n', '    if (participants[_token][_from] & PERM_SEND == 0) {\n', '      return CHECK_ESEND;\n', '    }\n', '\n', '    if (participants[_token][_to] & PERM_RECEIVE == 0) {\n', '      return CHECK_ERECV;\n', '    }\n', '\n', '    if (!settings[_token].partialTransfers && _amount % _wholeToken(_token) != 0) {\n', '      return CHECK_EDIVIS;\n', '    }\n', '\n', '    return CHECK_SUCCESS;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the error message for a passed failed check reason\n', '   *\n', '   * @param  _reason The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *                 to assign meaning.\n', '   *\n', '   * @return The human-readable mesage string\n', '   */\n', '  function messageForReason (uint8 _reason) public pure returns (string) {\n', '    if (_reason == CHECK_ELOCKED) {\n', '      return ELOCKED_MESSAGE;\n', '    }\n', '    \n', '    if (_reason == CHECK_ESEND) {\n', '      return ESEND_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_ERECV) {\n', '      return ERECV_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_EDIVIS) {\n', '      return EDIVIS_MESSAGE;\n', '    }\n', '\n', '    return SUCCESS_MESSAGE;\n', '  }\n', '\n', '  /**\n', '   * @notice Retrieves the whole token value from a token that this `RegulatorService` manages\n', '   *\n', '   * @param  _token The token address of the managed token\n', '   *\n', '   * @return The uint256 value that represents a single whole token\n', '   */\n', '  function _wholeToken(address _token) view private returns (uint256) {\n', '    return uint256(10)**DetailedERC20(_token).decimals();\n', '  }\n', '}']
