['pragma solidity 0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract IRegistry {\n', '    function add(address who) public;\n', '}\n', '\n', '\n', 'contract IUniswapExchange {\n', '    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 timestamp) public payable returns (uint256);\n', '}\n', '\n', '\n', 'contract IGovernance {\n', '    function proposeWithFeeRecipient(address feeRecipient, address target, bytes memory data) public returns (uint);\n', '    function proposalFee() public view returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath::mul: Integer overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath::div: Invalid divisor zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath::sub: Integer underflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath::add: Integer overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath::mod: Invalid divisor zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title HumanityApplicant\n', ' * @dev Convenient interface for applying to the Humanity registry.\n', ' */\n', 'contract HumanityApplicant {\n', '    using SafeMath for uint;\n', '\n', '    IGovernance public governance;\n', '    IRegistry public registry;\n', '    IERC20 public humanity;\n', '\n', '    constructor(IGovernance _governance, IRegistry _registry, IERC20 _humanity) public {\n', '        governance = _governance;\n', '        registry = _registry;\n', '        humanity = _humanity;\n', '        humanity.approve(address(governance), uint(-1));\n', '    }\n', '\n', '    function applyFor(address who) public returns (uint) {\n', '        uint fee = governance.proposalFee();\n', '        uint balance = humanity.balanceOf(address(this));\n', '        if (fee > balance) {\n', '            require(humanity.transferFrom(msg.sender, address(this), fee.sub(balance)), "HumanityApplicant::applyFor: Transfer failed");\n', '        }\n', '        bytes memory data = abi.encodeWithSelector(registry.add.selector, who);\n', '        return governance.proposeWithFeeRecipient(msg.sender, address(registry), data);\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title PayableHumanityApplicant\n', ' * @dev Convenient interface for applying to the Humanity registry using Ether.\n', ' */\n', 'contract PayableHumanityApplicant is HumanityApplicant {\n', '\n', '    IUniswapExchange public exchange;\n', '\n', '    constructor(IGovernance _governance, IRegistry _registry, IERC20 _humanity, IUniswapExchange _exchange) public\n', '        HumanityApplicant(_governance, _registry, _humanity)\n', '    {\n', '        exchange = _exchange;\n', '    }\n', '\n', '    function () external payable {}\n', '\n', '    function applyWithEtherFor(address who) public payable returns (uint) {\n', '        // Exchange Ether for Humanity tokens\n', '        uint fee = governance.proposalFee();\n', '        exchange.ethToTokenSwapOutput.value(msg.value)(fee, block.timestamp);\n', '\n', '        // Apply to the registry\n', '        uint proposalId = applyFor(who);\n', '\n', '        // Refund any remaining balance\n', '        msg.sender.send(address(this).balance);\n', '\n', '        return proposalId;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title TwitterHumanityApplicant\n', ' * @dev Convenient interface for applying to the Humanity registry using Twitter as proof of identity.\n', ' */\n', 'contract TwitterHumanityApplicant is PayableHumanityApplicant {\n', '\n', '    event Apply(uint indexed proposalId, address indexed applicant, string username);\n', '\n', '    constructor(\n', '        IGovernance _governance,\n', '        IRegistry _registry,\n', '        IERC20 _humanity,\n', '        IUniswapExchange _exchange\n', '    ) public\n', '        PayableHumanityApplicant(_governance, _registry, _humanity, _exchange) {}\n', '\n', '    function applyWithTwitter(string memory username) public returns (uint) {\n', '        return applyWithTwitterFor(msg.sender, username);\n', '    }\n', '\n', '    function applyWithTwitterFor(address who, string memory username) public returns (uint) {\n', '        uint proposalId = applyFor(who);\n', '        emit Apply(proposalId, who, username);\n', '        return proposalId;\n', '    }\n', '\n', '    function applyWithTwitterUsingEther(string memory username) public payable returns (uint) {\n', '        return applyWithTwitterUsingEtherFor(msg.sender, username);\n', '    }\n', '\n', '    function applyWithTwitterUsingEtherFor(address who, string memory username) public payable returns (uint) {\n', '        uint proposalId = applyWithEtherFor(who);\n', '        emit Apply(proposalId, who, username);\n', '        return proposalId;\n', '    }\n', '\n', '}']