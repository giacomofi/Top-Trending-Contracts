['pragma solidity 0.4.23;\n', '\n', '/**\n', ' * @title Access Control List (Lightweight version)\n', ' *\n', ' * @dev Access control smart contract provides an API to check\n', ' *      if specific operation is permitted globally and\n', ' *      if particular user has a permission to execute it.\n', ' * @dev This smart contract is designed to be inherited by other\n', ' *      smart contracts which require access control management capabilities.\n', ' *\n', ' * @author Basil Gorin\n', ' */\n', 'contract AccessControlLight {\n', '  /// @notice Role manager is responsible for assigning the roles\n', '  /// @dev Role ROLE_ROLE_MANAGER allows modifying operator roles\n', '  uint256 private constant ROLE_ROLE_MANAGER = 0x10000000;\n', '\n', '  /// @notice Feature manager is responsible for enabling/disabling\n', '  ///      global features of the smart contract\n', '  /// @dev Role ROLE_FEATURE_MANAGER allows modifying global features\n', '  uint256 private constant ROLE_FEATURE_MANAGER = 0x20000000;\n', '\n', '  /// @dev Bitmask representing all the possible permissions (super admin role)\n', '  uint256 private constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /// @dev A bitmask of globally enabled features\n', '  uint256 public features;\n', '\n', '  /// @notice Privileged addresses with defined roles/permissions\n', '  /// @notice In the context of ERC20/ERC721 tokens these can be permissions to\n', '  ///      allow minting tokens, transferring on behalf and so on\n', '  /// @dev Maps an address to the permissions bitmask (role), where each bit\n', '  ///      represents a permission\n', '  /// @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n', '  ///      represents all possible permissions\n', '  mapping(address => uint256) public userRoles;\n', '\n', '  /// @dev Fired in updateFeatures()\n', '  event FeaturesUpdated(address indexed _by, uint256 _requested, uint256 _actual);\n', '\n', '  /// @dev Fired in updateRole()\n', '  event RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n', '\n', '  /**\n', '   * @dev Creates an access control instance,\n', '   *      setting contract creator to have full privileges\n', '   */\n', '  constructor() public {\n', '    // contract creator has full privileges\n', '    userRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n', '  }\n', '\n', '  /**\n', '   * @dev Updates set of the globally enabled features (`features`),\n', "   *      taking into account sender's permissions.=\n", '   * @dev Requires transaction sender to have `ROLE_FEATURE_MANAGER` permission.\n', '   * @param mask bitmask representing a set of features to enable/disable\n', '   */\n', '  function updateFeatures(uint256 mask) public {\n', '    // caller must have a permission to update global features\n', '    require(isSenderInRole(ROLE_FEATURE_MANAGER));\n', '\n', '    // evaluate new features set and assign them\n', '    features = evaluateBy(msg.sender, features, mask);\n', '\n', '    // fire an event\n', '    emit FeaturesUpdated(msg.sender, mask, features);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates set of permissions (role) for a given operator,\n', "   *      taking into account sender's permissions.\n", '   * @dev Setting role to zero is equivalent to removing an operator.\n', '   * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n', '   *      copying senders permissions (role) to an operator.\n', '   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\n', '   * @param operator address of an operator to alter permissions for\n', '   * @param role bitmask representing a set of permissions to\n', '   *      enable/disable for an operator specified\n', '   */\n', '  function updateRole(address operator, uint256 role) public {\n', '    // caller must have a permission to update user roles\n', '    require(isSenderInRole(ROLE_ROLE_MANAGER));\n', '\n', '    // evaluate the role and reassign it\n', '    userRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n', '\n', '    // fire an event\n', '    emit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n', '  }\n', '\n', '  /**\n', '   * @dev Based on the actual role provided (set of permissions), operator address,\n', '   *      and role required (set of permissions), calculate the resulting\n', '   *      set of permissions (role).\n', '   * @dev If operator is super admin and has full permissions (FULL_PRIVILEGES_MASK),\n', '   *      the function will always return `required` regardless of the `actual`.\n', '   * @dev In contrast, if operator has no permissions at all (zero mask),\n', '   *      the function will always return `actual` regardless of the `required`.\n', '   * @param operator address of the contract operator to use permissions of\n', '   * @param actual input set of permissions to modify\n', '   * @param required desired set of permissions operator would like to have\n', '   * @return resulting set of permissions this operator can set\n', '   */\n', '  function evaluateBy(address operator, uint256 actual, uint256 required) public constant returns(uint256) {\n', "    // read operator's permissions\n", '    uint256 p = userRoles[operator];\n', '\n', "    // taking into account operator's permissions,\n", '    // 1) enable permissions requested on the `current`\n', '    actual |= p & required;\n', '    // 2) disable permissions requested on the `current`\n', '    actual &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ required));\n', '\n', '    // return calculated result (actual is not modified)\n', '    return actual;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if requested set of features is enabled globally on the contract\n', '   * @param required set of features to check\n', '   * @return true if all the features requested are enabled, false otherwise\n', '   */\n', '  function isFeatureEnabled(uint256 required) public constant returns(bool) {\n', '    // delegate call to `__hasRole`, passing `features` property\n', '    return __hasRole(features, required);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if transaction sender `msg.sender` has all the permissions (role) required\n', '   * @param required set of permissions (role) to check\n', '   * @return true if all the permissions requested are enabled, false otherwise\n', '   */\n', '  function isSenderInRole(uint256 required) public constant returns(bool) {\n', '    // delegate call to `isOperatorInRole`, passing transaction sender\n', '    return isOperatorInRole(msg.sender, required);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if operator `operator` has all the permissions (role) required\n', '   * @param required set of permissions (role) to check\n', '   * @return true if all the permissions requested are enabled, false otherwise\n', '   */\n', '  function isOperatorInRole(address operator, uint256 required) public constant returns(bool) {\n', "    // delegate call to `__hasRole`, passing operator's permissions (role)\n", '    return __hasRole(userRoles[operator], required);\n', '  }\n', '\n', '  /// @dev Checks if role `actual` contains all the permissions required `required`\n', '  function __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\n', '    // check the bitmask for the role required and return the result\n', '    return actual & required == required;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Address Utils\n', ' *\n', ' * @dev Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * @notice Checks if the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *      as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    // a variable to load `extcodesize` to\n', '    uint256 size = 0;\n', '\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n', '    // TODO: Check this again before the Serenity release, because all addresses will be contracts.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      // retrieve the size of the code at address `addr`\n', '      size := extcodesize(addr)\n', '    }\n', '\n', '    // positive size indicates a smart contract address\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 token receiver interface\n', ' *\n', ' * @dev Interface for any contract that wants to support safe transfers\n', ' *      from ERC20 token smart contracts.\n', ' * @dev Inspired by ERC721 and ERC223 token standards\n', ' *\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' * @dev See https://github.com/ethereum/EIPs/issues/223\n', ' *\n', ' * @author Basil Gorin\n', ' */\n', 'interface ERC20Receiver {\n', '  /**\n', '   * @notice Handle the receipt of a ERC20 token(s)\n', '   * @dev The ERC20 smart contract calls this function on the recipient\n', '   *      after a successful transfer (`safeTransferFrom`).\n', '   *      This function MAY throw to revert and reject the transfer.\n', '   *      Return of other than the magic value MUST result in the transaction being reverted.\n', '   * @notice The contract address is always the message sender.\n', '   *      A wallet/broker/auction application MUST implement the wallet interface\n', '   *      if it will accept safe transfers.\n', '   * @param _operator The address which called `safeTransferFrom` function\n', '   * @param _from The address which previously owned the token\n', '   * @param _value amount of tokens which is being transferred\n', '   * @param _data additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC20Received(address,address,uint256,bytes)"))` unless throwing\n', '   */\n', '  function onERC20Received(address _operator, address _from, uint256 _value, bytes _data) external returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @title Gold Smart Contract\n', ' *\n', ' * @notice Gold is a transferable fungible entity (ERC20 token)\n', ' *      used to "pay" for in game services like gem upgrades, etc.\n', ' * @notice Gold is a part of Gold/Silver system, which allows to\n', ' *      upgrade gems (level, grade, etc.)\n', ' *\n', ' * @dev Gold is mintable and burnable entity,\n', ' *      meaning it can be created or destroyed by the authorized addresses\n', ' * @dev An address authorized can mint/burn its own tokens (own balance) as well\n', ' *      as tokens owned by another address (additional permission level required)\n', ' *\n', ' * @author Basil Gorin\n', ' */\n', 'contract GoldERC20 is AccessControlLight {\n', '  /**\n', '   * @dev Smart contract version\n', '   * @dev Should be incremented manually in this source code\n', '   *      each time smart contact source code is changed and deployed\n', '   * @dev To distinguish from other tokens must be multiple of 0x100\n', '   */\n', '  uint32 public constant TOKEN_VERSION = 0x300;\n', '\n', '  /**\n', '   * @notice ERC20 symbol of that token (short name)\n', '   */\n', '  string public constant symbol = "GLD";\n', '\n', '  /**\n', '   * @notice ERC20 name of the token (long name)\n', '   */\n', '  string public constant name = "GOLD - CryptoMiner World";\n', '\n', '  /**\n', '   * @notice ERC20 decimals (number of digits to draw after the dot\n', '   *    in the UI applications (like MetaMask, other wallets and so on)\n', '   */\n', '  uint8 public constant decimals = 3;\n', '\n', '  /**\n', '   * @notice Based on the value of decimals above, one token unit\n', '   *      represents native number of tokens which is displayed\n', '   *      in the UI applications as one (1 or 1.0, 1.00, etc.)\n', '   */\n', '  uint256 public constant ONE_UNIT = uint256(10) ** decimals;\n', '\n', '  /**\n', '   * @notice A record of all the players token balances\n', '   * @dev This mapping keeps record of all token owners\n', '   */\n', '  mapping(address => uint256) private tokenBalances;\n', '\n', '  /**\n', '   * @notice Total amount of tokens tracked by this smart contract\n', '   * @dev Equal to sum of all token balances `tokenBalances`\n', '   */\n', '  uint256 private tokensTotal;\n', '\n', '  /**\n', '   * @notice A record of all the allowances to spend tokens on behalf\n', '   * @dev Maps token owner address to an address approved to spend\n', '   *      some tokens on behalf, maps approved address to that amount\n', '   */\n', '  mapping(address => mapping(address => uint256)) private transferAllowances;\n', '\n', '  /**\n', '   * @notice Enables ERC20 transfers of the tokens\n', '   *      (transfer by the token owner himself)\n', '   * @dev Feature FEATURE_TRANSFERS must be enabled to\n', '   *      call `transfer()` function\n', '   */\n', '  uint32 public constant FEATURE_TRANSFERS = 0x00000001;\n', '\n', '  /**\n', '   * @notice Enables ERC20 transfers on behalf\n', '   *      (transfer by someone else on behalf of token owner)\n', '   * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled to\n', '   *      call `transferFrom()` function\n', '   * @dev Token owner must call `approve()` first to authorize\n', '   *      the transfer on behalf\n', '   */\n', '  uint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x00000002;\n', '\n', '  /**\n', '   * @notice Token creator is responsible for creating (minting)\n', '   *      tokens to some player address\n', '   * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n', '   *      (calling `mint` and `mintTo` functions)\n', '   */\n', '  uint32 public constant ROLE_TOKEN_CREATOR = 0x00000001;\n', '\n', '  /**\n', '   * @notice Token destroyer is responsible for destroying (burning)\n', '   *      tokens owned by some player address\n', '   * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n', '   *      (calling `burn` and `burnFrom` functions)\n', '   */\n', '  uint32 public constant ROLE_TOKEN_DESTROYER = 0x00000002;\n', '\n', '  /**\n', '   * @dev Magic value to be returned by ERC20Receiver upon successful reception of token(s)\n', '   * @dev Equal to `bytes4(keccak256("onERC20Received(address,address,uint256,bytes)"))`,\n', '   *      which can be also obtained as `ERC20Receiver(0).onERC20Received.selector`\n', '   */\n', '  bytes4 private constant ERC20_RECEIVED = 0x4fc35859;\n', '\n', '  /**\n', '   * @dev Fired in transfer() and transferFrom() functions\n', '   * @param _from an address which performed the transfer\n', '   * @param _to an address tokens were sent to\n', '   * @param _value number of tokens transferred\n', '   */\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * @dev Fired in approve() function\n', '   * @param _owner an address which granted a permission to transfer\n', '   *      tokens on its behalf\n', '   * @param _spender an address which received a permission to transfer\n', '   *      tokens on behalf of the owner `_owner`\n', '   */\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  /**\n', '   * @dev Fired in mint() function\n', '   * @param _by an address which minted some tokens (transaction sender)\n', '   * @param _to an address the tokens were minted to\n', '   * @param _value an amount of tokens minted\n', '   */\n', '  event Minted(address indexed _by, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * @dev Fired in burn() function\n', '   * @param _by an address which burned some tokens (transaction sender)\n', '   * @param _from an address the tokens were burnt from\n', '   * @param _value an amount of tokens burnt\n', '   */\n', '  event Burnt(address indexed _by, address indexed _from, uint256 _value);\n', '\n', '  /**\n', '   * @notice Total number of tokens tracked by this smart contract\n', '   * @dev Equal to sum of all token balances\n', '   * @return total number of tokens\n', '   */\n', '  function totalSupply() public constant returns (uint256) {\n', '    // read total tokens value and return\n', '    return tokensTotal;\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the balance of particular address\n', '   * @dev Gets the balance of the specified address\n', '   * @param _owner the address to query the the balance for\n', '   * @return an amount of tokens owned by the address specified\n', '   */\n', '  function balanceOf(address _owner) public constant returns (uint256) {\n', '    // read the balance from storage and return\n', '    return tokenBalances[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev A function to check an amount of tokens owner approved\n', '   *      to transfer on its behalf by some other address called "spender"\n', '   * @param _owner an address which approves transferring some tokens on its behalf\n', '   * @param _spender an address approved to transfer some tokens on behalf\n', '   * @return an amount of tokens approved address `_spender` can transfer on behalf\n', '   *      of token owner `_owner`\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '    // read the value from storage and return\n', '    return transferAllowances[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers some tokens to an address `_to`\n', '   * @dev Called by token owner (an address which has a\n', '   *      positive token balance tracked by this smart contract)\n', '   * @dev Throws on any error like\n', '   *      * incorrect `_value` (zero) or\n', '   *      * insufficient token balance or\n', '   *      * incorrect `_to` address:\n', '   *          * zero address or\n', '   *          * self address or\n', "   *          * smart contract which doesn't support ERC20\n", '   * @param _to an address to transfer tokens to,\n', '   *      must be either an external address or a smart contract,\n', '   *      compliant with the ERC20 standard\n', '   * @param _value amount of tokens to be transferred, must\n', '   *      be greater than zero\n', '   * @return true on success, throws otherwise\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    // just delegate call to `transferFrom`,\n', '    // `FEATURE_TRANSFERS` is verified inside it\n', '    return transferFrom(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', "   * @notice Transfers some tokens on behalf of address `_from' (token owner)\n", '   *      to some other address `_to`\n', '   * @dev Called by token owner on his own or approved address,\n', '   *      an address approved earlier by token owner to\n', '   *      transfer some amount of tokens on its behalf\n', '   * @dev Throws on any error like\n', '   *      * incorrect `_value` (zero) or\n', '   *      * insufficient token balance or\n', '   *      * incorrect `_to` address:\n', '   *          * zero address or\n', '   *          * same as `_from` address (self transfer)\n', "   *          * smart contract which doesn't support ERC20\n", '   * @param _from token owner which approved caller (transaction sender)\n', '   *      to transfer `_value` of tokens on its behalf\n', '   * @param _to an address to transfer tokens to,\n', '   *      must be either an external address or a smart contract,\n', '   *      compliant with the ERC20 standard\n', '   * @param _value amount of tokens to be transferred, must\n', '   *      be greater than zero\n', '   * @return true on success, throws otherwise\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    // just delegate call to `safeTransferFrom`, passing empty `_data`,\n', '    // `FEATURE_TRANSFERS` is verified inside it\n', '    safeTransferFrom(_from, _to, _value, "");\n', '\n', '    // `safeTransferFrom` throws of any error, so\n', "    // if we're here - it means operation successful,\n", '    // just return true\n', '    return true;\n', '  }\n', '\n', '  /**\n', "   * @notice Transfers some tokens on behalf of address `_from' (token owner)\n", '   *      to some other address `_to`\n', '   * @dev Inspired by ERC721 safeTransferFrom, this function allows to\n', '   *      send arbitrary data to the receiver on successful token transfer\n', '   * @dev Called by token owner on his own or approved address,\n', '   *      an address approved earlier by token owner to\n', '   *      transfer some amount of tokens on its behalf\n', '   * @dev Throws on any error like\n', '   *      * incorrect `_value` (zero) or\n', '   *      * insufficient token balance or\n', '   *      * incorrect `_to` address:\n', '   *          * zero address or\n', '   *          * same as `_from` address (self transfer)\n', "   *          * smart contract which doesn't support ERC20Receiver interface\n", '   * @param _from token owner which approved caller (transaction sender)\n', '   *      to transfer `_value` of tokens on its behalf\n', '   * @param _to an address to transfer tokens to,\n', '   *      must be either an external address or a smart contract,\n', '   *      compliant with the ERC20 standard\n', '   * @param _value amount of tokens to be transferred, must\n', '   *      be greater than zero\n', '   * @param _data [optional] additional data with no specified format,\n', '   *      sent in onERC20Received call to `_to` in case if its a smart contract\n', '   * @return true on success, throws otherwise\n', '   */\n', '  function safeTransferFrom(address _from, address _to, uint256 _value, bytes _data) public {\n', '    // first delegate call to `unsafeTransferFrom`\n', '    // to perform the unsafe token(s) transfer\n', '    unsafeTransferFrom(_from, _to, _value);\n', '\n', '    // after the successful transfer – check if receiver supports\n', '    // ERC20Receiver and execute a callback handler `onERC20Received`,\n', '    // reverting whole transaction on any error:\n', '    // check if receiver `_to` supports ERC20Receiver interface\n', '    if (AddressUtils.isContract(_to)) {\n', '      // if `_to` is a contract – execute onERC20Received\n', '      bytes4 response = ERC20Receiver(_to).onERC20Received(msg.sender, _from, _value, _data);\n', '\n', '      // expected response is ERC20_RECEIVED\n', '      require(response == ERC20_RECEIVED);\n', '    }\n', '  }\n', '\n', '  /**\n', "   * @notice Transfers some tokens on behalf of address `_from' (token owner)\n", '   *      to some other address `_to`\n', "   * @dev In contrast to `safeTransferFrom` doesn't check recipient\n", '   *      smart contract to support ERC20 tokens (ERC20Receiver)\n', '   * @dev Designed to be used by developers when the receiver is known\n', "   *      to support ERC20 tokens but doesn't implement ERC20Receiver interface\n", '   * @dev Called by token owner on his own or approved address,\n', '   *      an address approved earlier by token owner to\n', '   *      transfer some amount of tokens on its behalf\n', '   * @dev Throws on any error like\n', '   *      * incorrect `_value` (zero) or\n', '   *      * insufficient token balance or\n', '   *      * incorrect `_to` address:\n', '   *          * zero address or\n', '   *          * same as `_from` address (self transfer)\n', '   * @param _from token owner which approved caller (transaction sender)\n', '   *      to transfer `_value` of tokens on its behalf\n', '   * @param _to an address to transfer tokens to,\n', '   *      must be either an external address or a smart contract,\n', '   *      compliant with the ERC20 standard\n', '   * @param _value amount of tokens to be transferred, must\n', '   *      be greater than zero\n', '   * @return true on success, throws otherwise\n', '   */\n', '  function unsafeTransferFrom(address _from, address _to, uint256 _value) public {\n', '    // if `_from` is equal to sender, require transfers feature to be enabled\n', '    // otherwise require transfers on behalf feature to be enabled\n', '    require(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n', '         || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF));\n', '\n', '    // non-zero to address check\n', '    require(_to != address(0));\n', '\n', '    // sender and recipient cannot be the same\n', '    require(_from != _to);\n', '\n', '    // zero value transfer check\n', '    require(_value != 0);\n', '\n', '    // by design of mint() -\n', '    // - no need to make arithmetic overflow check on the _value\n', '\n', '    // in case of transfer on behalf\n', '    if(_from != msg.sender) {\n', '      // verify sender has an allowance to transfer amount of tokens requested\n', '      require(transferAllowances[_from][msg.sender] >= _value);\n', '\n', '      // decrease the amount of tokens allowed to transfer\n', '      transferAllowances[_from][msg.sender] -= _value;\n', '    }\n', '\n', '    // verify sender has enough tokens to transfer on behalf\n', '    require(tokenBalances[_from] >= _value);\n', '\n', '    // perform the transfer:\n', '    // decrease token owner (sender) balance\n', '    tokenBalances[_from] -= _value;\n', '\n', '    // increase `_to` address (receiver) balance\n', '    tokenBalances[_to] += _value;\n', '\n', '    // emit an ERC20 transfer event\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @notice Approves address called "spender" to transfer some amount\n', '   *      of tokens on behalf of the owner\n', '   * @dev Caller must not necessarily own any tokens to grant the permission\n', '   * @param _spender an address approved by the caller (token owner)\n', '   *      to spend some tokens on its behalf\n', '   * @param _value an amount of tokens spender `_spender` is allowed to\n', '   *      transfer on behalf of the token owner\n', '   * @return true on success, throws otherwise\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    // perform an operation: write value requested into the storage\n', '    transferAllowances[msg.sender][_spender] = _value;\n', '\n', '    // emit an event\n', '    emit Approval(msg.sender, _spender, _value);\n', '\n', '    // operation successful, return true\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Mints (creates) some tokens to address specified\n', '   * @dev The value passed is treated as number of units (see `ONE_UNIT`)\n', '   *      to achieve natural impression on token quantity\n', '   * @dev Requires sender to have `ROLE_TOKEN_CREATOR` permission\n', '   * @param _to an address to mint tokens to\n', '   * @param _value an amount of tokens to mint (create)\n', '   */\n', '  function mint(address _to, uint256 _value) public {\n', '    // calculate native value, taking into account `decimals`\n', '    uint256 value = _value * ONE_UNIT;\n', '\n', '    // arithmetic overflow and non-zero value check\n', '    require(value > _value);\n', '\n', '    // delegate call to native `mintNative`\n', '    mintNative(_to, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints (creates) some tokens to address specified\n', '   * @dev The value specified is treated as is without taking\n', '   *      into account what `decimals` value is\n', '   * @dev Requires sender to have `ROLE_TOKEN_CREATOR` permission\n', '   * @param _to an address to mint tokens to\n', '   * @param _value an amount of tokens to mint (create)\n', '   */\n', '  function mintNative(address _to, uint256 _value) public {\n', '    // check if caller has sufficient permissions to mint tokens\n', '    require(isSenderInRole(ROLE_TOKEN_CREATOR));\n', '\n', '    // non-zero recipient address check\n', '    require(_to != address(0));\n', '\n', '    // non-zero _value and arithmetic overflow check on the total supply\n', '    // this check automatically secures arithmetic overflow on the individual balance\n', '    require(tokensTotal + _value > tokensTotal);\n', '\n', '    // increase `_to` address balance\n', '    tokenBalances[_to] += _value;\n', '\n', '    // increase total amount of tokens value\n', '    tokensTotal += _value;\n', '\n', '    // fire ERC20 compliant transfer event\n', '    emit Transfer(address(0), _to, _value);\n', '\n', '    // fire a mint event\n', '    emit Minted(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns (destroys) some tokens from the address specified\n', '   * @dev The value passed is treated as number of units (see `ONE_UNIT`)\n', '   *      to achieve natural impression on token quantity\n', '   * @dev Requires sender to have `ROLE_TOKEN_DESTROYER` permission\n', '   * @param _from an address to burn some tokens from\n', '   * @param _value an amount of tokens to burn (destroy)\n', '   */\n', '  function burn(address _from, uint256 _value) public {\n', '    // calculate native value, taking into account `decimals`\n', '    uint256 value = _value * ONE_UNIT;\n', '\n', '    // arithmetic overflow and non-zero value check\n', '    require(value > _value);\n', '\n', '    // delegate call to native `burnNative`\n', '    burnNative(_from, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns (destroys) some tokens from the address specified\n', '   * @dev The value specified is treated as is without taking\n', '   *      into account what `decimals` value is\n', '   * @dev Requires sender to have `ROLE_TOKEN_DESTROYER` permission\n', '   * @param _from an address to burn some tokens from\n', '   * @param _value an amount of tokens to burn (destroy)\n', '   */\n', '  function burnNative(address _from, uint256 _value) public {\n', '    // check if caller has sufficient permissions to burn tokens\n', '    require(isSenderInRole(ROLE_TOKEN_DESTROYER));\n', '\n', '    // non-zero burn value check\n', '    require(_value != 0);\n', '\n', '    // verify `_from` address has enough tokens to destroy\n', '    // (basically this is a arithmetic overflow check)\n', '    require(tokenBalances[_from] >= _value);\n', '\n', '    // decrease `_from` address balance\n', '    tokenBalances[_from] -= _value;\n', '\n', '    // decrease total amount of tokens value\n', '    tokensTotal -= _value;\n', '\n', '    // fire ERC20 compliant transfer event\n', '    emit Transfer(_from, address(0), _value);\n', '\n', '    // fire a burn event\n', '    emit Burnt(msg.sender, _from, _value);\n', '  }\n', '\n', '}']