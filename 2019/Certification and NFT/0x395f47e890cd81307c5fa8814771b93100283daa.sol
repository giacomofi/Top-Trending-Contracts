['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/helpers/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', ' * ownership control to OpenZeppelin&#39;s Ownable class. In this model, the original owner \n', ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public pendingOwner;\n', '\n', '\n', '    event OwnershipTransferred(\n', '      address indexed previousOwner,\n', '      address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Account is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "Account is not pending owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0), "Empty address");\n', '        pendingOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the pendingOwner address to finalize the transfer.\n', '    */\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/AllowanceSheet.sol\n', '\n', '/**\n', '* @title AllowanceSheet\n', '* @notice A wrapper around an allowance mapping. \n', '*/\n', 'contract AllowanceSheet is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowanceOf;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = _value;\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/BalanceSheet.sol\n', '\n', '/**\n', '* @title BalanceSheet\n', '* @notice A wrapper around the balanceOf mapping. \n', '*/\n', 'contract BalanceSheet is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    uint256 public totalSupply;\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = balanceOf[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = balanceOf[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/TokenStorage.sol\n', '\n', '/**\n', '* @title TokenStorage\n', '*/\n', 'contract TokenStorage {\n', '    /**\n', '        Storage\n', '    */\n', '    BalanceSheet public balances;\n', '    AllowanceSheet public allowances;\n', '\n', '\n', '    string public name;   //name of Token                \n', '    uint8  public decimals;        //decimals of Token        \n', '    string public symbol;   //Symbol of Token\n', '\n', '    /**\n', '    * @dev a TokenStorage consumer can set its storages only once, on construction\n', '    *\n', '    **/\n', '    constructor (address _balances, address _allowances, string _name, uint8 _decimals, string _symbol) public {\n', '        balances = BalanceSheet(_balances);\n', '        allowances = AllowanceSheet(_allowances);\n', '\n', '        name = _name;\n', '        decimals = _decimals;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    /**\n', '    * @dev claim ownership of balance sheet passed into constructor.\n', '    **/\n', '    function claimBalanceOwnership() public {\n', '        balances.claimOwnership();\n', '    }\n', '\n', '    /**\n', '    * @dev claim ownership of allowance sheet passed into constructor.\n', '    **/\n', '    function claimAllowanceOwnership() public {\n', '        allowances.claimOwnership();\n', '    }\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/Proxy.sol\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  function () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', '   * This is a low level function that doesn&#39;t return to its internal call site.\n', '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize)\n', '\n', '      // Call the implementation.\n', '      // out and outsize are 0 because we don&#39;t know the size yet.\n', '      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize)\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize) }\n', '      default { return(0, returndatasize) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() internal {\n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _implementation Address of the initial implementation.\n', '   */\n', '  constructor(address _implementation) public {\n', '    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));\n', '\n', '    _setImplementation(_implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) private {\n', '    require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/token/TokenProxy.sol\n', '\n', '/**\n', '* @title TokenProxy\n', '* @notice A proxy contract that serves the latest implementation of TokenProxy.\n', '*/\n', 'contract TokenProxy is UpgradeabilityProxy, TokenStorage, Ownable {\n', '    constructor(address _implementation, address _balances, address _allowances, string _name, uint8 _decimals, string _symbol) \n', '    UpgradeabilityProxy(_implementation) \n', '    TokenStorage(_balances, _allowances, _name, _decimals, _symbol) public {\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrade the backing implementation of the proxy.\n', '    * Only the admin can call this function.\n', '    * @param newImplementation Address of the new implementation.\n', '    */\n', '    function upgradeTo(address newImplementation) public onlyOwner {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '    * @return The address of the implementation.\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return _implementation();\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/helpers/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', " * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n", ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public pendingOwner;\n', '\n', '\n', '    event OwnershipTransferred(\n', '      address indexed previousOwner,\n', '      address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Account is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "Account is not pending owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0), "Empty address");\n', '        pendingOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the pendingOwner address to finalize the transfer.\n', '    */\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/AllowanceSheet.sol\n', '\n', '/**\n', '* @title AllowanceSheet\n', '* @notice A wrapper around an allowance mapping. \n', '*/\n', 'contract AllowanceSheet is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowanceOf;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowanceOf[_tokenHolder][_spender] = _value;\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/BalanceSheet.sol\n', '\n', '/**\n', '* @title BalanceSheet\n', '* @notice A wrapper around the balanceOf mapping. \n', '*/\n', 'contract BalanceSheet is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    uint256 public totalSupply;\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = balanceOf[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = balanceOf[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balanceOf[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '}\n', '\n', '// File: contracts/token/dataStorage/TokenStorage.sol\n', '\n', '/**\n', '* @title TokenStorage\n', '*/\n', 'contract TokenStorage {\n', '    /**\n', '        Storage\n', '    */\n', '    BalanceSheet public balances;\n', '    AllowanceSheet public allowances;\n', '\n', '\n', '    string public name;   //name of Token                \n', '    uint8  public decimals;        //decimals of Token        \n', '    string public symbol;   //Symbol of Token\n', '\n', '    /**\n', '    * @dev a TokenStorage consumer can set its storages only once, on construction\n', '    *\n', '    **/\n', '    constructor (address _balances, address _allowances, string _name, uint8 _decimals, string _symbol) public {\n', '        balances = BalanceSheet(_balances);\n', '        allowances = AllowanceSheet(_allowances);\n', '\n', '        name = _name;\n', '        decimals = _decimals;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    /**\n', '    * @dev claim ownership of balance sheet passed into constructor.\n', '    **/\n', '    function claimBalanceOwnership() public {\n', '        balances.claimOwnership();\n', '    }\n', '\n', '    /**\n', '    * @dev claim ownership of allowance sheet passed into constructor.\n', '    **/\n', '    function claimAllowanceOwnership() public {\n', '        allowances.claimOwnership();\n', '    }\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/Proxy.sol\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  function () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', "   * This is a low level function that doesn't return to its internal call site.\n", '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize)\n', '\n', '      // Call the implementation.\n', "      // out and outsize are 0 because we don't know the size yet.\n", '      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize)\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize) }\n', '      default { return(0, returndatasize) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() internal {\n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _implementation Address of the initial implementation.\n', '   */\n', '  constructor(address _implementation) public {\n', '    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));\n', '\n', '    _setImplementation(_implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) private {\n', '    require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/token/TokenProxy.sol\n', '\n', '/**\n', '* @title TokenProxy\n', '* @notice A proxy contract that serves the latest implementation of TokenProxy.\n', '*/\n', 'contract TokenProxy is UpgradeabilityProxy, TokenStorage, Ownable {\n', '    constructor(address _implementation, address _balances, address _allowances, string _name, uint8 _decimals, string _symbol) \n', '    UpgradeabilityProxy(_implementation) \n', '    TokenStorage(_balances, _allowances, _name, _decimals, _symbol) public {\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrade the backing implementation of the proxy.\n', '    * Only the admin can call this function.\n', '    * @param newImplementation Address of the new implementation.\n', '    */\n', '    function upgradeTo(address newImplementation) public onlyOwner {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '    * @return The address of the implementation.\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return _implementation();\n', '    }\n', '}']
