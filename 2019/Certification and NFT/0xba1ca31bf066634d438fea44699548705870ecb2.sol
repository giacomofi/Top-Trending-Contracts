['pragma solidity >=0.5.4<0.6.0;\n', '\n', 'contract ERC20Detailed {\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '\n', '  constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '    _name = name;\n', '    _symbol = symbol;\n', '    _decimals = decimals;\n', '  }\n', '\n', '  function name() public view returns (string memory) {\n', '    return _name;\n', '  }\n', '\n', '  function symbol() public view returns (string memory) {\n', '    return _symbol;\n', '  }\n', '\n', '  function decimals() public view returns (uint8) {\n', '    return _decimals;\n', '  }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20 is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) private _balances;\n', '\n', '  mapping(address => mapping(address => uint256)) private _allowed;\n', '\n', '  uint256 private _totalSupply;\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return _allowed[owner][spender];\n', '  }\n', '\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    _transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    _approve(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    _transfer(from, to, value);\n', '    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '    return true;\n', '  }\n', '\n', '  function _transfer(address from, address to, uint256 value) internal {\n', '    require(to != address(0));\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(from, to, value);\n', '  }\n', '\n', '  function _mint(address account, uint256 value) internal {\n', '    require(account != address(0));\n', '\n', '    _totalSupply = _totalSupply.add(value);\n', '    _balances[account] = _balances[account].add(value);\n', '    emit Transfer(address(0), account, value);\n', '  }\n', '\n', '  function _burn(address account, uint256 value) internal {\n', '    require(account != address(0));\n', '\n', '    _totalSupply = _totalSupply.sub(value);\n', '    _balances[account] = _balances[account].sub(value);\n', '    emit Transfer(account, address(0), value);\n', '  }\n', '\n', '  function _approve(address owner, address spender, uint256 value) internal {\n', '    require(spender != address(0));\n', '    require(owner != address(0));\n', '\n', '    _allowed[owner][spender] = value;\n', '    emit Approval(owner, spender, value);\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'library MultiSigAction {\n', '  struct Action {\n', '    uint8 actionType;\n', '    address callbackAddress;\n', '    string callbackSig;\n', '    bytes callbackData;\n', '    uint8 quorum;\n', '    address requestedBy;\n', '    address rejectedBy;\n', '    mapping(address => bool) approvedBy;\n', '    uint8 numOfApprovals;\n', '    bool rejected;\n', '    bool failed;\n', '  }\n', '\n', '  function init(\n', '    Action storage _self,\n', '    uint8 _actionType,\n', '    address _callbackAddress,\n', '    string memory _callbackSig,\n', '    bytes memory _callbackData,\n', '    uint8 _quorum\n', '  ) internal {\n', '    _self.actionType = _actionType;\n', '    _self.callbackAddress = _callbackAddress;\n', '    _self.callbackSig = _callbackSig;\n', '    _self.callbackData = _callbackData;\n', '    _self.quorum = _quorum;\n', '    _self.requestedBy = msg.sender;\n', '  }\n', '\n', '  function approve(Action storage _self) internal {\n', '    require(!_self.rejected, "CANNOT_APPROVE_REJECTED");\n', '    require(!_self.failed, "CANNOT_APPROVE_FAILED");\n', '    require(!_self.approvedBy[msg.sender], "CANNOT_APPROVE_AGAIN");\n', '    require(!isCompleted(_self), "CANNOT_APPROVE_COMPLETED");\n', '\n', '    _self.approvedBy[msg.sender] = true;\n', '    _self.numOfApprovals++;\n', '  }\n', '\n', '  function reject(Action storage _self) internal {\n', '    require(!_self.approvedBy[msg.sender], "CANNOT_REJECT_APPROVED");\n', '    require(!_self.failed, "CANNOT_REJECT_FAILED");\n', '    require(!_self.rejected, "CANNOT_REJECT_REJECTED");\n', '    require(!isCompleted(_self), "CANNOT_REJECT_COMPLETED");\n', '\n', '    _self.rejectedBy = msg.sender;\n', '    _self.rejected = true;\n', '  }\n', '\n', '  function complete(Action storage _self) internal {\n', '    require(!_self.rejected, "CANNOT_COMPLETE_REJECTED");\n', '    require(!_self.failed, "CANNOT_COMPLETE_FAILED");\n', '    require(isCompleted(_self), "CANNNOT_COMPLETE_AGAIN");\n', '\n', '    // solium-disable-next-line security/no-low-level-calls\n', '    (bool _success, ) = _self.callbackAddress.call(\n', '      abi.encodePacked(bytes4(keccak256(bytes(_self.callbackSig))), _self.callbackData)\n', '    );\n', '\n', '    if (!_success) {\n', '      _self.failed = true;\n', '    }\n', '  }\n', '\n', '  function isCompleted(Action storage _self) internal view returns (bool) {\n', '    return _self.numOfApprovals >= _self.quorum && !_self.failed;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Extended is Ownable, ERC20, ERC20Detailed {\n', '  constructor(string memory _name, string memory _symbol, uint8 _decimals)\n', '    public\n', '    ERC20Detailed(_name, _symbol, _decimals)\n', '  {}\n', '\n', '  function burn(uint256 _value) public onlyOwner returns (bool) {\n', '    _burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  function mint(address _to, uint256 _value) public onlyOwner returns (bool) {\n', '    _mint(_to, _value);\n', '\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract MultiSigAdministration {\n', '  event TenantRegistered(\n', '    address indexed tenant,\n', '    address[] creators,\n', '    address[] admins,\n', '    uint8 quorum\n', '  );\n', '  event ActionInitiated(address indexed tenant, uint256 indexed id, address initiatedBy);\n', '  event ActionApproved(address indexed tenant, uint256 indexed id, address approvedBy);\n', '  event ActionRejected(address indexed tenant, uint256 indexed id, address rejectedBy);\n', '  event ActionCompleted(address indexed tenant, uint256 indexed id);\n', '  event ActionFailed(address indexed tenant, uint256 indexed id);\n', '\n', '  using MultiSigAction for MultiSigAction.Action;\n', '\n', '  enum AdminAction {ADD_ADMIN, REMOVE_ADMIN, CHANGE_QUORUM, ADD_CREATOR, REMOVE_CREATOR}\n', '  uint8 private constant OTHER_ACTION = uint8(AdminAction.REMOVE_CREATOR) + 1;\n', '\n', '  mapping(address => uint256) public numOfActions;\n', '  mapping(address => mapping(address => bool)) public isAdmin;\n', '  mapping(address => uint8) public numOfAdmins;\n', '  mapping(address => mapping(address => bool)) public isCreator;\n', '  mapping(address => uint8) public quorums;\n', '  mapping(address => bool) public isRegistered;\n', '  mapping(address => uint256) public minValidActionId;\n', '\n', '  mapping(address => mapping(uint256 => MultiSigAction.Action)) private actions;\n', '\n', '  modifier onlyAdminOf(address _tenant) {\n', '    require(isAdmin[_tenant][msg.sender], "ONLY_ADMIN_OF_TENANT");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdminOrCreatorOf(address _tenant) {\n', '    require(\n', '      isAdmin[_tenant][msg.sender] || isCreator[_tenant][msg.sender],\n', '      "ONLY_ADMIN_OR_CREATOR_OF_TENANT"\n', '    );\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyRegistered(address _tenant) {\n', '    require(isRegistered[_tenant], "ONLY_REGISTERED_TENANT");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyMe() {\n', '    require(msg.sender == address(this), "ONLY_INTERNAL");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyExistingAction(address _tenant, uint256 _id) {\n', '    require(_id <= numOfActions[_tenant], "ONLY_EXISTING_ACTION");\n', '    require(_id > 0, "ONLY_EXISTING_ACTION");\n', '\n', '    _;\n', '  }\n', '\n', '  constructor() public {}\n', '\n', '  /* Public Functions - Start */\n', '  function register(\n', '    address _tenant,\n', '    address[] memory _creators,\n', '    address[] memory _admins,\n', '    uint8 _quorum\n', '  ) public returns (bool success) {\n', '    require(\n', '      msg.sender == _tenant || msg.sender == Ownable(_tenant).owner(),\n', '      "ONLY_TENANT_OR_TENANT_OWNER"\n', '    );\n', '\n', '    return _register(_tenant, _creators, _admins, _quorum);\n', '  }\n', '\n', '  function initiateAdminAction(\n', '    address _tenant,\n', '    AdminAction _adminAction,\n', '    bytes memory _callbackData\n', '  ) public onlyRegistered(_tenant) onlyAdminOf(_tenant) returns (uint256 id) {\n', '    string memory _callbackSig = _getAdminActionCallbackSig(_adminAction);\n', '\n', '    uint256 _id = _initiateAction(\n', '      uint8(_adminAction),\n', '      _tenant,\n', '      address(this),\n', '      _callbackSig,\n', '      abi.encodePacked(abi.encode(_tenant), _callbackData)\n', '    );\n', '    _approveAction(_tenant, _id);\n', '\n', '    return _id;\n', '  }\n', '\n', '  function initiateAction(address _tenant, string memory _callbackSig, bytes memory _callbackData)\n', '    public\n', '    onlyRegistered(_tenant)\n', '    onlyAdminOrCreatorOf(_tenant)\n', '    returns (uint256 id)\n', '  {\n', '    uint256 _id = _initiateAction(OTHER_ACTION, _tenant, _tenant, _callbackSig, _callbackData);\n', '\n', '    if (isAdmin[_tenant][msg.sender]) {\n', '      _approveAction(_tenant, _id);\n', '    }\n', '\n', '    return _id;\n', '  }\n', '\n', '  function approveAction(address _tenant, uint256 _id)\n', '    public\n', '    onlyRegistered(_tenant)\n', '    onlyAdminOf(_tenant)\n', '    onlyExistingAction(_tenant, _id)\n', '    returns (bool success)\n', '  {\n', '    return _approveAction(_tenant, _id);\n', '  }\n', '\n', '  function rejectAction(address _tenant, uint256 _id)\n', '    public\n', '    onlyRegistered(_tenant)\n', '    onlyAdminOrCreatorOf(_tenant)\n', '    onlyExistingAction(_tenant, _id)\n', '    returns (bool success)\n', '  {\n', '    return _rejectAction(_tenant, _id);\n', '  }\n', '\n', '  function addAdmin(address _tenant, address _admin, bool _increaseQuorum) public onlyMe {\n', '    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\n', '    _addAdmin(_tenant, _admin);\n', '\n', '    if (_increaseQuorum) {\n', '      uint8 _quorum = quorums[_tenant];\n', '      uint8 _newQuorum = _quorum + 1;\n', '      require(_newQuorum > _quorum, "OVERFLOW");\n', '\n', '      _changeQuorum(_tenant, _newQuorum);\n', '    }\n', '  }\n', '\n', '  function removeAdmin(address _tenant, address _admin, bool _decreaseQuorum) public onlyMe {\n', '    uint8 _quorum = quorums[_tenant];\n', '\n', '    if (_decreaseQuorum && _quorum > 1) {\n', '      _changeQuorum(_tenant, _quorum - 1);\n', '    }\n', '\n', '    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\n', '    _removeAdmin(_tenant, _admin);\n', '  }\n', '\n', '  function changeQuorum(address _tenant, uint8 _quorum) public onlyMe {\n', '    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\n', '    _changeQuorum(_tenant, _quorum);\n', '  }\n', '\n', '  function addCreator(address _tenant, address _creator) public onlyMe {\n', '    _addCreator(_tenant, _creator);\n', '  }\n', '\n', '  function removeCreator(address _tenant, address _creator) public onlyMe {\n', '    _removeCreator(_tenant, _creator);\n', '  }\n', '\n', '  function getAction(address _tenant, uint256 _id)\n', '    public\n', '    view\n', '    returns (\n', '    bool isAdminAction,\n', '    string memory callbackSig,\n', '    bytes memory callbackData,\n', '    uint8 quorum,\n', '    address requestedBy,\n', '    address rejectedBy,\n', '    uint8 numOfApprovals,\n', '    bool rejected,\n', '    bool failed,\n', '    bool completed,\n', '    bool valid\n', '  )\n', '  {\n', '    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\n', '\n', '    isAdminAction = _action.callbackAddress == address(this);\n', '    callbackSig = _action.callbackSig;\n', '    callbackData = _action.callbackData;\n', '    quorum = _action.quorum;\n', '    requestedBy = _action.requestedBy;\n', '    rejectedBy = _action.rejectedBy;\n', '    numOfApprovals = _action.numOfApprovals;\n', '    rejected = _action.rejected;\n', '    failed = _action.failed;\n', '    completed = _action.isCompleted();\n', '    valid = _isActionValid(_tenant, _id);\n', '  }\n', '\n', '  function hasApprovedBy(address _tenant, uint256 _id, address _admin)\n', '    public\n', '    view\n', '    returns (bool approvedBy)\n', '  {\n', '    approvedBy = _getAction(_tenant, _id).approvedBy[_admin];\n', '  }\n', '  /* Public Functions - End */\n', '\n', '  /* Private Functions - Start */\n', '  function _getAction(address _tenant, uint256 _id)\n', '    private\n', '    view\n', '    returns (MultiSigAction.Action storage)\n', '  {\n', '    return actions[_tenant][_id];\n', '  }\n', '\n', '  function _isActionValid(address _tenant, uint256 _id) private view returns (bool) {\n', '    return _id >= minValidActionId[_tenant];\n', '  }\n', '\n', '  function _getAdminActionCallbackSig(AdminAction _adminAction)\n', '    private\n', '    pure\n', '    returns (string memory)\n', '  {\n', '    if (_adminAction == AdminAction.ADD_ADMIN) {\n', '      return "addAdmin(address,address,bool)";\n', '    }\n', '\n', '    if (_adminAction == AdminAction.REMOVE_ADMIN) {\n', '      return "removeAdmin(address,address,bool)";\n', '    }\n', '\n', '    if (_adminAction == AdminAction.CHANGE_QUORUM) {\n', '      return "changeQuorum(address,uint8)";\n', '    }\n', '\n', '    if (_adminAction == AdminAction.ADD_CREATOR) {\n', '      return "addCreator(address,address)";\n', '    }\n', '\n', '    return "removeCreator(address,address)";\n', '  }\n', '\n', '  function _addCreator(address _tenant, address _creator) private {\n', '    require(_creator != address(this), "INVALID_CREATOR");\n', '    require(!isAdmin[_tenant][_creator], "ALREADY_ADMIN");\n', '    require(!isCreator[_tenant][_creator], "ALREADY_CREATOR");\n', '\n', '    isCreator[_tenant][_creator] = true;\n', '  }\n', '\n', '  function _removeCreator(address _tenant, address _creator) private {\n', '    require(isCreator[_tenant][_creator], "NOT_CREATOR");\n', '\n', '    isCreator[_tenant][_creator] = false;\n', '  }\n', '\n', '  function _addAdmin(address _tenant, address _admin) private {\n', '    require(_admin != address(this), "INVALID_ADMIN");\n', '    require(!isAdmin[_tenant][_admin], "ALREADY_ADMIN");\n', '    require(!isCreator[_tenant][_admin], "ALREADY_CREATOR");\n', '    require(numOfAdmins[_tenant] + 1 > numOfAdmins[_tenant], "OVERFLOW");\n', '\n', '    numOfAdmins[_tenant]++;\n', '    isAdmin[_tenant][_admin] = true;\n', '  }\n', '\n', '  function _removeAdmin(address _tenant, address _admin) private {\n', '    require(isAdmin[_tenant][_admin], "NOT_ADMIN");\n', '    require(--numOfAdmins[_tenant] >= quorums[_tenant], "TOO_FEW_ADMINS");\n', '\n', '    isAdmin[_tenant][_admin] = false;\n', '  }\n', '\n', '  function _changeQuorum(address _tenant, uint8 _quorum) private {\n', '    require(_quorum <= numOfAdmins[_tenant], "QUORUM_TOO_BIG");\n', '    require(_quorum > 0, "QUORUM_ZERO");\n', '\n', '    quorums[_tenant] = _quorum;\n', '  }\n', '\n', '  function _register(\n', '    address _tenant,\n', '    address[] memory _creators,\n', '    address[] memory _admins,\n', '    uint8 _quorum\n', '  ) private returns (bool) {\n', '    require(_tenant != address(this), "INVALID_TENANT");\n', '    require(!isRegistered[_tenant], "ALREADY_REGISTERED");\n', '\n', '    for (uint8 i = 0; i < _admins.length; i++) {\n', '      _addAdmin(_tenant, _admins[i]);\n', '    }\n', '    _changeQuorum(_tenant, _quorum);\n', '\n', '    for (uint8 i = 0; i < _creators.length; i++) {\n', '      _addCreator(_tenant, _creators[i]);\n', '    }\n', '\n', '    isRegistered[_tenant] = true;\n', '    emit TenantRegistered(_tenant, _creators, _admins, _quorum);\n', '\n', '    return true;\n', '  }\n', '\n', '  function _initiateAction(\n', '    uint8 _actionType,\n', '    address _tenant,\n', '    address _callbackAddress,\n', '    string memory _callbackSig,\n', '    bytes memory _callbackData\n', '  ) private returns (uint256) {\n', '    uint256 _id = ++numOfActions[_tenant];\n', '    uint8 _quorum = quorums[_tenant];\n', '\n', '    if (_actionType == uint8(AdminAction.REMOVE_ADMIN)) {\n', '      require(numOfAdmins[_tenant] > 1, "TOO_FEW_ADMINS");\n', '\n', '      if (_quorum == numOfAdmins[_tenant] && _quorum > 2) {\n', '        _quorum = numOfAdmins[_tenant] - 1;\n', '      }\n', '    }\n', '\n', '    _getAction(_tenant, _id).init(\n', '      _actionType,\n', '      _callbackAddress,\n', '      _callbackSig,\n', '      _callbackData,\n', '      _quorum\n', '    );\n', '\n', '    emit ActionInitiated(_tenant, _id, msg.sender);\n', '\n', '    return _id;\n', '  }\n', '\n', '  function _approveAction(address _tenant, uint256 _id) private returns (bool) {\n', '    require(_isActionValid(_tenant, _id), "ACTION_INVALIDATED");\n', '\n', '    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\n', '    _action.approve();\n', '    emit ActionApproved(_tenant, _id, msg.sender);\n', '\n', '    if (_action.isCompleted()) {\n', '      _action.complete();\n', '\n', '      if (_action.failed) {\n', '        emit ActionFailed(_tenant, _id);\n', '      } else {\n', '        emit ActionCompleted(_tenant, _id);\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function _rejectAction(address _tenant, uint256 _id) private returns (bool) {\n', '    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\n', '\n', '    if (isCreator[_tenant][msg.sender]) {\n', '      require(msg.sender == _action.requestedBy, "CREATOR_REJECT_NOT_REQUESTOR");\n', '    }\n', '\n', '    if (_action.actionType == uint8(AdminAction.REMOVE_ADMIN)) {\n', '      (, address _admin, ) = abi.decode(_action.callbackData, (address, address, bool));\n', '\n', '      require(_admin != msg.sender, "CANNOT_REJECT_ITS_OWN_REMOVAL");\n', '    }\n', '\n', '    _action.reject();\n', '\n', '    emit ActionRejected(_tenant, _id, msg.sender);\n', '\n', '    return true;\n', '  }\n', '  /* Private Functions - End */\n', '}\n', '\n', 'contract MultiSigProxyOwner {\n', '  event BurnRequested(address indexed owner, uint256 value);\n', '  event BurnCanceled(address indexed owner);\n', '  event BurnMinSet(uint256 burnMin);\n', '\n', '  struct BurnRequest {\n', '    uint256 actionId;\n', '    uint256 value;\n', '  }\n', '\n', '  uint256 public burnMin;\n', '  mapping(address => BurnRequest) public burnRequests;\n', '\n', '  ERC20Extended private token;\n', '  MultiSigAdministration private multiSigAdmin;\n', '  address[] private creators;\n', '\n', '  modifier onlyMultiSigAdministration {\n', '    require(msg.sender == address(multiSigAdmin));\n', '\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address _token,\n', '    address _multiSigAdmin,\n', '    address[] memory _admins,\n', '    uint8 _quorum,\n', '    uint256 _burnMin\n', '  ) public {\n', '    token = ERC20Extended(_token);\n', '    multiSigAdmin = MultiSigAdministration(_multiSigAdmin);\n', '    burnMin = _burnMin;\n', '\n', '    creators.push(address(this));\n', '    multiSigAdmin.register(address(this), creators, _admins, _quorum);\n', '\n', '  }\n', '\n', '  function requestBurn(uint256 _value) public returns (bool) {\n', '    require(!_burnRequestExist(msg.sender), "BURN_REQUEST_EXISTS");\n', '    require(_value >= burnMin, "SMALLER_THAN_MIN_BURN_AMOUNT");\n', '\n', '    token.transferFrom(msg.sender, address(this), _value);\n', '    burnRequests[msg.sender].value = _value;\n', '    burnRequests[msg.sender].actionId = multiSigAdmin.initiateAction(\n', '      address(this),\n', '      "burn(address,uint256)",\n', '      abi.encode(msg.sender, _value)\n', '    );\n', '\n', '    emit BurnRequested(msg.sender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function cancelBurn() public returns (bool) {\n', '    uint256 _actionId = burnRequests[msg.sender].actionId;\n', '    uint256 _value = burnRequests[msg.sender].value;\n', '    _deleteBurnRequest(msg.sender);\n', '\n', '    // solium-disable-next-line security/no-low-level-calls\n', '    (bool _success, ) = address(multiSigAdmin).call(\n', '      abi.encodeWithSignature("rejectAction(address,uint256)", address(this), _actionId)\n', '    );\n', '    _success;\n', '    token.transfer(msg.sender, _value);\n', '\n', '    emit BurnCanceled(msg.sender);\n', '\n', '    return true;\n', '  }\n', '\n', '  function burn(address _owner, uint256 _value) public onlyMultiSigAdministration returns (bool) {\n', '    require(burnRequests[_owner].value == _value, "BURN_VALUE_MISMATCH");\n', '\n', '    _deleteBurnRequest(_owner);\n', '    token.burn(_value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function mint(address _to, uint256 _value) public onlyMultiSigAdministration returns (bool) {\n', '    return token.mint(_to, _value);\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyMultiSigAdministration returns (bool) {\n', '    token.transferOwnership(_newOwner);\n', '\n', '    return true;\n', '  }\n', '\n', '  function setBurnMin(uint256 _burnMin) public onlyMultiSigAdministration returns (bool) {\n', '    return _setBurnMin(_burnMin);\n', '  }\n', '\n', '  function _setBurnMin(uint256 _burnMin) internal returns (bool) {\n', '    burnMin = _burnMin;\n', '    emit BurnMinSet(_burnMin);\n', '\n', '    return true;\n', '  }\n', '\n', '  function _burnRequestExist(address _owner) internal view returns (bool) {\n', '    return burnRequests[_owner].actionId != 0;\n', '  }\n', '\n', '  function _deleteBurnRequest(address _owner) internal returns (bool) {\n', '    require(_burnRequestExist(_owner), "NO_BURN_REQUEST_EXISTS");\n', '\n', '    burnRequests[_owner].actionId = 0;\n', '    burnRequests[_owner].value = 0;\n', '\n', '    return true;\n', '  }\n', '}']