['pragma solidity ^0.5.2;\n', '\n', '\n', '/** @title A contract for issuing, redeeming and transfering Sila StableCoins\n', '  *\n', '  * @author www.silamoney.com\n', '  * Email: contact@silamoney.com\n', '  *\n', '  */\n', '\n', '/**Run\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', ' \n', 'library SafeMath{\n', '    \n', '    \n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  \n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    \n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '\n', '    \n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', ' \n', '   /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', ' \n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    \n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    \n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '  \n', '  \n', ' \n', '   /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  \n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  \n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '    \n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract hotOwner and ColdOwner, and provides authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', '\n', 'contract Ownable {\n', '    \n', '    // hot and cold wallet addresses\n', '    \n', '    address public hotOwner=0xCd39203A332Ff477a35dA3AD2AD7761cDBEAb7F0;\n', '\n', '    address public coldOwner=0x1Ba688e70bb4F3CB266b8D721b5597bFbCCFF957;\n', '    \n', '    \n', '    //events\n', '    \n', '    event OwnershipTransferred(address indexed _newHotOwner,address indexed _newColdOwner,address indexed _oldColdOwner);\n', '\n', '\n', '    /**\n', '   * @dev Reverts if called by any account other than the hotOwner.\n', '   */\n', '   \n', '    modifier onlyHotOwner() {\n', '        require(msg.sender == hotOwner);\n', '        _;\n', '    }\n', '    \n', '     /**\n', '   * @dev Reverts if called by any account other than the coldOwner.\n', '   */\n', '    \n', '    modifier onlyColdOwner() {\n', '        require(msg.sender == coldOwner);\n', '        _;\n', '    }\n', '    \n', '     /**\n', '   * @dev Function assigns new hotowner and coldOwner\n', '   * @param _newHotOwner address The address which owns the funds.\n', '   * @param _newColdOwner address The address which can change the hotOwner.\n', '   */\n', '    \n', '    function transferOwnership(address _newHotOwner,address _newColdOwner) public onlyColdOwner returns (bool) {\n', '        require(_newHotOwner != address(0));\n', '        require(_newColdOwner!= address(0));\n', '        hotOwner = _newHotOwner;\n', '        coldOwner = _newColdOwner;\n', '        emit OwnershipTransferred(_newHotOwner,_newColdOwner,msg.sender);\n', '        return true;\n', '        \n', '        \n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Authorizable\n', ' * @dev The Authorizable contract can be used to authorize addresses to control silatoken main functions\n', ' * functions, this will provide more flexibility in terms of signing trasactions\n', ' */\n', '\n', 'contract Authorizable is Ownable {\n', '    \n', '    //map to check if the address is authorized to issue, redeem sila\n', '    mapping(address => bool) authorized;\n', '    \n', '    //events for when address is added or removed\n', '    event AuthorityAdded(address indexed _toAdd);\n', '    event AuthorityRemoved(address indexed _toRemove);\n', '    \n', '    //array of authorized address to check for all the authorized addresses\n', '    address[] public authorizedAddresses;\n', '\n', '    \n', '    modifier onlyAuthorized() {\n', '        require(authorized[msg.sender] || hotOwner == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    \n', '     \n', '     /**\n', '   * @dev Function addAuthorized adds addresses that can issue,redeem and transfer silas\n', '   * @param _toAdd address of the added authority\n', '   */\n', '\n', '    function addAuthorized(address _toAdd) onlyHotOwner public returns(bool) {\n', '        require(_toAdd != address(0));\n', '        require(!authorized[_toAdd]);\n', '        authorized[_toAdd] = true;\n', '        authorizedAddresses.push(_toAdd);\n', '        emit AuthorityAdded(_toAdd);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '   * @dev Function RemoveAuthorized removes addresses that can issue and redeem silas\n', '   * @param _toRemove address of the added authority\n', '   */\n', '\n', '    function removeAuthorized(address _toRemove,uint _toRemoveIndex) onlyHotOwner public returns(bool) {\n', '        require(_toRemove != address(0));\n', '        require(authorized[_toRemove]);\n', '        authorized[_toRemove] = false;\n', '        authorizedAddresses[_toRemoveIndex] = authorizedAddresses[authorizedAddresses.length-1];\n', '        authorizedAddresses.pop();\n', '        emit AuthorityRemoved(_toRemove);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    // view all the authorized addresses\n', '    function viewAuthorized() external view returns(address[] memory _authorizedAddresses){\n', '        return authorizedAddresses;\n', '    }\n', '    \n', '    \n', '    // check if the address is authorized\n', '    \n', '    function isAuthorized(address _authorized) external view returns(bool _isauthorized){\n', '        return authorized[_authorized];\n', '    }\n', '    \n', '    \n', '  \n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title EmergencyToggle\n', ' * @dev The EmergencyToggle contract provides a way to pause the contract in emergency\n', ' */\n', '\n', 'contract EmergencyToggle is Ownable{\n', '     \n', '    //variable to pause the entire contract if true\n', '    bool public emergencyFlag; \n', '\n', '    //constructor\n', '    constructor () public{\n', '      emergencyFlag = false;                            \n', '      \n', '    }\n', '  \n', '  \n', '   /**\n', '    * @dev onlyHotOwner can can pause the usage of issue,redeem, transfer functions\n', '    */\n', '    \n', '    function emergencyToggle() external onlyHotOwner{\n', '      emergencyFlag = !emergencyFlag;\n', '    }\n', '\n', '    \n', ' \n', ' }\n', ' \n', ' /**\n', ' * @title  Token is Betalist,Blacklist\n', ' */\n', ' contract Betalist is Authorizable,EmergencyToggle{\n', '     \n', '    //maps for betalisted and blacklisted addresses\n', '    mapping(address=>bool) betalisted;\n', '    mapping(address=>bool) blacklisted;\n', '\n', '    //events for betalist and blacklist\n', '    event BetalistedAddress (address indexed _betalisted);\n', '    event BlacklistedAddress (address indexed _blacklisted);\n', '    event RemovedFromBlacklist(address indexed _toRemoveBlacklist);\n', '    event RemovedFromBetalist(address indexed _toRemoveBetalist);\n', '    \n', '    //variable to check if betalist is required when calling several functions on smart contract\n', '    bool public requireBetalisted;\n', '\n', '\n', '    //constructor\n', '    constructor () public{\n', '        requireBetalisted=true;\n', '        \n', '    }\n', '    \n', '    \n', '   /**\n', '  * @dev betaList the specified address\n', '  * @param _toBetalist the address to betalist\n', '  */\n', '    function betalistAddress(address _toBetalist) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_toBetalist != address(0));\n', '        require(!blacklisted[_toBetalist]);\n', '        require(!betalisted[_toBetalist]);\n', '        betalisted[_toBetalist]=true;\n', '        emit BetalistedAddress(_toBetalist);\n', '        return true;\n', '        \n', '    }\n', '    \n', '     /**\n', '  * @dev remove from betaList the specified address\n', '  * @param _toRemoveBetalist The address to be removed\n', '  */\n', '    function removeAddressFromBetalist(address _toRemoveBetalist) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_toRemoveBetalist != address(0));\n', '        require(betalisted[_toRemoveBetalist]);\n', '        betalisted[_toRemoveBetalist]=false;\n', '        emit RemovedFromBetalist(_toRemoveBetalist);\n', '        return true;\n', '        \n', '    }\n', '    \n', '      \n', '    /**\n', '  * @dev blackList the specified address\n', '  * @param _toBlacklist The address to blacklist\n', '  */\n', '    function blacklistAddress(address _toBlacklist) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_toBlacklist != address(0));\n', '        require(!blacklisted[_toBlacklist]);\n', '        blacklisted[_toBlacklist]=true;\n', '        emit RemovedFromBlacklist(_toBlacklist);\n', '        return true;\n', '        \n', '    }\n', '    \n', '     /**\n', '  * @dev remove from blackList the specified address\n', '  * @param _toRemoveBlacklist The address to blacklist\n', '  */\n', '    function removeAddressFromBlacklist(address _toRemoveBlacklist) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_toRemoveBlacklist != address(0));\n', '        require(blacklisted[_toRemoveBlacklist]);\n', '        blacklisted[_toRemoveBlacklist]=false;\n', '        emit RemovedFromBlacklist(_toRemoveBlacklist);\n', '        return true;\n', '        \n', '    }\n', ' \n', '      /**\n', '  * @dev check the specified address if isBetaListed\n', '  * @param _betalisted The address to transfer to.\n', '  */\n', '    function isBetaListed(address _betalisted) external view returns(bool){\n', '            return (betalisted[_betalisted]);\n', '    }\n', '    \n', '     \n', '      /**\n', '  * @dev check the specified address isBlackListed\n', '  * @param _blacklisted The address to transfer to.\n', '  */\n', '    function isBlackListed(address _blacklisted) external view returns(bool){\n', '        return (blacklisted[_blacklisted]);\n', '        \n', '    }\n', '    \n', '    \n', '}\n', '\n', '/**\n', ' * @title  Token is token Interface\n', ' */\n', '\n', 'contract Token{\n', '    \n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/**\n', ' *@title StandardToken\n', ' *@dev Implementation of the basic standard token.\n', ' */\n', '\n', 'contract StandardToken is Token,Betalist{\n', '  using SafeMath for uint256;\n', '\n', '  mapping (address => uint256)  balances;\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  \n', '  uint256 public totalSupply;\n', '\n', '\n', ' \n', '  \n', '  \n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '  }\n', '\n', '  \n', '  \n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  \n', '  function allowance(address _owner,address _spender)public view returns (uint256){\n', '        return allowed[_owner][_spender];\n', '  }\n', '\n', ' \n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  \n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(!emergencyFlag);\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '    if (requireBetalisted){\n', '        require(betalisted[_to]);\n', '        require(betalisted[msg.sender]);\n', '    }\n', '    require(!blacklisted[msg.sender]);\n', '    require(!blacklisted[_to]);\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '\n', '  }\n', '  \n', '  \n', '    /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * @param _value The amount of tokens to be spent.\n', '   */\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    require(!emergencyFlag);\n', '    if (requireBetalisted){\n', '        require(betalisted[msg.sender]);\n', '        require(betalisted[_spender]);\n', '    }\n', '    require(!blacklisted[msg.sender]);\n', '    require(!blacklisted[_spender]);\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '\n', '  }\n', '  \n', '  \n', '    /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '\n', '  function transferFrom(address _from,address _to,uint256 _value)public returns (bool){\n', '    require(!emergencyFlag);\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '    if (requireBetalisted){\n', '        require(betalisted[_to]);\n', '        require(betalisted[_from]);\n', '        require(betalisted[msg.sender]);\n', '    }\n', '    require(!blacklisted[_to]);\n', '    require(!blacklisted[_from]);\n', '    require(!blacklisted[msg.sender]);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '    \n', '  }\n', '\n', '}\n', '\n', 'contract AssignOperator is StandardToken{\n', '    \n', '    //mappings\n', '    \n', '    mapping(address=>mapping(address=>bool)) isOperator;\n', '    \n', '    \n', '    //Events\n', '    event AssignedOperator (address indexed _operator,address indexed _for);\n', '    event OperatorTransfer (address indexed _developer,address indexed _from,address indexed _to,uint _amount);\n', '    event RemovedOperator  (address indexed _operator,address indexed _for);\n', '    \n', '    \n', '    /**\n', '   * @dev AssignedOperator to transfer tokens on users behalf\n', '   * @param _developer address The address which is allowed to transfer tokens on users behalf\n', '   * @param _user address The address which developer want to transfer from\n', '   */\n', '    \n', '    function assignOperator(address _developer,address _user) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_developer != address(0));\n', '        require(_user != address(0));\n', '        require(!isOperator[_developer][_user]);\n', '        if(requireBetalisted){\n', '            require(betalisted[_user]);\n', '            require(betalisted[_developer]);\n', '        }\n', '        require(!blacklisted[_developer]);\n', '        require(!blacklisted[_user]);\n', '        isOperator[_developer][_user]=true;\n', '        emit AssignedOperator(_developer,_user);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '   * @dev RemoveOperator allowed to transfer tokens on users behalf\n', '   * @param _developer address The address which is allowed to trasnfer tokens on users behalf\n', '   * @param _user address The address which developer want to transfer from\n', '   */\n', '    function removeOperator(address _developer,address _user) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_developer != address(0));\n', '        require(_user != address(0));\n', '        require(isOperator[_developer][_user]);\n', '        isOperator[_developer][_user]=false;\n', '        emit RemovedOperator(_developer,_user);\n', '        return true;\n', '        \n', '    }\n', '    \n', '    /**\n', '   * @dev Operatransfer for developer to transfer tokens on users behalf without requiring ethers in managed  ethereum accounts\n', '   * @param _from address the address to transfer tokens from\n', '   * @param _to address The address which developer want to transfer to\n', '   * @param _amount the amount of tokens user wants to transfer\n', '   */\n', '    \n', '    function operatorTransfer(address _from,address _to,uint _amount) public returns (bool){\n', '        require(!emergencyFlag);\n', '        require(isOperator[msg.sender][_from]);\n', '        require(_amount <= balances[_from]);\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        if (requireBetalisted){\n', '            require(betalisted[_to]);\n', '            require(betalisted[_from]);\n', '            require(betalisted[msg.sender]);\n', '        }\n', '        require(!blacklisted[_to]);\n', '        require(!blacklisted[_from]);\n', '        require(!blacklisted[msg.sender]);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit OperatorTransfer(msg.sender,_from, _to, _amount);\n', '        emit Transfer(_from,_to,_amount);\n', '        return true;\n', '        \n', '        \n', '    }\n', '    \n', '     /**\n', '   * @dev checkIsOperator is developer an operator allowed to transfer tokens on users behalf\n', '   * @param _developer the address allowed to trasnfer tokens \n', '   * @param _for address The address which developer want to transfer from\n', '   */\n', '    \n', '    function checkIsOperator(address _developer,address _for) external view returns (bool){\n', '            return (isOperator[_developer][_for]);\n', '    }\n', '\n', '    \n', '}\n', '\n', '\n', '\n', ' /**\n', ' *@title SilaToken\n', ' *@dev Implementation for sila issue,redeem,protectedTransfer and batch functions\n', ' */\n', '\n', 'contract SilaToken is AssignOperator{\n', '    using SafeMath for uint256;\n', '    \n', '    // parameters for silatoken\n', '    string  public constant name = "SilaToken";\n', '    string  public constant symbol = "SILA";\n', '    uint256 public constant decimals = 18;\n', '    string  public version = "1.0";\n', '    \n', '     \n', '    //Events fired during successfull execution of main silatoken functions\n', '    event Issued(address indexed _to,uint256 _value);\n', '    event Redeemed(address indexed _from,uint256 _amount);\n', '    event ProtectedTransfer(address indexed _from,address indexed _to,uint256 _amount);\n', '    event ProtectedApproval(address indexed _owner,address indexed _spender,uint256 _amount);\n', '    event GlobalLaunchSila(address indexed _launcher);\n', '    \n', '    \n', '\n', '    /**\n', '   * @dev issue tokens from sila  to _to address\n', '   * @dev onlyAuthorized  addresses can call this function\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _amount uint256 the amount of tokens to be issued\n', '   */\n', '\n', '    function issue(address _to, uint256 _amount) public onlyAuthorized returns (bool) {\n', '        require(!emergencyFlag);\n', '        require(_to !=address(0));\n', '        if (requireBetalisted){\n', '            require(betalisted[_to]);\n', '        }\n', '        require(!blacklisted[_to]);\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);                 \n', '        emit Issued(_to, _amount);                     \n', '        return true;\n', '    }\n', '    \n', '    \n', '      \n', '   /**\n', '   * @dev redeem tokens from _from address\n', '   * @dev onlyAuthorized  addresses can call this function\n', '   * @param _from address is the address from which tokens are burnt\n', '   * @param _amount uint256 the amount of tokens to be burnt\n', '   */\n', '\n', '    function redeem(address _from,uint256 _amount) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_from != address(0));\n', '        require(_amount <= balances[_from]);\n', '        if(requireBetalisted){\n', '            require(betalisted[_from]);\n', '        }\n', '        require(!blacklisted[_from]);\n', '        balances[_from] = balances[_from].sub(_amount);   \n', '        totalSupply = totalSupply.sub(_amount);\n', '        emit Redeemed(_from,_amount);\n', '        return true;\n', '            \n', '\n', '    }\n', '    \n', '    \n', '    /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @dev onlyAuthorized  addresses can call this function\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _amount uint256 the amount of tokens to be transferred\n', '   */\n', '\n', '    function protectedTransfer(address _from,address _to,uint256 _amount) public onlyAuthorized returns(bool){\n', '        require(!emergencyFlag);\n', '        require(_amount <= balances[_from]);\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        if (requireBetalisted){\n', '            require(betalisted[_to]);\n', '            require(betalisted[_from]);\n', '        }\n', '        require(!blacklisted[_to]);\n', '        require(!blacklisted[_from]);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit ProtectedTransfer(_from, _to, _amount);\n', '        emit Transfer(_from,_to,_amount);\n', '        return true;\n', '        \n', '    }\n', '    \n', '    \n', '    /**\n', '    * @dev Launch sila for global transfers to work as standard\n', '    */\n', '    \n', '    function globalLaunchSila() public onlyHotOwner{\n', '            require(!emergencyFlag);\n', '            require(requireBetalisted);\n', '            requireBetalisted=false;\n', '            emit GlobalLaunchSila(msg.sender);\n', '    }\n', '    \n', '    \n', '    \n', '     /**\n', '   * @dev batchissue , isuue tokens in batches to multiple addresses at a time\n', '   * @param _amounts The amount of tokens to be issued.\n', '   * @param _toAddresses tokens to be issued to these addresses respectively\n', '    */\n', '    \n', '    function batchIssue(address[] memory _toAddresses,uint256[]  memory _amounts) public onlyAuthorized returns(bool) {\n', '            require(!emergencyFlag);\n', '            require(_toAddresses.length==_amounts.length);\n', '            for(uint i = 0; i < _toAddresses.length; i++) {\n', '                bool check=issue(_toAddresses[i],_amounts[i]);\n', '                require(check);\n', '            }\n', '            return true;\n', '            \n', '    }\n', '    \n', '    \n', '    /**\n', '    * @dev batchredeem , redeem tokens in batches from multiple addresses at a time\n', '    * @param _amounts The amount of tokens to be redeemed.\n', '    * @param _fromAddresses tokens to be redeemed to from addresses respectively\n', '     */\n', '    \n', '    function batchRedeem(address[] memory  _fromAddresses,uint256[]  memory _amounts) public onlyAuthorized returns(bool){\n', '            require(!emergencyFlag);\n', '            require(_fromAddresses.length==_amounts.length);\n', '            for(uint i = 0; i < _fromAddresses.length; i++) {\n', '                bool check=redeem(_fromAddresses[i],_amounts[i]);\n', '                require(check);\n', '            }  \n', '            return true;\n', '        \n', '    }\n', '    \n', '    \n', '      /**\n', '    * @dev batchTransfer, transfer tokens in batches between multiple addresses at a time\n', '    * @param _fromAddresses tokens to be transfered to these addresses respectively\n', '    * @param _toAddresses tokens to be transfered to these addresses respectively\n', '    * @param _amounts The amount of tokens to be transfered\n', '     */\n', '    function protectedBatchTransfer(address[] memory _fromAddresses,address[]  memory _toAddresses,uint256[] memory  _amounts) public onlyAuthorized returns(bool){\n', '            require(!emergencyFlag);\n', '            require(_fromAddresses.length==_amounts.length);\n', '            require(_toAddresses.length==_amounts.length);\n', '            require(_fromAddresses.length==_toAddresses.length);\n', '            for(uint i = 0; i < _fromAddresses.length; i++) {\n', '                bool check=protectedTransfer(_fromAddresses[i],_toAddresses[i],_amounts[i]);\n', '                require(check);\n', '               \n', '            }\n', '            return true;\n', '        \n', '    } \n', '    \n', '    \n', '    \n', '\n', '    \n', '    \n', '}']