['// File: contracts/IFeed.sol\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'interface IFeed {\n', '    function get(address base, address quote) external view returns (uint128 xrt, uint64 when);\n', '}\n', '\n', '// File: contracts/open-zeppelin/ECRecovery.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '// Using ECRecovery from open-zeppelin@ad12381549c4c0711c2f3310e9fb1f65d51c299c + added personalRecover function\n', '// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/ad12381549c4c0711c2f3310e9fb1f65d51c299c/contracts/ECRecovery.sol\n', '\n', 'library ECRecovery {\n', '  /**\n', '   * @dev Recover signer address from a personal signed message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.personal.sign()\n', '   */\n', '  function personalRecover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    return recover(toEthSignedMessageHash(hash), sig);\n', '  }\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(abi.encodePacked(\n', '      "\\x19Ethereum Signed Message:\\n32",\n', '      hash\n', '    ));\n', '  }\n', '}\n', '\n', '// File: @aragon/os/contracts/common/Uint256Helpers.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'library Uint256Helpers {\n', '    uint256 private constant MAX_UINT64 = uint64(-1);\n', '\n', '    string private constant ERROR_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";\n', '\n', '    function toUint64(uint256 a) internal pure returns (uint64) {\n', '        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n', '        return uint64(a);\n', '    }\n', '}\n', '\n', '// File: @aragon/os/contracts/common/TimeHelpers.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract TimeHelpers {\n', '    using Uint256Helpers for uint256;\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number, converted to uint64.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber64() internal view returns (uint64) {\n', '        return getBlockNumber().toUint64();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp() internal view returns (uint256) {\n', '        return block.timestamp; // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp, converted to uint64.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp64() internal view returns (uint64) {\n', '        return getTimestamp().toUint64();\n', '    }\n', '}\n', '\n', '// File: contracts/PPF.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract PPF is IFeed, TimeHelpers {\n', '    using ECRecovery for bytes32;\n', '\n', '    uint256 constant public ONE = 10 ** 18; // 10^18 is considered 1 in the price feed to allow for decimal calculations\n', '    bytes32 constant public PPF_v1_ID = 0x33a8ba7202230fa1cee2aac7bac322939edc7ba0a48b0989335a5f87a5770369; // keccak256("PPF-v1");\n', '\n', '    string private constant ERROR_BAD_SIGNATURE = "PPF_BAD_SIGNATURE";\n', '    string private constant ERROR_BAD_RATE_TIMESTAMP = "PPF_BAD_RATE_TIMESTAMP";\n', '    string private constant ERROR_INVALID_RATE_VALUE = "PPF_INVALID_RATE_VALUE";\n', '    string private constant ERROR_EQUAL_BASE_QUOTE_ADDRESSES = "PPF_EQUAL_BASE_QUOTE_ADDRESSES";\n', '    string private constant ERROR_BASE_ADDRESSES_LENGTH_ZERO = "PPF_BASE_ADDRESSES_LEN_ZERO";\n', '    string private constant ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH = "PPF_QUOTE_ADDRESSES_LEN_MISMATCH";\n', '    string private constant ERROR_RATE_VALUES_LENGTH_MISMATCH = "PPF_RATE_VALUES_LEN_MISMATCH";\n', '    string private constant ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH = "PPF_RATE_TIMESTAMPS_LEN_MISMATCH";\n', '    string private constant ERROR_SIGNATURES_LENGTH_MISMATCH = "PPF_SIGNATURES_LEN_MISMATCH";\n', '    string private constant ERROR_CAN_NOT_SET_OPERATOR = "PPF_CAN_NOT_SET_OPERATOR";\n', '    string private constant ERROR_CAN_NOT_SET_OPERATOR_OWNER = "PPF_CAN_NOT_SET_OPERATOR_OWNER";\n', '    string private constant ERROR_OPERATOR_ADDRESS_ZERO = "PPF_OPERATOR_ADDRESS_ZERO";\n', '    string private constant ERROR_OPERATOR_OWNER_ADDRESS_ZERO = "PPF_OPERATOR_OWNER_ADDRESS_ZERO";\n', '\n', '    struct Price {\n', '        uint128 xrt;\n', '        uint64 when;\n', '    }\n', '\n', '    mapping (bytes32 => Price) internal feed;\n', '    address public operator;\n', '    address public operatorOwner;\n', '\n', '    event SetRate(address indexed base, address indexed quote, uint256 xrt, uint64 when);\n', '    event SetOperator(address indexed operator);\n', '    event SetOperatorOwner(address indexed operatorOwner);\n', '\n', '    /**\n', '    * @param _operator Public key allowed to sign messages to update the pricefeed\n', '    * @param _operatorOwner Address of an account that can change the operator\n', '    */\n', '    constructor (address _operator, address _operatorOwner) public {\n', '        _setOperator(_operator);\n', '        _setOperatorOwner(_operatorOwner);\n', '    }\n', '\n', '    /**\n', "    * @notice Update the price for the `base + ':' + quote` feed with an exchange rate of `xrt / ONE` for time `when`\n", '    * @dev If the number representation of base is lower than the one for quote, and update is cheaper, as less manipulation is required.\n', '    * @param base Address for the base token in the feed\n', '    * @param quote Address for the quote token the base is denominated in\n', '    * @param xrt Exchange rate for base denominated in quote. 10^18 is considered 1 to allow for decimal calculations\n', '    * @param when Timestamp for the exchange rate value\n', '    * @param sig Signature payload (EIP191) from operator, concatenated [  r  ][  s  ][v]. See setHash function for the hash calculation.\n', '    */\n', '    function update(address base, address quote, uint128 xrt, uint64 when, bytes sig) public {\n', '        bytes32 pair = pairId(base, quote);\n', '\n', '        // Ensure it is more recent than the current value (implicit check for > 0) and not a future date\n', '        require(when > feed[pair].when && when <= getTimestamp(), ERROR_BAD_RATE_TIMESTAMP);\n', '        require(xrt > 0, ERROR_INVALID_RATE_VALUE); // Make sure xrt is not 0, as the math would break (Dividing by 0 sucks big time)\n', '        require(base != quote, ERROR_EQUAL_BASE_QUOTE_ADDRESSES); // Assumption that currency units are fungible and xrt should always be 1\n', '\n', '        bytes32 h = setHash(base, quote, xrt, when);\n', '        require(h.personalRecover(sig) == operator, ERROR_BAD_SIGNATURE); // Make sure the update was signed by the operator\n', '\n', '        feed[pair] = Price(pairXRT(base, quote, xrt), when);\n', '\n', '        emit SetRate(base, quote, xrt, when);\n', '    }\n', '\n', '    /**\n', '    * @notice Update the price for many pairs\n', '    * @dev If the number representation of bases is lower than the one for quotes, and update is cheaper, as less manipulation is required.\n', '    * @param bases Array of addresses for the base tokens in the feed\n', '    * @param quotes Array of addresses for the quote tokens bases are denominated in\n', '    * @param xrts Array of the exchange rates for bases denominated in quotes. 10^18 is considered 1 to allow for decimal calculations\n', '    * @param whens Array of timestamps for the exchange rate value\n', '    * @param sigs Bytes array with the ordered concatenated signatures for the updates\n', '    */\n', '    function updateMany(address[] bases, address[] quotes, uint128[] xrts, uint64[] whens, bytes sigs) public {\n', '        require(bases.length != 0, ERROR_BASE_ADDRESSES_LENGTH_ZERO);\n', '        require(bases.length == quotes.length, ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH);\n', '        require(bases.length == xrts.length, ERROR_RATE_VALUES_LENGTH_MISMATCH);\n', '        require(bases.length == whens.length, ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH);\n', '        require(bases.length == sigs.length / 65, ERROR_SIGNATURES_LENGTH_MISMATCH);\n', '        require(sigs.length % 65 == 0, ERROR_SIGNATURES_LENGTH_MISMATCH);\n', '\n', '        for (uint256 i = 0; i < bases.length; i++) {\n', '            // Extract the signature for the update from the concatenated sigs\n', '            bytes memory sig = new bytes(65);\n', '            uint256 needle = 32 + 65 * i; // where to start copying from sigs\n', '            assembly {\n', '                // copy 32 bytes at a time and just the last byte at the end\n', '                mstore(add(sig, 0x20), mload(add(sigs, needle)))\n', '                mstore(add(sig, 0x40), mload(add(sigs, add(needle, 0x20))))\n', '                // we have to mload the last 32 bytes of the sig, and mstore8 just gets the LSB for the word\n', '                mstore8(add(sig, 0x60), mload(add(sigs, add(needle, 0x21))))\n', '            }\n', '\n', '            update(bases[i], quotes[i], xrts[i], whens[i], sig);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @param base Address for the base token in the feed\n', '    * @param quote Address for the quote token the base is denominated in\n', '    * @return XRT for base:quote and the timestamp when it was updated\n', '    */\n', '    function get(address base, address quote) public view returns (uint128, uint64) {\n', '        if (base == quote) {\n', '            return (uint128(ONE), getTimestamp64());\n', '        }\n', '\n', '        Price storage price = feed[pairId(base, quote)];\n', '\n', '        // if never set, return 0.\n', '        if (price.when == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        return (pairXRT(base, quote, price.xrt), price.when);\n', '    }\n', '\n', '    /**\n', '    * @notice Set operator public key to `_operator`\n', '    * @param _operator Public key allowed to sign messages to update the pricefeed\n', '    */\n', '    function setOperator(address _operator) external {\n', '        // Allow the current operator to change the operator to avoid having to hassle the\n', '        // operatorOwner in cases where a node just wants to rotate its public key\n', '        require(msg.sender == operator || msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR);\n', '        _setOperator(_operator);\n', '    }\n', '\n', '    /**\n', '    * @notice Set operator owner to `_operatorOwner`\n', '    * @param _operatorOwner Address of an account that can change the operator\n', '    */\n', '    function setOperatorOwner(address _operatorOwner) external {\n', '        require(msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR_OWNER);\n', '        _setOperatorOwner(_operatorOwner);\n', '    }\n', '\n', '    function _setOperator(address _operator) internal {\n', '        require(_operator != address(0), ERROR_OPERATOR_ADDRESS_ZERO);\n', '        operator = _operator;\n', '        emit SetOperator(_operator);\n', '    }\n', '\n', '    function _setOperatorOwner(address _operatorOwner) internal {\n', '        require(_operatorOwner != address(0), ERROR_OPERATOR_OWNER_ADDRESS_ZERO);\n', '        operatorOwner = _operatorOwner;\n', '        emit SetOperatorOwner(_operatorOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev pairId returns a unique id for each pair, regardless of the order of base and quote\n', '    */\n', '    function pairId(address base, address quote) internal pure returns (bytes32) {\n', '        bool pairOrdered = isPairOrdered(base, quote);\n', '        address orderedBase = pairOrdered ? base : quote;\n', '        address orderedQuote = pairOrdered ? quote : base;\n', '\n', '        return keccak256(abi.encodePacked(orderedBase, orderedQuote));\n', '    }\n', '\n', '    /**\n', '    * @dev Compute xrt depending on base and quote order.\n', '    */\n', '    function pairXRT(address base, address quote, uint128 xrt) internal pure returns (uint128) {\n', '        bool pairOrdered = isPairOrdered(base, quote);\n', '\n', '        return pairOrdered ? xrt : uint128((ONE**2 / uint256(xrt))); // If pair is not ordered, return the inverse\n', '    }\n', '\n', '    function setHash(address base, address quote, uint128 xrt, uint64 when) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(PPF_v1_ID, base, quote, xrt, when));\n', '    }\n', '\n', '    function isPairOrdered(address base, address quote) private pure returns (bool) {\n', '        return base < quote;\n', '    }\n', '}']