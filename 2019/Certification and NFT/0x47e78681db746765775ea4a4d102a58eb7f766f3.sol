['pragma solidity ^0.5.7;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract User is Ownable {\n', '\n', '    event UserRegistered(address internal_wallet_address, address external_wallet_address, address referrer, bytes32 nick_name, bytes32 geo_location);\n', '\n', '    event UserNickNameUpdated(address external_wallet_address, bytes32 old_nick_name, bytes32 new_nick_name);\n', '\n', '    event UserGeoLocationUpdated(address external_wallet_address, bytes32 old_geo_location, bytes32 new_geo_location);\n', '\n', '    struct UserDetails {\n', '        bytes32 nick_name;\n', '        address payable referrer;\n', '        bytes32 geo_location;\n', '    }\n', '\n', '    // address details\n', '    mapping(address => UserDetails) public users;\n', '\n', '    // mapping of internal wallet to external wallet\n', '    mapping(address => address) public internal_to_external;\n', '\n', '    // mapping of external wallet to internal wallet\n', '    mapping(address => address) public external_to_internal;\n', '\n', '    // all referees for an address\n', '    mapping(address => address[]) public referees;\n', '\n', '    constructor() public {\n', '        UserDetails memory root = UserDetails({\n', '            nick_name : "new",\n', '            referrer : address(0),\n', '            geo_location : "51.507351,-0.127758" // London\n', '            });\n', '        users[msg.sender] = root;\n', '        internal_to_external[msg.sender] = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev method to register users, can be called by admin only\n', '     * @param _internal_wallet_addresses internal wallet addresses array\n', '     * @param _external_wallet_addresses external wallet addresses array\n', '     * @param _referrers referrers array\n', '     * @param _nick_names nick names array\n', '     * @param _geo_locations geo locations array\n', '     */\n', '    function registerUsers(\n', '        address payable[] calldata _internal_wallet_addresses,\n', '        address payable[] calldata _external_wallet_addresses,\n', '        address payable[] calldata _referrers,\n', '        bytes32[] calldata _nick_names,\n', '        bytes32[] calldata _geo_locations) external onlyOwner() {\n', '        for (uint256 i; i < _internal_wallet_addresses.length; i++) {\n', '            UserDetails memory ud = UserDetails({\n', '                nick_name : _nick_names[i],\n', '                referrer : _referrers[i],\n', '                geo_location : _geo_locations[i]\n', '                });\n', '            users[_external_wallet_addresses[i]] = ud;\n', '            referees[_referrers[i]].push(_external_wallet_addresses[i]);\n', '            internal_to_external[_internal_wallet_addresses[i]] = _external_wallet_addresses[i];\n', '            external_to_internal[_external_wallet_addresses[i]] = _internal_wallet_addresses[i];\n', '            emit UserRegistered(_internal_wallet_addresses[i], _external_wallet_addresses[i], _referrers[i], _nick_names[i], _geo_locations[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev method to register user, can be called by admin only\n', '     * @param _internal_wallet_address internal wallet address\n', '     * @param _external_wallet_address external wallet address\n', '     * @param _referrer referrer\n', '     * @param _nick_name nick name\n', '     * @param _geo_location geo location\n', '     */\n', '    function registerUser(\n', '        address payable _internal_wallet_address,\n', '        address payable _external_wallet_address,\n', '        address payable _referrer,\n', '        bytes32 _nick_name,\n', '        bytes32 _geo_location) external onlyOwner() {\n', '        UserDetails memory ud = UserDetails({\n', '            nick_name : _nick_name,\n', '            referrer : _referrer,\n', '            geo_location : _geo_location\n', '            });\n', '        users[_external_wallet_address] = ud;\n', '        referees[_referrer].push(_external_wallet_address);\n', '        internal_to_external[_internal_wallet_address] = _external_wallet_address;\n', '        external_to_internal[_external_wallet_address] = _internal_wallet_address;\n', '        emit UserRegistered(_internal_wallet_address, _external_wallet_address, _referrer, _nick_name, _geo_location);\n', '    }\n', '\n', '    /**\n', '     * @dev method to update users nick name, can be called external address only\n', '     * @param _nick_name new nick name\n', '     */\n', '    function updateNickname(bytes32 _nick_name) external {\n', '        require(external_to_internal[msg.sender] != address(0));\n', '        UserDetails memory ud = users[msg.sender];\n', '        require(ud.nick_name != bytes32(0), "user does not esist!");\n', '        bytes32 old_nick_name = ud.nick_name;\n', '        ud.nick_name = _nick_name;\n', '        users[msg.sender] = ud;\n', '        emit UserNickNameUpdated(msg.sender, old_nick_name, _nick_name);\n', '    }\n', '\n', '    /**\n', '     * @dev method to update users geo location, can be called external address only\n', '     * @param _geo_location new geo location\n', '     */\n', '    function updateGeoLocation(bytes32 _geo_location) external {\n', '        require(external_to_internal[msg.sender] != address(0));\n', '        UserDetails memory ud = users[msg.sender];\n', '        require(ud.nick_name != bytes32(0), "user does not esist!");\n', '        bytes32 old_geo_location = ud.geo_location;\n', '        ud.geo_location = _geo_location;\n', '        users[msg.sender] = ud;\n', '        emit UserGeoLocationUpdated(msg.sender, old_geo_location, _geo_location);\n', '    }\n', '\n', '    /**\n', '       * @dev Throws if called by any account other than the internal wallet.\n', '       */\n', '    modifier onlyInternalWallets() {\n', '        require(internal_to_external[msg.sender] != address(0));\n', '        _;\n', '    }\n', '}\n', '\n', 'contract SuperOneSpots is User {\n', '\n', '    event Withdrawal(address wallet, uint256 weiAmount);\n', '    event CommissionSent(address indexed from, address to, uint256 amount);\n', '\n', '    // coordinates to Spot index first is level(x) then mapping of y to owner address\n', '    mapping(uint256 => mapping(uint256 => address)) public coordinates;\n', '\n', '    // mapping to return what to add according to x index\n', '    mapping(uint256 => uint256) public x_addition;\n', '\n', '    // mapping to return what to add according to y index\n', '    mapping(uint256 => uint256) public y_addition;\n', '\n', '    // Constructor to bootstartp the contract\n', '    constructor() public {\n', '        // initial coordinates belongs to owner\n', '        coordinates[0][0] = msg.sender;\n', '        uint256 x_factor = 1;\n', '        uint256 y_factor;\n', '        //pre fill x_addition for level calculation in the tree\n', '        for (uint256 i; i < 128; i++) {\n', '            // for x_addition\n', '            if ((i + 2) >= (2 * (2 ** x_factor))) {\n', '                x_factor += 1;\n', '                y_factor = 1;\n', '            } else {\n', '                y_factor += 1;\n', '            }\n', '            x_addition[i] = x_factor;\n', '            y_addition[i] = y_factor - 1;\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev method to assign spots, can be called by admin only\n', '     * @param coord_x coordinate x of the tree to start\n', '     * @param coord_y coordinate y of the tree to start\n', '     * @param _count count of spots to be assigned\n', '     */\n', '    function assignSpotsByAdmin(uint256 coord_x, uint256 coord_y, uint _count, address external_wallet_address) external onlyOwner() {\n', '        require(_count < 128);\n', '        coordinates[coord_x][coord_y] = external_wallet_address;\n', '        for (uint256 i; i < _count - 1; i++) {\n', '            coordinates[coord_x + x_addition[i]][coord_y * (2 * (2 ** (x_addition[i] - 1))) + y_addition[i]] = external_wallet_address;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev method to assign spots, can be called by internal wallets only\n', '     * @param coord_x coordinate x of the tree to start\n', '     * @param coord_y coordinate y of the tree to start\n', '     * @param _count count of spots to be assigned\n', '     */\n', '    function assignSpots(uint256 coord_x, uint256 coord_y, uint _count) external onlyInternalWallets() {\n', '        require(_count < 128);\n', '        address wallet = internal_to_external[msg.sender];\n', '        coordinates[coord_x][coord_y] = wallet;\n', '        for (uint256 i; i < _count - 1; i++) {\n', '            coordinates[coord_x + x_addition[i]][coord_y * (2 * (2 ** (x_addition[i] - 1))) + y_addition[i]] = wallet;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev method to distribute Comission, can be called by internal wallets only\n', '     * @param beneficiaries address to which funds will be transferred\n', '     * @param amounts the amount of index wise benificiaries\n', '     */\n', '    function distributeCommission(address payable[] calldata beneficiaries, uint256[] calldata amounts) external payable onlyInternalWallets() {\n', '        require(beneficiaries.length == amounts.length);\n', '        for (uint256 i; i < beneficiaries.length; i++) {\n', '            beneficiaries[i].transfer(amounts[i]);\n', '            emit CommissionSent(internal_to_external[msg.sender], beneficiaries[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev method to withdraw funds only by owner\n', '     * @param _wallet address to which funds will be transferred\n', '     */\n', '    function withdraw(address payable _wallet) onlyOwner() public {\n', '        uint256 weiAmount = address(this).balance;\n', '        require(weiAmount > 0);\n', '        _wallet.transfer(weiAmount);\n', '        emit Withdrawal(_wallet, weiAmount);\n', '    }\n', '\n', '    function checkSpots(uint256[] calldata x, uint256[] calldata y) external view returns (address[] memory){\n', '        address[] memory addresses;\n', '        for (uint256 i; i < x.length; i++) {\n', '            addresses[i] = coordinates[x[i]][y[i]];\n', '        }\n', '        return addresses;\n', '    }\n', '\n', '}']