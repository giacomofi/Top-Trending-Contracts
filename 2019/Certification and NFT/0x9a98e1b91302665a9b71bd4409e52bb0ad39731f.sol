['/*\n', '\n', 'Introducing "TORPEDO LAUNCH" Version 2.1, with a minor update on payout system\n', '"TORPEDO LAUNCH" is playable @ https://torpedolaunch.io (Ethereum Edition) and https://trx.torpedolaunch.io (TRON Edition)\n', '\n', 'About the game :\n', '\n', 'You are in command on a WW2 Class Submarine, YOUR MISSION : Seek and Destroy enemy ships.\n', '\n', 'How to play TORPEDO LAUNCH:\n', '\n', 'Buy a batch of 15 torpedoes and try to score as much as possible by sinking ships and submarines.\n', 'Your Break-even point is at the moving average score of all players, if your score is over the moving average, you are receiving your credits back\n', 'plus a part of the current treasure proportionally to your score, if your score is lower than the moving average, you are receiving\n', 'a part of your credits also proportionally to your score. At every play, the best score is registered also for the HIGHSCORE JACKPOT PAYOUT which is\n', 'paid every 100 play. In addition, every time you buy new torpedoes, 5% of the price will buy you HDX20 Token you can resell anytime, earning\n', 'you Ethereum or Tron(TRX) from the volume of any HDX20 POWERED GAMES as long as you hold them (visit hdx20.io or trx.hdx20.io for details).\n', '\n', 'Play for the JACKPOT, Play for the TREASURE, Play for staking HDX20 TOKEN or Play for all at once...Your Choice!\n', '\n', 'We wish you Good Luck!\n', '\n', 'PAYOUTS DISTRIBUTION:\n', '100% of TREASURE and JACKPOT are paid to Players\n', '\n', 'at every Play:\n', '\n', ' 5% credited to player as HDX20 token\n', '64% of losing credits to the running TREASURE\n', '16% of losing credits to the running JACKPOT\n', '15% of losing credits to the community of HDX20 gamers/holders distributed as price appreciation.\n', ' 5% of losing credits to developer for running, developing and expanding the platform.\n', '\n', '\n', 'UPDATE:\n', '\n', 'Version 2.1 is a UPDATE on the payout system to distribute a percentage of the treasure for a better distribution among all players  \n', '(previous version was distributing the full treasure at average_score *2)\n', '\n', '\n', 'This product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\n', '\n', 'Copyright 2018 HyperDevbox\n', '\n', '*/\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', 'interface HDX20Interface\n', '{\n', '    function() payable external;\n', '    \n', '    \n', '    function buyTokenFromGame( address _customerAddress , address _referrer_address ) payable external returns(uint256);\n', '  \n', '    function payWithToken( uint256 _eth , address _player_address ) external returns(uint256);\n', '  \n', '    function appreciateTokenPrice() payable external;\n', '   \n', '    function totalSupply() external view returns(uint256); \n', '    \n', '    function ethBalanceOf(address _customerAddress) external view returns(uint256);\n', '  \n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '    \n', '    function sellingPrice( bool includeFees) external view returns(uint256);\n', '  \n', '}\n', '\n', '\n', 'contract TorpedoLaunchGame\n', '{\n', '     HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882);\n', '     \n', '     using SafeMath for uint256;\n', '     using SafeMath128 for uint128;\n', '     \n', '     /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event OwnershipTransferred(\n', '        \n', '         address previousOwner,\n', '         address nextOwner,\n', '          uint256 timeStamp\n', '         );\n', '         \n', '    event HDXcontractChanged(\n', '        \n', '         address previous,\n', '         address next,\n', '         uint256 timeStamp\n', '         );\n', ' \n', '    event onJackpotWin(\n', '        address customerAddress,\n', '        uint256 val\n', '       \n', '    );\n', '    \n', '    event onChangeAverageScore(\n', '        uint32 score\n', '       \n', '    );\n', '    \n', '    event onChangeJackpotCycle(\n', '        uint32 cycle\n', '       \n', '    );\n', '    \n', '    \n', '     event onChangeMaximumScore(\n', '        uint32 score\n', '       \n', '    );\n', '    \n', '     event onChangeTimeout(\n', '        uint32 timeout\n', '       \n', '    );\n', '    \n', '      event onChangePercentageTreasure(\n', '        uint32 percentage\n', '       \n', '    );\n', '\t    \n', '     event onWithdrawGains(\n', '        address customerAddress,\n', '        uint256 ethereumWithdrawn,\n', '        uint256 timeStamp\n', '    );\n', '    \n', '    event onNewScore(\n', '\t\tuint256       score,\n', '        address       customerAddress,\n', '        bool          newHighScore,\n', '        uint256\t\t  val,\t\t\t\t//winning\n', '        uint32        torpedoBatchMultiplier  //x1, x10, x100\n', '        \n', '    );\n', '             \n', '    event onBuyTorpedo(\n', '        address     customerAddress,\n', '        uint256     torpedoBatchID,\n', '        uint256     torpedoBatchBlockTimeout,  \n', '        uint256     nbToken,\n', '        uint32      torpedoBatchMultiplier  //x1, x10, x100\n', '        );    \n', '        \n', '        \n', '     event onMaintenance(\n', '        bool        mode,\n', '        uint256     timeStamp\n', '\n', '        );    \n', '      \n', '        \n', '    event onChangeBlockTimeAverage(\n', '        \n', '         uint256 blocktimeavg\n', '         \n', '        );    \n', '        \n', '    event onChangeMinimumPrice(\n', '        \n', '         uint256 minimum,\n', '         uint256 timeStamp\n', '         );\n', '         \n', '    event onNewName(\n', '        \n', '         address     customerAddress,\n', '         bytes32     name,\n', '         uint256     timeStamp\n', '         );\n', '        \n', '    /*==============================\n', '    =            MODIFIERS         =\n', '    ==============================*/\n', '    modifier onlyOwner\n', '    {\n', '        require (msg.sender == owner );\n', '        _;\n', '    }\n', '    \n', '    modifier onlyFromHDXToken\n', '    {\n', '        require (msg.sender == address( HDXcontract ));\n', '        _;\n', '    }\n', '   \n', '     modifier onlyDirectTransaction\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '   \n', '   \n', '  \n', '    \n', '    modifier isMaintenance\n', '    {\n', '        require (maintenanceMode==true);\n', '        _;\n', '    }\n', '    \n', '     modifier isNotMaintenance\n', '    {\n', '        require (maintenanceMode==false);\n', '        _;\n', '    }\n', '   \n', '  \n', '    address public owner;\n', '  \n', '   \n', '    address public signerAuthority = 0xf77444cE64f3F46ba6b63F6b9411dF9c589E3319;\n', '   \n', '    \n', '    \n', '\n', '    constructor () public\n', '    {\n', '        owner = msg.sender;\n', '       \n', '\t\t//set the average point to the maximum / 5 extended score\n', '\t\t\n', '\t\tuint32 maximumScore = (1350+70)*15;\n', '\t   \t   \n', '\t\tGameRoundData.extraData[2] = maximumScore/5;\n', '\t\tGameRoundData.extraData[3] = 100; //default jackpot cycle\n', '        GameRoundData.extraData[4] = maximumScore;\n', '        GameRoundData.extraData[5] = 60*60; //1 hour by default\n', '        GameRoundData.extraData[6] = 10; //10 percents default\n', '        \n', '        if ( address(this).balance > 0)\n', '        {\n', '            owner.transfer( address(this).balance );\n', '        }\n', '    }\n', '    \n', '    function changeOwner(address _nextOwner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextOwner != owner);\n', '        require(_nextOwner != address(0));\n', '         \n', '        emit OwnershipTransferred(owner, _nextOwner , now);\n', '         \n', '        owner = _nextOwner;\n', '    }\n', '    \n', '    function changeSigner(address _nextSigner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextSigner != signerAuthority);\n', '        require(_nextSigner != address(0));\n', '      \n', '        signerAuthority = _nextSigner;\n', '    }\n', '    \n', '    function changeHDXcontract(address _next) public\n', '    onlyOwner\n', '    {\n', '        require (_next != address( HDXcontract ));\n', '        require( _next != address(0));\n', '         \n', '        emit HDXcontractChanged(address(HDXcontract), _next , now);\n', '         \n', '        HDXcontract  = HDX20Interface( _next);\n', '    }\n', '  \n', '  \n', '    \n', '    function changeBlockTimeAverage( uint256 blocktimeavg) public\n', '    onlyOwner\n', '    {\n', '        require ( blocktimeavg>0 );\n', '        \n', '       \n', '        blockTimeAverage = blocktimeavg;\n', '        \n', '        emit onChangeBlockTimeAverage( blockTimeAverage );\n', '         \n', '    }\n', '    \n', '    \n', '    //in case we need to reset the game difficulty \n', '    function changeAverageScore( uint32 score) public\n', '    onlyOwner\n', '    {\n', '       \n', '        GameRoundData.extraData[2] = score;\n', '        \n', '        emit onChangeAverageScore( score );\n', '         \n', '    }\n', '    \n', '    //in case we need to adjust if players prefer a fast jackpot over quantity or opposite \n', '    function changeJackpotCycle( uint32 cycle) public\n', '    onlyOwner\n', '    {\n', "        //let's stay reasonnable\n", '        require( cycle>0 && cycle<=1000);\n', '        \n', '       \n', '        GameRoundData.extraData[3] = cycle;\n', '        \n', '        emit onChangeJackpotCycle( cycle );\n', '         \n', '    }\n', '    \n', '    //in case we want to add new ships, new bonus item to the game, etc....we need to adjust the maximum score\n', '    function changeMaximumScore( uint32 score) public\n', '    onlyOwner\n', '    {\n', "        //let's stay reasonnable\n", '        require( score > 4000);\n', '        \n', '        GameRoundData.extraData[4] = score;\n', '       \n', '      \n', '        emit onChangeMaximumScore( score );\n', '         \n', '    }\n', '    \n', '     //in case we need to change the timeout because of slower or faster network (in seconds) \n', '    function changeTimeOut( uint32 timeout) public\n', '    onlyOwner\n', '    {\n', '       \n', '        GameRoundData.extraData[5] = timeout;\n', '        \n', '        emit onChangeTimeout( timeout );\n', '         \n', '    }\n', '    \n', '    //we want to be able to tune the game and select a different percentage of the treasure to be giving per play at maximum\n', '    //also we can use this to make contest and special event etc....\n', '    function changePercentageTreasure( uint32 percentage) public\n', '    onlyOwner\n', '    {\n', '        require( percentage > 0 && percentage<=100);\n', '        \n', '        GameRoundData.extraData[6] = percentage;\n', '        \n', '        emit onChangePercentageTreasure( percentage );\n', '         \n', '    }\n', '    \n', '    function enableMaintenance() public\n', '    onlyOwner\n', '    {\n', '        maintenanceMode = true;\n', '        \n', '        emit onMaintenance( maintenanceMode , now);\n', '        \n', '    }\n', '\n', '    function disableMaintenance() public\n', '    onlyOwner\n', '    {\n', '      \n', '        maintenanceMode = false;\n', '        \n', '        emit onMaintenance( maintenanceMode , now);\n', '        \n', '       \n', '      \n', '    }\n', '    \n', '  \n', '    function changeMinimumPrice( uint256 newmini) public\n', '    onlyOwner\n', '    {\n', '      \n', '      if (newmini>0)\n', '      {\n', '          minimumSharePrice = newmini;\n', '      }\n', '       \n', '      emit onChangeMinimumPrice( newmini , now ); \n', '    }\n', '    \n', '    \n', '     /*================================\n', '    =       GAMES VARIABLES         =\n', '    ================================*/\n', '    \n', '    struct PlayerData_s\n', '    {\n', '   \n', '        uint256 chest;  \n', '        uint256 payoutsTo;\n', '       \n', '\t\t//credit locked until we validate the score\n', '\t\tuint256 lockedCredit;\t\n', '\t\t\n', '        uint256         torpedoBatchID;         \n', '        uint256         torpedoBatchBlockTimeout;   \n', '\n', '\t\tuint32[1]\t\tpackedData;\t\t//[0] = torpedomultiplier;\n', '\t\t\t\t\t\t\n', '    }\n', '    \n', '    \n', '    struct GameRoundData_s\n', '    {\n', '\t   \n', '\t   uint256\t\t\t\tjackpotAmount;\n', '\t   uint256\t\t\t\ttreasureAmount;\n', '\t   address\t\t\t\tcurrentJackpotWinner;\n', '\t          \n', '       uint256              hdx20AppreciationPayout;\n', '       uint256              devAppreciationPayout;\n', '\t   \n', '       //********************************************************************************************\n', '\t   \n', '\t   uint32[7]\t\t\textraData;\t\t//[0] = jackpot current highscore\n', '\t\t\t\t\t\t\t\t\t\t\t//[1] = jackpot turn (start at 0 to jackpot cycle )\n', '\t\t\t\t\t\t\t\t\t\t\t//[2] = scoreAverage to beat\n', '\t\t\t                                //[3] = jackpot cycle (default 100)\t\t\t\t\t\t\t\t\n', '\t                                        //[4] = maximum score possible in the game\n', '\t                                        //[5] = timeout/torpedo score in seconds\n', '\t                                        //[6] = percentage treasure per play\n', '  \n', '    }\n', '      \n', '   \n', '    mapping (address => PlayerData_s)   private PlayerData;\n', '       \n', '    GameRoundData_s   private GameRoundData;\n', '    \n', '    mapping( address => bytes32) private registeredNames;\n', '       \n', '    bool        private maintenanceMode=false;     \n', '    \n', '    uint8 constant private HDX20BuyFees = 5;\n', '     \n', '    uint8 constant private DevFees = 5;\n', '\tuint8 constant private AppreciationFees = 15;\t\t\n', '\tuint8 constant private JackpotAppreciation = 16;\n', '\tuint8 constant private TreasureAppreciation = 64;\n', '   \n', '    uint256 constant internal magnitude = 1e18;\n', '     \n', '    uint256 private minimumSharePrice = 0.01 ether;\n', '    \n', '    uint256 private blockTimeAverage = 15;                \n', '\n', '\n', '    uint256 constant thresholdForAppreciation = 0.05 ether;\n', '      \n', '    /*================================\n', '    =       PUBLIC FUNCTIONS         =\n', '    ================================*/\n', '    \n', "    //fallback will be called only from the HDX token contract to fund the game from customers's HDX20\n", '    \n', '     function()\n', '     payable\n', '     public\n', '     onlyFromHDXToken \n', '    {\n', '       \n', '      \n', '      \n', '          \n', '    }\n', '    \n', '     function ChargeJackpot() public payable\n', '    {\n', '\t\tuint256 _val = msg.value;\n', '\t\t\n', '\t\tGameRoundData.jackpotAmount = GameRoundData.jackpotAmount.add( _val );\n', '\t\n', '    }\n', '    \n', '    function ChargeTreasure() public payable\n', '    {\n', '\t\tuint256 _val = msg.value;\n', '\t\n', '\t\t\n', '\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val );\n', '\t\t\t\t   \n', '    }\n', '\t\n', '\tfunction AddJackpotTreasure( uint256 _val ) private\n', '\t{\n', '\t\t//add to jackpot and treasure\n', '\t\tGameRoundData.jackpotAmount = GameRoundData.jackpotAmount.add( _val.mul( JackpotAppreciation ) / 100 );\n', '\t\t\n', '\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val.mul( TreasureAppreciation ) / 100 );\n', '\t\t\n', '\t\t//now HDX20 appreciation and dev account\n', '\t\t\n', '\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \n', '          \n', '        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \n', '\t\t\n', '\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\n', '\t\t\n', '\t\tif (_dev>= thresholdForAppreciation )\n', '\t\t{\n', '\t\t\tGameRoundData.devAppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t GameRoundData.devAppreciationPayout = _dev;\n', '\t\t}\n', '\t\n', '\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\n', '\t\t\n', '\t\tif (_appreciation>= thresholdForAppreciation)\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\n', '\t\t}\n', '\t\t\n', '\t}\n', '\t\n', '    \n', '    \n', '    \n', '    function ValidTorpedoScore( int256 score, uint256 torpedoBatchID , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        address _customer_address = msg.sender;\n', '         \n', '        require( maintenanceMode==false);\n', '  \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.torpedoBatchID = torpedoBatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '   \n', '        coreValidTorpedoScore( _customer_address , gamevar  );\n', '    }\n', '    \n', '    \n', '    struct GameVar_s\n', '    {\n', '     \n', '        bool madehigh;\n', '              \n', '               \n', '        uint256  torpedoBatchID;\n', '       \n', ' \t    int256   score;\n', '\t\tuint256  scoreMultiplied;\n', '\t\t\n', '\t\tuint32   multiplier;\n', '\t\t\n', '        bytes32  r;\n', '        bytes32  s;\n', '        uint8    v;\n', '    }\n', '    \n', '\tfunction payJackpot() private\n', '\t{\n', '\t\taddress _winner = GameRoundData.currentJackpotWinner;\n', '\t\tuint256 _j = GameRoundData.jackpotAmount;\n', '\t\t\n', '\t\t\n', '\t\tif (_winner != address(0))\n', '\t\t{\n', '\t\t\tPlayerData[ _winner ].chest = PlayerData[ _winner ].chest.add( _j ); \n', '\t\t\n', '\t\t\n', '    \t\tGameRoundData.currentJackpotWinner = address(0);\n', '    \t\tGameRoundData.jackpotAmount = 0;\n', '    \t\t//turn to 0\n', '    \t\tGameRoundData.extraData[1] = 0;\n', '    \t\t//highscore to 0\n', '    \t\tGameRoundData.extraData[0] = 0;\n', '    \t\t\n', '    \t\temit onJackpotWin( _winner , _j  );\n', '\t\t}\n', '\t\t\n', '\t}\n', '  \n', '    \n', '    function coreValidTorpedoScore( address _player_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '                \n', '        require((gamevar.torpedoBatchID != 0) && (gamevar.torpedoBatchID == _PlayerData.torpedoBatchID) && ( _PlayerData.lockedCredit>0 ));\n', '                \n', '        gamevar.madehigh = false;\n', '\n', '\t\n', '        if (block.number>=_PlayerData.torpedoBatchBlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.torpedoBatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\n', '        {\n', '            gamevar.score = 0;\n', '        }\n', '\t\t\n', '\t\tif (gamevar.score<0) gamevar.score = 0;\n', '\t\t\t\t            \n', '        gamevar.scoreMultiplied = uint256(gamevar.score) * uint256(_PlayerData.packedData[0]);\n', '        \n', '        if (gamevar.score>0xffffffff) gamevar.score = 0xffffffff;\n', '        if (gamevar.scoreMultiplied>0xffffffff) gamevar.scoreMultiplied = 0xffffffff;\n', '   \t\t\n', '\t\t//new jackpot highscore\n', '\t\tif (gamevar.scoreMultiplied > uint256( GameRoundData.extraData[0] ))\n', '\t\t{\n', '\t\t\tGameRoundData.extraData[0] = uint32( gamevar.scoreMultiplied );\n', '\t\t\t\n', '\t\t\tGameRoundData.currentJackpotWinner = _player_address;\n', '\t\t\t\n', ' \t\t\tgamevar.madehigh = true;\n', '\t\t\t \n', '\t\t}\n', '\t\t\n', '\t\t//jackpot turn++\n', '\t\t GameRoundData.extraData[1]++;\n', '\t\t\n', '\t\t//time to pay jackpot cycle ?\t\n', '\t\tif (GameRoundData.extraData[1]>=GameRoundData.extraData[3])\n', '\t\t{\n', '\t\t\tpayJackpot();\n', '\t\t}\n', '\t\t\n', '\t\n', '\t\t//we need to deal with scores not multiplied here\t\n', '\t\t\n', '\t\tuint256 _winning =0;\n', '\t\tuint256 _average = uint256( GameRoundData.extraData[2]);\n', '\t\tuint256 _top = _average*3;\n', '\t\t\n', '\t\tuint256 _score = uint256(gamevar.score);\n', '\t\t\n', '\t\tif (_score >=_average )\n', '\t\t{\n', '\t\t\t//more or equal than average score \n', '\t\t\t\n', '\t\t\t_winning = _PlayerData.lockedCredit;\n', '\t\t\t\n', '\t\t\t//how much from the treasure\n', '\t\t\t\t\t\n', '\t\t\tif (_score > _top) _score = _top;\n', '\t\t\n', '\t\t\t_score -= _average;\n', '\t\t\t_top -= _average;\n', '\t\t\n', '\t\t\t\n', '\t\t\t//apply the credit multiplier\t\t\t\n', '\t\t\tuint256 _gains = GameRoundData.treasureAmount.mul( _score * uint256( _PlayerData.packedData[0] )) / 100;\n', '\t\t\t\n', '\t\t\t\n', '\t\t\t//apply the percentage now per play NEW\n', '\t\t\t_gains = _gains.mul( GameRoundData.extraData[6] );\n', '\t\t\t_gains /= 100;\n', '\t\t\t\n', '\t\t\t//finally scale it to the score \n', '\t\t\t_gains /= (1+_top);\n', '\t\t\t\n', '\t\t\t//adjust treasure\n', '\t\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.sub( _gains );\n', '\t\t\t\t\t\t\t\t\t\n', '\t\t\t_winning = _winning.add( _gains );\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t//less than average score\n', '\t\t\n', '\t\t\tif (_average>0)\n', '\t\t\t{\n', '\t\t\t\t_winning = _PlayerData.lockedCredit.mul( _score ) / _average;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\t//credit the player for what is won\n', '\t\t_PlayerData.chest = _PlayerData.chest.add( _winning );\n', '\t\t\n', '\t\t\n', '\t\t//loosing some ?\n', '\t\t\n', '\t\tif (_PlayerData.lockedCredit> _winning)\n', '\t\t{\n', '\t\t\t\n', '\t\t\tAddJackpotTreasure( _PlayerData.lockedCredit - _winning );\n', '\t\t}\n', '\t\t\n', '\t\t//update average, we shall not overflow :)\n', '\t\t\t\t\n', '\t\t_score = uint256(gamevar.score);\n', '\t\t\n', '\t\tuint32 maximumScore = GameRoundData.extraData[4];\n', '\t\t\n', '\t\t\n', '\t\t//this has to be significatf and not just someone trying to cheat the system \n', '\t\t//\n', '\t\tif (_score>_average/2)\n', '\t\t{\n', '\t\t\t_score = _score.add( _average * 99 );\n', '\t\t\t_score /= 100;\n', '\t\t\t\n', '\t\t\tif (_score< maximumScore/6 ) _score = maximumScore/6;\n', '\t\t\tif (_score > maximumScore/3) _score = maximumScore/3;\n', '\t\t\t\n', '\t\t\tGameRoundData.extraData[2] = uint32( _score );\n', '\t\t}\n', '\n', '\t\t//\t\t\n', '   \n', '        //ok reset it so we can get a new one\n', '        _PlayerData.torpedoBatchID = 0;\n', '        _PlayerData.lockedCredit = 0;\n', '\t\t\n', '        emit onNewScore( gamevar.scoreMultiplied , _player_address , gamevar.madehigh , _winning , _PlayerData.packedData[0] );\n', '\n', '\n', '    }\n', '    \n', '    \n', '    function BuyTorpedoWithDividends( uint256 eth , int256 score, uint256 torpedoBatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        \n', '        require( maintenanceMode==false  && (eth==minimumSharePrice || eth==minimumSharePrice*10 || eth==minimumSharePrice*100) );\n', '  \n', '        address _customer_address = msg.sender;\n', '        \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.torpedoBatchID = torpedoBatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '        \n', '      \n', '        gamevar.multiplier =uint32( eth / minimumSharePrice);\n', '        \n', '        eth = HDXcontract.payWithToken( eth , _customer_address );\n', '       \n', '        require( eth>0 );\n', '        \n', '         \n', '        CoreBuyTorpedo( _customer_address , eth , _referrer_address , gamevar );\n', '        \n', '       \n', '    }\n', '    \n', '    function BuyName( bytes32 name ) public payable\n', '    {\n', '        address _customer_address = msg.sender;\n', '        uint256 eth = msg.value; \n', '        \n', '        require( maintenanceMode==false  && (eth==minimumSharePrice*10));\n', '        \n', '        //50% for the community\n', '        //50% for the developer account\n', '        \n', '        eth /= 2;\n', '        \n', '        HDXcontract.buyTokenFromGame.value( eth )( owner , address(0));\n', '       \n', '        HDXcontract.appreciateTokenPrice.value( eth )();\n', '        \n', '        registeredNames[ _customer_address ] = name;\n', '        \n', '        emit onNewName( _customer_address , name , now );\n', '    }\n', '    \n', '    function BuyTorpedo( int256 score, uint256 torpedoBatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\n', '    onlyDirectTransaction\n', '    {\n', '     \n', '        address _customer_address = msg.sender;\n', '        uint256 eth = msg.value;\n', '        \n', '        require( maintenanceMode==false  && (eth==minimumSharePrice || eth==minimumSharePrice*10 || eth==minimumSharePrice*100));\n', '   \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.torpedoBatchID = torpedoBatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '        \n', '       \n', '        gamevar.multiplier =uint32( eth / minimumSharePrice);\n', '   \n', '        CoreBuyTorpedo( _customer_address , eth , _referrer_address, gamevar);\n', '     \n', '    }\n', '    \n', '    /*================================\n', '    =       CORE BUY FUNCTIONS       =\n', '    ================================*/\n', '    \n', '    function CoreBuyTorpedo( address _player_address , uint256 eth ,  address _referrer_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '            \n', '        \n', '        //we need to validate the score before buying a torpedo batch\n', '        if (gamevar.torpedoBatchID !=0 || _PlayerData.torpedoBatchID !=0)\n', '        {\n', '             coreValidTorpedoScore( _player_address , gamevar);\n', '        }\n', '        \n', '        \n', "        //if we can continue then everything is fine let's create the new torpedo batch\n", '        \n', '        _PlayerData.packedData[0] = gamevar.multiplier;\n', '        _PlayerData.torpedoBatchBlockTimeout = block.number + (uint256(GameRoundData.extraData[5]) / blockTimeAverage);\n', '        _PlayerData.torpedoBatchID = uint256((keccak256(abi.encodePacked( block.number, _player_address , address(this)))));\n', '        \n', '        \n', '        //HDX20BuyFees\n', '        uint256 _tempo = (eth.mul(HDX20BuyFees)) / 100;\n', '\t\t\n', '\t\t_PlayerData.lockedCredit =  eth - _tempo;\t//total - hdx20\n', '\t\t        \n', '        uint256 _nb_token =   HDXcontract.buyTokenFromGame.value( _tempo )( _player_address , _referrer_address);\n', '        \n', '        \n', '        emit onBuyTorpedo( _player_address, _PlayerData.torpedoBatchID , _PlayerData.torpedoBatchBlockTimeout, _nb_token,  _PlayerData.packedData[0]);\n', '            \n', '        \n', '    }\n', '    \n', '   \n', '    \n', '    function get_Gains(address _player_address) private view\n', '    returns( uint256)\n', '    {\n', '       \n', '        uint256 _gains = PlayerData[ _player_address ].chest;\n', '        \n', '        if (_gains > PlayerData[ _player_address].payoutsTo)\n', '        {\n', '            _gains -= PlayerData[ _player_address].payoutsTo;\n', '        }\n', '        else _gains = 0;\n', '     \n', '    \n', '        return( _gains );\n', '        \n', '    }\n', '    \n', '    \n', '    function WithdrawGains() public \n', '   \n', '    {\n', '        address _customer_address = msg.sender;\n', '        \n', '        uint256 _gains = get_Gains( _customer_address );\n', '        \n', '        require( _gains>0);\n', '        \n', '        PlayerData[ _customer_address ].payoutsTo = PlayerData[ _customer_address ].payoutsTo.add( _gains );\n', '        \n', '      \n', '        emit onWithdrawGains( _customer_address , _gains , now);\n', '        \n', '        _customer_address.transfer( _gains );\n', '        \n', '        \n', '    }\n', '    \n', '   \n', '    \n', '   \n', '   \n', '  \n', '  \n', '    \n', '     /*================================\n', '    =  VIEW AND HELPERS FUNCTIONS    =\n', '    ================================*/\n', '  \n', '    \n', '    function view_get_Treasure() public\n', '    view\n', '    returns(uint256)\n', '    {\n', '      \n', '      return( GameRoundData.treasureAmount );  \n', '    }\n', '\t\n', '\tfunction view_get_Jackpot() public\n', '    view\n', '    returns(uint256)\n', '    {\n', '      \n', '      return( GameRoundData.jackpotAmount );  \n', '    }\n', ' \n', '    function view_get_gameData() public\n', '    view\n', '    returns( uint256 treasure,\n', '\t\t\t uint256 jackpot,\n', '\t\t\t uint32  highscore ,\n', '\t\t\t address highscore_address ,\n', '\t\t\t bytes32 highscore_name,\n', '\t\t\t uint32  highscore_turn,\n', '\t\t\t uint32  score_average,\n', '\t\t\n', '\t\t\t uint256 torpedoBatchID ,\n', '\t\t\t uint32 torpedoBatchMultiplier ,\n', '\t\t\t uint256 torpedoBatchBlockTimeout,\n', '\t\t\t uint32  score_maximum,\n', '\t\t\t uint32  percentage)\n', '    {\n', '        address _player_address = msg.sender;\n', '\t\t\n', '\t\ttreasure = GameRoundData.treasureAmount;\n', '\t\tjackpot = GameRoundData.jackpotAmount;\n', '\t\thighscore = GameRoundData.extraData[0];\n', '\t\thighscore_address = GameRoundData.currentJackpotWinner;\n', '\t\thighscore_name = view_get_registeredNames( GameRoundData.currentJackpotWinner  );\n', '\t\thighscore_turn = GameRoundData.extraData[1];\n', '\t\tscore_average = GameRoundData.extraData[2];\n', '\t\tscore_maximum =  GameRoundData.extraData[4];\n', '\t\t\n', '\t\tpercentage = GameRoundData.extraData[6];\n', '\t\t      \n', '        torpedoBatchID = PlayerData[_player_address].torpedoBatchID;\n', '        torpedoBatchMultiplier = PlayerData[_player_address].packedData[0];\n', '        torpedoBatchBlockTimeout = PlayerData[_player_address].torpedoBatchBlockTimeout;\n', '       \n', '    }\n', '  \n', '       \n', '  \n', '    \n', '    function view_get_Gains()\n', '    public\n', '    view\n', '    returns( uint256 gains)\n', '    {\n', '        \n', '        address _player_address = msg.sender;\n', '   \n', '      \n', '        uint256 _gains = PlayerData[ _player_address ].chest;\n', '        \n', '        if (_gains > PlayerData[ _player_address].payoutsTo)\n', '        {\n', '            _gains -= PlayerData[ _player_address].payoutsTo;\n', '        }\n', '        else _gains = 0;\n', '     \n', '    \n', '        return( _gains );\n', '        \n', '    }\n', '  \n', '  \n', '    \n', '    function view_get_gameStates() public \n', '    view\n', '    returns( uint256 minimumshare ,\n', '\t\t     uint256 blockNumberCurrent ,\n', '\t\t\t uint256 blockTimeAvg ,\n', '\t\t\t uint32  highscore ,\n', '\t\t\t address highscore_address ,\n', '\t\t\t bytes32 highscore_name,\n', '\t\t\t uint32  highscore_turn,\n', '\t\t\t uint256 jackpot,\n', '\t\t\t bytes32 myname,\n', '\t\t\t uint32  jackpotCycle)\n', '    {\n', '       \n', '        \n', '        return( minimumSharePrice ,  block.number , blockTimeAverage , GameRoundData.extraData[0] , GameRoundData.currentJackpotWinner , view_get_registeredNames( GameRoundData.currentJackpotWinner  ) , GameRoundData.extraData[1] , GameRoundData.jackpotAmount,  view_get_registeredNames(msg.sender) , GameRoundData.extraData[3]);\n', '    }\n', '    \n', '    function view_get_pendingHDX20Appreciation()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return GameRoundData.hdx20AppreciationPayout;\n', '    }\n', '    \n', '    function view_get_pendingDevAppreciation()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return GameRoundData.devAppreciationPayout;\n', '    }\n', '  \n', ' \n', ' \n', '    function totalEthereumBalance()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function view_get_maintenanceMode()\n', '    public\n', '    view\n', '    returns(bool)\n', '    {\n', '        return( maintenanceMode);\n', '    }\n', '    \n', '    function view_get_blockNumbers()\n', '    public\n', '    view\n', '    returns( uint256 b1 )\n', '    {\n', '        return( block.number);\n', '        \n', '    }\n', '    \n', '    function view_get_registeredNames(address _player)\n', '    public\n', '    view\n', '    returns( bytes32)\n', '    {\n', '        \n', '        return( registeredNames[ _player ]);\n', '    }\n', '    \n', '   \n', '}\n', '\n', '\n', 'library SafeMath {\n', '    \n', '   \n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '   \n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '   \n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}\n', '\n', '\n', 'library SafeMath128 {\n', '    \n', '   \n', '    function mul(uint128 a, uint128 b) \n', '        internal \n', '        pure \n', '        returns (uint128 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '   \n', '    function sub(uint128 a, uint128 b)\n', '        internal\n', '        pure\n', '        returns (uint128) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '   \n', '    function add(uint128 a, uint128 b)\n', '        internal\n', '        pure\n', '        returns (uint128 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}']