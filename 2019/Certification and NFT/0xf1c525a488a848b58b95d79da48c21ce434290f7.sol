['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Log Various Error Types\n', ' * @author Adam Lemmon <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c0a1a4a1ad80afb2a1a3aca9baa5eea9b4">[email&#160;protected]</a>>\n', ' * @dev Inherit this contract and your may now log errors easily\n', ' * To support various error types, params, etc.\n', ' */\n', 'contract LoggingErrors {\n', '  /**\n', '  * Events\n', '  */\n', '  event LogErrorString(string errorString);\n', '\n', '  /**\n', '  * Error cases\n', '  */\n', '\n', '  /**\n', '   * @dev Default error to simply log the error message and return\n', '   * @param _errorMessage The error message to log\n', '   * @return ALWAYS false\n', '   */\n', '  function error(string _errorMessage) internal returns(bool) {\n', '    LogErrorString(_errorMessage);\n', '    return false;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Wallet Connector\n', ' * @dev Connect the wallet contract to the correct Wallet Logic version\n', ' */\n', 'contract WalletConnector is LoggingErrors {\n', '  /**\n', '   * Storage\n', '   */\n', '  address public owner_;\n', '  address public latestLogic_;\n', '  uint256 public latestVersion_;\n', '  mapping(uint256 => address) public logicVersions_;\n', '  uint256 public birthBlock_;\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogLogicVersionAdded(uint256 version);\n', '  event LogLogicVersionRemoved(uint256 version);\n', '\n', '  /**\n', '   * @dev Constructor to set the latest logic address\n', '   * @param _latestVersion Latest version of the wallet logic\n', '   * @param _latestLogic Latest address of the wallet logic contract\n', '   */\n', '  function WalletConnector (\n', '    uint256 _latestVersion,\n', '    address _latestLogic\n', '  ) public {\n', '    owner_ = msg.sender;\n', '    latestLogic_ = _latestLogic;\n', '    latestVersion_ = _latestVersion;\n', '    logicVersions_[_latestVersion] = _latestLogic;\n', '    birthBlock_ = block.number;\n', '  }\n', '\n', '  /**\n', '   * Add a new version of the logic contract\n', '   * @param _version The version to be associated with the new contract.\n', '   * @param _logic New logic contract.\n', '   * @return Success of the transaction.\n', '   */\n', '  function addLogicVersion (\n', '    uint256 _version,\n', '    address _logic\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', '      return error(&#39;msg.sender != owner, WalletConnector.addLogicVersion()&#39;);\n', '\n', '    if (logicVersions_[_version] != 0)\n', '      return error(&#39;Version already exists, WalletConnector.addLogicVersion()&#39;);\n', '\n', '    // Update latest if this is the latest version\n', '    if (_version > latestVersion_) {\n', '      latestLogic_ = _logic;\n', '      latestVersion_ = _version;\n', '    }\n', '\n', '    logicVersions_[_version] = _logic;\n', '    LogLogicVersionAdded(_version);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Remove a version. Cannot remove the latest version.\n', '   * @param  _version The version to remove.\n', '   */\n', '  function removeLogicVersion(uint256 _version) external {\n', '    require(msg.sender == owner_);\n', '    require(_version != latestVersion_);\n', '    delete logicVersions_[_version];\n', '    LogLogicVersionRemoved(_version);\n', '  }\n', '\n', '  /**\n', '   * Constants\n', '   */\n', '\n', '  /**\n', '   * Called from user wallets in order to upgrade their logic.\n', '   * @param _version The version to upgrade to. NOTE pass in 0 to upgrade to latest.\n', '   * @return The address of the logic contract to upgrade to.\n', '   */\n', '  function getLogic(uint256 _version)\n', '    external\n', '    constant\n', '    returns(address)\n', '  {\n', '    if (_version == 0)\n', '      return latestLogic_;\n', '    else\n', '      return logicVersions_[_version];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Wallet to hold and trade ERC20 tokens and ether\n', ' * @author Adam Lemmon <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="95f4f1f4f8d5fae7f4f6f9fceff0bbfce1">[email&#160;protected]</a>>\n', ' * @dev User wallet to interact with the exchange.\n', ' * all tokens and ether held in this wallet, 1 to 1 mapping to user EOAs.\n', ' */\n', 'contract WalletV2 is LoggingErrors {\n', '  /**\n', '   * Storage\n', '   */\n', '  // Vars included in wallet logic "lib", the order must match between Wallet and Logic\n', '  address public owner_;\n', '  address public exchange_;\n', '  mapping(address => uint256) public tokenBalances_;\n', '\n', '  address public logic_; // storage location 0x3 loaded for delegatecalls so this var must remain at index 3\n', '  uint256 public birthBlock_;\n', '\n', '  WalletConnector private connector_;\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogDeposit(address token, uint256 amount, uint256 balance);\n', '  event LogWithdrawal(address token, uint256 amount, uint256 balance);\n', '\n', '  /**\n', '   * @dev Contract constructor. Set user as owner and connector address.\n', '   * @param _owner The address of the user&#39;s EOA, wallets created from the exchange\n', '   * so must past in the owner address, msg.sender == exchange.\n', '   * @param _connector The wallet connector to be used to retrieve the wallet logic\n', '   */\n', '  function WalletV2(address _owner, address _connector) public {\n', '    owner_ = _owner;\n', '    connector_ = WalletConnector(_connector);\n', '    exchange_ = msg.sender;\n', '    logic_ = connector_.latestLogic_();\n', '    birthBlock_ = block.number;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback - Only enable funds to be sent from the exchange.\n', '   * Ensures balances will be consistent.\n', '   */\n', '  function () external payable {\n', '    require(msg.sender == exchange_);\n', '  }\n', '\n', '  /**\n', '  * External\n', '  */\n', '\n', '  /**\n', '   * @dev Deposit ether into this wallet, default to address 0 for consistent token lookup.\n', '   */\n', '  function depositEther()\n', '    external\n', '    payable\n', '  {\n', '    require(logic_.delegatecall(bytes4(sha3(&#39;deposit(address,uint256)&#39;)), 0, msg.value));\n', '  }\n', '\n', '  /**\n', '   * @dev Deposit any ERC20 token into this wallet.\n', '   * @param _token The address of the existing token contract.\n', '   * @param _amount The amount of tokens to deposit.\n', '   * @return Bool if the deposit was successful.\n', '   */\n', '  function depositERC20Token (\n', '    address _token,\n', '    uint256 _amount\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    // ether\n', '    if (_token == 0)\n', '      return error(&#39;Cannot deposit ether via depositERC20, Wallet.depositERC20Token()&#39;);\n', '\n', '    require(logic_.delegatecall(bytes4(sha3(&#39;deposit(address,uint256)&#39;)), _token, _amount));\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev The result of an order, update the balance of this wallet.\n', '   * @param _token The address of the token balance to update.\n', '   * @param _amount The amount to update the balance by.\n', '   * @param _subtractionFlag If true then subtract the token amount else add.\n', '   * @return Bool if the update was successful.\n', '   */\n', '  function updateBalance (\n', '    address _token,\n', '    uint256 _amount,\n', '    bool _subtractionFlag\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * User may update to the latest version of the exchange contract.\n', '   * Note that multiple versions are NOT supported at this time and therefore if a\n', '   * user does not wish to update they will no longer be able to use the exchange.\n', '   * @param _exchange The new exchange.\n', '   * @return Success of this transaction.\n', '   */\n', '  function updateExchange(address _exchange)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', '      return error(&#39;msg.sender != owner_, Wallet.updateExchange()&#39;);\n', '\n', '    // If subsequent messages are not sent from this address all orders will fail\n', '    exchange_ = _exchange;\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * User may update to a new or older version of the logic contract.\n', '   * @param _version The versin to update to.\n', '   * @return Success of this transaction.\n', '   */\n', '  function updateLogic(uint256 _version)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', '      return error(&#39;msg.sender != owner_, Wallet.updateLogic()&#39;);\n', '\n', '    address newVersion = connector_.getLogic(_version);\n', '\n', '    // Invalid version as defined by connector\n', '    if (newVersion == 0)\n', '      return error(&#39;Invalid version, Wallet.updateLogic()&#39;);\n', '\n', '    logic_ = newVersion;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify an order that the Exchange has received involving this wallet.\n', '   * Internal checks and then authorize the exchange to move the tokens.\n', '   * If sending ether will transfer to the exchange to broker the trade.\n', '   * @param _token The address of the token contract being sold.\n', '   * @param _amount The amount of tokens the order is for.\n', '   * @param _fee The fee for the current trade.\n', '   * @param _feeToken The token of which the fee is to be paid in.\n', '   * @return If the order was verified or not.\n', '   */\n', '  function verifyOrder (\n', '    address _token,\n', '    uint256 _amount,\n', '    uint256 _fee,\n', '    address _feeToken\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw any token, including ether from this wallet to an EOA.\n', '   * @param _token The address of the token to withdraw.\n', '   * @param _amount The amount to withdraw.\n', '   * @return Success of the withdrawal.\n', '   */\n', '  function withdraw(address _token, uint256 _amount)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if(msg.sender != owner_)\n', '      return error(&#39;msg.sender != owner, Wallet.withdraw()&#39;);\n', '\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Constants\n', '   */\n', '\n', '  /**\n', '   * @dev Get the balance for a specific token.\n', '   * @param _token The address of the token contract to retrieve the balance of.\n', '   * @return The current balance within this contract.\n', '   */\n', '  function balanceOf(address _token)\n', '    public\n', '    view\n', '    returns(uint)\n', '  {\n', '    return tokenBalances_[_token];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'interface ExchangeV1 {\n', '  function userAccountToWallet_(address) external returns(address);\n', '}\n', '\n', 'interface BadERC20 {\n', '  function transfer(address to, uint value) external;\n', '  function transferFrom(address from, address to, uint256 value) external;\n', '}\n', '\n', '/**\n', ' * @title Decentralized exchange for ether and ERC20 tokens.\n', ' * @author Eidoo SAGL.\n', ' * @dev All trades brokered by this contract.\n', ' * Orders submitted by off chain order book and this contract handles\n', ' * verification and execution of orders.\n', ' * All value between parties is transferred via this exchange.\n', ' * Methods arranged by visibility; external, public, internal, private and alphabatized within.\n', ' *\n', ' * New Exchange SC with eventually no fee and ERC20 tokens as quote\n', ' */\n', 'contract ExchangeV2 is LoggingErrors {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Data Structures\n', '   */\n', '  struct Order {\n', '    address offerToken_;\n', '    uint256 offerTokenTotal_;\n', '    uint256 offerTokenRemaining_;  // Amount left to give\n', '    address wantToken_;\n', '    uint256 wantTokenTotal_;\n', '    uint256 wantTokenReceived_;  // Amount received, note this may exceed want total\n', '  }\n', '\n', '  struct OrderStatus {\n', '    uint256 expirationBlock_;\n', '    uint256 wantTokenReceived_;    // Amount received, note this may exceed want total\n', '    uint256 offerTokenRemaining_;  // Amount left to give\n', '  }\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '  address public previousExchangeAddress_;\n', '  address private orderBookAccount_;\n', '  address public owner_;\n', '  uint256 public birthBlock_;\n', '  address public edoToken_;\n', '  address public walletConnector;\n', '\n', '  mapping (address => uint256) public feeEdoPerQuote;\n', '  mapping (address => uint256) public feeEdoPerQuoteDecimals;\n', '\n', '  address public eidooWallet_;\n', '\n', '  // Define if fee calculation must be skipped for a given trade. By default (false) fee must not be skipped.\n', '  mapping(address => mapping(address => bool)) public mustSkipFee;\n', '\n', '  /**\n', '   * @dev Define in a trade who is the quote using a priority system:\n', '   * values example\n', '   *   0: not used as quote\n', '   *  >0: used as quote\n', '   *  if wanted and offered tokens have value > 0 the quote is the token with the bigger value\n', '   */\n', '  mapping(address => uint256) public quotePriority;\n', '\n', '  mapping(bytes32 => OrderStatus) public orders_; // Map order hashes to order data struct\n', '  mapping(address => address) public userAccountToWallet_; // User EOA to wallet addresses\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogFeeRateSet(address indexed token, uint256 rate, uint256 decimals);\n', '  event LogQuotePrioritySet(address indexed quoteToken, uint256 priority);\n', '  event LogMustSkipFeeSet(address indexed base, address indexed quote, bool mustSkipFee);\n', '  event LogUserAdded(address indexed user, address walletAddress);\n', '  event LogWalletDeposit(address indexed walletAddress, address token, uint256 amount, uint256 balance);\n', '  event LogWalletWithdrawal(address indexed walletAddress, address token, uint256 amount, uint256 balance);\n', '\n', '  event LogOrderExecutionSuccess(\n', '    bytes32 indexed makerOrderId,\n', '    bytes32 indexed takerOrderId,\n', '    uint256 toMaker,\n', '    uint256 toTaker\n', '  );\n', '  event LogOrderFilled(bytes32 indexed orderId, uint256 totalOfferRemaining, uint256 totalWantReceived);\n', '\n', '  /**\n', '   * @dev Contract constructor - CONFIRM matches contract name.  Set owner and addr of order book.\n', '   * @param _bookAccount The EOA address for the order book, will submit ALL orders.\n', '   * @param _edoToken Deployed edo token.\n', '   * @param _edoPerWei Rate of edo tokens per wei.\n', '   * @param _edoPerWeiDecimals Decimlas carried in edo rate.\n', '   * @param _eidooWallet Wallet to pay fees to.\n', '   * @param _previousExchangeAddress Previous exchange smart contract address.\n', '   */\n', '  constructor (\n', '    address _bookAccount,\n', '    address _edoToken,\n', '    uint256 _edoPerWei,\n', '    uint256 _edoPerWeiDecimals,\n', '    address _eidooWallet,\n', '    address _previousExchangeAddress,\n', '    address _walletConnector\n', '  ) public {\n', '    orderBookAccount_ = _bookAccount;\n', '    owner_ = msg.sender;\n', '    birthBlock_ = block.number;\n', '    edoToken_ = _edoToken;\n', '    feeEdoPerQuote[address(0)] = _edoPerWei;\n', '    feeEdoPerQuoteDecimals[address(0)] = _edoPerWeiDecimals;\n', '    eidooWallet_ = _eidooWallet;\n', '    quotePriority[address(0)] = 10;\n', '    previousExchangeAddress_ = _previousExchangeAddress;\n', '    require(_walletConnector != address (0), "WalletConnector address == 0");\n', '    walletConnector = _walletConnector;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback. wallets utilize to send ether in order to broker trade.\n', '   */\n', '  function () external payable { }\n', '\n', '  /**\n', '   * External\n', '   */\n', '\n', '  /**\n', '   * @dev Returns the Wallet contract address associated to a user account. If the user account is not known, try to\n', '   * migrate the wallet address from the old exchange instance. This function is equivalent to getWallet(), in addition\n', '   * it stores the wallet address fetched from old the exchange instance.\n', '   * @param userAccount The user account address\n', '   * @return The address of the Wallet instance associated to the user account\n', '   */\n', '  function retrieveWallet(address userAccount)\n', '    public\n', '    returns(address walletAddress)\n', '  {\n', '    walletAddress = userAccountToWallet_[userAccount];\n', '    if (walletAddress == address(0) && previousExchangeAddress_ != 0) {\n', '      // Retrieve the wallet address from the old exchange.\n', '      walletAddress = ExchangeV1(previousExchangeAddress_).userAccountToWallet_(userAccount);\n', '      // TODO: in the future versions of the exchange the above line must be replaced with the following one\n', '      //walletAddress = ExchangeV2(previousExchangeAddress_).retrieveWallet(userAccount);\n', '\n', '      if (walletAddress != address(0)) {\n', '        userAccountToWallet_[userAccount] = walletAddress;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Add a new user to the exchange, create a wallet for them.\n', '   * Map their account address to the wallet contract for lookup.\n', '   * @param userExternalOwnedAccount The address of the user"s EOA.\n', '   * @return Success of the transaction, false if error condition met.\n', '   */\n', '  function addNewUser(address userExternalOwnedAccount)\n', '    public\n', '    returns (bool)\n', '  {\n', '    if (retrieveWallet(userExternalOwnedAccount) != address(0)) {\n', '      return error("User already exists, Exchange.addNewUser()");\n', '    }\n', '\n', '    // Pass the userAccount address to wallet constructor so owner is not the exchange contract\n', '    address userTradingWallet = new WalletV2(userExternalOwnedAccount, walletConnector);\n', '    userAccountToWallet_[userExternalOwnedAccount] = userTradingWallet;\n', '    emit LogUserAdded(userExternalOwnedAccount, userTradingWallet);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Execute orders in batches.\n', '   * @param ownedExternalAddressesAndTokenAddresses Tokan and user addresses.\n', '   * @param amountsExpirationsAndSalts Offer and want token amount and expiration and salt values.\n', '   * @param vSignatures All order signature v values.\n', '   * @param rAndSsignatures All order signature r and r values.\n', '   * @return The success of this transaction.\n', '   */\n', '  function batchExecuteOrder(\n', '    address[4][] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8][] amountsExpirationsAndSalts, // Packing to save stack size\n', '    uint8[2][] vSignatures,\n', '    bytes32[4][] rAndSsignatures\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    for (uint256 i = 0; i < amountsExpirationsAndSalts.length; i++) {\n', '      require(\n', '        executeOrder(\n', '          ownedExternalAddressesAndTokenAddresses[i],\n', '          amountsExpirationsAndSalts[i],\n', '          vSignatures[i],\n', '          rAndSsignatures[i]\n', '        ),\n', '        "Cannot execute order, Exchange.batchExecuteOrder()"\n', '      );\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Execute an order that was submitted by the external order book server.\n', '   * The order book server believes it to be a match.\n', '   * There are components for both orders, maker and taker, 2 signatures as well.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param amountsExpirationsAndSalts The amount of tokens and the block number at which this order expires and a random number to mitigate replay.\n', '   * [\n', '   *   makerOffer\n', '   *   makerWant\n', '   *   takerOffer\n', '   *   takerWant\n', '   *   makerExpiry\n', '   *   makerSalt\n', '   *   takerExpiry\n', '   *   takerSalt\n', '   * ]\n', '   * @param vSignatures ECDSA signature parameter.\n', '   * [\n', '   *   maker V\n', '   *   taker V\n', '   * ]\n', '   * @param rAndSsignatures ECDSA signature parameters r ans s, maker 0, 1 and taker 2, 3.\n', '   * [\n', '   *   maker R\n', '   *   maker S\n', '   *   taker R\n', '   *   taker S\n', '   * ]\n', '   * @return Success of the transaction, false if error condition met.\n', '   * Like types grouped to eliminate stack depth error.\n', '   */\n', '  function executeOrder (\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts, // Packing to save stack size\n', '    uint8[2] vSignatures,\n', '    bytes32[4] rAndSsignatures\n', '  ) public\n', '    returns(bool)\n', '  {\n', '    // Only read wallet addresses from storage once\n', '    // Need one more stack slot so squashing into array\n', '    WalletV2[2] memory makerAndTakerTradingWallets = [\n', '      WalletV2(retrieveWallet(ownedExternalAddressesAndTokenAddresses[0])), // maker\n', '      WalletV2(retrieveWallet(ownedExternalAddressesAndTokenAddresses[2])) // taker\n', '    ];\n', '\n', '    // Basic pre-conditions, return if any input data is invalid\n', '    if(!__executeOrderInputIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses,\n', '      amountsExpirationsAndSalts,\n', '      makerAndTakerTradingWallets[0], // maker\n', '      makerAndTakerTradingWallets[1] // taker\n', '    )) {\n', '      return error("Input is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Verify Maker and Taker signatures\n', '    bytes32[2] memory makerAndTakerOrderHash = generateOrderHashes(\n', '      ownedExternalAddressesAndTokenAddresses,\n', '      amountsExpirationsAndSalts\n', '    );\n', '\n', '    // Check maker order signature\n', '    if (!__signatureIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses[0],\n', '      makerAndTakerOrderHash[0],\n', '      vSignatures[0],\n', '      rAndSsignatures[0],\n', '      rAndSsignatures[1]\n', '    )) {\n', '      return error("Maker signature is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Check taker order signature\n', '    if (!__signatureIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses[2],\n', '      makerAndTakerOrderHash[1],\n', '      vSignatures[1],\n', '      rAndSsignatures[2],\n', '      rAndSsignatures[3]\n', '    )) {\n', '      return error("Taker signature is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Exchange Order Verification and matching\n', '    OrderStatus memory makerOrderStatus = orders_[makerAndTakerOrderHash[0]];\n', '    OrderStatus memory takerOrderStatus = orders_[makerAndTakerOrderHash[1]];\n', '    Order memory makerOrder;\n', '    Order memory takerOrder;\n', '\n', '    makerOrder.offerToken_ = ownedExternalAddressesAndTokenAddresses[1];\n', '    makerOrder.offerTokenTotal_ = amountsExpirationsAndSalts[0];\n', '    makerOrder.wantToken_ = ownedExternalAddressesAndTokenAddresses[3];\n', '    makerOrder.wantTokenTotal_ = amountsExpirationsAndSalts[1];\n', '\n', '    if (makerOrderStatus.expirationBlock_ > 0) {  // Check for existence\n', '      // Orders still active\n', '      if (makerOrderStatus.offerTokenRemaining_ == 0) {\n', '        return error("Maker order is inactive, Exchange.executeOrder()");\n', '      }\n', '      makerOrder.offerTokenRemaining_ = makerOrderStatus.offerTokenRemaining_; // Amount to give\n', '      makerOrder.wantTokenReceived_ = makerOrderStatus.wantTokenReceived_; // Amount received\n', '    } else {\n', '      makerOrder.offerTokenRemaining_ = amountsExpirationsAndSalts[0]; // Amount to give\n', '      makerOrder.wantTokenReceived_ = 0; // Amount received\n', '      makerOrderStatus.expirationBlock_ = amountsExpirationsAndSalts[4]; // maker order expiration block\n', '    }\n', '\n', '    takerOrder.offerToken_ = ownedExternalAddressesAndTokenAddresses[3];\n', '    takerOrder.offerTokenTotal_ = amountsExpirationsAndSalts[2];\n', '    takerOrder.wantToken_ = ownedExternalAddressesAndTokenAddresses[1];\n', '    takerOrder.wantTokenTotal_ = amountsExpirationsAndSalts[3];\n', '\n', '    if (takerOrderStatus.expirationBlock_ > 0) {  // Check for existence\n', '      if (takerOrderStatus.offerTokenRemaining_ == 0) {\n', '        return error("Taker order is inactive, Exchange.executeOrder()");\n', '      }\n', '      takerOrder.offerTokenRemaining_ = takerOrderStatus.offerTokenRemaining_;  // Amount to give\n', '      takerOrder.wantTokenReceived_ = takerOrderStatus.wantTokenReceived_; // Amount received\n', '\n', '    } else {\n', '      takerOrder.offerTokenRemaining_ = amountsExpirationsAndSalts[2];  // Amount to give\n', '      takerOrder.wantTokenReceived_ = 0; // Amount received\n', '      takerOrderStatus.expirationBlock_ = amountsExpirationsAndSalts[6]; // taker order expiration block\n', '    }\n', '\n', '    // Check if orders are matching and are valid\n', '    if (!__ordersMatch_and_AreVaild__(makerOrder, takerOrder)) {\n', '      return error("Orders do not match, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Trade amounts\n', '    // [0] => toTakerAmount\n', '    // [1] => toMakerAmount\n', '    uint[2] memory toTakerAndToMakerAmount;\n', '    toTakerAndToMakerAmount = __getTradeAmounts__(makerOrder, takerOrder);\n', '\n', '    // TODO consider removing. Can this condition be met?\n', '    if (toTakerAndToMakerAmount[0] < 1 || toTakerAndToMakerAmount[1] < 1) {\n', '      return error("Token amount < 1, price ratio is invalid! Token value < 1, Exchange.executeOrder()");\n', '    }\n', '\n', '    uint calculatedFee = __calculateFee__(makerOrder, toTakerAndToMakerAmount[0], toTakerAndToMakerAmount[1]);\n', '\n', '    // Check taker has sufficent EDO token balance to pay the fee\n', '    if (\n', '      takerOrder.offerToken_ == edoToken_ &&\n', '      Token(edoToken_).balanceOf(makerAndTakerTradingWallets[1]) < calculatedFee.add(toTakerAndToMakerAmount[1])\n', '    ) {\n', '      return error("Taker has an insufficient EDO token balance to cover the fee AND the offer, Exchange.executeOrder()");\n', '    } else if (Token(edoToken_).balanceOf(makerAndTakerTradingWallets[1]) < calculatedFee) {\n', '      return error("Taker has an insufficient EDO token balance to cover the fee, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Wallet Order Verification, reach out to the maker and taker wallets.\n', '    if (\n', '      !__ordersVerifiedByWallets__(\n', '        ownedExternalAddressesAndTokenAddresses,\n', '        toTakerAndToMakerAmount[1],\n', '        toTakerAndToMakerAmount[0],\n', '        makerAndTakerTradingWallets[0],\n', '        makerAndTakerTradingWallets[1],\n', '        calculatedFee\n', '    )) {\n', '      return error("Order could not be verified by wallets, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Write to storage then external calls\n', '    makerOrderStatus.offerTokenRemaining_ = makerOrder.offerTokenRemaining_.sub(toTakerAndToMakerAmount[0]);\n', '    makerOrderStatus.wantTokenReceived_ = makerOrder.wantTokenReceived_.add(toTakerAndToMakerAmount[1]);\n', '\n', '    takerOrderStatus.offerTokenRemaining_ = takerOrder.offerTokenRemaining_.sub(toTakerAndToMakerAmount[1]);\n', '    takerOrderStatus.wantTokenReceived_ = takerOrder.wantTokenReceived_.add(toTakerAndToMakerAmount[0]);\n', '\n', '    // Finally write orders to storage\n', '    orders_[makerAndTakerOrderHash[0]] = makerOrderStatus;\n', '    orders_[makerAndTakerOrderHash[1]] = takerOrderStatus;\n', '\n', '    // Transfer the external value, ether <> tokens\n', '    require(\n', '      __executeTokenTransfer__(\n', '        ownedExternalAddressesAndTokenAddresses,\n', '        toTakerAndToMakerAmount[0],\n', '        toTakerAndToMakerAmount[1],\n', '        calculatedFee,\n', '        makerAndTakerTradingWallets[0],\n', '        makerAndTakerTradingWallets[1]\n', '      ),\n', '      "Cannot execute token transfer, Exchange.__executeTokenTransfer__()"\n', '    );\n', '\n', '    // Log the order id(hash), amount of offer given, amount of offer remaining\n', '    emit LogOrderFilled(makerAndTakerOrderHash[0], makerOrderStatus.offerTokenRemaining_, makerOrderStatus.wantTokenReceived_);\n', '    emit LogOrderFilled(makerAndTakerOrderHash[1], takerOrderStatus.offerTokenRemaining_, takerOrderStatus.wantTokenReceived_);\n', '    emit LogOrderExecutionSuccess(makerAndTakerOrderHash[0], makerAndTakerOrderHash[1], toTakerAndToMakerAmount[1], toTakerAndToMakerAmount[0]);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set the fee rate for a specific quote\n', '   * @param _quoteToken Quote token.\n', '   * @param _edoPerQuote EdoPerQuote.\n', '   * @param _edoPerQuoteDecimals EdoPerQuoteDecimals.\n', '   * @return Success of the transaction.\n', '   */\n', '  function setFeeRate(\n', '    address _quoteToken,\n', '    uint256 _edoPerQuote,\n', '    uint256 _edoPerQuoteDecimals\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setFeeRate()");\n', '    }\n', '\n', '    if (quotePriority[_quoteToken] == 0) {\n', '      return error("quotePriority[_quoteToken] == 0, Exchange.setFeeRate()");\n', '    }\n', '\n', '    feeEdoPerQuote[_quoteToken] = _edoPerQuote;\n', '    feeEdoPerQuoteDecimals[_quoteToken] = _edoPerQuoteDecimals;\n', '\n', '    emit LogFeeRateSet(_quoteToken, _edoPerQuote, _edoPerQuoteDecimals);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set the wallet for fees to be paid to.\n', '   * @param eidooWallet Wallet to pay fees to.\n', '   * @return Success of the transaction.\n', '   */\n', '  function setEidooWallet(\n', '    address eidooWallet\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setEidooWallet()");\n', '    }\n', '    eidooWallet_ = eidooWallet;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set a new order book account.\n', '   * @param account The new order book account.\n', '   */\n', '  function setOrderBookAcount (\n', '    address account\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setOrderBookAcount()");\n', '    }\n', '    orderBookAccount_ = account;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set if a base must skip fee calculation.\n', '   * @param _baseTokenAddress The trade base token address that must skip fee calculation.\n', '   * @param _quoteTokenAddress The trade quote token address that must skip fee calculation.\n', '   * @param _mustSkipFee The trade base token address that must skip fee calculation.\n', '   */\n', '  function setMustSkipFee (\n', '    address _baseTokenAddress,\n', '    address _quoteTokenAddress,\n', '    bool _mustSkipFee\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    // Preserving same owner check style\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setMustSkipFee()");\n', '    }\n', '    mustSkipFee[_baseTokenAddress][_quoteTokenAddress] = _mustSkipFee;\n', '    emit LogMustSkipFeeSet(_baseTokenAddress, _quoteTokenAddress, _mustSkipFee);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set quote priority token.\n', '   * Set the sorting of token quote based on a priority.\n', '   * @param _token The address of the token that was deposited.\n', '   * @param _priority The amount of the token that was deposited.\n', '   * @return Operation success.\n', '   */\n', '\n', '  function setQuotePriority(address _token, uint256 _priority)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setQuotePriority()");\n', '    }\n', '    quotePriority[_token] = _priority;\n', '    emit LogQuotePrioritySet(_token, _priority);\n', '    return true;\n', '  }\n', '\n', '  /*\n', '   Methods to catch events from external contracts, user wallets primarily\n', '   */\n', '\n', '  /**\n', '   * @dev Simply log the event to track wallet interaction off-chain.\n', '   * @param tokenAddress The address of the token that was deposited.\n', '   * @param amount The amount of the token that was deposited.\n', '   * @param tradingWalletBalance The updated balance of the wallet after deposit.\n', '   */\n', '  function walletDeposit(\n', '    address tokenAddress,\n', '    uint256 amount,\n', '    uint256 tradingWalletBalance\n', '  ) external\n', '  {\n', '    emit LogWalletDeposit(msg.sender, tokenAddress, amount, tradingWalletBalance);\n', '  }\n', '\n', '  /**\n', '   * @dev Simply log the event to track wallet interaction off-chain.\n', '   * @param tokenAddress The address of the token that was deposited.\n', '   * @param amount The amount of the token that was deposited.\n', '   * @param tradingWalletBalance The updated balance of the wallet after deposit.\n', '   */\n', '  function walletWithdrawal(\n', '    address tokenAddress,\n', '    uint256 amount,\n', '    uint256 tradingWalletBalance\n', '  ) external\n', '  {\n', '    emit LogWalletWithdrawal(msg.sender, tokenAddress, amount, tradingWalletBalance);\n', '  }\n', '\n', '  /**\n', '   * Private\n', '   */\n', '\n', '  /**\n', '   * Calculate the fee for the given trade. Calculated as the set % of the wei amount\n', '   * converted into EDO tokens using the manually set conversion ratio.\n', '   * @param makerOrder The maker order object.\n', '   * @param toTakerAmount The amount of tokens going to the taker.\n', '   * @param toMakerAmount The amount of tokens going to the maker.\n', '   * @return The total fee to be paid in EDO tokens.\n', '   */\n', '  function __calculateFee__(\n', '    Order makerOrder,\n', '    uint256 toTakerAmount,\n', '    uint256 toMakerAmount\n', '  ) private\n', '    view\n', '    returns(uint256)\n', '  {\n', '    // weiAmount * (fee %) * (EDO/Wei) / (decimals in edo/wei) / (decimals in percentage)\n', '    if (!__isSell__(makerOrder)) {\n', '      // buy -> the quote is the offered token by the maker\n', '      return mustSkipFee[makerOrder.wantToken_][makerOrder.offerToken_]\n', '        ? 0\n', '        : toTakerAmount.mul(feeEdoPerQuote[makerOrder.offerToken_]).div(10**feeEdoPerQuoteDecimals[makerOrder.offerToken_]);\n', '    } else {\n', '      // sell -> the quote is the wanted token by the maker\n', '      return mustSkipFee[makerOrder.offerToken_][makerOrder.wantToken_]\n', '        ? 0\n', '        : toMakerAmount.mul(feeEdoPerQuote[makerOrder.wantToken_]).div(10**feeEdoPerQuoteDecimals[makerOrder.wantToken_]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Verify the input to order execution is valid.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param amountsExpirationsAndSalts The amount of tokens and the block number at which this order expires and a random number to mitigate replay.\n', '   * [\n', '   *   makerOffer\n', '   *   makerWant\n', '   *   takerOffer\n', '   *   takerWant\n', '   *   makerExpiry\n', '   *   makerSalt\n', '   *   takerExpiry\n', '   *   takerSalt\n', '   * ]\n', '   * @return Success if all checks pass.\n', '   */\n', '  function __executeOrderInputIsValid__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts,\n', '    address makerTradingWallet,\n', '    address takerTradingWallet\n', '  ) private\n', '    returns(bool)\n', '  {\n', '    // msg.send needs to be the orderBookAccount\n', '    if (msg.sender != orderBookAccount_) {\n', '      return error("msg.sender != orderBookAccount, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Check expirations base on the block number\n', '    if (block.number > amountsExpirationsAndSalts[4]) {\n', '      return error("Maker order has expired, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (block.number > amountsExpirationsAndSalts[6]) {\n', '      return error("Taker order has expired, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Operating on existing tradingWallets\n', '    if (makerTradingWallet == address(0)) {\n', '      return error("Maker wallet does not exist, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (takerTradingWallet == address(0)) {\n', '      return error("Taker wallet does not exist, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (quotePriority[ownedExternalAddressesAndTokenAddresses[1]] == quotePriority[ownedExternalAddressesAndTokenAddresses[3]]) {\n', '      return error("Quote token is omitted! Is not offered by either the Taker or Maker, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Check that none of the amounts is = to 0\n', '    if (\n', '        amountsExpirationsAndSalts[0] == 0 ||\n', '        amountsExpirationsAndSalts[1] == 0 ||\n', '        amountsExpirationsAndSalts[2] == 0 ||\n', '        amountsExpirationsAndSalts[3] == 0\n', '      )\n', '      return error("May not execute an order where token amount == 0, Exchange.__executeOrderInputIsValid__()");\n', '\n', '    // // Confirm order ether amount >= min amount\n', '    //  // Maker\n', '    //  uint256 minOrderEthAmount = minOrderEthAmount_; // Single storage read\n', '    //  if (_token_and_EOA_Addresses[1] == 0 && _amountsExpirationAndSalt[0] < minOrderEthAmount)\n', '    //    return error(&#39;Maker order does not meet the minOrderEthAmount_ of ether, Exchange.__executeOrderInputIsValid__()&#39;);\n', '\n', '    //  // Taker\n', '    //  if (_token_and_EOA_Addresses[3] == 0 && _amountsExpirationAndSalt[2] < minOrderEthAmount)\n', '    //    return error(&#39;Taker order does not meet the minOrderEthAmount_ of ether, Exchange.__executeOrderInputIsValid__()&#39;);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Execute the external transfer of tokens.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param toTakerAmount The amount of tokens to transfer to the taker.\n', '   * @param toMakerAmount The amount of tokens to transfer to the maker.\n', '   * @return Success if both wallets verify the order.\n', '   */\n', '  function __executeTokenTransfer__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256 toTakerAmount,\n', '    uint256 toMakerAmount,\n', '    uint256 fee,\n', '    WalletV2 makerTradingWallet,\n', '    WalletV2 takerTradingWallet\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Wallet mapping balances\n', '    address makerOfferTokenAddress = ownedExternalAddressesAndTokenAddresses[1];\n', '    address takerOfferTokenAddress = ownedExternalAddressesAndTokenAddresses[3];\n', '\n', '    // Taker to pay fee before trading\n', '    if(fee != 0) {\n', '      require(\n', '        takerTradingWallet.updateBalance(edoToken_, fee, true),\n', '        "Taker trading wallet cannot update balance with fee, Exchange.__executeTokenTransfer__()"\n', '      );\n', '\n', '      require(\n', '        Token(edoToken_).transferFrom(takerTradingWallet, eidooWallet_, fee),\n', '        "Cannot transfer fees from taker trading wallet to eidoo wallet, Exchange.__executeTokenTransfer__()"\n', '      );\n', '    }\n', '\n', '    // Updating makerTradingWallet balance by the toTaker\n', '    require(\n', '      makerTradingWallet.updateBalance(makerOfferTokenAddress, toTakerAmount, true),\n', '      "Maker trading wallet cannot update balance subtracting toTakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to subtract maker token from maker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating takerTradingWallet balance by the toTaker\n', '    require(\n', '      takerTradingWallet.updateBalance(makerOfferTokenAddress, toTakerAmount, false),\n', '      "Taker trading wallet cannot update balance adding toTakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to add maker token to taker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating takerTradingWallet balance by the toMaker amount\n', '    require(\n', '      takerTradingWallet.updateBalance(takerOfferTokenAddress, toMakerAmount, true),\n', '      "Taker trading wallet cannot update balance subtracting toMakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to subtract taker token from taker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating makerTradingWallet balance by the toMaker amount\n', '    require(\n', '      makerTradingWallet.updateBalance(takerOfferTokenAddress, toMakerAmount, false),\n', '      "Maker trading wallet cannot update balance adding toMakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to add taker token to maker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Ether to the taker and tokens to the maker\n', '    if (makerOfferTokenAddress == address(0)) {\n', '      address(takerTradingWallet).transfer(toTakerAmount);\n', '    } else {\n', '      require(\n', '        safeTransferFrom(makerOfferTokenAddress, makerTradingWallet, takerTradingWallet, toTakerAmount),\n', '        "Token transfership from makerTradingWallet to takerTradingWallet failed, Exchange.__executeTokenTransfer__()"\n', '      );\n', '      assert(\n', '        __tokenAndWalletBalancesMatch__(\n', '          makerTradingWallet,\n', '          takerTradingWallet,\n', '          makerOfferTokenAddress\n', '        )\n', '      );\n', '    }\n', '\n', '    if (takerOfferTokenAddress == address(0)) {\n', '      address(makerTradingWallet).transfer(toMakerAmount);\n', '    } else {\n', '      require(\n', '        safeTransferFrom(takerOfferTokenAddress, takerTradingWallet, makerTradingWallet, toMakerAmount),\n', '        "Token transfership from takerTradingWallet to makerTradingWallet failed, Exchange.__executeTokenTransfer__()"\n', '      );\n', '      assert(\n', '        __tokenAndWalletBalancesMatch__(\n', '          makerTradingWallet,\n', '          takerTradingWallet,\n', '          takerOfferTokenAddress\n', '        )\n', '      );\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates Keccak-256 hash of order with specified parameters.\n', '   * @param ownedExternalAddressesAndTokenAddresses The orders maker EOA and current exchange address.\n', '   * @param amountsExpirationsAndSalts The orders offer and want amounts and expirations with salts.\n', '   * @return Keccak-256 hash of the passed order.\n', '   */\n', '\n', '  function generateOrderHashes(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts\n', '  ) public\n', '    view\n', '    returns (bytes32[2])\n', '  {\n', '    bytes32 makerOrderHash = keccak256(\n', '      address(this),\n', '      ownedExternalAddressesAndTokenAddresses[0], // _makerEOA\n', '      ownedExternalAddressesAndTokenAddresses[1], // offerToken\n', '      amountsExpirationsAndSalts[0],  // offerTokenAmount\n', '      ownedExternalAddressesAndTokenAddresses[3], // wantToken\n', '      amountsExpirationsAndSalts[1],  // wantTokenAmount\n', '      amountsExpirationsAndSalts[4], // expiry\n', '      amountsExpirationsAndSalts[5] // salt\n', '    );\n', '\n', '    bytes32 takerOrderHash = keccak256(\n', '      address(this),\n', '      ownedExternalAddressesAndTokenAddresses[2], // _makerEOA\n', '      ownedExternalAddressesAndTokenAddresses[3], // offerToken\n', '      amountsExpirationsAndSalts[2],  // offerTokenAmount\n', '      ownedExternalAddressesAndTokenAddresses[1], // wantToken\n', '      amountsExpirationsAndSalts[3],  // wantTokenAmount\n', '      amountsExpirationsAndSalts[6], // expiry\n', '      amountsExpirationsAndSalts[7] // salt\n', '    );\n', '\n', '    return [makerOrderHash, takerOrderHash];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a bool representing a SELL or BUY order based on quotePriority.\n', '   * @param _order The maker order data structure.\n', '   * @return The bool indicating if the order is a SELL or BUY.\n', '   */\n', '  function __isSell__(Order _order) internal view returns (bool) {\n', '    return quotePriority[_order.offerToken_] < quotePriority[_order.wantToken_];\n', '  }\n', '\n', '  /**\n', '   * @dev Compute the tradeable amounts of the two verified orders.\n', '   * Token amount is the __min__ remaining between want and offer of the two orders that isn"t ether.\n', '   * Ether amount is then: etherAmount = tokenAmount * priceRatio, as ratio = eth / token.\n', '   * @param makerOrder The maker order data structure.\n', '   * @param takerOrder The taker order data structure.\n', '   * @return The amount moving from makerOfferRemaining to takerWantRemaining and vice versa.\n', '   */\n', '  function __getTradeAmounts__(\n', '    Order makerOrder,\n', '    Order takerOrder\n', '  ) internal\n', '    view\n', '    returns (uint256[2])\n', '  {\n', '    bool isMakerBuy = __isSell__(takerOrder);  // maker buy = taker sell\n', '    uint256 priceRatio;\n', '    uint256 makerAmountLeftToReceive;\n', '    uint256 takerAmountLeftToReceive;\n', '\n', '    uint toTakerAmount;\n', '    uint toMakerAmount;\n', '\n', '    if (makerOrder.offerTokenTotal_ >= makerOrder.wantTokenTotal_) {\n', '      priceRatio = makerOrder.offerTokenTotal_.mul(2**128).div(makerOrder.wantTokenTotal_);\n', '      if (isMakerBuy) {\n', '        // MP > 1\n', '        makerAmountLeftToReceive = makerOrder.wantTokenTotal_.sub(makerOrder.wantTokenReceived_);\n', '        toMakerAmount = __min__(takerOrder.offerTokenRemaining_, makerAmountLeftToReceive);\n', '        // add 2**128-1 in order to obtain a round up\n', '        toTakerAmount = toMakerAmount.mul(priceRatio).add(2**128-1).div(2**128);\n', '      } else {\n', '        // MP < 1\n', '        takerAmountLeftToReceive = takerOrder.wantTokenTotal_.sub(takerOrder.wantTokenReceived_);\n', '        toTakerAmount = __min__(makerOrder.offerTokenRemaining_, takerAmountLeftToReceive);\n', '        toMakerAmount = toTakerAmount.mul(2**128).div(priceRatio);\n', '      }\n', '    } else {\n', '      priceRatio = makerOrder.wantTokenTotal_.mul(2**128).div(makerOrder.offerTokenTotal_);\n', '      if (isMakerBuy) {\n', '        // MP < 1\n', '        makerAmountLeftToReceive = makerOrder.wantTokenTotal_.sub(makerOrder.wantTokenReceived_);\n', '        toMakerAmount = __min__(takerOrder.offerTokenRemaining_, makerAmountLeftToReceive);\n', '        toTakerAmount = toMakerAmount.mul(2**128).div(priceRatio);\n', '      } else {\n', '        // MP > 1\n', '        takerAmountLeftToReceive = takerOrder.wantTokenTotal_.sub(takerOrder.wantTokenReceived_);\n', '        toTakerAmount = __min__(makerOrder.offerTokenRemaining_, takerAmountLeftToReceive);\n', '        // add 2**128-1 in order to obtain a round up\n', '        toMakerAmount = toTakerAmount.mul(priceRatio).add(2**128-1).div(2**128);\n', '      }\n', '    }\n', '    return [toTakerAmount, toMakerAmount];\n', '  }\n', '\n', '  /**\n', '   * @dev Return the maximum of two uints\n', '   * @param a Uint 1\n', '   * @param b Uint 2\n', '   * @return The grater value or a if equal\n', '   */\n', '  function __max__(uint256 a, uint256 b)\n', '    private\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return a < b\n', '      ? b\n', '      : a;\n', '  }\n', '\n', '  /**\n', '   * @dev Return the minimum of two uints\n', '   * @param a Uint 1\n', '   * @param b Uint 2\n', '   * @return The smallest value or b if equal\n', '   */\n', '  function __min__(uint256 a, uint256 b)\n', '    private\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return a < b\n', '      ? a\n', '      : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Confirm that the orders do match and are valid.\n', '   * @param makerOrder The maker order data structure.\n', '   * @param takerOrder The taker order data structure.\n', '   * @return Bool if the orders passes all checks.\n', '   */\n', '  function __ordersMatch_and_AreVaild__(\n', '    Order makerOrder,\n', '    Order takerOrder\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Confirm tokens match\n', '    // NOTE potentially omit as matching handled upstream?\n', '    if (makerOrder.wantToken_ != takerOrder.offerToken_) {\n', '      return error("Maker wanted token does not match taker offer token, Exchange.__ordersMatch_and_AreVaild__()");\n', '    }\n', '\n', '    if (makerOrder.offerToken_ != takerOrder.wantToken_) {\n', '      return error("Maker offer token does not match taker wanted token, Exchange.__ordersMatch_and_AreVaild__()");\n', '    }\n', '\n', '    // Price Ratios, to x decimal places hence * decimals, dependent on the size of the denominator.\n', '    // Ratios are relative to eth, amount of ether for a single token, ie. ETH / GNO == 0.2 Ether per 1 Gnosis\n', '\n', '    uint256 orderPrice;   // The price the maker is willing to accept\n', '    uint256 offeredPrice; // The offer the taker has given\n', '\n', '    // Ratio = larger amount / smaller amount\n', '    if (makerOrder.offerTokenTotal_ >= makerOrder.wantTokenTotal_) {\n', '      orderPrice = makerOrder.offerTokenTotal_.mul(2**128).div(makerOrder.wantTokenTotal_);\n', '      offeredPrice = takerOrder.wantTokenTotal_.mul(2**128).div(takerOrder.offerTokenTotal_);\n', '\n', '      // ie. Maker is offering 10 ETH for 100 GNO but taker is offering 100 GNO for 20 ETH, no match!\n', '      // The taker wants more ether than the maker is offering.\n', '      if (orderPrice < offeredPrice) {\n', '        return error("Taker price is greater than maker price, Exchange.__ordersMatch_and_AreVaild__()");\n', '      }\n', '    } else {\n', '      orderPrice = makerOrder.wantTokenTotal_.mul(2**128).div(makerOrder.offerTokenTotal_);\n', '      offeredPrice = takerOrder.offerTokenTotal_.mul(2**128).div(takerOrder.wantTokenTotal_);\n', '\n', '      // ie. Maker is offering 100 GNO for 10 ETH but taker is offering 5 ETH for 100 GNO, no match!\n', '      // The taker is not offering enough ether for the maker\n', '      if (orderPrice > offeredPrice) {\n', '        return error("Taker price is less than maker price, Exchange.__ordersMatch_and_AreVaild__()");\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Ask each wallet to verify this order.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param toMakerAmount The amount of tokens to be sent to the maker.\n', '   * @param toTakerAmount The amount of tokens to be sent to the taker.\n', '   * @param makerTradingWallet The maker trading wallet contract.\n', '   * @param takerTradingWallet The taker trading wallet contract.\n', '   * @param fee The fee to be paid for this trade, paid in full by taker.\n', '   * @return Success if both wallets verify the order.\n', '   */\n', '  function __ordersVerifiedByWallets__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256 toMakerAmount,\n', '    uint256 toTakerAmount,\n', '    WalletV2 makerTradingWallet,\n', '    WalletV2 takerTradingWallet,\n', '    uint256 fee\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Have the transaction verified by both maker and taker wallets\n', '    // confirm sufficient balance to transfer, offerToken and offerTokenAmount\n', '    if(!makerTradingWallet.verifyOrder(ownedExternalAddressesAndTokenAddresses[1], toTakerAmount, 0, 0)) {\n', '      return error("Maker wallet could not verify the order, Exchange.____ordersVerifiedByWallets____()");\n', '    }\n', '\n', '    if(!takerTradingWallet.verifyOrder(ownedExternalAddressesAndTokenAddresses[3], toMakerAmount, fee, edoToken_)) {\n', '      return error("Taker wallet could not verify the order, Exchange.____ordersVerifiedByWallets____()");\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev On chain verification of an ECDSA ethereum signature.\n', '   * @param signer The EOA address of the account that supposedly signed the message.\n', '   * @param orderHash The on-chain generated hash for the order.\n', '   * @param v ECDSA signature parameter v.\n', '   * @param r ECDSA signature parameter r.\n', '   * @param s ECDSA signature parameter s.\n', '   * @return Bool if the signature is valid or not.\n', '   */\n', '  function __signatureIsValid__(\n', '    address signer,\n', '    bytes32 orderHash,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) private\n', '    pure\n', '    returns (bool)\n', '  {\n', '    address recoveredAddr = ecrecover(\n', '      keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)),\n', '      v,\n', '      r,\n', '      s\n', '    );\n', '\n', '    return recoveredAddr == signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Confirm wallet local balances and token balances match.\n', '   * @param makerTradingWallet  Maker wallet address.\n', '   * @param takerTradingWallet  Taker wallet address.\n', '   * @param token  Token address to confirm balances match.\n', '   * @return If the balances do match.\n', '   */\n', '  function __tokenAndWalletBalancesMatch__(\n', '    address makerTradingWallet,\n', '    address takerTradingWallet,\n', '    address token\n', '  ) private\n', '    view\n', '    returns(bool)\n', '  {\n', '    if (Token(token).balanceOf(makerTradingWallet) != WalletV2(makerTradingWallet).balanceOf(token)) {\n', '      return false;\n', '    }\n', '\n', '    if (Token(token).balanceOf(takerTradingWallet) != WalletV2(takerTradingWallet).balanceOf(token)) {\n', '      return false;\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Wrapping the ERC20 transfer function to avoid missing returns.\n', '   * @param _token The address of bad formed ERC20 token.\n', '   * @param _from Transfer sender.\n', '   * @param _to Transfer receiver.\n', '   * @param _value Amount to be transfered.\n', '   * @return Success of the safeTransfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool result)\n', '  {\n', '    BadERC20(_token).transferFrom(_from, _to, _value);\n', '\n', '    assembly {\n', '      switch returndatasize()\n', '      case 0 {                      // This is our BadToken\n', '        result := not(0)            // result is true\n', '      }\n', '      case 32 {                     // This is our GoodToken\n', '        returndatacopy(0, 0, 32)\n', '        result := mload(0)          // result == returndata of external call\n', '      }\n', '      default {                     // This is not an ERC20 token\n', '        revert(0, 0)\n', '      }\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Log Various Error Types\n', ' * @author Adam Lemmon <adam@oraclize.it>\n', ' * @dev Inherit this contract and your may now log errors easily\n', ' * To support various error types, params, etc.\n', ' */\n', 'contract LoggingErrors {\n', '  /**\n', '  * Events\n', '  */\n', '  event LogErrorString(string errorString);\n', '\n', '  /**\n', '  * Error cases\n', '  */\n', '\n', '  /**\n', '   * @dev Default error to simply log the error message and return\n', '   * @param _errorMessage The error message to log\n', '   * @return ALWAYS false\n', '   */\n', '  function error(string _errorMessage) internal returns(bool) {\n', '    LogErrorString(_errorMessage);\n', '    return false;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Wallet Connector\n', ' * @dev Connect the wallet contract to the correct Wallet Logic version\n', ' */\n', 'contract WalletConnector is LoggingErrors {\n', '  /**\n', '   * Storage\n', '   */\n', '  address public owner_;\n', '  address public latestLogic_;\n', '  uint256 public latestVersion_;\n', '  mapping(uint256 => address) public logicVersions_;\n', '  uint256 public birthBlock_;\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogLogicVersionAdded(uint256 version);\n', '  event LogLogicVersionRemoved(uint256 version);\n', '\n', '  /**\n', '   * @dev Constructor to set the latest logic address\n', '   * @param _latestVersion Latest version of the wallet logic\n', '   * @param _latestLogic Latest address of the wallet logic contract\n', '   */\n', '  function WalletConnector (\n', '    uint256 _latestVersion,\n', '    address _latestLogic\n', '  ) public {\n', '    owner_ = msg.sender;\n', '    latestLogic_ = _latestLogic;\n', '    latestVersion_ = _latestVersion;\n', '    logicVersions_[_latestVersion] = _latestLogic;\n', '    birthBlock_ = block.number;\n', '  }\n', '\n', '  /**\n', '   * Add a new version of the logic contract\n', '   * @param _version The version to be associated with the new contract.\n', '   * @param _logic New logic contract.\n', '   * @return Success of the transaction.\n', '   */\n', '  function addLogicVersion (\n', '    uint256 _version,\n', '    address _logic\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', "      return error('msg.sender != owner, WalletConnector.addLogicVersion()');\n", '\n', '    if (logicVersions_[_version] != 0)\n', "      return error('Version already exists, WalletConnector.addLogicVersion()');\n", '\n', '    // Update latest if this is the latest version\n', '    if (_version > latestVersion_) {\n', '      latestLogic_ = _logic;\n', '      latestVersion_ = _version;\n', '    }\n', '\n', '    logicVersions_[_version] = _logic;\n', '    LogLogicVersionAdded(_version);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Remove a version. Cannot remove the latest version.\n', '   * @param  _version The version to remove.\n', '   */\n', '  function removeLogicVersion(uint256 _version) external {\n', '    require(msg.sender == owner_);\n', '    require(_version != latestVersion_);\n', '    delete logicVersions_[_version];\n', '    LogLogicVersionRemoved(_version);\n', '  }\n', '\n', '  /**\n', '   * Constants\n', '   */\n', '\n', '  /**\n', '   * Called from user wallets in order to upgrade their logic.\n', '   * @param _version The version to upgrade to. NOTE pass in 0 to upgrade to latest.\n', '   * @return The address of the logic contract to upgrade to.\n', '   */\n', '  function getLogic(uint256 _version)\n', '    external\n', '    constant\n', '    returns(address)\n', '  {\n', '    if (_version == 0)\n', '      return latestLogic_;\n', '    else\n', '      return logicVersions_[_version];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Wallet to hold and trade ERC20 tokens and ether\n', ' * @author Adam Lemmon <adam@oraclize.it>\n', ' * @dev User wallet to interact with the exchange.\n', ' * all tokens and ether held in this wallet, 1 to 1 mapping to user EOAs.\n', ' */\n', 'contract WalletV2 is LoggingErrors {\n', '  /**\n', '   * Storage\n', '   */\n', '  // Vars included in wallet logic "lib", the order must match between Wallet and Logic\n', '  address public owner_;\n', '  address public exchange_;\n', '  mapping(address => uint256) public tokenBalances_;\n', '\n', '  address public logic_; // storage location 0x3 loaded for delegatecalls so this var must remain at index 3\n', '  uint256 public birthBlock_;\n', '\n', '  WalletConnector private connector_;\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogDeposit(address token, uint256 amount, uint256 balance);\n', '  event LogWithdrawal(address token, uint256 amount, uint256 balance);\n', '\n', '  /**\n', '   * @dev Contract constructor. Set user as owner and connector address.\n', "   * @param _owner The address of the user's EOA, wallets created from the exchange\n", '   * so must past in the owner address, msg.sender == exchange.\n', '   * @param _connector The wallet connector to be used to retrieve the wallet logic\n', '   */\n', '  function WalletV2(address _owner, address _connector) public {\n', '    owner_ = _owner;\n', '    connector_ = WalletConnector(_connector);\n', '    exchange_ = msg.sender;\n', '    logic_ = connector_.latestLogic_();\n', '    birthBlock_ = block.number;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback - Only enable funds to be sent from the exchange.\n', '   * Ensures balances will be consistent.\n', '   */\n', '  function () external payable {\n', '    require(msg.sender == exchange_);\n', '  }\n', '\n', '  /**\n', '  * External\n', '  */\n', '\n', '  /**\n', '   * @dev Deposit ether into this wallet, default to address 0 for consistent token lookup.\n', '   */\n', '  function depositEther()\n', '    external\n', '    payable\n', '  {\n', "    require(logic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));\n", '  }\n', '\n', '  /**\n', '   * @dev Deposit any ERC20 token into this wallet.\n', '   * @param _token The address of the existing token contract.\n', '   * @param _amount The amount of tokens to deposit.\n', '   * @return Bool if the deposit was successful.\n', '   */\n', '  function depositERC20Token (\n', '    address _token,\n', '    uint256 _amount\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    // ether\n', '    if (_token == 0)\n', "      return error('Cannot deposit ether via depositERC20, Wallet.depositERC20Token()');\n", '\n', "    require(logic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), _token, _amount));\n", '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev The result of an order, update the balance of this wallet.\n', '   * @param _token The address of the token balance to update.\n', '   * @param _amount The amount to update the balance by.\n', '   * @param _subtractionFlag If true then subtract the token amount else add.\n', '   * @return Bool if the update was successful.\n', '   */\n', '  function updateBalance (\n', '    address _token,\n', '    uint256 _amount,\n', '    bool _subtractionFlag\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * User may update to the latest version of the exchange contract.\n', '   * Note that multiple versions are NOT supported at this time and therefore if a\n', '   * user does not wish to update they will no longer be able to use the exchange.\n', '   * @param _exchange The new exchange.\n', '   * @return Success of this transaction.\n', '   */\n', '  function updateExchange(address _exchange)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', "      return error('msg.sender != owner_, Wallet.updateExchange()');\n", '\n', '    // If subsequent messages are not sent from this address all orders will fail\n', '    exchange_ = _exchange;\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * User may update to a new or older version of the logic contract.\n', '   * @param _version The versin to update to.\n', '   * @return Success of this transaction.\n', '   */\n', '  function updateLogic(uint256 _version)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_)\n', "      return error('msg.sender != owner_, Wallet.updateLogic()');\n", '\n', '    address newVersion = connector_.getLogic(_version);\n', '\n', '    // Invalid version as defined by connector\n', '    if (newVersion == 0)\n', "      return error('Invalid version, Wallet.updateLogic()');\n", '\n', '    logic_ = newVersion;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Verify an order that the Exchange has received involving this wallet.\n', '   * Internal checks and then authorize the exchange to move the tokens.\n', '   * If sending ether will transfer to the exchange to broker the trade.\n', '   * @param _token The address of the token contract being sold.\n', '   * @param _amount The amount of tokens the order is for.\n', '   * @param _fee The fee for the current trade.\n', '   * @param _feeToken The token of which the fee is to be paid in.\n', '   * @return If the order was verified or not.\n', '   */\n', '  function verifyOrder (\n', '    address _token,\n', '    uint256 _amount,\n', '    uint256 _fee,\n', '    address _feeToken\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw any token, including ether from this wallet to an EOA.\n', '   * @param _token The address of the token to withdraw.\n', '   * @param _amount The amount to withdraw.\n', '   * @return Success of the withdrawal.\n', '   */\n', '  function withdraw(address _token, uint256 _amount)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if(msg.sender != owner_)\n', "      return error('msg.sender != owner, Wallet.withdraw()');\n", '\n', '    assembly {\n', '      calldatacopy(0x40, 0, calldatasize)\n', '      delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32)\n', '      return(0, 32)\n', '      pop\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Constants\n', '   */\n', '\n', '  /**\n', '   * @dev Get the balance for a specific token.\n', '   * @param _token The address of the token contract to retrieve the balance of.\n', '   * @return The current balance within this contract.\n', '   */\n', '  function balanceOf(address _token)\n', '    public\n', '    view\n', '    returns(uint)\n', '  {\n', '    return tokenBalances_[_token];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'interface ExchangeV1 {\n', '  function userAccountToWallet_(address) external returns(address);\n', '}\n', '\n', 'interface BadERC20 {\n', '  function transfer(address to, uint value) external;\n', '  function transferFrom(address from, address to, uint256 value) external;\n', '}\n', '\n', '/**\n', ' * @title Decentralized exchange for ether and ERC20 tokens.\n', ' * @author Eidoo SAGL.\n', ' * @dev All trades brokered by this contract.\n', ' * Orders submitted by off chain order book and this contract handles\n', ' * verification and execution of orders.\n', ' * All value between parties is transferred via this exchange.\n', ' * Methods arranged by visibility; external, public, internal, private and alphabatized within.\n', ' *\n', ' * New Exchange SC with eventually no fee and ERC20 tokens as quote\n', ' */\n', 'contract ExchangeV2 is LoggingErrors {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * Data Structures\n', '   */\n', '  struct Order {\n', '    address offerToken_;\n', '    uint256 offerTokenTotal_;\n', '    uint256 offerTokenRemaining_;  // Amount left to give\n', '    address wantToken_;\n', '    uint256 wantTokenTotal_;\n', '    uint256 wantTokenReceived_;  // Amount received, note this may exceed want total\n', '  }\n', '\n', '  struct OrderStatus {\n', '    uint256 expirationBlock_;\n', '    uint256 wantTokenReceived_;    // Amount received, note this may exceed want total\n', '    uint256 offerTokenRemaining_;  // Amount left to give\n', '  }\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '  address public previousExchangeAddress_;\n', '  address private orderBookAccount_;\n', '  address public owner_;\n', '  uint256 public birthBlock_;\n', '  address public edoToken_;\n', '  address public walletConnector;\n', '\n', '  mapping (address => uint256) public feeEdoPerQuote;\n', '  mapping (address => uint256) public feeEdoPerQuoteDecimals;\n', '\n', '  address public eidooWallet_;\n', '\n', '  // Define if fee calculation must be skipped for a given trade. By default (false) fee must not be skipped.\n', '  mapping(address => mapping(address => bool)) public mustSkipFee;\n', '\n', '  /**\n', '   * @dev Define in a trade who is the quote using a priority system:\n', '   * values example\n', '   *   0: not used as quote\n', '   *  >0: used as quote\n', '   *  if wanted and offered tokens have value > 0 the quote is the token with the bigger value\n', '   */\n', '  mapping(address => uint256) public quotePriority;\n', '\n', '  mapping(bytes32 => OrderStatus) public orders_; // Map order hashes to order data struct\n', '  mapping(address => address) public userAccountToWallet_; // User EOA to wallet addresses\n', '\n', '  /**\n', '   * Events\n', '   */\n', '  event LogFeeRateSet(address indexed token, uint256 rate, uint256 decimals);\n', '  event LogQuotePrioritySet(address indexed quoteToken, uint256 priority);\n', '  event LogMustSkipFeeSet(address indexed base, address indexed quote, bool mustSkipFee);\n', '  event LogUserAdded(address indexed user, address walletAddress);\n', '  event LogWalletDeposit(address indexed walletAddress, address token, uint256 amount, uint256 balance);\n', '  event LogWalletWithdrawal(address indexed walletAddress, address token, uint256 amount, uint256 balance);\n', '\n', '  event LogOrderExecutionSuccess(\n', '    bytes32 indexed makerOrderId,\n', '    bytes32 indexed takerOrderId,\n', '    uint256 toMaker,\n', '    uint256 toTaker\n', '  );\n', '  event LogOrderFilled(bytes32 indexed orderId, uint256 totalOfferRemaining, uint256 totalWantReceived);\n', '\n', '  /**\n', '   * @dev Contract constructor - CONFIRM matches contract name.  Set owner and addr of order book.\n', '   * @param _bookAccount The EOA address for the order book, will submit ALL orders.\n', '   * @param _edoToken Deployed edo token.\n', '   * @param _edoPerWei Rate of edo tokens per wei.\n', '   * @param _edoPerWeiDecimals Decimlas carried in edo rate.\n', '   * @param _eidooWallet Wallet to pay fees to.\n', '   * @param _previousExchangeAddress Previous exchange smart contract address.\n', '   */\n', '  constructor (\n', '    address _bookAccount,\n', '    address _edoToken,\n', '    uint256 _edoPerWei,\n', '    uint256 _edoPerWeiDecimals,\n', '    address _eidooWallet,\n', '    address _previousExchangeAddress,\n', '    address _walletConnector\n', '  ) public {\n', '    orderBookAccount_ = _bookAccount;\n', '    owner_ = msg.sender;\n', '    birthBlock_ = block.number;\n', '    edoToken_ = _edoToken;\n', '    feeEdoPerQuote[address(0)] = _edoPerWei;\n', '    feeEdoPerQuoteDecimals[address(0)] = _edoPerWeiDecimals;\n', '    eidooWallet_ = _eidooWallet;\n', '    quotePriority[address(0)] = 10;\n', '    previousExchangeAddress_ = _previousExchangeAddress;\n', '    require(_walletConnector != address (0), "WalletConnector address == 0");\n', '    walletConnector = _walletConnector;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback. wallets utilize to send ether in order to broker trade.\n', '   */\n', '  function () external payable { }\n', '\n', '  /**\n', '   * External\n', '   */\n', '\n', '  /**\n', '   * @dev Returns the Wallet contract address associated to a user account. If the user account is not known, try to\n', '   * migrate the wallet address from the old exchange instance. This function is equivalent to getWallet(), in addition\n', '   * it stores the wallet address fetched from old the exchange instance.\n', '   * @param userAccount The user account address\n', '   * @return The address of the Wallet instance associated to the user account\n', '   */\n', '  function retrieveWallet(address userAccount)\n', '    public\n', '    returns(address walletAddress)\n', '  {\n', '    walletAddress = userAccountToWallet_[userAccount];\n', '    if (walletAddress == address(0) && previousExchangeAddress_ != 0) {\n', '      // Retrieve the wallet address from the old exchange.\n', '      walletAddress = ExchangeV1(previousExchangeAddress_).userAccountToWallet_(userAccount);\n', '      // TODO: in the future versions of the exchange the above line must be replaced with the following one\n', '      //walletAddress = ExchangeV2(previousExchangeAddress_).retrieveWallet(userAccount);\n', '\n', '      if (walletAddress != address(0)) {\n', '        userAccountToWallet_[userAccount] = walletAddress;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Add a new user to the exchange, create a wallet for them.\n', '   * Map their account address to the wallet contract for lookup.\n', '   * @param userExternalOwnedAccount The address of the user"s EOA.\n', '   * @return Success of the transaction, false if error condition met.\n', '   */\n', '  function addNewUser(address userExternalOwnedAccount)\n', '    public\n', '    returns (bool)\n', '  {\n', '    if (retrieveWallet(userExternalOwnedAccount) != address(0)) {\n', '      return error("User already exists, Exchange.addNewUser()");\n', '    }\n', '\n', '    // Pass the userAccount address to wallet constructor so owner is not the exchange contract\n', '    address userTradingWallet = new WalletV2(userExternalOwnedAccount, walletConnector);\n', '    userAccountToWallet_[userExternalOwnedAccount] = userTradingWallet;\n', '    emit LogUserAdded(userExternalOwnedAccount, userTradingWallet);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Execute orders in batches.\n', '   * @param ownedExternalAddressesAndTokenAddresses Tokan and user addresses.\n', '   * @param amountsExpirationsAndSalts Offer and want token amount and expiration and salt values.\n', '   * @param vSignatures All order signature v values.\n', '   * @param rAndSsignatures All order signature r and r values.\n', '   * @return The success of this transaction.\n', '   */\n', '  function batchExecuteOrder(\n', '    address[4][] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8][] amountsExpirationsAndSalts, // Packing to save stack size\n', '    uint8[2][] vSignatures,\n', '    bytes32[4][] rAndSsignatures\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    for (uint256 i = 0; i < amountsExpirationsAndSalts.length; i++) {\n', '      require(\n', '        executeOrder(\n', '          ownedExternalAddressesAndTokenAddresses[i],\n', '          amountsExpirationsAndSalts[i],\n', '          vSignatures[i],\n', '          rAndSsignatures[i]\n', '        ),\n', '        "Cannot execute order, Exchange.batchExecuteOrder()"\n', '      );\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Execute an order that was submitted by the external order book server.\n', '   * The order book server believes it to be a match.\n', '   * There are components for both orders, maker and taker, 2 signatures as well.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param amountsExpirationsAndSalts The amount of tokens and the block number at which this order expires and a random number to mitigate replay.\n', '   * [\n', '   *   makerOffer\n', '   *   makerWant\n', '   *   takerOffer\n', '   *   takerWant\n', '   *   makerExpiry\n', '   *   makerSalt\n', '   *   takerExpiry\n', '   *   takerSalt\n', '   * ]\n', '   * @param vSignatures ECDSA signature parameter.\n', '   * [\n', '   *   maker V\n', '   *   taker V\n', '   * ]\n', '   * @param rAndSsignatures ECDSA signature parameters r ans s, maker 0, 1 and taker 2, 3.\n', '   * [\n', '   *   maker R\n', '   *   maker S\n', '   *   taker R\n', '   *   taker S\n', '   * ]\n', '   * @return Success of the transaction, false if error condition met.\n', '   * Like types grouped to eliminate stack depth error.\n', '   */\n', '  function executeOrder (\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts, // Packing to save stack size\n', '    uint8[2] vSignatures,\n', '    bytes32[4] rAndSsignatures\n', '  ) public\n', '    returns(bool)\n', '  {\n', '    // Only read wallet addresses from storage once\n', '    // Need one more stack slot so squashing into array\n', '    WalletV2[2] memory makerAndTakerTradingWallets = [\n', '      WalletV2(retrieveWallet(ownedExternalAddressesAndTokenAddresses[0])), // maker\n', '      WalletV2(retrieveWallet(ownedExternalAddressesAndTokenAddresses[2])) // taker\n', '    ];\n', '\n', '    // Basic pre-conditions, return if any input data is invalid\n', '    if(!__executeOrderInputIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses,\n', '      amountsExpirationsAndSalts,\n', '      makerAndTakerTradingWallets[0], // maker\n', '      makerAndTakerTradingWallets[1] // taker\n', '    )) {\n', '      return error("Input is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Verify Maker and Taker signatures\n', '    bytes32[2] memory makerAndTakerOrderHash = generateOrderHashes(\n', '      ownedExternalAddressesAndTokenAddresses,\n', '      amountsExpirationsAndSalts\n', '    );\n', '\n', '    // Check maker order signature\n', '    if (!__signatureIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses[0],\n', '      makerAndTakerOrderHash[0],\n', '      vSignatures[0],\n', '      rAndSsignatures[0],\n', '      rAndSsignatures[1]\n', '    )) {\n', '      return error("Maker signature is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Check taker order signature\n', '    if (!__signatureIsValid__(\n', '      ownedExternalAddressesAndTokenAddresses[2],\n', '      makerAndTakerOrderHash[1],\n', '      vSignatures[1],\n', '      rAndSsignatures[2],\n', '      rAndSsignatures[3]\n', '    )) {\n', '      return error("Taker signature is invalid, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Exchange Order Verification and matching\n', '    OrderStatus memory makerOrderStatus = orders_[makerAndTakerOrderHash[0]];\n', '    OrderStatus memory takerOrderStatus = orders_[makerAndTakerOrderHash[1]];\n', '    Order memory makerOrder;\n', '    Order memory takerOrder;\n', '\n', '    makerOrder.offerToken_ = ownedExternalAddressesAndTokenAddresses[1];\n', '    makerOrder.offerTokenTotal_ = amountsExpirationsAndSalts[0];\n', '    makerOrder.wantToken_ = ownedExternalAddressesAndTokenAddresses[3];\n', '    makerOrder.wantTokenTotal_ = amountsExpirationsAndSalts[1];\n', '\n', '    if (makerOrderStatus.expirationBlock_ > 0) {  // Check for existence\n', '      // Orders still active\n', '      if (makerOrderStatus.offerTokenRemaining_ == 0) {\n', '        return error("Maker order is inactive, Exchange.executeOrder()");\n', '      }\n', '      makerOrder.offerTokenRemaining_ = makerOrderStatus.offerTokenRemaining_; // Amount to give\n', '      makerOrder.wantTokenReceived_ = makerOrderStatus.wantTokenReceived_; // Amount received\n', '    } else {\n', '      makerOrder.offerTokenRemaining_ = amountsExpirationsAndSalts[0]; // Amount to give\n', '      makerOrder.wantTokenReceived_ = 0; // Amount received\n', '      makerOrderStatus.expirationBlock_ = amountsExpirationsAndSalts[4]; // maker order expiration block\n', '    }\n', '\n', '    takerOrder.offerToken_ = ownedExternalAddressesAndTokenAddresses[3];\n', '    takerOrder.offerTokenTotal_ = amountsExpirationsAndSalts[2];\n', '    takerOrder.wantToken_ = ownedExternalAddressesAndTokenAddresses[1];\n', '    takerOrder.wantTokenTotal_ = amountsExpirationsAndSalts[3];\n', '\n', '    if (takerOrderStatus.expirationBlock_ > 0) {  // Check for existence\n', '      if (takerOrderStatus.offerTokenRemaining_ == 0) {\n', '        return error("Taker order is inactive, Exchange.executeOrder()");\n', '      }\n', '      takerOrder.offerTokenRemaining_ = takerOrderStatus.offerTokenRemaining_;  // Amount to give\n', '      takerOrder.wantTokenReceived_ = takerOrderStatus.wantTokenReceived_; // Amount received\n', '\n', '    } else {\n', '      takerOrder.offerTokenRemaining_ = amountsExpirationsAndSalts[2];  // Amount to give\n', '      takerOrder.wantTokenReceived_ = 0; // Amount received\n', '      takerOrderStatus.expirationBlock_ = amountsExpirationsAndSalts[6]; // taker order expiration block\n', '    }\n', '\n', '    // Check if orders are matching and are valid\n', '    if (!__ordersMatch_and_AreVaild__(makerOrder, takerOrder)) {\n', '      return error("Orders do not match, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Trade amounts\n', '    // [0] => toTakerAmount\n', '    // [1] => toMakerAmount\n', '    uint[2] memory toTakerAndToMakerAmount;\n', '    toTakerAndToMakerAmount = __getTradeAmounts__(makerOrder, takerOrder);\n', '\n', '    // TODO consider removing. Can this condition be met?\n', '    if (toTakerAndToMakerAmount[0] < 1 || toTakerAndToMakerAmount[1] < 1) {\n', '      return error("Token amount < 1, price ratio is invalid! Token value < 1, Exchange.executeOrder()");\n', '    }\n', '\n', '    uint calculatedFee = __calculateFee__(makerOrder, toTakerAndToMakerAmount[0], toTakerAndToMakerAmount[1]);\n', '\n', '    // Check taker has sufficent EDO token balance to pay the fee\n', '    if (\n', '      takerOrder.offerToken_ == edoToken_ &&\n', '      Token(edoToken_).balanceOf(makerAndTakerTradingWallets[1]) < calculatedFee.add(toTakerAndToMakerAmount[1])\n', '    ) {\n', '      return error("Taker has an insufficient EDO token balance to cover the fee AND the offer, Exchange.executeOrder()");\n', '    } else if (Token(edoToken_).balanceOf(makerAndTakerTradingWallets[1]) < calculatedFee) {\n', '      return error("Taker has an insufficient EDO token balance to cover the fee, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Wallet Order Verification, reach out to the maker and taker wallets.\n', '    if (\n', '      !__ordersVerifiedByWallets__(\n', '        ownedExternalAddressesAndTokenAddresses,\n', '        toTakerAndToMakerAmount[1],\n', '        toTakerAndToMakerAmount[0],\n', '        makerAndTakerTradingWallets[0],\n', '        makerAndTakerTradingWallets[1],\n', '        calculatedFee\n', '    )) {\n', '      return error("Order could not be verified by wallets, Exchange.executeOrder()");\n', '    }\n', '\n', '    // Write to storage then external calls\n', '    makerOrderStatus.offerTokenRemaining_ = makerOrder.offerTokenRemaining_.sub(toTakerAndToMakerAmount[0]);\n', '    makerOrderStatus.wantTokenReceived_ = makerOrder.wantTokenReceived_.add(toTakerAndToMakerAmount[1]);\n', '\n', '    takerOrderStatus.offerTokenRemaining_ = takerOrder.offerTokenRemaining_.sub(toTakerAndToMakerAmount[1]);\n', '    takerOrderStatus.wantTokenReceived_ = takerOrder.wantTokenReceived_.add(toTakerAndToMakerAmount[0]);\n', '\n', '    // Finally write orders to storage\n', '    orders_[makerAndTakerOrderHash[0]] = makerOrderStatus;\n', '    orders_[makerAndTakerOrderHash[1]] = takerOrderStatus;\n', '\n', '    // Transfer the external value, ether <> tokens\n', '    require(\n', '      __executeTokenTransfer__(\n', '        ownedExternalAddressesAndTokenAddresses,\n', '        toTakerAndToMakerAmount[0],\n', '        toTakerAndToMakerAmount[1],\n', '        calculatedFee,\n', '        makerAndTakerTradingWallets[0],\n', '        makerAndTakerTradingWallets[1]\n', '      ),\n', '      "Cannot execute token transfer, Exchange.__executeTokenTransfer__()"\n', '    );\n', '\n', '    // Log the order id(hash), amount of offer given, amount of offer remaining\n', '    emit LogOrderFilled(makerAndTakerOrderHash[0], makerOrderStatus.offerTokenRemaining_, makerOrderStatus.wantTokenReceived_);\n', '    emit LogOrderFilled(makerAndTakerOrderHash[1], takerOrderStatus.offerTokenRemaining_, takerOrderStatus.wantTokenReceived_);\n', '    emit LogOrderExecutionSuccess(makerAndTakerOrderHash[0], makerAndTakerOrderHash[1], toTakerAndToMakerAmount[1], toTakerAndToMakerAmount[0]);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set the fee rate for a specific quote\n', '   * @param _quoteToken Quote token.\n', '   * @param _edoPerQuote EdoPerQuote.\n', '   * @param _edoPerQuoteDecimals EdoPerQuoteDecimals.\n', '   * @return Success of the transaction.\n', '   */\n', '  function setFeeRate(\n', '    address _quoteToken,\n', '    uint256 _edoPerQuote,\n', '    uint256 _edoPerQuoteDecimals\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setFeeRate()");\n', '    }\n', '\n', '    if (quotePriority[_quoteToken] == 0) {\n', '      return error("quotePriority[_quoteToken] == 0, Exchange.setFeeRate()");\n', '    }\n', '\n', '    feeEdoPerQuote[_quoteToken] = _edoPerQuote;\n', '    feeEdoPerQuoteDecimals[_quoteToken] = _edoPerQuoteDecimals;\n', '\n', '    emit LogFeeRateSet(_quoteToken, _edoPerQuote, _edoPerQuoteDecimals);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set the wallet for fees to be paid to.\n', '   * @param eidooWallet Wallet to pay fees to.\n', '   * @return Success of the transaction.\n', '   */\n', '  function setEidooWallet(\n', '    address eidooWallet\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setEidooWallet()");\n', '    }\n', '    eidooWallet_ = eidooWallet;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set a new order book account.\n', '   * @param account The new order book account.\n', '   */\n', '  function setOrderBookAcount (\n', '    address account\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setOrderBookAcount()");\n', '    }\n', '    orderBookAccount_ = account;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set if a base must skip fee calculation.\n', '   * @param _baseTokenAddress The trade base token address that must skip fee calculation.\n', '   * @param _quoteTokenAddress The trade quote token address that must skip fee calculation.\n', '   * @param _mustSkipFee The trade base token address that must skip fee calculation.\n', '   */\n', '  function setMustSkipFee (\n', '    address _baseTokenAddress,\n', '    address _quoteTokenAddress,\n', '    bool _mustSkipFee\n', '  ) external\n', '    returns(bool)\n', '  {\n', '    // Preserving same owner check style\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setMustSkipFee()");\n', '    }\n', '    mustSkipFee[_baseTokenAddress][_quoteTokenAddress] = _mustSkipFee;\n', '    emit LogMustSkipFeeSet(_baseTokenAddress, _quoteTokenAddress, _mustSkipFee);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Set quote priority token.\n', '   * Set the sorting of token quote based on a priority.\n', '   * @param _token The address of the token that was deposited.\n', '   * @param _priority The amount of the token that was deposited.\n', '   * @return Operation success.\n', '   */\n', '\n', '  function setQuotePriority(address _token, uint256 _priority)\n', '    external\n', '    returns(bool)\n', '  {\n', '    if (msg.sender != owner_) {\n', '      return error("msg.sender != owner, Exchange.setQuotePriority()");\n', '    }\n', '    quotePriority[_token] = _priority;\n', '    emit LogQuotePrioritySet(_token, _priority);\n', '    return true;\n', '  }\n', '\n', '  /*\n', '   Methods to catch events from external contracts, user wallets primarily\n', '   */\n', '\n', '  /**\n', '   * @dev Simply log the event to track wallet interaction off-chain.\n', '   * @param tokenAddress The address of the token that was deposited.\n', '   * @param amount The amount of the token that was deposited.\n', '   * @param tradingWalletBalance The updated balance of the wallet after deposit.\n', '   */\n', '  function walletDeposit(\n', '    address tokenAddress,\n', '    uint256 amount,\n', '    uint256 tradingWalletBalance\n', '  ) external\n', '  {\n', '    emit LogWalletDeposit(msg.sender, tokenAddress, amount, tradingWalletBalance);\n', '  }\n', '\n', '  /**\n', '   * @dev Simply log the event to track wallet interaction off-chain.\n', '   * @param tokenAddress The address of the token that was deposited.\n', '   * @param amount The amount of the token that was deposited.\n', '   * @param tradingWalletBalance The updated balance of the wallet after deposit.\n', '   */\n', '  function walletWithdrawal(\n', '    address tokenAddress,\n', '    uint256 amount,\n', '    uint256 tradingWalletBalance\n', '  ) external\n', '  {\n', '    emit LogWalletWithdrawal(msg.sender, tokenAddress, amount, tradingWalletBalance);\n', '  }\n', '\n', '  /**\n', '   * Private\n', '   */\n', '\n', '  /**\n', '   * Calculate the fee for the given trade. Calculated as the set % of the wei amount\n', '   * converted into EDO tokens using the manually set conversion ratio.\n', '   * @param makerOrder The maker order object.\n', '   * @param toTakerAmount The amount of tokens going to the taker.\n', '   * @param toMakerAmount The amount of tokens going to the maker.\n', '   * @return The total fee to be paid in EDO tokens.\n', '   */\n', '  function __calculateFee__(\n', '    Order makerOrder,\n', '    uint256 toTakerAmount,\n', '    uint256 toMakerAmount\n', '  ) private\n', '    view\n', '    returns(uint256)\n', '  {\n', '    // weiAmount * (fee %) * (EDO/Wei) / (decimals in edo/wei) / (decimals in percentage)\n', '    if (!__isSell__(makerOrder)) {\n', '      // buy -> the quote is the offered token by the maker\n', '      return mustSkipFee[makerOrder.wantToken_][makerOrder.offerToken_]\n', '        ? 0\n', '        : toTakerAmount.mul(feeEdoPerQuote[makerOrder.offerToken_]).div(10**feeEdoPerQuoteDecimals[makerOrder.offerToken_]);\n', '    } else {\n', '      // sell -> the quote is the wanted token by the maker\n', '      return mustSkipFee[makerOrder.offerToken_][makerOrder.wantToken_]\n', '        ? 0\n', '        : toMakerAmount.mul(feeEdoPerQuote[makerOrder.wantToken_]).div(10**feeEdoPerQuoteDecimals[makerOrder.wantToken_]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Verify the input to order execution is valid.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param amountsExpirationsAndSalts The amount of tokens and the block number at which this order expires and a random number to mitigate replay.\n', '   * [\n', '   *   makerOffer\n', '   *   makerWant\n', '   *   takerOffer\n', '   *   takerWant\n', '   *   makerExpiry\n', '   *   makerSalt\n', '   *   takerExpiry\n', '   *   takerSalt\n', '   * ]\n', '   * @return Success if all checks pass.\n', '   */\n', '  function __executeOrderInputIsValid__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts,\n', '    address makerTradingWallet,\n', '    address takerTradingWallet\n', '  ) private\n', '    returns(bool)\n', '  {\n', '    // msg.send needs to be the orderBookAccount\n', '    if (msg.sender != orderBookAccount_) {\n', '      return error("msg.sender != orderBookAccount, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Check expirations base on the block number\n', '    if (block.number > amountsExpirationsAndSalts[4]) {\n', '      return error("Maker order has expired, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (block.number > amountsExpirationsAndSalts[6]) {\n', '      return error("Taker order has expired, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Operating on existing tradingWallets\n', '    if (makerTradingWallet == address(0)) {\n', '      return error("Maker wallet does not exist, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (takerTradingWallet == address(0)) {\n', '      return error("Taker wallet does not exist, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    if (quotePriority[ownedExternalAddressesAndTokenAddresses[1]] == quotePriority[ownedExternalAddressesAndTokenAddresses[3]]) {\n', '      return error("Quote token is omitted! Is not offered by either the Taker or Maker, Exchange.__executeOrderInputIsValid__()");\n', '    }\n', '\n', '    // Check that none of the amounts is = to 0\n', '    if (\n', '        amountsExpirationsAndSalts[0] == 0 ||\n', '        amountsExpirationsAndSalts[1] == 0 ||\n', '        amountsExpirationsAndSalts[2] == 0 ||\n', '        amountsExpirationsAndSalts[3] == 0\n', '      )\n', '      return error("May not execute an order where token amount == 0, Exchange.__executeOrderInputIsValid__()");\n', '\n', '    // // Confirm order ether amount >= min amount\n', '    //  // Maker\n', '    //  uint256 minOrderEthAmount = minOrderEthAmount_; // Single storage read\n', '    //  if (_token_and_EOA_Addresses[1] == 0 && _amountsExpirationAndSalt[0] < minOrderEthAmount)\n', "    //    return error('Maker order does not meet the minOrderEthAmount_ of ether, Exchange.__executeOrderInputIsValid__()');\n", '\n', '    //  // Taker\n', '    //  if (_token_and_EOA_Addresses[3] == 0 && _amountsExpirationAndSalt[2] < minOrderEthAmount)\n', "    //    return error('Taker order does not meet the minOrderEthAmount_ of ether, Exchange.__executeOrderInputIsValid__()');\n", '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Execute the external transfer of tokens.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param toTakerAmount The amount of tokens to transfer to the taker.\n', '   * @param toMakerAmount The amount of tokens to transfer to the maker.\n', '   * @return Success if both wallets verify the order.\n', '   */\n', '  function __executeTokenTransfer__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256 toTakerAmount,\n', '    uint256 toMakerAmount,\n', '    uint256 fee,\n', '    WalletV2 makerTradingWallet,\n', '    WalletV2 takerTradingWallet\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Wallet mapping balances\n', '    address makerOfferTokenAddress = ownedExternalAddressesAndTokenAddresses[1];\n', '    address takerOfferTokenAddress = ownedExternalAddressesAndTokenAddresses[3];\n', '\n', '    // Taker to pay fee before trading\n', '    if(fee != 0) {\n', '      require(\n', '        takerTradingWallet.updateBalance(edoToken_, fee, true),\n', '        "Taker trading wallet cannot update balance with fee, Exchange.__executeTokenTransfer__()"\n', '      );\n', '\n', '      require(\n', '        Token(edoToken_).transferFrom(takerTradingWallet, eidooWallet_, fee),\n', '        "Cannot transfer fees from taker trading wallet to eidoo wallet, Exchange.__executeTokenTransfer__()"\n', '      );\n', '    }\n', '\n', '    // Updating makerTradingWallet balance by the toTaker\n', '    require(\n', '      makerTradingWallet.updateBalance(makerOfferTokenAddress, toTakerAmount, true),\n', '      "Maker trading wallet cannot update balance subtracting toTakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to subtract maker token from maker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating takerTradingWallet balance by the toTaker\n', '    require(\n', '      takerTradingWallet.updateBalance(makerOfferTokenAddress, toTakerAmount, false),\n', '      "Taker trading wallet cannot update balance adding toTakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to add maker token to taker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating takerTradingWallet balance by the toMaker amount\n', '    require(\n', '      takerTradingWallet.updateBalance(takerOfferTokenAddress, toMakerAmount, true),\n', '      "Taker trading wallet cannot update balance subtracting toMakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to subtract taker token from taker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Updating makerTradingWallet balance by the toMaker amount\n', '    require(\n', '      makerTradingWallet.updateBalance(takerOfferTokenAddress, toMakerAmount, false),\n', '      "Maker trading wallet cannot update balance adding toMakerAmount, Exchange.__executeTokenTransfer__()"\n', '    ); // return error("Unable to add taker token to maker wallet, Exchange.__executeTokenTransfer__()");\n', '\n', '    // Ether to the taker and tokens to the maker\n', '    if (makerOfferTokenAddress == address(0)) {\n', '      address(takerTradingWallet).transfer(toTakerAmount);\n', '    } else {\n', '      require(\n', '        safeTransferFrom(makerOfferTokenAddress, makerTradingWallet, takerTradingWallet, toTakerAmount),\n', '        "Token transfership from makerTradingWallet to takerTradingWallet failed, Exchange.__executeTokenTransfer__()"\n', '      );\n', '      assert(\n', '        __tokenAndWalletBalancesMatch__(\n', '          makerTradingWallet,\n', '          takerTradingWallet,\n', '          makerOfferTokenAddress\n', '        )\n', '      );\n', '    }\n', '\n', '    if (takerOfferTokenAddress == address(0)) {\n', '      address(makerTradingWallet).transfer(toMakerAmount);\n', '    } else {\n', '      require(\n', '        safeTransferFrom(takerOfferTokenAddress, takerTradingWallet, makerTradingWallet, toMakerAmount),\n', '        "Token transfership from takerTradingWallet to makerTradingWallet failed, Exchange.__executeTokenTransfer__()"\n', '      );\n', '      assert(\n', '        __tokenAndWalletBalancesMatch__(\n', '          makerTradingWallet,\n', '          takerTradingWallet,\n', '          takerOfferTokenAddress\n', '        )\n', '      );\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates Keccak-256 hash of order with specified parameters.\n', '   * @param ownedExternalAddressesAndTokenAddresses The orders maker EOA and current exchange address.\n', '   * @param amountsExpirationsAndSalts The orders offer and want amounts and expirations with salts.\n', '   * @return Keccak-256 hash of the passed order.\n', '   */\n', '\n', '  function generateOrderHashes(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256[8] amountsExpirationsAndSalts\n', '  ) public\n', '    view\n', '    returns (bytes32[2])\n', '  {\n', '    bytes32 makerOrderHash = keccak256(\n', '      address(this),\n', '      ownedExternalAddressesAndTokenAddresses[0], // _makerEOA\n', '      ownedExternalAddressesAndTokenAddresses[1], // offerToken\n', '      amountsExpirationsAndSalts[0],  // offerTokenAmount\n', '      ownedExternalAddressesAndTokenAddresses[3], // wantToken\n', '      amountsExpirationsAndSalts[1],  // wantTokenAmount\n', '      amountsExpirationsAndSalts[4], // expiry\n', '      amountsExpirationsAndSalts[5] // salt\n', '    );\n', '\n', '    bytes32 takerOrderHash = keccak256(\n', '      address(this),\n', '      ownedExternalAddressesAndTokenAddresses[2], // _makerEOA\n', '      ownedExternalAddressesAndTokenAddresses[3], // offerToken\n', '      amountsExpirationsAndSalts[2],  // offerTokenAmount\n', '      ownedExternalAddressesAndTokenAddresses[1], // wantToken\n', '      amountsExpirationsAndSalts[3],  // wantTokenAmount\n', '      amountsExpirationsAndSalts[6], // expiry\n', '      amountsExpirationsAndSalts[7] // salt\n', '    );\n', '\n', '    return [makerOrderHash, takerOrderHash];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a bool representing a SELL or BUY order based on quotePriority.\n', '   * @param _order The maker order data structure.\n', '   * @return The bool indicating if the order is a SELL or BUY.\n', '   */\n', '  function __isSell__(Order _order) internal view returns (bool) {\n', '    return quotePriority[_order.offerToken_] < quotePriority[_order.wantToken_];\n', '  }\n', '\n', '  /**\n', '   * @dev Compute the tradeable amounts of the two verified orders.\n', '   * Token amount is the __min__ remaining between want and offer of the two orders that isn"t ether.\n', '   * Ether amount is then: etherAmount = tokenAmount * priceRatio, as ratio = eth / token.\n', '   * @param makerOrder The maker order data structure.\n', '   * @param takerOrder The taker order data structure.\n', '   * @return The amount moving from makerOfferRemaining to takerWantRemaining and vice versa.\n', '   */\n', '  function __getTradeAmounts__(\n', '    Order makerOrder,\n', '    Order takerOrder\n', '  ) internal\n', '    view\n', '    returns (uint256[2])\n', '  {\n', '    bool isMakerBuy = __isSell__(takerOrder);  // maker buy = taker sell\n', '    uint256 priceRatio;\n', '    uint256 makerAmountLeftToReceive;\n', '    uint256 takerAmountLeftToReceive;\n', '\n', '    uint toTakerAmount;\n', '    uint toMakerAmount;\n', '\n', '    if (makerOrder.offerTokenTotal_ >= makerOrder.wantTokenTotal_) {\n', '      priceRatio = makerOrder.offerTokenTotal_.mul(2**128).div(makerOrder.wantTokenTotal_);\n', '      if (isMakerBuy) {\n', '        // MP > 1\n', '        makerAmountLeftToReceive = makerOrder.wantTokenTotal_.sub(makerOrder.wantTokenReceived_);\n', '        toMakerAmount = __min__(takerOrder.offerTokenRemaining_, makerAmountLeftToReceive);\n', '        // add 2**128-1 in order to obtain a round up\n', '        toTakerAmount = toMakerAmount.mul(priceRatio).add(2**128-1).div(2**128);\n', '      } else {\n', '        // MP < 1\n', '        takerAmountLeftToReceive = takerOrder.wantTokenTotal_.sub(takerOrder.wantTokenReceived_);\n', '        toTakerAmount = __min__(makerOrder.offerTokenRemaining_, takerAmountLeftToReceive);\n', '        toMakerAmount = toTakerAmount.mul(2**128).div(priceRatio);\n', '      }\n', '    } else {\n', '      priceRatio = makerOrder.wantTokenTotal_.mul(2**128).div(makerOrder.offerTokenTotal_);\n', '      if (isMakerBuy) {\n', '        // MP < 1\n', '        makerAmountLeftToReceive = makerOrder.wantTokenTotal_.sub(makerOrder.wantTokenReceived_);\n', '        toMakerAmount = __min__(takerOrder.offerTokenRemaining_, makerAmountLeftToReceive);\n', '        toTakerAmount = toMakerAmount.mul(2**128).div(priceRatio);\n', '      } else {\n', '        // MP > 1\n', '        takerAmountLeftToReceive = takerOrder.wantTokenTotal_.sub(takerOrder.wantTokenReceived_);\n', '        toTakerAmount = __min__(makerOrder.offerTokenRemaining_, takerAmountLeftToReceive);\n', '        // add 2**128-1 in order to obtain a round up\n', '        toMakerAmount = toTakerAmount.mul(priceRatio).add(2**128-1).div(2**128);\n', '      }\n', '    }\n', '    return [toTakerAmount, toMakerAmount];\n', '  }\n', '\n', '  /**\n', '   * @dev Return the maximum of two uints\n', '   * @param a Uint 1\n', '   * @param b Uint 2\n', '   * @return The grater value or a if equal\n', '   */\n', '  function __max__(uint256 a, uint256 b)\n', '    private\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return a < b\n', '      ? b\n', '      : a;\n', '  }\n', '\n', '  /**\n', '   * @dev Return the minimum of two uints\n', '   * @param a Uint 1\n', '   * @param b Uint 2\n', '   * @return The smallest value or b if equal\n', '   */\n', '  function __min__(uint256 a, uint256 b)\n', '    private\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return a < b\n', '      ? a\n', '      : b;\n', '  }\n', '\n', '  /**\n', '   * @dev Confirm that the orders do match and are valid.\n', '   * @param makerOrder The maker order data structure.\n', '   * @param takerOrder The taker order data structure.\n', '   * @return Bool if the orders passes all checks.\n', '   */\n', '  function __ordersMatch_and_AreVaild__(\n', '    Order makerOrder,\n', '    Order takerOrder\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Confirm tokens match\n', '    // NOTE potentially omit as matching handled upstream?\n', '    if (makerOrder.wantToken_ != takerOrder.offerToken_) {\n', '      return error("Maker wanted token does not match taker offer token, Exchange.__ordersMatch_and_AreVaild__()");\n', '    }\n', '\n', '    if (makerOrder.offerToken_ != takerOrder.wantToken_) {\n', '      return error("Maker offer token does not match taker wanted token, Exchange.__ordersMatch_and_AreVaild__()");\n', '    }\n', '\n', '    // Price Ratios, to x decimal places hence * decimals, dependent on the size of the denominator.\n', '    // Ratios are relative to eth, amount of ether for a single token, ie. ETH / GNO == 0.2 Ether per 1 Gnosis\n', '\n', '    uint256 orderPrice;   // The price the maker is willing to accept\n', '    uint256 offeredPrice; // The offer the taker has given\n', '\n', '    // Ratio = larger amount / smaller amount\n', '    if (makerOrder.offerTokenTotal_ >= makerOrder.wantTokenTotal_) {\n', '      orderPrice = makerOrder.offerTokenTotal_.mul(2**128).div(makerOrder.wantTokenTotal_);\n', '      offeredPrice = takerOrder.wantTokenTotal_.mul(2**128).div(takerOrder.offerTokenTotal_);\n', '\n', '      // ie. Maker is offering 10 ETH for 100 GNO but taker is offering 100 GNO for 20 ETH, no match!\n', '      // The taker wants more ether than the maker is offering.\n', '      if (orderPrice < offeredPrice) {\n', '        return error("Taker price is greater than maker price, Exchange.__ordersMatch_and_AreVaild__()");\n', '      }\n', '    } else {\n', '      orderPrice = makerOrder.wantTokenTotal_.mul(2**128).div(makerOrder.offerTokenTotal_);\n', '      offeredPrice = takerOrder.offerTokenTotal_.mul(2**128).div(takerOrder.wantTokenTotal_);\n', '\n', '      // ie. Maker is offering 100 GNO for 10 ETH but taker is offering 5 ETH for 100 GNO, no match!\n', '      // The taker is not offering enough ether for the maker\n', '      if (orderPrice > offeredPrice) {\n', '        return error("Taker price is less than maker price, Exchange.__ordersMatch_and_AreVaild__()");\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Ask each wallet to verify this order.\n', '   * @param ownedExternalAddressesAndTokenAddresses The maker and taker external owned accounts addresses and offered tokens contracts.\n', '   * [\n', '   *   makerEOA\n', '   *   makerOfferToken\n', '   *   takerEOA\n', '   *   takerOfferToken\n', '   * ]\n', '   * @param toMakerAmount The amount of tokens to be sent to the maker.\n', '   * @param toTakerAmount The amount of tokens to be sent to the taker.\n', '   * @param makerTradingWallet The maker trading wallet contract.\n', '   * @param takerTradingWallet The taker trading wallet contract.\n', '   * @param fee The fee to be paid for this trade, paid in full by taker.\n', '   * @return Success if both wallets verify the order.\n', '   */\n', '  function __ordersVerifiedByWallets__(\n', '    address[4] ownedExternalAddressesAndTokenAddresses,\n', '    uint256 toMakerAmount,\n', '    uint256 toTakerAmount,\n', '    WalletV2 makerTradingWallet,\n', '    WalletV2 takerTradingWallet,\n', '    uint256 fee\n', '  ) private\n', '    returns (bool)\n', '  {\n', '    // Have the transaction verified by both maker and taker wallets\n', '    // confirm sufficient balance to transfer, offerToken and offerTokenAmount\n', '    if(!makerTradingWallet.verifyOrder(ownedExternalAddressesAndTokenAddresses[1], toTakerAmount, 0, 0)) {\n', '      return error("Maker wallet could not verify the order, Exchange.____ordersVerifiedByWallets____()");\n', '    }\n', '\n', '    if(!takerTradingWallet.verifyOrder(ownedExternalAddressesAndTokenAddresses[3], toMakerAmount, fee, edoToken_)) {\n', '      return error("Taker wallet could not verify the order, Exchange.____ordersVerifiedByWallets____()");\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev On chain verification of an ECDSA ethereum signature.\n', '   * @param signer The EOA address of the account that supposedly signed the message.\n', '   * @param orderHash The on-chain generated hash for the order.\n', '   * @param v ECDSA signature parameter v.\n', '   * @param r ECDSA signature parameter r.\n', '   * @param s ECDSA signature parameter s.\n', '   * @return Bool if the signature is valid or not.\n', '   */\n', '  function __signatureIsValid__(\n', '    address signer,\n', '    bytes32 orderHash,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) private\n', '    pure\n', '    returns (bool)\n', '  {\n', '    address recoveredAddr = ecrecover(\n', '      keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)),\n', '      v,\n', '      r,\n', '      s\n', '    );\n', '\n', '    return recoveredAddr == signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Confirm wallet local balances and token balances match.\n', '   * @param makerTradingWallet  Maker wallet address.\n', '   * @param takerTradingWallet  Taker wallet address.\n', '   * @param token  Token address to confirm balances match.\n', '   * @return If the balances do match.\n', '   */\n', '  function __tokenAndWalletBalancesMatch__(\n', '    address makerTradingWallet,\n', '    address takerTradingWallet,\n', '    address token\n', '  ) private\n', '    view\n', '    returns(bool)\n', '  {\n', '    if (Token(token).balanceOf(makerTradingWallet) != WalletV2(makerTradingWallet).balanceOf(token)) {\n', '      return false;\n', '    }\n', '\n', '    if (Token(token).balanceOf(takerTradingWallet) != WalletV2(takerTradingWallet).balanceOf(token)) {\n', '      return false;\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Wrapping the ERC20 transfer function to avoid missing returns.\n', '   * @param _token The address of bad formed ERC20 token.\n', '   * @param _from Transfer sender.\n', '   * @param _to Transfer receiver.\n', '   * @param _value Amount to be transfered.\n', '   * @return Success of the safeTransfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool result)\n', '  {\n', '    BadERC20(_token).transferFrom(_from, _to, _value);\n', '\n', '    assembly {\n', '      switch returndatasize()\n', '      case 0 {                      // This is our BadToken\n', '        result := not(0)            // result is true\n', '      }\n', '      case 32 {                     // This is our GoodToken\n', '        returndatacopy(0, 0, 32)\n', '        result := mload(0)          // result == returndata of external call\n', '      }\n', '      default {                     // This is not an ERC20 token\n', '        revert(0, 0)\n', '      }\n', '    }\n', '  }\n', '}']
