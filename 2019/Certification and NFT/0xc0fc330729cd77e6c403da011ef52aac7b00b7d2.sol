['pragma solidity 0.4.25;\n', '\n', 'library SafeMath256 {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        if (b == 0) return 1;\n', '\n', '        uint256 c = a ** b;\n', '        assert(c / (a ** (b - 1)) == a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function _validateAddress(address _addr) internal pure {\n', '        require(_addr != address(0), "invalid address");\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "not a contract owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _validateAddress(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused, "contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused, "contract is not paused");\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    mapping(address => bool) controllers;\n', '\n', '    modifier onlyController {\n', '        require(_isController(msg.sender), "no controller rights");\n', '        _;\n', '    }\n', '\n', '    function _isController(address _controller) internal view returns (bool) {\n', '        return controllers[_controller];\n', '    }\n', '\n', '    function _setControllers(address[] _controllers) internal {\n', '        for (uint256 i = 0; i < _controllers.length; i++) {\n', '            _validateAddress(_controllers[i]);\n', '            controllers[_controllers[i]] = true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Upgradable is Controllable {\n', '    address[] internalDependencies;\n', '    address[] externalDependencies;\n', '\n', '    function getInternalDependencies() public view returns(address[]) {\n', '        return internalDependencies;\n', '    }\n', '\n', '    function getExternalDependencies() public view returns(address[]) {\n', '        return externalDependencies;\n', '    }\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        for (uint256 i = 0; i < _newDependencies.length; i++) {\n', '            _validateAddress(_newDependencies[i]);\n', '        }\n', '        internalDependencies = _newDependencies;\n', '    }\n', '\n', '    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        externalDependencies = _newDependencies;\n', '        _setControllers(_newDependencies);\n', '    }\n', '}\n', '\n', 'contract Battle {\n', '    function start(uint256, uint256, uint8[2], uint8[2], uint256, bool) external returns (uint256[2], uint32, uint32, uint32, uint32, uint256);\n', '}\n', '\n', 'contract Treasury {\n', '    function takeGold(uint256) external;\n', '}\n', '\n', 'contract Random {\n', '    function random(uint256) external view returns (uint256);\n', '    function randomOfBlock(uint256, uint256) external view returns (uint256);\n', '}\n', '\n', 'contract Getter {\n', '    function getDragonStrength(uint256) external view returns (uint32);\n', '    function isDragonOwner(address, uint256) external view returns (bool);\n', '    function isDragonInGladiatorBattle(uint256) public view returns (bool);\n', '    function isDragonOnSale(uint256) public view returns (bool);\n', '    function isBreedingOnSale(uint256) public view returns (bool);\n', '}\n', '\n', 'contract Gold {\n', '    function remoteTransfer(address _to, uint256 _value) external;\n', '}\n', '\n', 'contract GladiatorBattleStorage {\n', '    function challengesAmount() external view returns (uint256);\n', '    function battleOccurred(uint256) external view returns (bool);\n', '    function challengeCancelled(uint256) external view returns (bool);\n', '    function getChallengeApplicants(uint256) external view returns (uint256[]);\n', '    function challengeApplicantsAmount(uint256) external view returns (uint256);\n', '    function userApplicationIndex(address, uint256) external view returns (uint256, bool, uint256);\n', '    function challenges(uint256) external view returns (bool, uint256, uint256);\n', '    function challengeCompensation(uint256) external view returns (uint256);\n', '    function getDragonApplication(uint256) external view returns (uint256, uint8[2], address);\n', '    function battleBlockNumber(uint256) external view returns (uint256);\n', '    function creator(uint256) external view returns (address, uint256);\n', '    function opponent(uint256) external view returns (address, uint256);\n', '    function winner(uint256) external view returns (address, uint256);\n', '    function setCompensation(uint256, uint256) external;\n', '    function create(bool, uint256, uint16) external returns (uint256);\n', '    function addUserChallenge(address, uint256) external;\n', '    function addUserApplication(address, uint256, uint256) external;\n', '    function removeUserApplication(address, uint256) external;\n', '    function addChallengeApplicant(uint256, uint256) external;\n', '    function setCreator(uint256, address, uint256) external;\n', '    function setOpponent(uint256, address, uint256) external;\n', '    function setWinner(uint256, address, uint256) external;\n', '    function setDragonApplication(uint256, uint256, uint8[2], address) external;\n', '    function removeDragonApplication(uint256, uint256) external;\n', '    function setBattleBlockNumber(uint256, uint256) external;\n', '    function setAutoSelectBlock(uint256, uint256) external;\n', '    function autoSelectBlock(uint256) external view returns (uint256);\n', '    function challengeApplicants(uint256, uint256) external view returns (uint256);\n', '    function payOut(address, bool, uint256) external;\n', '    function setBattleOccurred(uint256) external;\n', '    function setChallengeCancelled(uint256) external;\n', '    function setChallengeBattleId(uint256, uint256) external;\n', '    function getExtensionTimePrice(uint256) external view returns (uint256);\n', '    function setExtensionTimePrice(uint256, uint256) external;\n', '}\n', '\n', 'contract GladiatorBattleSpectatorsStorage {\n', '    function challengeBetsValue(uint256, bool) external view returns (uint256);\n', '    function challengeBalance(uint256) external view returns (uint256);\n', '    function payOut(address, bool, uint256) external;\n', '    function setChallengeBalance(uint256, uint256) external;\n', '}\n', '\n', '\n', 'contract GladiatorBattle is Upgradable {\n', '    using SafeMath256 for uint256;\n', '\n', '    Battle battle;\n', '    Random random;\n', '    Gold goldTokens;\n', '    Getter getter;\n', '    Treasury treasury;\n', '    GladiatorBattleStorage _storage_;\n', '    GladiatorBattleSpectatorsStorage spectatorsStorage;\n', '\n', '    uint8 constant MAX_TACTICS_PERCENTAGE = 80;\n', '    uint8 constant MIN_TACTICS_PERCENTAGE = 20;\n', '    uint8 constant MAX_DRAGON_STRENGTH_PERCENTAGE = 120;\n', '    uint8 constant PERCENTAGE = 100;\n', '    uint256 AUTO_SELECT_TIME = 6000; // in blocks\n', '    uint256 INTERVAL_FOR_NEW_BLOCK = 1000; // in blocks\n', '\n', '    function() external payable {}\n', '\n', '    function _safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return b > a ? 0 : a.sub(b);\n', '    }\n', '\n', '    function _payForBet(\n', '        uint256 _value,\n', '        bool _isGold,\n', '        uint256 _bet\n', '    ) internal {\n', '        if (_isGold) {\n', '            require(_value == 0, "specify isGold as false to send eth");\n', '            goldTokens.remoteTransfer(address(_storage_), _bet);\n', '        } else {\n', '            require(_value == _bet, "wrong eth amount");\n', '            address(_storage_).transfer(_value);\n', '        }\n', '    }\n', '\n', '    function _validateChallengeId(uint256 _challengeId) internal view {\n', '        require(\n', '            _challengeId > 0 &&\n', '            _challengeId < _storage_.challengesAmount(),\n', '            "wrong challenge id"\n', '        );\n', '    }\n', '\n', '    function _validateTactics(uint8[2] _tactics) internal pure {\n', '        require(\n', '            _tactics[0] >= MIN_TACTICS_PERCENTAGE &&\n', '            _tactics[0] <= MAX_TACTICS_PERCENTAGE &&\n', '            _tactics[1] >= MIN_TACTICS_PERCENTAGE &&\n', '            _tactics[1] <= MAX_TACTICS_PERCENTAGE,\n', '            "tactics value must be between 20 and 80"\n', '        );\n', '    }\n', '\n', '    function _checkDragonAvailability(address _user, uint256 _dragonId) internal view {\n', '        require(getter.isDragonOwner(_user, _dragonId), "not a dragon owner");\n', '        require(!getter.isDragonOnSale(_dragonId), "dragon is on sale");\n', '        require(!getter.isBreedingOnSale(_dragonId), "dragon is on breeding sale");\n', '        require(!isDragonChallenging(_dragonId), "this dragon has already applied");\n', '    }\n', '\n', '    function _checkTheBattleHasNotOccurred(uint256 _challengeId) internal view {\n', '        require(!_storage_.battleOccurred(_challengeId), "the battle has already occurred");\n', '    }\n', '\n', '    function _checkTheChallengeIsNotCancelled(uint256 _id) internal view {\n', '        require(!_storage_.challengeCancelled(_id), "the challenge is cancelled");\n', '    }\n', '\n', '    function _checkTheOpponentIsNotSelected(uint256 _id) internal view {\n', '        require(!_isOpponentSelected(_id), "opponent already selected");\n', '    }\n', '\n', '    function _checkThatTimeHasCome(uint256 _blockNumber) internal view {\n', '        require(_blockNumber <= block.number, "time has not yet come");\n', '    }\n', '\n', '    function _checkChallengeCreator(uint256 _id, address _user) internal view {\n', '        (address _creator, ) = _getCreator(_id);\n', '        require(_creator == _user, "not a challenge creator");\n', '    }\n', '\n', '    function _checkForApplicants(uint256 _id) internal view {\n', '        require(_getChallengeApplicantsAmount(_id) > 0, "no applicants");\n', '    }\n', '\n', '    function _compareApplicantsArrays(uint256 _challengeId, bytes32 _hash) internal view {\n', '        uint256[] memory _applicants = _storage_.getChallengeApplicants(_challengeId);\n', '        require(keccak256(abi.encode(_applicants)) == _hash, "wrong applicants array");\n', '    }\n', '\n', '    function _compareDragonStrength(uint256 _challengeId, uint256 _applicantId) internal view {\n', '        ( , uint256 _dragonId) = _getCreator(_challengeId);\n', '        uint256 _strength = getter.getDragonStrength(_dragonId);\n', '        uint256 _applicantStrength = getter.getDragonStrength(_applicantId);\n', '        uint256 _maxStrength = _strength.mul(MAX_DRAGON_STRENGTH_PERCENTAGE).div(PERCENTAGE); // +20%\n', '        require(_applicantStrength <= _maxStrength, "too strong dragon");\n', '    }\n', '\n', '    function _setChallengeCompensation(\n', '        uint256 _challengeId,\n', '        uint256 _bet,\n', '        uint256 _applicantsAmount\n', '    ) internal {\n', '        // 30% of a bet\n', '        _storage_.setCompensation(_challengeId, _bet.mul(3).div(10).div(_applicantsAmount));\n', '    }\n', '\n', '    function _isOpponentSelected(uint256 _challengeId) internal view returns (bool) {\n', '        ( , uint256 _dragonId) = _getOpponent(_challengeId);\n', '        return _dragonId != 0;\n', '    }\n', '\n', '    function _getChallengeApplicantsAmount(\n', '        uint256 _challengeId\n', '    ) internal view returns (uint256) {\n', '        return _storage_.challengeApplicantsAmount(_challengeId);\n', '    }\n', '\n', '    function _getUserApplicationIndex(\n', '        address _user,\n', '        uint256 _challengeId\n', '    ) internal view returns (uint256, bool, uint256) {\n', '        return _storage_.userApplicationIndex(_user, _challengeId);\n', '    }\n', '\n', '    function _getChallenge(\n', '        uint256 _id\n', '    ) internal view returns (bool, uint256, uint256) {\n', '        return _storage_.challenges(_id);\n', '    }\n', '\n', '    function _getCompensation(\n', '        uint256 _id\n', '    ) internal view returns (uint256) {\n', '        return _storage_.challengeCompensation(_id);\n', '    }\n', '\n', '    function _getDragonApplication(\n', '        uint256 _id\n', '    ) internal view returns (uint256, uint8[2], address) {\n', '        return _storage_.getDragonApplication(_id);\n', '    }\n', '\n', '    function _getBattleBlockNumber(\n', '        uint256 _id\n', '    ) internal view returns (uint256) {\n', '        return _storage_.battleBlockNumber(_id);\n', '    }\n', '\n', '    function _getCreator(\n', '        uint256 _id\n', '    ) internal view returns (address, uint256) {\n', '        return _storage_.creator(_id);\n', '    }\n', '\n', '    function _getOpponent(\n', '        uint256 _id\n', '    ) internal view returns (address, uint256) {\n', '        return _storage_.opponent(_id);\n', '    }\n', '\n', '    function _getSpectatorsBetsValue(\n', '        uint256 _challengeId,\n', '        bool _onCreator\n', '    ) internal view returns (uint256) {\n', '        return spectatorsStorage.challengeBetsValue(_challengeId, _onCreator);\n', '    }\n', '\n', '    function isDragonChallenging(uint256 _dragonId) public view returns (bool) {\n', '        (uint256 _challengeId, , ) = _getDragonApplication(_dragonId);\n', '        if (_challengeId != 0) {\n', '            if (_storage_.challengeCancelled(_challengeId)) {\n', '                return false;\n', '            }\n', '            ( , uint256 _owner) = _getCreator(_challengeId);\n', '            ( , uint256 _opponent) = _getOpponent(_challengeId);\n', '            bool _isParticipant = (_dragonId == _owner) || (_dragonId == _opponent);\n', '\n', '            if (_isParticipant) {\n', '                return !_storage_.battleOccurred(_challengeId);\n', '            }\n', '            return !_isOpponentSelected(_challengeId);\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function create(\n', '        address _user,\n', '        uint256 _dragonId,\n', '        uint8[2] _tactics,\n', '        bool _isGold,\n', '        uint256 _bet,\n', '        uint16 _counter,\n', '        uint256 _value // in eth\n', '    ) external onlyController returns (uint256 challengeId) {\n', '        _validateTactics(_tactics);\n', '        _checkDragonAvailability(_user, _dragonId);\n', '        require(_counter >= 5, "too few blocks");\n', '\n', '        _payForBet(_value, _isGold, _bet);\n', '\n', '        challengeId = _storage_.create(_isGold, _bet, _counter);\n', '        _storage_.addUserChallenge(_user, challengeId);\n', '        _storage_.setCreator(challengeId, _user, _dragonId);\n', '        _storage_.setDragonApplication(_dragonId, challengeId, _tactics, _user);\n', '    }\n', '\n', '    function apply(\n', '        uint256 _challengeId,\n', '        address _user,\n', '        uint256 _dragonId,\n', '        uint8[2] _tactics,\n', '        uint256 _value // in eth\n', '    ) external onlyController {\n', '        _validateChallengeId(_challengeId);\n', '        _validateTactics(_tactics);\n', '        _checkTheBattleHasNotOccurred(_challengeId);\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '        _checkTheOpponentIsNotSelected(_challengeId);\n', '        _checkDragonAvailability(_user, _dragonId);\n', '        _compareDragonStrength(_challengeId, _dragonId);\n', '        ( , bool _exist, ) = _getUserApplicationIndex(_user, _challengeId);\n', '        require(!_exist, "you have already applied");\n', '\n', '        (bool _isGold, uint256 _bet, ) = _getChallenge(_challengeId);\n', '\n', '        _payForBet(_value, _isGold, _bet);\n', '\n', '        _storage_.addUserApplication(_user, _challengeId, _dragonId);\n', '        _storage_.setDragonApplication(_dragonId, _challengeId, _tactics, _user);\n', '        _storage_.addChallengeApplicant(_challengeId, _dragonId);\n', '\n', "        // if it's the first applicant then set auto select block\n", '        if (_getChallengeApplicantsAmount(_challengeId) == 1) {\n', '            _storage_.setAutoSelectBlock(_challengeId, block.number.add(AUTO_SELECT_TIME));\n', '        }\n', '    }\n', '\n', '    function chooseOpponent(\n', '        address _user,\n', '        uint256 _challengeId,\n', '        uint256 _applicantId,\n', '        bytes32 _applicantsHash\n', '    ) external onlyController {\n', '        _validateChallengeId(_challengeId);\n', '        _checkChallengeCreator(_challengeId, _user);\n', '        _compareApplicantsArrays(_challengeId, _applicantsHash);\n', '        _selectOpponent(_challengeId, _applicantId);\n', '    }\n', '\n', '    function autoSelectOpponent(\n', '        uint256 _challengeId,\n', '        bytes32 _applicantsHash\n', '    ) external onlyController returns (uint256 applicantId) {\n', '        _validateChallengeId(_challengeId);\n', '        _compareApplicantsArrays(_challengeId, _applicantsHash);\n', '        uint256 _autoSelectBlock = _storage_.autoSelectBlock(_challengeId);\n', '        require(_autoSelectBlock != 0, "no auto select");\n', '        _checkThatTimeHasCome(_autoSelectBlock);\n', '\n', '        _checkForApplicants(_challengeId);\n', '\n', '        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\n', '        uint256 _index = random.random(2**256 - 1) % _applicantsAmount;\n', '        applicantId = _storage_.challengeApplicants(_challengeId, _index);\n', '\n', '        _selectOpponent(_challengeId, applicantId);\n', '    }\n', '\n', '    function _selectOpponent(uint256 _challengeId, uint256 _dragonId) internal {\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '        _checkTheOpponentIsNotSelected(_challengeId);\n', '\n', '        (\n', '            uint256 _dragonChallengeId, ,\n', '            address _opponentUser\n', '        ) = _getDragonApplication(_dragonId);\n', '        ( , uint256 _creatorDragonId) = _getCreator(_challengeId);\n', '\n', '        require(_dragonChallengeId == _challengeId, "wrong opponent");\n', '        require(_creatorDragonId != _dragonId, "the same dragon");\n', '\n', '        _storage_.setOpponent(_challengeId, _opponentUser, _dragonId);\n', '\n', '        ( , uint256 _bet, uint256 _counter) = _getChallenge(_challengeId);\n', '        _storage_.setBattleBlockNumber(_challengeId, block.number.add(_counter));\n', '\n', '        _storage_.addUserChallenge(_opponentUser, _challengeId);\n', '        _storage_.removeUserApplication(_opponentUser, _challengeId);\n', '\n', '        // if there are more applicants than one just selected then set challenge compensation\n', '        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\n', '        if (_applicantsAmount > 1) {\n', '            uint256 _otherApplicants = _applicantsAmount.sub(1);\n', '            _setChallengeCompensation(_challengeId, _bet, _otherApplicants);\n', '        }\n', '    }\n', '\n', '    function _checkBattleBlockNumber(uint256 _blockNumber) internal view {\n', '        require(_blockNumber != 0, "opponent is not selected");\n', '        _checkThatTimeHasCome(_blockNumber);\n', '    }\n', '\n', '    function _checkBattlePossibilityAndGenerateRandom(uint256 _challengeId) internal view returns (uint256) {\n', '        uint256 _blockNumber = _getBattleBlockNumber(_challengeId);\n', '        _checkBattleBlockNumber(_blockNumber);\n', '        require(_blockNumber >= _safeSub(block.number, 256), "time has passed");\n', '        _checkTheBattleHasNotOccurred(_challengeId);\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '\n', '        return random.randomOfBlock(2**256 - 1, _blockNumber);\n', '    }\n', '\n', '    function _payReward(uint256 _challengeId) internal returns (uint256 reward, bool isGold) {\n', '        uint8 _factor = _getCompensation(_challengeId) > 0 ? 17 : 20;\n', '        uint256 _bet;\n', '        (isGold, _bet, ) = _getChallenge(_challengeId);\n', '        ( , uint256 _creatorId) = _getCreator(_challengeId);\n', '        (address _winner, uint256 _winnerId) = _storage_.winner(_challengeId);\n', '\n', '        reward = _bet.mul(_factor).div(10);\n', '        _storage_.payOut(\n', '            _winner,\n', '            isGold,\n', '            reward\n', '        ); // 30% of bet to applicants\n', '\n', '        bool _didCreatorWin = _creatorId == _winnerId;\n', '        uint256 _winnerBetsValue = _getSpectatorsBetsValue(_challengeId, _didCreatorWin);\n', '        uint256 _opponentBetsValue = _getSpectatorsBetsValue(_challengeId, !_didCreatorWin);\n', '        if (_opponentBetsValue > 0 && _winnerBetsValue > 0) {\n', '            uint256 _rewardFromSpectatorsBets = _opponentBetsValue.mul(15).div(100); // 15%\n', '\n', '            uint256 _challengeBalance = spectatorsStorage.challengeBalance(_challengeId);\n', '            require(_challengeBalance >= _rewardFromSpectatorsBets, "not enough coins, something went wrong");\n', '\n', '            spectatorsStorage.payOut(_winner, isGold, _rewardFromSpectatorsBets);\n', '\n', '            _challengeBalance = _challengeBalance.sub(_rewardFromSpectatorsBets);\n', '            spectatorsStorage.setChallengeBalance(_challengeId, _challengeBalance);\n', '\n', '            reward = reward.add(_rewardFromSpectatorsBets);\n', '        }\n', '    }\n', '\n', '    function _setWinner(uint256 _challengeId, uint256 _dragonId) internal {\n', '        ( , , address _user) = _getDragonApplication(_dragonId);\n', '        _storage_.setWinner(_challengeId, _user, _dragonId);\n', '    }\n', '\n', '    function start(\n', '        uint256 _challengeId\n', '    ) external onlyController returns (\n', '        uint256 seed,\n', '        uint256 battleId,\n', '        uint256 reward,\n', '        bool isGold\n', '    ) {\n', '        _validateChallengeId(_challengeId);\n', '        seed = _checkBattlePossibilityAndGenerateRandom(_challengeId);\n', '\n', '        ( , uint256 _firstDragonId) = _getCreator(_challengeId);\n', '        ( , uint256 _secondDragonId) = _getOpponent(_challengeId);\n', '\n', '        ( , uint8[2] memory _firstTactics, ) = _getDragonApplication(_firstDragonId);\n', '        ( , uint8[2] memory _secondTactics, ) = _getDragonApplication(_secondDragonId);\n', '\n', '        uint256[2] memory winnerLooserIds;\n', '        (\n', '            winnerLooserIds, , , , , battleId\n', '        ) = battle.start(\n', '            _firstDragonId,\n', '            _secondDragonId,\n', '            _firstTactics,\n', '            _secondTactics,\n', '            seed,\n', '            true\n', '        );\n', '\n', '        _setWinner(_challengeId, winnerLooserIds[0]);\n', '\n', '        _storage_.setBattleOccurred(_challengeId);\n', '        _storage_.setChallengeBattleId(_challengeId, battleId);\n', '\n', '        (reward, isGold) = _payReward(_challengeId);\n', '    }\n', '\n', '    function cancel(\n', '        address _user,\n', '        uint256 _challengeId,\n', '        bytes32 _applicantsHash\n', '    ) external onlyController {\n', '        _validateChallengeId(_challengeId);\n', '        _checkChallengeCreator(_challengeId, _user);\n', '        _checkTheOpponentIsNotSelected(_challengeId);\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '        _compareApplicantsArrays(_challengeId, _applicantsHash);\n', '\n', '        (bool _isGold, uint256 _value /* bet */, ) = _getChallenge(_challengeId);\n', '        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\n', '        // if there are opponents then set challenge compensation\n', '        if (_applicantsAmount > 0) {\n', '            _setChallengeCompensation(_challengeId, _value, _applicantsAmount); // 30% to applicants\n', '            _value = _value.mul(7).div(10); // 70% to creator\n', '        }\n', '        _storage_.payOut(_user, _isGold, _value);\n', '        _storage_.setChallengeCancelled(_challengeId);\n', '    }\n', '\n', '    function returnBet(address _user, uint256 _challengeId) external onlyController {\n', '        _validateChallengeId(_challengeId);\n', '        ( , bool _exist, uint256 _dragonId) = _getUserApplicationIndex(_user, _challengeId);\n', '        require(_exist, "wrong challenge");\n', '\n', '        (bool _isGold, uint256 _bet, ) = _getChallenge(_challengeId);\n', '        uint256 _compensation = _getCompensation(_challengeId);\n', '        uint256 _value = _bet.add(_compensation);\n', '        _storage_.payOut(_user, _isGold, _value);\n', '        _storage_.removeDragonApplication(_dragonId, _challengeId);\n', '        _storage_.removeUserApplication(_user, _challengeId);\n', '\n', '        // if there are no more applicants then reset auto select block\n', '        if (_getChallengeApplicantsAmount(_challengeId) == 0) {\n', '            _storage_.setAutoSelectBlock(_challengeId, 0);\n', '        }\n', '    }\n', '\n', '    function addTimeForOpponentSelect(\n', '        address _user,\n', '        uint256 _challengeId\n', '    ) external onlyController returns (uint256 newAutoSelectBlock) {\n', '        _validateChallengeId(_challengeId);\n', '        _checkChallengeCreator(_challengeId, _user);\n', '        _checkForApplicants(_challengeId);\n', '        _checkTheOpponentIsNotSelected(_challengeId);\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '        uint256 _price = _storage_.getExtensionTimePrice(_challengeId);\n', '         // take gold\n', '        treasury.takeGold(_price);\n', '         // update multiplier\n', '        _storage_.setExtensionTimePrice(_challengeId, _price.mul(2));\n', '        // update auto select block\n', '        uint256 _autoSelectBlock = _storage_.autoSelectBlock(_challengeId);\n', '        newAutoSelectBlock = _autoSelectBlock.add(AUTO_SELECT_TIME);\n', '        _storage_.setAutoSelectBlock(_challengeId, newAutoSelectBlock);\n', '    }\n', '\n', '    function updateBattleBlockNumber(\n', '        uint256 _challengeId\n', '    ) external onlyController returns (uint256 newBattleBlockNumber) {\n', '        _validateChallengeId(_challengeId);\n', '        _checkTheBattleHasNotOccurred(_challengeId);\n', '        _checkTheChallengeIsNotCancelled(_challengeId);\n', '        uint256 _blockNumber = _getBattleBlockNumber(_challengeId);\n', '        _checkBattleBlockNumber(_blockNumber);\n', '        require(_blockNumber < _safeSub(block.number, 256), "you can start a battle");\n', '\n', '        newBattleBlockNumber = block.number.add(INTERVAL_FOR_NEW_BLOCK);\n', '        _storage_.setBattleBlockNumber(_challengeId, newBattleBlockNumber);\n', '    }\n', '\n', '    // UPDATE CONTRACT\n', '\n', '    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\n', '        super.setInternalDependencies(_newDependencies);\n', '\n', '        battle = Battle(_newDependencies[0]);\n', '        random = Random(_newDependencies[1]);\n', '        goldTokens = Gold(_newDependencies[2]);\n', '        getter = Getter(_newDependencies[3]);\n', '        treasury = Treasury(_newDependencies[4]);\n', '        _storage_ = GladiatorBattleStorage(_newDependencies[5]);\n', '        spectatorsStorage = GladiatorBattleSpectatorsStorage(_newDependencies[6]);\n', '    }\n', '}']