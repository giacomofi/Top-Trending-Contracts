['pragma solidity 0.5.3; /*\n', '\n', '___________________________________________________________________\n', '  _      _                                        ______           \n', '  |  |  /          /                                /              \n', '--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\n', "  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \n", '__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\n', '\n', '\n', '\n', '██████╗ ███████╗██████╗  ██████╗ ███████╗██╗████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗\n', '██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔════╝██║╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║\n', '██║  ██║█████╗  ██████╔╝██║   ██║███████╗██║   ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║\n', '██║  ██║██╔══╝  ██╔═══╝ ██║   ██║╚════██║██║   ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║\n', '██████╔╝███████╗██║     ╚██████╔╝███████║██║   ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║\n', '╚═════╝ ╚══════╝╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝\n', '                                                                                        \n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'DeposiToken (DT10)' contract with following functionalities:\n", '//      => Higher control of owner\n', '//      => SafeMath implementation \n', '//      => Referral system - 3 level\n', '//\n', '// Name             : DeposiToken\n', '// Symbol           : DT10\n', '// Decimals         : 15\n', '//\n', '// Copyright (c) 2018 FIRST DECENTRALIZED DEPOSIT PLATFORM ( https://fddp.io )\n', '// Contract designed by: EtherAuthority ( https://EtherAuthority.io ) \n', '// ----------------------------------------------------------------------------\n', '*/ \n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    \n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function subsafe(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if(b <= a){\n', '        return a - b;\n', '    }else{\n', '        return 0;\n', '    }\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '\n', 'contract DepositToken_10 {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    string public constant name = "DeposiToken";\n', '    \n', '    string public constant symbol = "DT10";\n', '    \n', '    uint32 public constant decimals = 15;\n', '    \n', '    uint public _money = 0;\n', '    uint public _tokens = 0;\n', '    uint public _sellprice;\n', '    \n', '    // Адрес контракта Акций\n', '    address payable public theStocksTokenContract;\n', '    \n', '    // сохранить баланс на счетах пользователя\n', '    \n', '    mapping (address => uint) private balances;\n', '    \n', '    event FullEventLog(\n', '        address indexed user,\n', '        bytes32 status,\n', '        uint sellprice,\n', '        uint buyprice, \n', '        uint time,\n', '        uint tokens,\n', '        uint ethers);\n', '        \n', '    \n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value);\n', '        \n', '    // OK\n', '    constructor (address payable _tstc) public {\n', '        uint s = 10**13; // start price\n', '        _sellprice = s.mul(90).div(100);\n', '        theStocksTokenContract = _tstc;\n', '        \n', '        /* 1000 token belongs to the contract */\n', '        uint _value = 1000 * 10**15; \n', '        \n', '        _tokens += _value;\n', '        balances[address(this)] += _value;\n', '        \n', '        emit Transfer(address(0x0), address(this), _value);\n', '    }\n', '    \n', '    // OK\n', '    function totalSupply () public view returns (uint256 tokens) {\n', '        return _tokens;\n', '    }\n', '    \n', '    // OK\n', '    function balanceOf(address addr) public view returns(uint){\n', '        return balances[addr];\n', '    }\n', '    \n', '    // OK\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        address addressContract = address(this);\n', '        require(_to == addressContract);\n', '        sell(_value);\n', '        success = true;\n', '    }\n', '    \n', '    // OK\n', '    function () external payable {\n', '        buy(address(0x0));\n', '    }\n', '    \n', '    \n', '    //***************************************************//\n', '    //--------------- REFERAL SYSTEM CODE ---------------//\n', '    //***************************************************//\n', '    \n', '    /** TECHNICAL SPECIFICATIONS\n', '     * \n', '     * Because this is multi-level (3 level) referral system, we have to fix referrals.\n', '     * Which means once a user is fixed under someone as referral, then that can not be changed.\n', '     * Referral will be fixed at their first deposit.\n', '     * This also means. If a person have used referral link to deposit and got fixed. Then if he does not use any links to deposit again, referral bonus paid to their referrers.\n', '     * \n', '     * \n', '     * USE CASES\n', '     * \n', '     * Case 1: depositor have used referral links, as well as depositor has existing direct referrer.\n', '     * In this case, ether will be sent to existing referrer, it will ignore the new link he used.\n', '     * \n', '     * Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract.\n', '     * In this case, ether will be sent to existing referrer.\n', '     * \n', '     * Case 3: depositor does not have any existing direct referrer, but used referral link.\n', '     * In this case, referral bonus will be paid to address in the referral link.\n', '     * \n', '     * All other cases apart from above, referral bonus will not be paid to anyone.\n', '     * And Entire platform fee (5% of deposit) will be sent to stock contract.\n', '     */\n', '    \n', '    /* Mapping to track referrer. The second address is the address of referrer, the Up-line/ Sponsor */\n', '    mapping (address => address payable) public referrers;\n', '    \n', '    /* Mapping to track referrer bonus for all the referrers */\n', '    mapping (address => uint) public referrerBonusBalance;\n', '    \n', '    /* Events to track ether transfer to referrers */\n', '    event ReferrerBonus(address indexed referer, address indexed depositor, uint256 depositAmount , uint256 etherReceived, uint256 timestamp );\n', '    \n', '    /* Events to track referral bonus claims */\n', '    event ReferralBonusClaim(address indexed referrar, uint256 bonus, uint256 timestamp);\n', '    /* Function to distribute bonuses to referrers, as well as calculating finaPlatformFee */\n', '    function distributeReferrerBonus(address payable _directReferrer, uint platformFee) internal returns (uint){\n', '        \n', '        // 60% of the Platform fee will be distributed to referrers, which is 3% of deposited ether\n', '        uint finaPlatformFee = platformFee;\n', '        \n', '        // Sending ether to level 1 (direct) referrer and deducting that amount from platformFee\n', '        uint _valueLevel1 = platformFee.mul(40).div(100);\n', '        referrerBonusBalance[_directReferrer] += _valueLevel1;  //40% of Platform Fee, equivilent to 2% of deposited ether\n', '        finaPlatformFee = finaPlatformFee.sub(_valueLevel1);\n', '        emit ReferrerBonus(_directReferrer, msg.sender, msg.value , _valueLevel1, now );\n', '    \n', '        \n', '        // If there is level 2 referrer, then sending ether to him/her as well\n', '        if(referrers[_directReferrer] != address(0x0)){\n', '            // Sending ether to level 2 referrer and deducting that amount from platformFee\n', '            uint _valueLevel2 = platformFee.mul(10).div(100);\n', '            referrerBonusBalance[referrers[_directReferrer]] += _valueLevel2;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\n', '            finaPlatformFee = finaPlatformFee.sub(_valueLevel2);\n', '            emit ReferrerBonus(referrers[_directReferrer], msg.sender, msg.value , _valueLevel2, now );\n', '        }\n', '        \n', '        // If there is level 3 referrer, then sending ether to him/her as well\n', '        if(referrers[referrers[_directReferrer]] != address(0x0)){\n', '            // Sending ether to level 2 referrer and deducting that amount from platformFee\n', '            uint _valueLevel3 = platformFee.mul(10).div(100);\n', '            referrerBonusBalance[referrers[referrers[_directReferrer]]] += _valueLevel3;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\n', '            finaPlatformFee = finaPlatformFee.sub(_valueLevel3);\n', '            emit ReferrerBonus(referrers[referrers[_directReferrer]], msg.sender, msg.value , _valueLevel3, now );\n', '        }\n', '        \n', '        // Returns final platform fee which would be sent to stock contract\n', '        return finaPlatformFee;\n', '    }\n', '    \n', '    /* Function will allow users to withdraw their referrer bonus  */\n', '    function claimReferrerBonus() public {\n', '        uint256 referralBonus = referrerBonusBalance[msg.sender];\n', "        require(referralBonus > 0, 'Insufficient referrer bonus');\n", '        referrerBonusBalance[msg.sender] = 0;\n', '        msg.sender.transfer(referralBonus);\n', '        emit ReferralBonusClaim(msg.sender,referralBonus,now);\n', '    }\n', '    \n', '    \n', '    // OK\n', '    function buy(address payable _referrer) public payable {\n', '        uint _value = msg.value.mul(10**15).div(_sellprice.mul(100).div(90));\n', '        \n', '        // общий баланс Эфиров на контракте\n', '        _money = _money.add(msg.value.mul(95).div(100));\n', '        \n', '        // Platform fee - 5% of the ether deposit\n', '        uint platformFee = msg.value.mul(50).div(1000);\n', '        \n', '        // Final platform Fee, is after all the referrer payout deductions (as many as applicable).\n', '        uint finaPlatformFee; \n', '        \n', '        \n', '        /** Processing referral system fund distribution **/\n', '        // Case 1: depositor have used referral links, as well as depositor has existing direct referrer\n', '        // In this case, ether will be sent to existing referrer, it will ignore the new link he used.\n', '        if(_referrer != address(0x0) && referrers[msg.sender] != address(0x0)){\n', '            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\n', '        }\n', '        \n', '        // Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract\n', '        // In this case, ether will be sent to existing referrer\n', '        else if(_referrer == address(0x0) && referrers[msg.sender] != address(0x0)){\n', '            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\n', '        }\n', '        \n', '        // Case 3: depositor does not have any existing direct referrer, but used referral link\n', '        // In this case, referral bonus will be paid to address in the referral link\n', '        else if(_referrer != address(0x0) && referrers[msg.sender] == address(0x0)){\n', '            finaPlatformFee = distributeReferrerBonus(_referrer, platformFee);\n', '            //adding referral details in both the mappings\n', '            referrers[msg.sender]=_referrer;\n', '        }\n', '        \n', '        // All other cases apart from above, referral bonus will not be paid to anyone\n', '        // And Entire platform fee (5% of deposit) will be sent to stock contract\n', '        else {\n', '            finaPlatformFee = platformFee;\n', '        }\n', '        \n', '        // отправить прибыль на контракт собствеников системы\n', '        (bool success, ) =    theStocksTokenContract.call.value(finaPlatformFee).gas(53000)("");\n', '        \n', '        // This checks if ether transfer to stock contract is successful, otherwise revert\n', "        require(success, 'Ether transfer to DA Token contract failed');\n", '        \n', '        // всего токенов в системе\n', '        _tokens = _tokens.add(_value);\n', '        \n', '        // добавить токены, на баланс пользователя\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        \n', '        // Логируем событие с курсом / датой / \n', '        emit FullEventLog(msg.sender, "buy", _sellprice, _sellprice.mul(100).div(90), now, _value, msg.value);\n', '        \n', '        _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\n', '        \n', '        \n', '        emit Transfer(address(this), msg.sender, _value);\n', '    }\n', '\n', '    // OK\n', '    function sell (uint256 countTokens) public {\n', '        // проверка на отрицательный баланс\n', '        require(balances[msg.sender] >= countTokens);\n', '        \n', '        uint _value = countTokens.mul(_sellprice).div(10**15);\n', '        \n', '        _money = _money.sub(_value);\n', '        \n', '        _tokens = _tokens.subsafe(countTokens);\n', '        \n', '        balances[msg.sender] = balances[msg.sender].subsafe(countTokens);\n', '        \n', '        emit FullEventLog(msg.sender, "sell", _sellprice, _sellprice.mul(100).div(90), now, countTokens, _value);\n', '        \n', '        if(_tokens > 0) {\n', '            _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\n', '        }\n', '\n', '    \temit Transfer(msg.sender, address(this), countTokens);\n', '        msg.sender.transfer(_value);\n', '    }\n', '    // OK\n', '    function getPrice() public view returns (uint bid, uint ask) {\n', '        bid = _sellprice.mul(100).div(90);\n', '        ask = _sellprice;\n', '    }\n', '}']