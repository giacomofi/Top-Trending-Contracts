['pragma solidity ^0.4.25;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'UBETCOINS' token contract\n", '//\n', '// Symbol      : UBETS\n', '// Name        : UBET COINS\n', '// Total supply: 4000000000\n', '// Decimals    : 18\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public{\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) pure internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) public returns (bool success) {\n', '      \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public returns (bool success) {\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract UbetCoins is Ownable, StandardToken {\n', '\n', '    string public name = "Ubet Coins";\n', '    string public symbol = "UBETS"; \n', '    uint public decimals = 18;      \n', '\n', '    uint256 public totalSupply =  4000000000 * (10**decimals);\n', '    uint256 public tokenSupplyFromCheck = 0;              \n', '        \n', '    /// Base exchange rate is set\n', '    uint256 public ratePerOneEther = 135;\n', '    uint256 public totalUBetCheckAmounts = 0;\n', '\n', '    /// Issue event index starting from 0.\n', '    uint64 public issueIndex = 0;\n', '\n', '    /// Emitted for each sucuessful token purchase.\n', '    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n', '    \n', '    // All funds will be transferred in this wallet.\n', '    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n', '    \n', '    string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = "https://s3.amazonaws.com/s3-ubetcoin-user-signatures/document/LEDGER-TO-LEDGER-ENTRY-FOR-UBETCOINS.pdf";\n', '    string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = "c8f0ae2602005dd88ef908624cf59f3956107d0890d67d3baf9c885b64544a8140e282366cae6a3af7bfbc96d17f856b55fc4960e2287d4a03d67e646e0e88c6";\n', '\n', '    /// Emitted for each UBetCheckS register.\n', '    event UBetCheckIssue(string chequeIndex);\n', '      \n', '    struct UBetCheck {\n', '      string accountId;\n', '      string accountNumber;\n', '      string fullName;\n', '      string routingNumber;\n', '      string institution;\n', '      uint256 amount;\n', '      uint256 tokens;\n', '      string checkFilePath;\n', '      string digitalCheckFingerPrint;\n', '    }\n', '    \n', '    mapping (address => UBetCheck) UBetChecks;\n', '    address[] public UBetCheckAccts;\n', '    \n', '    \n', '    /// @dev Initializes the contract and allocates all initial tokens to the owner\n', '    function UbetCoins() public{\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '  \n', '    //////////////// owner only functions below\n', '\n', '    /// @dev To transfer token contract ownership\n', '    /// @param _newOwner The address of the new owner of this contract\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        Ownable.transferOwnership(_newOwner);\n', '    }\n', '    \n', '    /// check functionality\n', '    \n', '    /// @dev Register UBetCheck to the chain\n', '    /// @param _beneficiary recipient ether address\n', '    /// @param _accountId the id generated from the db\n', '    /// @param _accountNumber the account number stated in the check\n', '    /// @param _routingNumber the routing number stated in the check\n', '    /// @param _institution the name of the institution / bank in the check\n', '    /// @param _fullname the name printed on the check\n', '    /// @param _amount the amount in currency in the chek\n', '    /// @param _checkFilePath the url path where the cheque has been uploaded\n', '    /// @param _digitalCheckFingerPrint the hash of the file\n', '    /// @param _tokens number of tokens issued to the beneficiary\n', '    function registerUBetCheck(address _beneficiary, string _accountId,  string _accountNumber, string _routingNumber, string _institution, string _fullname,  uint256 _amount, string _checkFilePath, string _digitalCheckFingerPrint, uint256 _tokens) public payable onlyOwner {\n', '      \n', '      require(_beneficiary != address(0));\n', '      require(bytes(_accountId).length != 0);\n', '      require(bytes(_accountNumber).length != 0);\n', '      require(bytes(_routingNumber).length != 0);\n', '      require(bytes(_institution).length != 0);\n', '      require(bytes(_fullname).length != 0);\n', '      require(_amount > 0);\n', '      require(_tokens > 0);\n', '      require(bytes(_checkFilePath).length != 0);\n', '      require(bytes(_digitalCheckFingerPrint).length != 0);\n', '      \n', '      uint256 __conToken = _tokens * (10**(decimals));\n', '\n', '      \n', '      var UBetCheck = UBetChecks[_beneficiary];\n', '      \n', '      UBetCheck.accountId = _accountId;\n', '      UBetCheck.accountNumber = _accountNumber;\n', '      UBetCheck.routingNumber = _routingNumber;\n', '      UBetCheck.institution = _institution;\n', '      UBetCheck.fullName = _fullname;\n', '      UBetCheck.amount = _amount;\n', '      UBetCheck.tokens = _tokens;\n', '      \n', '      UBetCheck.checkFilePath = _checkFilePath;\n', '      UBetCheck.digitalCheckFingerPrint = _digitalCheckFingerPrint;\n', '      \n', '      totalUBetCheckAmounts = safeAdd(totalUBetCheckAmounts, _amount);\n', '      tokenSupplyFromCheck = safeAdd(tokenSupplyFromCheck, _tokens);\n', '      \n', '      UBetCheckAccts.push(_beneficiary) -1;\n', '      \n', '      // Issue token when registered UBetCheck is complete to the _beneficiary\n', '      doIssueTokens(_beneficiary, __conToken);\n', '      \n', '      // Fire Event UBetCheckIssue\n', '      UBetCheckIssue(_accountId);\n', '    }\n', '    \n', '    /// @dev List all the checks in the\n', '    function getUBetChecks() public view returns (address[]) {\n', '      return UBetCheckAccts;\n', '    }\n', '    \n', '    /// @dev Return UBetCheck information by supplying beneficiary adddress\n', '    function getUBetCheck(address _address) public view returns(string, string, string, string, uint256, string, string) {\n', '            \n', '      return (UBetChecks[_address].accountNumber,\n', '              UBetChecks[_address].routingNumber,\n', '              UBetChecks[_address].institution,\n', '              UBetChecks[_address].fullName,\n', '              UBetChecks[_address].amount,\n', '              UBetChecks[_address].checkFilePath,\n', '              UBetChecks[_address].digitalCheckFingerPrint);\n', '    }\n', '    \n', '    /// @dev This default function allows token to be purchased by directly\n', '    /// sending ether to this smart contract.\n', '    function () public payable {\n', '      purchaseTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev return total count of registered UBetChecks\n', '    function countUBetChecks() public view returns (uint) {\n', '        return UBetCheckAccts.length;\n', '    }\n', '    \n', '\n', '    /// @dev issue tokens for a single buyer\n', '    /// @param _beneficiary addresses that the tokens will be sent to.\n', '    /// @param _tokens the amount of tokens, with decimals expanded (full).\n', '    function doIssueTokens(address _beneficiary, uint256 _tokens) internal {\n', '      require(_beneficiary != address(0));    \n', '\n', '      // compute without actually increasing it\n', '      uint256 increasedTotalSupply = safeAdd(totalSupply, _tokens);\n', '      \n', '      // increase token total supply\n', '      totalSupply = increasedTotalSupply;\n', '      // update the beneficiary balance to number of tokens sent\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _tokens);\n', '      \n', '      emit Transfer(msg.sender, _beneficiary, _tokens);\n', '    \n', '      // event is fired when tokens issued\n', '      emit Issue(\n', '                issueIndex++,\n', '                _beneficiary,\n', '                _tokens\n', '                );\n', '    }\n', '    \n', '    /// @dev Issue token based on Ether received.\n', '    /// @param _beneficiary Address that newly issued token will be sent to.\n', '    function purchaseTokens(address _beneficiary) public payable {\n', '      \n', '      uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals)));\n', '      doIssueTokens(_beneficiary, _tokens);\n', '\n', '      /// forward the money to the money wallet\n', '      address(moneyWallet).transfer(address(this).balance);\n', '    }\n', '    \n', '    \n', '    /// @dev Change money wallet owner\n', '    /// @param _address new address to received the ether\n', '    function setMoneyWallet(address _address) public onlyOwner {\n', '        moneyWallet = _address;\n', '    }\n', '    \n', '    /// @dev Change Rate per token in one ether\n', '    /// @param _value the amount of tokens, with decimals expanded (full).\n', '    function setRatePerOneEther(uint256 _value) public onlyOwner {\n', '      require(_value >= 1);\n', '      ratePerOneEther = _value;\n', '    }\n', '    \n', '}']