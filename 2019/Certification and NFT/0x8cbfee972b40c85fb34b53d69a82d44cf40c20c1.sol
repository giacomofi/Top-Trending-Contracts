['pragma solidity 0.5.1;\n', '\n', '/**\n', '* @dev Base contract for teams\n', '*/\n', 'contract Team {\n', '    using SafeMath for uint256;\n', '\n', '    //DEEX fund address\n', '    address payable public DEEXFund = 0xA2A3aD8319D24f4620Fbe06D2bC57c045ECF0932;\n', '\n', '    JackPot public JPContract;\n', '    DEEX public DEEXContract;\n', '\n', '    /**\n', '    * @dev Payable function. 10% will send to DEEX fund and 90% will send to JackPot contract.\n', '    * Also setting info about player.\n', '    */\n', '    function () external payable {\n', '        require(JPContract.getState() && msg.value >= 0.05 ether);\n', '\n', '        JPContract.setInfo(msg.sender, msg.value.mul(90).div(100));\n', '\n', '        DEEXFund.transfer(msg.value.mul(10).div(100));\n', '\n', '        address(JPContract).transfer(msg.value.mul(90).div(100));\n', '    }\n', '}\n', '\n', '/*\n', '* @dev Dragons contract. To play game with Dragons send ETH to this contract\n', '*/\n', 'contract Dragons is Team {\n', '\n', '    /*\n', '    * @dev Approving JackPot contract for spending token from Dragons contract.\n', '    * Also setting Dragons address in JackPot contract\n', '    */\n', '    constructor(address payable _jackPotAddress, address payable _DEEXAddress) public {\n', '        JPContract = JackPot(_jackPotAddress);\n', '        JPContract.setDragonsAddress(address(this));\n', '        DEEXContract = DEEX(_DEEXAddress);\n', '        DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000);\n', '    }\n', '}\n', '\n', '/*\n', '* @dev Hamsters contract. To play game with Hamsters send ETH to this contract\n', '*/\n', 'contract Hamsters is Team {\n', '\n', '    /*\n', '    * @dev Approving JackPot contract for spending token from Hamsters contract.\n', '    * Also setting Hamsters address in JackPot contract\n', '    */\n', '    constructor(address payable _jackPotAddress, address payable _DEEXAddress) public {\n', '        JPContract = JackPot(_jackPotAddress);\n', '        JPContract.setHamstersAddress(address(this));\n', '        DEEXContract = DEEX(_DEEXAddress);\n', '        DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error. Latest version on 05.01.2019\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/*\n', '* @title JackPot\n', '* @dev Jackpot contract which contained all ETH from Dragons and Hamsters teams.\n', '* When time in blockchain will be grater then current deadline or last deadline need call getWinner function\n', '* then participants able get prizes.\n', '*\n', '* Last participant(last hero) win 10% from all bank\n', '*\n', '* - To get prize send 0 ETH to this contract\n', '*/\n', 'contract JackPot {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public depositDragons;\n', '    mapping (address => uint256) public depositHamsters;\n', '    uint256 public currentDeadline;\n', '    uint256 public lastDeadline = 1551978000; //last deadline for game\n', '    uint256 public countOfDragons;\n', '    uint256 public countOfHamsters;\n', '    uint256 public totalSupplyOfHamsters;\n', '    uint256 public totalSupplyOfDragons;\n', '    uint256 public totalDEEXSupplyOfHamsters;\n', '    uint256 public totalDEEXSupplyOfDragons;\n', '    uint256 public probabilityOfHamsters;\n', '    uint256 public probabilityOfDragons;\n', '    address public lastHero;\n', '    address public lastHeroHistory;\n', '    uint256 public jackPot;\n', '    uint256 public winner;\n', '    bool public finished = false;\n', '\n', '    Dragons public DragonsContract;\n', '    Hamsters public HamstersContract;\n', '    DEEX public DEEXContract;\n', '\n', '    /*\n', '    * @dev Constructor create first deadline\n', '    */\n', '    constructor() public {\n', '        currentDeadline = block.timestamp + 60 * 60 * 24 * 30 ; //days for first deadline\n', '    }\n', '\n', '    /**\n', '    * @dev Setter the DEEX Token contract address. Address can be set at once.\n', '    * @param _DEEXAddress Address of the DEEX Token contract\n', '    */\n', '    function setDEEXAddress(address payable _DEEXAddress) public {\n', '        require(address(DEEXContract) == address(0x0));\n', '        DEEXContract = DEEX(_DEEXAddress);\n', '    }\n', '\n', '    /**\n', '    * @dev Setter the Dragons contract address. Address can be set at once.\n', '    * @param _dragonsAddress Address of the Dragons contract\n', '    */\n', '    function setDragonsAddress(address payable _dragonsAddress) external {\n', '        require(address(DragonsContract) == address(0x0));\n', '        DragonsContract = Dragons(_dragonsAddress);\n', '    }\n', '\n', '    /**\n', '    * @dev Setter the Hamsters contract address. Address can be set at once.\n', '    * @param _hamstersAddress Address of the Hamsters contract\n', '    */\n', '    function setHamstersAddress(address payable _hamstersAddress) external {\n', '        require(address(HamstersContract) == address(0x0));\n', '        HamstersContract = Hamsters(_hamstersAddress);\n', '    }\n', '\n', '    /**\n', '    * @dev Getting time from blockchain\n', '    */\n', '    function getNow() view public returns(uint){\n', '        return block.timestamp;\n', '    }\n', '\n', '    /**\n', '    * @dev Getting state of game. True - game continue, False - game stopped\n', '    */\n', '    function getState() view public returns(bool) {\n', '        if (block.timestamp > currentDeadline) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Setting info about participant from Dragons or Hamsters contract\n', '    * @param _lastHero Address of participant\n', '    * @param _deposit Amount of deposit\n', '    */\n', '    function setInfo(address _lastHero, uint256 _deposit) public {\n', '        require(address(DragonsContract) == msg.sender || address(HamstersContract) == msg.sender);\n', '\n', '        if (address(DragonsContract) == msg.sender) {\n', '            require(depositHamsters[_lastHero] == 0, "You are already in hamsters team");\n', '            if (depositDragons[_lastHero] == 0)\n', '                countOfDragons++;\n', '            totalSupplyOfDragons = totalSupplyOfDragons.add(_deposit.mul(90).div(100));\n', '            depositDragons[_lastHero] = depositDragons[_lastHero].add(_deposit.mul(90).div(100));\n', '        }\n', '\n', '        if (address(HamstersContract) == msg.sender) {\n', '            require(depositDragons[_lastHero] == 0, "You are already in dragons team");\n', '            if (depositHamsters[_lastHero] == 0)\n', '                countOfHamsters++;\n', '            totalSupplyOfHamsters = totalSupplyOfHamsters.add(_deposit.mul(90).div(100));\n', '            depositHamsters[_lastHero] = depositHamsters[_lastHero].add(_deposit.mul(90).div(100));\n', '        }\n', '\n', '        lastHero = _lastHero;\n', '\n', '        if (currentDeadline.add(120) <= lastDeadline) {\n', '            currentDeadline = currentDeadline.add(120);\n', '        } else {\n', '            currentDeadline = lastDeadline;\n', '        }\n', '\n', '        jackPot = (address(this).balance.add(_deposit)).mul(10).div(100);\n', '\n', '        calculateProbability();\n', '    }\n', '\n', '    /**\n', "    * @dev Calculation probability for team's win\n", '    */\n', '    function calculateProbability() public {\n', '        require(winner == 0 && getState());\n', '\n', '        totalDEEXSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\n', '        totalDEEXSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\n', '        uint256 percent = (totalSupplyOfHamsters.add(totalSupplyOfDragons)).div(100);\n', '\n', '        if (totalDEEXSupplyOfHamsters < 1) {\n', '            totalDEEXSupplyOfHamsters = 0;\n', '        }\n', '\n', '        if (totalDEEXSupplyOfDragons < 1) {\n', '            totalDEEXSupplyOfDragons = 0;\n', '        }\n', '\n', '        if (totalDEEXSupplyOfHamsters <= totalDEEXSupplyOfDragons) {\n', '            uint256 difference = (totalDEEXSupplyOfDragons.sub(totalDEEXSupplyOfHamsters)).mul(100);\n', '            probabilityOfDragons = totalSupplyOfDragons.mul(100).div(percent).add(difference);\n', '\n', '            if (probabilityOfDragons > 8000) {\n', '                probabilityOfDragons = 8000;\n', '            }\n', '            if (probabilityOfDragons < 2000) {\n', '                probabilityOfDragons = 2000;\n', '            }\n', '            probabilityOfHamsters = 10000 - probabilityOfDragons;\n', '        } else {\n', '            uint256 difference = (totalDEEXSupplyOfHamsters.sub(totalDEEXSupplyOfDragons)).mul(100);\n', '\n', '            probabilityOfHamsters = totalSupplyOfHamsters.mul(100).div(percent).add(difference);\n', '\n', '            if (probabilityOfHamsters > 8000) {\n', '                probabilityOfHamsters = 8000;\n', '            }\n', '            if (probabilityOfHamsters < 2000) {\n', '                probabilityOfHamsters = 2000;\n', '            }\n', '            probabilityOfDragons = 10000 - probabilityOfHamsters;\n', '        }\n', '\n', '        totalDEEXSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\n', '        totalDEEXSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\n', '    }\n', '\n', '    /**\n', '    * @dev Getting winner team\n', '    */\n', '    function getWinners() public {\n', '        require(winner == 0 && !getState());\n', '\n', '        uint256 seed1 = address(this).balance;\n', '        uint256 seed2 = totalSupplyOfHamsters;\n', '        uint256 seed3 = totalSupplyOfDragons;\n', '        uint256 seed4 = totalDEEXSupplyOfHamsters;\n', '        uint256 seed5 = totalDEEXSupplyOfHamsters;\n', '        uint256 seed6 = block.difficulty;\n', '        uint256 seed7 = block.timestamp;\n', '\n', '        bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7));\n', '        uint randomNumber = uint(randomHash);\n', '\n', '        if (randomNumber == 0){\n', '            randomNumber = 1;\n', '        }\n', '\n', '        uint winningNumber = randomNumber % 10000;\n', '\n', '        if (1 <= winningNumber && winningNumber <= probabilityOfDragons){\n', '            winner = 1;\n', '        }\n', '\n', '        if (probabilityOfDragons < winningNumber && winningNumber <= 10000){\n', '            winner = 2;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Payable function for take prize\n', '    */\n', '    function () external payable {\n', '        if (msg.value == 0 &&  !getState() && winner > 0){\n', '            require(depositDragons[msg.sender] > 0 || depositHamsters[msg.sender] > 0);\n', '\n', '            uint payout = 0;\n', '            uint payoutDEEX = 0;\n', '\n', '            if (winner == 1 && depositDragons[msg.sender] > 0) {\n', '                payout = calculateETHPrize(msg.sender);\n', '            }\n', '            if (winner == 2 && depositHamsters[msg.sender] > 0) {\n', '                payout = calculateETHPrize(msg.sender);\n', '            }\n', '\n', '            if (payout > 0) {\n', '                depositDragons[msg.sender] = 0;\n', '                depositHamsters[msg.sender] = 0;\n', '                msg.sender.transfer(payout);\n', '            }\n', '\n', '            if ((winner == 1 && depositDragons[msg.sender] == 0) || (winner == 2 && depositHamsters[msg.sender] == 0)) {\n', '                payoutDEEX = calculateDEEXPrize(msg.sender);\n', '                if (DEEXContract.balanceOf(address(HamstersContract)) > 0)\n', '                    DEEXContract.transferFrom(\n', '                        address(HamstersContract),\n', '                        address(this),\n', '                        DEEXContract.balanceOf(address(HamstersContract))\n', '                    );\n', '                if (DEEXContract.balanceOf(address(DragonsContract)) > 0)\n', '                    DEEXContract.transferFrom(\n', '                        address(DragonsContract),\n', '                        address(this),\n', '                        DEEXContract.balanceOf(address(DragonsContract))\n', '                    );\n', '                if (payoutDEEX > 0){\n', '                    DEEXContract.transfer(msg.sender, payoutDEEX);\n', '                }\n', '            }\n', '\n', '            if (msg.sender == lastHero) {\n', '                lastHeroHistory = lastHero;\n', '                lastHero = address(0x0);\n', '                msg.sender.transfer(jackPot);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Getting ETH prize of participant\n', '    * @param participant Address of participant\n', '    */\n', '    function calculateETHPrize(address participant) public view returns(uint) {\n', '        uint payout = 0;\n', '\n', '        uint256 totalSupply = totalSupplyOfDragons.add(totalSupplyOfHamsters);\n', '        if (totalSupply > 0) {\n', '            if (depositDragons[participant] > 0) {\n', '                payout = totalSupply.mul(depositDragons[participant]).div(totalSupplyOfDragons);\n', '            }\n', '\n', '            if (depositHamsters[participant] > 0) {\n', '                payout = totalSupply.mul(depositHamsters[participant]).div(totalSupplyOfHamsters);\n', '            }\n', '        }\n', '        return payout;\n', '    }\n', '\n', '    /**\n', '    * @dev Getting DEEX Token prize of participant\n', '    * @param participant Address of participant\n', '    */\n', '    function calculateDEEXPrize(address participant) public view returns(uint) {\n', '        uint payout = 0;\n', '\n', '        if (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters) > 0){\n', '            uint totalSupply = (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters)).mul(80).div(100);\n', '\n', '            if (depositDragons[participant] > 0) {\n', '                payout = totalSupply.mul(depositDragons[participant]).div(totalSupplyOfDragons);\n', '            }\n', '\n', '            if (depositHamsters[participant] > 0) {\n', '                payout = totalSupply.mul(depositHamsters[participant]).div(totalSupplyOfHamsters);\n', '            }\n', '\n', '            return payout;\n', '        }\n', '        return payout;\n', '    }\n', '}\n', '\n', '/*\n', '*  deex.exchange pre-ICO tokens smart contract\n', '*  implements [ERC-20 Token Standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\n', '*\n', '*  Style\n', "*  1) before start coding, run Python and type 'import this' in Python console.\n", '*  2) we avoid using inheritance (contract B is A) as it makes code less clear for observer\n', '*  ("Flat is better than nested", "Readability counts")\n', '*  3) we avoid using -= ; =- ; +=; =+\n', '*  see: https://github.com/ether-camp/virtual-accelerator/issues/8\n', '*  https://www.ethnews.com/ethercamps-hkg-token-has-a-bug-and-needs-to-be-reissued\n', '*  4) always explicitly mark variables and functions visibility ("Explicit is better than implicit")\n', '*  5) every function except constructor should trigger at leas one event.\n', '*  6) smart contracts have to be audited and reviewed, comment your code.\n', '*\n', '*  Code is published on https://github.com/thedeex/thedeex.github.io\n', '*/\n', '\n', '\n', '/* "Interfaces" */\n', '\n', '//  this is expected from another contracts\n', '//  if it wants to spend tokens of behalf of the token owner in our contract\n', '//  this can be used in many situations, for example to convert pre-ICO tokens to ICO tokens\n', "//  see 'approveAndCall' function\n", 'contract allowanceRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _inContract, bytes memory _extraData) public returns (bool success);\n', '}\n', '\n', '\n', '// see:\n', '// https://github.com/ethereum/EIPs/issues/677\n', 'contract tokenRecipient {\n', '    function tokenFallback(address _from, uint256 _value, bytes memory _extraData) public returns (bool success);\n', '}\n', '\n', '\n', 'contract DEEX {\n', '\n', '    // ver. 2.0\n', '\n', '    /* ---------- Variables */\n', '\n', '    /* --- ERC-20 variables */\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\n', '    // function name() constant returns (string name)\n', '    string public name = "deex";\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\n', '    // function symbol() constant returns (string symbol)\n', '    string public symbol = "deex";\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\n', '    // function decimals() constant returns (uint8 decimals)\n', '    uint8 public decimals = 0;\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\n', '    // function totalSupply() constant returns (uint256 totalSupply)\n', '    // we start with zero and will create tokens as SC receives ETH\n', '    uint256 public totalSupply;\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\n', '    // function balanceOf(address _owner) constant returns (uint256 balance)\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\n', '    // function allowance(address _owner, address _spender) constant returns (uint256 remaining)\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* ----- For tokens sale */\n', '\n', '    uint256 public salesCounter = 0;\n', '\n', '    uint256 public maxSalesAllowed;\n', '\n', '    bool private transfersBetweenSalesAllowed;\n', '\n', '    // initial value should be changed by the owner\n', '    uint256 public tokenPriceInWei = 0;\n', '\n', '    uint256 public saleStartUnixTime = 0; // block.timestamp\n', '    uint256 public saleEndUnixTime = 0;  // block.timestamp\n', '\n', '    /* --- administrative */\n', '    address public owner;\n', '\n', '    // account that can set prices\n', '    address public priceSetter;\n', '\n', '    // 0 - not set\n', '    uint256 private priceMaxWei = 0;\n', '    // 0 - not set\n', '    uint256 private priceMinWei = 0;\n', '\n', '    // accounts holding tokens for for the team, for advisers and for the bounty campaign\n', '    mapping (address => bool) public isPreferredTokensAccount;\n', '\n', '    bool public contractInitialized = false;\n', '\n', '\n', '    /* ---------- Constructor */\n', '    // do not forget about:\n', '    // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\n', '    constructor () public {\n', '        owner = msg.sender;\n', '\n', '        // for testNet can be more than 2\n', '        // --------------------------------2------------------------------------------------------change  in production!\n', '        maxSalesAllowed = 2;\n', '        //\n', '        transfersBetweenSalesAllowed = true;\n', '    }\n', '\n', '\n', '    function initContract(address team, address advisers, address bounty) public onlyBy(owner) returns (bool){\n', '\n', '        require(contractInitialized == false);\n', '        contractInitialized = true;\n', '\n', '        priceSetter = msg.sender;\n', '\n', '        totalSupply = 100000000;\n', '\n', '        // tokens for sale go SC own account\n', '        balanceOf[address(this)] = 75000000;\n', '\n', '        // for the team\n', '        balanceOf[team] = balanceOf[team] + 15000000;\n', '        isPreferredTokensAccount[team] = true;\n', '\n', '        // for advisers\n', '        balanceOf[advisers] = balanceOf[advisers] + 7000000;\n', '        isPreferredTokensAccount[advisers] = true;\n', '\n', '        // for the bounty campaign\n', '        balanceOf[bounty] = balanceOf[bounty] + 3000000;\n', '        isPreferredTokensAccount[bounty] = true;\n', '\n', '    }\n', '\n', '    /* ---------- Events */\n', '\n', '    /* --- ERC-20 events */\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\n', '    event Approval(address indexed _owner, address indexed spender, uint256 value);\n', '\n', '    /* --- Administrative events:  */\n', '    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n', '\n', '    /* ---- Tokens creation and sale events  */\n', '\n', '    event PriceChanged(uint256 indexed newTokenPriceInWei);\n', '\n', '    event SaleStarted(uint256 startUnixTime, uint256 endUnixTime, uint256 indexed saleNumber);\n', '\n', '    event NewTokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\n', '\n', '    event Withdrawal(address indexed to, uint sumInWei);\n', '\n', '    /* --- Interaction with other contracts events  */\n', '    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\n', '\n', '    /* ---------- Functions */\n', '\n', '    /* --- Modifiers  */\n', '    modifier onlyBy(address _account){\n', '        require(msg.sender == _account);\n', '\n', '        _;\n', '    }\n', '\n', '    /* --- ERC-20 Functions */\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\n', '    function transfer(address _to, uint256 _value) public returns (bool){\n', '        return transferFrom(msg.sender, _to, _value);\n', '    }\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '\n', '        // transfers are possible only after sale is finished\n', '        // except for manager and preferred accounts\n', '\n', '        bool saleFinished = saleIsFinished();\n', '        require(saleFinished || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\n', '\n', '        // transfers can be forbidden until final ICO is finished\n', '        // except for manager and preferred accounts\n', '        require(transfersBetweenSalesAllowed || salesCounter == maxSalesAllowed || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\n', '\n', '        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\n', '        require(_value >= 0);\n', '\n', '        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\n', '        require(msg.sender == _from || _value <= allowance[_from][msg.sender]);\n', '\n', '        // check if _from account have required amount\n', '        require(_value <= balanceOf[_from]);\n', '\n', '        // Subtract from the sender\n', '        balanceOf[_from] = balanceOf[_from] - _value;\n', '        //\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = balanceOf[_to] + _value;\n', '\n', '        // If allowance used, change allowances correspondingly\n', '        if (_from != msg.sender) {\n', '            allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\n', '        }\n', '\n', '        // event\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\n', '    // there is and attack, see:\n', '    // https://github.com/CORIONplatform/solidity/issues/6,\n', '    // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\n', '    // but this function is required by ERC-20\n', '    function approve(address _spender, uint256 _value) public returns (bool success){\n', '\n', '        require(_value >= 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        // event\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*  ---------- Interaction with other contracts  */\n', '\n', '    /* User can allow another smart contract to spend some shares in his behalf\n', '    *  (this function should be called by user itself)\n', "    *  @param _spender another contract's address\n", '    *  @param _value number of tokens\n', '    *  @param _extraData Data that can be sent from user to another contract to be processed\n', '    *  bytes - dynamically-sized byte array,\n', '    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array\n', "    *  see possible attack information in comments to function 'approve'\n", '    *  > this may be used to convert pre-ICO tokens to ICO tokens\n', '    */\n', '    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n', '\n', '        approve(_spender, _value);\n', '\n', "        // 'spender' is another contract that implements code as prescribed in 'allowanceRecipient' above\n", '        allowanceRecipient spender = allowanceRecipient(_spender);\n', '\n', "        // our contract calls 'receiveApproval' function of another contract ('allowanceRecipient') to send information about\n", '        // allowance and data sent by user\n', "        // 'this' is this (our) contract address\n", '        if (spender.receiveApproval(msg.sender, _value, address(this), _extraData)) {\n', '            emit DataSentToAnotherContract(msg.sender, _spender, _extraData);\n', '            return true;\n', '        }\n', '        else return false;\n', '    }\n', '\n', '    function approveAllAndCall(address _spender, bytes memory _extraData) public returns (bool success) {\n', '        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);\n', '    }\n', '\n', '    /* https://github.com/ethereum/EIPs/issues/677\n', '    * transfer tokens with additional info to another smart contract, and calls its correspondent function\n', '    * @param address _to - another smart contract address\n', '    * @param uint256 _value - number of tokens\n', '    * @param bytes _extraData - data to send to another contract\n', '    * > this may be used to convert pre-ICO tokens to ICO tokens\n', '    */\n', '    function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){\n', '\n', '        transferFrom(msg.sender, _to, _value);\n', '\n', '        tokenRecipient receiver = tokenRecipient(_to);\n', '\n', '        if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\n', '            emit DataSentToAnotherContract(msg.sender, _to, _extraData);\n', '            return true;\n', '        }\n', '        else return false;\n', '    }\n', '\n', '    // for example for conveting ALL tokens of user account to another tokens\n', '    function transferAllAndCall(address _to, bytes memory _extraData) public returns (bool success){\n', '        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\n', '    }\n', '\n', '    /* --- Administrative functions */\n', '\n', '    function changeOwner(address _newOwner) public onlyBy(owner) returns (bool success){\n', '        //\n', '        require(_newOwner != address(0));\n', '\n', '        address oldOwner = owner;\n', '        owner = _newOwner;\n', '\n', '        emit OwnerChanged(oldOwner, _newOwner);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* ---------- Create and sell tokens  */\n', '\n', '    /* set time for start and time for end pre-ICO\n', '    * time is integer representing block timestamp\n', '    * in UNIX Time,\n', '    * see: https://www.epochconverter.com\n', '    * @param uint256 startTime - time to start\n', '    * @param uint256 endTime - time to end\n', '    * should be taken into account that\n', '    * "block.timestamp" can be influenced by miners to a certain degree.\n', '    * That means that a miner can "choose" the block.timestamp, to a certain degree,\n', '    * to change the outcome of a transaction in the mined block.\n', '    * see:\n', '    * http://solidity.readthedocs.io/en/v0.4.15/frequently-asked-questions.html#are-timestamps-now-block-timestamp-reliable\n', '    */\n', '\n', '    function startSale(uint256 _startUnixTime, uint256 _endUnixTime) public onlyBy(owner) returns (bool success){\n', '\n', '        require(balanceOf[address(this)] > 0);\n', '        require(salesCounter < maxSalesAllowed);\n', '\n', '        // time for sale can be set only if:\n', '        // this is first sale (saleStartUnixTime == 0 && saleEndUnixTime == 0) , or:\n', '        // previous sale finished ( saleIsFinished() )\n', '        require(\n', '        (saleStartUnixTime == 0 && saleEndUnixTime == 0) || saleIsFinished()\n', '        );\n', '        // time can be set only for future\n', '        require(_startUnixTime > now && _endUnixTime > now);\n', '        // end time should be later than start time\n', '        require(_endUnixTime - _startUnixTime > 0);\n', '\n', '        saleStartUnixTime = _startUnixTime;\n', '        saleEndUnixTime = _endUnixTime;\n', '        salesCounter = salesCounter + 1;\n', '\n', '        emit SaleStarted(_startUnixTime, _endUnixTime, salesCounter);\n', '\n', '        return true;\n', '    }\n', '\n', '    function saleIsRunning() public view returns (bool){\n', '\n', '        if (balanceOf[address(this)] == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (saleStartUnixTime == 0 && saleEndUnixTime == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (now > saleStartUnixTime && now < saleEndUnixTime) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function saleIsFinished() public view returns (bool){\n', '\n', '        if (balanceOf[address(this)] == 0) {\n', '            return true;\n', '        }\n', '\n', '        else if (\n', '        (saleStartUnixTime > 0 && saleEndUnixTime > 0)\n', '        && now > saleEndUnixTime) {\n', '\n', '            return true;\n', '        }\n', '\n', '        // <<<\n', '        return true;\n', '    }\n', '\n', '    function changePriceSetter(address _priceSetter) public onlyBy(owner) returns (bool success) {\n', '        priceSetter = _priceSetter;\n', '        return true;\n', '    }\n', '\n', '    function setMinMaxPriceInWei(uint256 _priceMinWei, uint256 _priceMaxWei) public onlyBy(owner) returns (bool success){\n', '        require(_priceMinWei >= 0 && _priceMaxWei >= 0);\n', '        priceMinWei = _priceMinWei;\n', '        priceMaxWei = _priceMaxWei;\n', '        return true;\n', '    }\n', '\n', '\n', '    function setTokenPriceInWei(uint256 _priceInWei) public onlyBy(priceSetter) returns (bool success){\n', '\n', '        require(_priceInWei >= 0);\n', '\n', '        // if 0 - not set\n', '        if (priceMinWei != 0 && _priceInWei < priceMinWei) {\n', '            tokenPriceInWei = priceMinWei;\n', '        }\n', '        else if (priceMaxWei != 0 && _priceInWei > priceMaxWei) {\n', '            tokenPriceInWei = priceMaxWei;\n', '        }\n', '        else {\n', '            tokenPriceInWei = _priceInWei;\n', '        }\n', '\n', '        emit PriceChanged(tokenPriceInWei);\n', '\n', '        return true;\n', '    }\n', '\n', '    // allows sending ether and receiving tokens just using contract address\n', '    // warning:\n', "    // 'If the fallback function requires more than 2300 gas, the contract cannot receive Ether'\n", '    // see:\n', '    // https://ethereum.stackexchange.com/questions/21643/fallback-function-best-practices-when-registering-information\n', '    function() external payable {\n', '        buyTokens();\n', '    }\n', '\n', '    //\n', '    function buyTokens() public payable returns (bool success){\n', '\n', '        if (saleIsRunning() && tokenPriceInWei > 0) {\n', '\n', '            uint256 numberOfTokens = msg.value / tokenPriceInWei;\n', '\n', '            if (numberOfTokens <= balanceOf[address(this)]) {\n', '\n', '                balanceOf[msg.sender] = balanceOf[msg.sender] + numberOfTokens;\n', '                balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens;\n', '\n', '                emit NewTokensSold(numberOfTokens, msg.sender, tokenPriceInWei);\n', '\n', '                return true;\n', '            }\n', '            else {\n', '                // (payable)\n', '                revert();\n', '            }\n', '        }\n', '        else {\n', '            // (payable)\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /*  After sale contract owner\n', '    *  (can be another contract or account)\n', '    *  can withdraw all collected Ether\n', '    */\n', '    function withdrawAllToOwner() public onlyBy(owner) returns (bool) {\n', '\n', '        // only after sale is finished:\n', '        require(saleIsFinished());\n', '        uint256 sumInWei = address(this).balance;\n', '\n', '        if (\n', '        // makes withdrawal and returns true or false\n', '        !msg.sender.send(address(this).balance)\n', '        ) {\n', '            return false;\n', '        }\n', '        else {\n', '            // event\n', '            emit Withdrawal(msg.sender, sumInWei);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* ---------- Referral System */\n', '\n', '    // list of registered referrers\n', '    // represented by keccak256(address) (returns bytes32)\n', '    // ! referrers can not be removed !\n', '    mapping (bytes32 => bool) private isReferrer;\n', '\n', '    uint256 private referralBonus = 0;\n', '\n', '    uint256 private referrerBonus = 0;\n', '    // tokens owned by referrers:\n', '    mapping (bytes32 => uint256) public referrerBalanceOf;\n', '\n', '    mapping (bytes32 => uint) public referrerLinkedSales;\n', '\n', '    function addReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\n', '        isReferrer[_referrer] = true;\n', '        return true;\n', '    }\n', '\n', '    function removeReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\n', '        isReferrer[_referrer] = false;\n', '        return true;\n', '    }\n', '\n', '    // bonuses are set in as integers (20%, 30%), initial 0%\n', '    function setReferralBonuses(uint256 _referralBonus, uint256 _referrerBonus) public onlyBy(owner) returns (bool success){\n', '        require(_referralBonus > 0 && _referrerBonus > 0);\n', '        referralBonus = _referralBonus;\n', '        referrerBonus = _referrerBonus;\n', '        return true;\n', '    }\n', '\n', '    function buyTokensWithReferrerAddress(address _referrer) public payable returns (bool success){\n', '\n', '        bytes32 referrer = keccak256(abi.encodePacked(_referrer));\n', '\n', '        if (saleIsRunning() && tokenPriceInWei > 0) {\n', '\n', '            if (isReferrer[referrer]) {\n', '\n', '                uint256 numberOfTokens = msg.value / tokenPriceInWei;\n', '\n', '                if (numberOfTokens <= balanceOf[address(this)]) {\n', '\n', '                    referrerLinkedSales[referrer] = referrerLinkedSales[referrer] + numberOfTokens;\n', '\n', '                    uint256 referralBonusTokens = (numberOfTokens * (100 + referralBonus) / 100) - numberOfTokens;\n', '                    uint256 referrerBonusTokens = (numberOfTokens * (100 + referrerBonus) / 100) - numberOfTokens;\n', '\n', '                    balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens - referralBonusTokens - referrerBonusTokens;\n', '\n', '                    balanceOf[msg.sender] = balanceOf[msg.sender] + (numberOfTokens + referralBonusTokens);\n', '\n', '                    referrerBalanceOf[referrer] = referrerBalanceOf[referrer] + referrerBonusTokens;\n', '\n', '                    emit NewTokensSold(numberOfTokens + referralBonusTokens, msg.sender, tokenPriceInWei);\n', '\n', '                    return true;\n', '                }\n', '                else {\n', '                    // (payable)\n', '                    revert();\n', '                }\n', '            }\n', '            else {\n', '                // (payable)\n', '                buyTokens();\n', '            }\n', '        }\n', '        else {\n', '            // (payable)\n', '            revert();\n', '        }\n', '    }\n', '\n', '    event ReferrerBonusTokensTaken(address referrer, uint256 bonusTokensValue);\n', '\n', '    function getReferrerBonusTokens() public returns (bool success){\n', '        require(saleIsFinished());\n', '        uint256 bonusTokens = referrerBalanceOf[keccak256(abi.encodePacked(msg.sender))];\n', '        balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens;\n', '        emit ReferrerBonusTokensTaken(msg.sender, bonusTokens);\n', '        return true;\n', '    }\n', '\n', '}']