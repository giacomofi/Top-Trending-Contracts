['pragma solidity ^0.5.3;\n', '\n', '// counter.market smart contracts:\n', '//  1) Proxy - delegatecalls into current exchange code, maintains storage of exchange state\n', '//  2) Registry - stores information on the latest exchange contract version and user approvals\n', '//  3) Treasury (this one) - takes custody of funds, moves them between token accounts, authorizing exchange code via Registry\n', '\n', '// Counter contracts are deployed at predefined addresses which can be hardcoded.\n', 'contract FixedAddress {\n', '    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\n', '    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\n', '    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\n', '\n', '    function getRegistry() internal pure returns (RegistryInterface) {\n', '        return RegistryInterface(RegistryAddress);\n', '    }\n', '}\n', '\n', '// External contracts access Registry via one of these methods\n', 'interface RegistryInterface {\n', '    function getOwner() external view returns (address);\n', '    function getExchangeContract() external view returns (address);\n', '    function contractApproved(address traderAddr) external view returns (bool);\n', '    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool);\n', '    function acceptNextExchangeContract() external;\n', '}\n', '\n', '// Access modifiers on restricted Treasury methods\n', 'contract AccessModifiers is FixedAddress {\n', '\n', '    // Only the owner of the Registry contract may invoke this method.\n', '    modifier onlyRegistryOwner() {\n', '        require (msg.sender == getRegistry().getOwner(), "onlyRegistryOwner() method called by non-owner.");\n', '        _;\n', '    }\n', '\n', '    // Method should be called by the current exchange (by delegatecall from Proxy), and trader should have approved\n', '    // the latest Exchange code.\n', '    modifier onlyApprovedExchange(address trader) {\n', '        require (msg.sender == ProxyAddress, "onlyApprovedExchange() called not by exchange proxy.");\n', '        require (getRegistry().contractApproved(trader), "onlyApprovedExchange() requires approval of the latest contract code by trader.");\n', '        _;\n', '    }\n', '\n', '    // The same as above, but checks approvals of two traders simultaneously.\n', '    modifier onlyApprovedExchangeBoth(address trader1, address trader2) {\n', '        require (msg.sender == ProxyAddress, "onlyApprovedExchange() called not by exchange proxy.");\n', '        require (getRegistry().contractApprovedBoth(trader1, trader2), "onlyApprovedExchangeBoth() requires approval of the latest contract code by both traders.");\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '// External contracts access Treasury via one of these methods\n', 'interface TreasuryInterface {\n', '    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external;\n', '    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external;\n', '    function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external;\n', '    function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external;\n', '    function exchangeTokens(uint16 tokenCode1, uint16 tokenCode2, address addr1, address addr2, address addrFee, uint amount1, uint fee1, uint amount2, uint fee2) external;\n', '}\n', '\n', '// Treasury responsibilities:\n', '//  - storing the mapping of token codes to token contract addresses\n', '//  - processing deposits to/withdrawals from/transfers between token accounts within itself\n', '//  - processing emergency releases\n', '\n', '// Treasury is required because Counter is not a wallet-to-wallet exchange, and requires deposits and\n', '// withdrawals in order to be able to trade. Having full control over settlement order enables Counter\n', '// to be responsive on its UI by settling trades and withdrawals in background. The former\n', '// operations are authorized by ECDSA signatures collected from users and effected on-chain by the\n', '// Counter arbiter services.\n', '\n', '// Because user signatures are effected on the contract via an intermediary (the Counter arbiter),\n', '// there is inherent trust issue where a trader may assume that the Counter may refuse to apply some\n', '// operations on-chain (especially withdrawals), or may simply experience prolonged downtime. Hence\n', '// the need for the emergency release (ER) feature, which is an ability to withdraw funds from Counter\n', '// directly. It works as follows:\n', '//  1) any trader may initiate a cooldown of two days for all token accounts of the same address\n', '//  2) this cooldown is reset by invoking withdrawal or exchange on this address - these are the\n', '//     operations which require explicit consent in the form of digital signature and thus mean\n', '//     that a) exchange is operational b) the user trusts it\n', '//  3) in case the cooldown have not been reset by any means within two day period, the user may withdraw\n', '//     the entirety of their funds from Treasury.\n', '//\n', '// A note should be made regarding 2) - Counter does _not_ have an ability to reset the ER cooldown\n', '// arbitrarily long, as trade signatures contain an explicit expiration date, and withdrawals have a\n', '// nonce which makes them eligible to be applied once.\n', '\n', 'contract Treasury is AccessModifiers, TreasuryInterface {\n', '    // *** Constants.\n', '\n', '    uint constant EMERGENCY_RELEASE_CHALLENGE_PERIOD = 2 days;\n', '\n', '    // *** Variables.\n', '\n', '    // Treasury can be "paused" by the registry owner to effectively freeze fund movement\n', '    // (sans emergency releases).\n', '    bool active = false;\n', '\n', '    // Mapping from token codes (uint16) into corresponding ERC-20 contract addresses.\n', '    // Each token code can only be assigned once for security reasons. Token code 0 is\n', '    // always Ether.\n', '    mapping (uint16 => address) public tokenContracts;\n', '\n', '    // Balance of a specific token account, in lowest denomination (wei for Ether).\n', '    // uint176 key is composite of u16 token code (bits 160..175) and address (bits 0..159).\n', '    mapping (uint176 => uint) public tokenAmounts;\n', '\n', '    // *** Events\n', '\n', '    event SetActive(bool active);\n', '    event ChangeTokenInfo(uint16 tokenCode, address tokenContract);\n', '    event StartEmergencyRelease(address account);\n', '    event Deposit(uint16 tokenCode, address account, uint amount);\n', '    event Withdrawal(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount);\n', '    event EmergencyRelease(uint16 tokenCode, address account, uint amount);\n', '\n', '    // Emergency release status for an address (_not_ for the token account):\n', '    //     == 0 - escape release challenge inactive\n', '    //     != 0 - timestamp after which ER can be executed\n', '    mapping (address => uint) public emergencyReleaseSince;\n', '\n', '    // *** Constructor\n', '\n', '    constructor () public {\n', '    }\n', '\n', '    // *** Modifiers\n', '\n', '    modifier onlyActive() {\n', '        require (active, "Inactive treasury only allows withdrawals.");\n', '        _;\n', '    }\n', '\n', '    modifier emergencyReleasePossible(address trader) {\n', '        uint deadline = emergencyReleaseSince[trader];\n', '        require (deadline > 0 && block.timestamp > deadline, "Challenge should be active and deadline expired.");\n', '        _;\n', '    }\n', '\n', '    // *** Admin methods (mostly self-explanatory)\n', '\n', '    function setActive(bool _active) external onlyRegistryOwner() {\n', '        active = _active;\n', '\n', '        emit SetActive(active);\n', '    }\n', '\n', '    function changeTokenInfo(uint16 tokenCode, address tokenContract) external onlyRegistryOwner() {\n', '        require (tokenCode != 0,\n', '                 "Token code of zero is reserved for Ether.");\n', '\n', '        require (tokenContracts[tokenCode] == address(0),\n', '                 "Token contract address can be assigned only once.");\n', '\n', '        tokenContracts[tokenCode] = tokenContract;\n', '\n', '        emit ChangeTokenInfo(tokenCode, tokenContract);\n', '    }\n', '\n', '    // *** Emergency release initiation and reset\n', '\n', '    // This method is invoked by the user to start the ER cooldown\n', '    function startEmergencyRelease() external {\n', '        emergencyReleaseSince[msg.sender] = block.timestamp + EMERGENCY_RELEASE_CHALLENGE_PERIOD;\n', '\n', '        emit StartEmergencyRelease(msg.sender);\n', '    }\n', '\n', '    // This private method resets the UR cooldown for when executing successful trades/withdrawals\n', '    function resetEmergencyRelease(address traderAddr) private {\n', '        if (emergencyReleaseSince[traderAddr] != 0) {\n', '            emergencyReleaseSince[traderAddr] = 0;\n', '        }\n', '    }\n', '\n', '    // *** Fund movement methods\n', '\n', '    // * Deposits (initiated by and paid for by the trader)\n', '\n', '    function depositEther(address account) external payable {\n', '        emit Deposit(0, account, msg.value);\n', '\n', '        addBalance(0, account, msg.value);\n', '    }\n', '\n', '    function depositERC20Token(uint176 tokenAccount, uint amount) external {\n', '        uint16 tokenCode = uint16(tokenAccount >> 160);\n', '        address tokenContract = tokenContracts[tokenCode];\n', '\n', '        require (tokenContract != address(0), "Registered token contract.");\n', '\n', '        // Need a preliminary .approve() call\n', '        require (safeTransferFrom(tokenContract, msg.sender, address(this), amount),\n', '                 "Could not transfer ERC-20 tokens using transferFrom.");\n', '\n', '        address account = address(tokenAccount);\n', '        emit Deposit(tokenCode, account, amount);\n', '\n', '        addBalance(tokenCode, account, amount);\n', '    }\n', '\n', '    // * Emergency release (initiated by and paid for by the trader)\n', '\n', '    function emergencyReleaseEther() external emergencyReleasePossible(msg.sender) {\n', '        uint amount = deductFullBalance(0, msg.sender);\n', '\n', '        emit EmergencyRelease(0, msg.sender, amount);\n', '\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function emergencyReleaseERC20Token(uint16 tokenCode) external emergencyReleasePossible(msg.sender) {\n', '        uint amount = deductFullBalance(tokenCode, msg.sender);\n', '\n', '        emit EmergencyRelease(tokenCode, msg.sender, amount);\n', '\n', '        address tokenContract = tokenContracts[tokenCode];\n', '        require (tokenContract != address(0), "Registered token contract.");\n', '\n', '        require (safeTransfer(tokenContract, msg.sender, amount),\n', '                 "Could not transfer ERC-20 tokens using transfer.");\n', '    }\n', '\n', '    // * Regular withdrawal (authorized by the trader, initiated and paid for by Counter)\n', '    //   Requires trader approval of exchange contract.\n', '    //   Resets ER.\n', '\n', '    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external\n', '        onlyActive()\n', '        onlyApprovedExchange(traderAddr) {\n', '\n', '        deductBalance(0, traderAddr, amount);\n', '        resetEmergencyRelease(traderAddr);\n', '\n', '        emit Withdrawal(0, traderAddr, withdrawalAddr, amount);\n', '\n', '        withdrawalAddr.transfer(amount);\n', '    }\n', '\n', '    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external\n', '        onlyActive()\n', '        onlyApprovedExchange(traderAddr) {\n', '\n', '        deductBalance(tokenCode, traderAddr, amount);\n', '        resetEmergencyRelease(traderAddr);\n', '\n', '        address tokenContract = tokenContracts[tokenCode];\n', '        require (tokenContract != address(0), "Registered token contract.");\n', '\n', '        require (safeTransfer(tokenContract, withdrawalAddr, amount),\n', '                 "Could not transfer ERC-20 tokens using transfer.");\n', '\n', '        emit Withdrawal(tokenCode, traderAddr, withdrawalAddr, amount);\n', '    }\n', '\n', '    // * Funds transfer between token accounts within Treasury\n', '    //   Initiated and paid for by Counter as part of trade or withdrawal fee collection.\n', '    //   Requires trader approval of exchange contract.\n', '    //   There are three specializations to save gas on inter-contract method calls.\n', '    //   Resets ER.\n', '\n', '    // Case 1 - transfer tokens from one account to another\n', '    // Example usecase: withdrawal fee collection\n', '    function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external\n', '        onlyActive() onlyApprovedExchange(fromAddr) {\n', '\n', '        resetEmergencyRelease(fromAddr);\n', '\n', '        deductBalance(tokenCode, fromAddr, amount);\n', '        addBalance(tokenCode, toAddr, amount);\n', '    }\n', '\n', '    // Case 2 - transfer tokens from one account to two accounts, splitting arbitrarily.\n', '    function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external\n', '        onlyActive() onlyApprovedExchange(fromAddr) {\n', '\n', '        resetEmergencyRelease(fromAddr);\n', '\n', '        deductBalance(tokenCode, fromAddr, amount1 + amount2);\n', '\n', '        addBalance(tokenCode, toAddr1, amount1);\n', '        addBalance(tokenCode, toAddr2, amount2);\n', '    }\n', '\n', '    // Case 3 - transfer tokens of one type from A to B, tokens of another type from B to A,\n', '    //          and deduct a fee from both transfers to a third account C.\n', '    // Example usecase: any trade on Counter\n', '    function exchangeTokens(\n', '        uint16 tokenCode1, uint16 tokenCode2,\n', '        address addr1, address addr2, address addrFee,\n', '        uint amount1, uint fee1,\n', '        uint amount2, uint fee2) external onlyActive() onlyApprovedExchangeBoth(addr1, addr2) {\n', '\n', '        resetEmergencyRelease(addr1);\n', '        resetEmergencyRelease(addr2);\n', '\n', '        deductBalance(tokenCode1, addr1, amount1 + fee1);\n', '        deductBalance(tokenCode2, addr2, amount2 + fee2);\n', '\n', '        addBalance(tokenCode1, addr2, amount1);\n', '        addBalance(tokenCode2, addr1, amount2);\n', '        addBalance(tokenCode1, addrFee, fee1);\n', '        addBalance(tokenCode2, addrFee, fee2);\n', '    }\n', '\n', '    // * Token account balance management routines.\n', '    //   Construct uint176 ids, check for over- and underflows.\n', '\n', '    function deductBalance(uint tokenCode, address addr, uint amount) private {\n', '        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\n', '        uint before = tokenAmounts[tokenAccount];\n', '        require (before >= amount, "Enough funds.");\n', '        tokenAmounts[tokenAccount] = before - amount;\n', '    }\n', '\n', '    function deductFullBalance(uint tokenCode, address addr) private returns (uint amount) {\n', '        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\n', '        amount = tokenAmounts[tokenAccount];\n', '        tokenAmounts[tokenAccount] = 0;\n', '    }\n', '\n', '    function addBalance(uint tokenCode, address addr, uint amount) private {\n', '        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\n', '        uint before = tokenAmounts[tokenAccount];\n', '        require (before + amount >= before, "No overflow.");\n', '        tokenAmounts[tokenAccount] = before + amount;\n', '    }\n', '\n', '    // * Safe ERC-20 transfer() and transferFrom() invocations\n', '    //   Work correctly with those tokens that do not return (bool success) and thus are not\n', '    //   strictly speaking ERC-20 compatible, but unfortunately are quite widespread.\n', '\n', '    function safeTransfer(address tokenContract, address to, uint value) internal returns (bool success)\n', '    {\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '\n', '        success = false;\n', '\n', '        if (call_success) {\n', '            if (return_data.length == 0) {\n', "                // transfer() doesn't have a return value\n", '                success = true;\n', '\n', '            } else if (return_data.length == 32) {\n', '                // check returned bool\n', '                assembly { success := mload(add(return_data, 0x20)) }\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '    function safeTransferFrom(address tokenContract, address from, address to, uint value) internal returns (bool success)\n', '    {\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '\n', '        success = false;\n', '\n', '        if (call_success) {\n', '            if (return_data.length == 0) {\n', '                success = true;\n', '\n', '            } else if (return_data.length == 32) {\n', '                assembly { success := mload(add(return_data, 0x20)) }\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '}']