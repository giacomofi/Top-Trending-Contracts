['/*\n', '\n', '    Copyright 2019 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: canonical-weth/contracts/WETH9.sol\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() external payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        emit Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Require.sol\n', '\n', '/**\n', ' * @title Require\n', ' * @author dYdX\n', ' *\n', ' * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\n', ' */\n', 'library Require {\n', '\n', '    // ============ Constants ============\n', '\n', "    uint256 constant ASCII_ZERO = 48; // '0'\n", "    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\n", "    uint256 constant ASCII_LOWER_EX = 120; // 'x'\n", "    bytes2 constant COLON = 0x3a20; // ': '\n", "    bytes2 constant COMMA = 0x2c20; // ', '\n", "    bytes2 constant LPAREN = 0x203c; // ' <'\n", "    byte constant RPAREN = 0x3e; // '>'\n", '    uint256 constant FOUR_BIT_MASK = 0xf;\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason)\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        uint256 payloadA\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        uint256 payloadA,\n', '        uint256 payloadB\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA,\n', '        uint256 payloadB\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA,\n', '        uint256 payloadB,\n', '        uint256 payloadC\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringify(file),\n', '                        COLON,\n', '                        stringify(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        COMMA,\n', '                        stringify(payloadC),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function stringify(\n', '        bytes32 input\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        // put the input bytes into the result\n', '        bytes memory result = abi.encodePacked(input);\n', '\n', '        // determine the length of the input by finding the location of the last non-zero byte\n', '        for (uint256 i = 32; i > 0; ) {\n', '            // reverse-for-loops with unsigned integer\n', '            /* solium-disable-next-line security/no-modify-for-iter-var */\n', '            i--;\n', '\n', '            // find the last non-zero byte in order to determine the length\n', '            if (result[i] != 0) {\n', '                uint256 length = i + 1;\n', '\n', '                /* solium-disable-next-line security/no-inline-assembly */\n', '                assembly {\n', '                    mstore(result, length) // r.length = length;\n', '                }\n', '\n', '                return result;\n', '            }\n', '        }\n', '\n', '        // all bytes are zero\n', '        return new bytes(0);\n', '    }\n', '\n', '    function stringify(\n', '        uint256 input\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        if (input == 0) {\n', '            return "0";\n', '        }\n', '\n', '        // get the final string length\n', '        uint256 j = input;\n', '        uint256 length;\n', '        while (j != 0) {\n', '            length++;\n', '            j /= 10;\n', '        }\n', '\n', '        // allocate the string\n', '        bytes memory bstr = new bytes(length);\n', '\n', '        // populate the string starting with the least-significant character\n', '        j = input;\n', '        for (uint256 i = length; i > 0; ) {\n', '            // reverse-for-loops with unsigned integer\n', '            /* solium-disable-next-line security/no-modify-for-iter-var */\n', '            i--;\n', '\n', '            // take last decimal digit\n', '            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\n', '\n', '            // remove the last decimal digit\n', '            j /= 10;\n', '        }\n', '\n', '        return bstr;\n', '    }\n', '\n', '    function stringify(\n', '        address input\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        uint256 z = uint256(input);\n', '\n', '        // addresses are "0x" followed by 20 bytes of data which take up 2 characters each\n', '        bytes memory result = new bytes(42);\n', '\n', '        // populate the result with "0x"\n', '        result[0] = byte(uint8(ASCII_ZERO));\n', '        result[1] = byte(uint8(ASCII_LOWER_EX));\n', '\n', '        // for each byte (starting from the lowest byte), populate the result with two characters\n', '        for (uint256 i = 0; i < 20; i++) {\n', '            // each byte takes two characters\n', '            uint256 shift = i * 2;\n', '\n', '            // populate the least-significant character\n', '            result[41 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '\n', '            // populate the most-significant character\n', '            result[40 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function char(\n', '        uint256 input\n', '    )\n', '        private\n', '        pure\n', '        returns (byte)\n', '    {\n', '        // return ASCII digit (0-9)\n', '        if (input < 10) {\n', '            return byte(uint8(input + ASCII_ZERO));\n', '        }\n', '\n', '        // return ASCII letter (a-f)\n', '        return byte(uint8(input + ASCII_RELATIVE_ZERO));\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @author dYdX\n', ' *\n', ' * Library for non-standard Math functions\n', ' */\n', 'library Math {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Math";\n', '\n', '    // ============ Library Functions ============\n', '\n', '    /*\n', '     * Return target * (numerator / denominator).\n', '     */\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    /*\n', '     * Return target * (numerator / denominator), but rounded up.\n', '     */\n', '    function getPartialRoundUp(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (target == 0 || numerator == 0) {\n', '            // SafeMath will check for zero denominator\n', '            return SafeMath.div(0, denominator);\n', '        }\n', '        return target.mul(numerator).sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    function to128(\n', '        uint256 number\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint128)\n', '    {\n', '        uint128 result = uint128(number);\n', '        Require.that(\n', '            result == number,\n', '            FILE,\n', '            "Unsafe cast to uint128"\n', '        );\n', '        return result;\n', '    }\n', '\n', '    function to96(\n', '        uint256 number\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint96)\n', '    {\n', '        uint96 result = uint96(number);\n', '        Require.that(\n', '            result == number,\n', '            FILE,\n', '            "Unsafe cast to uint96"\n', '        );\n', '        return result;\n', '    }\n', '\n', '    function to32(\n', '        uint256 number\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        uint32 result = uint32(number);\n', '        Require.that(\n', '            result == number,\n', '            FILE,\n', '            "Unsafe cast to uint32"\n', '        );\n', '        return result;\n', '    }\n', '\n', '    function min(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Types.sol\n', '\n', '/**\n', ' * @title Types\n', ' * @author dYdX\n', ' *\n', ' * Library for interacting with the basic structs used in Solo\n', ' */\n', 'library Types {\n', '    using Math for uint256;\n', '\n', '    // ============ AssetAmount ============\n', '\n', '    enum AssetDenomination {\n', '        Wei, // the amount is denominated in wei\n', '        Par  // the amount is denominated in par\n', '    }\n', '\n', '    enum AssetReference {\n', '        Delta, // the amount is given as a delta from the current value\n', '        Target // the amount is given as an exact number to end up at\n', '    }\n', '\n', '    struct AssetAmount {\n', '        bool sign; // true if positive\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Par (Principal Amount) ============\n', '\n', '    // Total borrow and supply values for a market\n', '    struct TotalPar {\n', '        uint128 borrow;\n', '        uint128 supply;\n', '    }\n', '\n', '    // Individual principal amount for an account\n', '    struct Par {\n', '        bool sign; // true if positive\n', '        uint128 value;\n', '    }\n', '\n', '    function zeroPar()\n', '        internal\n', '        pure\n', '        returns (Par memory)\n', '    {\n', '        return Par({\n', '            sign: false,\n', '            value: 0\n', '        });\n', '    }\n', '\n', '    function sub(\n', '        Par memory a,\n', '        Par memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Par memory)\n', '    {\n', '        return add(a, negative(b));\n', '    }\n', '\n', '    function add(\n', '        Par memory a,\n', '        Par memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Par memory)\n', '    {\n', '        Par memory result;\n', '        if (a.sign == b.sign) {\n', '            result.sign = a.sign;\n', '            result.value = SafeMath.add(a.value, b.value).to128();\n', '        } else {\n', '            if (a.value >= b.value) {\n', '                result.sign = a.sign;\n', '                result.value = SafeMath.sub(a.value, b.value).to128();\n', '            } else {\n', '                result.sign = b.sign;\n', '                result.value = SafeMath.sub(b.value, a.value).to128();\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function equals(\n', '        Par memory a,\n', '        Par memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if (a.value == b.value) {\n', '            if (a.value == 0) {\n', '                return true;\n', '            }\n', '            return a.sign == b.sign;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function negative(\n', '        Par memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (Par memory)\n', '    {\n', '        return Par({\n', '            sign: !a.sign,\n', '            value: a.value\n', '        });\n', '    }\n', '\n', '    function isNegative(\n', '        Par memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return !a.sign && a.value > 0;\n', '    }\n', '\n', '    function isPositive(\n', '        Par memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return a.sign && a.value > 0;\n', '    }\n', '\n', '    function isZero(\n', '        Par memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return a.value == 0;\n', '    }\n', '\n', '    // ============ Wei (Token Amount) ============\n', '\n', '    // Individual token amount for an account\n', '    struct Wei {\n', '        bool sign; // true if positive\n', '        uint256 value;\n', '    }\n', '\n', '    function zeroWei()\n', '        internal\n', '        pure\n', '        returns (Wei memory)\n', '    {\n', '        return Wei({\n', '            sign: false,\n', '            value: 0\n', '        });\n', '    }\n', '\n', '    function sub(\n', '        Wei memory a,\n', '        Wei memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Wei memory)\n', '    {\n', '        return add(a, negative(b));\n', '    }\n', '\n', '    function add(\n', '        Wei memory a,\n', '        Wei memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Wei memory)\n', '    {\n', '        Wei memory result;\n', '        if (a.sign == b.sign) {\n', '            result.sign = a.sign;\n', '            result.value = SafeMath.add(a.value, b.value);\n', '        } else {\n', '            if (a.value >= b.value) {\n', '                result.sign = a.sign;\n', '                result.value = SafeMath.sub(a.value, b.value);\n', '            } else {\n', '                result.sign = b.sign;\n', '                result.value = SafeMath.sub(b.value, a.value);\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function equals(\n', '        Wei memory a,\n', '        Wei memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if (a.value == b.value) {\n', '            if (a.value == 0) {\n', '                return true;\n', '            }\n', '            return a.sign == b.sign;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function negative(\n', '        Wei memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (Wei memory)\n', '    {\n', '        return Wei({\n', '            sign: !a.sign,\n', '            value: a.value\n', '        });\n', '    }\n', '\n', '    function isNegative(\n', '        Wei memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return !a.sign && a.value > 0;\n', '    }\n', '\n', '    function isPositive(\n', '        Wei memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return a.sign && a.value > 0;\n', '    }\n', '\n', '    function isZero(\n', '        Wei memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return a.value == 0;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Account.sol\n', '\n', '/**\n', ' * @title Account\n', ' * @author dYdX\n', ' *\n', ' * Library of structs and functions that represent an account\n', ' */\n', 'library Account {\n', '    // ============ Enums ============\n', '\n', '    /*\n', '     * Most-recently-cached account status.\n', '     *\n', '     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\n', '     * Liquid: Can be liquidated no matter the account values.\n', '     *         Can be vaporized if there are no more positive account values.\n', '     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\n', '     *\n', '     */\n', '    enum Status {\n', '        Normal,\n', '        Liquid,\n', '        Vapor\n', '    }\n', '\n', '    // ============ Structs ============\n', '\n', '    // Represents the unique key that specifies an account\n', '    struct Info {\n', '        address owner;  // The address that owns the account\n', '        uint256 number; // A nonce that allows a single address to control many accounts\n', '    }\n', '\n', '    // The complete storage for any account\n', '    struct Storage {\n', '        mapping (uint256 => Types.Par) balances; // Mapping from marketId to principal\n', '        Status status;\n', '    }\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function equals(\n', '        Info memory a,\n', '        Info memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return a.owner == b.owner && a.number == b.number;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Monetary.sol\n', '\n', '/**\n', ' * @title Monetary\n', ' * @author dYdX\n', ' *\n', ' * Library for types involving money\n', ' */\n', 'library Monetary {\n', '\n', '    /*\n', '     * The price of a base-unit of an asset.\n', '     */\n', '    struct Price {\n', '        uint256 value;\n', '    }\n', '\n', '    /*\n', '     * Total value of an some amount of an asset. Equal to (price * amount).\n', '     */\n', '    struct Value {\n', '        uint256 value;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Cache.sol\n', '\n', '/**\n', ' * @title Cache\n', ' * @author dYdX\n', ' *\n', ' * Library for caching information about markets\n', ' */\n', 'library Cache {\n', '    using Cache for MarketCache;\n', '    using Storage for Storage.State;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct MarketInfo {\n', '        bool isClosing;\n', '        uint128 borrowPar;\n', '        Monetary.Price price;\n', '    }\n', '\n', '    struct MarketCache {\n', '        MarketInfo[] markets;\n', '    }\n', '\n', '    // ============ Setter Functions ============\n', '\n', '    /**\n', '     * Initialize an empty cache for some given number of total markets.\n', '     */\n', '    function create(\n', '        uint256 numMarkets\n', '    )\n', '        internal\n', '        pure\n', '        returns (MarketCache memory)\n', '    {\n', '        return MarketCache({\n', '            markets: new MarketInfo[](numMarkets)\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Add market information (price and total borrowed par if the market is closing) to the cache.\n', '     * Return true if the market information did not previously exist in the cache.\n', '     */\n', '    function addMarket(\n', '        MarketCache memory cache,\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (cache.hasMarket(marketId)) {\n', '            return false;\n', '        }\n', '        cache.markets[marketId].price = state.fetchPrice(marketId);\n', '        if (state.markets[marketId].isClosing) {\n', '            cache.markets[marketId].isClosing = true;\n', '            cache.markets[marketId].borrowPar = state.getTotalPar(marketId).borrow;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // ============ Getter Functions ============\n', '\n', '    function getNumMarkets(\n', '        MarketCache memory cache\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return cache.markets.length;\n', '    }\n', '\n', '    function hasMarket(\n', '        MarketCache memory cache,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return cache.markets[marketId].price.value != 0;\n', '    }\n', '\n', '    function getIsClosing(\n', '        MarketCache memory cache,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return cache.markets[marketId].isClosing;\n', '    }\n', '\n', '    function getPrice(\n', '        MarketCache memory cache,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        pure\n', '        returns (Monetary.Price memory)\n', '    {\n', '        return cache.markets[marketId].price;\n', '    }\n', '\n', '    function getBorrowPar(\n', '        MarketCache memory cache,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint128)\n', '    {\n', '        return cache.markets[marketId].borrowPar;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Decimal.sol\n', '\n', '/**\n', ' * @title Decimal\n', ' * @author dYdX\n', ' *\n', ' * Library that defines a fixed-point number with 18 decimal places.\n', ' */\n', 'library Decimal {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function one()\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: BASE });\n', '    }\n', '\n', '    function onePlus(\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: d.value.add(BASE) });\n', '    }\n', '\n', '    function mul(\n', '        uint256 target,\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, d.value, BASE);\n', '    }\n', '\n', '    function div(\n', '        uint256 target,\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, BASE, d.value);\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Time.sol\n', '\n', '/**\n', ' * @title Time\n', ' * @author dYdX\n', ' *\n', ' * Library for dealing with time, assuming timestamps fit within 32 bits (valid until year 2106)\n', ' */\n', 'library Time {\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function currentTime()\n', '        internal\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return Math.to32(block.timestamp);\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Interest.sol\n', '\n', '/**\n', ' * @title Interest\n', ' * @author dYdX\n', ' *\n', ' * Library for managing the interest rate and interest indexes of Solo\n', ' */\n', 'library Interest {\n', '    using Math for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Interest";\n', '    uint64 constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Rate {\n', '        uint256 value;\n', '    }\n', '\n', '    struct Index {\n', '        uint96 borrow;\n', '        uint96 supply;\n', '        uint32 lastUpdate;\n', '    }\n', '\n', '    // ============ Library Functions ============\n', '\n', '    /**\n', '     * Get a new market Index based on the old index and market interest rate.\n', '     * Calculate interest for borrowers by using the formula rate * time. Approximates\n', '     * continuously-compounded interest when called frequently, but is much more\n', '     * gas-efficient to calculate. For suppliers, the interest rate is adjusted by the earningsRate,\n', '     * then prorated the across all suppliers.\n', '     *\n', '     * @param  index         The old index for a market\n', '     * @param  rate          The current interest rate of the market\n', '     * @param  totalPar      The total supply and borrow par values of the market\n', '     * @param  earningsRate  The portion of the interest that is forwarded to the suppliers\n', '     * @return               The updated index for a market\n', '     */\n', '    function calculateNewIndex(\n', '        Index memory index,\n', '        Rate memory rate,\n', '        Types.TotalPar memory totalPar,\n', '        Decimal.D256 memory earningsRate\n', '    )\n', '        internal\n', '        view\n', '        returns (Index memory)\n', '    {\n', '        (\n', '            Types.Wei memory supplyWei,\n', '            Types.Wei memory borrowWei\n', '        ) = totalParToWei(totalPar, index);\n', '\n', '        // get interest increase for borrowers\n', '        uint32 currentTime = Time.currentTime();\n', '        uint256 borrowInterest = rate.value.mul(uint256(currentTime).sub(index.lastUpdate));\n', '\n', '        // get interest increase for suppliers\n', '        uint256 supplyInterest;\n', '        if (Types.isZero(supplyWei)) {\n', '            supplyInterest = 0;\n', '        } else {\n', '            supplyInterest = Decimal.mul(borrowInterest, earningsRate);\n', '            if (borrowWei.value < supplyWei.value) {\n', '                supplyInterest = Math.getPartial(supplyInterest, borrowWei.value, supplyWei.value);\n', '            }\n', '        }\n', '        assert(supplyInterest <= borrowInterest);\n', '\n', '        return Index({\n', '            borrow: Math.getPartial(index.borrow, borrowInterest, BASE).add(index.borrow).to96(),\n', '            supply: Math.getPartial(index.supply, supplyInterest, BASE).add(index.supply).to96(),\n', '            lastUpdate: currentTime\n', '        });\n', '    }\n', '\n', '    function newIndex()\n', '        internal\n', '        view\n', '        returns (Index memory)\n', '    {\n', '        return Index({\n', '            borrow: BASE,\n', '            supply: BASE,\n', '            lastUpdate: Time.currentTime()\n', '        });\n', '    }\n', '\n', '    /*\n', '     * Convert a principal amount to a token amount given an index.\n', '     */\n', '    function parToWei(\n', '        Types.Par memory input,\n', '        Index memory index\n', '    )\n', '        internal\n', '        pure\n', '        returns (Types.Wei memory)\n', '    {\n', '        uint256 inputValue = uint256(input.value);\n', '        if (input.sign) {\n', '            return Types.Wei({\n', '                sign: true,\n', '                value: inputValue.getPartial(index.supply, BASE)\n', '            });\n', '        } else {\n', '            return Types.Wei({\n', '                sign: false,\n', '                value: inputValue.getPartialRoundUp(index.borrow, BASE)\n', '            });\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Convert a token amount to a principal amount given an index.\n', '     */\n', '    function weiToPar(\n', '        Types.Wei memory input,\n', '        Index memory index\n', '    )\n', '        internal\n', '        pure\n', '        returns (Types.Par memory)\n', '    {\n', '        if (input.sign) {\n', '            return Types.Par({\n', '                sign: true,\n', '                value: input.value.getPartial(BASE, index.supply).to128()\n', '            });\n', '        } else {\n', '            return Types.Par({\n', '                sign: false,\n', '                value: input.value.getPartialRoundUp(BASE, index.borrow).to128()\n', '            });\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Convert the total supply and borrow principal amounts of a market to total supply and borrow\n', '     * token amounts.\n', '     */\n', '    function totalParToWei(\n', '        Types.TotalPar memory totalPar,\n', '        Index memory index\n', '    )\n', '        internal\n', '        pure\n', '        returns (Types.Wei memory, Types.Wei memory)\n', '    {\n', '        Types.Par memory supplyPar = Types.Par({\n', '            sign: true,\n', '            value: totalPar.supply\n', '        });\n', '        Types.Par memory borrowPar = Types.Par({\n', '            sign: false,\n', '            value: totalPar.borrow\n', '        });\n', '        Types.Wei memory supplyWei = parToWei(supplyPar, index);\n', '        Types.Wei memory borrowWei = parToWei(borrowPar, index);\n', '        return (supplyWei, borrowWei);\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/interfaces/IErc20.sol\n', '\n', '/**\n', ' * @title IErc20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', " * that we don't automatically revert when calling non-compliant tokens that have no return value for\n", ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface IErc20 {\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function name()\n', '        external\n', '        view\n', '        returns (string memory);\n', '\n', '    function symbol()\n', '        external\n', '        view\n', '        returns (string memory);\n', '\n', '    function decimals()\n', '        external\n', '        view\n', '        returns (uint8);\n', '}\n', '\n', '// File: contracts/protocol/lib/Token.sol\n', '\n', '/**\n', ' * @title Token\n', ' * @author dYdX\n', ' *\n', ' * This library contains basic functions for interacting with ERC20 tokens. Modified to work with\n', " * tokens that don't adhere strictly to the ERC20 standard (for example tokens that don't return a\n", ' * boolean value on success).\n', ' */\n', 'library Token {\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Token";\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IErc20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IErc20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        IErc20(token).approve(spender, amount);\n', '\n', '        Require.that(\n', '            checkSuccess(),\n', '            FILE,\n', '            "Approve failed"\n', '        );\n', '    }\n', '\n', '    function approveMax(\n', '        address token,\n', '        address spender\n', '    )\n', '        internal\n', '    {\n', '        approve(\n', '            token,\n', '            spender,\n', '            uint256(-1)\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (amount == 0 || to == address(this)) {\n', '            return;\n', '        }\n', '\n', '        IErc20(token).transfer(to, amount);\n', '\n', '        Require.that(\n', '            checkSuccess(),\n', '            FILE,\n', '            "Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (amount == 0 || to == from) {\n', '            return;\n', '        }\n', '\n', '        IErc20(token).transferFrom(from, to, amount);\n', '\n', '        Require.that(\n', '            checkSuccess(),\n', '            FILE,\n', '            "TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * Check the return value of the previous function up to 32 bytes. Return true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', "            // not sure what was returned: don't mark as success\n", '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/interfaces/IInterestSetter.sol\n', '\n', '/**\n', ' * @title IInterestSetter\n', ' * @author dYdX\n', ' *\n', ' * Interface that Interest Setters for Solo must implement in order to report interest rates.\n', ' */\n', 'interface IInterestSetter {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Get the interest rate of a token given some borrowed and supplied amounts\n', '     *\n', '     * @param  token        The address of the ERC20 token for the market\n', '     * @param  borrowWei    The total borrowed token amount for the market\n', '     * @param  supplyWei    The total supplied token amount for the market\n', '     * @return              The interest rate per second\n', '     */\n', '    function getInterestRate(\n', '        address token,\n', '        uint256 borrowWei,\n', '        uint256 supplyWei\n', '    )\n', '        external\n', '        view\n', '        returns (Interest.Rate memory);\n', '}\n', '\n', '// File: contracts/protocol/interfaces/IPriceOracle.sol\n', '\n', '/**\n', ' * @title IPriceOracle\n', ' * @author dYdX\n', ' *\n', ' * Interface that Price Oracles for Solo must implement in order to report prices.\n', ' */\n', 'contract IPriceOracle {\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 public constant ONE_DOLLAR = 10 ** 36;\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Get the price of a token\n', '     *\n', '     * @param  token  The ERC20 token address of the market\n', '     * @return        The USD price of a base unit of the token, then multiplied by 10^36.\n', '     *                So a USD-stable coin with 18 decimal places would return 10^18.\n', '     *                This is the price of the base unit rather than the price of a "human-readable"\n', '     *                token amount. Every ERC20 may have a different number of decimals.\n', '     */\n', '    function getPrice(\n', '        address token\n', '    )\n', '        public\n', '        view\n', '        returns (Monetary.Price memory);\n', '}\n', '\n', '// File: contracts/protocol/lib/Storage.sol\n', '\n', '/**\n', ' * @title Storage\n', ' * @author dYdX\n', ' *\n', ' * Functions for reading, writing, and verifying state in Solo\n', ' */\n', 'library Storage {\n', '    using Cache for Cache.MarketCache;\n', '    using Storage for Storage.State;\n', '    using Math for uint256;\n', '    using Types for Types.Par;\n', '    using Types for Types.Wei;\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Storage";\n', '\n', '    // ============ Structs ============\n', '\n', '    // All information necessary for tracking a market\n', '    struct Market {\n', '        // Contract address of the associated ERC20 token\n', '        address token;\n', '\n', '        // Total aggregated supply and borrow amount of the entire market\n', '        Types.TotalPar totalPar;\n', '\n', '        // Interest index of the market\n', '        Interest.Index index;\n', '\n', '        // Contract address of the price oracle for this market\n', '        IPriceOracle priceOracle;\n', '\n', '        // Contract address of the interest setter for this market\n', '        IInterestSetter interestSetter;\n', '\n', '        // Multiplier on the marginRatio for this market\n', '        Decimal.D256 marginPremium;\n', '\n', '        // Multiplier on the liquidationSpread for this market\n', '        Decimal.D256 spreadPremium;\n', '\n', '        // Whether additional borrows are allowed for this market\n', '        bool isClosing;\n', '    }\n', '\n', '    // The global risk parameters that govern the health and security of the system\n', '    struct RiskParams {\n', '        // Required ratio of over-collateralization\n', '        Decimal.D256 marginRatio;\n', '\n', '        // Percentage penalty incurred by liquidated accounts\n', '        Decimal.D256 liquidationSpread;\n', '\n', "        // Percentage of the borrower's interest fee that gets passed to the suppliers\n", '        Decimal.D256 earningsRate;\n', '\n', '        // The minimum absolute borrow value of an account\n', '        // There must be sufficient incentivize to liquidate undercollateralized accounts\n', '        Monetary.Value minBorrowedValue;\n', '    }\n', '\n', '    // The maximum RiskParam values that can be set\n', '    struct RiskLimits {\n', '        uint64 marginRatioMax;\n', '        uint64 liquidationSpreadMax;\n', '        uint64 earningsRateMax;\n', '        uint64 marginPremiumMax;\n', '        uint64 spreadPremiumMax;\n', '        uint128 minBorrowedValueMax;\n', '    }\n', '\n', '    // The entire storage state of Solo\n', '    struct State {\n', '        // number of markets\n', '        uint256 numMarkets;\n', '\n', '        // marketId => Market\n', '        mapping (uint256 => Market) markets;\n', '\n', '        // owner => account number => Account\n', '        mapping (address => mapping (uint256 => Account.Storage)) accounts;\n', '\n', '        // Addresses that can control other users accounts\n', '        mapping (address => mapping (address => bool)) operators;\n', '\n', '        // Addresses that can control all users accounts\n', '        mapping (address => bool) globalOperators;\n', '\n', '        // mutable risk parameters of the system\n', '        RiskParams riskParams;\n', '\n', '        // immutable risk limits of the system\n', '        RiskLimits riskLimits;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function getToken(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.markets[marketId].token;\n', '    }\n', '\n', '    function getTotalPar(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.TotalPar memory)\n', '    {\n', '        return state.markets[marketId].totalPar;\n', '    }\n', '\n', '    function getIndex(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Interest.Index memory)\n', '    {\n', '        return state.markets[marketId].index;\n', '    }\n', '\n', '    function getNumExcessTokens(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Wei memory)\n', '    {\n', '        Interest.Index memory index = state.getIndex(marketId);\n', '        Types.TotalPar memory totalPar = state.getTotalPar(marketId);\n', '\n', '        address token = state.getToken(marketId);\n', '\n', '        Types.Wei memory balanceWei = Types.Wei({\n', '            sign: true,\n', '            value: Token.balanceOf(token, address(this))\n', '        });\n', '\n', '        (\n', '            Types.Wei memory supplyWei,\n', '            Types.Wei memory borrowWei\n', '        ) = Interest.totalParToWei(totalPar, index);\n', '\n', '        // borrowWei is negative, so subtracting it makes the value more positive\n', '        return balanceWei.sub(borrowWei).sub(supplyWei);\n', '    }\n', '\n', '    function getStatus(\n', '        Storage.State storage state,\n', '        Account.Info memory account\n', '    )\n', '        internal\n', '        view\n', '        returns (Account.Status)\n', '    {\n', '        return state.accounts[account.owner][account.number].status;\n', '    }\n', '\n', '    function getPar(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Par memory)\n', '    {\n', '        return state.accounts[account.owner][account.number].balances[marketId];\n', '    }\n', '\n', '    function getWei(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Wei memory)\n', '    {\n', '        Types.Par memory par = state.getPar(account, marketId);\n', '\n', '        if (par.isZero()) {\n', '            return Types.zeroWei();\n', '        }\n', '\n', '        Interest.Index memory index = state.getIndex(marketId);\n', '        return Interest.parToWei(par, index);\n', '    }\n', '\n', '    function getLiquidationSpreadForPair(\n', '        Storage.State storage state,\n', '        uint256 heldMarketId,\n', '        uint256 owedMarketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        uint256 result = state.riskParams.liquidationSpread.value;\n', '        result = Decimal.mul(result, Decimal.onePlus(state.markets[heldMarketId].spreadPremium));\n', '        result = Decimal.mul(result, Decimal.onePlus(state.markets[owedMarketId].spreadPremium));\n', '        return Decimal.D256({\n', '            value: result\n', '        });\n', '    }\n', '\n', '    function fetchNewIndex(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Interest.Index memory index\n', '    )\n', '        internal\n', '        view\n', '        returns (Interest.Index memory)\n', '    {\n', '        Interest.Rate memory rate = state.fetchInterestRate(marketId, index);\n', '\n', '        return Interest.calculateNewIndex(\n', '            index,\n', '            rate,\n', '            state.getTotalPar(marketId),\n', '            state.riskParams.earningsRate\n', '        );\n', '    }\n', '\n', '    function fetchInterestRate(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Interest.Index memory index\n', '    )\n', '        internal\n', '        view\n', '        returns (Interest.Rate memory)\n', '    {\n', '        Types.TotalPar memory totalPar = state.getTotalPar(marketId);\n', '        (\n', '            Types.Wei memory supplyWei,\n', '            Types.Wei memory borrowWei\n', '        ) = Interest.totalParToWei(totalPar, index);\n', '\n', '        Interest.Rate memory rate = state.markets[marketId].interestSetter.getInterestRate(\n', '            state.getToken(marketId),\n', '            borrowWei.value,\n', '            supplyWei.value\n', '        );\n', '\n', '        return rate;\n', '    }\n', '\n', '    function fetchPrice(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        view\n', '        returns (Monetary.Price memory)\n', '    {\n', '        IPriceOracle oracle = IPriceOracle(state.markets[marketId].priceOracle);\n', '        Monetary.Price memory price = oracle.getPrice(state.getToken(marketId));\n', '        Require.that(\n', '            price.value != 0,\n', '            FILE,\n', '            "Price cannot be zero",\n', '            marketId\n', '        );\n', '        return price;\n', '    }\n', '\n', '    function getAccountValues(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        Cache.MarketCache memory cache,\n', '        bool adjustForLiquidity\n', '    )\n', '        internal\n', '        view\n', '        returns (Monetary.Value memory, Monetary.Value memory)\n', '    {\n', '        Monetary.Value memory supplyValue;\n', '        Monetary.Value memory borrowValue;\n', '\n', '        uint256 numMarkets = cache.getNumMarkets();\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (!cache.hasMarket(m)) {\n', '                continue;\n', '            }\n', '\n', '            Types.Wei memory userWei = state.getWei(account, m);\n', '\n', '            if (userWei.isZero()) {\n', '                continue;\n', '            }\n', '\n', '            uint256 assetValue = userWei.value.mul(cache.getPrice(m).value);\n', '            Decimal.D256 memory adjust = Decimal.one();\n', '            if (adjustForLiquidity) {\n', '                adjust = Decimal.onePlus(state.markets[m].marginPremium);\n', '            }\n', '\n', '            if (userWei.sign) {\n', '                supplyValue.value = supplyValue.value.add(Decimal.div(assetValue, adjust));\n', '            } else {\n', '                borrowValue.value = borrowValue.value.add(Decimal.mul(assetValue, adjust));\n', '            }\n', '        }\n', '\n', '        return (supplyValue, borrowValue);\n', '    }\n', '\n', '    function isCollateralized(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        Cache.MarketCache memory cache,\n', '        bool requireMinBorrow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // get account values (adjusted for liquidity)\n', '        (\n', '            Monetary.Value memory supplyValue,\n', '            Monetary.Value memory borrowValue\n', '        ) = state.getAccountValues(account, cache, /* adjustForLiquidity = */ true);\n', '\n', '        if (borrowValue.value == 0) {\n', '            return true;\n', '        }\n', '\n', '        if (requireMinBorrow) {\n', '            Require.that(\n', '                borrowValue.value >= state.riskParams.minBorrowedValue.value,\n', '                FILE,\n', '                "Borrow value too low",\n', '                account.owner,\n', '                account.number,\n', '                borrowValue.value\n', '            );\n', '        }\n', '\n', '        uint256 requiredMargin = Decimal.mul(borrowValue.value, state.riskParams.marginRatio);\n', '\n', '        return supplyValue.value >= borrowValue.value.add(requiredMargin);\n', '    }\n', '\n', '    function isGlobalOperator(\n', '        Storage.State storage state,\n', '        address operator\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.globalOperators[operator];\n', '    }\n', '\n', '    function isLocalOperator(\n', '        Storage.State storage state,\n', '        address owner,\n', '        address operator\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.operators[owner][operator];\n', '    }\n', '\n', '    function requireIsOperator(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        address operator\n', '    )\n', '        internal\n', '        view\n', '    {\n', '        bool isValidOperator =\n', '            operator == account.owner\n', '            || state.isGlobalOperator(operator)\n', '            || state.isLocalOperator(account.owner, operator);\n', '\n', '        Require.that(\n', '            isValidOperator,\n', '            FILE,\n', '            "Unpermissioned operator",\n', '            operator\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Determine and set an account's balance based on the intended balance change. Return the\n", '     * equivalent amount in wei\n', '     */\n', '    function getNewParAndDeltaWei(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId,\n', '        Types.AssetAmount memory amount\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Par memory, Types.Wei memory)\n', '    {\n', '        Types.Par memory oldPar = state.getPar(account, marketId);\n', '\n', '        if (amount.value == 0 && amount.ref == Types.AssetReference.Delta) {\n', '            return (oldPar, Types.zeroWei());\n', '        }\n', '\n', '        Interest.Index memory index = state.getIndex(marketId);\n', '        Types.Wei memory oldWei = Interest.parToWei(oldPar, index);\n', '        Types.Par memory newPar;\n', '        Types.Wei memory deltaWei;\n', '\n', '        if (amount.denomination == Types.AssetDenomination.Wei) {\n', '            deltaWei = Types.Wei({\n', '                sign: amount.sign,\n', '                value: amount.value\n', '            });\n', '            if (amount.ref == Types.AssetReference.Target) {\n', '                deltaWei = deltaWei.sub(oldWei);\n', '            }\n', '            newPar = Interest.weiToPar(oldWei.add(deltaWei), index);\n', '        } else { // AssetDenomination.Par\n', '            newPar = Types.Par({\n', '                sign: amount.sign,\n', '                value: amount.value.to128()\n', '            });\n', '            if (amount.ref == Types.AssetReference.Delta) {\n', '                newPar = oldPar.add(newPar);\n', '            }\n', '            deltaWei = Interest.parToWei(newPar, index).sub(oldWei);\n', '        }\n', '\n', '        return (newPar, deltaWei);\n', '    }\n', '\n', '    function getNewParAndDeltaWeiForLiquidation(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId,\n', '        Types.AssetAmount memory amount\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Par memory, Types.Wei memory)\n', '    {\n', '        Types.Par memory oldPar = state.getPar(account, marketId);\n', '\n', '        Require.that(\n', '            !oldPar.isPositive(),\n', '            FILE,\n', '            "Owed balance cannot be positive",\n', '            account.owner,\n', '            account.number,\n', '            marketId\n', '        );\n', '\n', '        (\n', '            Types.Par memory newPar,\n', '            Types.Wei memory deltaWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            account,\n', '            marketId,\n', '            amount\n', '        );\n', '\n', '        // if attempting to over-repay the owed asset, bound it by the maximum\n', '        if (newPar.isPositive()) {\n', '            newPar = Types.zeroPar();\n', '            deltaWei = state.getWei(account, marketId).negative();\n', '        }\n', '\n', '        Require.that(\n', '            !deltaWei.isNegative() && oldPar.value >= newPar.value,\n', '            FILE,\n', '            "Owed balance cannot increase",\n', '            account.owner,\n', '            account.number,\n', '            marketId\n', '        );\n', '\n', '        // if not paying back enough wei to repay any par, then bound wei to zero\n', '        if (oldPar.equals(newPar)) {\n', '            deltaWei = Types.zeroWei();\n', '        }\n', '\n', '        return (newPar, deltaWei);\n', '    }\n', '\n', '    function isVaporizable(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        Cache.MarketCache memory cache\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        bool hasNegative = false;\n', '        uint256 numMarkets = cache.getNumMarkets();\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (!cache.hasMarket(m)) {\n', '                continue;\n', '            }\n', '            Types.Par memory par = state.getPar(account, m);\n', '            if (par.isZero()) {\n', '                continue;\n', '            } else if (par.sign) {\n', '                return false;\n', '            } else {\n', '                hasNegative = true;\n', '            }\n', '        }\n', '        return hasNegative;\n', '    }\n', '\n', '    // =============== Setter Functions ===============\n', '\n', '    function updateIndex(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        internal\n', '        returns (Interest.Index memory)\n', '    {\n', '        Interest.Index memory index = state.getIndex(marketId);\n', '        if (index.lastUpdate == Time.currentTime()) {\n', '            return index;\n', '        }\n', '        return state.markets[marketId].index = state.fetchNewIndex(marketId, index);\n', '    }\n', '\n', '    function setStatus(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        Account.Status status\n', '    )\n', '        internal\n', '    {\n', '        state.accounts[account.owner][account.number].status = status;\n', '    }\n', '\n', '    function setPar(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId,\n', '        Types.Par memory newPar\n', '    )\n', '        internal\n', '    {\n', '        Types.Par memory oldPar = state.getPar(account, marketId);\n', '\n', '        if (Types.equals(oldPar, newPar)) {\n', '            return;\n', '        }\n', '\n', '        // updateTotalPar\n', '        Types.TotalPar memory totalPar = state.getTotalPar(marketId);\n', '\n', '        // roll-back oldPar\n', '        if (oldPar.sign) {\n', '            totalPar.supply = uint256(totalPar.supply).sub(oldPar.value).to128();\n', '        } else {\n', '            totalPar.borrow = uint256(totalPar.borrow).sub(oldPar.value).to128();\n', '        }\n', '\n', '        // roll-forward newPar\n', '        if (newPar.sign) {\n', '            totalPar.supply = uint256(totalPar.supply).add(newPar.value).to128();\n', '        } else {\n', '            totalPar.borrow = uint256(totalPar.borrow).add(newPar.value).to128();\n', '        }\n', '\n', '        state.markets[marketId].totalPar = totalPar;\n', '        state.accounts[account.owner][account.number].balances[marketId] = newPar;\n', '    }\n', '\n', '    /**\n', "     * Determine and set an account's balance based on a change in wei\n", '     */\n', '    function setParFromDeltaWei(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 marketId,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        if (deltaWei.isZero()) {\n', '            return;\n', '        }\n', '        Interest.Index memory index = state.getIndex(marketId);\n', '        Types.Wei memory oldWei = state.getWei(account, marketId);\n', '        Types.Wei memory newWei = oldWei.add(deltaWei);\n', '        Types.Par memory newPar = Interest.weiToPar(newWei, index);\n', '        state.setPar(\n', '            account,\n', '            marketId,\n', '            newPar\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/State.sol\n', '\n', '/**\n', ' * @title State\n', ' * @author dYdX\n', ' *\n', ' * Base-level contract that holds the state of Solo\n', ' */\n', 'contract State\n', '{\n', '    Storage.State g_state;\n', '}\n', '\n', '// File: contracts/protocol/impl/AdminImpl.sol\n', '\n', '/**\n', ' * @title AdminImpl\n', ' * @author dYdX\n', ' *\n', ' * Administrative functions to keep the protocol updated\n', ' */\n', 'library AdminImpl {\n', '    using Storage for Storage.State;\n', '    using Token for address;\n', '    using Types for Types.Wei;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "AdminImpl";\n', '\n', '    // ============ Events ============\n', '\n', '    event LogWithdrawExcessTokens(\n', '        address token,\n', '        uint256 amount\n', '    );\n', '\n', '    event LogAddMarket(\n', '        uint256 marketId,\n', '        address token\n', '    );\n', '\n', '    event LogSetIsClosing(\n', '        uint256 marketId,\n', '        bool isClosing\n', '    );\n', '\n', '    event LogSetPriceOracle(\n', '        uint256 marketId,\n', '        address priceOracle\n', '    );\n', '\n', '    event LogSetInterestSetter(\n', '        uint256 marketId,\n', '        address interestSetter\n', '    );\n', '\n', '    event LogSetMarginPremium(\n', '        uint256 marketId,\n', '        Decimal.D256 marginPremium\n', '    );\n', '\n', '    event LogSetSpreadPremium(\n', '        uint256 marketId,\n', '        Decimal.D256 spreadPremium\n', '    );\n', '\n', '    event LogSetMarginRatio(\n', '        Decimal.D256 marginRatio\n', '    );\n', '\n', '    event LogSetLiquidationSpread(\n', '        Decimal.D256 liquidationSpread\n', '    );\n', '\n', '    event LogSetEarningsRate(\n', '        Decimal.D256 earningsRate\n', '    );\n', '\n', '    event LogSetMinBorrowedValue(\n', '        Monetary.Value minBorrowedValue\n', '    );\n', '\n', '    event LogSetGlobalOperator(\n', '        address operator,\n', '        bool approved\n', '    );\n', '\n', '    // ============ Token Functions ============\n', '\n', '    function ownerWithdrawExcessTokens(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        address recipient\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        Types.Wei memory excessWei = state.getNumExcessTokens(marketId);\n', '\n', '        Require.that(\n', '            !excessWei.isNegative(),\n', '            FILE,\n', '            "Negative excess"\n', '        );\n', '\n', '        address token = state.getToken(marketId);\n', '\n', '        uint256 actualBalance = token.balanceOf(address(this));\n', '        if (excessWei.value > actualBalance) {\n', '            excessWei.value = actualBalance;\n', '        }\n', '\n', '        token.transfer(recipient, excessWei.value);\n', '\n', '        emit LogWithdrawExcessTokens(token, excessWei.value);\n', '\n', '        return excessWei.value;\n', '    }\n', '\n', '    function ownerWithdrawUnsupportedTokens(\n', '        Storage.State storage state,\n', '        address token,\n', '        address recipient\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        _requireNoMarket(state, token);\n', '\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(recipient, balance);\n', '\n', '        emit LogWithdrawExcessTokens(token, balance);\n', '\n', '        return balance;\n', '    }\n', '\n', '    // ============ Market Functions ============\n', '\n', '    function ownerAddMarket(\n', '        Storage.State storage state,\n', '        address token,\n', '        IPriceOracle priceOracle,\n', '        IInterestSetter interestSetter,\n', '        Decimal.D256 memory marginPremium,\n', '        Decimal.D256 memory spreadPremium\n', '    )\n', '        public\n', '    {\n', '        _requireNoMarket(state, token);\n', '\n', '        uint256 marketId = state.numMarkets;\n', '\n', '        state.numMarkets++;\n', '        state.markets[marketId].token = token;\n', '        state.markets[marketId].index = Interest.newIndex();\n', '\n', '        emit LogAddMarket(marketId, token);\n', '\n', '        _setPriceOracle(state, marketId, priceOracle);\n', '        _setInterestSetter(state, marketId, interestSetter);\n', '        _setMarginPremium(state, marketId, marginPremium);\n', '        _setSpreadPremium(state, marketId, spreadPremium);\n', '    }\n', '\n', '    function ownerSetIsClosing(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        bool isClosing\n', '    )\n', '        public\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        state.markets[marketId].isClosing = isClosing;\n', '        emit LogSetIsClosing(marketId, isClosing);\n', '    }\n', '\n', '    function ownerSetPriceOracle(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        IPriceOracle priceOracle\n', '    )\n', '        public\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        _setPriceOracle(state, marketId, priceOracle);\n', '    }\n', '\n', '    function ownerSetInterestSetter(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        IInterestSetter interestSetter\n', '    )\n', '        public\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        _setInterestSetter(state, marketId, interestSetter);\n', '    }\n', '\n', '    function ownerSetMarginPremium(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Decimal.D256 memory marginPremium\n', '    )\n', '        public\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        _setMarginPremium(state, marketId, marginPremium);\n', '    }\n', '\n', '    function ownerSetSpreadPremium(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Decimal.D256 memory spreadPremium\n', '    )\n', '        public\n', '    {\n', '        _validateMarketId(state, marketId);\n', '        _setSpreadPremium(state, marketId, spreadPremium);\n', '    }\n', '\n', '    // ============ Risk Functions ============\n', '\n', '    function ownerSetMarginRatio(\n', '        Storage.State storage state,\n', '        Decimal.D256 memory ratio\n', '    )\n', '        public\n', '    {\n', '        Require.that(\n', '            ratio.value <= state.riskLimits.marginRatioMax,\n', '            FILE,\n', '            "Ratio too high"\n', '        );\n', '        Require.that(\n', '            ratio.value > state.riskParams.liquidationSpread.value,\n', '            FILE,\n', '            "Ratio cannot be <= spread"\n', '        );\n', '        state.riskParams.marginRatio = ratio;\n', '        emit LogSetMarginRatio(ratio);\n', '    }\n', '\n', '    function ownerSetLiquidationSpread(\n', '        Storage.State storage state,\n', '        Decimal.D256 memory spread\n', '    )\n', '        public\n', '    {\n', '        Require.that(\n', '            spread.value <= state.riskLimits.liquidationSpreadMax,\n', '            FILE,\n', '            "Spread too high"\n', '        );\n', '        Require.that(\n', '            spread.value < state.riskParams.marginRatio.value,\n', '            FILE,\n', '            "Spread cannot be >= ratio"\n', '        );\n', '        state.riskParams.liquidationSpread = spread;\n', '        emit LogSetLiquidationSpread(spread);\n', '    }\n', '\n', '    function ownerSetEarningsRate(\n', '        Storage.State storage state,\n', '        Decimal.D256 memory earningsRate\n', '    )\n', '        public\n', '    {\n', '        Require.that(\n', '            earningsRate.value <= state.riskLimits.earningsRateMax,\n', '            FILE,\n', '            "Rate too high"\n', '        );\n', '        state.riskParams.earningsRate = earningsRate;\n', '        emit LogSetEarningsRate(earningsRate);\n', '    }\n', '\n', '    function ownerSetMinBorrowedValue(\n', '        Storage.State storage state,\n', '        Monetary.Value memory minBorrowedValue\n', '    )\n', '        public\n', '    {\n', '        Require.that(\n', '            minBorrowedValue.value <= state.riskLimits.minBorrowedValueMax,\n', '            FILE,\n', '            "Value too high"\n', '        );\n', '        state.riskParams.minBorrowedValue = minBorrowedValue;\n', '        emit LogSetMinBorrowedValue(minBorrowedValue);\n', '    }\n', '\n', '    // ============ Global Operator Functions ============\n', '\n', '    function ownerSetGlobalOperator(\n', '        Storage.State storage state,\n', '        address operator,\n', '        bool approved\n', '    )\n', '        public\n', '    {\n', '        state.globalOperators[operator] = approved;\n', '\n', '        emit LogSetGlobalOperator(operator, approved);\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function _setPriceOracle(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        IPriceOracle priceOracle\n', '    )\n', '        private\n', '    {\n', '        // require oracle can return non-zero price\n', '        address token = state.markets[marketId].token;\n', '\n', '        Require.that(\n', '            priceOracle.getPrice(token).value != 0,\n', '            FILE,\n', '            "Invalid oracle price"\n', '        );\n', '\n', '        state.markets[marketId].priceOracle = priceOracle;\n', '\n', '        emit LogSetPriceOracle(marketId, address(priceOracle));\n', '    }\n', '\n', '    function _setInterestSetter(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        IInterestSetter interestSetter\n', '    )\n', '        private\n', '    {\n', '        // ensure interestSetter can return a value without reverting\n', '        address token = state.markets[marketId].token;\n', '        interestSetter.getInterestRate(token, 0, 0);\n', '\n', '        state.markets[marketId].interestSetter = interestSetter;\n', '\n', '        emit LogSetInterestSetter(marketId, address(interestSetter));\n', '    }\n', '\n', '    function _setMarginPremium(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Decimal.D256 memory marginPremium\n', '    )\n', '        private\n', '    {\n', '        Require.that(\n', '            marginPremium.value <= state.riskLimits.marginPremiumMax,\n', '            FILE,\n', '            "Margin premium too high"\n', '        );\n', '        state.markets[marketId].marginPremium = marginPremium;\n', '\n', '        emit LogSetMarginPremium(marketId, marginPremium);\n', '    }\n', '\n', '    function _setSpreadPremium(\n', '        Storage.State storage state,\n', '        uint256 marketId,\n', '        Decimal.D256 memory spreadPremium\n', '    )\n', '        private\n', '    {\n', '        Require.that(\n', '            spreadPremium.value <= state.riskLimits.spreadPremiumMax,\n', '            FILE,\n', '            "Spread premium too high"\n', '        );\n', '        state.markets[marketId].spreadPremium = spreadPremium;\n', '\n', '        emit LogSetSpreadPremium(marketId, spreadPremium);\n', '    }\n', '\n', '    function _requireNoMarket(\n', '        Storage.State storage state,\n', '        address token\n', '    )\n', '        private\n', '        view\n', '    {\n', '        uint256 numMarkets = state.numMarkets;\n', '\n', '        bool marketExists = false;\n', '\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (state.markets[m].token == token) {\n', '                marketExists = true;\n', '                break;\n', '            }\n', '        }\n', '\n', '        Require.that(\n', '            !marketExists,\n', '            FILE,\n', '            "Market exists"\n', '        );\n', '    }\n', '\n', '    function _validateMarketId(\n', '        Storage.State storage state,\n', '        uint256 marketId\n', '    )\n', '        private\n', '        view\n', '    {\n', '        Require.that(\n', '            marketId < state.numMarkets,\n', '            FILE,\n', '            "Market OOB",\n', '            marketId\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/Admin.sol\n', '\n', '/**\n', ' * @title Admin\n', ' * @author dYdX\n', ' *\n', ' * Public functions that allow the privileged owner address to manage Solo\n', ' */\n', 'contract Admin is\n', '    State,\n', '    Ownable,\n', '    ReentrancyGuard\n', '{\n', '    // ============ Token Functions ============\n', '\n', '    /**\n', '     * Withdraw an ERC20 token for which there is an associated market. Only excess tokens can be\n', '     * withdrawn. The number of excess tokens is calculated by taking the current number of tokens\n', '     * held in Solo, adding the number of tokens owed to Solo by borrowers, and subtracting the\n', '     * number of tokens owed to suppliers by Solo.\n', '     */\n', '    function ownerWithdrawExcessTokens(\n', '        uint256 marketId,\n', '        address recipient\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return AdminImpl.ownerWithdrawExcessTokens(\n', '            g_state,\n', '            marketId,\n', '            recipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Withdraw an ERC20 token for which there is no associated market.\n', '     */\n', '    function ownerWithdrawUnsupportedTokens(\n', '        address token,\n', '        address recipient\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return AdminImpl.ownerWithdrawUnsupportedTokens(\n', '            g_state,\n', '            token,\n', '            recipient\n', '        );\n', '    }\n', '\n', '    // ============ Market Functions ============\n', '\n', '    /**\n', '     * Add a new market to Solo. Must be for a previously-unsupported ERC20 token.\n', '     */\n', '    function ownerAddMarket(\n', '        address token,\n', '        IPriceOracle priceOracle,\n', '        IInterestSetter interestSetter,\n', '        Decimal.D256 memory marginPremium,\n', '        Decimal.D256 memory spreadPremium\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerAddMarket(\n', '            g_state,\n', '            token,\n', '            priceOracle,\n', '            interestSetter,\n', '            marginPremium,\n', '            spreadPremium\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set (or unset) the status of a market to "closing". The borrowedValue of a market cannot\n', '     * increase while its status is "closing".\n', '     */\n', '    function ownerSetIsClosing(\n', '        uint256 marketId,\n', '        bool isClosing\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetIsClosing(\n', '            g_state,\n', '            marketId,\n', '            isClosing\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set the price oracle for a market.\n', '     */\n', '    function ownerSetPriceOracle(\n', '        uint256 marketId,\n', '        IPriceOracle priceOracle\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetPriceOracle(\n', '            g_state,\n', '            marketId,\n', '            priceOracle\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set the interest-setter for a market.\n', '     */\n', '    function ownerSetInterestSetter(\n', '        uint256 marketId,\n', '        IInterestSetter interestSetter\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetInterestSetter(\n', '            g_state,\n', '            marketId,\n', '            interestSetter\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set a premium on the minimum margin-ratio for a market. This makes it so that any positions\n', '     * that include this market require a higher collateralization to avoid being liquidated.\n', '     */\n', '    function ownerSetMarginPremium(\n', '        uint256 marketId,\n', '        Decimal.D256 memory marginPremium\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetMarginPremium(\n', '            g_state,\n', '            marketId,\n', '            marginPremium\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set a premium on the liquidation spread for a market. This makes it so that any liquidations\n', '     * that include this market have a higher spread than the global default.\n', '     */\n', '    function ownerSetSpreadPremium(\n', '        uint256 marketId,\n', '        Decimal.D256 memory spreadPremium\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetSpreadPremium(\n', '            g_state,\n', '            marketId,\n', '            spreadPremium\n', '        );\n', '    }\n', '\n', '    // ============ Risk Functions ============\n', '\n', '    /**\n', '     * Set the global minimum margin-ratio that every position must maintain to prevent being\n', '     * liquidated.\n', '     */\n', '    function ownerSetMarginRatio(\n', '        Decimal.D256 memory ratio\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetMarginRatio(\n', '            g_state,\n', '            ratio\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set the global liquidation spread. This is the spread between oracle prices that incentivizes\n', '     * the liquidation of risky positions.\n', '     */\n', '    function ownerSetLiquidationSpread(\n', '        Decimal.D256 memory spread\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetLiquidationSpread(\n', '            g_state,\n', '            spread\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set the global earnings-rate variable that determines what percentage of the interest paid\n', '     * by borrowers gets passed-on to suppliers.\n', '     */\n', '    function ownerSetEarningsRate(\n', '        Decimal.D256 memory earningsRate\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetEarningsRate(\n', '            g_state,\n', '            earningsRate\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Set the global minimum-borrow value which is the minimum value of any new borrow on Solo.\n', '     */\n', '    function ownerSetMinBorrowedValue(\n', '        Monetary.Value memory minBorrowedValue\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetMinBorrowedValue(\n', '            g_state,\n', '            minBorrowedValue\n', '        );\n', '    }\n', '\n', '    // ============ Global Operator Functions ============\n', '\n', '    /**\n', '     * Approve (or disapprove) an address that is permissioned to be an operator for all accounts in\n', '     * Solo. Intended only to approve smart-contracts.\n', '     */\n', '    function ownerSetGlobalOperator(\n', '        address operator,\n', '        bool approved\n', '    )\n', '        public\n', '        onlyOwner\n', '        nonReentrant\n', '    {\n', '        AdminImpl.ownerSetGlobalOperator(\n', '            g_state,\n', '            operator,\n', '            approved\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/Getters.sol\n', '\n', '/**\n', ' * @title Getters\n', ' * @author dYdX\n', ' *\n', ' * Public read-only functions that allow transparency into the state of Solo\n', ' */\n', 'contract Getters is\n', '    State\n', '{\n', '    using Cache for Cache.MarketCache;\n', '    using Storage for Storage.State;\n', '    using Types for Types.Par;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 FILE = "Getters";\n', '\n', '    // ============ Getters for Risk ============\n', '\n', '    /**\n', '     * Get the global minimum margin-ratio that every position must maintain to prevent being\n', '     * liquidated.\n', '     *\n', '     * @return  The global margin-ratio\n', '     */\n', '    function getMarginRatio()\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return g_state.riskParams.marginRatio;\n', '    }\n', '\n', '    /**\n', '     * Get the global liquidation spread. This is the spread between oracle prices that incentivizes\n', '     * the liquidation of risky positions.\n', '     *\n', '     * @return  The global liquidation spread\n', '     */\n', '    function getLiquidationSpread()\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return g_state.riskParams.liquidationSpread;\n', '    }\n', '\n', '    /**\n', '     * Get the global earnings-rate variable that determines what percentage of the interest paid\n', '     * by borrowers gets passed-on to suppliers.\n', '     *\n', '     * @return  The global earnings rate\n', '     */\n', '    function getEarningsRate()\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return g_state.riskParams.earningsRate;\n', '    }\n', '\n', '    /**\n', '     * Get the global minimum-borrow value which is the minimum value of any new borrow on Solo.\n', '     *\n', '     * @return  The global minimum borrow value\n', '     */\n', '    function getMinBorrowedValue()\n', '        public\n', '        view\n', '        returns (Monetary.Value memory)\n', '    {\n', '        return g_state.riskParams.minBorrowedValue;\n', '    }\n', '\n', '    /**\n', '     * Get all risk parameters in a single struct.\n', '     *\n', '     * @return  All global risk parameters\n', '     */\n', '    function getRiskParams()\n', '        public\n', '        view\n', '        returns (Storage.RiskParams memory)\n', '    {\n', '        return g_state.riskParams;\n', '    }\n', '\n', '    /**\n', '     * Get all risk parameter limits in a single struct. These are the maximum limits at which the\n', '     * risk parameters can be set by the admin of Solo.\n', '     *\n', '     * @return  All global risk parameter limnits\n', '     */\n', '    function getRiskLimits()\n', '        public\n', '        view\n', '        returns (Storage.RiskLimits memory)\n', '    {\n', '        return g_state.riskLimits;\n', '    }\n', '\n', '    // ============ Getters for Markets ============\n', '\n', '    /**\n', '     * Get the total number of markets.\n', '     *\n', '     * @return  The number of markets\n', '     */\n', '    function getNumMarkets()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return g_state.numMarkets;\n', '    }\n', '\n', '    /**\n', '     * Get the ERC20 token address for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The token address\n', '     */\n', '    function getMarketTokenAddress(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.getToken(marketId);\n', '    }\n', '\n', '    /**\n', '     * Get the total principal amounts (borrowed and supplied) for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The total principal amounts\n', '     */\n', '    function getMarketTotalPar(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Types.TotalPar memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.getTotalPar(marketId);\n', '    }\n', '\n', '    /**\n', '     * Get the most recently cached interest index for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The most recent index\n', '     */\n', '    function getMarketCachedIndex(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Interest.Index memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.getIndex(marketId);\n', '    }\n', '\n', '    /**\n', '     * Get the interest index for a market if it were to be updated right now.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The estimated current index\n', '     */\n', '    function getMarketCurrentIndex(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Interest.Index memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.fetchNewIndex(marketId, g_state.getIndex(marketId));\n', '    }\n', '\n', '    /**\n', '     * Get the price oracle address for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The price oracle address\n', '     */\n', '    function getMarketPriceOracle(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (IPriceOracle)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId].priceOracle;\n', '    }\n', '\n', '    /**\n', '     * Get the interest-setter address for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The interest-setter address\n', '     */\n', '    function getMarketInterestSetter(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (IInterestSetter)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId].interestSetter;\n', '    }\n', '\n', '    /**\n', '     * Get the margin premium for a market. A margin premium makes it so that any positions that\n', '     * include the market require a higher collateralization to avoid being liquidated.\n', '     *\n', '     * @param  marketId  The market to query\n', "     * @return           The market's margin premium\n", '     */\n', '    function getMarketMarginPremium(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId].marginPremium;\n', '    }\n', '\n', '    /**\n', '     * Get the spread premium for a market. A spread premium makes it so that any liquidations\n', '     * that include the market have a higher spread than the global default.\n', '     *\n', '     * @param  marketId  The market to query\n', "     * @return           The market's spread premium\n", '     */\n', '    function getMarketSpreadPremium(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId].spreadPremium;\n', '    }\n', '\n', '    /**\n', '     * Return true if a particular market is in closing mode. Additional borrows cannot be taken\n', '     * from a market that is closing.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           True if the market is closing\n', '     */\n', '    function getMarketIsClosing(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId].isClosing;\n', '    }\n', '\n', '    /**\n', '     * Get the price of the token for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The price of each atomic unit of the token\n', '     */\n', '    function getMarketPrice(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Monetary.Price memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.fetchPrice(marketId);\n', '    }\n', '\n', '    /**\n', '     * Get the current borrower interest rate for a market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The current interest rate\n', '     */\n', '    function getMarketInterestRate(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Interest.Rate memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.fetchInterestRate(\n', '            marketId,\n', '            g_state.getIndex(marketId)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the adjusted liquidation spread for some market pair. This is equal to the global\n', '     * liquidation spread multiplied by (1 + spreadPremium) for each of the two markets.\n', '     *\n', '     * @param  heldMarketId  The market for which the account has collateral\n', '     * @param  owedMarketId  The market for which the account has borrowed tokens\n', '     * @return               The adjusted liquidation spread\n', '     */\n', '    function getLiquidationSpreadForPair(\n', '        uint256 heldMarketId,\n', '        uint256 owedMarketId\n', '    )\n', '        public\n', '        view\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        _requireValidMarket(heldMarketId);\n', '        _requireValidMarket(owedMarketId);\n', '        return g_state.getLiquidationSpreadForPair(heldMarketId, owedMarketId);\n', '    }\n', '\n', '    /**\n', '     * Get basic information about a particular market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           A Storage.Market struct with the current state of the market\n', '     */\n', '    function getMarket(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Storage.Market memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.markets[marketId];\n', '    }\n', '\n', '    /**\n', '     * Get comprehensive information about a particular market.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           A tuple containing the values:\n', '     *                    - A Storage.Market struct with the current state of the market\n', '     *                    - The current estimated interest index\n', '     *                    - The current token price\n', '     *                    - The current market interest rate\n', '     */\n', '    function getMarketWithInfo(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            Storage.Market memory,\n', '            Interest.Index memory,\n', '            Monetary.Price memory,\n', '            Interest.Rate memory\n', '        )\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return (\n', '            getMarket(marketId),\n', '            getMarketCurrentIndex(marketId),\n', '            getMarketPrice(marketId),\n', '            getMarketInterestRate(marketId)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the number of excess tokens for a market. The number of excess tokens is calculated\n', '     * by taking the current number of tokens held in Solo, adding the number of tokens owed to Solo\n', '     * by borrowers, and subtracting the number of tokens owed to suppliers by Solo.\n', '     *\n', '     * @param  marketId  The market to query\n', '     * @return           The number of excess tokens\n', '     */\n', '    function getNumExcessTokens(\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Types.Wei memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.getNumExcessTokens(marketId);\n', '    }\n', '\n', '    // ============ Getters for Accounts ============\n', '\n', '    /**\n', '     * Get the principal value for a particular account and market.\n', '     *\n', '     * @param  account   The account to query\n', '     * @param  marketId  The market to query\n', '     * @return           The principal value\n', '     */\n', '    function getAccountPar(\n', '        Account.Info memory account,\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Types.Par memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return g_state.getPar(account, marketId);\n', '    }\n', '\n', '    /**\n', '     * Get the token balance for a particular account and market.\n', '     *\n', '     * @param  account   The account to query\n', '     * @param  marketId  The market to query\n', '     * @return           The token amount\n', '     */\n', '    function getAccountWei(\n', '        Account.Info memory account,\n', '        uint256 marketId\n', '    )\n', '        public\n', '        view\n', '        returns (Types.Wei memory)\n', '    {\n', '        _requireValidMarket(marketId);\n', '        return Interest.parToWei(\n', '            g_state.getPar(account, marketId),\n', '            g_state.fetchNewIndex(marketId, g_state.getIndex(marketId))\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the status of an account (Normal, Liquidating, or Vaporizing).\n', '     *\n', '     * @param  account  The account to query\n', "     * @return          The account's status\n", '     */\n', '    function getAccountStatus(\n', '        Account.Info memory account\n', '    )\n', '        public\n', '        view\n', '        returns (Account.Status)\n', '    {\n', '        return g_state.getStatus(account);\n', '    }\n', '\n', '    /**\n', '     * Get the total supplied and total borrowed value of an account.\n', '     *\n', '     * @param  account  The account to query\n', '     * @return          The following values:\n', '     *                   - The supplied value of the account\n', '     *                   - The borrowed value of the account\n', '     */\n', '    function getAccountValues(\n', '        Account.Info memory account\n', '    )\n', '        public\n', '        view\n', '        returns (Monetary.Value memory, Monetary.Value memory)\n', '    {\n', '        return getAccountValuesInternal(account, /* adjustForLiquidity = */ false);\n', '    }\n', '\n', '    /**\n', '     * Get the total supplied and total borrowed values of an account adjusted by the marginPremium\n', '     * of each market. Supplied values are divided by (1 + marginPremium) for each market and\n', '     * borrowed values are multiplied by (1 + marginPremium) for each market. Comparing these\n', '     * adjusted values gives the margin-ratio of the account which will be compared to the global\n', '     * margin-ratio when determining if the account can be liquidated.\n', '     *\n', '     * @param  account  The account to query\n', '     * @return          The following values:\n', '     *                   - The supplied value of the account (adjusted for marginPremium)\n', '     *                   - The borrowed value of the account (adjusted for marginPremium)\n', '     */\n', '    function getAdjustedAccountValues(\n', '        Account.Info memory account\n', '    )\n', '        public\n', '        view\n', '        returns (Monetary.Value memory, Monetary.Value memory)\n', '    {\n', '        return getAccountValuesInternal(account, /* adjustForLiquidity = */ true);\n', '    }\n', '\n', '    /**\n', "     * Get an account's summary for each market.\n", '     *\n', '     * @param  account  The account to query\n', '     * @return          The following values:\n', '     *                   - The ERC20 token address for each market\n', "     *                   - The account's principal value for each market\n", "     *                   - The account's (supplied or borrowed) number of tokens for each market\n", '     */\n', '    function getAccountBalances(\n', '        Account.Info memory account\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory,\n', '            Types.Par[] memory,\n', '            Types.Wei[] memory\n', '        )\n', '    {\n', '        uint256 numMarkets = g_state.numMarkets;\n', '        address[] memory tokens = new address[](numMarkets);\n', '        Types.Par[] memory pars = new Types.Par[](numMarkets);\n', '        Types.Wei[] memory weis = new Types.Wei[](numMarkets);\n', '\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            tokens[m] = getMarketTokenAddress(m);\n', '            pars[m] = getAccountPar(account, m);\n', '            weis[m] = getAccountWei(account, m);\n', '        }\n', '\n', '        return (\n', '            tokens,\n', '            pars,\n', '            weis\n', '        );\n', '    }\n', '\n', '    // ============ Getters for Permissions ============\n', '\n', '    /**\n', "     * Return true if a particular address is approved as an operator for an owner's accounts.\n", "     * Approved operators can act on the accounts of the owner as if it were the operator's own.\n", '     *\n', '     * @param  owner     The owner of the accounts\n', '     * @param  operator  The possible operator\n', "     * @return           True if operator is approved for owner's accounts\n", '     */\n', '    function getIsLocalOperator(\n', '        address owner,\n', '        address operator\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return g_state.isLocalOperator(owner, operator);\n', '    }\n', '\n', '    /**\n', '     * Return true if a particular address is approved as a global operator. Such an address can\n', "     * act on any account as if it were the operator's own.\n", '     *\n', '     * @param  operator  The address to query\n', '     * @return           True if operator is a global operator\n', '     */\n', '    function getIsGlobalOperator(\n', '        address operator\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return g_state.isGlobalOperator(operator);\n', '    }\n', '\n', '    // ============ Private Helper Functions ============\n', '\n', '    /**\n', '     * Revert if marketId is invalid.\n', '     */\n', '    function _requireValidMarket(\n', '        uint256 marketId\n', '    )\n', '        private\n', '        view\n', '    {\n', '        Require.that(\n', '            marketId < g_state.numMarkets,\n', '            FILE,\n', '            "Market OOB"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Private helper for getting the monetary values of an account.\n', '     */\n', '    function getAccountValuesInternal(\n', '        Account.Info memory account,\n', '        bool adjustForLiquidity\n', '    )\n', '        private\n', '        view\n', '        returns (Monetary.Value memory, Monetary.Value memory)\n', '    {\n', '        uint256 numMarkets = g_state.numMarkets;\n', '\n', '        // populate cache\n', '        Cache.MarketCache memory cache = Cache.create(numMarkets);\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (!g_state.getPar(account, m).isZero()) {\n', '                cache.addMarket(g_state, m);\n', '            }\n', '        }\n', '\n', '        return g_state.getAccountValues(account, cache, adjustForLiquidity);\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/interfaces/IAutoTrader.sol\n', '\n', '/**\n', ' * @title IAutoTrader\n', ' * @author dYdX\n', ' *\n', ' * Interface that Auto-Traders for Solo must implement in order to approve trades.\n', ' */\n', 'contract IAutoTrader {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', "     * Allows traders to make trades approved by this smart contract. The active trader's account is\n", '     * the takerAccount and the passive account (for which this contract approves trades\n', '     * on-behalf-of) is the makerAccount.\n', '     *\n', '     * @param  inputMarketId   The market for which the trader specified the original amount\n', '     * @param  outputMarketId  The market for which the trader wants the resulting amount specified\n', '     * @param  makerAccount    The account for which this contract is making trades\n', '     * @param  takerAccount    The account requesting the trade\n', '     * @param  oldInputPar     The old principal amount for the makerAccount for the inputMarketId\n', '     * @param  newInputPar     The new principal amount for the makerAccount for the inputMarketId\n', '     * @param  inputWei        The change in token amount for the makerAccount for the inputMarketId\n', '     * @param  data            Arbitrary data passed in by the trader\n', '     * @return                 The AssetAmount for the makerAccount for the outputMarketId\n', '     */\n', '    function getTradeCost(\n', '        uint256 inputMarketId,\n', '        uint256 outputMarketId,\n', '        Account.Info memory makerAccount,\n', '        Account.Info memory takerAccount,\n', '        Types.Par memory oldInputPar,\n', '        Types.Par memory newInputPar,\n', '        Types.Wei memory inputWei,\n', '        bytes memory data\n', '    )\n', '        public\n', '        returns (Types.AssetAmount memory);\n', '}\n', '\n', '// File: contracts/protocol/interfaces/ICallee.sol\n', '\n', '/**\n', ' * @title ICallee\n', ' * @author dYdX\n', ' *\n', ' * Interface that Callees for Solo must implement in order to ingest data.\n', ' */\n', 'contract ICallee {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Allows users to send this contract arbitrary data.\n', '     *\n', '     * @param  sender       The msg.sender to Solo\n', '     * @param  accountInfo  The account from which the data is being sent\n', '     * @param  data         Arbitrary data given by the sender\n', '     */\n', '    function callFunction(\n', '        address sender,\n', '        Account.Info memory accountInfo,\n', '        bytes memory data\n', '    )\n', '        public;\n', '}\n', '\n', '// File: contracts/protocol/lib/Actions.sol\n', '\n', '/**\n', ' * @title Actions\n', ' * @author dYdX\n', ' *\n', ' * Library that defines and parses valid Actions\n', ' */\n', 'library Actions {\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Actions";\n', '\n', '    // ============ Enums ============\n', '\n', '    enum ActionType {\n', '        Deposit,   // supply tokens\n', '        Withdraw,  // borrow tokens\n', '        Transfer,  // transfer balance between accounts\n', '        Buy,       // buy an amount of some token (externally)\n', '        Sell,      // sell an amount of some token (externally)\n', '        Trade,     // trade tokens against another account\n', '        Liquidate, // liquidate an undercollateralized or expiring account\n', '        Vaporize,  // use excess tokens to zero-out a completely negative account\n', '        Call       // send arbitrary data to an address\n', '    }\n', '\n', '    enum AccountLayout {\n', '        OnePrimary,\n', '        TwoPrimary,\n', '        PrimaryAndSecondary\n', '    }\n', '\n', '    enum MarketLayout {\n', '        ZeroMarkets,\n', '        OneMarket,\n', '        TwoMarkets\n', '    }\n', '\n', '    // ============ Structs ============\n', '\n', '    /*\n', '     * Arguments that are passed to Solo in an ordered list as part of a single operation.\n', '     * Each ActionArgs has an actionType which specifies which action struct that this data will be\n', '     * parsed into before being processed.\n', '     */\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        Types.AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '\n', '    // ============ Action Types ============\n', '\n', '    /*\n', '     * Moves tokens from an address to Solo. Can either repay a borrow or provide additional supply.\n', '     */\n', '    struct DepositArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info account;\n', '        uint256 market;\n', '        address from;\n', '    }\n', '\n', '    /*\n', '     * Moves tokens from Solo to another address. Can either borrow tokens or reduce the amount\n', '     * previously supplied.\n', '     */\n', '    struct WithdrawArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info account;\n', '        uint256 market;\n', '        address to;\n', '    }\n', '\n', '    /*\n', '     * Transfers balance between two accounts. The msg.sender must be an operator for both accounts.\n', '     * The amount field applies to accountOne.\n', '     * This action does not require any token movement since the trade is done internally to Solo.\n', '     */\n', '    struct TransferArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info accountOne;\n', '        Account.Info accountTwo;\n', '        uint256 market;\n', '    }\n', '\n', '    /*\n', '     * Acquires a certain amount of tokens by spending other tokens. Sends takerMarket tokens to the\n', '     * specified exchangeWrapper contract and expects makerMarket tokens in return. The amount field\n', '     * applies to the makerMarket.\n', '     */\n', '    struct BuyArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info account;\n', '        uint256 makerMarket;\n', '        uint256 takerMarket;\n', '        address exchangeWrapper;\n', '        bytes orderData;\n', '    }\n', '\n', '    /*\n', '     * Spends a certain amount of tokens to acquire other tokens. Sends takerMarket tokens to the\n', '     * specified exchangeWrapper and expects makerMarket tokens in return. The amount field applies\n', '     * to the takerMarket.\n', '     */\n', '    struct SellArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info account;\n', '        uint256 takerMarket;\n', '        uint256 makerMarket;\n', '        address exchangeWrapper;\n', '        bytes orderData;\n', '    }\n', '\n', '    /*\n', '     * Trades balances between two accounts using any external contract that implements the\n', '     * AutoTrader interface. The AutoTrader contract must be an operator for the makerAccount (for\n', '     * which it is trading on-behalf-of). The amount field applies to the makerAccount and the\n', '     * inputMarket. This proposed change to the makerAccount is passed to the AutoTrader which will\n', '     * quote a change for the makerAccount in the outputMarket (or will disallow the trade).\n', '     * This action does not require any token movement since the trade is done internally to Solo.\n', '     */\n', '    struct TradeArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info takerAccount;\n', '        Account.Info makerAccount;\n', '        uint256 inputMarket;\n', '        uint256 outputMarket;\n', '        address autoTrader;\n', '        bytes tradeData;\n', '    }\n', '\n', '    /*\n', '     * Each account must maintain a certain margin-ratio (specified globally). If the account falls\n', '     * below this margin-ratio, it can be liquidated by any other account. This allows anyone else\n', '     * (arbitrageurs) to repay any borrowed asset (owedMarket) of the liquidating account in\n', '     * exchange for any collateral asset (heldMarket) of the liquidAccount. The ratio is determined\n', '     * by the price ratio (given by the oracles) plus a spread (specified globally). Liquidating an\n', '     * account also sets a flag on the account that the account is being liquidated. This allows\n', '     * anyone to continue liquidating the account until there are no more borrows being taken by the\n', '     * liquidating account. Liquidators do not have to liquidate the entire account all at once but\n', '     * can liquidate as much as they choose. The liquidating flag allows liquidators to continue\n', '     * liquidating the account even if it becomes collateralized through partial liquidation or\n', '     * price movement.\n', '     */\n', '    struct LiquidateArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info solidAccount;\n', '        Account.Info liquidAccount;\n', '        uint256 owedMarket;\n', '        uint256 heldMarket;\n', '    }\n', '\n', '    /*\n', '     * Similar to liquidate, but vaporAccounts are accounts that have only negative balances\n', '     * remaining. The arbitrageur pays back the negative asset (owedMarket) of the vaporAccount in\n', '     * exchange for a collateral asset (heldMarket) at a favorable spread. However, since the\n', "     * liquidAccount has no collateral assets, the collateral must come from Solo's excess tokens.\n", '     */\n', '    struct VaporizeArgs {\n', '        Types.AssetAmount amount;\n', '        Account.Info solidAccount;\n', '        Account.Info vaporAccount;\n', '        uint256 owedMarket;\n', '        uint256 heldMarket;\n', '    }\n', '\n', '    /*\n', '     * Passes arbitrary bytes of data to an external contract that implements the Callee interface.\n', '     * Does not change any asset amounts. This function may be useful for setting certain variables\n', '     * on layer-two contracts for certain accounts without having to make a separate Ethereum\n', '     * transaction for doing so. Also, the second-layer contracts can ensure that the call is coming\n', '     * from an operator of the particular account.\n', '     */\n', '    struct CallArgs {\n', '        Account.Info account;\n', '        address callee;\n', '        bytes data;\n', '    }\n', '\n', '    // ============ Helper Functions ============\n', '\n', '    function getMarketLayout(\n', '        ActionType actionType\n', '    )\n', '        internal\n', '        pure\n', '        returns (MarketLayout)\n', '    {\n', '        if (\n', '            actionType == Actions.ActionType.Deposit\n', '            || actionType == Actions.ActionType.Withdraw\n', '            || actionType == Actions.ActionType.Transfer\n', '        ) {\n', '            return MarketLayout.OneMarket;\n', '        }\n', '        else if (actionType == Actions.ActionType.Call) {\n', '            return MarketLayout.ZeroMarkets;\n', '        }\n', '        return MarketLayout.TwoMarkets;\n', '    }\n', '\n', '    function getAccountLayout(\n', '        ActionType actionType\n', '    )\n', '        internal\n', '        pure\n', '        returns (AccountLayout)\n', '    {\n', '        if (\n', '            actionType == Actions.ActionType.Transfer\n', '            || actionType == Actions.ActionType.Trade\n', '        ) {\n', '            return AccountLayout.TwoPrimary;\n', '        } else if (\n', '            actionType == Actions.ActionType.Liquidate\n', '            || actionType == Actions.ActionType.Vaporize\n', '        ) {\n', '            return AccountLayout.PrimaryAndSecondary;\n', '        }\n', '        return AccountLayout.OnePrimary;\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseDepositArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (DepositArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Deposit);\n', '        return DepositArgs({\n', '            amount: args.amount,\n', '            account: accounts[args.accountId],\n', '            market: args.primaryMarketId,\n', '            from: args.otherAddress\n', '        });\n', '    }\n', '\n', '    function parseWithdrawArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (WithdrawArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Withdraw);\n', '        return WithdrawArgs({\n', '            amount: args.amount,\n', '            account: accounts[args.accountId],\n', '            market: args.primaryMarketId,\n', '            to: args.otherAddress\n', '        });\n', '    }\n', '\n', '    function parseTransferArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (TransferArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Transfer);\n', '        return TransferArgs({\n', '            amount: args.amount,\n', '            accountOne: accounts[args.accountId],\n', '            accountTwo: accounts[args.otherAccountId],\n', '            market: args.primaryMarketId\n', '        });\n', '    }\n', '\n', '    function parseBuyArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (BuyArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Buy);\n', '        return BuyArgs({\n', '            amount: args.amount,\n', '            account: accounts[args.accountId],\n', '            makerMarket: args.primaryMarketId,\n', '            takerMarket: args.secondaryMarketId,\n', '            exchangeWrapper: args.otherAddress,\n', '            orderData: args.data\n', '        });\n', '    }\n', '\n', '    function parseSellArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (SellArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Sell);\n', '        return SellArgs({\n', '            amount: args.amount,\n', '            account: accounts[args.accountId],\n', '            takerMarket: args.primaryMarketId,\n', '            makerMarket: args.secondaryMarketId,\n', '            exchangeWrapper: args.otherAddress,\n', '            orderData: args.data\n', '        });\n', '    }\n', '\n', '    function parseTradeArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (TradeArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Trade);\n', '        return TradeArgs({\n', '            amount: args.amount,\n', '            takerAccount: accounts[args.accountId],\n', '            makerAccount: accounts[args.otherAccountId],\n', '            inputMarket: args.primaryMarketId,\n', '            outputMarket: args.secondaryMarketId,\n', '            autoTrader: args.otherAddress,\n', '            tradeData: args.data\n', '        });\n', '    }\n', '\n', '    function parseLiquidateArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (LiquidateArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Liquidate);\n', '        return LiquidateArgs({\n', '            amount: args.amount,\n', '            solidAccount: accounts[args.accountId],\n', '            liquidAccount: accounts[args.otherAccountId],\n', '            owedMarket: args.primaryMarketId,\n', '            heldMarket: args.secondaryMarketId\n', '        });\n', '    }\n', '\n', '    function parseVaporizeArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (VaporizeArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Vaporize);\n', '        return VaporizeArgs({\n', '            amount: args.amount,\n', '            solidAccount: accounts[args.accountId],\n', '            vaporAccount: accounts[args.otherAccountId],\n', '            owedMarket: args.primaryMarketId,\n', '            heldMarket: args.secondaryMarketId\n', '        });\n', '    }\n', '\n', '    function parseCallArgs(\n', '        Account.Info[] memory accounts,\n', '        ActionArgs memory args\n', '    )\n', '        internal\n', '        pure\n', '        returns (CallArgs memory)\n', '    {\n', '        assert(args.actionType == ActionType.Call);\n', '        return CallArgs({\n', '            account: accounts[args.accountId],\n', '            callee: args.otherAddress,\n', '            data: args.data\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/lib/Events.sol\n', '\n', '/**\n', ' * @title Events\n', ' * @author dYdX\n', ' *\n', ' * Library to parse and emit logs from which the state of all accounts and indexes can be followed\n', ' */\n', 'library Events {\n', '    using Types for Types.Wei;\n', '    using Storage for Storage.State;\n', '\n', '    // ============ Events ============\n', '\n', '    event LogIndexUpdate(\n', '        uint256 indexed market,\n', '        Interest.Index index\n', '    );\n', '\n', '    event LogOperation(\n', '        address sender\n', '    );\n', '\n', '    event LogDeposit(\n', '        address indexed accountOwner,\n', '        uint256 accountNumber,\n', '        uint256 market,\n', '        BalanceUpdate update,\n', '        address from\n', '    );\n', '\n', '    event LogWithdraw(\n', '        address indexed accountOwner,\n', '        uint256 accountNumber,\n', '        uint256 market,\n', '        BalanceUpdate update,\n', '        address to\n', '    );\n', '\n', '    event LogTransfer(\n', '        address indexed accountOneOwner,\n', '        uint256 accountOneNumber,\n', '        address indexed accountTwoOwner,\n', '        uint256 accountTwoNumber,\n', '        uint256 market,\n', '        BalanceUpdate updateOne,\n', '        BalanceUpdate updateTwo\n', '    );\n', '\n', '    event LogBuy(\n', '        address indexed accountOwner,\n', '        uint256 accountNumber,\n', '        uint256 takerMarket,\n', '        uint256 makerMarket,\n', '        BalanceUpdate takerUpdate,\n', '        BalanceUpdate makerUpdate,\n', '        address exchangeWrapper\n', '    );\n', '\n', '    event LogSell(\n', '        address indexed accountOwner,\n', '        uint256 accountNumber,\n', '        uint256 takerMarket,\n', '        uint256 makerMarket,\n', '        BalanceUpdate takerUpdate,\n', '        BalanceUpdate makerUpdate,\n', '        address exchangeWrapper\n', '    );\n', '\n', '    event LogTrade(\n', '        address indexed takerAccountOwner,\n', '        uint256 takerAccountNumber,\n', '        address indexed makerAccountOwner,\n', '        uint256 makerAccountNumber,\n', '        uint256 inputMarket,\n', '        uint256 outputMarket,\n', '        BalanceUpdate takerInputUpdate,\n', '        BalanceUpdate takerOutputUpdate,\n', '        BalanceUpdate makerInputUpdate,\n', '        BalanceUpdate makerOutputUpdate,\n', '        address autoTrader\n', '    );\n', '\n', '    event LogCall(\n', '        address indexed accountOwner,\n', '        uint256 accountNumber,\n', '        address callee\n', '    );\n', '\n', '    event LogLiquidate(\n', '        address indexed solidAccountOwner,\n', '        uint256 solidAccountNumber,\n', '        address indexed liquidAccountOwner,\n', '        uint256 liquidAccountNumber,\n', '        uint256 heldMarket,\n', '        uint256 owedMarket,\n', '        BalanceUpdate solidHeldUpdate,\n', '        BalanceUpdate solidOwedUpdate,\n', '        BalanceUpdate liquidHeldUpdate,\n', '        BalanceUpdate liquidOwedUpdate\n', '    );\n', '\n', '    event LogVaporize(\n', '        address indexed solidAccountOwner,\n', '        uint256 solidAccountNumber,\n', '        address indexed vaporAccountOwner,\n', '        uint256 vaporAccountNumber,\n', '        uint256 heldMarket,\n', '        uint256 owedMarket,\n', '        BalanceUpdate solidHeldUpdate,\n', '        BalanceUpdate solidOwedUpdate,\n', '        BalanceUpdate vaporOwedUpdate\n', '    );\n', '\n', '    // ============ Structs ============\n', '\n', '    struct BalanceUpdate {\n', '        Types.Wei deltaWei;\n', '        Types.Par newPar;\n', '    }\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    function logIndexUpdate(\n', '        uint256 marketId,\n', '        Interest.Index memory index\n', '    )\n', '        internal\n', '    {\n', '        emit LogIndexUpdate(\n', '            marketId,\n', '            index\n', '        );\n', '    }\n', '\n', '    function logOperation()\n', '        internal\n', '    {\n', '        emit LogOperation(msg.sender);\n', '    }\n', '\n', '    function logDeposit(\n', '        Storage.State storage state,\n', '        Actions.DepositArgs memory args,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        emit LogDeposit(\n', '            args.account.owner,\n', '            args.account.number,\n', '            args.market,\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.market,\n', '                deltaWei\n', '            ),\n', '            args.from\n', '        );\n', '    }\n', '\n', '    function logWithdraw(\n', '        Storage.State storage state,\n', '        Actions.WithdrawArgs memory args,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        emit LogWithdraw(\n', '            args.account.owner,\n', '            args.account.number,\n', '            args.market,\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.market,\n', '                deltaWei\n', '            ),\n', '            args.to\n', '        );\n', '    }\n', '\n', '    function logTransfer(\n', '        Storage.State storage state,\n', '        Actions.TransferArgs memory args,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        emit LogTransfer(\n', '            args.accountOne.owner,\n', '            args.accountOne.number,\n', '            args.accountTwo.owner,\n', '            args.accountTwo.number,\n', '            args.market,\n', '            getBalanceUpdate(\n', '                state,\n', '                args.accountOne,\n', '                args.market,\n', '                deltaWei\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.accountTwo,\n', '                args.market,\n', '                deltaWei.negative()\n', '            )\n', '        );\n', '    }\n', '\n', '    function logBuy(\n', '        Storage.State storage state,\n', '        Actions.BuyArgs memory args,\n', '        Types.Wei memory takerWei,\n', '        Types.Wei memory makerWei\n', '    )\n', '        internal\n', '    {\n', '        emit LogBuy(\n', '            args.account.owner,\n', '            args.account.number,\n', '            args.takerMarket,\n', '            args.makerMarket,\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.takerMarket,\n', '                takerWei\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.makerMarket,\n', '                makerWei\n', '            ),\n', '            args.exchangeWrapper\n', '        );\n', '    }\n', '\n', '    function logSell(\n', '        Storage.State storage state,\n', '        Actions.SellArgs memory args,\n', '        Types.Wei memory takerWei,\n', '        Types.Wei memory makerWei\n', '    )\n', '        internal\n', '    {\n', '        emit LogSell(\n', '            args.account.owner,\n', '            args.account.number,\n', '            args.takerMarket,\n', '            args.makerMarket,\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.takerMarket,\n', '                takerWei\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.account,\n', '                args.makerMarket,\n', '                makerWei\n', '            ),\n', '            args.exchangeWrapper\n', '        );\n', '    }\n', '\n', '    function logTrade(\n', '        Storage.State storage state,\n', '        Actions.TradeArgs memory args,\n', '        Types.Wei memory inputWei,\n', '        Types.Wei memory outputWei\n', '    )\n', '        internal\n', '    {\n', '        BalanceUpdate[4] memory updates = [\n', '            getBalanceUpdate(\n', '                state,\n', '                args.takerAccount,\n', '                args.inputMarket,\n', '                inputWei.negative()\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.takerAccount,\n', '                args.outputMarket,\n', '                outputWei.negative()\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.makerAccount,\n', '                args.inputMarket,\n', '                inputWei\n', '            ),\n', '            getBalanceUpdate(\n', '                state,\n', '                args.makerAccount,\n', '                args.outputMarket,\n', '                outputWei\n', '            )\n', '        ];\n', '\n', '        emit LogTrade(\n', '            args.takerAccount.owner,\n', '            args.takerAccount.number,\n', '            args.makerAccount.owner,\n', '            args.makerAccount.number,\n', '            args.inputMarket,\n', '            args.outputMarket,\n', '            updates[0],\n', '            updates[1],\n', '            updates[2],\n', '            updates[3],\n', '            args.autoTrader\n', '        );\n', '    }\n', '\n', '    function logCall(\n', '        Actions.CallArgs memory args\n', '    )\n', '        internal\n', '    {\n', '        emit LogCall(\n', '            args.account.owner,\n', '            args.account.number,\n', '            args.callee\n', '        );\n', '    }\n', '\n', '    function logLiquidate(\n', '        Storage.State storage state,\n', '        Actions.LiquidateArgs memory args,\n', '        Types.Wei memory heldWei,\n', '        Types.Wei memory owedWei\n', '    )\n', '        internal\n', '    {\n', '        BalanceUpdate memory solidHeldUpdate = getBalanceUpdate(\n', '            state,\n', '            args.solidAccount,\n', '            args.heldMarket,\n', '            heldWei.negative()\n', '        );\n', '        BalanceUpdate memory solidOwedUpdate = getBalanceUpdate(\n', '            state,\n', '            args.solidAccount,\n', '            args.owedMarket,\n', '            owedWei.negative()\n', '        );\n', '        BalanceUpdate memory liquidHeldUpdate = getBalanceUpdate(\n', '            state,\n', '            args.liquidAccount,\n', '            args.heldMarket,\n', '            heldWei\n', '        );\n', '        BalanceUpdate memory liquidOwedUpdate = getBalanceUpdate(\n', '            state,\n', '            args.liquidAccount,\n', '            args.owedMarket,\n', '            owedWei\n', '        );\n', '\n', '        emit LogLiquidate(\n', '            args.solidAccount.owner,\n', '            args.solidAccount.number,\n', '            args.liquidAccount.owner,\n', '            args.liquidAccount.number,\n', '            args.heldMarket,\n', '            args.owedMarket,\n', '            solidHeldUpdate,\n', '            solidOwedUpdate,\n', '            liquidHeldUpdate,\n', '            liquidOwedUpdate\n', '        );\n', '    }\n', '\n', '    function logVaporize(\n', '        Storage.State storage state,\n', '        Actions.VaporizeArgs memory args,\n', '        Types.Wei memory heldWei,\n', '        Types.Wei memory owedWei,\n', '        Types.Wei memory excessWei\n', '    )\n', '        internal\n', '    {\n', '        BalanceUpdate memory solidHeldUpdate = getBalanceUpdate(\n', '            state,\n', '            args.solidAccount,\n', '            args.heldMarket,\n', '            heldWei.negative()\n', '        );\n', '        BalanceUpdate memory solidOwedUpdate = getBalanceUpdate(\n', '            state,\n', '            args.solidAccount,\n', '            args.owedMarket,\n', '            owedWei.negative()\n', '        );\n', '        BalanceUpdate memory vaporOwedUpdate = getBalanceUpdate(\n', '            state,\n', '            args.vaporAccount,\n', '            args.owedMarket,\n', '            owedWei.add(excessWei)\n', '        );\n', '\n', '        emit LogVaporize(\n', '            args.solidAccount.owner,\n', '            args.solidAccount.number,\n', '            args.vaporAccount.owner,\n', '            args.vaporAccount.number,\n', '            args.heldMarket,\n', '            args.owedMarket,\n', '            solidHeldUpdate,\n', '            solidOwedUpdate,\n', '            vaporOwedUpdate\n', '        );\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function getBalanceUpdate(\n', '        Storage.State storage state,\n', '        Account.Info memory account,\n', '        uint256 market,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        private\n', '        view\n', '        returns (BalanceUpdate memory)\n', '    {\n', '        return BalanceUpdate({\n', '            deltaWei: deltaWei,\n', '            newPar: state.getPar(account, market)\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/interfaces/IExchangeWrapper.sol\n', '\n', '/**\n', ' * @title IExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Interface that Exchange Wrappers for Solo must implement in order to trade ERC20 tokens.\n', ' */\n', 'interface IExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes calldata orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the exchange\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes calldata orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/protocol/lib/Exchange.sol\n', '\n', '/**\n', ' * @title Exchange\n', ' * @author dYdX\n', ' *\n', ' * Library for transferring tokens and interacting with ExchangeWrappers by using the Wei struct\n', ' */\n', 'library Exchange {\n', '    using Types for Types.Wei;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "Exchange";\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function transferOut(\n', '        address token,\n', '        address to,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        Require.that(\n', '            !deltaWei.isPositive(),\n', '            FILE,\n', '            "Cannot transferOut positive",\n', '            deltaWei.value\n', '        );\n', '\n', '        Token.transfer(\n', '            token,\n', '            to,\n', '            deltaWei.value\n', '        );\n', '    }\n', '\n', '    function transferIn(\n', '        address token,\n', '        address from,\n', '        Types.Wei memory deltaWei\n', '    )\n', '        internal\n', '    {\n', '        Require.that(\n', '            !deltaWei.isNegative(),\n', '            FILE,\n', '            "Cannot transferIn negative",\n', '            deltaWei.value\n', '        );\n', '\n', '        Token.transferFrom(\n', '            token,\n', '            from,\n', '            address(this),\n', '            deltaWei.value\n', '        );\n', '    }\n', '\n', '    function getCost(\n', '        address exchangeWrapper,\n', '        address supplyToken,\n', '        address borrowToken,\n', '        Types.Wei memory desiredAmount,\n', '        bytes memory orderData\n', '    )\n', '        internal\n', '        view\n', '        returns (Types.Wei memory)\n', '    {\n', '        Require.that(\n', '            !desiredAmount.isNegative(),\n', '            FILE,\n', '            "Cannot getCost negative",\n', '            desiredAmount.value\n', '        );\n', '\n', '        Types.Wei memory result;\n', '        result.sign = false;\n', '        result.value = IExchangeWrapper(exchangeWrapper).getExchangeCost(\n', '            supplyToken,\n', '            borrowToken,\n', '            desiredAmount.value,\n', '            orderData\n', '        );\n', '\n', '        return result;\n', '    }\n', '\n', '    function exchange(\n', '        address exchangeWrapper,\n', '        address accountOwner,\n', '        address supplyToken,\n', '        address borrowToken,\n', '        Types.Wei memory requestedFillAmount,\n', '        bytes memory orderData\n', '    )\n', '        internal\n', '        returns (Types.Wei memory)\n', '    {\n', '        Require.that(\n', '            !requestedFillAmount.isPositive(),\n', '            FILE,\n', '            "Cannot exchange positive",\n', '            requestedFillAmount.value\n', '        );\n', '\n', '        transferOut(borrowToken, exchangeWrapper, requestedFillAmount);\n', '\n', '        Types.Wei memory result;\n', '        result.sign = true;\n', '        result.value = IExchangeWrapper(exchangeWrapper).exchange(\n', '            accountOwner,\n', '            address(this),\n', '            supplyToken,\n', '            borrowToken,\n', '            requestedFillAmount.value,\n', '            orderData\n', '        );\n', '\n', '        transferIn(supplyToken, exchangeWrapper, result);\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/impl/OperationImpl.sol\n', '\n', '/**\n', ' * @title OperationImpl\n', ' * @author dYdX\n', ' *\n', ' * Logic for processing actions\n', ' */\n', 'library OperationImpl {\n', '    using Cache for Cache.MarketCache;\n', '    using SafeMath for uint256;\n', '    using Storage for Storage.State;\n', '    using Types for Types.Par;\n', '    using Types for Types.Wei;\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "OperationImpl";\n', '\n', '    // ============ Public Functions ============\n', '\n', '    function operate(\n', '        Storage.State storage state,\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions\n', '    )\n', '        public\n', '    {\n', '        Events.logOperation();\n', '\n', '        _verifyInputs(accounts, actions);\n', '\n', '        (\n', '            bool[] memory primaryAccounts,\n', '            Cache.MarketCache memory cache\n', '        ) = _runPreprocessing(\n', '            state,\n', '            accounts,\n', '            actions\n', '        );\n', '\n', '        _runActions(\n', '            state,\n', '            accounts,\n', '            actions,\n', '            cache\n', '        );\n', '\n', '        _verifyFinalState(\n', '            state,\n', '            accounts,\n', '            primaryAccounts,\n', '            cache\n', '        );\n', '    }\n', '\n', '    // ============ Helper Functions ============\n', '\n', '    function _verifyInputs(\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        Require.that(\n', '            actions.length != 0,\n', '            FILE,\n', '            "Cannot have zero actions"\n', '        );\n', '\n', '        Require.that(\n', '            accounts.length != 0,\n', '            FILE,\n', '            "Cannot have zero accounts"\n', '        );\n', '\n', '        for (uint256 a = 0; a < accounts.length; a++) {\n', '            for (uint256 b = a + 1; b < accounts.length; b++) {\n', '                Require.that(\n', '                    !Account.equals(accounts[a], accounts[b]),\n', '                    FILE,\n', '                    "Cannot duplicate accounts",\n', '                    a,\n', '                    b\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    function _runPreprocessing(\n', '        Storage.State storage state,\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions\n', '    )\n', '        private\n', '        returns (\n', '            bool[] memory,\n', '            Cache.MarketCache memory\n', '        )\n', '    {\n', '        uint256 numMarkets = state.numMarkets;\n', '        bool[] memory primaryAccounts = new bool[](accounts.length);\n', '        Cache.MarketCache memory cache = Cache.create(numMarkets);\n', '\n', '        // keep track of primary accounts and indexes that need updating\n', '        for (uint256 i = 0; i < actions.length; i++) {\n', '            Actions.ActionArgs memory arg = actions[i];\n', '            Actions.ActionType actionType = arg.actionType;\n', '            Actions.MarketLayout marketLayout = Actions.getMarketLayout(actionType);\n', '            Actions.AccountLayout accountLayout = Actions.getAccountLayout(actionType);\n', '\n', '            // parse out primary accounts\n', '            if (accountLayout != Actions.AccountLayout.OnePrimary) {\n', '                Require.that(\n', '                    arg.accountId != arg.otherAccountId,\n', '                    FILE,\n', '                    "Duplicate accounts in action",\n', '                    i\n', '                );\n', '                if (accountLayout == Actions.AccountLayout.TwoPrimary) {\n', '                    primaryAccounts[arg.otherAccountId] = true;\n', '                } else {\n', '                    assert(accountLayout == Actions.AccountLayout.PrimaryAndSecondary);\n', '                    Require.that(\n', '                        !primaryAccounts[arg.otherAccountId],\n', '                        FILE,\n', '                        "Requires non-primary account",\n', '                        arg.otherAccountId\n', '                    );\n', '                }\n', '            }\n', '            primaryAccounts[arg.accountId] = true;\n', '\n', '            // keep track of indexes to update\n', '            if (marketLayout == Actions.MarketLayout.OneMarket) {\n', '                _updateMarket(state, cache, arg.primaryMarketId);\n', '            } else if (marketLayout == Actions.MarketLayout.TwoMarkets) {\n', '                Require.that(\n', '                    arg.primaryMarketId != arg.secondaryMarketId,\n', '                    FILE,\n', '                    "Duplicate markets in action",\n', '                    i\n', '                );\n', '                _updateMarket(state, cache, arg.primaryMarketId);\n', '                _updateMarket(state, cache, arg.secondaryMarketId);\n', '            } else {\n', '                assert(marketLayout == Actions.MarketLayout.ZeroMarkets);\n', '            }\n', '        }\n', '\n', '        // get any other markets for which an account has a balance\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (cache.hasMarket(m)) {\n', '                continue;\n', '            }\n', '            for (uint256 a = 0; a < accounts.length; a++) {\n', '                if (!state.getPar(accounts[a], m).isZero()) {\n', '                    _updateMarket(state, cache, m);\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return (primaryAccounts, cache);\n', '    }\n', '\n', '    function _updateMarket(\n', '        Storage.State storage state,\n', '        Cache.MarketCache memory cache,\n', '        uint256 marketId\n', '    )\n', '        private\n', '    {\n', '        bool updated = cache.addMarket(state, marketId);\n', '        if (updated) {\n', '            Events.logIndexUpdate(marketId, state.updateIndex(marketId));\n', '        }\n', '    }\n', '\n', '    function _runActions(\n', '        Storage.State storage state,\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions,\n', '        Cache.MarketCache memory cache\n', '    )\n', '        private\n', '    {\n', '        for (uint256 i = 0; i < actions.length; i++) {\n', '            Actions.ActionArgs memory action = actions[i];\n', '            Actions.ActionType actionType = action.actionType;\n', '\n', '            if (actionType == Actions.ActionType.Deposit) {\n', '                _deposit(state, Actions.parseDepositArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Withdraw) {\n', '                _withdraw(state, Actions.parseWithdrawArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Transfer) {\n', '                _transfer(state, Actions.parseTransferArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Buy) {\n', '                _buy(state, Actions.parseBuyArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Sell) {\n', '                _sell(state, Actions.parseSellArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Trade) {\n', '                _trade(state, Actions.parseTradeArgs(accounts, action));\n', '            }\n', '            else if (actionType == Actions.ActionType.Liquidate) {\n', '                _liquidate(state, Actions.parseLiquidateArgs(accounts, action), cache);\n', '            }\n', '            else if (actionType == Actions.ActionType.Vaporize) {\n', '                _vaporize(state, Actions.parseVaporizeArgs(accounts, action), cache);\n', '            }\n', '            else  {\n', '                assert(actionType == Actions.ActionType.Call);\n', '                _call(state, Actions.parseCallArgs(accounts, action));\n', '            }\n', '        }\n', '    }\n', '\n', '    function _verifyFinalState(\n', '        Storage.State storage state,\n', '        Account.Info[] memory accounts,\n', '        bool[] memory primaryAccounts,\n', '        Cache.MarketCache memory cache\n', '    )\n', '        private\n', '    {\n', '        // verify no increase in borrowPar for closing markets\n', '        uint256 numMarkets = cache.getNumMarkets();\n', '        for (uint256 m = 0; m < numMarkets; m++) {\n', '            if (cache.getIsClosing(m)) {\n', '                Require.that(\n', '                    state.getTotalPar(m).borrow <= cache.getBorrowPar(m),\n', '                    FILE,\n', '                    "Market is closing",\n', '                    m\n', '                );\n', '            }\n', '        }\n', '\n', '        // verify account collateralization\n', '        for (uint256 a = 0; a < accounts.length; a++) {\n', '            Account.Info memory account = accounts[a];\n', '\n', '            // validate minBorrowedValue\n', '            bool collateralized = state.isCollateralized(account, cache, true);\n', '\n', "            // don't check collateralization for non-primary accounts\n", '            if (!primaryAccounts[a]) {\n', '                continue;\n', '            }\n', '\n', '            // check collateralization for primary accounts\n', '            Require.that(\n', '                collateralized,\n', '                FILE,\n', '                "Undercollateralized account",\n', '                account.owner,\n', '                account.number\n', '            );\n', '\n', '            // ensure status is normal for primary accounts\n', '            if (state.getStatus(account) != Account.Status.Normal) {\n', '                state.setStatus(account, Account.Status.Normal);\n', '            }\n', '        }\n', '    }\n', '\n', '    // ============ Action Functions ============\n', '\n', '    function _deposit(\n', '        Storage.State storage state,\n', '        Actions.DepositArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.account, msg.sender);\n', '\n', '        Require.that(\n', '            args.from == msg.sender || args.from == args.account.owner,\n', '            FILE,\n', '            "Invalid deposit source",\n', '            args.from\n', '        );\n', '\n', '        (\n', '            Types.Par memory newPar,\n', '            Types.Wei memory deltaWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.account,\n', '            args.market,\n', '            args.amount\n', '        );\n', '\n', '        state.setPar(\n', '            args.account,\n', '            args.market,\n', '            newPar\n', '        );\n', '\n', '        // requires a positive deltaWei\n', '        Exchange.transferIn(\n', '            state.getToken(args.market),\n', '            args.from,\n', '            deltaWei\n', '        );\n', '\n', '        Events.logDeposit(\n', '            state,\n', '            args,\n', '            deltaWei\n', '        );\n', '    }\n', '\n', '    function _withdraw(\n', '        Storage.State storage state,\n', '        Actions.WithdrawArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.account, msg.sender);\n', '\n', '        (\n', '            Types.Par memory newPar,\n', '            Types.Wei memory deltaWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.account,\n', '            args.market,\n', '            args.amount\n', '        );\n', '\n', '        state.setPar(\n', '            args.account,\n', '            args.market,\n', '            newPar\n', '        );\n', '\n', '        // requires a negative deltaWei\n', '        Exchange.transferOut(\n', '            state.getToken(args.market),\n', '            args.to,\n', '            deltaWei\n', '        );\n', '\n', '        Events.logWithdraw(\n', '            state,\n', '            args,\n', '            deltaWei\n', '        );\n', '    }\n', '\n', '    function _transfer(\n', '        Storage.State storage state,\n', '        Actions.TransferArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.accountOne, msg.sender);\n', '        state.requireIsOperator(args.accountTwo, msg.sender);\n', '\n', '        (\n', '            Types.Par memory newPar,\n', '            Types.Wei memory deltaWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.accountOne,\n', '            args.market,\n', '            args.amount\n', '        );\n', '\n', '        state.setPar(\n', '            args.accountOne,\n', '            args.market,\n', '            newPar\n', '        );\n', '\n', '        state.setParFromDeltaWei(\n', '            args.accountTwo,\n', '            args.market,\n', '            deltaWei.negative()\n', '        );\n', '\n', '        Events.logTransfer(\n', '            state,\n', '            args,\n', '            deltaWei\n', '        );\n', '    }\n', '\n', '    function _buy(\n', '        Storage.State storage state,\n', '        Actions.BuyArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.account, msg.sender);\n', '\n', '        address takerToken = state.getToken(args.takerMarket);\n', '        address makerToken = state.getToken(args.makerMarket);\n', '\n', '        (\n', '            Types.Par memory makerPar,\n', '            Types.Wei memory makerWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.account,\n', '            args.makerMarket,\n', '            args.amount\n', '        );\n', '\n', '        Types.Wei memory takerWei = Exchange.getCost(\n', '            args.exchangeWrapper,\n', '            makerToken,\n', '            takerToken,\n', '            makerWei,\n', '            args.orderData\n', '        );\n', '\n', '        Types.Wei memory tokensReceived = Exchange.exchange(\n', '            args.exchangeWrapper,\n', '            args.account.owner,\n', '            makerToken,\n', '            takerToken,\n', '            takerWei,\n', '            args.orderData\n', '        );\n', '\n', '        Require.that(\n', '            tokensReceived.value >= makerWei.value,\n', '            FILE,\n', '            "Buy amount less than promised",\n', '            tokensReceived.value,\n', '            makerWei.value\n', '        );\n', '\n', '        state.setPar(\n', '            args.account,\n', '            args.makerMarket,\n', '            makerPar\n', '        );\n', '\n', '        state.setParFromDeltaWei(\n', '            args.account,\n', '            args.takerMarket,\n', '            takerWei\n', '        );\n', '\n', '        Events.logBuy(\n', '            state,\n', '            args,\n', '            takerWei,\n', '            makerWei\n', '        );\n', '    }\n', '\n', '    function _sell(\n', '        Storage.State storage state,\n', '        Actions.SellArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.account, msg.sender);\n', '\n', '        address takerToken = state.getToken(args.takerMarket);\n', '        address makerToken = state.getToken(args.makerMarket);\n', '\n', '        (\n', '            Types.Par memory takerPar,\n', '            Types.Wei memory takerWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.account,\n', '            args.takerMarket,\n', '            args.amount\n', '        );\n', '\n', '        Types.Wei memory makerWei = Exchange.exchange(\n', '            args.exchangeWrapper,\n', '            args.account.owner,\n', '            makerToken,\n', '            takerToken,\n', '            takerWei,\n', '            args.orderData\n', '        );\n', '\n', '        state.setPar(\n', '            args.account,\n', '            args.takerMarket,\n', '            takerPar\n', '        );\n', '\n', '        state.setParFromDeltaWei(\n', '            args.account,\n', '            args.makerMarket,\n', '            makerWei\n', '        );\n', '\n', '        Events.logSell(\n', '            state,\n', '            args,\n', '            takerWei,\n', '            makerWei\n', '        );\n', '    }\n', '\n', '    function _trade(\n', '        Storage.State storage state,\n', '        Actions.TradeArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.takerAccount, msg.sender);\n', '        state.requireIsOperator(args.makerAccount, args.autoTrader);\n', '\n', '        Types.Par memory oldInputPar = state.getPar(\n', '            args.makerAccount,\n', '            args.inputMarket\n', '        );\n', '        (\n', '            Types.Par memory newInputPar,\n', '            Types.Wei memory inputWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.makerAccount,\n', '            args.inputMarket,\n', '            args.amount\n', '        );\n', '\n', '        Types.AssetAmount memory outputAmount = IAutoTrader(args.autoTrader).getTradeCost(\n', '            args.inputMarket,\n', '            args.outputMarket,\n', '            args.makerAccount,\n', '            args.takerAccount,\n', '            oldInputPar,\n', '            newInputPar,\n', '            inputWei,\n', '            args.tradeData\n', '        );\n', '\n', '        (\n', '            Types.Par memory newOutputPar,\n', '            Types.Wei memory outputWei\n', '        ) = state.getNewParAndDeltaWei(\n', '            args.makerAccount,\n', '            args.outputMarket,\n', '            outputAmount\n', '        );\n', '\n', '        Require.that(\n', '            outputWei.isZero() || inputWei.isZero() || outputWei.sign != inputWei.sign,\n', '            FILE,\n', '            "Trades cannot be one-sided"\n', '        );\n', '\n', '        // set the balance for the maker\n', '        state.setPar(\n', '            args.makerAccount,\n', '            args.inputMarket,\n', '            newInputPar\n', '        );\n', '        state.setPar(\n', '            args.makerAccount,\n', '            args.outputMarket,\n', '            newOutputPar\n', '        );\n', '\n', '        // set the balance for the taker\n', '        state.setParFromDeltaWei(\n', '            args.takerAccount,\n', '            args.inputMarket,\n', '            inputWei.negative()\n', '        );\n', '        state.setParFromDeltaWei(\n', '            args.takerAccount,\n', '            args.outputMarket,\n', '            outputWei.negative()\n', '        );\n', '\n', '        Events.logTrade(\n', '            state,\n', '            args,\n', '            inputWei,\n', '            outputWei\n', '        );\n', '    }\n', '\n', '    function _liquidate(\n', '        Storage.State storage state,\n', '        Actions.LiquidateArgs memory args,\n', '        Cache.MarketCache memory cache\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.solidAccount, msg.sender);\n', '\n', '        // verify liquidatable\n', '        if (Account.Status.Liquid != state.getStatus(args.liquidAccount)) {\n', '            Require.that(\n', '                !state.isCollateralized(args.liquidAccount, cache, /* requireMinBorrow = */ false),\n', '                FILE,\n', '                "Unliquidatable account",\n', '                args.liquidAccount.owner,\n', '                args.liquidAccount.number\n', '            );\n', '            state.setStatus(args.liquidAccount, Account.Status.Liquid);\n', '        }\n', '\n', '        Types.Wei memory maxHeldWei = state.getWei(\n', '            args.liquidAccount,\n', '            args.heldMarket\n', '        );\n', '\n', '        Require.that(\n', '            !maxHeldWei.isNegative(),\n', '            FILE,\n', '            "Collateral cannot be negative",\n', '            args.liquidAccount.owner,\n', '            args.liquidAccount.number,\n', '            args.heldMarket\n', '        );\n', '\n', '        (\n', '            Types.Par memory owedPar,\n', '            Types.Wei memory owedWei\n', '        ) = state.getNewParAndDeltaWeiForLiquidation(\n', '            args.liquidAccount,\n', '            args.owedMarket,\n', '            args.amount\n', '        );\n', '\n', '        (\n', '            Monetary.Price memory heldPrice,\n', '            Monetary.Price memory owedPrice\n', '        ) = _getLiquidationPrices(\n', '            state,\n', '            cache,\n', '            args.heldMarket,\n', '            args.owedMarket\n', '        );\n', '\n', '        Types.Wei memory heldWei = _owedWeiToHeldWei(owedWei, heldPrice, owedPrice);\n', '\n', '        // if attempting to over-borrow the held asset, bound it by the maximum\n', '        if (heldWei.value > maxHeldWei.value) {\n', '            heldWei = maxHeldWei.negative();\n', '            owedWei = _heldWeiToOwedWei(heldWei, heldPrice, owedPrice);\n', '\n', '            state.setPar(\n', '                args.liquidAccount,\n', '                args.heldMarket,\n', '                Types.zeroPar()\n', '            );\n', '            state.setParFromDeltaWei(\n', '                args.liquidAccount,\n', '                args.owedMarket,\n', '                owedWei\n', '            );\n', '        } else {\n', '            state.setPar(\n', '                args.liquidAccount,\n', '                args.owedMarket,\n', '                owedPar\n', '            );\n', '            state.setParFromDeltaWei(\n', '                args.liquidAccount,\n', '                args.heldMarket,\n', '                heldWei\n', '            );\n', '        }\n', '\n', '        // set the balances for the solid account\n', '        state.setParFromDeltaWei(\n', '            args.solidAccount,\n', '            args.owedMarket,\n', '            owedWei.negative()\n', '        );\n', '        state.setParFromDeltaWei(\n', '            args.solidAccount,\n', '            args.heldMarket,\n', '            heldWei.negative()\n', '        );\n', '\n', '        Events.logLiquidate(\n', '            state,\n', '            args,\n', '            heldWei,\n', '            owedWei\n', '        );\n', '    }\n', '\n', '    function _vaporize(\n', '        Storage.State storage state,\n', '        Actions.VaporizeArgs memory args,\n', '        Cache.MarketCache memory cache\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.solidAccount, msg.sender);\n', '\n', '        // verify vaporizable\n', '        if (Account.Status.Vapor != state.getStatus(args.vaporAccount)) {\n', '            Require.that(\n', '                state.isVaporizable(args.vaporAccount, cache),\n', '                FILE,\n', '                "Unvaporizable account",\n', '                args.vaporAccount.owner,\n', '                args.vaporAccount.number\n', '            );\n', '            state.setStatus(args.vaporAccount, Account.Status.Vapor);\n', '        }\n', '\n', '        // First, attempt to refund using the same token\n', '        (\n', '            bool fullyRepaid,\n', '            Types.Wei memory excessWei\n', '        ) = _vaporizeUsingExcess(state, args);\n', '        if (fullyRepaid) {\n', '            Events.logVaporize(\n', '                state,\n', '                args,\n', '                Types.zeroWei(),\n', '                Types.zeroWei(),\n', '                excessWei\n', '            );\n', '            return;\n', '        }\n', '\n', '        Types.Wei memory maxHeldWei = state.getNumExcessTokens(args.heldMarket);\n', '\n', '        Require.that(\n', '            !maxHeldWei.isNegative(),\n', '            FILE,\n', '            "Excess cannot be negative",\n', '            args.heldMarket\n', '        );\n', '\n', '        (\n', '            Types.Par memory owedPar,\n', '            Types.Wei memory owedWei\n', '        ) = state.getNewParAndDeltaWeiForLiquidation(\n', '            args.vaporAccount,\n', '            args.owedMarket,\n', '            args.amount\n', '        );\n', '\n', '        (\n', '            Monetary.Price memory heldPrice,\n', '            Monetary.Price memory owedPrice\n', '        ) = _getLiquidationPrices(\n', '            state,\n', '            cache,\n', '            args.heldMarket,\n', '            args.owedMarket\n', '        );\n', '\n', '        Types.Wei memory heldWei = _owedWeiToHeldWei(owedWei, heldPrice, owedPrice);\n', '\n', '        // if attempting to over-borrow the held asset, bound it by the maximum\n', '        if (heldWei.value > maxHeldWei.value) {\n', '            heldWei = maxHeldWei.negative();\n', '            owedWei = _heldWeiToOwedWei(heldWei, heldPrice, owedPrice);\n', '\n', '            state.setParFromDeltaWei(\n', '                args.vaporAccount,\n', '                args.owedMarket,\n', '                owedWei\n', '            );\n', '        } else {\n', '            state.setPar(\n', '                args.vaporAccount,\n', '                args.owedMarket,\n', '                owedPar\n', '            );\n', '        }\n', '\n', '        // set the balances for the solid account\n', '        state.setParFromDeltaWei(\n', '            args.solidAccount,\n', '            args.owedMarket,\n', '            owedWei.negative()\n', '        );\n', '        state.setParFromDeltaWei(\n', '            args.solidAccount,\n', '            args.heldMarket,\n', '            heldWei.negative()\n', '        );\n', '\n', '        Events.logVaporize(\n', '            state,\n', '            args,\n', '            heldWei,\n', '            owedWei,\n', '            excessWei\n', '        );\n', '    }\n', '\n', '    function _call(\n', '        Storage.State storage state,\n', '        Actions.CallArgs memory args\n', '    )\n', '        private\n', '    {\n', '        state.requireIsOperator(args.account, msg.sender);\n', '\n', '        ICallee(args.callee).callFunction(\n', '            msg.sender,\n', '            args.account,\n', '            args.data\n', '        );\n', '\n', '        Events.logCall(args);\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * For the purposes of liquidation or vaporization, get the value-equivalent amount of heldWei\n', '     * given owedWei and the (spread-adjusted) prices of each asset.\n', '     */\n', '    function _owedWeiToHeldWei(\n', '        Types.Wei memory owedWei,\n', '        Monetary.Price memory heldPrice,\n', '        Monetary.Price memory owedPrice\n', '    )\n', '        private\n', '        pure\n', '        returns (Types.Wei memory)\n', '    {\n', '        return Types.Wei({\n', '            sign: false,\n', '            value: Math.getPartial(owedWei.value, owedPrice.value, heldPrice.value)\n', '        });\n', '    }\n', '\n', '    /**\n', '     * For the purposes of liquidation or vaporization, get the value-equivalent amount of owedWei\n', '     * given heldWei and the (spread-adjusted) prices of each asset.\n', '     */\n', '    function _heldWeiToOwedWei(\n', '        Types.Wei memory heldWei,\n', '        Monetary.Price memory heldPrice,\n', '        Monetary.Price memory owedPrice\n', '    )\n', '        private\n', '        pure\n', '        returns (Types.Wei memory)\n', '    {\n', '        return Types.Wei({\n', '            sign: true,\n', '            value: Math.getPartialRoundUp(heldWei.value, heldPrice.value, owedPrice.value)\n', '        });\n', '    }\n', '\n', '    /**\n', "     * Attempt to vaporize an account's balance using the excess tokens in the protocol. Return a\n", '     * bool and a wei value. The boolean is true if and only if the balance was fully vaporized. The\n', "     * Wei value is how many excess tokens were used to partially or fully vaporize the account's\n", '     * negative balance.\n', '     */\n', '    function _vaporizeUsingExcess(\n', '        Storage.State storage state,\n', '        Actions.VaporizeArgs memory args\n', '    )\n', '        internal\n', '        returns (bool, Types.Wei memory)\n', '    {\n', '        Types.Wei memory excessWei = state.getNumExcessTokens(args.owedMarket);\n', '\n', '        // There are no excess funds, return zero\n', '        if (!excessWei.isPositive()) {\n', '            return (false, Types.zeroWei());\n', '        }\n', '\n', '        Types.Wei memory maxRefundWei = state.getWei(args.vaporAccount, args.owedMarket);\n', '        maxRefundWei.sign = true;\n', '\n', '        // The account is fully vaporizable using excess funds\n', '        if (excessWei.value >= maxRefundWei.value) {\n', '            state.setPar(\n', '                args.vaporAccount,\n', '                args.owedMarket,\n', '                Types.zeroPar()\n', '            );\n', '            return (true, maxRefundWei);\n', '        }\n', '\n', '        // The account is only partially vaporizable using excess funds\n', '        else {\n', '            state.setParFromDeltaWei(\n', '                args.vaporAccount,\n', '                args.owedMarket,\n', '                excessWei\n', '            );\n', '            return (false, excessWei);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the (spread-adjusted) prices of two assets for the purposes of liquidation or\n', '     * vaporization.\n', '     */\n', '    function _getLiquidationPrices(\n', '        Storage.State storage state,\n', '        Cache.MarketCache memory cache,\n', '        uint256 heldMarketId,\n', '        uint256 owedMarketId\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            Monetary.Price memory,\n', '            Monetary.Price memory\n', '        )\n', '    {\n', '        uint256 originalPrice = cache.getPrice(owedMarketId).value;\n', '        Decimal.D256 memory spread = state.getLiquidationSpreadForPair(\n', '            heldMarketId,\n', '            owedMarketId\n', '        );\n', '\n', '        Monetary.Price memory owedPrice = Monetary.Price({\n', '            value: originalPrice.add(Decimal.mul(originalPrice, spread))\n', '        });\n', '\n', '        return (cache.getPrice(heldMarketId), owedPrice);\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/Operation.sol\n', '\n', '/**\n', ' * @title Operation\n', ' * @author dYdX\n', ' *\n', ' * Primary public function for allowing users and contracts to manage accounts within Solo\n', ' */\n', 'contract Operation is\n', '    State,\n', '    ReentrancyGuard\n', '{\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * The main entry-point to Solo that allows users and contracts to manage accounts.\n', '     * Take one or more actions on one or more accounts. The msg.sender must be the owner or\n', '     * operator of all accounts except for those being liquidated, vaporized, or traded with.\n', '     * One call to operate() is considered a singular "operation". Account collateralization is\n', '     * ensured only after the completion of the entire operation.\n', '     *\n', '     * @param  accounts  A list of all accounts that will be used in this operation. Cannot contain\n', '     *                   duplicates. In each action, the relevant account will be referred-to by its\n', '     *                   index in the list.\n', '     * @param  actions   An ordered list of all actions that will be taken in this operation. The\n', '     *                   actions will be processed in order.\n', '     */\n', '    function operate(\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions\n', '    )\n', '        public\n', '        nonReentrant\n', '    {\n', '        OperationImpl.operate(\n', '            g_state,\n', '            accounts,\n', '            actions\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/Permission.sol\n', '\n', '/**\n', ' * @title Permission\n', ' * @author dYdX\n', ' *\n', ' * Public function that allows other addresses to manage accounts\n', ' */\n', 'contract Permission is\n', '    State\n', '{\n', '    // ============ Events ============\n', '\n', '    event LogOperatorSet(\n', '        address indexed owner,\n', '        address operator,\n', '        bool trusted\n', '    );\n', '\n', '    // ============ Structs ============\n', '\n', '    struct OperatorArg {\n', '        address operator;\n', '        bool trusted;\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Approves/disapproves any number of operators. An operator is an external address that has the\n', '     * same permissions to manipulate an account as the owner of the account. Operators are simply\n', '     * addresses and therefore may either be externally-owned Ethereum accounts OR smart contracts.\n', '     *\n', '     * Operators are also able to act as AutoTrader contracts on behalf of the account owner if the\n', '     * operator is a smart contract and implements the IAutoTrader interface.\n', '     *\n', '     * @param  args  A list of OperatorArgs which have an address and a boolean. The boolean value\n', '     *               denotes whether to approve (true) or revoke approval (false) for that address.\n', '     */\n', '    function setOperators(\n', '        OperatorArg[] memory args\n', '    )\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < args.length; i++) {\n', '            address operator = args[i].operator;\n', '            bool trusted = args[i].trusted;\n', '            g_state.operators[msg.sender][operator] = trusted;\n', '            emit LogOperatorSet(msg.sender, operator, trusted);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/protocol/SoloMargin.sol\n', '\n', '/**\n', ' * @title SoloMargin\n', ' * @author dYdX\n', ' *\n', ' * Main contract that inherits from other contracts\n', ' */\n', 'contract SoloMargin is\n', '    State,\n', '    Admin,\n', '    Getters,\n', '    Operation,\n', '    Permission\n', '{\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        Storage.RiskParams memory riskParams,\n', '        Storage.RiskLimits memory riskLimits\n', '    )\n', '        public\n', '    {\n', '        g_state.riskParams = riskParams;\n', '        g_state.riskLimits = riskLimits;\n', '    }\n', '}\n', '\n', '// File: contracts/external/helpers/OnlySolo.sol\n', '\n', '/**\n', ' * @title OnlySolo\n', ' * @author dYdX\n', ' *\n', ' * Inheritable contract that restricts the calling of certain functions to Solo only\n', ' */\n', 'contract OnlySolo {\n', '\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "OnlySolo";\n', '\n', '    // ============ Storage ============\n', '\n', '    SoloMargin public SOLO_MARGIN;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor (\n', '        address soloMargin\n', '    )\n', '        public\n', '    {\n', '        SOLO_MARGIN = SoloMargin(soloMargin);\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlySolo(address from) {\n', '        Require.that(\n', '            from == address(SOLO_MARGIN),\n', '            FILE,\n', '            "Only Solo can call function",\n', '            from\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxies/PayableProxyForSoloMargin.sol\n', '\n', '/**\n', ' * @title PayableProxyForSoloMargin\n', ' * @author dYdX\n', ' *\n', ' * Contract for wrapping/unwrapping ETH before/after interacting with Solo\n', ' */\n', 'contract PayableProxyForSoloMargin is\n', '    OnlySolo,\n', '    ReentrancyGuard\n', '{\n', '    // ============ Constants ============\n', '\n', '    bytes32 constant FILE = "PayableProxyForSoloMargin";\n', '\n', '    // ============ Storage ============\n', '\n', '    WETH9 public WETH;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor (\n', '        address soloMargin,\n', '        address payable weth\n', '    )\n', '        public\n', '        OnlySolo(soloMargin)\n', '    {\n', '        WETH = WETH9(weth);\n', '        WETH.approve(soloMargin, uint256(-1));\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Fallback function. Disallows ether to be sent to this contract without data except when\n', '     * unwrapping WETH.\n', '     */\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        require( // coverage-disable-line\n', '            msg.sender == address(WETH),\n', '            "Cannot receive ETH"\n', '        );\n', '    }\n', '\n', '    function operate(\n', '        Account.Info[] memory accounts,\n', '        Actions.ActionArgs[] memory actions,\n', '        address payable sendEthTo\n', '    )\n', '        public\n', '        payable\n', '        nonReentrant\n', '    {\n', '        WETH9 weth = WETH;\n', '\n', '        // create WETH from ETH\n', '        if (msg.value != 0) {\n', '            weth.deposit.value(msg.value)();\n', '        }\n', '\n', '        // validate the input\n', '        for (uint256 i = 0; i < actions.length; i++) {\n', '            Actions.ActionArgs memory action = actions[i];\n', '\n', '            // Can only operate on accounts owned by msg.sender\n', '            address owner1 = accounts[action.accountId].owner;\n', '            Require.that(\n', '                owner1 == msg.sender,\n', '                FILE,\n', '                "Sender must be primary account",\n', '                owner1\n', '            );\n', '\n', '            // For a transfer both accounts must be owned by msg.sender\n', '            if (action.actionType == Actions.ActionType.Transfer) {\n', '                address owner2 = accounts[action.otherAccountId].owner;\n', '                Require.that(\n', '                    owner2 == msg.sender,\n', '                    FILE,\n', '                    "Sender must be secondary account",\n', '                    owner2\n', '                );\n', '            }\n', '        }\n', '\n', '        SOLO_MARGIN.operate(accounts, actions);\n', '\n', '        // return all remaining WETH to the sendEthTo as ETH\n', '        uint256 remainingWeth = weth.balanceOf(address(this));\n', '        if (remainingWeth != 0) {\n', '            Require.that(\n', '                sendEthTo != address(0),\n', '                FILE,\n', '                "Must set sendEthTo"\n', '            );\n', '\n', '            weth.withdraw(remainingWeth);\n', '            sendEthTo.transfer(remainingWeth);\n', '        }\n', '    }\n', '}']