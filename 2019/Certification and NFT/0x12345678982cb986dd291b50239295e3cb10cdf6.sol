['pragma solidity ^0.5.3;\n', '\n', '// counter.market smart contracts:\n', '//  1) Proxy - delegatecalls into current exchange code, maintains storage of exchange state\n', '//  2) Registry (this one) - stores information on the latest exchange contract version and user approvals\n', '//  3) Treasury - takes custody of funds, moves them between token accounts, authorizing exchange code via\n', '\n', '// Counter contracts are deployed at predefined addresses which can be hardcoded.\n', 'contract FixedAddress {\n', '    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\n', '    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\n', '    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\n', '}\n', '\n', '// External contracts access Registry via one of these methods\n', 'interface RegistryInterface {\n', '    function getOwner() external view returns (address);\n', '    function getExchangeContract() external view returns (address);\n', '    function contractApproved(address traderAddr) external view returns (bool);\n', '    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool);\n', '    function acceptNextExchangeContract() external;\n', '}\n', '\n', '// Standard ownership semantics\n', 'contract Ownable {\n', '    address public owner;\n', '    address private nextOwner;\n', '\n', '    event OwnershipTransfer(address newOwner, address previousOwner);\n', '\n', '    modifier onlyOwner {\n', '        require (msg.sender == owner, "onlyOwner methods called by non-owner.");\n', '        _;\n', '    }\n', '\n', '    function approveNextOwner(address _nextOwner) external onlyOwner {\n', '        require (_nextOwner != owner, "Cannot approve current owner.");\n', '        nextOwner = _nextOwner;\n', '    }\n', '\n', '    function acceptNextOwner() external {\n', '        require (msg.sender == nextOwner, "Can only accept preapproved new owner.");\n', '        emit OwnershipTransfer(nextOwner, owner);\n', '        owner = nextOwner;\n', '    }\n', '}\n', '\n', 'contract Registry is FixedAddress, RegistryInterface, Ownable {\n', '\n', '    // *** Variables\n', '\n', '    // Current exchange contract and its version.\n', '    // Version 0 means uninitialized Registry, first ever Exchange contract is\n', '    // version 1 and the number increments from there.\n', '    address public exchangeContract;\n', '    uint private exchangeContractVersion;\n', '\n', '    // Contract upgrades are preapproved by the Registry owner, and the new version\n', '    // should accept the ownership transfer from its address. This means that Exchange\n', '    // contracts should use deterministic addresses which can be determined beforehand.\n', '    address private nextExchangeContract;\n', '\n', '    // Previously used Exchange contracts cannot be used again - this prevents some\n', '    // scenarios where Counter operator may use old digital signatures of traders\n', '    // maliciously.\n', '    mapping (address => bool) private prevExchangeContracts;\n', '\n', '    // The very first Exchange contract (version 1) is unconditionally trusted, because\n', '    // users can study it before depositing funds. Exchange contract upgrades, however, may\n', '    // invalidate many assumptions, so we require that each trader explicitly approves the upgrade.\n', '    // These approvals are checked by the (immutable) Treasury contract before moving funds, so\n', "    // that it's impossible to compromise user funds by substituting Exchange contract with malicious\n", '    // code.\n', '    mapping (address => uint) private traderApprovals;\n', '\n', '    // *** Events\n', '\n', '    event UpgradeExchangeContract(address exchangeContract, uint exchangeContractVersion);\n', '    event TraderApproveContract(address traderAddr, uint exchangeContractVersion);\n', '\n', '    // *** Constructor\n', '\n', '    constructor () public {\n', '        owner = msg.sender;\n', '        // exchangeContract, exchangeContractVersion are zero upon initialization\n', '    }\n', '\n', '    // *** Public getters\n', '\n', '    function getOwner() external view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getExchangeContract() external view returns (address) {\n', '        return exchangeContract;\n', '    }\n', '\n', '    // *** Exchange contract upgrade (approve/accept pattern)\n', '\n', '    function approveNextExchangeContract(address _nextExchangeContract) external onlyOwner {\n', '        require (_nextExchangeContract != exchangeContract, "Cannot approve current exchange contract.");\n', '        require (!prevExchangeContracts[_nextExchangeContract], "Cannot approve previously used contract.");\n', '        nextExchangeContract = _nextExchangeContract;\n', '    }\n', '\n', '    function acceptNextExchangeContract() external {\n', '        require (msg.sender == nextExchangeContract, "Can only accept preapproved exchange contract.");\n', '        exchangeContract = nextExchangeContract;\n', '        prevExchangeContracts[nextExchangeContract] = true;\n', '        exchangeContractVersion++;\n', '\n', '        emit UpgradeExchangeContract(exchangeContract, exchangeContractVersion);\n', '    }\n', '\n', '    // *** Trader approval for the new contract version.\n', '\n', '    function traderApproveCurrentExchangeContract(uint _exchangeContractVersion) external {\n', '        require (_exchangeContractVersion > 1, "First version doesn\'t need approval.");\n', '        require (_exchangeContractVersion == exchangeContractVersion, "Can only approve the latest version.");\n', '        traderApprovals[msg.sender] = _exchangeContractVersion;\n', '\n', '        emit TraderApproveContract(msg.sender, _exchangeContractVersion);\n', '    }\n', '\n', '    // *** Methods to check approval of the contract upgrade (invoked by the Treasury)\n', '\n', '    function contractApproved(address traderAddr) external view returns (bool) {\n', '        if (exchangeContractVersion > 1) {\n', '            return exchangeContractVersion == traderApprovals[traderAddr];\n', '\n', '        } else {\n', '            return exchangeContractVersion == 1;\n', '        }\n', '    }\n', '\n', '    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool) {\n', '        // This method is an optimization - it checks approval of two traders simultaneously to\n', '        // save gas on an extra cross-contract method call.\n', '        if (exchangeContractVersion > 1) {\n', '            return\n', '              exchangeContractVersion == traderApprovals[traderAddr1] &&\n', '              exchangeContractVersion == traderApprovals[traderAddr2];\n', '\n', '        } else {\n', '            return exchangeContractVersion == 1;\n', '        }\n', '    }\n', '\n', '}']