['pragma solidity 0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply()public view returns (uint256 total_Supply);\n', '  function balanceOf(address who)public view returns (uint256);\n', '  function allowance(address owner, address spender)public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value)public returns (bool ok);\n', '  function approve(address spender, uint256 value)public returns (bool ok);\n', '  function transfer(address to, uint256 value)public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BNTE is ERC20 { \n', '    using SafeMath for uint256;\n', '    //--- Token configurations ----// \n', '    string public constant name = "Bountie";\n', '    string public constant symbol = "BNTE";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant basePrice = 6500;\n', '    uint public maxCap = 20000 ether;\n', '    \n', '    //--- Token allocations -------//\n', '    uint256 public _totalsupply;\n', '    uint256 public mintedTokens;\n', '    uint256 public ETHcollected;\n', '\n', '    //--- Address -----------------//\n', '    address public owner;\n', '    address payable public ethFundMain;\n', '    address public novumAddress;\n', '   \n', '    //--- Milestones --------------//\n', '    uint256 public presale1_startdate = 1537675200; // 23-9-2018\n', '    uint256 public presale2_startdate = 1538712000; // 5-10-2018\n', '    uint256 public presale3_startdate = 1539662400; // 16-10-2018\n', '    uint256 public ico_startdate = 1540612800; // 27-10-2018\n', '    uint256 public ico_enddate = 1541563200; // 7-11-2018\n', '    \n', '    //--- Variables ---------------//\n', '    bool public lockstatus = true;\n', '    bool public stopped = false;\n', '    \n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    event Mint(address indexed from, address indexed to, uint256 amount);\n', '    event Burn(address indexed from, uint256 amount);\n', '    \n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyICO() {\n', '        require(now >= presale1_startdate && now < ico_enddate);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFinishedICO() {\n', '        require(now >= ico_enddate);\n', '        _;\n', '    }\n', '    \n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '        ethFundMain = 0xDEe3a6b14ef8E21B9df09a059186292C9472045D;\n', '        novumAddress = 0xDEe3a6b14ef8E21B9df09a059186292C9472045D;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total_Supply) {\n', '        total_Supply = _totalsupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner)public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFrom( address _from, address _to, uint256 _amount ) public onlyFinishedICO returns (bool success)  {\n', '        require( _to != address(0));\n', '        require(!lockstatus);\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n', '        balances[_from] = (balances[_from]).sub(_amount);\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _amount)public onlyFinishedICO returns (bool success)  {\n', '        require(!lockstatus);\n', '        require( _spender != address(0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n', '        require( _owner != address(0) && _spender != address(0));\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount)public onlyFinishedICO returns (bool success) {\n', '        require(!lockstatus);\n', '        require( _to != address(0));\n', '        require(balances[msg.sender] >= _amount && _amount >= 0);\n', '        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 value) public onlyOwner returns (bool success) {\n', '        uint256 _value = value * 10 ** 18;\n', '        require(balances[msg.sender] >= _value);   \n', '        balances[msg.sender] = (balances[msg.sender]).sub(_value);            \n', '        _totalsupply = _totalsupply.sub(_value);                     \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function stopTransferToken() external onlyOwner onlyFinishedICO {\n', '        require(!lockstatus);\n', '        lockstatus = true;\n', '    }\n', '\n', '    function startTransferToken() external onlyOwner onlyFinishedICO {\n', '        require(lockstatus);\n', '        lockstatus = false;\n', '    }\n', '\n', '    function manualMint(address receiver, uint256 _tokenQuantity) external onlyOwner{\n', '        uint256 tokenQuantity = _tokenQuantity * 10 ** 18;\n', '        uint256 tokenPrice = calculatePrice();\n', '        uint256 ethAmount = tokenQuantity.div(tokenPrice);\n', '        ETHcollected = ETHcollected.add(ethAmount);\n', '        require(ETHcollected <= maxCap);\n', '        mintContract(owner, receiver, tokenQuantity);\n', '    }\n', '\n', '    function () external payable onlyICO {\n', '        require(msg.value != 0 && msg.sender != address(0));\n', '        require(!stopped && msg.sender != owner);\n', '        uint256 tokenPrice = calculatePrice();\n', '        uint256 tokenQuantity = (msg.value).mul(tokenPrice);\n', '        ETHcollected = ETHcollected.add(msg.value);\n', '        require(ETHcollected <= maxCap);\n', '        mintContract(address(this), msg.sender, tokenQuantity);\n', '    }\n', '\n', '    function mintContract(address from, address receiver, uint256 tokenQuantity) private {\n', '        require(tokenQuantity > 0);\n', '        mintedTokens = mintedTokens.add(tokenQuantity);\n', '        uint256 novumShare = tokenQuantity * 4 / 65;\n', '        uint256 userManagement = tokenQuantity * 31 / 65;\n', '        balances[novumAddress] = balances[novumAddress].add(novumShare);\n', '        balances[owner] = balances[owner].add(userManagement);\n', '        _totalsupply = _totalsupply.add(tokenQuantity * 100 / 65);\n', '        balances[receiver] = balances[receiver].add(tokenQuantity);\n', '        emit Mint(from, receiver, tokenQuantity);\n', '        emit Transfer(address(0), receiver, tokenQuantity);\n', '        emit Mint(from, novumAddress, novumShare);\n', '        emit Transfer(address(0), novumAddress, novumShare);\n', '        emit Mint(from, owner, userManagement);\n', '        emit Transfer(address(0), owner, userManagement);\n', '    }\n', '    \n', '    function calculatePrice() private view returns (uint256){\n', '        uint256 price_token = basePrice;\n', '         \n', '        if(now < presale1_startdate) {\n', '            require(ETHcollected < 10000 ether);\n', '            price_token = basePrice * 6 / 5;   \n', '        }\n', '        else  if (now < presale2_startdate) {\n', '            require(ETHcollected < 11739 ether);\n', '            price_token = basePrice * 23 / 20;   \n', '        }\n', '        else if (now < presale3_startdate) {\n', '            require(ETHcollected < 13557 ether);\n', '            price_token = basePrice * 11 / 10;\n', '        }\n', '        else if (now < ico_startdate) {\n', '            require(ETHcollected < 15462 ether);\n', '            price_token = basePrice * 21 / 20;\n', '        }\n', '        else {\n', '            require(ETHcollected < maxCap);\n', '            price_token = basePrice;\n', '        }\n', '        return price_token;\n', '    }\n', '    \n', '    function CrowdSale_Halt() external onlyOwner onlyICO {\n', '        require(!stopped);\n', '        stopped = true;\n', '    }\n', '\n', '\n', '    function CrowdSale_Resume() external onlyOwner onlyICO {\n', '        require(stopped);\n', '        stopped = false;\n', '    }\n', '\n', '    function CrowdSale_Change_ReceiveWallet(address payable New_Wallet_Address) external onlyOwner {\n', '        require(New_Wallet_Address != address(0));\n', '        ethFundMain = New_Wallet_Address;\n', '    }\n', '\n', '\tfunction CrowdSale_AssignOwnership(address newOwner) public onlyOwner {\n', '\t    require(newOwner != address(0));\n', '\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n', '\t    balances[owner] = 0;\n', '\t    owner = newOwner;\n', '\t    emit Transfer(msg.sender, newOwner, balances[newOwner]);\n', '\t}\n', '\n', '    function forwardFunds() external onlyOwner { \n', '        address myAddress = address(this);\n', '        ethFundMain.transfer(myAddress.balance);\n', '    }\n', '\n', '    function modify_NovumAddress(address newAddress) public onlyOwner returns(bool) {\n', '        require(newAddress != address(0) && novumAddress != newAddress);\n', '        uint256 novumBalance = balances[novumAddress];\n', '        address oldAddress = novumAddress;\n', '        balances[newAddress] = (balances[newAddress]).add(novumBalance);\n', '        balances[novumAddress] = 0;\n', '        novumAddress = newAddress;\n', '        emit Transfer(oldAddress, newAddress, novumBalance);\n', '        return true;\n', '    }\n', '}']
['pragma solidity 0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply()public view returns (uint256 total_Supply);\n', '  function balanceOf(address who)public view returns (uint256);\n', '  function allowance(address owner, address spender)public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value)public returns (bool ok);\n', '  function approve(address spender, uint256 value)public returns (bool ok);\n', '  function transfer(address to, uint256 value)public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BNTE is ERC20 { \n', '    using SafeMath for uint256;\n', '    //--- Token configurations ----// \n', '    string public constant name = "Bountie";\n', '    string public constant symbol = "BNTE";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public constant basePrice = 6500;\n', '    uint public maxCap = 20000 ether;\n', '    \n', '    //--- Token allocations -------//\n', '    uint256 public _totalsupply;\n', '    uint256 public mintedTokens;\n', '    uint256 public ETHcollected;\n', '\n', '    //--- Address -----------------//\n', '    address public owner;\n', '    address payable public ethFundMain;\n', '    address public novumAddress;\n', '   \n', '    //--- Milestones --------------//\n', '    uint256 public presale1_startdate = 1537675200; // 23-9-2018\n', '    uint256 public presale2_startdate = 1538712000; // 5-10-2018\n', '    uint256 public presale3_startdate = 1539662400; // 16-10-2018\n', '    uint256 public ico_startdate = 1540612800; // 27-10-2018\n', '    uint256 public ico_enddate = 1541563200; // 7-11-2018\n', '    \n', '    //--- Variables ---------------//\n', '    bool public lockstatus = true;\n', '    bool public stopped = false;\n', '    \n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    event Mint(address indexed from, address indexed to, uint256 amount);\n', '    event Burn(address indexed from, uint256 amount);\n', '    \n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyICO() {\n', '        require(now >= presale1_startdate && now < ico_enddate);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFinishedICO() {\n', '        require(now >= ico_enddate);\n', '        _;\n', '    }\n', '    \n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '        ethFundMain = 0xDEe3a6b14ef8E21B9df09a059186292C9472045D;\n', '        novumAddress = 0xDEe3a6b14ef8E21B9df09a059186292C9472045D;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256 total_Supply) {\n', '        total_Supply = _totalsupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner)public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferFrom( address _from, address _to, uint256 _amount ) public onlyFinishedICO returns (bool success)  {\n', '        require( _to != address(0));\n', '        require(!lockstatus);\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n', '        balances[_from] = (balances[_from]).sub(_amount);\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _amount)public onlyFinishedICO returns (bool success)  {\n', '        require(!lockstatus);\n', '        require( _spender != address(0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n', '        require( _owner != address(0) && _spender != address(0));\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount)public onlyFinishedICO returns (bool success) {\n', '        require(!lockstatus);\n', '        require( _to != address(0));\n', '        require(balances[msg.sender] >= _amount && _amount >= 0);\n', '        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 value) public onlyOwner returns (bool success) {\n', '        uint256 _value = value * 10 ** 18;\n', '        require(balances[msg.sender] >= _value);   \n', '        balances[msg.sender] = (balances[msg.sender]).sub(_value);            \n', '        _totalsupply = _totalsupply.sub(_value);                     \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function stopTransferToken() external onlyOwner onlyFinishedICO {\n', '        require(!lockstatus);\n', '        lockstatus = true;\n', '    }\n', '\n', '    function startTransferToken() external onlyOwner onlyFinishedICO {\n', '        require(lockstatus);\n', '        lockstatus = false;\n', '    }\n', '\n', '    function manualMint(address receiver, uint256 _tokenQuantity) external onlyOwner{\n', '        uint256 tokenQuantity = _tokenQuantity * 10 ** 18;\n', '        uint256 tokenPrice = calculatePrice();\n', '        uint256 ethAmount = tokenQuantity.div(tokenPrice);\n', '        ETHcollected = ETHcollected.add(ethAmount);\n', '        require(ETHcollected <= maxCap);\n', '        mintContract(owner, receiver, tokenQuantity);\n', '    }\n', '\n', '    function () external payable onlyICO {\n', '        require(msg.value != 0 && msg.sender != address(0));\n', '        require(!stopped && msg.sender != owner);\n', '        uint256 tokenPrice = calculatePrice();\n', '        uint256 tokenQuantity = (msg.value).mul(tokenPrice);\n', '        ETHcollected = ETHcollected.add(msg.value);\n', '        require(ETHcollected <= maxCap);\n', '        mintContract(address(this), msg.sender, tokenQuantity);\n', '    }\n', '\n', '    function mintContract(address from, address receiver, uint256 tokenQuantity) private {\n', '        require(tokenQuantity > 0);\n', '        mintedTokens = mintedTokens.add(tokenQuantity);\n', '        uint256 novumShare = tokenQuantity * 4 / 65;\n', '        uint256 userManagement = tokenQuantity * 31 / 65;\n', '        balances[novumAddress] = balances[novumAddress].add(novumShare);\n', '        balances[owner] = balances[owner].add(userManagement);\n', '        _totalsupply = _totalsupply.add(tokenQuantity * 100 / 65);\n', '        balances[receiver] = balances[receiver].add(tokenQuantity);\n', '        emit Mint(from, receiver, tokenQuantity);\n', '        emit Transfer(address(0), receiver, tokenQuantity);\n', '        emit Mint(from, novumAddress, novumShare);\n', '        emit Transfer(address(0), novumAddress, novumShare);\n', '        emit Mint(from, owner, userManagement);\n', '        emit Transfer(address(0), owner, userManagement);\n', '    }\n', '    \n', '    function calculatePrice() private view returns (uint256){\n', '        uint256 price_token = basePrice;\n', '         \n', '        if(now < presale1_startdate) {\n', '            require(ETHcollected < 10000 ether);\n', '            price_token = basePrice * 6 / 5;   \n', '        }\n', '        else  if (now < presale2_startdate) {\n', '            require(ETHcollected < 11739 ether);\n', '            price_token = basePrice * 23 / 20;   \n', '        }\n', '        else if (now < presale3_startdate) {\n', '            require(ETHcollected < 13557 ether);\n', '            price_token = basePrice * 11 / 10;\n', '        }\n', '        else if (now < ico_startdate) {\n', '            require(ETHcollected < 15462 ether);\n', '            price_token = basePrice * 21 / 20;\n', '        }\n', '        else {\n', '            require(ETHcollected < maxCap);\n', '            price_token = basePrice;\n', '        }\n', '        return price_token;\n', '    }\n', '    \n', '    function CrowdSale_Halt() external onlyOwner onlyICO {\n', '        require(!stopped);\n', '        stopped = true;\n', '    }\n', '\n', '\n', '    function CrowdSale_Resume() external onlyOwner onlyICO {\n', '        require(stopped);\n', '        stopped = false;\n', '    }\n', '\n', '    function CrowdSale_Change_ReceiveWallet(address payable New_Wallet_Address) external onlyOwner {\n', '        require(New_Wallet_Address != address(0));\n', '        ethFundMain = New_Wallet_Address;\n', '    }\n', '\n', '\tfunction CrowdSale_AssignOwnership(address newOwner) public onlyOwner {\n', '\t    require(newOwner != address(0));\n', '\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n', '\t    balances[owner] = 0;\n', '\t    owner = newOwner;\n', '\t    emit Transfer(msg.sender, newOwner, balances[newOwner]);\n', '\t}\n', '\n', '    function forwardFunds() external onlyOwner { \n', '        address myAddress = address(this);\n', '        ethFundMain.transfer(myAddress.balance);\n', '    }\n', '\n', '    function modify_NovumAddress(address newAddress) public onlyOwner returns(bool) {\n', '        require(newAddress != address(0) && novumAddress != newAddress);\n', '        uint256 novumBalance = balances[novumAddress];\n', '        address oldAddress = novumAddress;\n', '        balances[newAddress] = (balances[newAddress]).add(novumBalance);\n', '        balances[novumAddress] = 0;\n', '        novumAddress = newAddress;\n', '        emit Transfer(oldAddress, newAddress, novumBalance);\n', '        return true;\n', '    }\n', '}']
