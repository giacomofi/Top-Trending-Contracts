['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-05\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract Receiver {\n', '    //The purpose of this contract is to act purely as a static address\n', '    //in the Ethereum uint256 address space from which to initiate other\n', '    //actions\n', '\n', '    //State\n', '    address public implementation;\n', '    bool public isPayable;\n', '\n', '    //Events\n', '    event LogImplementationChanged(address _oldImplementation, address _newImplementation);\n', '    event LogPaymentReceived(address sender, uint256 value);\n', '\n', '    constructor(address _implementation, bool _isPayable)\n', '        public\n', '    {\n', '        require(_implementation != address(0), "Implementation address cannot be 0");\n', '        implementation = _implementation;\n', '        isPayable = _isPayable;\n', '    }\n', '\n', '    modifier onlyImplementation\n', '    {\n', '        require(msg.sender == implementation, "Only the contract implementation may perform this action");\n', '        _;\n', '    }\n', '    \n', '    function drain()\n', '        external\n', '        onlyImplementation\n', '    {\n', '        msg.sender.call.value(address(this).balance)("");\n', '    }\n', '\n', '\n', '    function ()\n', '        external\n', '        payable \n', '    {\n', '        if (msg.sender != implementation) {\n', '            if (isPayable) {\n', '                emit LogPaymentReceived(msg.sender, msg.value);\n', '            } else {\n', '                revert("not payable");\n', '            }\n', '        } else {\n', '            assembly {\n', '                switch calldatasize\n', '                case 0 {\n', '                }\n', '                default {\n', '                    //Copy call data into free memory region.\n', '                    let free_ptr := mload(0x40)\n', '                    calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                    //Forward all gas and call data to the target contract.\n', '                    let result := delegatecall(gas, caller, free_ptr, calldatasize, 0, 0)\n', '                    returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                    //Revert if the call failed, otherwise return the result\n', '                    if iszero(result) { revert(free_ptr, returndatasize) }\n', '                    return(free_ptr, returndatasize)\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.5.0;\n', '\n', 'contract Receiver {\n', '    //The purpose of this contract is to act purely as a static address\n', '    //in the Ethereum uint256 address space from which to initiate other\n', '    //actions\n', '\n', '    //State\n', '    address public implementation;\n', '    bool public isPayable;\n', '\n', '    //Events\n', '    event LogImplementationChanged(address _oldImplementation, address _newImplementation);\n', '    event LogPaymentReceived(address sender, uint256 value);\n', '\n', '    constructor(address _implementation, bool _isPayable)\n', '        public\n', '    {\n', '        require(_implementation != address(0), "Implementation address cannot be 0");\n', '        implementation = _implementation;\n', '        isPayable = _isPayable;\n', '    }\n', '\n', '    modifier onlyImplementation\n', '    {\n', '        require(msg.sender == implementation, "Only the contract implementation may perform this action");\n', '        _;\n', '    }\n', '    \n', '    function drain()\n', '        external\n', '        onlyImplementation\n', '    {\n', '        msg.sender.call.value(address(this).balance)("");\n', '    }\n', '\n', '\n', '    function ()\n', '        external\n', '        payable \n', '    {\n', '        if (msg.sender != implementation) {\n', '            if (isPayable) {\n', '                emit LogPaymentReceived(msg.sender, msg.value);\n', '            } else {\n', '                revert("not payable");\n', '            }\n', '        } else {\n', '            assembly {\n', '                switch calldatasize\n', '                case 0 {\n', '                }\n', '                default {\n', '                    //Copy call data into free memory region.\n', '                    let free_ptr := mload(0x40)\n', '                    calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                    //Forward all gas and call data to the target contract.\n', '                    let result := delegatecall(gas, caller, free_ptr, calldatasize, 0, 0)\n', '                    returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                    //Revert if the call failed, otherwise return the result\n', '                    if iszero(result) { revert(free_ptr, returndatasize) }\n', '                    return(free_ptr, returndatasize)\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']
