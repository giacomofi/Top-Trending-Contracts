['pragma solidity 0.4.24;\n', '\n', '/// @title SafeMath\n', '/// @dev Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '    /// @dev Multiply two numbers, throw on overflow.\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /// @dev Substract two numbers, throw on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Add two numbers, throw on overflow.\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev Provide a modifier that permits only a single user to call the function\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @dev Set the original `owner` of the contract to the sender account.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Require that the modified function is only called by `owner`\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev Allow `owner` to transfer control of the contract to `newOwner`.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be sent to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', ' */\n', 'contract HasNoEther is Ownable {\n', '\n', '    /**\n', '    * @dev Constructor that rejects incoming Ether\n', '    * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '    * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '    * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '    * we could use assembly to access msg.value.\n', '    */\n', '    constructor() public payable {\n', '        require(msg.value == 0);\n', '    }\n', '\n', '    /**\n', '    * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '    */\n', '    function() external {}\n', '\n', '    /**\n', '    * @dev Transfer all Ether held by the contract to the owner.\n', '    */\n', '    function reclaimEther() external onlyOwner {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Tokens\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\n', ' * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\n', ' * owner to reclaim the tokens.\n', ' */\n', 'contract HasNoTokens is CanReclaimToken {\n', '\n', ' /**\n', '  * @dev Reject all ERC223 compatible tokens\n', '  * @param from_ address The address that is transferring the tokens\n', '  * @param value_ uint256 the amount of the specified token\n', '  * @param data_ Bytes The data passed from the caller.\n', '  */\n', '  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n', '    from_;\n', '    value_;\n', '    data_;\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '    /**\n', '    * @dev Reclaim ownership of Ownable contracts\n', '    * @param contractAddr The address of the Ownable to be reclaimed.\n', '    */\n', '    function reclaimContract(address contractAddr) external onlyOwner {\n', '        Ownable contractInst = Ownable(contractAddr);\n', '        contractInst.transferOwnership(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Base contract for contracts that should not own things.\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\n', ' * Owned contracts. See respective base contracts for details.\n', ' */\n', 'contract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/// @title Lockable token with exceptions\n', '/// @dev StandardToken modified with pausable transfers.\n', 'contract LockableToken is Ownable, StandardToken {\n', '\n', '    /// Flag for locking normal trading\n', '    bool public locked = true;\n', '\n', '    /// Addresses exempted from token trade lock\n', '    mapping(address => bool) public lockExceptions;\n', '\n', '    constructor() public {\n', '        // It should always be possible to call reclaimToken\n', '        lockExceptions[this] = true;\n', '    }\n', '\n', '    /// @notice Admin function to lock trading\n', '    function lock() public onlyOwner {\n', '        locked = true;\n', '    }\n', '\n', '    /// @notice Admin function to unlock trading\n', '    function unlock() public onlyOwner {\n', '        locked = false;\n', '    }\n', '\n', '    /// @notice Set whether `sender` may trade when token is locked\n', '    /// @param sender The address to change the lock exception for\n', '    /// @param _canTrade Whether `sender` may trade\n', '    function setTradeException(address sender, bool _canTrade) public onlyOwner {\n', '        lockExceptions[sender] = _canTrade;\n', '    }\n', '\n', '    /// @notice Check if the token is currently tradable for `sender`\n', '    /// @param sender The address attempting to make a transfer\n', '    /// @return True if `sender` is allowed to make transfers, false otherwise\n', '    function canTrade(address sender) public view returns(bool) {\n', '        return !locked || lockExceptions[sender];\n', '    }\n', '\n', '    /// @dev Modifier to make a function callable only when the contract is not paused.\n', '    modifier whenNotLocked() {\n', '        require(canTrade(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '                public whenNotLocked returns (bool) {\n', '\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '                public whenNotLocked returns (bool) {\n', '\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value)\n', '                public whenNotLocked returns (bool) {\n', '\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue)\n', '                public whenNotLocked returns (bool success) {\n', '\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue)\n', '                public whenNotLocked returns (bool success) {\n', '                        \n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '}\n', '\n', '/// @title Pledgecamp Token (PLG)\n', '/// @author Sam Pullman\n', '/// @notice ERC20 compatible token for the Pledgecamp platform\n', 'contract PLGToken is Ownable, NoOwner, LockableToken {\n', '    using SafeMath for uint256;\n', '    \n', '    /// @notice Emitted when tokens are burned\n', '    /// @param burner Account that burned its tokens\n', '    /// @param value Number of tokens burned\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    string public name = "PLGToken";\n', '    string public symbol = "PLG";\n', '    uint8 public decimals = 18;\n', '\n', '    /// Flag for only allowing a single token initialization\n', '    bool public initialized = false;\n', '\n', '    /// @notice Set initial PLG allocations, which can only happen once\n', '    /// @param addresses Addresses of beneficiaries\n', '    /// @param allocations Amounts to allocate each beneficiary\n', '    function initialize(address[] addresses, uint256[] allocations) public onlyOwner {\n', '        require(!initialized);\n', '        require(addresses.length == allocations.length);\n', '        initialized = true;\n', '\n', '        for(uint i = 0; i<allocations.length; i += 1) {\n', '            require(addresses[i] != address(0));\n', '            require(allocations[i] > 0);\n', '            balances[addresses[i]] = allocations[i];\n', '            totalSupply_ = totalSupply_.add(allocations[i]);\n', '        }\n', '    }\n', '\n', '    /// @dev Burns a specific amount of tokens owned by the sender\n', '    /// @param value The number of tokens to be burned\n', '    function burn(uint256 value) public {\n', '        require(value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        totalSupply_ = totalSupply_.sub(value);\n', '        emit Burn(msg.sender, value);\n', '        emit Transfer(msg.sender, address(0), value);\n', '    }\n', '\n', '}\n', '\n', '/// @title Whitelist\n', '/// @dev Handle whitelisting, maximum purchase limits, and bonus calculation for PLGCrowdsale\n', 'contract Whitelist is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /// A participant in the crowdsale\n', '    struct Participant {\n', '        /// Percent of bonus tokens awarded to this participant\n', '        uint256 bonusPercent;\n', '        /// Maximum amount the participant can contribute in wei\n', '        uint256 maxPurchaseAmount;\n', '        /// Wei contributed to the crowdsale so far\n', '        uint256 weiContributed;\n', '    }\n', '\n', '    /// Crowdsale address, used to authorize purchase records\n', '    address public crowdsaleAddress;\n', '\n', '    /// Bonus/Vesting for specific accounts\n', '    /// If Participant.maxPurchaseAmount is zero, the address is not whitelisted\n', '    mapping(address => Participant) private participants;\n', '\n', '    /// @notice Set the crowdsale address. Only one crowdsale at a time may use this whitelist\n', '    /// @param crowdsale The address of the crowdsale\n', '    function setCrowdsale(address crowdsale) public onlyOwner {\n', '        require(crowdsale != address(0));\n', '        crowdsaleAddress = crowdsale;\n', '    }\n', '\n', '    /// @notice Get the bonus token percentage for `user`\n', '    /// @param user The address of a crowdsale participant\n', '    /// @return The percentage of bonus tokens `user` qualifies for\n', '    function getBonusPercent(address user) public view returns(uint256) {\n', '        return participants[user].bonusPercent;\n', '    }\n', '\n', '    /// @notice Check if an address is whitelisted\n', '    /// @param user Potential participant\n', '    /// @return Whether `user` may participate in the crowdsale\n', '    function isValidPurchase(address user, uint256 weiAmount) public view returns(bool) {\n', '        require(user != address(0));\n', '        Participant storage participant = participants[user];\n', '        if(participant.maxPurchaseAmount == 0) {\n', '            return false;\n', '        }\n', '        return participant.weiContributed.add(weiAmount) <= participant.maxPurchaseAmount;\n', '    }\n', '\n', '    /// @notice Whitelist a crowdsale participant\n', '    /// @notice Do not override weiContributed if the user has previously been whitelisted\n', '    /// @param user The participant to add\n', "    /// @param bonusPercent The user's bonus percentage\n", '    /// @param maxPurchaseAmount The maximum the participant is allowed to contribute in wei\n', '    ///     If zero, the user is de-whitelisted\n', '    function addParticipant(address user, uint256 bonusPercent, uint256 maxPurchaseAmount) external onlyOwner {\n', '        require(user != address(0));\n', '        participants[user].bonusPercent = bonusPercent;\n', '        participants[user].maxPurchaseAmount = maxPurchaseAmount;\n', '    }\n', '\n', '    /// @notice Whitelist multiple crowdsale participants at once with the same bonus/purchase amount\n', '    /// @param users The participants to add\n', '    /// @param bonusPercent The bonus percentage shared among users\n', '    /// @param maxPurchaseAmount The maximum each participant is allowed to contribute in wei\n', '    function addParticipants(address[] users, uint256 bonusPercent, uint256 maxPurchaseAmount) external onlyOwner {\n', '        \n', '        for(uint i=0; i<users.length; i+=1) {\n', '            require(users[i] != address(0));\n', '            participants[users[i]].bonusPercent = bonusPercent;\n', '            participants[users[i]].maxPurchaseAmount = maxPurchaseAmount;\n', '        }\n', '    }\n', '\n', '    /// @notice De-whitelist a crowdsale participant\n', '    /// @param user The participant to revoke\n', '    function revokeParticipant(address user) external onlyOwner {\n', '        require(user != address(0));\n', '        participants[user].maxPurchaseAmount = 0;\n', '    }\n', '\n', '    /// @notice De-whitelist multiple crowdsale participants at once\n', '    /// @param users The participants to revoke\n', '    function revokeParticipants(address[] users) external onlyOwner {\n', '        \n', '        for(uint i=0; i<users.length; i+=1) {\n', '            require(users[i] != address(0));\n', '            participants[users[i]].maxPurchaseAmount = 0;\n', '        }\n', '    }\n', '\n', '    function recordPurchase(address beneficiary, uint256 weiAmount) public {\n', '\n', '        require(msg.sender == crowdsaleAddress);\n', '\n', '        Participant storage participant = participants[beneficiary];\n', '        participant.weiContributed = participant.weiContributed.add(weiAmount);\n', '    }\n', '    \n', '}\n', '\n', '/// @title Pledgecamp Crowdsale\n', '/// @author Sam Pullman\n', '/// @notice Capped crowdsale with bonuses for the Pledgecamp platform\n', 'contract PLGCrowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Indicates successful token purchase\n', '    /// @param buyer Fund provider for the token purchase. Must either be `owner` or equal to `beneficiary`\n', '    /// @param beneficiary Account that ultimately receives purchased tokens\n', '    /// @param value Amount in wei of investment\n', '    /// @param tokenAmount Number of tokens purchased (not including bonus)\n', '    /// @param bonusAmount Number of bonus tokens received\n', '    event TokenPurchase(address indexed buyer, address indexed beneficiary,\n', '                        uint256 value, uint256 tokenAmount, uint256 bonusAmount);\n', '\n', '    /// @notice Emitted when the ETH to PLG exchange rate has been updated\n', '    /// @param oldRate The previous exchange rate\n', '    /// @param newRate The new exchange rate\n', '    event ExchangeRateUpdated(uint256 oldRate, uint256 newRate);\n', '\n', '    /// @notice Emitted when the crowdsale ends\n', '    event Closed();\n', '\n', '    /// True if the sale is active\n', '    bool public saleActive;\n', '\n', '    /// ERC20 token the crowdsale is based on\n', '    PLGToken plgToken;\n', '\n', '    /// Timestamp for when the crowdsale may start\n', '    uint256 public startTime;\n', '\n', '    /// Timestamp set when crowdsale purchasing stops\n', '    uint256 public endTime;\n', '\n', '    /// Token to ether conversion rate\n', '    uint256 public tokensPerEther;\n', '\n', '    /// Amount raised so far in wei\n', '    uint256 public amountRaised;\n', '\n', '    /// The minimum purchase amount in wei\n', '    uint256 public minimumPurchase;\n', '\n', '    /// The address from which bonus tokens are distributed\n', '    address public bonusPool;\n', '\n', '    /// The strategy for assigning bonus tokens from bonusPool and assigning vesting contracts\n', '    Whitelist whitelist;\n', '\n', '    /// @notice Constructor for the Pledgecamp crowdsale contract\n', '    /// @param _plgToken ERC20 token contract used in the crowdsale\n', '    /// @param _startTime Timestamp for when the crowdsale may start\n', '    /// @param _rate Token to ether conversion rate\n', '    /// @param _minimumPurchase The minimum purchase amount in wei\n', '    constructor(address _plgToken, uint256 _startTime, uint256 _rate, uint256 _minimumPurchase) public {\n', '\n', '        require(_startTime >= now);\n', '        require(_rate > 0);\n', '        require(_plgToken != address(0));\n', '\n', '        startTime = _startTime;\n', '        tokensPerEther = _rate;\n', '        minimumPurchase = _minimumPurchase;\n', '        plgToken = PLGToken(_plgToken);\n', '    }\n', '\n', '    /// @notice Set the address of the bonus pool, which provides tokens\n', '    /// @notice during bonus periods if it contains sufficient PLG\n', '    /// @param _bonusPool Address of PLG holder\n', '    function setBonusPool(address _bonusPool) public onlyOwner {\n', '        bonusPool = _bonusPool;\n', '    }\n', '\n', '    /// @notice Set the contract that whitelists and calculates how many bonus tokens to award each purchase.\n', '    /// @param _whitelist The address of the whitelist, which must be a `Whitelist`\n', '    function setWhitelist(address _whitelist) public onlyOwner {\n', '        require(_whitelist != address(0));\n', '        whitelist = Whitelist(_whitelist);\n', '    }\n', '\n', '    /// @notice Starts the crowdsale under appropriate conditions\n', '    function start() public onlyOwner {\n', '        require(!saleActive);\n', '        require(now > startTime);\n', '        require(endTime == 0);\n', '        require(plgToken.initialized());\n', '        require(plgToken.lockExceptions(address(this)));\n', '        require(bonusPool != address(0));\n', '        require(whitelist != address(0));\n', '        \n', '        saleActive = true;\n', '    }\n', '\n', '    /// @notice End the crowdsale if the sale is active\n', '    /// @notice Transfer remaining tokens to reserve pool\n', '    function end() public onlyOwner {\n', '        require(saleActive);\n', '        require(bonusPool != address(0));\n', '        saleActive = false;\n', '        endTime = now;\n', '\n', '        withdrawTokens();\n', '\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @notice Withdraw crowdsale ETH to owner wallet\n', '    function withdrawEth() public onlyOwner {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @notice Send remaining crowdsale tokens to `bonusPool` after sale is over\n', '    function withdrawTokens() public onlyOwner {\n', '        require(!saleActive);\n', '        uint256 remainingTokens = plgToken.balanceOf(this);\n', '        plgToken.transfer(bonusPool, remainingTokens);\n', '    }\n', '\n', '    /// Default function tries to make a token purchase\n', '    function () external payable {\n', '        buyTokensInternal(msg.sender);\n', '    }\n', '\n', '    /// @notice Public crowdsale purchase method\n', '    function buyTokens() external payable {\n', '        buyTokensInternal(msg.sender);\n', '    }\n', '\n', '    /// @notice Owner only method for purchasing on behalf of another person\n', '    /// @param beneficiary Address to receive the tokens\n', '    function buyTokensFor(address beneficiary) external payable onlyOwner {\n', '        require(beneficiary != address(0));\n', '        buyTokensInternal(beneficiary);\n', '    }\n', '\n', '    /// @notice Main crowdsale purchase method, which validates the purchase and assigns bonuses\n', '    /// @param beneficiary Address to receive the tokens\n', '    function buyTokensInternal(address beneficiary) private {\n', '        require(whitelist != address(0));\n', '        require(bonusPool != address(0));\n', '        require(validPurchase(msg.value));\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // This is the whitelist/max purchase check\n', '        require(whitelist.isValidPurchase(beneficiary, weiAmount));\n', '\n', "        // Calculate the amount of PLG that's been purchased\n", '        uint256 tokens = weiAmount.mul(tokensPerEther);\n', '\n', '        // update state\n', '        amountRaised = amountRaised.add(weiAmount);\n', '        // Record the purchase in the whitelist contract\n', '        whitelist.recordPurchase(beneficiary, weiAmount);\n', '\n', '        plgToken.transfer(beneficiary, tokens);\n', '\n', '        uint256 bonusPercent = whitelist.getBonusPercent(beneficiary);\n', '        uint256 bonusTokens = tokens.mul(bonusPercent) / 100;\n', '\n', '        if(bonusTokens > 0) {\n', '            plgToken.transferFrom(bonusPool, beneficiary, bonusTokens);\n', '        }\n', '\n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, bonusTokens);\n', '    }\n', '\n', '    /// @notice Set a new ETH to PLG exchange rate\n', '    /// @param _tokensPerEther Exchange rate\n', '    function setExchangeRate(uint256 _tokensPerEther) external onlyOwner {\n', '\n', '        emit ExchangeRateUpdated(tokensPerEther, _tokensPerEther);\n', '        tokensPerEther = _tokensPerEther;\n', '    }\n', '\n', '    /// @notice Check various conditions to determine whether a purchase is currently valid\n', '    /// @param amount The amount of tokens to be purchased\n', '    function validPurchase(uint256 amount) public view returns (bool) {\n', '        bool nonZeroPurchase = amount != 0;\n', '        bool isMinPurchase = (amount >= minimumPurchase);\n', '        return saleActive && nonZeroPurchase && isMinPurchase;\n', '    }\n', '\n', '    /// @notice Check if this is valid PLGCrowdsale contract\n', '    function validCrowdsale() public view returns (bool) {\n', '        return true;\n', '    }\n', '}']