['pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There tis no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner,"Owner can call this function.");\n', '        _;\n', '    }\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0),"Use new owner address.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    } \n', '}\n', '\n', '  \n', 'contract ERC223 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function roleOf(address who) public view returns (uint256);\n', '    function setUserRole(address _user_address, uint256 _role_define) public;\n', '    function transfer(address to, uint256 value) public;\n', '    function transfer(address to, uint value, bytes memory data) public;\n', '    function transferFrom(address from, address to, uint256 value) public;\n', '    function approve(address spender, uint256 value) public;\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// Interface for the contract which implements the ERC223 fallback\n', 'contract ERC223ReceivingContract { \n', '    function tokenFallback(address _from, uint _value, bytes memory _data) public;\n', '}\n', '\n', 'contract WRTToken is Ownable, ERC223 {\n', '    using SafeMath for uint256;\n', '    // Token properties\n', '    string public name = "Warrior Token";\n', '    string public symbol = "WRT";\n', '    uint256 public decimals = 18;\n', '    uint256 public numberDecimal18 = 1000000000000000000;\n', '    uint256 public RATE = 360e18;\n', '\n', '    // Distribution of tokens\n', '    uint256 public _totalSupply = 100000000e18;\n', '    uint256 public _presaleSupply = 5000000e18; // 5% for presale\n', '    uint256 public _projTeamSupply = 5000000e18; // 5% for project team ( will be time sealed for 6 months )\n', '    uint256 public _PartnersSupply = 10000000e18; // 10% for partners and advisors ( will be time sealed for 12 months )\n', '    uint256 public _PRSupply = 9000000e18; // 9% for marketing and bonus \n', '    uint256 public _metaIcoSupply = 1000000e18; // 1% for Expenses done during the ICO i.e. marketing\n', '    uint256 public _icoSupply = 30000000e18; // 30% for ICO\n', '\n', '    //number of total tokens sold in main sale\n', '    uint256 public totalNumberTokenSoldMainSale = 0;\n', '    uint256 public totalNumberTokenSoldPreSale = 0;\n', '\n', '    uint256 public softCapUSD = 5000000;\n', '    uint256 public hardCapUSD = 10000000;\n', '    \n', '    bool public mintingFinished = false;\n', '    bool public tradable = true;\n', '    bool public active = true;\n', '\n', '\n', '    // Balances for each account\n', '    mapping (address => uint256) balances;\n', '    \n', '    // role for each account\n', '    // 0 => No Role, 1 =>Admin, 2 => Team, 3=> Advisors, 4=> Partner, 5=> Marketing, 6=> MetaICO\n', '    \n', '    mapping (address => uint256) role;\n', '    \n', '    // time seal for upper management\n', '    mapping (address => uint256) vault;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping (address => mapping(address => uint256)) allowed;\n', '\n', '    mapping (address => bool) whitelist;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint256 public mainSaleStartTime; \n', '    uint256 public mainSaleEndTime;\n', '    uint256 public preSaleStartTime;\n', '    uint256 public preSaleEndTime;\n', '    \n', '    uint256 public projsealDate; // seal date for project team \n', '    uint256 public partnersealDate; // seal date for partners and advisors ( will be time sealed for 12 months )\n', '\n', '\n', '    uint256 contractDeployedTime;\n', '    \n', '\n', '    // Wallet Address of Token\n', '    address payable public  multisig;\n', '\n', '    // how many token units a buyer get in base unit \n', '\n', '    event MintFinished();\n', '    event StartTradable();\n', '    event PauseTradable();\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    modifier canTradable() {\n', '        require(tradable);\n', '        _;\n', '    }\n', '\n', '    modifier isActive() {\n', '        require(active);\n', '        _;\n', '    }\n', '    \n', '    modifier saleIsOpen(){\n', '        require((mainSaleStartTime <= now && now <= mainSaleEndTime) || (preSaleStartTime <= now && now <= preSaleEndTime));\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '    // @notice WarriorToken Contract\n', '    // @return the transaction address\n', '    constructor(address payable _multisig, uint256 _preSaleStartTime, uint256 _mainSaleStartTime) public {\n', '        require(_multisig != address(0x0),"Invalid address.");\n', '        require(_mainSaleStartTime > _preSaleStartTime);\n', '        multisig = _multisig;\n', '\n', '\n', '        mainSaleStartTime = _mainSaleStartTime;\n', '        preSaleStartTime = _preSaleStartTime;\n', '        // for now the token sale will run for 60 days\n', '        mainSaleEndTime = mainSaleStartTime + 60 days;\n', '        preSaleEndTime = preSaleStartTime + 60 days;\n', '        contractDeployedTime = now;\n', '\n', '        balances[multisig] = _totalSupply;\n', '\n', '        // The project team can get their token 180days after the main sale ends\n', '        projsealDate = mainSaleEndTime + 180 days;\n', '        // The partners and advisors can get their token 1 year after the main sale ends\n', '        partnersealDate = mainSaleEndTime + 365 days;\n', '\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function getTimePassed() public view returns (uint256) {\n', '        return (now - contractDeployedTime).div(1 days);\n', '    }\n', '\n', '    function isPresale() public view returns (bool) {\n', '        return now < preSaleEndTime && now > preSaleStartTime;\n', '    }\n', '\n', '\n', '    function applyBonus(uint256 tokens) public view returns (uint256) {\n', '        if ( now < (preSaleStartTime + 1 days) ) {\n', '            return tokens.mul(20).div(10); // 100% bonus     \n', '        } else if ( now < (preSaleStartTime + 7 days) ) {\n', '            return tokens.mul(15).div(10); // 50% bonus\n', '        } else if ( now < (preSaleStartTime + 14 days) ) {\n', '            return tokens.mul(13).div(10); // 30% bonus\n', '        } else if ( now < (preSaleStartTime + 21 days) ) {\n', '            return tokens.mul(115).div(100); // 15% bonus\n', '        } else if ( now < (preSaleStartTime + 28 days) ) {\n', '            return tokens.mul(11).div(10); // 10% bonus\n', '        } \n', '        return tokens; // if reached till hear means no bonus \n', '    }\n', '\n', '    // Payable method\n', '    // @notice Anyone can buy the tokens on tokensale by paying ether\n', '    function () external payable {        \n', '        tokensale(msg.sender);\n', '    }\n', '\n', '    // @notice tokensale\n', '    // @param recipient The address of the recipient\n', '    // @return the transaction address and send the event as Transfer\n', '    function tokensale(address recipient) internal saleIsOpen isActive {\n', '        require(recipient != address(0x0));\n', '        require(validPurchase());\n', '        require(whitelisted(recipient));\n', '        \n', '        uint256 weiAmount = msg.value;\n', '        uint256 numberToken = weiAmount.mul(RATE).div(1 ether);\n', '\n', '        numberToken = applyBonus(numberToken);\n', '        \n', '        // An investor is only allowed to buy tokens between 333 to 350,000 tokens\n', '        require(numberToken >= 333e18 && numberToken <= 350000e18);\n', '\n', '        \n', '        // if its a presale\n', '        if (isPresale()) {\n', '            require(_presaleSupply >= numberToken);\n', '            totalNumberTokenSoldPreSale = totalNumberTokenSoldPreSale.add(numberToken);\n', '            _presaleSupply = _presaleSupply.sub(numberToken);\n', '        // as the validPurchase checks for the period, else block will only mean its main sale\n', '        } else {\n', '            require(_icoSupply >= numberToken);\n', '            totalNumberTokenSoldMainSale = totalNumberTokenSoldMainSale.add(numberToken);\n', '            _icoSupply = _icoSupply.sub(numberToken);\n', '        }\n', '    \n', '        updateBalances(recipient, numberToken);\n', '        forwardFunds();\n', '        whitelist[recipient] = false;\n', '    }\n', '\n', '    function transFromProjTeamSupply(address receiver, uint256 tokens) public onlyOwner {\n', ' \n', '        require(tokens <= _projTeamSupply);\n', '        updateBalances(receiver, tokens);\n', '        _projTeamSupply = _projTeamSupply.sub(tokens);\n', '        role[receiver] = 2;\n', '    }\n', '\n', '    function transFromPartnersSupply(address receiver, uint256 tokens) public onlyOwner {\n', '        require(tokens <= _PartnersSupply);\n', '        updateBalances(receiver, tokens);        \n', '        _PartnersSupply = _PartnersSupply.sub(tokens);\n', '        role[receiver] = 4;\n', '    }\n', '    \n', '    function setUserRole(address _user, uint256 _role) public onlyOwner {\n', '        role[_user] = _role;\n', '    }\n', '\n', '    function transFromPRSupply(address receiver, uint256 tokens) public onlyOwner {\n', '        require(tokens <= _PRSupply);\n', '        updateBalances(receiver, tokens);\n', '        _PRSupply = _PRSupply.sub(tokens);\n', '        role[receiver] = 5;\n', '    }\n', '\n', '    function transFromMetaICOSupply(address receiver, uint256 tokens) public onlyOwner {\n', '        require(tokens <= _metaIcoSupply);\n', '        updateBalances(receiver, tokens);\n', '        _metaIcoSupply = _metaIcoSupply.sub(tokens);\n', '        role[receiver] = 6;\n', '    }\n', '\n', '    function setWhitelistStatus(address user, bool status) public onlyOwner returns (bool) {\n', '\n', '        whitelist[user] = status; \n', '        \n', '        return whitelist[user];\n', '    }\n', '    \n', '    function setWhitelistForBulk(address[] memory listAddresses, bool status) public onlyOwner {\n', '        for (uint256 i = 0; i < listAddresses.length; i++) {\n', '            whitelist[listAddresses[i]] = status;\n', '        }\n', '    }\n', '\n', '    // used to transfer manually when senders are using BTC\n', '    function transferToAll(address[] memory tos, uint256[] memory values) public onlyOwner canTradable isActive {\n', '        require(\n', '            tos.length == values.length\n', '            );\n', '        \n', '        for(uint256 i = 0; i < tos.length; i++){\n', '            require(_icoSupply >= values[i]);   \n', '            totalNumberTokenSoldMainSale = totalNumberTokenSoldMainSale.add(values[i]);\n', '            _icoSupply = _icoSupply.sub(values[i]);\n', '            updateBalances(tos[i],values[i]);\n', '        }\n', '    }\n', '\n', '    function transferToAllInPreSale(address[] memory tos, uint256[] memory values) public onlyOwner canTradable isActive {\n', '        require(\n', '            tos.length == values.length\n', '            );\n', '        \n', '        for(uint256 i = 0; i < tos.length; i++){\n', '            require(_presaleSupply >= values[i]);   \n', '            totalNumberTokenSoldPreSale = totalNumberTokenSoldPreSale.add(values[i]);\n', '            _presaleSupply = _presaleSupply.sub(values[i]);\n', '            updateBalances(tos[i],values[i]);\n', '        }\n', '    }\n', '    \n', '    function updateBalances(address receiver, uint256 tokens) internal {\n', '        balances[multisig] = balances[multisig].sub(tokens);\n', '        balances[receiver] = balances[receiver].add(tokens);\n', '        emit Transfer(multisig, receiver, tokens);\n', '    }\n', '\n', '    function whitelisted(address user) public view returns (bool) {\n', '        return whitelist[user];\n', '    }\n', '    \n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds()  internal {\n', '       multisig.transfer(msg.value);\n', '    }\n', '\n', '    \n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = (now >= mainSaleStartTime && now <= mainSaleEndTime) || (now >= preSaleStartTime && now <= preSaleEndTime);\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    // @return true if crowdsale current lot event has ended\n', '    function hasEnded() public view returns (bool) {\n', '        return now > mainSaleEndTime;\n', '    }\n', '\n', '    function hasPreSaleEnded() public view returns (bool) {\n', '        return now > preSaleEndTime;\n', '    }\n', '\n', '    // Set/change Multi-signature wallet address\n', '    function changeMultiSignatureWallet(address payable _multisig) public onlyOwner isActive {\n', '        multisig = _multisig;\n', '    }\n', '\n', '    // Change ETH/Token exchange rate\n', '    function changeTokenRate(uint _tokenPrice) public onlyOwner isActive {\n', '        RATE = _tokenPrice;\n', '    }\n', '\n', '    // Set Finish Minting.\n', '    function finishMinting() public onlyOwner isActive {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '    }\n', '\n', '    // Start or pause tradable to Transfer token\n', '    function startTradable(bool _tradable) public onlyOwner isActive {\n', '        tradable = _tradable;\n', '        if (tradable)\n', '            emit StartTradable();\n', '        else\n', '            emit PauseTradable();\n', '    }\n', '    \n', '    function setActive(bool _active) public onlyOwner {\n', '        active = _active;\n', '    }\n', '    \n', '    //Change mainSaleStartTime to start ICO manually\n', '    function changeMainSaleStartTime(uint256 _mainSaleStartTime) public onlyOwner {\n', '        mainSaleStartTime = _mainSaleStartTime;\n', '    }\n', '\n', '    //Change mainSaleEndTime to end ICO manually\n', '    function changeMainSaleEndTime(uint256 _mainSaleEndTime) public onlyOwner {\n', '        mainSaleEndTime = _mainSaleEndTime;\n', '    }\n', '\n', '    function changePreSaleStartTime(uint256 _preSaleStartTime) public onlyOwner {\n', '        preSaleStartTime = _preSaleStartTime;\n', '    }\n', '\n', '    //Change mainSaleEndTime to end ICO manually\n', '    function changePreSaleEndTime(uint256 _preSaleEndTime) public onlyOwner {\n', '        preSaleEndTime = _preSaleEndTime;\n', '    }\n', '\n', '    //Change total supply\n', '    function changeTotalSupply(uint256 newSupply) public onlyOwner {\n', '        _totalSupply = newSupply;\n', '    }\n', '\n', '    // In case multiple ICOs are planned, use this with the totalSupply function\n', '    function changeICOSupply(uint256 newICOSupply) public onlyOwner {\n', '        _icoSupply = newICOSupply;\n', '    }\n', '\n', '    // Get current price of a Token\n', '    // @return the price or token value for a ether\n', '    function getRate() public view returns (uint256 result) {\n', '        return RATE;\n', '    }\n', '    \n', '    function getTokenDetail() public view returns (string memory, string memory, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (name, symbol, mainSaleStartTime, mainSaleEndTime, preSaleStartTime, preSaleEndTime, _totalSupply, _icoSupply, _presaleSupply, totalNumberTokenSoldMainSale, totalNumberTokenSoldPreSale);\n', '    }\n', '\n', '\n', '    // ERC223 Methods  \n', '    \n', '    // What is the balance of a particular account?\n', '    // @param who The address of the particular account\n', '    // @return the balance the particular account\n', '    function balanceOf(address who) public view returns (uint256) {\n', '        return balances[who];\n', '    }\n', '    function roleOf(address who) public view returns (uint256) {\n', '        return role[who];\n', '    }\n', '\n', '    // @return total tokens supplied\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function burn(uint256 _value) public {\n', '        require(_value <= balances[msg.sender]);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(multisig, _value);\n', '        \n', '    }\n', '    \n', '    /**\n', '     * @dev Transfer the specified amount of tokens to the specified address.\n', '     *      Invokes the `tokenFallback` function if the recipient is a contract.\n', '     *      The token transfer fails if the recipient is a contract\n', '     *      but does not implement the `tokenFallback` function\n', '     *      or the fallback function to receive funds.\n', '     *\n', '     * @param _to    Receiver address.\n', '     * @param _value Amount of tokens that will be transferred.\n', '     * @param _data  Transaction metadata.\n', '     */\n', '    function transfer(address _to, uint _value, bytes memory _data) public {\n', '        // Standard function transfer similar to ERC20 transfer with no _data .\n', '        // Added due to backwards compatibility reasons .\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        if(role[msg.sender] == 2)\n', '        {\n', '            require(now >= projsealDate,"you can not transfer yet");\n', '        }\n', '        if(role[msg.sender] == 3 || role[msg.sender] == 4)\n', '        {\n', '            require(now >= partnersealDate,"you can not transfer yet");\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '    }\n', '    \n', '    /**\n', '     * @dev Transfer the specified amount of tokens to the specified address.\n', '     *      This function works the same with the previous one\n', "     *      but doesn't contain `_data` param.\n", '     *      Added due to backwards compatibility reasons.\n', '     *\n', '     * @param _to    Receiver address.\n', '     * @param _value Amount of tokens that will be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) public {\n', '        uint codeLength;\n', '        bytes memory empty;\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_to)\n', '        }\n', '       if(role[msg.sender] == 2)\n', '        {\n', '            require(now >= projsealDate,"you can not transfer yet");\n', '        }\n', '        if(role[msg.sender] == 3 || role[msg.sender] == 4)\n', '        {\n', '            require(now >= partnersealDate,"you can not transfer yet");\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, empty);\n', '        }\n', '        emit Transfer(msg.sender, _to, _value, empty);\n', '    }\n', '\n', '    // @notice send `value` token to `to` from `from`\n', '    // @param from The address of the sender\n', '    // @param to The address of the recipient\n', '    // @param value The amount of token to be transferred\n', '    // @return the transaction address and send the event as Transfer\n', '    function transferFrom(address from, address to, uint256 value) public canTradable isActive {\n', '        require (\n', '            allowed[from][msg.sender] >= value && balances[from] >= value && value > 0\n', '        );\n', '        if(role[from] == 2)\n', '        {\n', '            require(now >= projsealDate,"you can not transfer yet");\n', '        }\n', '        if(role[from] == 3 || role[from] == 4)\n', '        {\n', '            require(now >= partnersealDate,"you can not transfer yet");\n', '        }\n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '    // Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '    // If this function is called again it overwrites the current allowance with value.\n', '    // @param spender The address of the sender\n', '    // @param value The amount to be approved\n', '    // @return the transaction address and send the event as Approval\n', '    function approve(address spender, uint256 value) public isActive {\n', '        require (\n', '            balances[msg.sender] >= value && value > 0\n', '        );\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '    }\n', '    // Check the allowed value for the spender to withdraw from owner\n', '    // @param owner The address of the owner\n', '    // @param spender The address of the spender\n', '    // @return the amount which spender is still allowed to withdraw from owner\n', '    function allowance(address _owner, address spender) public view returns (uint256) {\n', '        return allowed[_owner][spender];\n', '    }    \n', '}']