['// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://eips.ethereum.org/EIPS/eip-165\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /*\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/WizardPresaleNFT.sol\n', '\n', 'pragma solidity >=0.5.6 <0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title WizardPresaleNFT\n', ' * @notice The basic ERC-721 functionality for storing the presale Wizard NFTs.\n', ' *     Derived from: https://github.com/OpenZeppelin/openzeppelin-solidity/tree/v2.2.0\n', ' */\n', 'contract WizardPresaleNFT is ERC165, IERC721 {\n', '\n', '    using Address for address;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /// @notice Emitted when a wizard token is created.\n', '    event WizardSummoned(uint256 indexed tokenId, uint8 element, uint256 power);\n', '\n', '    /// @notice Emitted when a wizard change element. Should only happen once and for wizards\n', '    ///         that previously had the element undefined.\n', '    event WizardAlignmentAssigned(uint256 indexed tokenId, uint8 element);\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /// @dev The presale Wizard structure.\n', '    ///  Fits in one word\n', '    struct Wizard {\n', '        // NOTE: Changing the order or meaning of any of these fields requires an update\n', '        //   to the _createWizard() function which assumes a specific order for these fields.\n', '        uint8 affinity;\n', '        uint88 power;\n', '        address owner;\n', '    }\n', '\n', '    // Mapping from Wizard ID to Wizard struct\n', '    mapping (uint256 => Wizard) public _wizardsById;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => uint256) internal _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _wizardsById[tokenId].owner;\n', '        require(owner != address(0), "ERC721: owner query for nonexistent token");\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '        require(\n', '            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender, "ERC721: approve to caller");\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return bool whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _wizardsById[tokenId].owner;\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     * is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner, "ERC721: burn of token that is not own");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner]--;\n', '        // delete the entire object to recover the most gas\n', '        delete _wizardsById[tokenId];\n', '\n', '        // required for ERC721 compatibility\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from]--;\n', '        _ownedTokensCount[to]++;\n', '\n', '        _wizardsById[tokenId].owner = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/WizardPresaleInterface.sol\n', '\n', 'pragma solidity >=0.5.6 <0.6.0;\n', '\n', '\n', '/// @title WizardPresaleInterface\n', '/// @notice This interface represents the single method that the final tournament and master Wizard contracts\n', '///         will use to import the presale wizards when those contracts have been finalized a released on\n', '///         mainnet. Once all presale Wizards have been absorbed, this temporary pre-sale contract can be\n', '///         destroyed.\n', 'contract WizardPresaleInterface {\n', '\n', '    // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md on how\n', '    // to calculate this\n', '    bytes4 public constant _INTERFACE_ID_WIZARDPRESALE = 0x4df71efb;\n', '\n', '    /// @notice This function is used to bring a presale Wizard into the final contracts. It can\n', '    ///         ONLY be called by the official gatekeeper contract (as set by the Owner of the presale\n', '    ///         contract). It does a number of things:\n', '    ///            1. Check that the presale Wizard exists, and has not already been absorbed\n', '    ///            2. Transfer the Eth used to create the presale Wizard to the caller\n', '    ///            3. Mark the Wizard as having been absorbed, reclaiming the storage used by the presale info\n', '    ///            4. Return the Wizard information (its owner, minting price, and elemental alignment)\n', '    /// @param id the id of the presale Wizard to be absorbed\n', '    function absorbWizard(uint256 id) external returns (address owner, uint256 power, uint8 affinity);\n', '\n', '    /// @notice A convenience function that allows multiple Wizards to be moved to the final contracts\n', '    ///         simultaneously, works the same as the previous function, but in a batch.\n', '    /// @param ids An array of ids indicating which presale Wizards are to be absorbed\n', '    function absorbWizardMulti(uint256[] calldata ids) external\n', '        returns (address[] memory owners, uint256[] memory powers, uint8[] memory affinities);\n', '\n', '    function powerToCost(uint256 power) public pure returns (uint256 cost);\n', '    function costToPower(uint256 cost) public pure returns (uint256 power);\n', '}\n', '\n', '// File: contracts/AddressPayable.sol\n', '\n', 'pragma solidity >=0.5.6 <0.6.0;\n', '\n', '/**\n', ' * Utility library of inline functions on address payables\n', ' * Modified from original by OpenZeppelin\n', ' */\n', 'contract AddressPayable {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address payable account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) } // solium-disable-line security/no-inline-assembly\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/WizardConstants.sol\n', '\n', 'pragma solidity >=0.5.6 <0.6.0;\n', '\n', '/// @title The master organization behind wizardry activity, where Wiz come from.\n', 'contract WizardConstants {\n', '    uint8 internal constant ELEMENT_NOTSET = 0;\n', '    // need to decide what neutral is because of price difference\n', '    uint8 internal constant ELEMENT_NEUTRAL = 1;\n', '    // no sense in defining these here as they are probably not fixed,\n', '    // all we need to know is that these are not neutral\n', '    uint8 internal constant ELEMENT_FIRE = 2;\n', '    uint8 internal constant ELEMENT_WIND = 3;\n', '    uint8 internal constant ELEMENT_WATER = 4;\n', '    uint8 internal constant MAX_ELEMENT = ELEMENT_WATER;\n', '}\n', '\n', '// File: contracts/WizardPresale.sol\n', '\n', 'pragma solidity >=0.5.6 <0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/// @title WizardPresale - Making Cheeze Wizards available for sale!\n', '/// @notice Allows for the creation and sale of Cheeze Wizards before the final tournament\n', '///         contract has been reviewed and released on mainnet. There are three main types\n', '///         of Wizards that are managed by this contract:\n', '///          - Neutral Wizards: Available in unlimited quantities and all have the same\n', "///             innate power. Don't have a natural affinity for any particular elemental\n", '///             spell... or the corresponding weakness!\n', '///          - Elemental Wizards: Available in unlimited quantities, but with a steadily increasing\n', '///             power; the power of an Elemental Wizard is always _slightly_ higher than the power\n', '///             of the previously created Elemental Wizard. Each Elemental Wizard has an Elemental\n', '///             Affinity that gives it a power multiplier when using the associated spell, but also\n', '///             gives it a weakness for the opposing element.\n', '///          - Exclusive Wizards: Only available in VERY limited quantities, with a hard cap set at\n', '///             contract creation time. Exclusive Wizards can ONLY be created by the Guild Master\n', '///             address (the address that created this contract), and are assigned the first N\n', '///             Wizard IDs, starting with 1 (where N is the hard cap on Exclusive Wizards). The first\n', '///             non-exclusive Wizard is assigned the ID N+1. Exclusive Wizards have no starting\n', '///             affinity, and their owners much choose an affinity before they can be entered into a\n', '///             Battle. The affinity CAN NOT CHANGE once it has been selected. The power of Exclusive\n', '///             Wizards is not set by the Guild Master and is not required to follow any pattern (although\n', "///             it can't be lower than the power of Neutral Wizards).\n", 'contract WizardPresale is AddressPayable, WizardPresaleNFT, WizardPresaleInterface, WizardConstants {\n', '\n', '    /// @dev The ratio between the cost of a Wizard (in wei) and the power of the wizard.\n', '    ///      power = cost / POWER_SCALE\n', '    ///      cost = power * POWER_SCALE\n', '    uint256 private constant POWER_SCALE = 1000;\n', '\n', '    /// @dev The unit conversion for tenths of basis points\n', '    uint256 private constant TENTH_BASIS_POINTS = 100000;\n', '\n', '    /// @dev The address used to create this smart contract, has permission to conjure Exclusive Wizards,\n', '    ///      set the gatekeeper address, and destroy this contract once the sale is finished and all Presale\n', '    ///      Wizards have been absorbed into the main contracts.\n', '    address payable public guildmaster;\n', '\n', '    /// @dev The start block and duration (in blocks) of the sale.\n', '    ///      ACT NOW! For a limited time only!\n', '    uint256 public saleStartBlock;\n', '    uint256 public saleDuration;\n', '\n', '    /// @dev The cost of Neutral Wizards (in wei).\n', '    uint256 public neutralWizardCost;\n', '\n', '    /// @dev The cost of the _next_ Elemental Wizard (in wei); increases with each Elemental Wizard sold\n', '    uint256 public elementalWizardCost;\n', '\n', '    /// @dev The increment ratio in price between sequential Elemental Wizards, multiplied by 100k for\n', '    ///      greater granularity (0 == 0% increase, 100000 == 100% increase, 100 = 0.1% increase, etc.)\n', "    ///      NOTE: This is NOT percentage points, or basis points. It's tenths of a basis point.\n", '    uint256 public elementalWizardIncrement;\n', '\n', '    /// @dev The hard cap on how many Exclusive Wizards can be created\n', '    uint256 public maxExclusives;\n', '\n', '    /// @dev The ID number of the next Wizard to be created (Neutral or Elemental)\n', '    uint256 public nextWizardId;\n', '\n', '    /// @dev The address of the Gatekeeper for the tournament, initially set to address(0).\n', '    ///      To be set by the Guild Master when the final Tournament Contract is deployed on mainnet\n', '    address payable public gatekeeper;\n', '\n', '    /// @notice Emitted whenever the start of the sale changes.\n', '    event StartBlockChanged(uint256 oldStartBlock, uint256 newStartBlock);\n', '\n', '    /// @param startingCost The minimum cost of a Wizard, used as the price for all Neutral Wizards, and the\n', '    ///        cost of the first Elemental Wizard. Also used as a minimum value for Exclusive Wizards.\n', '    /// @param costIncremement The rate (in tenths of a basis point) at which the price of Elemental Wizards increases\n', '    /// @param exclusiveCount The hard cap on Exclusive Wizards, also dictates the ID of the first non-Exclusive\n', '    /// @param startBlock The starting block of the presale.\n', '    /// @param duration The duration of the presale.  Not changeable!\n', '    constructor(uint128 startingCost,\n', '            uint16 costIncremement,\n', '            uint256 exclusiveCount,\n', '            uint128 startBlock,\n', '            uint128 duration) public\n', '    {\n', '        require(startBlock > block.number, "start must be greater than current block");\n', '\n', '        guildmaster = msg.sender;\n', '        saleStartBlock = startBlock;\n', '        saleDuration = duration;\n', '        neutralWizardCost = startingCost;\n', '        elementalWizardCost = startingCost;\n', '        elementalWizardIncrement = costIncremement;\n', '        maxExclusives = exclusiveCount;\n', '        nextWizardId = exclusiveCount + 1;\n', '\n', '        _registerInterface(_INTERFACE_ID_WIZARDPRESALE);\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the gatekeeper.\n', '    modifier onlyGatekeeper() {\n', '        require(msg.sender == gatekeeper, "Must be gatekeeper");\n', '        _;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the guildmaster.\n', '    modifier onlyGuildmaster() {\n', '        require(msg.sender == guildmaster, "Must be guildmaster");\n', '        _;\n', '    }\n', '\n', '    /// @dev Checks to see that the current block number is within the range\n', '    ///      [saleStartBlock, saleStartBlock + saleDuraction) indicating that the sale\n', '    ///      is currently active\n', '    modifier onlyDuringSale() {\n', "        // The addtion of start and duration can't overflow since they can only be set from\n", '        // 128-bit arguments.\n', '        require(block.number >= saleStartBlock, "Sale not open yet");\n', '        require(block.number < saleStartBlock + saleDuration, "Sale closed");\n', '        _;\n', '    }\n', '\n', '    /// @dev Sets the address of the Gatekeeper contract once the final Tournament contract is live.\n', '    ///      Can only be set once.\n', '    /// @param gc The gatekeeper address to set\n', '    function setGatekeeper(address payable gc) external onlyGuildmaster {\n', '        require(gatekeeper == address(0) && gc != address(0), "Can only set once and must not be zero");\n', '        gatekeeper = gc;\n', '    }\n', '\n', "    /// @dev Updates the start block of the sale. The sale can only be postponed; it can't be made earlier.\n", '    /// @param newStart the new start block.\n', '    function postponeSale(uint128 newStart) external onlyGuildmaster {\n', '        require(block.number < saleStartBlock, "Sale start time only adjustable before previous start time");\n', '        require(newStart > saleStartBlock, "New start time must be later than previous start time");\n', '\n', '        emit StartBlockChanged(saleStartBlock, newStart);\n', '\n', '        saleStartBlock = newStart;\n', '    }\n', '\n', '    /// @dev Returns true iff the sale is currently active\n', '    function isDuringSale() external view returns (bool) {\n', '        return (block.number >= saleStartBlock && block.number < saleStartBlock + saleDuration);\n', '    }\n', '\n', "    /// @dev Convenience method for getting a presale wizard's data\n", '    /// @param id The wizard id\n', '    function getWizard(uint256 id) public view returns (address owner, uint88 power, uint8 affinity) {\n', '        Wizard memory wizard = _wizardsById[id];\n', '        (owner, power, affinity) = (wizard.owner, wizard.power, wizard.affinity);\n', '        require(wizard.owner != address(0), "Wizard does not exist");\n', '    }\n', '\n', '    /// @param cost The price of the wizard in wei\n', '    /// @return The power of the wizard (left as uint256)\n', '    function costToPower(uint256 cost) public pure returns (uint256 power) {\n', '        return cost / POWER_SCALE;\n', '    }\n', '\n', '    /// @param power The power of the wizard\n', '    /// @return The cost of the wizard in wei\n', '    function powerToCost(uint256 power) public pure returns (uint256 cost) {\n', '        return power * POWER_SCALE;\n', '    }\n', '\n', '    /// @notice This function is used to bring a presale Wizard into the final contracts. It can\n', '    ///         ONLY be called by the official gatekeeper contract (as set by the Owner of the presale\n', '    ///         contract). It does a number of things:\n', '    ///            1. Check that the presale Wizard exists, and has not already been absorbed\n', '    ///            2. Transfer the Eth used to create the presale Wizard to the caller\n', '    ///            3. Mark the Wizard as having been absorbed, reclaiming the storage used by the presale info\n', '    ///            4. Return the Wizard information (its owner, minting price, and elemental alignment)\n', '    /// @param id the id of the presale Wizard to be absorbed\n', '    function absorbWizard(uint256 id) external onlyGatekeeper returns (address owner, uint256 power, uint8 affinity) {\n', '        (owner, power, affinity) = getWizard(id);\n', '\n', '        // Free up the storage used by this wizard\n', '        _burn(owner, id);\n', '\n', '        // send the price paid to the gatekeeper to be used in the tournament prize pool\n', '        msg.sender.transfer(powerToCost(power));\n', '    }\n', '\n', '    /// @notice A convenience function that allows multiple Wizards to be moved to the final contracts\n', '    ///         simultaneously, works the same as the previous function, but in a batch.\n', '    /// @param ids An array of ids indicating which presale Wizards are to be absorbed\n', '    function absorbWizardMulti(uint256[] calldata ids) external onlyGatekeeper\n', '            returns (address[] memory owners, uint256[] memory powers, uint8[] memory affinities)\n', '    {\n', '        // allocate arrays\n', '        owners = new address[](ids.length);\n', '        powers = new uint256[](ids.length);\n', '        affinities = new uint8[](ids.length);\n', '\n', '        // The total eth to send (sent in a batch to save gas)\n', '        uint256 totalTransfer;\n', '\n', '        // Put the data for each Wizard into the returned arrays\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            (owners[i], powers[i], affinities[i]) = getWizard(ids[i]);\n', '\n', '            // Free up the storage used by this wizard\n', '            _burn(owners[i], ids[i]);\n', '\n', '            // add the amount to transfer\n', '            totalTransfer += powerToCost(powers[i]);\n', '        }\n', '\n', '        // Send all the eth together\n', '        msg.sender.transfer(totalTransfer);\n', '    }\n', '\n', '    /// @dev Internal function to create a new Wizard; reverts if the Wizard ID is taken.\n', '    ///      NOTE: This function heavily depends on the internal format of the Wizard struct\n', '    ///      and should always be reassessed if anything about that structure changes.\n', '    /// @param tokenId ID of the new Wizard\n', '    /// @param owner The address that will own the newly conjured Wizard\n', '    /// @param power The power level associated with the new Wizard\n', '    /// @param affinity The elemental affinity of the new Wizard\n', '    function _createWizard(uint256 tokenId, address owner, uint256 power, uint8 affinity) internal {\n', '        require(!_exists(tokenId), "Can\'t reuse Wizard ID");\n', '        require(owner != address(0), "Owner address must exist");\n', '        require(power > 0, "Wizard power must be non-zero");\n', '        require(power < (1<<88), "Wizard power must fit in 88 bits of storage.");\n', '        require(affinity <= MAX_ELEMENT, "Invalid elemental affinity");\n', '\n', '        // Create the Wizard!\n', '        _wizardsById[tokenId] = Wizard(affinity, uint88(power), owner);\n', '        _ownedTokensCount[owner]++;\n', '\n', '        // Tell the world!\n', '        emit Transfer(address(0), owner, tokenId);\n', '        emit WizardSummoned(tokenId, affinity, power);\n', '    }\n', '\n', '    /// @dev A private utility function that refunds any overpayment to the sender; smart\n', '    ///      enough to only send the excess if the amount we are returning is more than the\n', '    ///      cost of sending it!\n', '    /// @dev Warning! This does not check for underflows (msg.value < actualPrice) - so\n', '    ///      be sure to call this with correct values!\n', '    /// @param actualPrice the actual price owed\n', '    function _transferRefund(uint256 actualPrice) private {\n', '        uint256 refund = msg.value - actualPrice;\n', '\n', "        // Make sure the amount we're trying to refund is less than the actual cost of sending it!\n", '        // See https://github.com/ethereum/wiki/wiki/Subtleties for magic values costs.  We can\n', '        // safley ignore the 25000 additional gas cost for new accounts, as msg.sender is\n', '        // guarunteed to exist at this point!\n', '        if (refund > (tx.gasprice * (9000+700))) {\n', '            msg.sender.transfer(refund);\n', '        }\n', '    }\n', '\n', '    /// @notice Conjures an Exclusive Wizard with a specific element and ID. This can only be done by\n', '    ///         the Guildmaster, who still has to pay for the power imbued in that Wizard! The power level\n', '    ///         is inferred by the amount of Eth sent. MUST ONLY BE USED FOR EXTERNAL OWNER ADDRESSES.\n', "    /// @param id The ID of the new Wizard; must be in the Exclusive range, and can't already be allocated\n", '    /// @param owner The address which will own the new Wizard\n', '    /// @param affinity The elemental affinity of the new Wizard, can be ELEMENT_NOTSET for Exclusives!\n', '    function conjureExclusiveWizard(uint256 id, address owner, uint8 affinity) public payable onlyGuildmaster {\n', '        require(id > 0 && id <= maxExclusives, "Invalid exclusive ID");\n', '        _createWizard(id, owner, costToPower(msg.value), affinity);\n', '    }\n', '\n', '    /// @notice Same as conjureExclusiveWizard(), but reverts if the owner address is a smart\n', '    ///         contract that is not ERC-721 aware.\n', "    /// @param id The ID of the new Wizard; must be in the Exclusive range, and can't already be allocated\n", '    /// @param owner The address which will own the new Wizard\n', '    /// @param affinity The elemental affinity of the new Wizard, can be ELEMENT_NOTSET for Exclusives!\n', '    function safeConjureExclusiveWizard(uint256 id, address owner, uint8 affinity) external payable onlyGuildmaster {\n', '        conjureExclusiveWizard(id, owner, affinity);\n', '        require(_checkOnERC721Received(address(0), owner, id, ""), "must support erc721");\n', '    }\n', '\n', '    /// @notice Allows for the batch creation of Exclusive Wizards. Same rules apply as above, but the\n', '    ///         powers are specified instead of being inferred. The message still needs to have enough\n', '    ///         value to pay for all the newly conjured Wizards!  MUST ONLY BE USED FOR EXTERNAL OWNER ADDRESSES.\n', '    /// @param ids An array of IDs of the new Wizards\n', '    /// @param owners An array of owners\n', '    /// @param powers An array of power levels\n', '    /// @param affinities An array of elemental affinities\n', '    function conjureExclusiveWizardMulti(\n', '        uint256[] calldata ids,\n', '        address[] calldata owners,\n', '        uint256[] calldata powers,\n', '        uint8[] calldata affinities) external payable onlyGuildmaster\n', '    {\n', '        // Ensure the arrays are all of the same length\n', '        require(\n', '            ids.length == owners.length &&\n', '            owners.length == powers.length &&\n', '            owners.length == affinities.length,\n', '            "Must have equal array lengths"\n', '        );\n', '\n', '        uint256 totalPower = 0;\n', '\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            require(ids[i] > 0 && ids[i] <= maxExclusives, "Invalid exclusive ID");\n', '            require(affinities[i] <= MAX_ELEMENT, "Must choose a valid elemental affinity");\n', '\n', '            _createWizard(ids[i], owners[i], powers[i], affinities[i]);\n', '\n', '            totalPower += powers[i];\n', '        }\n', '\n', '        // Ensure that the message includes enough eth to cover the total power of all Wizards\n', "        // If this check fails, all the Wizards that we just created will be deleted, and we'll just\n", "        // have wasted a bunch of gas. Don't be dumb, Guildmaster!\n", '        // If the guildMaster has managed to overflow totalPower, well done!\n', '        require(powerToCost(totalPower) <= msg.value, "Must pay for power in all Wizards");\n', '\n', '        // We don\'t return "change" if the caller overpays, because the caller is the Guildmaster and\n', "        // shouldn't be dumb like that. How many times do I have to say it? Don't be dumb, Guildmaster!\n", '    }\n', '\n', "    /// @notice Sets the affinity for a Wizard that doesn't already have its elemental affinity chosen.\n", '    ///         Only usable for Exclusive Wizards (all non-Exclusives must have their affinity chosen when\n', "    ///         conjured.) Even Exclusives can't change their affinity once it's been chosen.\n", '    /// @param wizardId The id of the wizard\n', '    /// @param newAffinity The new affinity of the wizard\n', '    function setAffinity(uint256 wizardId, uint8 newAffinity) external {\n', '        require(newAffinity > ELEMENT_NOTSET && newAffinity <= MAX_ELEMENT, "Must choose a valid affinity");\n', '        (address owner, , uint8 affinity) = getWizard(wizardId);\n', '        require(msg.sender == owner, "Affinity can only be set by the owner");\n', '        require(affinity == ELEMENT_NOTSET, "Affinity can only be chosen once");\n', '\n', '        _wizardsById[wizardId].affinity = newAffinity;\n', '\n', '        // Tell the world this wizards now has an affinity!\n', '        emit WizardAlignmentAssigned(wizardId, newAffinity);\n', '    }\n', '\n', '    /// @dev An internal convenience function used by conjureWizard and conjureWizardMulti that takes care\n', '    ///      of the work that is shared between them.\n', '    ///      The use of tempElementalWizardCost and updatedElementalWizardCost deserves some explanation here.\n', '    ///      Using elementalWizardCost directly would be very expensive in the case where this function is\n', '    ///      called repeatedly by conjureWizardMulti. Buying an elemental wizard would update the elementalWizardCost\n', "    ///      each time through this function _which would cost 5000 gas each time_. Of course, we don't actually\n", '    ///      need to store the new value each time, only once at the very end. So we go through this very annoying\n', '    ///      process of passing the elementalWizardCost in as an argument (tempElementalWizardCost) and returning\n', "    ///      the updated value as a return value (updatedElementalWizardCost). It's enough to make one want\n", "    ///      tear one's hair out. But! What's done is done, and hopefully SOMEONE will realize how much trouble\n", '    ///      we went to to save them _just that little bit_ of gas cost when they decided to buy a schwack of\n', '    ///      Wizards.\n', '    function _conjureWizard(\n', '        uint256 wizardId,\n', '        address owner,\n', '        uint8 affinity,\n', '        uint256 tempElementalWizardCost) private\n', '        returns (uint256 wizardCost, uint256 updatedElementalWizardCost)\n', '    {\n', '        // Check for a valid elemental affinity\n', '        require(affinity > ELEMENT_NOTSET && affinity <= MAX_ELEMENT, "Non-exclusive Wizards need a real affinity");\n', '\n', '        updatedElementalWizardCost = tempElementalWizardCost;\n', '\n', '        // Determine the price\n', '        if (affinity == ELEMENT_NEUTRAL) {\n', '            wizardCost = neutralWizardCost;\n', '        } else {\n', '            wizardCost = updatedElementalWizardCost;\n', '\n', '            // Update the elemental Wizard cost\n', "            // NOTE: This math can't overflow because the total Ether supply in wei is well less than\n", "            //       2^128. Multiplying a price in wei by some number <100k can't possibly overflow 256 bits.\n", '            updatedElementalWizardCost += (updatedElementalWizardCost * elementalWizardIncrement) / TENTH_BASIS_POINTS;\n', '        }\n', '\n', '        // Bring the new Wizard into existence!\n', '        _createWizard(wizardId, owner, costToPower(wizardCost), affinity);\n', '    }\n', '\n', '    /// @notice This is it folks, the main event! The way for the world to get new Wizards! Does\n', "    ///         pretty much what it says on the box: Let's you conjure a new Wizard with a specified\n", '    ///         elemental affinity. The call must include enough eth to cover the cost of the new\n', '    ///         Wizard, and any excess is refunded. The power of the Wizard is derived from\n', '    ///         the sale price. YOU CAN NOT PAY EXTRA TO GET MORE POWER. (But you always have the option\n', '    ///         to conjure some more Wizards!) Returns the ID of the newly conjured Wizard.\n', '    /// @param affinity The elemental affinity you want for your wizard.\n', '    function conjureWizard(uint8 affinity) external payable onlyDuringSale returns (uint256 wizardId) {\n', '\n', '        wizardId = nextWizardId;\n', '        nextWizardId++;\n', '\n', '        uint256 wizardCost;\n', '\n', '        (wizardCost, elementalWizardCost) = _conjureWizard(wizardId, msg.sender, affinity, elementalWizardCost);\n', '\n', '        require(msg.value >= wizardCost, "Not enough eth to pay");\n', '\n', '         // Refund any overpayment\n', '        _transferRefund(wizardCost);\n', '\n', '        // Ensure the Wizard is being assigned to an ERC-721 aware address (either an external address,\n', '        // or a smart contract that implements onERC721Reived())\n', '        require(_checkOnERC721Received(address(0), msg.sender, wizardId, ""), "must support erc721");\n', '    }\n', '\n', '    /// @notice A convenience function that allows you to get a whole bunch of Wizards at once! You know how\n', '    ///         there\'s "a pride of lions", "a murder of crows", and "a parliament of owls"? Well, with this\n', '    ///         here function you can conjure yourself "a stench of Cheeze Wizards"!\n', '    /// @dev This function is careful to bundle all of the external calls (the refund and onERC721Received)\n', '    ///         at the end of the function to limit the risk of reentrancy attacks.\n', '    /// @param affinities the elements of the wizards\n', '    function conjureWizardMulti(uint8[] calldata affinities) external payable onlyDuringSale\n', '            returns (uint256[] memory wizardIds)\n', '    {\n', '        // allocate result array\n', '        wizardIds = new uint256[](affinities.length);\n', '\n', '        uint256 totalCost = 0;\n', '\n', '        // We take these two storage variables, and turn them into local variables for the course\n', "        // of this loop to save about 10k gas per wizard. It's kind of ugly, but that's a lot of\n", "        // gas! Won't somebody please think of the children!!\n", '        uint256 tempWizardId = nextWizardId;\n', '        uint256 tempElementalWizardCost = elementalWizardCost;\n', '\n', '        for (uint256 i = 0; i < affinities.length; i++) {\n', '            wizardIds[i] = tempWizardId;\n', '            tempWizardId++;\n', '\n', '            uint256 wizardCost;\n', '\n', '            (wizardCost, tempElementalWizardCost) = _conjureWizard(\n', '                wizardIds[i],\n', '                msg.sender,\n', '                affinities[i],\n', '                tempElementalWizardCost);\n', '\n', '            totalCost += wizardCost;\n', '        }\n', '\n', '        elementalWizardCost = tempElementalWizardCost;\n', '        nextWizardId = tempWizardId;\n', '\n', "        // check to see if there's enough eth\n", '        require(msg.value >= totalCost, "Not enough eth to pay");\n', '\n', '        // Ensure the Wizard is being assigned to an ERC-721 aware address (either an external address,\n', '        // or a smart contract that implements onERC721Received()). We unwind the logic of _checkOnERC721Received\n', '        // because called address.isContract() every time through this loop can get reasonably expensive. We do\n', "        // need to call this function for each token created, however, because it's allowed for an ERC-721 receiving\n", '        // contract to reject the transfer based on the properties of the token.\n', '        if (isContract(msg.sender)) {\n', '            for (uint256 i = 0; i < wizardIds.length; i++) {\n', '                bytes4 retval = IERC721Receiver(msg.sender).onERC721Received(msg.sender, address(0), wizardIds[i], "");\n', '                require(retval == _ERC721_RECEIVED, "Contract owner didn\'t accept ERC-721 transfer");\n', '            }\n', '        }\n', '\n', '        // Refund any excess funds\n', '        _transferRefund(totalCost);\n', '    }\n', '\n', '    /// @dev Transfers the current balance to the owner and terminates the contract.\n', '    function destroy() external onlyGuildmaster {\n', '        selfdestruct(guildmaster);\n', '    }\n', '}']