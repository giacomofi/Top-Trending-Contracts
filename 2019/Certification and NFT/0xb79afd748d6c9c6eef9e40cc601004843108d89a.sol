['/*\n', ' * This file was generated by MyWish Platform (https://mywish.io/)\n', ' * The complete code could be found at https://github.com/MyWishPlatform/\n', ' * Copyright (C) 2018 MyWish\n', ' *\n', ' * This program is free software: you can redistribute it and/or modify\n', ' * it under the terms of the GNU Lesser General Public License as published by\n', ' * the Free Software Foundation, either version 3 of the License, or\n', ' * (at your option) any later version.\n', ' *\n', ' * This program is distributed in the hope that it will be useful,\n', ' * but WITHOUT ANY WARRANTY; without even the implied warranty of\n', ' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', ' * GNU Lesser General Public License for more details.\n', ' *\n', ' * You should have received a copy of the GNU Lesser General Public License\n', ' * along with this program. If not, see <http://www.gnu.org/licenses/>.\n', ' */\n', 'pragma solidity ^0.5.7;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface without bool returns\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external;\n', '\n', '    function approve(address spender, uint256 value) external;\n', '\n', '    function transferFrom(address from, address to, uint256 value) external;\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'interface ISwaps {\n', '    function createOrder(\n', '        bytes32 _id,\n', '        address _baseAddress,\n', '        address _quoteAddress,\n', '        uint _baseLimit,\n', '        uint _quoteLimit,\n', '        uint _expirationTimestamp,\n', '        address _baseOnlyInvestor,\n', '        uint _minBaseInvestment,\n', '        uint _minQuoteInvestment\n', '    ) external;\n', '\n', '    function deposit(\n', '        bytes32 _id,\n', '        address _token,\n', '        uint _amount\n', '    ) payable external;\n', '\n', '    function cancel(bytes32 _id) external;\n', '\n', '    function refund(bytes32 _id, address _token) external;\n', '}\n', '\n', '\n', 'contract Vault is Ownable {\n', '    address public swaps;\n', '\n', '    modifier onlySwaps() {\n', '        require(msg.sender == swaps);\n', '        _;\n', '    }\n', '\n', '    function () external payable {\n', '    }\n', '\n', '    function tokenFallback(address, uint, bytes calldata) external {\n', '    }\n', '\n', '    function setSwaps(address _swaps) public onlyOwner {\n', '        swaps = _swaps;\n', '    }\n', '\n', '    function withdraw(address _token, address _receiver, uint _amount) public onlySwaps {\n', '        if (_token == address(0)) {\n', '            address(uint160(_receiver)).transfer(_amount);\n', '        } else {\n', '            IERC20(_token).transfer(_receiver, _amount);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract Swaps is Ownable, ISwaps, ReentrancyGuard {\n', '    using SafeMath for uint;\n', '\n', '    uint public MAX_INVESTORS = 10;\n', '\n', '    Vault public vault;\n', '    mapping (bytes32 => address) public baseOnlyInvestor;\n', '    mapping (bytes32 => address) public owners;\n', '    mapping (bytes32 => address) public baseAddresses;\n', '    mapping (bytes32 => address) public quoteAddresses;\n', '    mapping (bytes32 => uint) public expirationTimestamps;\n', '    mapping (bytes32 => bool) public isSwapped;\n', '    mapping (bytes32 => bool) public isCancelled;\n', '    mapping (bytes32 => mapping (address => uint)) public limits;\n', '    mapping (bytes32 => mapping (address => uint)) public raised;\n', '    mapping (bytes32 => mapping (address => address[])) public investors;\n', '    mapping (bytes32 => mapping (address => mapping (address => uint))) public investments;\n', '    mapping (bytes32 => mapping (address => uint)) public minInvestments;\n', '\n', '    modifier onlyInvestor(bytes32 _id, address _token) {\n', '        require(_isInvestor(_id, _token, msg.sender), "Allowed only for investors");\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenVaultDefined() {\n', '        require(address(vault) != address(0), "Vault is not defined");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOrderOwner(bytes32 _id) {\n', '        require(msg.sender == owners[_id], "Allowed only for owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenOrderExists(bytes32 _id) {\n', '        require(owners[_id] != address(0), "Order doesn\'t exist");\n', '        _;\n', '    }\n', '\n', '    event OrderCreated(\n', '        bytes32 id,\n', '        address owner,\n', '        address baseAddress,\n', '        address quoteAddress,\n', '        uint baseLimit,\n', '        uint quoteLimit,\n', '        uint expirationTimestamp,\n', '        address baseOnlyInvestor,\n', '        uint minBaseInvestment,\n', '        uint minQuoteInvestment\n', '    );\n', '\n', '    event OrderCancelled(bytes32 id);\n', '\n', '    event Deposit(\n', '        bytes32 id,\n', '        address token,\n', '        address user,\n', '        uint amount,\n', '        uint balance\n', '    );\n', '\n', '    event Refund(\n', '        bytes32 id,\n', '        address token,\n', '        address user,\n', '        uint amount\n', '    );\n', '\n', '    event OrderSwapped(\n', '        bytes32 id,\n', '        address byUser\n', '    );\n', '\n', '    event SwapSend(\n', '        bytes32 id,\n', '        address token,\n', '        address user,\n', '        uint amount\n', '    );\n', '\n', '    function tokenFallback(address, uint, bytes calldata) external {\n', '    }\n', '\n', '    function createOrder(\n', '        bytes32 _id,\n', '        address _baseAddress,\n', '        address _quoteAddress,\n', '        uint _baseLimit,\n', '        uint _quoteLimit,\n', '        uint _expirationTimestamp,\n', '        address _baseOnlyInvestor,\n', '        uint _minBaseInvestment,\n', '        uint _minQuoteInvestment\n', '    )\n', '        external\n', '        nonReentrant\n', '        onlyWhenVaultDefined\n', '    {\n', '        require(owners[_id] == address(0), "Order already exists");\n', '        require(_baseAddress != _quoteAddress, "Exchanged tokens must be different");\n', '        require(_baseLimit > 0, "Base limit must be positive");\n', '        require(_quoteLimit > 0, "Quote limit must be positive");\n', '        require(_expirationTimestamp > now, "Expiration time must be in future");\n', '\n', '        owners[_id] = msg.sender;\n', '        baseAddresses[_id] = _baseAddress;\n', '        quoteAddresses[_id] = _quoteAddress;\n', '        expirationTimestamps[_id] = _expirationTimestamp;\n', '        limits[_id][_baseAddress] = _baseLimit;\n', '        limits[_id][_quoteAddress] = _quoteLimit;\n', '        baseOnlyInvestor[_id] = _baseOnlyInvestor;\n', '        minInvestments[_id][_baseAddress] = _minBaseInvestment;\n', '        minInvestments[_id][_quoteAddress] = _minQuoteInvestment;\n', '\n', '        emit OrderCreated(\n', '            _id,\n', '            msg.sender,\n', '            _baseAddress,\n', '            _quoteAddress,\n', '            _baseLimit,\n', '            _quoteLimit,\n', '            _expirationTimestamp,\n', '            _baseOnlyInvestor,\n', '            _minBaseInvestment,\n', '            _minQuoteInvestment\n', '        );\n', '    }\n', '\n', '    function deposit(\n', '        bytes32 _id,\n', '        address _token,\n', '        uint _amount\n', '    )\n', '        payable\n', '        external\n', '        nonReentrant\n', '        onlyWhenVaultDefined\n', '        onlyWhenOrderExists(_id)\n', '    {\n', '        if (_token == address(0)) {\n', '            require(msg.value == _amount, "Payable value should be equals value");\n', '            address(vault).transfer(msg.value);\n', '        } else {\n', '            require(msg.value == 0, "Payable not allowed here");\n', '            uint allowance = IERC20(_token).allowance(msg.sender, address(this));\n', '            require(_amount <= allowance, "Allowance should be not less than amount");\n', '            IERC20(_token).transferFrom(msg.sender, address(vault), _amount);\n', '        }\n', '        _deposit(_id, _token, msg.sender, _amount);\n', '    }\n', '\n', '    function cancel(bytes32 _id)\n', '        external\n', '        nonReentrant\n', '        onlyOrderOwner(_id)\n', '        onlyWhenVaultDefined\n', '        onlyWhenOrderExists(_id)\n', '    {\n', '        require(!isCancelled[_id], "Already cancelled");\n', '        require(!isSwapped[_id], "Already swapped");\n', '\n', '        address[2] memory tokens = [baseAddresses[_id], quoteAddresses[_id]];\n', '        for (uint t = 0; t < tokens.length; t++) {\n', '            address token = tokens[t];\n', '            for (uint u = 0; u < investors[_id][token].length; u++) {\n', '                address user = investors[_id][token][u];\n', '                uint userInvestment = investments[_id][token][user];\n', '                vault.withdraw(token, user, userInvestment);\n', '            }\n', '        }\n', '\n', '        isCancelled[_id] = true;\n', '        emit OrderCancelled(_id);\n', '    }\n', '\n', '    function refund(bytes32 _id, address _token)\n', '        external\n', '        nonReentrant\n', '        onlyInvestor(_id, _token)\n', '        onlyWhenVaultDefined\n', '        onlyWhenOrderExists(_id)\n', '    {\n', '        require(!isSwapped[_id], "Already swapped");\n', '        address user = msg.sender;\n', '        uint investment = investments[_id][_token][user];\n', '        if (investment > 0) {\n', '            delete investments[_id][_token][user];\n', '        }\n', '\n', '        _removeInvestor(investors[_id][_token], user);\n', '\n', '        if (investment > 0) {\n', '            raised[_id][_token] = raised[_id][_token].sub(investment);\n', '            vault.withdraw(_token, user, investment);\n', '        }\n', '\n', '        emit Refund(_id, _token, user, investment);\n', '    }\n', '\n', '    function setVault(Vault _vault) external onlyOwner {\n', '        vault = _vault;\n', '    }\n', '\n', '    function createKey(address _owner)\n', '        public\n', '        view\n', '        returns (bytes32 result)\n', '    {\n', '        uint creationTime = now;\n', '        result = 0x0000000000000000000000000000000000000000000000000000000000000000;\n', '        assembly {\n', '            result := or(result, mul(_owner, 0x1000000000000000000000000))\n', '            result := or(result, and(creationTime, 0xffffffffffffffffffffffff))\n', '        }\n', '    }\n', '\n', '    function baseLimit(bytes32 _id)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return limits[_id][baseAddresses[_id]];\n', '    }\n', '\n', '    function quoteLimit(bytes32 _id)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return limits[_id][quoteAddresses[_id]];\n', '    }\n', '\n', '    function baseRaised(bytes32 _id)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return raised[_id][baseAddresses[_id]];\n', '    }\n', '\n', '    function quoteRaised(bytes32 _id)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return raised[_id][quoteAddresses[_id]];\n', '    }\n', '\n', '    function isBaseFilled(bytes32 _id)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return raised[_id][baseAddresses[_id]] == limits[_id][baseAddresses[_id]];\n', '    }\n', '\n', '    function isQuoteFilled(bytes32 _id)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return raised[_id][quoteAddresses[_id]] == limits[_id][quoteAddresses[_id]];\n', '    }\n', '\n', '    function baseInvestors(bytes32 _id)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return investors[_id][baseAddresses[_id]];\n', '    }\n', '\n', '    function quoteInvestors(bytes32 _id)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return investors[_id][quoteAddresses[_id]];\n', '    }\n', '\n', '    function baseUserInvestment(bytes32 _id, address _user)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return investments[_id][baseAddresses[_id]][_user];\n', '    }\n', '\n', '    function quoteUserInvestment(bytes32 _id, address _user)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return investments[_id][quoteAddresses[_id]][_user];\n', '    }\n', '\n', '    function _swap(bytes32 _id) internal {\n', '        require(!isSwapped[_id], "Already swapped");\n', '        require(!isCancelled[_id], "Already cancelled");\n', '        require(isBaseFilled(_id), "Base tokens not filled");\n', '        require(isQuoteFilled(_id), "Quote tokens not filled");\n', '        require(now <= expirationTimestamps[_id], "Contract expired");\n', '\n', '        _distribute(_id, baseAddresses[_id], quoteAddresses[_id]);\n', '        _distribute(_id, quoteAddresses[_id], baseAddresses[_id]);\n', '\n', '        isSwapped[_id] = true;\n', '        emit OrderSwapped(_id, msg.sender);\n', '    }\n', '\n', '    function _distribute(bytes32 _id, address _aSide, address _bSide) internal {\n', '        uint remainder = raised[_id][_bSide];\n', '        for (uint i = 0; i < investors[_id][_aSide].length; i++) {\n', '            address user = investors[_id][_aSide][i];\n', '            uint toPay;\n', '            // last\n', '            if (i + 1 == investors[_id][_aSide].length) {\n', '                toPay = remainder;\n', '            } else {\n', '                uint aSideRaised = raised[_id][_aSide];\n', '                uint userInvestment = investments[_id][_aSide][user];\n', '                uint bSideRaised = raised[_id][_bSide];\n', '                toPay = userInvestment.mul(bSideRaised).div(aSideRaised);\n', '                remainder = remainder.sub(toPay);\n', '            }\n', '\n', '            vault.withdraw(_bSide, user, toPay);\n', '            emit SwapSend(_id, _bSide, user, toPay);\n', '        }\n', '    }\n', '\n', '    function _removeInvestor(address[] storage _array, address _investor) internal {\n', '        uint idx = _array.length - 1;\n', '        for (uint i = 0; i < _array.length - 1; i++) {\n', '            if (_array[i] == _investor) {\n', '                idx = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        _array[idx] = _array[_array.length - 1];\n', '        delete _array[_array.length - 1];\n', '        _array.length--;\n', '    }\n', '\n', '    function _deposit(\n', '        bytes32 _id,\n', '        address _token,\n', '        address _from,\n', '        uint _amount\n', '    ) internal {\n', '        uint amount = _amount;\n', '        require(baseAddresses[_id] == _token || quoteAddresses[_id] == _token, "You can deposit only base or quote currency");\n', '        require(raised[_id][_token] < limits[_id][_token], "Limit already reached");\n', '        require(now <= expirationTimestamps[_id], "Contract expired");\n', '        if (baseAddresses[_id] == _token && baseOnlyInvestor[_id] != address(0)) {\n', '            require(msg.sender == baseOnlyInvestor[_id], "Allowed only for specified address");\n', '        }\n', '        if (limits[_id][_token].sub(raised[_id][_token]) > minInvestments[_id][_token]) {\n', '            require(_amount >= minInvestments[_id][_token], "Should not be less than minimum value");\n', '        }\n', '\n', '        if (!_isInvestor(_id, _token, _from)) {\n', '            require(investors[_id][_token].length < MAX_INVESTORS, "Too many investors");\n', '            investors[_id][_token].push(_from);\n', '        }\n', '\n', '        uint raisedWithOverflow = raised[_id][_token].add(amount);\n', '        if (raisedWithOverflow > limits[_id][_token]) {\n', '            uint overflow = raisedWithOverflow.sub(limits[_id][_token]);\n', '            vault.withdraw(_token, _from, overflow);\n', '            amount = amount.sub(overflow);\n', '        }\n', '\n', '        investments[_id][_token][_from] = investments[_id][_token][_from].add(amount);\n', '\n', '        raised[_id][_token] = raised[_id][_token].add(amount);\n', '        emit Deposit(\n', '            _id,\n', '            _token,\n', '            _from,\n', '            amount,\n', '            investments[_id][_token][_from]\n', '        );\n', '\n', '        if (isBaseFilled(_id) && isQuoteFilled(_id)) {\n', '            _swap(_id);\n', '        }\n', '    }\n', '\n', '    function _isInvestor(\n', '        bytes32 _id,\n', '        address _token,\n', '        address _who\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return investments[_id][_token][_who] > 0;\n', '    }\n', '}']