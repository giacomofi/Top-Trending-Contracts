['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-07\n', '*/\n', '\n', 'pragma solidity 0.5.8;\n', '\n', 'interface IERC20 \n', '{\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\n', '}\n', '\n', 'library SafeMath \n', '{\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0) \n', '        {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function ceil(uint256 a, uint256 m) internal pure returns (uint256) \n', '    {\n', '        uint256 c = add(a,m);\n', '        uint256 d = sub(c,1);\n', '        return mul(div(d,m),m);\n', '    }\n', '}\n', '\n', 'contract ERC20Detailed is IERC20 \n', '{\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '    \n', '    constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '    \n', '    function name() public view returns(string memory) {\n', '        return _name;\n', '    }\n', '    \n', '    function symbol() public view returns(string memory) {\n', '        return _symbol;\n', '    }\n', '    \n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', 'contract AfterShock is ERC20Detailed \n', '{\n', '    using SafeMath for uint256;\n', '    \n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '    \n', '    string constant tokenName = "AfterShock";//"AfterShock";\n', '    string constant tokenSymbol = "SHOCK";//"SHOCK"; \n', '    uint8  constant tokenDecimals = 18;\n', '    uint256 _totalSupply = 0;\n', '    \n', '    // ------------------------------------------------------------------------\n', '  \n', '    address public contractOwner;\n', '\n', '    uint256 public fullUnitsStaked_total = 0;\n', '    mapping (address => bool) public excludedFromStaking; //exchanges/other contracts will be excluded from staking\n', '\n', '    uint256 _totalRewardsPerUnit = 0;\n', '    mapping (address => uint256) private _totalRewardsPerUnit_positions;\n', '    mapping (address => uint256) private _savedRewards;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    \n', '    constructor() public ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) \n', '    {\n', '        contractOwner = msg.sender;\n', '        excludedFromStaking[msg.sender] = true;\n', '        excludedFromStaking[address(this)] = true;\n', '        _mint(msg.sender, 1000000 * (10**uint256(tokenDecimals)));\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '\n', '    function transferOwnership(address newOwner) public \n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(contractOwner, newOwner);\n', '        contractOwner = newOwner;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) \n', '    {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address owner) public view returns (uint256) \n', '    {\n', '        return _balances[owner];\n', '    }\n', '    \n', '    function fullUnitsStaked(address owner) public view returns (uint256) \n', '    {\n', '        return toFullUnits(_balances[owner]);\n', '    }\n', '    \n', '    function toFullUnits(uint256 valueWithDecimals) public pure returns (uint256) \n', '    {\n', '        return valueWithDecimals.div(10**uint256(tokenDecimals));\n', '    }\n', '    \n', '    function allowance(address owner, address spender) public view returns (uint256) \n', '    {\n', '        return _allowed[owner][spender];\n', '    }\n', '    \n', '    function transfer(address to, uint256 value) public returns (bool) \n', '    {\n', '        _executeTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    function multiTransfer(address[] memory receivers, uint256[] memory values) public\n', '    {\n', '        require(receivers.length == values.length);\n', '        for(uint256 i = 0; i < receivers.length; i++)\n', '            _executeTransfer(msg.sender, receivers[i], values[i]);\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) \n', '    {\n', '        require(value <= _allowed[from][msg.sender]);\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _executeTransfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address spender, uint256 value) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) \n', '    {\n', '        _allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '        return true;\n', '    }\n', '    \n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    \n', '    function _mint(address account, uint256 value) internal \n', '    {\n', '        require(value != 0);\n', '        \n', '        uint256 initalBalance = _balances[account];\n', '        uint256 newBalance = initalBalance.add(value);\n', '        \n', '        _balances[account] = newBalance;\n', '        _totalSupply = _totalSupply.add(value);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[account])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance));\n', '            fus_total = fus_total.add(toFullUnits(newBalance));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '    \n', '    function burn(uint256 value) external \n', '    {\n', '        _burn(msg.sender, value);\n', '    }\n', '    \n', '    function burnFrom(address account, uint256 value) external \n', '    {\n', '        require(value <= _allowed[account][msg.sender]);\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '        _burn(account, value);\n', '    }\n', '    \n', '    function _burn(address account, uint256 value) internal \n', '    {\n', '        require(value != 0);\n', '        require(value <= _balances[account]);\n', '        \n', '        uint256 initalBalance = _balances[account];\n', '        uint256 newBalance = initalBalance.sub(value);\n', '        \n', '        _balances[account] = newBalance;\n', '        _totalSupply = _totalSupply.sub(value);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[account])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance));\n', '            fus_total = fus_total.add(toFullUnits(newBalance));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        \n', '        emit Transfer(account, address(0), value);\n', '    }\n', '    \n', '    /*\n', '    *   transfer with additional burn and stake rewards\n', '    *   the receiver gets 94% of the sent value\n', '    *   6% are split to be burnt and distributed to holders\n', '    */\n', '    function _executeTransfer(address from, address to, uint256 value) private\n', '    {\n', '        require(value <= _balances[from]);\n', '        require(to != address(0) && to != address(this));\n', '\n', '        //Update sender and receivers rewards - changing balances will change rewards shares\n', '        updateRewardsFor(from);\n', '        updateRewardsFor(to);\n', '        \n', '        uint256 sixPercent = value.mul(6).div(100);\n', '        \n', '        //set a minimum burn rate to prevent no-burn-txs due to precision loss\n', '        if(sixPercent == 0 && value > 0)\n', '            sixPercent = 1;\n', '            \n', '        uint256 initalBalance_from = _balances[from];\n', '        uint256 newBalance_from = initalBalance_from.sub(value);\n', '        \n', '        value = value.sub(sixPercent);\n', '        \n', '        uint256 initalBalance_to = _balances[to];\n', '        uint256 newBalance_to = initalBalance_to.add(value);\n', '        \n', '        //transfer\n', '        _balances[from] = newBalance_from;\n', '        _balances[to] = newBalance_to;\n', '        emit Transfer(from, to, value);\n', '         \n', '        //update full units staked\n', '        uint256 fus_total = fullUnitsStaked_total;\n', '        if(!excludedFromStaking[from])\n', '        {\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_from));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_from));\n', '        }\n', '        if(!excludedFromStaking[to])\n', '        {\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_to));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_to));\n', '        }\n', '        fullUnitsStaked_total = fus_total;\n', '        \n', '        uint256 amountToBurn = sixPercent;\n', '        \n', '        if(fus_total > 0)\n', '        {\n', '            uint256 stakingRewards = sixPercent.div(2);\n', '            //split up to rewards per unit in stake\n', '            uint256 rewardsPerUnit = stakingRewards.div(fus_total);\n', '            //apply rewards\n', '            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\n', '            _balances[address(this)] = _balances[address(this)].add(stakingRewards);\n', '            emit Transfer(msg.sender, address(this), stakingRewards);\n', '    \n', '            amountToBurn = amountToBurn.sub(stakingRewards);\n', '        }\n', '        \n', '        //update total supply\n', '        _totalSupply = _totalSupply.sub(amountToBurn);\n', '        emit Transfer(msg.sender, address(0), amountToBurn);\n', '    }\n', '    \n', '    //catch up with the current total rewards. This needs to be done before an addresses balance is changed\n', '    function updateRewardsFor(address staker) private\n', '    {\n', '        _savedRewards[staker] = viewUnpaidRewards(staker);\n', '        _totalRewardsPerUnit_positions[staker] = _totalRewardsPerUnit;\n', '    }\n', '    \n', '    //get all rewards that have not been claimed yet\n', '    function viewUnpaidRewards(address staker) public view returns (uint256)\n', '    {\n', '        if(excludedFromStaking[staker])\n', '            return _savedRewards[staker];\n', '        uint256 newRewardsPerUnit = _totalRewardsPerUnit.sub(_totalRewardsPerUnit_positions[staker]);\n', '        \n', '        uint256 newRewards = newRewardsPerUnit.mul(fullUnitsStaked(staker));\n', '        return _savedRewards[staker].add(newRewards);\n', '    }\n', '    \n', '    //pay out unclaimed rewards\n', '    function payoutRewards() public\n', '    {\n', '        updateRewardsFor(msg.sender);\n', '        uint256 rewards = _savedRewards[msg.sender];\n', '        require(rewards > 0 && rewards <= _balances[address(this)]);\n', '        \n', '        _savedRewards[msg.sender] = 0;\n', '        \n', '        uint256 initalBalance_staker = _balances[msg.sender];\n', '        uint256 newBalance_staker = initalBalance_staker.add(rewards);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[msg.sender])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_staker));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_staker));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        \n', '        //transfer\n', '        _balances[address(this)] = _balances[address(this)].sub(rewards);\n', '        _balances[msg.sender] = newBalance_staker;\n', '        emit Transfer(address(this), msg.sender, rewards);\n', '    }\n', '    \n', '    //exchanges or other contracts can be excluded from receiving stake rewards\n', '    function excludeAddressFromStaking(address excludeAddress, bool exclude) public\n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(excludeAddress != address(this)); //contract may never be included\n', '        require(exclude != excludedFromStaking[excludeAddress]);\n', '        updateRewardsFor(excludeAddress);\n', '        excludedFromStaking[excludeAddress] = exclude;\n', '        fullUnitsStaked_total = exclude ? fullUnitsStaked_total.sub(fullUnitsStaked(excludeAddress)) : fullUnitsStaked_total.add(fullUnitsStaked(excludeAddress));\n', '    }\n', '    \n', '    //withdraw tokens that were sent to this contract by accident\n', '    function withdrawERC20Tokens(address tokenAddress, uint256 amount) public\n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(tokenAddress != address(this));\n', '        IERC20(tokenAddress).transfer(msg.sender, amount);\n', '    }\n', '    \n', '}']
['pragma solidity 0.5.8;\n', '\n', 'interface IERC20 \n', '{\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\n', '}\n', '\n', 'library SafeMath \n', '{\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0) \n', '        {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function ceil(uint256 a, uint256 m) internal pure returns (uint256) \n', '    {\n', '        uint256 c = add(a,m);\n', '        uint256 d = sub(c,1);\n', '        return mul(div(d,m),m);\n', '    }\n', '}\n', '\n', 'contract ERC20Detailed is IERC20 \n', '{\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '    \n', '    constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '    \n', '    function name() public view returns(string memory) {\n', '        return _name;\n', '    }\n', '    \n', '    function symbol() public view returns(string memory) {\n', '        return _symbol;\n', '    }\n', '    \n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', 'contract AfterShock is ERC20Detailed \n', '{\n', '    using SafeMath for uint256;\n', '    \n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '    \n', '    string constant tokenName = "AfterShock";//"AfterShock";\n', '    string constant tokenSymbol = "SHOCK";//"SHOCK"; \n', '    uint8  constant tokenDecimals = 18;\n', '    uint256 _totalSupply = 0;\n', '    \n', '    // ------------------------------------------------------------------------\n', '  \n', '    address public contractOwner;\n', '\n', '    uint256 public fullUnitsStaked_total = 0;\n', '    mapping (address => bool) public excludedFromStaking; //exchanges/other contracts will be excluded from staking\n', '\n', '    uint256 _totalRewardsPerUnit = 0;\n', '    mapping (address => uint256) private _totalRewardsPerUnit_positions;\n', '    mapping (address => uint256) private _savedRewards;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    \n', '    constructor() public ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) \n', '    {\n', '        contractOwner = msg.sender;\n', '        excludedFromStaking[msg.sender] = true;\n', '        excludedFromStaking[address(this)] = true;\n', '        _mint(msg.sender, 1000000 * (10**uint256(tokenDecimals)));\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '\n', '    function transferOwnership(address newOwner) public \n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(contractOwner, newOwner);\n', '        contractOwner = newOwner;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) \n', '    {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address owner) public view returns (uint256) \n', '    {\n', '        return _balances[owner];\n', '    }\n', '    \n', '    function fullUnitsStaked(address owner) public view returns (uint256) \n', '    {\n', '        return toFullUnits(_balances[owner]);\n', '    }\n', '    \n', '    function toFullUnits(uint256 valueWithDecimals) public pure returns (uint256) \n', '    {\n', '        return valueWithDecimals.div(10**uint256(tokenDecimals));\n', '    }\n', '    \n', '    function allowance(address owner, address spender) public view returns (uint256) \n', '    {\n', '        return _allowed[owner][spender];\n', '    }\n', '    \n', '    function transfer(address to, uint256 value) public returns (bool) \n', '    {\n', '        _executeTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    function multiTransfer(address[] memory receivers, uint256[] memory values) public\n', '    {\n', '        require(receivers.length == values.length);\n', '        for(uint256 i = 0; i < receivers.length; i++)\n', '            _executeTransfer(msg.sender, receivers[i], values[i]);\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) \n', '    {\n', '        require(value <= _allowed[from][msg.sender]);\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _executeTransfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address spender, uint256 value) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) \n', '    {\n', '        _allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '        return true;\n', '    }\n', '    \n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    \n', '    function _mint(address account, uint256 value) internal \n', '    {\n', '        require(value != 0);\n', '        \n', '        uint256 initalBalance = _balances[account];\n', '        uint256 newBalance = initalBalance.add(value);\n', '        \n', '        _balances[account] = newBalance;\n', '        _totalSupply = _totalSupply.add(value);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[account])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance));\n', '            fus_total = fus_total.add(toFullUnits(newBalance));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '    \n', '    function burn(uint256 value) external \n', '    {\n', '        _burn(msg.sender, value);\n', '    }\n', '    \n', '    function burnFrom(address account, uint256 value) external \n', '    {\n', '        require(value <= _allowed[account][msg.sender]);\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '        _burn(account, value);\n', '    }\n', '    \n', '    function _burn(address account, uint256 value) internal \n', '    {\n', '        require(value != 0);\n', '        require(value <= _balances[account]);\n', '        \n', '        uint256 initalBalance = _balances[account];\n', '        uint256 newBalance = initalBalance.sub(value);\n', '        \n', '        _balances[account] = newBalance;\n', '        _totalSupply = _totalSupply.sub(value);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[account])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance));\n', '            fus_total = fus_total.add(toFullUnits(newBalance));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        \n', '        emit Transfer(account, address(0), value);\n', '    }\n', '    \n', '    /*\n', '    *   transfer with additional burn and stake rewards\n', '    *   the receiver gets 94% of the sent value\n', '    *   6% are split to be burnt and distributed to holders\n', '    */\n', '    function _executeTransfer(address from, address to, uint256 value) private\n', '    {\n', '        require(value <= _balances[from]);\n', '        require(to != address(0) && to != address(this));\n', '\n', '        //Update sender and receivers rewards - changing balances will change rewards shares\n', '        updateRewardsFor(from);\n', '        updateRewardsFor(to);\n', '        \n', '        uint256 sixPercent = value.mul(6).div(100);\n', '        \n', '        //set a minimum burn rate to prevent no-burn-txs due to precision loss\n', '        if(sixPercent == 0 && value > 0)\n', '            sixPercent = 1;\n', '            \n', '        uint256 initalBalance_from = _balances[from];\n', '        uint256 newBalance_from = initalBalance_from.sub(value);\n', '        \n', '        value = value.sub(sixPercent);\n', '        \n', '        uint256 initalBalance_to = _balances[to];\n', '        uint256 newBalance_to = initalBalance_to.add(value);\n', '        \n', '        //transfer\n', '        _balances[from] = newBalance_from;\n', '        _balances[to] = newBalance_to;\n', '        emit Transfer(from, to, value);\n', '         \n', '        //update full units staked\n', '        uint256 fus_total = fullUnitsStaked_total;\n', '        if(!excludedFromStaking[from])\n', '        {\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_from));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_from));\n', '        }\n', '        if(!excludedFromStaking[to])\n', '        {\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_to));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_to));\n', '        }\n', '        fullUnitsStaked_total = fus_total;\n', '        \n', '        uint256 amountToBurn = sixPercent;\n', '        \n', '        if(fus_total > 0)\n', '        {\n', '            uint256 stakingRewards = sixPercent.div(2);\n', '            //split up to rewards per unit in stake\n', '            uint256 rewardsPerUnit = stakingRewards.div(fus_total);\n', '            //apply rewards\n', '            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\n', '            _balances[address(this)] = _balances[address(this)].add(stakingRewards);\n', '            emit Transfer(msg.sender, address(this), stakingRewards);\n', '    \n', '            amountToBurn = amountToBurn.sub(stakingRewards);\n', '        }\n', '        \n', '        //update total supply\n', '        _totalSupply = _totalSupply.sub(amountToBurn);\n', '        emit Transfer(msg.sender, address(0), amountToBurn);\n', '    }\n', '    \n', '    //catch up with the current total rewards. This needs to be done before an addresses balance is changed\n', '    function updateRewardsFor(address staker) private\n', '    {\n', '        _savedRewards[staker] = viewUnpaidRewards(staker);\n', '        _totalRewardsPerUnit_positions[staker] = _totalRewardsPerUnit;\n', '    }\n', '    \n', '    //get all rewards that have not been claimed yet\n', '    function viewUnpaidRewards(address staker) public view returns (uint256)\n', '    {\n', '        if(excludedFromStaking[staker])\n', '            return _savedRewards[staker];\n', '        uint256 newRewardsPerUnit = _totalRewardsPerUnit.sub(_totalRewardsPerUnit_positions[staker]);\n', '        \n', '        uint256 newRewards = newRewardsPerUnit.mul(fullUnitsStaked(staker));\n', '        return _savedRewards[staker].add(newRewards);\n', '    }\n', '    \n', '    //pay out unclaimed rewards\n', '    function payoutRewards() public\n', '    {\n', '        updateRewardsFor(msg.sender);\n', '        uint256 rewards = _savedRewards[msg.sender];\n', '        require(rewards > 0 && rewards <= _balances[address(this)]);\n', '        \n', '        _savedRewards[msg.sender] = 0;\n', '        \n', '        uint256 initalBalance_staker = _balances[msg.sender];\n', '        uint256 newBalance_staker = initalBalance_staker.add(rewards);\n', '        \n', '        //update full units staked\n', '        if(!excludedFromStaking[msg.sender])\n', '        {\n', '            uint256 fus_total = fullUnitsStaked_total;\n', '            fus_total = fus_total.sub(toFullUnits(initalBalance_staker));\n', '            fus_total = fus_total.add(toFullUnits(newBalance_staker));\n', '            fullUnitsStaked_total = fus_total;\n', '        }\n', '        \n', '        //transfer\n', '        _balances[address(this)] = _balances[address(this)].sub(rewards);\n', '        _balances[msg.sender] = newBalance_staker;\n', '        emit Transfer(address(this), msg.sender, rewards);\n', '    }\n', '    \n', '    //exchanges or other contracts can be excluded from receiving stake rewards\n', '    function excludeAddressFromStaking(address excludeAddress, bool exclude) public\n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(excludeAddress != address(this)); //contract may never be included\n', '        require(exclude != excludedFromStaking[excludeAddress]);\n', '        updateRewardsFor(excludeAddress);\n', '        excludedFromStaking[excludeAddress] = exclude;\n', '        fullUnitsStaked_total = exclude ? fullUnitsStaked_total.sub(fullUnitsStaked(excludeAddress)) : fullUnitsStaked_total.add(fullUnitsStaked(excludeAddress));\n', '    }\n', '    \n', '    //withdraw tokens that were sent to this contract by accident\n', '    function withdrawERC20Tokens(address tokenAddress, uint256 amount) public\n', '    {\n', '        require(msg.sender == contractOwner);\n', '        require(tokenAddress != address(this));\n', '        IERC20(tokenAddress).transfer(msg.sender, amount);\n', '    }\n', '    \n', '}']
