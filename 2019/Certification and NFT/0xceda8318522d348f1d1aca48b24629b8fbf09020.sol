['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-11\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c8baada5aba788fa">[email&#160;protected]</a>Ï€.com>, Eenae <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="41202d24392438012c283923383524326f282e">[email&#160;protected]</a>>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/core/lib/RebalancingLibraryV2.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingLibrary\n', ' * @author Set Protocol\n', ' *\n', ' * The RebalancingLibrary contains functions for facilitating the rebalancing process for\n', ' * Rebalancing Set Tokens. Removes the old calculation functions\n', ' *\n', ' */\n', 'library RebalancingLibraryV2 {\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ Enums ============ */\n', '\n', '    enum State { Default, Proposal, Rebalance, Drawdown }\n', '\n', '    /* ============ Structs ============ */\n', '\n', '    struct AuctionPriceParameters {\n', '        uint256 auctionStartTime;\n', '        uint256 auctionTimeToPivot;\n', '        uint256 auctionStartPrice;\n', '        uint256 auctionPivotPrice;\n', '    }\n', '\n', '    struct BiddingParameters {\n', '        uint256 minimumBid;\n', '        uint256 remainingCurrentSets;\n', '        uint256[] combinedCurrentUnits;\n', '        uint256[] combinedNextSetUnits;\n', '        address[] combinedTokenArray;\n', '    }\n', '}\n', '\n', '// File: contracts/core/interfaces/IRebalancingSetTokenV2.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IRebalancingSetTokenV2\n', ' * @author Set Protocol\n', ' *\n', ' * The IRebalancingSetToken interface provides a light-weight, structured way to interact with the\n', ' * RebalancingSetToken contract from another contract.\n', ' */\n', '\n', 'interface IRebalancingSetTokenV2 {\n', '\n', '    /*\n', '     * Get totalSupply of Rebalancing Set\n', '     *\n', '     * @return  totalSupply\n', '     */\n', '    function totalSupply()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get lastRebalanceTimestamp of Rebalancing Set\n', '     *\n', '     * @return  lastRebalanceTimestamp\n', '     */\n', '    function lastRebalanceTimestamp()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get rebalanceInterval of Rebalancing Set\n', '     *\n', '     * @return  rebalanceInterval\n', '     */\n', '    function rebalanceInterval()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get rebalanceState of Rebalancing Set\n', '     *\n', '     * @return  rebalanceState\n', '     */\n', '    function rebalanceState()\n', '        external\n', '        view\n', '        returns (RebalancingLibraryV2.State);\n', '\n', '    /**\n', '     * Gets the balance of the specified address.\n', '     *\n', '     * @param owner      The address to query the balance of.\n', '     * @return           A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(\n', '        address owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Function used to set the terms of the next rebalance and start the proposal period\n', '     *\n', '     * @param _nextSet                      The Set to rebalance into\n', '     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\n', '     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\n', '     * @param _auctionStartPrice            The price to start the auction at\n', '     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\n', '     */\n', '    function propose(\n', '        address _nextSet,\n', '        address _auctionLibrary,\n', '        uint256 _auctionTimeToPivot,\n', '        uint256 _auctionStartPrice,\n', '        uint256 _auctionPivotPrice\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Get natural unit of Set\n', '     *\n', '     * @return  uint256       Natural unit of Set\n', '     */\n', '    function naturalUnit()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Returns the address of the current Base Set\n', '     *\n', '     * @return           A address representing the base Set Token\n', '     */\n', '    function currentSet()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /*\n', '     * Get the unit shares of the rebalancing Set\n', '     *\n', '     * @return  unitShares       Unit Shares of the base Set\n', '     */\n', '    function unitShares()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Burn set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _from        The address of the redeeming account\n', '     * @param  _quantity    The number of sets to burn from redeemer\n', '     */\n', '    function burn(\n', '        address _from,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Place bid during rebalance auction. Can only be called by Core.\n', '     *\n', '     * @param _quantity                 The amount of currentSet to be rebalanced\n', '     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\n', '     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\n', '     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\n', '     */\n', '    function placeBid(\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (address[] memory, uint256[] memory, uint256[] memory);\n', '\n', '    /*\n', '     * Get combinedTokenArray of Rebalancing Set\n', '     *\n', '     * @return  combinedTokenArray\n', '     */\n', '    function getCombinedTokenArrayLength()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get combinedTokenArray of Rebalancing Set\n', '     *\n', '     * @return  combinedTokenArray\n', '     */\n', '    function getCombinedTokenArray()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get failedAuctionWithdrawComponents of Rebalancing Set\n', '     *\n', '     * @return  failedAuctionWithdrawComponents\n', '     */\n', '    function getFailedAuctionWithdrawComponents()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get biddingParameters for current auction\n', '     *\n', '     * @return  biddingParameters\n', '     */\n', '    function getBiddingParameters()\n', '        external\n', '        view\n', '        returns (uint256[] memory);\n', '\n', '}\n', '\n', '// File: contracts/core/interfaces/ISetToken.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title ISetToken\n', ' * @author Set Protocol\n', ' *\n', ' * The ISetToken interface provides a light-weight, structured way to interact with the\n', ' * SetToken contract from another contract.\n', ' */\n', 'interface ISetToken {\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /*\n', '     * Get natural unit of Set\n', '     *\n', '     * @return  uint256       Natural unit of Set\n', '     */\n', '    function naturalUnit()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get addresses of all components in the Set\n', '     *\n', '     * @return  componentAddresses       Array of component tokens\n', '     */\n', '    function getComponents()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get units of all tokens in Set\n', '     *\n', '     * @return  units       Array of component units\n', '     */\n', '    function getUnits()\n', '        external\n', '        view\n', '        returns (uint256[] memory);\n', '\n', '    /*\n', '     * Checks to make sure token is component of Set\n', '     *\n', '     * @param  _tokenAddress     Address of token being checked\n', '     * @return  bool             True if token is component of Set\n', '     */\n', '    function tokenIsComponent(\n', '        address _tokenAddress\n', '    )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /*\n', '     * Mint set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _issuer      The address of the issuing account\n', '     * @param  _quantity    The number of sets to attribute to issuer\n', '     */\n', '    function mint(\n', '        address _issuer,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Burn set token for given address\n', '     * Can only be called by authorized contracts\n', '     *\n', '     * @param  _from        The address of the redeeming account\n', '     * @param  _quantity    The number of sets to burn from redeemer\n', '     */\n', '    function burn(\n', '        address _from,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '    * Transfer token for a specified address\n', '    *\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/IWETH.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IWETH\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for Wrapped Ether. This interface allows for interaction for wrapped ether&#39;s deposit and withdrawal\n', ' * functionality.\n', ' */\n', 'interface IWETH {\n', '    function deposit()\n', '        external\n', '        payable;\n', '\n', '    function withdraw(\n', '        uint256 wad\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/CommonMath.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'library CommonMath {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUInt256()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0);\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Checks for rounding errors and returns value of potential partial amounts of a principal\n', '     *\n', '     * @param  _principal       Number fractional amount is derived from\n', '     * @param  _numerator       Numerator of fraction\n', '     * @param  _denominator     Denominator of fraction\n', '     * @return uint256          Fractional amount of principal calculated\n', '     */\n', '    function getPartialAmount(\n', '        uint256 _principal,\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Get remainder of partial amount (if 0 not a partial amount)\n', '        uint256 remainder = mulmod(_principal, _numerator, _denominator);\n', '\n', '        // Return if not a partial amount\n', '        if (remainder == 0) {\n', '            return _principal.mul(_numerator).div(_denominator);\n', '        }\n', '\n', '        // Calculate error percentage\n', '        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\n', '\n', '        // Require error percentage is less than 0.1%.\n', '        require(\n', '            errPercentageTimes1000000 < 1000,\n', '            "CommonMath.getPartialAmount: Rounding error exceeds bounds"\n', '        );\n', '\n', '        return _principal.mul(_numerator).div(_denominator);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lib/IERC20.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IERC20\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for using ERC20 Tokens. This interface is needed to interact with tokens that are not\n', ' * fully ERC20 compliant and return something other than true on successful transfers.\n', ' */\n', 'interface IERC20 {\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC20Wrapper.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Wrapper\n', ' * @author Set Protocol\n', ' *\n', ' * This library contains functions for interacting wtih ERC20 tokens, even those not fully compliant.\n', ' * For all functions we will only accept tokens that return a null or true value, any other values will\n', ' * cause the operation to revert.\n', ' */\n', 'library ERC20Wrapper {\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    /**\n', '     * Check balance owner&#39;s balance of ERC20 token\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The owner who&#39;s balance is being checked\n', '     * @return  uint256        The _owner&#39;s amount of tokens\n', '     */\n', '    function balanceOf(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).balanceOf(_owner);\n', '    }\n', '\n', '    /**\n', '     * Checks spender&#39;s allowance to use token&#39;s on owner&#39;s behalf.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The token owner address\n', '     * @param  _spender        The address the allowance is being checked on\n', '     * @return  uint256        The spender&#39;s allowance on behalf of owner\n', '     */\n', '    function allowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).allowance(_owner, _spender);\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address. Handle&#39;s tokens that return true or null.\n', '     * If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The amount of tokens to transfer\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transfer(_to, _quantity);\n', '\n', '        // Check that transfer returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transfer: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Handle&#39;s tokens that return true or null. If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function transferFrom(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transferFrom(_from, _to, _quantity);\n', '\n', '        // Check that transferFrom returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transferFrom: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Grants spender ability to spend on owner&#39;s behalf.\n', '     * Handle&#39;s tokens that return true or null. If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _spender        The address to approve for transfer\n', '     * @param  _quantity       The amount of tokens to approve spender for\n', '     */\n', '    function approve(\n', '        address _token,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        IERC20(_token).approve(_spender, _quantity);\n', '\n', '        // Check that approve returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.approve: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Ensure&#39;s the owner has granted enough allowance for system to\n', '     * transfer tokens.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The address of the token owner\n', '     * @param  _spender        The address to grant/check allowance for\n', '     * @param  _quantity       The amount to see if allowed for\n', '     */\n', '    function ensureAllowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        uint256 currentAllowance = allowance(_token, _owner, _spender);\n', '        if (currentAllowance < _quantity) {\n', '            approve(\n', '                _token,\n', '                _spender,\n', '                CommonMath.maxUInt256()\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 1.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // default to failure\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        // check if returned value is one or nothing\n', '        return returnValue == 1;\n', '    }\n', '}\n', '\n', '// File: contracts/core/interfaces/ICore.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title ICore\n', ' * @author Set Protocol\n', ' *\n', ' * The ICore Contract defines all the functions exposed in the Core through its\n', ' * various extensions and is a light weight way to interact with the contract.\n', ' */\n', 'interface ICore {\n', '    /**\n', '     * Return transferProxy address.\n', '     *\n', '     * @return address       transferProxy address\n', '     */\n', '    function transferProxy()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /**\n', '     * Return vault address.\n', '     *\n', '     * @return address       vault address\n', '     */\n', '    function vault()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /**\n', '     * Return address belonging to given exchangeId.\n', '     *\n', '     * @param  _exchangeId       ExchangeId number\n', '     * @return address           Address belonging to given exchangeId\n', '     */\n', '    function exchangeIds(\n', '        uint8 _exchangeId\n', '    )\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /*\n', '     * Returns if valid set\n', '     *\n', '     * @return  bool      Returns true if Set created through Core and isn&#39;t disabled\n', '     */\n', '    function validSets(address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /*\n', '     * Returns if valid module\n', '     *\n', '     * @return  bool      Returns true if valid module\n', '     */\n', '    function validModules(address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /**\n', '     * Return boolean indicating if address is a valid Rebalancing Price Library.\n', '     *\n', '     * @param  _priceLibrary    Price library address\n', '     * @return bool             Boolean indicating if valid Price Library\n', '     */\n', '    function validPriceLibraries(\n', '        address _priceLibrary\n', '    )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /**\n', '     * Exchanges components for Set Tokens\n', '     *\n', '     * @param  _set          Address of set to issue\n', '     * @param  _quantity     Quantity of set to issue\n', '     */\n', '    function issue(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Issues a specified Set for a specified quantity to the recipient\n', '     * using the caller&#39;s components from the wallet and vault.\n', '     *\n', '     * @param  _recipient    Address to issue to\n', '     * @param  _set          Address of the Set to issue\n', '     * @param  _quantity     Number of tokens to issue\n', '     */\n', '    function issueTo(\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Converts user&#39;s components into Set Tokens held directly in Vault instead of user&#39;s account\n', '     *\n', '     * @param _set          Address of the Set\n', '     * @param _quantity     Number of tokens to redeem\n', '     */\n', '    function issueInVault(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Function to convert Set Tokens into underlying components\n', '     *\n', '     * @param _set          The address of the Set token\n', '     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n', '     */\n', '    function redeem(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Redeem Set token and return components to specified recipient. The components\n', '     * are left in the vault\n', '     *\n', '     * @param _recipient    Recipient of Set being issued\n', '     * @param _set          Address of the Set\n', '     * @param _quantity     Number of tokens to redeem\n', '     */\n', '    function redeemTo(\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Function to convert Set Tokens held in vault into underlying components\n', '     *\n', '     * @param _set          The address of the Set token\n', '     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n', '     */\n', '    function redeemInVault(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Composite method to redeem and withdraw with a single transaction\n', '     *\n', '     * Normally, you should expect to be able to withdraw all of the tokens.\n', '     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\n', '     * allows you to optionally specify which component tokens to exclude when\n', '     * redeeming. They will remain in the vault under the users&#39; addresses.\n', '     *\n', '     * @param _set          Address of the Set\n', '     * @param _to           Address to withdraw or attribute tokens to\n', '     * @param _quantity     Number of tokens to redeem\n', '     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\n', '     */\n', '    function redeemAndWithdrawTo(\n', '        address _set,\n', '        address _to,\n', '        uint256 _quantity,\n', '        uint256 _toExclude\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deposit multiple tokens to the vault. Quantities should be in the\n', '     * order of the addresses of the tokens being deposited.\n', '     *\n', '     * @param  _tokens           Array of the addresses of the ERC20 tokens\n', '     * @param  _quantities       Array of the number of tokens to deposit\n', '     */\n', '    function batchDeposit(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Withdraw multiple tokens from the vault. Quantities should be in the\n', '     * order of the addresses of the tokens being withdrawn.\n', '     *\n', '     * @param  _tokens            Array of the addresses of the ERC20 tokens\n', '     * @param  _quantities        Array of the number of tokens to withdraw\n', '     */\n', '    function batchWithdraw(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deposit any quantity of tokens into the vault.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _quantity        The number of tokens to deposit\n', '     */\n', '    function deposit(\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Withdraw a quantity of tokens from the vault.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _quantity        The number of tokens to withdraw\n', '     */\n', '    function withdraw(\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfer tokens associated with the sender&#39;s account in vault to another user&#39;s\n', '     * account in vault.\n', '     *\n', '     * @param  _token           Address of token being transferred\n', '     * @param  _to              Address of user receiving tokens\n', '     * @param  _quantity        Amount of tokens being transferred\n', '     */\n', '    function internalTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deploys a new Set Token and adds it to the valid list of SetTokens\n', '     *\n', '     * @param  _factory              The address of the Factory to create from\n', '     * @param  _components           The address of component tokens\n', '     * @param  _units                The units of each component token\n', '     * @param  _naturalUnit          The minimum unit to be issued or redeemed\n', '     * @param  _name                 The bytes32 encoded name of the new Set\n', '     * @param  _symbol               The bytes32 encoded symbol of the new Set\n', '     * @param  _callData             Byte string containing additional call parameters\n', '     * @return setTokenAddress       The address of the new Set\n', '     */\n', '    function createSet(\n', '        address _factory,\n', '        address[] calldata _components,\n', '        uint256[] calldata _units,\n', '        uint256 _naturalUnit,\n', '        bytes32 _name,\n', '        bytes32 _symbol,\n', '        bytes calldata _callData\n', '    )\n', '        external\n', '        returns (address);\n', '\n', '    /**\n', '     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\n', '     * the tokens respectively, to system modules.\n', '     *\n', '     * @param  _from            Address to transfer tokens from\n', '     * @param  _to              Address to credit for deposit\n', '     * @param  _token           Address of token being deposited\n', '     * @param  _quantity        Amount of tokens to deposit\n', '     */\n', '    function depositModule(\n', '        address _from,\n', '        address _to,\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that withdraws a quantity of tokens from the vault and\n', '     * deattributes the tokens respectively, to system modules.\n', '     *\n', '     * @param  _from            Address to decredit for withdraw\n', '     * @param  _to              Address to transfer tokens to\n', '     * @param  _token           Address of token being withdrawn\n', '     * @param  _quantity        Amount of tokens to withdraw\n', '     */\n', '    function withdrawModule(\n', '        address _from,\n', '        address _to,\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that deposits multiple tokens to the vault, to system\n', '     * modules. Quantities should be in the order of the addresses of the tokens being\n', '     * deposited.\n', '     *\n', '     * @param  _from              Address to transfer tokens from\n', '     * @param  _to                Address to credit for deposits\n', '     * @param  _tokens            Array of the addresses of the tokens being deposited\n', '     * @param  _quantities        Array of the amounts of tokens to deposit\n', '     */\n', '    function batchDepositModule(\n', '        address _from,\n', '        address _to,\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that withdraws multiple tokens from the vault, to system\n', '     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\n', '     *\n', '     * @param  _from              Address to decredit for withdrawals\n', '     * @param  _to                Address to transfer tokens to\n', '     * @param  _tokens            Array of the addresses of the tokens being withdrawn\n', '     * @param  _quantities        Array of the amounts of tokens to withdraw\n', '     */\n', '    function batchWithdrawModule(\n', '        address _from,\n', '        address _to,\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose internal function that exchanges components for Set tokens,\n', '     * accepting any owner, to system modules\n', '     *\n', '     * @param  _owner        Address to use tokens from\n', '     * @param  _recipient    Address to issue Set to\n', '     * @param  _set          Address of the Set to issue\n', '     * @param  _quantity     Number of tokens to issue\n', '     */\n', '    function issueModule(\n', '        address _owner,\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose internal function that exchanges Set tokens for components,\n', '     * accepting any owner, to system modules\n', '     *\n', '     * @param  _burnAddress         Address to burn token from\n', '     * @param  _incrementAddress    Address to increment component tokens to\n', '     * @param  _set                 Address of the Set to redeem\n', '     * @param  _quantity            Number of tokens to redeem\n', '     */\n', '    function redeemModule(\n', '        address _burnAddress,\n', '        address _incrementAddress,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose vault function that increments user&#39;s balance in the vault.\n', '     * Available to system modules\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchIncrementTokenOwnerModule(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose vault function that decrement user&#39;s balance in the vault\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchDecrementTokenOwnerModule(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose vault function that transfer vault balances between users\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens           Addresses of tokens being transferred\n', '     * @param  _from             Address tokens being transferred from\n', '     * @param  _to               Address tokens being transferred to\n', '     * @param  _quantities       Amounts of tokens being transferred\n', '     */\n', '    function batchTransferBalanceModule(\n', '        address[] calldata _tokens,\n', '        address _from,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers token from one address to another using the transfer proxy.\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _quantity       The number of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function transferModule(\n', '        address _token,\n', '        uint256 _quantity,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose transfer proxy function to transfer tokens from one address to another\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens         The addresses of the ERC20 token\n', '     * @param  _quantities     The numbers of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function batchTransferModule(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/core/interfaces/ITransferProxy.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title ITransferProxy\n', ' * @author Set Protocol\n', ' *\n', ' * The ITransferProxy interface provides a light-weight, structured way to interact with the\n', ' * TransferProxy contract from another contract.\n', ' */\n', 'interface ITransferProxy {\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by authorized core contracts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _quantity       The number of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        uint256 _quantity,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens         The addresses of the ERC20 token\n', '     * @param  _quantities     The numbers of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function batchTransfer(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/core/interfaces/IVault.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title IVault\n', ' * @author Set Protocol\n', ' *\n', ' * The IVault interface provides a light-weight, structured way to interact with the Vault\n', ' * contract from another contract.\n', ' */\n', 'interface IVault {\n', '\n', '    /*\n', '     * Withdraws user&#39;s unassociated tokens to user account. Can only be\n', '     * called by authorized core contracts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer token to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function withdrawTo(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Increment quantity owned of a token for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantity        The number of tokens to attribute to owner\n', '     */\n', '    function incrementTokenOwner(\n', '        address _token,\n', '        address _owner,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Decrement quantity owned of a token for a given address. Can only\n', '     * be called by authorized core contracts.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantity        The number of tokens to deattribute to owner\n', '     */\n', '    function decrementTokenOwner(\n', '        address _token,\n', '        address _owner,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers tokens associated with one account to another account in the vault\n', '     *\n', '     * @param  _token          Address of token being transferred\n', '     * @param  _from           Address token being transferred from\n', '     * @param  _to             Address token being transferred to\n', '     * @param  _quantity       Amount of tokens being transferred\n', '     */\n', '\n', '    function transferBalance(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '\n', '    /*\n', '     * Withdraws user&#39;s unassociated tokens to user account. Can only be\n', '     * called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchWithdrawTo(\n', '        address[] calldata _tokens,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Increment quantites owned of a collection of tokens for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchIncrementTokenOwner(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Decrements quantites owned of a collection of tokens for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchDecrementTokenOwner(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '   /**\n', '     * Transfers tokens associated with one account to another account in the vault\n', '     *\n', '     * @param  _tokens           Addresses of tokens being transferred\n', '     * @param  _from             Address tokens being transferred from\n', '     * @param  _to               Address tokens being transferred to\n', '     * @param  _quantities       Amounts of tokens being transferred\n', '     */\n', '    function batchTransferBalance(\n', '        address[] calldata _tokens,\n', '        address _from,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Get balance of particular contract for owner.\n', '     *\n', '     * @param  _token    The address of the ERC20 token\n', '     * @param  _owner    The address of the token owner\n', '     */\n', '    function getOwnerBalance(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/core/modules/lib/ModuleCoreState.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ModuleCoreState\n', ' * @author Set Protocol\n', ' *\n', ' * The ModuleCoreState library maintains Core-related state for modules\n', ' */\n', 'contract ModuleCoreState {\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    // Address of core contract\n', '    address public core;\n', '\n', '    // Address of vault contract\n', '    address public vault;\n', '\n', '    // Instance of core contract\n', '    ICore public coreInstance;\n', '\n', '    // Instance of vault contract\n', '    IVault public vaultInstance;\n', '\n', '    /* ============ Public Getters ============ */\n', '\n', '    /**\n', '     * Constructor function for ModuleCoreState\n', '     *\n', '     * @param _core                The address of Core\n', '     * @param _vault               The address of Vault\n', '     */\n', '    constructor(\n', '        address _core,\n', '        address _vault\n', '    )\n', '        public\n', '    {\n', '        // Commit passed address to core state variable\n', '        core = _core;\n', '\n', '        // Commit passed address to coreInstance state variable\n', '        coreInstance = ICore(_core);\n', '\n', '        // Commit passed address to vault state variable\n', '        vault = _vault;\n', '\n', '        // Commit passed address to vaultInstance state variable\n', '        vaultInstance = IVault(_vault);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressArrayUtils.sol\n', '\n', '// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\n', '// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'library AddressArrayUtils {\n', '\n', '    /**\n', '     * Finds the index of the first occurrence of the given element.\n', '     * @param A The input array to search\n', '     * @param a The value to find\n', '     * @return Returns (index and isIn) for the first occurrence starting from index 0\n', '     */\n', '    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (A[i] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '    * Returns true if the value is present in the list. Uses indexOf internally.\n', '    * @param A The input array to search\n', '    * @param a The value to find\n', '    * @return Returns isIn for the first occurrence starting from index 0\n', '    */\n', '    function contains(address[] memory A, address a) internal pure returns (bool) {\n', '        bool isIn;\n', '        (, isIn) = indexOf(A, a);\n', '        return isIn;\n', '    }\n', '\n', '    /// @return Returns index and isIn for the first occurrence starting from\n', '    /// end\n', '    function indexOfFromEnd(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = length; i > 0; i--) {\n', '            if (A[i - 1] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of the two arrays\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A extended by B\n', '     */\n', '    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 aLength = A.length;\n', '        uint256 bLength = B.length;\n', '        address[] memory newAddresses = new address[](aLength + bLength);\n', '        for (uint256 i = 0; i < aLength; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = 0; j < bLength; j++) {\n', '            newAddresses[aLength + j] = B[j];\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the array with a appended to A.\n', '     * @param A The first array\n', '     * @param a The value to append\n', '     * @return Returns A appended by a\n', '     */\n', '    function append(address[] memory A, address a) internal pure returns (address[] memory) {\n', '        address[] memory newAddresses = new address[](A.length + 1);\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        newAddresses[A.length] = a;\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of two storage arrays.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A appended by a\n', '     */\n', '    function sExtend(address[] storage A, address[] storage B) internal {\n', '        uint256 length = B.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            A.push(B[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The intersection of the two arrays\n', '     */\n', '    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 newLength = 0;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (contains(B, A[i])) {\n', '                includeMap[i] = true;\n', '                newLength++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](newLength);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the union of the two arrays. Order is not guaranteed.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The union of the two arrays\n', '     */\n', '    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        address[] memory leftDifference = difference(A, B);\n', '        address[] memory rightDifference = difference(B, A);\n', '        address[] memory intersection = intersect(A, B);\n', '        return extend(leftDifference, extend(intersection, rightDifference));\n', '    }\n', '\n', '    /**\n', '     * Alternate implementation\n', '     * Assumes there are no duplicates\n', '     */\n', '    function unionB(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        bool[] memory includeMap = new bool[](A.length + B.length);\n', '        uint256 count = 0;\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            includeMap[i] = true;\n', '            count++;\n', '        }\n', '        for (uint256 j = 0; j < B.length; j++) {\n', '            if (!contains(A, B[j])) {\n', '                includeMap[A.length + j] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 k = 0;\n', '        for (uint256 m = 0; m < A.length; m++) {\n', '            if (includeMap[m]) {\n', '                newAddresses[k] = A[m];\n', '                k++;\n', '            }\n', '        }\n', '        for (uint256 n = 0; n < B.length; n++) {\n', '            if (includeMap[A.length + n]) {\n', '                newAddresses[k] = B[n];\n', '                k++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Computes the difference of two arrays. Assumes there are no duplicates.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The difference of the two arrays\n', '     */\n', '    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 count = 0;\n', '        // First count the new length because can&#39;t push for in-memory arrays\n', '        for (uint256 i = 0; i < length; i++) {\n', '            address e = A[i];\n', '            if (!contains(B, e)) {\n', '                includeMap[i] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '    * @dev Reverses storage array in place\n', '    */\n', '    function sReverse(address[] storage A) internal {\n', '        address t;\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length / 2; i++) {\n', '            t = A[i];\n', '            A[i] = A[A.length - i - 1];\n', '            A[A.length - i - 1] = t;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Removes specified index from array\n', '    * Resulting ordering is not guaranteed\n', '    * @return Returns the new array and the removed entry\n', '    */\n', '    function pop(address[] memory A, uint256 index)\n', '        internal\n', '        pure\n', '        returns (address[] memory, address)\n', '    {\n', '        uint256 length = A.length;\n', '        address[] memory newAddresses = new address[](length - 1);\n', '        for (uint256 i = 0; i < index; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = index + 1; j < length; j++) {\n', '            newAddresses[j - 1] = A[j];\n', '        }\n', '        return (newAddresses, A[index]);\n', '    }\n', '\n', '    /**\n', '     * @return Returns the new array\n', '     */\n', '    function remove(address[] memory A, address a)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert();\n', '        } else {\n', '            (address[] memory _A,) = pop(A, index);\n', '            return _A;\n', '        }\n', '    }\n', '\n', '    function sPop(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        for (uint256 i = index; i < length - 1; i++) {\n', '            A[i] = A[i + 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '    * Deletes address at index and fills the spot with the last address.\n', '    * Order is not preserved.\n', '    * @return Returns the removed entry\n', '    */\n', '    function sPopCheap(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        if (index != length - 1) {\n', '            A[index] = A[length - 1];\n', '            delete A[length - 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '     * Deletes address at index. Works by swapping it with the last address, then deleting.\n', '     * Order is not preserved\n', '     * @param A Storage array to remove from\n', '     */\n', '    function sRemoveCheap(address[] storage A, address a) internal {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert("Error: entry not found");\n', '        } else {\n', '            sPopCheap(A, index);\n', '            return;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns whether or not there&#39;s a duplicate. Runs in O(n^2).\n', '     * @param A Array to search\n', '     * @return Returns true if duplicate, false otherwise\n', '     */\n', '    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n', '        if (A.length == 0) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length - 1; i++) {\n', '            for (uint256 j = i + 1; j < A.length; j++) {\n', '                if (A[i] == A[j]) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Returns whether the two arrays are equal.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return True is the arrays are equal, false if not.\n', '     */\n', '    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\n', '        if (A.length != B.length) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            if (A[i] != B[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns the elements indexed at indexArray.\n', '     * @param A The array to index\n', '     * @param indexArray The array to use to index\n', '     * @return Returns array containing elements indexed at indexArray\n', '     */\n', '    function argGet(address[] memory A, uint256[] memory indexArray)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory array = new address[](indexArray.length);\n', '        for (uint256 i = 0; i < indexArray.length; i++) {\n', '            array[i] = A[indexArray[i]];\n', '        }\n', '        return array;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/core/modules/lib/RebalancingSetIssuance.sol\n', '\n', '/*\n', '    Copyright 2019 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingSetIssuance\n', ' * @author Set Protocol\n', ' *\n', ' * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken\n', ' * issuance\n', ' */\n', 'contract RebalancingSetIssuance is\n', '    ModuleCoreState\n', '{\n', '    using SafeMath for uint256;\n', '    using AddressArrayUtils for address[];\n', '\n', '    // ============ Internal ============\n', '\n', '    /**\n', '     * Validates that wrapped Ether is a component of the SetToken\n', '     *\n', '     * @param  _setAddress            Address of the SetToken\n', '     * @param  _wrappedEtherAddress   Address of wrapped Ether\n', '     */\n', '    function validateWETHIsAComponentOfSet(\n', '        address _setAddress,\n', '        address _wrappedEtherAddress\n', '    )\n', '        internal\n', '        view\n', '    {\n', '        require(\n', '            ISetToken(_setAddress).tokenIsComponent(_wrappedEtherAddress),\n', '            "RebalancingSetIssuance.validateWETHIsAComponentOfSet: Components must contain weth"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Validates that the passed in address is tracked by Core and that the quantity\n', '     * is a multiple of the natural unit\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue/redeem\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     */\n', '    function validateRebalancingSetIssuance(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '    {\n', '        // Expect rebalancing SetToken to be valid and enabled SetToken\n', '        require(\n', '            coreInstance.validSets(_rebalancingSetAddress),\n', '            "RebalancingSetIssuance.validateRebalancingIssuance: Invalid or disabled SetToken address"\n', '        );\n', '\n', '        // Make sure Issuance quantity is multiple of the rebalancing SetToken natural unit\n', '        require(\n', '            _rebalancingSetQuantity.mod(ISetToken(_rebalancingSetAddress).naturalUnit()) == 0,\n', '            "RebalancingSetIssuance.validateRebalancingIssuance: Quantity must be multiple of natural unit"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Given a rebalancing SetToken and a desired issue quantity, calculates the\n', '     * minimum issuable quantity of the base SetToken. If the calculated quantity is initially\n', '     * not a multiple of the base SetToken&#39;s natural unit, the quantity is rounded up\n', '     * to the next base set natural unit.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\n', '     */\n', '    function getBaseSetIssuanceRequiredQuantity(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IRebalancingSetTokenV2 rebalancingSet = IRebalancingSetTokenV2(_rebalancingSetAddress);\n', '\n', '        uint256 unitShares = rebalancingSet.unitShares();\n', '        uint256 naturalUnit = rebalancingSet.naturalUnit();\n', '\n', '        uint256 requiredBaseSetQuantity = _rebalancingSetQuantity.div(naturalUnit).mul(unitShares);\n', '\n', '        address baseSet = rebalancingSet.currentSet();\n', '        uint256 baseSetNaturalUnit = ISetToken(baseSet).naturalUnit();\n', '\n', '        // If there is a mismatch between the required quantity and the base SetToken natural unit,\n', '        // round up to the next base SetToken natural unit if required.\n', '        uint256 roundDownQuantity = requiredBaseSetQuantity.mod(baseSetNaturalUnit);\n', '        if (roundDownQuantity > 0) {\n', '            requiredBaseSetQuantity = requiredBaseSetQuantity.sub(roundDownQuantity).add(baseSetNaturalUnit);\n', '        }\n', '\n', '        return requiredBaseSetQuantity;\n', '    }\n', '\n', '\n', '    /**\n', '     * Given a rebalancing SetToken address, retrieve the base SetToken quantity redeem quantity based on the quantity\n', '     * held in the Vault. Rounds down to the nearest base SetToken natural unit\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @return baseSetRedeemQuantity      The quantity of base SetToken to redeem\n', '     */\n', '    function getBaseSetRedeemQuantity(\n', '        address _baseSetAddress\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Get base SetToken Details from the rebalancing SetToken\n', '        uint256 baseSetNaturalUnit = ISetToken(_baseSetAddress).naturalUnit();\n', '        uint256 baseSetBalance = vaultInstance.getOwnerBalance(\n', '            _baseSetAddress,\n', '            address(this)\n', '        );\n', '\n', '        // Round the balance down to the base SetToken natural unit and return\n', '        return baseSetBalance.sub(baseSetBalance.mod(baseSetNaturalUnit));\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances in the Vault and on the contract.\n', '     * Sends any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param _transferProxyAddress       The address of the TransferProxy\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSet(\n', '        address _baseSetAddress,\n', '        address _transferProxyAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        returnExcessBaseSetFromContract(_baseSetAddress, _transferProxyAddress, _keepChangeInVault);\n', '\n', '        returnExcessBaseSetInVault(_baseSetAddress, _keepChangeInVault);\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances on the contract and sends\n', '     * any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param _transferProxyAddress       The address of the TransferProxy\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSetFromContract(\n', '        address _baseSetAddress,\n', '        address _transferProxyAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\n', '\n', '        if (baseSetQuantity == 0) {\n', '            return;\n', '        } else if (_keepChangeInVault) {\n', '            // Ensure base SetToken allowance\n', '            ERC20Wrapper.ensureAllowance(\n', '                _baseSetAddress,\n', '                address(this),\n', '                _transferProxyAddress,\n', '                baseSetQuantity\n', '            );\n', '\n', '            // Deposit base SetToken to the user\n', '            coreInstance.depositModule(\n', '                address(this),\n', '                msg.sender,\n', '                _baseSetAddress,\n', '                baseSetQuantity\n', '            );\n', '        } else {\n', '            // Transfer directly to the user\n', '            ERC20Wrapper.transfer(\n', '                _baseSetAddress,\n', '                msg.sender,\n', '                baseSetQuantity\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances in the Vault and sends\n', '     * any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSetInVault(\n', '        address _baseSetAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        // Return base SetToken if any that are in the Vault\n', '        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\n', '            _baseSetAddress,\n', '            address(this)\n', '        );\n', '\n', '        if (baseSetQuantityInVault == 0) {\n', '            return;\n', '        } else if (_keepChangeInVault) {\n', '            // Transfer ownership within the vault to the user\n', '            coreInstance.internalTransfer(\n', '                _baseSetAddress,\n', '                msg.sender,\n', '                baseSetQuantityInVault\n', '            );\n', '        } else {\n', '            // Transfer ownership directly to the user\n', '            coreInstance.withdrawModule(\n', '                address(this),\n', '                msg.sender,\n', '                _baseSetAddress,\n', '                baseSetQuantityInVault\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/modules/RebalancingSetIssuanceModule.sol\n', '\n', '/*\n', '    Copyright 2019 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingSetIssuanceModule\n', ' * @author Set Protocol\n', ' *\n', ' * A module that includes functions for issuing / redeeming rebalancing SetToken to/from its base components and ether.\n', ' */\n', 'contract RebalancingSetIssuanceModule is\n', '    ModuleCoreState,\n', '    RebalancingSetIssuance,\n', '    ReentrancyGuard\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // Address and instance of TransferProxy contract\n', '    address public transferProxy;\n', '\n', '    // Address and instance of Wrapped Ether contract\n', '    IWETH public weth;\n', '\n', '    /* ============ Events ============ */\n', '\n', '    event LogRebalancingSetIssue(\n', '        address indexed rebalancingSetAddress,\n', '        address indexed callerAddress,\n', '        uint256 rebalancingSetQuantity\n', '    );\n', '\n', '    event LogRebalancingSetRedeem(\n', '        address indexed rebalancingSetAddress,\n', '        address indexed callerAddress,\n', '        uint256 rebalancingSetQuantity\n', '    );\n', '\n', '    /* ============ Constructor ============ */\n', '\n', '    /**\n', '     * Constructor function for RebalancingSetIssuanceModule\n', '     *\n', '     * @param _core                The address of Core\n', '     * @param _vault               The address of Vault\n', '     * @param _transferProxy       The address of TransferProxy\n', '     * @param _weth                The address of Wrapped Ether\n', '     */\n', '    constructor(\n', '        address _core,\n', '        address _vault,\n', '        address _transferProxy,\n', '        IWETH _weth\n', '    )\n', '        public\n', '        ModuleCoreState(\n', '            _core,\n', '            _vault\n', '        )\n', '    {\n', '        // Commit the WETH instance\n', '        weth = _weth;\n', '\n', '        // Commit the transferProxy instance\n', '        transferProxy = _transferProxy;\n', '    }\n', '\n', '    /**\n', '     * Fallback function. Disallows ether to be sent to this contract without data except when\n', '     * unwrapping WETH.\n', '     */\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        require(\n', '            msg.sender == address(weth),\n', '            "RebalancingSetIssuanceModule.fallback: Cannot receive ETH directly unless unwrapping WETH"\n', '        );\n', '    }\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Issue a rebalancing SetToken using the base components of the base SetToken.\n', '     * The base SetToken is then issued into the rebalancing SetToken. The base SetToken quantity issued is calculated\n', '     * by taking the rebalancing SetToken&#39;s quantity, unit shares, and natural unit. If the calculated quantity is not\n', '     * a multiple of the natural unit of the base SetToken, the quantity is rounded up to the base SetToken natural unit.\n', '     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function issueRebalancingSet(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Get baseSet address and quantity required for issuance of Rebalancing Set\n', '        (\n', '            address baseSetAddress,\n', '            uint256 requiredBaseSetQuantity\n', '        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Issue base SetToken to this contract, held in this contract\n', '        coreInstance.issueModule(\n', '            msg.sender,\n', '            address(this),\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Ensure base SetToken allowance to the transferProxy\n', '        ERC20Wrapper.ensureAllowance(\n', '            baseSetAddress,\n', '            address(this),\n', '            transferProxy,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Issue rebalancing SetToken to the sender and return any excess base to sender\n', '        issueRebalancingSetAndReturnExcessBase(\n', '            _rebalancingSetAddress,\n', '            baseSetAddress,\n', '            _rebalancingSetQuantity,\n', '            _keepChangeInVault\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Issue a rebalancing SetToken using the base components and ether of the base SetToken. The ether is wrapped\n', '     * into wrapped Ether and utilized in issuance.\n', '     * The base SetToken is then issued and reissued into the rebalancing SetToken. Read more about base SetToken quantity\n', '     * in the issueRebalancingSet function.\n', '     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function issueRebalancingSetWrappingEther(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        payable\n', '        nonReentrant\n', '    {\n', '        // Get baseSet address and quantity required for issuance of Rebalancing Set\n', '        (\n', '            address baseSetAddress,\n', '            uint256 requiredBaseSetQuantity\n', '        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Validate that WETH is a component of baseSet\n', '        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\n', '\n', '        // Deposit all the required non-weth components to the vault under the name of this contract\n', '        // The required ether is wrapped and approved to the transferProxy\n', '        depositComponentsAndHandleEth(\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Issue base SetToken to this contract, with the base SetToken held in the Vault\n', '        coreInstance.issueInVault(\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Note: Don&#39;t need to set allowance of the base SetToken as the base SetToken is already in the vault\n', '\n', '        // Issue rebalancing SetToken to the sender and return any excess base to sender\n', '        issueRebalancingSetAndReturnExcessBase(\n', '            _rebalancingSetAddress,\n', '            baseSetAddress,\n', '            _rebalancingSetQuantity,\n', '            _keepChangeInVault\n', '        );\n', '\n', '        // Any eth that is not wrapped is sent back to the user\n', '        // Only the amount required for the base SetToken issuance is wrapped.\n', '        uint256 leftoverEth = address(this).balance;\n', '        if (leftoverEth > 0) {\n', '            msg.sender.transfer(leftoverEth);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Redeems a rebalancing SetToken into the base components of the base SetToken.\n', '     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function redeemRebalancingSet(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Redeem RB Set to the vault attributed to this contract\n', '        coreInstance.redeemModule(\n', '            msg.sender,\n', '            address(this),\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Calculate the base SetToken Redeem quantity\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\n', '\n', '        // Withdraw base SetToken to this contract\n', '        coreInstance.withdraw(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Redeem base SetToken and send components to the the user\n', '        // Set exclude to 0, as tokens in rebalancing SetToken are already whitelisted\n', '        coreInstance.redeemAndWithdrawTo(\n', '            baseSetAddress,\n', '            msg.sender,\n', '            baseSetRedeemQuantity,\n', '            0\n', '        );\n', '\n', '        // Transfer any change of the base SetToken to the end user\n', '        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetRedeem\n', '        emit LogRebalancingSetRedeem(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Redeems a rebalancing SetToken into the base components of the base SetToken. Unwraps\n', '     * wrapped ether and sends eth to the user. If no wrapped ether in Set then will REVERT.\n', '     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                   or left in the vault\n', '     */\n', '    function redeemRebalancingSetUnwrappingEther(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '\n', '        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\n', '\n', '        // Redeem rebalancing SetToken to the vault attributed to this contract\n', '        coreInstance.redeemModule(\n', '            msg.sender,\n', '            address(this),\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Calculate the base SetToken Redeem quantity\n', '        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\n', '\n', '        // Withdraw base SetToken to this contract\n', '        coreInstance.withdraw(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Redeem the base SetToken. The components stay in the vault\n', '        coreInstance.redeem(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Loop through the base SetToken components and transfer to sender.\n', '        withdrawComponentsToSenderWithEther(baseSetAddress);\n', '\n', '        // Transfer any change of the base SetToken to the end user\n', '        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetRedeem\n', '        emit LogRebalancingSetRedeem(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /* ============ Private Functions ============ */\n', '\n', '    /**\n', '     * Gets base set address from rebalancing set token and calculates amount of base set needed\n', '     * for issuance.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the RebalancingSetToken to issue\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to issue\n', '     * @return baseSetAddress            The address of RebalancingSet&#39;s base SetToken\n', '     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\n', '     */\n', '    function getBaseSetAddressAndQuantity(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '        returns (address, uint256)\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '\n', '        // Calculate required base SetToken quantity\n', '        uint256 requiredBaseSetQuantity = getBaseSetIssuanceRequiredQuantity(\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        return (baseSetAddress, requiredBaseSetQuantity);\n', '    }\n', '\n', '    /**\n', '     * Issues the rebalancing set token to sender and returns any excess baseSet.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _baseSetAddress           Address of the rebalancing SetToken&#39;s base set\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                   or left in the vault\n', '     */\n', '    function issueRebalancingSetAndReturnExcessBase(\n', '        address _rebalancingSetAddress,\n', '        address _baseSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        // Issue rebalancing SetToken to the sender\n', '        coreInstance.issueTo(\n', '            msg.sender,\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Return any excess base SetToken token to the sender\n', '        returnExcessBaseSet(_baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetIssue\n', '        emit LogRebalancingSetIssue(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /**\n', '     * During issuance, deposit the required quantity of base SetToken, wrap Ether, and deposit components\n', '     * (excluding Ether, which is deposited during issuance) to the Vault in the name of the module.\n', '     *\n', '     * @param  _baseSetAddress           Address of the base SetToken token\n', '     * @param  _baseSetQuantity          The Quantity of the base SetToken token to issue\n', '     */\n', '    function depositComponentsAndHandleEth(\n', '        address _baseSetAddress,\n', '        uint256 _baseSetQuantity\n', '    )\n', '        private\n', '    {\n', '        ISetToken baseSet = ISetToken(_baseSetAddress);\n', '\n', '        address[] memory baseSetComponents = baseSet.getComponents();\n', '        uint256[] memory baseSetUnits = baseSet.getUnits();\n', '        uint256 baseSetNaturalUnit = baseSet.naturalUnit();\n', '\n', '       // Loop through the base SetToken components and deposit components\n', '        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n', '            address currentComponent = baseSetComponents[i];\n', '            uint256 currentUnit = baseSetUnits[i];\n', '\n', '            // Calculate required component quantity\n', '            uint256 currentComponentQuantity = _baseSetQuantity.div(baseSetNaturalUnit).mul(currentUnit);\n', '\n', '            // If address is weth, deposit weth and transfer eth\n', '            if (currentComponent == address(weth)) {\n', '                // Expect the ether included exceeds the required Weth quantity\n', '                require(\n', '                    msg.value >= currentComponentQuantity,\n', '                    "RebalancingSetIssuanceModule.depositComponentsAndHandleEth: Not enough ether included for base SetToken"\n', '                );\n', '\n', '                // wrap the required ether quantity\n', '                weth.deposit.value(currentComponentQuantity)();\n', '\n', '                // Ensure weth allowance\n', '                ERC20Wrapper.ensureAllowance(\n', '                    address(weth),\n', '                    address(this),\n', '                    transferProxy,\n', '                    currentComponentQuantity\n', '                );\n', '            } else {\n', '                // Deposit components to the vault in the name of the contract\n', '                coreInstance.depositModule(\n', '                    msg.sender,\n', '                    address(this),\n', '                    currentComponent,\n', '                    currentComponentQuantity\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * During redemption, withdraw the required quantity of base SetToken, unwrapping Ether, and withdraw\n', '     * components to the sender\n', '     *\n', '     * @param  _baseSetAddress           Address of the base SetToken\n', '     */\n', '    function withdrawComponentsToSenderWithEther(\n', '        address _baseSetAddress\n', '    )\n', '        private\n', '    {\n', '        address[] memory baseSetComponents = ISetToken(_baseSetAddress).getComponents();\n', '\n', '        // Loop through the base SetToken components.\n', '        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n', '            address currentComponent = baseSetComponents[i];\n', '            uint256 currentComponentQuantity = vaultInstance.getOwnerBalance(\n', '                currentComponent,\n', '                address(this)\n', '            );\n', '\n', '            // If address is weth, withdraw weth and transfer eth to sender\n', '            if (currentComponent == address(weth)) {\n', '                // Transfer the wrapped ether to this address from the Vault\n', '                coreInstance.withdrawModule(\n', '                    address(this),\n', '                    address(this),\n', '                    address(weth),\n', '                    currentComponentQuantity\n', '                );\n', '\n', '                // Unwrap wrapped ether\n', '                weth.withdraw(currentComponentQuantity);\n', '\n', '                // Transfer to recipient\n', '                msg.sender.transfer(currentComponentQuantity);\n', '            } else {\n', '                // Withdraw component from the Vault and send to the user\n', '                coreInstance.withdrawModule(\n', '                    address(this),\n', '                    msg.sender,\n', '                    currentComponent,\n', '                    currentComponentQuantity\n', '                );\n', '            }\n', '        }\n', '    }\n', '}']
['// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/core/lib/RebalancingLibraryV2.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingLibrary\n', ' * @author Set Protocol\n', ' *\n', ' * The RebalancingLibrary contains functions for facilitating the rebalancing process for\n', ' * Rebalancing Set Tokens. Removes the old calculation functions\n', ' *\n', ' */\n', 'library RebalancingLibraryV2 {\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ Enums ============ */\n', '\n', '    enum State { Default, Proposal, Rebalance, Drawdown }\n', '\n', '    /* ============ Structs ============ */\n', '\n', '    struct AuctionPriceParameters {\n', '        uint256 auctionStartTime;\n', '        uint256 auctionTimeToPivot;\n', '        uint256 auctionStartPrice;\n', '        uint256 auctionPivotPrice;\n', '    }\n', '\n', '    struct BiddingParameters {\n', '        uint256 minimumBid;\n', '        uint256 remainingCurrentSets;\n', '        uint256[] combinedCurrentUnits;\n', '        uint256[] combinedNextSetUnits;\n', '        address[] combinedTokenArray;\n', '    }\n', '}\n', '\n', '// File: contracts/core/interfaces/IRebalancingSetTokenV2.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IRebalancingSetTokenV2\n', ' * @author Set Protocol\n', ' *\n', ' * The IRebalancingSetToken interface provides a light-weight, structured way to interact with the\n', ' * RebalancingSetToken contract from another contract.\n', ' */\n', '\n', 'interface IRebalancingSetTokenV2 {\n', '\n', '    /*\n', '     * Get totalSupply of Rebalancing Set\n', '     *\n', '     * @return  totalSupply\n', '     */\n', '    function totalSupply()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get lastRebalanceTimestamp of Rebalancing Set\n', '     *\n', '     * @return  lastRebalanceTimestamp\n', '     */\n', '    function lastRebalanceTimestamp()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get rebalanceInterval of Rebalancing Set\n', '     *\n', '     * @return  rebalanceInterval\n', '     */\n', '    function rebalanceInterval()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get rebalanceState of Rebalancing Set\n', '     *\n', '     * @return  rebalanceState\n', '     */\n', '    function rebalanceState()\n', '        external\n', '        view\n', '        returns (RebalancingLibraryV2.State);\n', '\n', '    /**\n', '     * Gets the balance of the specified address.\n', '     *\n', '     * @param owner      The address to query the balance of.\n', '     * @return           A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(\n', '        address owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Function used to set the terms of the next rebalance and start the proposal period\n', '     *\n', '     * @param _nextSet                      The Set to rebalance into\n', '     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\n', '     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\n', '     * @param _auctionStartPrice            The price to start the auction at\n', '     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\n', '     */\n', '    function propose(\n', '        address _nextSet,\n', '        address _auctionLibrary,\n', '        uint256 _auctionTimeToPivot,\n', '        uint256 _auctionStartPrice,\n', '        uint256 _auctionPivotPrice\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Get natural unit of Set\n', '     *\n', '     * @return  uint256       Natural unit of Set\n', '     */\n', '    function naturalUnit()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Returns the address of the current Base Set\n', '     *\n', '     * @return           A address representing the base Set Token\n', '     */\n', '    function currentSet()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /*\n', '     * Get the unit shares of the rebalancing Set\n', '     *\n', '     * @return  unitShares       Unit Shares of the base Set\n', '     */\n', '    function unitShares()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Burn set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _from        The address of the redeeming account\n', '     * @param  _quantity    The number of sets to burn from redeemer\n', '     */\n', '    function burn(\n', '        address _from,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Place bid during rebalance auction. Can only be called by Core.\n', '     *\n', '     * @param _quantity                 The amount of currentSet to be rebalanced\n', '     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\n', '     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\n', '     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\n', '     */\n', '    function placeBid(\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (address[] memory, uint256[] memory, uint256[] memory);\n', '\n', '    /*\n', '     * Get combinedTokenArray of Rebalancing Set\n', '     *\n', '     * @return  combinedTokenArray\n', '     */\n', '    function getCombinedTokenArrayLength()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get combinedTokenArray of Rebalancing Set\n', '     *\n', '     * @return  combinedTokenArray\n', '     */\n', '    function getCombinedTokenArray()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get failedAuctionWithdrawComponents of Rebalancing Set\n', '     *\n', '     * @return  failedAuctionWithdrawComponents\n', '     */\n', '    function getFailedAuctionWithdrawComponents()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get biddingParameters for current auction\n', '     *\n', '     * @return  biddingParameters\n', '     */\n', '    function getBiddingParameters()\n', '        external\n', '        view\n', '        returns (uint256[] memory);\n', '\n', '}\n', '\n', '// File: contracts/core/interfaces/ISetToken.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title ISetToken\n', ' * @author Set Protocol\n', ' *\n', ' * The ISetToken interface provides a light-weight, structured way to interact with the\n', ' * SetToken contract from another contract.\n', ' */\n', 'interface ISetToken {\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /*\n', '     * Get natural unit of Set\n', '     *\n', '     * @return  uint256       Natural unit of Set\n', '     */\n', '    function naturalUnit()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /*\n', '     * Get addresses of all components in the Set\n', '     *\n', '     * @return  componentAddresses       Array of component tokens\n', '     */\n', '    function getComponents()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    /*\n', '     * Get units of all tokens in Set\n', '     *\n', '     * @return  units       Array of component units\n', '     */\n', '    function getUnits()\n', '        external\n', '        view\n', '        returns (uint256[] memory);\n', '\n', '    /*\n', '     * Checks to make sure token is component of Set\n', '     *\n', '     * @param  _tokenAddress     Address of token being checked\n', '     * @return  bool             True if token is component of Set\n', '     */\n', '    function tokenIsComponent(\n', '        address _tokenAddress\n', '    )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /*\n', '     * Mint set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _issuer      The address of the issuing account\n', '     * @param  _quantity    The number of sets to attribute to issuer\n', '     */\n', '    function mint(\n', '        address _issuer,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Burn set token for given address\n', '     * Can only be called by authorized contracts\n', '     *\n', '     * @param  _from        The address of the redeeming account\n', '     * @param  _quantity    The number of sets to burn from redeemer\n', '     */\n', '    function burn(\n', '        address _from,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '    * Transfer token for a specified address\n', '    *\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/IWETH.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IWETH\n', ' * @author Set Protocol\n', ' *\n', " * Interface for Wrapped Ether. This interface allows for interaction for wrapped ether's deposit and withdrawal\n", ' * functionality.\n', ' */\n', 'interface IWETH {\n', '    function deposit()\n', '        external\n', '        payable;\n', '\n', '    function withdraw(\n', '        uint256 wad\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/CommonMath.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'library CommonMath {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUInt256()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0);\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Checks for rounding errors and returns value of potential partial amounts of a principal\n', '     *\n', '     * @param  _principal       Number fractional amount is derived from\n', '     * @param  _numerator       Numerator of fraction\n', '     * @param  _denominator     Denominator of fraction\n', '     * @return uint256          Fractional amount of principal calculated\n', '     */\n', '    function getPartialAmount(\n', '        uint256 _principal,\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Get remainder of partial amount (if 0 not a partial amount)\n', '        uint256 remainder = mulmod(_principal, _numerator, _denominator);\n', '\n', '        // Return if not a partial amount\n', '        if (remainder == 0) {\n', '            return _principal.mul(_numerator).div(_denominator);\n', '        }\n', '\n', '        // Calculate error percentage\n', '        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\n', '\n', '        // Require error percentage is less than 0.1%.\n', '        require(\n', '            errPercentageTimes1000000 < 1000,\n', '            "CommonMath.getPartialAmount: Rounding error exceeds bounds"\n', '        );\n', '\n', '        return _principal.mul(_numerator).div(_denominator);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lib/IERC20.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IERC20\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for using ERC20 Tokens. This interface is needed to interact with tokens that are not\n', ' * fully ERC20 compliant and return something other than true on successful transfers.\n', ' */\n', 'interface IERC20 {\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC20Wrapper.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Wrapper\n', ' * @author Set Protocol\n', ' *\n', ' * This library contains functions for interacting wtih ERC20 tokens, even those not fully compliant.\n', ' * For all functions we will only accept tokens that return a null or true value, any other values will\n', ' * cause the operation to revert.\n', ' */\n', 'library ERC20Wrapper {\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    /**\n', "     * Check balance owner's balance of ERC20 token\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', "     * @param  _owner          The owner who's balance is being checked\n", "     * @return  uint256        The _owner's amount of tokens\n", '     */\n', '    function balanceOf(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).balanceOf(_owner);\n', '    }\n', '\n', '    /**\n', "     * Checks spender's allowance to use token's on owner's behalf.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The token owner address\n', '     * @param  _spender        The address the allowance is being checked on\n', "     * @return  uint256        The spender's allowance on behalf of owner\n", '     */\n', '    function allowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).allowance(_owner, _spender);\n', '    }\n', '\n', '    /**\n', "     * Transfers tokens from an address. Handle's tokens that return true or null.\n", '     * If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The amount of tokens to transfer\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transfer(_to, _quantity);\n', '\n', '        // Check that transfer returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transfer: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function transferFrom(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transferFrom(_from, _to, _quantity);\n', '\n', '        // Check that transferFrom returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transferFrom: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Grants spender ability to spend on owner's behalf.\n", "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _spender        The address to approve for transfer\n', '     * @param  _quantity       The amount of tokens to approve spender for\n', '     */\n', '    function approve(\n', '        address _token,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        IERC20(_token).approve(_spender, _quantity);\n', '\n', '        // Check that approve returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.approve: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Ensure's the owner has granted enough allowance for system to\n", '     * transfer tokens.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The address of the token owner\n', '     * @param  _spender        The address to grant/check allowance for\n', '     * @param  _quantity       The amount to see if allowed for\n', '     */\n', '    function ensureAllowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        uint256 currentAllowance = allowance(_token, _owner, _spender);\n', '        if (currentAllowance < _quantity) {\n', '            approve(\n', '                _token,\n', '                _spender,\n', '                CommonMath.maxUInt256()\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 1.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // default to failure\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        // check if returned value is one or nothing\n', '        return returnValue == 1;\n', '    }\n', '}\n', '\n', '// File: contracts/core/interfaces/ICore.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title ICore\n', ' * @author Set Protocol\n', ' *\n', ' * The ICore Contract defines all the functions exposed in the Core through its\n', ' * various extensions and is a light weight way to interact with the contract.\n', ' */\n', 'interface ICore {\n', '    /**\n', '     * Return transferProxy address.\n', '     *\n', '     * @return address       transferProxy address\n', '     */\n', '    function transferProxy()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /**\n', '     * Return vault address.\n', '     *\n', '     * @return address       vault address\n', '     */\n', '    function vault()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /**\n', '     * Return address belonging to given exchangeId.\n', '     *\n', '     * @param  _exchangeId       ExchangeId number\n', '     * @return address           Address belonging to given exchangeId\n', '     */\n', '    function exchangeIds(\n', '        uint8 _exchangeId\n', '    )\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    /*\n', '     * Returns if valid set\n', '     *\n', "     * @return  bool      Returns true if Set created through Core and isn't disabled\n", '     */\n', '    function validSets(address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /*\n', '     * Returns if valid module\n', '     *\n', '     * @return  bool      Returns true if valid module\n', '     */\n', '    function validModules(address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /**\n', '     * Return boolean indicating if address is a valid Rebalancing Price Library.\n', '     *\n', '     * @param  _priceLibrary    Price library address\n', '     * @return bool             Boolean indicating if valid Price Library\n', '     */\n', '    function validPriceLibraries(\n', '        address _priceLibrary\n', '    )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /**\n', '     * Exchanges components for Set Tokens\n', '     *\n', '     * @param  _set          Address of set to issue\n', '     * @param  _quantity     Quantity of set to issue\n', '     */\n', '    function issue(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Issues a specified Set for a specified quantity to the recipient\n', "     * using the caller's components from the wallet and vault.\n", '     *\n', '     * @param  _recipient    Address to issue to\n', '     * @param  _set          Address of the Set to issue\n', '     * @param  _quantity     Number of tokens to issue\n', '     */\n', '    function issueTo(\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', "     * Converts user's components into Set Tokens held directly in Vault instead of user's account\n", '     *\n', '     * @param _set          Address of the Set\n', '     * @param _quantity     Number of tokens to redeem\n', '     */\n', '    function issueInVault(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Function to convert Set Tokens into underlying components\n', '     *\n', '     * @param _set          The address of the Set token\n', '     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n', '     */\n', '    function redeem(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Redeem Set token and return components to specified recipient. The components\n', '     * are left in the vault\n', '     *\n', '     * @param _recipient    Recipient of Set being issued\n', '     * @param _set          Address of the Set\n', '     * @param _quantity     Number of tokens to redeem\n', '     */\n', '    function redeemTo(\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Function to convert Set Tokens held in vault into underlying components\n', '     *\n', '     * @param _set          The address of the Set token\n', '     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\n', '     */\n', '    function redeemInVault(\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Composite method to redeem and withdraw with a single transaction\n', '     *\n', '     * Normally, you should expect to be able to withdraw all of the tokens.\n', '     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\n', '     * allows you to optionally specify which component tokens to exclude when\n', "     * redeeming. They will remain in the vault under the users' addresses.\n", '     *\n', '     * @param _set          Address of the Set\n', '     * @param _to           Address to withdraw or attribute tokens to\n', '     * @param _quantity     Number of tokens to redeem\n', '     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\n', '     */\n', '    function redeemAndWithdrawTo(\n', '        address _set,\n', '        address _to,\n', '        uint256 _quantity,\n', '        uint256 _toExclude\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deposit multiple tokens to the vault. Quantities should be in the\n', '     * order of the addresses of the tokens being deposited.\n', '     *\n', '     * @param  _tokens           Array of the addresses of the ERC20 tokens\n', '     * @param  _quantities       Array of the number of tokens to deposit\n', '     */\n', '    function batchDeposit(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Withdraw multiple tokens from the vault. Quantities should be in the\n', '     * order of the addresses of the tokens being withdrawn.\n', '     *\n', '     * @param  _tokens            Array of the addresses of the ERC20 tokens\n', '     * @param  _quantities        Array of the number of tokens to withdraw\n', '     */\n', '    function batchWithdraw(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deposit any quantity of tokens into the vault.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _quantity        The number of tokens to deposit\n', '     */\n', '    function deposit(\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Withdraw a quantity of tokens from the vault.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _quantity        The number of tokens to withdraw\n', '     */\n', '    function withdraw(\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', "     * Transfer tokens associated with the sender's account in vault to another user's\n", '     * account in vault.\n', '     *\n', '     * @param  _token           Address of token being transferred\n', '     * @param  _to              Address of user receiving tokens\n', '     * @param  _quantity        Amount of tokens being transferred\n', '     */\n', '    function internalTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Deploys a new Set Token and adds it to the valid list of SetTokens\n', '     *\n', '     * @param  _factory              The address of the Factory to create from\n', '     * @param  _components           The address of component tokens\n', '     * @param  _units                The units of each component token\n', '     * @param  _naturalUnit          The minimum unit to be issued or redeemed\n', '     * @param  _name                 The bytes32 encoded name of the new Set\n', '     * @param  _symbol               The bytes32 encoded symbol of the new Set\n', '     * @param  _callData             Byte string containing additional call parameters\n', '     * @return setTokenAddress       The address of the new Set\n', '     */\n', '    function createSet(\n', '        address _factory,\n', '        address[] calldata _components,\n', '        uint256[] calldata _units,\n', '        uint256 _naturalUnit,\n', '        bytes32 _name,\n', '        bytes32 _symbol,\n', '        bytes calldata _callData\n', '    )\n', '        external\n', '        returns (address);\n', '\n', '    /**\n', '     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\n', '     * the tokens respectively, to system modules.\n', '     *\n', '     * @param  _from            Address to transfer tokens from\n', '     * @param  _to              Address to credit for deposit\n', '     * @param  _token           Address of token being deposited\n', '     * @param  _quantity        Amount of tokens to deposit\n', '     */\n', '    function depositModule(\n', '        address _from,\n', '        address _to,\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that withdraws a quantity of tokens from the vault and\n', '     * deattributes the tokens respectively, to system modules.\n', '     *\n', '     * @param  _from            Address to decredit for withdraw\n', '     * @param  _to              Address to transfer tokens to\n', '     * @param  _token           Address of token being withdrawn\n', '     * @param  _quantity        Amount of tokens to withdraw\n', '     */\n', '    function withdrawModule(\n', '        address _from,\n', '        address _to,\n', '        address _token,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that deposits multiple tokens to the vault, to system\n', '     * modules. Quantities should be in the order of the addresses of the tokens being\n', '     * deposited.\n', '     *\n', '     * @param  _from              Address to transfer tokens from\n', '     * @param  _to                Address to credit for deposits\n', '     * @param  _tokens            Array of the addresses of the tokens being deposited\n', '     * @param  _quantities        Array of the amounts of tokens to deposit\n', '     */\n', '    function batchDepositModule(\n', '        address _from,\n', '        address _to,\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Exposes internal function that withdraws multiple tokens from the vault, to system\n', '     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\n', '     *\n', '     * @param  _from              Address to decredit for withdrawals\n', '     * @param  _to                Address to transfer tokens to\n', '     * @param  _tokens            Array of the addresses of the tokens being withdrawn\n', '     * @param  _quantities        Array of the amounts of tokens to withdraw\n', '     */\n', '    function batchWithdrawModule(\n', '        address _from,\n', '        address _to,\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose internal function that exchanges components for Set tokens,\n', '     * accepting any owner, to system modules\n', '     *\n', '     * @param  _owner        Address to use tokens from\n', '     * @param  _recipient    Address to issue Set to\n', '     * @param  _set          Address of the Set to issue\n', '     * @param  _quantity     Number of tokens to issue\n', '     */\n', '    function issueModule(\n', '        address _owner,\n', '        address _recipient,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose internal function that exchanges Set tokens for components,\n', '     * accepting any owner, to system modules\n', '     *\n', '     * @param  _burnAddress         Address to burn token from\n', '     * @param  _incrementAddress    Address to increment component tokens to\n', '     * @param  _set                 Address of the Set to redeem\n', '     * @param  _quantity            Number of tokens to redeem\n', '     */\n', '    function redeemModule(\n', '        address _burnAddress,\n', '        address _incrementAddress,\n', '        address _set,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', "     * Expose vault function that increments user's balance in the vault.\n", '     * Available to system modules\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchIncrementTokenOwnerModule(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', "     * Expose vault function that decrement user's balance in the vault\n", '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchDecrementTokenOwnerModule(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose vault function that transfer vault balances between users\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens           Addresses of tokens being transferred\n', '     * @param  _from             Address tokens being transferred from\n', '     * @param  _to               Address tokens being transferred to\n', '     * @param  _quantities       Amounts of tokens being transferred\n', '     */\n', '    function batchTransferBalanceModule(\n', '        address[] calldata _tokens,\n', '        address _from,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers token from one address to another using the transfer proxy.\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _quantity       The number of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function transferModule(\n', '        address _token,\n', '        uint256 _quantity,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Expose transfer proxy function to transfer tokens from one address to another\n', '     * Only available to system modules.\n', '     *\n', '     * @param  _tokens         The addresses of the ERC20 token\n', '     * @param  _quantities     The numbers of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function batchTransferModule(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/core/interfaces/ITransferProxy.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title ITransferProxy\n', ' * @author Set Protocol\n', ' *\n', ' * The ITransferProxy interface provides a light-weight, structured way to interact with the\n', ' * TransferProxy contract from another contract.\n', ' */\n', 'interface ITransferProxy {\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by authorized core contracts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _quantity       The number of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        uint256 _quantity,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens         The addresses of the ERC20 token\n', '     * @param  _quantities     The numbers of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function batchTransfer(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/core/interfaces/IVault.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title IVault\n', ' * @author Set Protocol\n', ' *\n', ' * The IVault interface provides a light-weight, structured way to interact with the Vault\n', ' * contract from another contract.\n', ' */\n', 'interface IVault {\n', '\n', '    /*\n', "     * Withdraws user's unassociated tokens to user account. Can only be\n", '     * called by authorized core contracts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer token to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function withdrawTo(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Increment quantity owned of a token for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantity        The number of tokens to attribute to owner\n', '     */\n', '    function incrementTokenOwner(\n', '        address _token,\n', '        address _owner,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Decrement quantity owned of a token for a given address. Can only\n', '     * be called by authorized core contracts.\n', '     *\n', '     * @param  _token           The address of the ERC20 token\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantity        The number of tokens to deattribute to owner\n', '     */\n', '    function decrementTokenOwner(\n', '        address _token,\n', '        address _owner,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * Transfers tokens associated with one account to another account in the vault\n', '     *\n', '     * @param  _token          Address of token being transferred\n', '     * @param  _from           Address token being transferred from\n', '     * @param  _to             Address token being transferred to\n', '     * @param  _quantity       Amount of tokens being transferred\n', '     */\n', '\n', '    function transferBalance(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '\n', '    /*\n', "     * Withdraws user's unassociated tokens to user account. Can only be\n", '     * called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchWithdrawTo(\n', '        address[] calldata _tokens,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Increment quantites owned of a collection of tokens for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchIncrementTokenOwner(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Decrements quantites owned of a collection of tokens for a given address. Can\n', '     * only be called by authorized core contracts.\n', '     *\n', '     * @param  _tokens          The addresses of the ERC20 tokens\n', '     * @param  _owner           The address of the token owner\n', '     * @param  _quantities      The numbers of tokens to attribute to owner\n', '     */\n', '    function batchDecrementTokenOwner(\n', '        address[] calldata _tokens,\n', '        address _owner,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '   /**\n', '     * Transfers tokens associated with one account to another account in the vault\n', '     *\n', '     * @param  _tokens           Addresses of tokens being transferred\n', '     * @param  _from             Address tokens being transferred from\n', '     * @param  _to               Address tokens being transferred to\n', '     * @param  _quantities       Amounts of tokens being transferred\n', '     */\n', '    function batchTransferBalance(\n', '        address[] calldata _tokens,\n', '        address _from,\n', '        address _to,\n', '        uint256[] calldata _quantities\n', '    )\n', '        external;\n', '\n', '    /*\n', '     * Get balance of particular contract for owner.\n', '     *\n', '     * @param  _token    The address of the ERC20 token\n', '     * @param  _owner    The address of the token owner\n', '     */\n', '    function getOwnerBalance(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/core/modules/lib/ModuleCoreState.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ModuleCoreState\n', ' * @author Set Protocol\n', ' *\n', ' * The ModuleCoreState library maintains Core-related state for modules\n', ' */\n', 'contract ModuleCoreState {\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    // Address of core contract\n', '    address public core;\n', '\n', '    // Address of vault contract\n', '    address public vault;\n', '\n', '    // Instance of core contract\n', '    ICore public coreInstance;\n', '\n', '    // Instance of vault contract\n', '    IVault public vaultInstance;\n', '\n', '    /* ============ Public Getters ============ */\n', '\n', '    /**\n', '     * Constructor function for ModuleCoreState\n', '     *\n', '     * @param _core                The address of Core\n', '     * @param _vault               The address of Vault\n', '     */\n', '    constructor(\n', '        address _core,\n', '        address _vault\n', '    )\n', '        public\n', '    {\n', '        // Commit passed address to core state variable\n', '        core = _core;\n', '\n', '        // Commit passed address to coreInstance state variable\n', '        coreInstance = ICore(_core);\n', '\n', '        // Commit passed address to vault state variable\n', '        vault = _vault;\n', '\n', '        // Commit passed address to vaultInstance state variable\n', '        vaultInstance = IVault(_vault);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressArrayUtils.sol\n', '\n', '// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\n', '// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'library AddressArrayUtils {\n', '\n', '    /**\n', '     * Finds the index of the first occurrence of the given element.\n', '     * @param A The input array to search\n', '     * @param a The value to find\n', '     * @return Returns (index and isIn) for the first occurrence starting from index 0\n', '     */\n', '    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (A[i] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '    * Returns true if the value is present in the list. Uses indexOf internally.\n', '    * @param A The input array to search\n', '    * @param a The value to find\n', '    * @return Returns isIn for the first occurrence starting from index 0\n', '    */\n', '    function contains(address[] memory A, address a) internal pure returns (bool) {\n', '        bool isIn;\n', '        (, isIn) = indexOf(A, a);\n', '        return isIn;\n', '    }\n', '\n', '    /// @return Returns index and isIn for the first occurrence starting from\n', '    /// end\n', '    function indexOfFromEnd(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = length; i > 0; i--) {\n', '            if (A[i - 1] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of the two arrays\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A extended by B\n', '     */\n', '    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 aLength = A.length;\n', '        uint256 bLength = B.length;\n', '        address[] memory newAddresses = new address[](aLength + bLength);\n', '        for (uint256 i = 0; i < aLength; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = 0; j < bLength; j++) {\n', '            newAddresses[aLength + j] = B[j];\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the array with a appended to A.\n', '     * @param A The first array\n', '     * @param a The value to append\n', '     * @return Returns A appended by a\n', '     */\n', '    function append(address[] memory A, address a) internal pure returns (address[] memory) {\n', '        address[] memory newAddresses = new address[](A.length + 1);\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        newAddresses[A.length] = a;\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of two storage arrays.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A appended by a\n', '     */\n', '    function sExtend(address[] storage A, address[] storage B) internal {\n', '        uint256 length = B.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            A.push(B[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The intersection of the two arrays\n', '     */\n', '    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 newLength = 0;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (contains(B, A[i])) {\n', '                includeMap[i] = true;\n', '                newLength++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](newLength);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the union of the two arrays. Order is not guaranteed.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The union of the two arrays\n', '     */\n', '    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        address[] memory leftDifference = difference(A, B);\n', '        address[] memory rightDifference = difference(B, A);\n', '        address[] memory intersection = intersect(A, B);\n', '        return extend(leftDifference, extend(intersection, rightDifference));\n', '    }\n', '\n', '    /**\n', '     * Alternate implementation\n', '     * Assumes there are no duplicates\n', '     */\n', '    function unionB(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        bool[] memory includeMap = new bool[](A.length + B.length);\n', '        uint256 count = 0;\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            includeMap[i] = true;\n', '            count++;\n', '        }\n', '        for (uint256 j = 0; j < B.length; j++) {\n', '            if (!contains(A, B[j])) {\n', '                includeMap[A.length + j] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 k = 0;\n', '        for (uint256 m = 0; m < A.length; m++) {\n', '            if (includeMap[m]) {\n', '                newAddresses[k] = A[m];\n', '                k++;\n', '            }\n', '        }\n', '        for (uint256 n = 0; n < B.length; n++) {\n', '            if (includeMap[A.length + n]) {\n', '                newAddresses[k] = B[n];\n', '                k++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Computes the difference of two arrays. Assumes there are no duplicates.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The difference of the two arrays\n', '     */\n', '    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 count = 0;\n', "        // First count the new length because can't push for in-memory arrays\n", '        for (uint256 i = 0; i < length; i++) {\n', '            address e = A[i];\n', '            if (!contains(B, e)) {\n', '                includeMap[i] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '    * @dev Reverses storage array in place\n', '    */\n', '    function sReverse(address[] storage A) internal {\n', '        address t;\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length / 2; i++) {\n', '            t = A[i];\n', '            A[i] = A[A.length - i - 1];\n', '            A[A.length - i - 1] = t;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Removes specified index from array\n', '    * Resulting ordering is not guaranteed\n', '    * @return Returns the new array and the removed entry\n', '    */\n', '    function pop(address[] memory A, uint256 index)\n', '        internal\n', '        pure\n', '        returns (address[] memory, address)\n', '    {\n', '        uint256 length = A.length;\n', '        address[] memory newAddresses = new address[](length - 1);\n', '        for (uint256 i = 0; i < index; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = index + 1; j < length; j++) {\n', '            newAddresses[j - 1] = A[j];\n', '        }\n', '        return (newAddresses, A[index]);\n', '    }\n', '\n', '    /**\n', '     * @return Returns the new array\n', '     */\n', '    function remove(address[] memory A, address a)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert();\n', '        } else {\n', '            (address[] memory _A,) = pop(A, index);\n', '            return _A;\n', '        }\n', '    }\n', '\n', '    function sPop(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        for (uint256 i = index; i < length - 1; i++) {\n', '            A[i] = A[i + 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '    * Deletes address at index and fills the spot with the last address.\n', '    * Order is not preserved.\n', '    * @return Returns the removed entry\n', '    */\n', '    function sPopCheap(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        if (index != length - 1) {\n', '            A[index] = A[length - 1];\n', '            delete A[length - 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '     * Deletes address at index. Works by swapping it with the last address, then deleting.\n', '     * Order is not preserved\n', '     * @param A Storage array to remove from\n', '     */\n', '    function sRemoveCheap(address[] storage A, address a) internal {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert("Error: entry not found");\n', '        } else {\n', '            sPopCheap(A, index);\n', '            return;\n', '        }\n', '    }\n', '\n', '    /**\n', "     * Returns whether or not there's a duplicate. Runs in O(n^2).\n", '     * @param A Array to search\n', '     * @return Returns true if duplicate, false otherwise\n', '     */\n', '    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n', '        if (A.length == 0) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length - 1; i++) {\n', '            for (uint256 j = i + 1; j < A.length; j++) {\n', '                if (A[i] == A[j]) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Returns whether the two arrays are equal.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return True is the arrays are equal, false if not.\n', '     */\n', '    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\n', '        if (A.length != B.length) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            if (A[i] != B[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns the elements indexed at indexArray.\n', '     * @param A The array to index\n', '     * @param indexArray The array to use to index\n', '     * @return Returns array containing elements indexed at indexArray\n', '     */\n', '    function argGet(address[] memory A, uint256[] memory indexArray)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory array = new address[](indexArray.length);\n', '        for (uint256 i = 0; i < indexArray.length; i++) {\n', '            array[i] = A[indexArray[i]];\n', '        }\n', '        return array;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/core/modules/lib/RebalancingSetIssuance.sol\n', '\n', '/*\n', '    Copyright 2019 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingSetIssuance\n', ' * @author Set Protocol\n', ' *\n', ' * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken\n', ' * issuance\n', ' */\n', 'contract RebalancingSetIssuance is\n', '    ModuleCoreState\n', '{\n', '    using SafeMath for uint256;\n', '    using AddressArrayUtils for address[];\n', '\n', '    // ============ Internal ============\n', '\n', '    /**\n', '     * Validates that wrapped Ether is a component of the SetToken\n', '     *\n', '     * @param  _setAddress            Address of the SetToken\n', '     * @param  _wrappedEtherAddress   Address of wrapped Ether\n', '     */\n', '    function validateWETHIsAComponentOfSet(\n', '        address _setAddress,\n', '        address _wrappedEtherAddress\n', '    )\n', '        internal\n', '        view\n', '    {\n', '        require(\n', '            ISetToken(_setAddress).tokenIsComponent(_wrappedEtherAddress),\n', '            "RebalancingSetIssuance.validateWETHIsAComponentOfSet: Components must contain weth"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Validates that the passed in address is tracked by Core and that the quantity\n', '     * is a multiple of the natural unit\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue/redeem\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     */\n', '    function validateRebalancingSetIssuance(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '    {\n', '        // Expect rebalancing SetToken to be valid and enabled SetToken\n', '        require(\n', '            coreInstance.validSets(_rebalancingSetAddress),\n', '            "RebalancingSetIssuance.validateRebalancingIssuance: Invalid or disabled SetToken address"\n', '        );\n', '\n', '        // Make sure Issuance quantity is multiple of the rebalancing SetToken natural unit\n', '        require(\n', '            _rebalancingSetQuantity.mod(ISetToken(_rebalancingSetAddress).naturalUnit()) == 0,\n', '            "RebalancingSetIssuance.validateRebalancingIssuance: Quantity must be multiple of natural unit"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Given a rebalancing SetToken and a desired issue quantity, calculates the\n', '     * minimum issuable quantity of the base SetToken. If the calculated quantity is initially\n', "     * not a multiple of the base SetToken's natural unit, the quantity is rounded up\n", '     * to the next base set natural unit.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\n', '     */\n', '    function getBaseSetIssuanceRequiredQuantity(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IRebalancingSetTokenV2 rebalancingSet = IRebalancingSetTokenV2(_rebalancingSetAddress);\n', '\n', '        uint256 unitShares = rebalancingSet.unitShares();\n', '        uint256 naturalUnit = rebalancingSet.naturalUnit();\n', '\n', '        uint256 requiredBaseSetQuantity = _rebalancingSetQuantity.div(naturalUnit).mul(unitShares);\n', '\n', '        address baseSet = rebalancingSet.currentSet();\n', '        uint256 baseSetNaturalUnit = ISetToken(baseSet).naturalUnit();\n', '\n', '        // If there is a mismatch between the required quantity and the base SetToken natural unit,\n', '        // round up to the next base SetToken natural unit if required.\n', '        uint256 roundDownQuantity = requiredBaseSetQuantity.mod(baseSetNaturalUnit);\n', '        if (roundDownQuantity > 0) {\n', '            requiredBaseSetQuantity = requiredBaseSetQuantity.sub(roundDownQuantity).add(baseSetNaturalUnit);\n', '        }\n', '\n', '        return requiredBaseSetQuantity;\n', '    }\n', '\n', '\n', '    /**\n', '     * Given a rebalancing SetToken address, retrieve the base SetToken quantity redeem quantity based on the quantity\n', '     * held in the Vault. Rounds down to the nearest base SetToken natural unit\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @return baseSetRedeemQuantity      The quantity of base SetToken to redeem\n', '     */\n', '    function getBaseSetRedeemQuantity(\n', '        address _baseSetAddress\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Get base SetToken Details from the rebalancing SetToken\n', '        uint256 baseSetNaturalUnit = ISetToken(_baseSetAddress).naturalUnit();\n', '        uint256 baseSetBalance = vaultInstance.getOwnerBalance(\n', '            _baseSetAddress,\n', '            address(this)\n', '        );\n', '\n', '        // Round the balance down to the base SetToken natural unit and return\n', '        return baseSetBalance.sub(baseSetBalance.mod(baseSetNaturalUnit));\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances in the Vault and on the contract.\n', '     * Sends any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param _transferProxyAddress       The address of the TransferProxy\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSet(\n', '        address _baseSetAddress,\n', '        address _transferProxyAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        returnExcessBaseSetFromContract(_baseSetAddress, _transferProxyAddress, _keepChangeInVault);\n', '\n', '        returnExcessBaseSetInVault(_baseSetAddress, _keepChangeInVault);\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances on the contract and sends\n', '     * any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param _transferProxyAddress       The address of the TransferProxy\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSetFromContract(\n', '        address _baseSetAddress,\n', '        address _transferProxyAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\n', '\n', '        if (baseSetQuantity == 0) {\n', '            return;\n', '        } else if (_keepChangeInVault) {\n', '            // Ensure base SetToken allowance\n', '            ERC20Wrapper.ensureAllowance(\n', '                _baseSetAddress,\n', '                address(this),\n', '                _transferProxyAddress,\n', '                baseSetQuantity\n', '            );\n', '\n', '            // Deposit base SetToken to the user\n', '            coreInstance.depositModule(\n', '                address(this),\n', '                msg.sender,\n', '                _baseSetAddress,\n', '                baseSetQuantity\n', '            );\n', '        } else {\n', '            // Transfer directly to the user\n', '            ERC20Wrapper.transfer(\n', '                _baseSetAddress,\n', '                msg.sender,\n', '                baseSetQuantity\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Checks the base SetToken balances in the Vault and sends\n', '     * any positive quantity to the user directly or into the Vault\n', '     * depending on the keepChangeInVault flag.\n', '     *\n', '     * @param _baseSetAddress             The address of the base SetToken\n', '     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function returnExcessBaseSetInVault(\n', '        address _baseSetAddress,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        // Return base SetToken if any that are in the Vault\n', '        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\n', '            _baseSetAddress,\n', '            address(this)\n', '        );\n', '\n', '        if (baseSetQuantityInVault == 0) {\n', '            return;\n', '        } else if (_keepChangeInVault) {\n', '            // Transfer ownership within the vault to the user\n', '            coreInstance.internalTransfer(\n', '                _baseSetAddress,\n', '                msg.sender,\n', '                baseSetQuantityInVault\n', '            );\n', '        } else {\n', '            // Transfer ownership directly to the user\n', '            coreInstance.withdrawModule(\n', '                address(this),\n', '                msg.sender,\n', '                _baseSetAddress,\n', '                baseSetQuantityInVault\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/modules/RebalancingSetIssuanceModule.sol\n', '\n', '/*\n', '    Copyright 2019 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RebalancingSetIssuanceModule\n', ' * @author Set Protocol\n', ' *\n', ' * A module that includes functions for issuing / redeeming rebalancing SetToken to/from its base components and ether.\n', ' */\n', 'contract RebalancingSetIssuanceModule is\n', '    ModuleCoreState,\n', '    RebalancingSetIssuance,\n', '    ReentrancyGuard\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // Address and instance of TransferProxy contract\n', '    address public transferProxy;\n', '\n', '    // Address and instance of Wrapped Ether contract\n', '    IWETH public weth;\n', '\n', '    /* ============ Events ============ */\n', '\n', '    event LogRebalancingSetIssue(\n', '        address indexed rebalancingSetAddress,\n', '        address indexed callerAddress,\n', '        uint256 rebalancingSetQuantity\n', '    );\n', '\n', '    event LogRebalancingSetRedeem(\n', '        address indexed rebalancingSetAddress,\n', '        address indexed callerAddress,\n', '        uint256 rebalancingSetQuantity\n', '    );\n', '\n', '    /* ============ Constructor ============ */\n', '\n', '    /**\n', '     * Constructor function for RebalancingSetIssuanceModule\n', '     *\n', '     * @param _core                The address of Core\n', '     * @param _vault               The address of Vault\n', '     * @param _transferProxy       The address of TransferProxy\n', '     * @param _weth                The address of Wrapped Ether\n', '     */\n', '    constructor(\n', '        address _core,\n', '        address _vault,\n', '        address _transferProxy,\n', '        IWETH _weth\n', '    )\n', '        public\n', '        ModuleCoreState(\n', '            _core,\n', '            _vault\n', '        )\n', '    {\n', '        // Commit the WETH instance\n', '        weth = _weth;\n', '\n', '        // Commit the transferProxy instance\n', '        transferProxy = _transferProxy;\n', '    }\n', '\n', '    /**\n', '     * Fallback function. Disallows ether to be sent to this contract without data except when\n', '     * unwrapping WETH.\n', '     */\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        require(\n', '            msg.sender == address(weth),\n', '            "RebalancingSetIssuanceModule.fallback: Cannot receive ETH directly unless unwrapping WETH"\n', '        );\n', '    }\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Issue a rebalancing SetToken using the base components of the base SetToken.\n', '     * The base SetToken is then issued into the rebalancing SetToken. The base SetToken quantity issued is calculated\n', "     * by taking the rebalancing SetToken's quantity, unit shares, and natural unit. If the calculated quantity is not\n", '     * a multiple of the natural unit of the base SetToken, the quantity is rounded up to the base SetToken natural unit.\n', '     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function issueRebalancingSet(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Get baseSet address and quantity required for issuance of Rebalancing Set\n', '        (\n', '            address baseSetAddress,\n', '            uint256 requiredBaseSetQuantity\n', '        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Issue base SetToken to this contract, held in this contract\n', '        coreInstance.issueModule(\n', '            msg.sender,\n', '            address(this),\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Ensure base SetToken allowance to the transferProxy\n', '        ERC20Wrapper.ensureAllowance(\n', '            baseSetAddress,\n', '            address(this),\n', '            transferProxy,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Issue rebalancing SetToken to the sender and return any excess base to sender\n', '        issueRebalancingSetAndReturnExcessBase(\n', '            _rebalancingSetAddress,\n', '            baseSetAddress,\n', '            _rebalancingSetQuantity,\n', '            _keepChangeInVault\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Issue a rebalancing SetToken using the base components and ether of the base SetToken. The ether is wrapped\n', '     * into wrapped Ether and utilized in issuance.\n', '     * The base SetToken is then issued and reissued into the rebalancing SetToken. Read more about base SetToken quantity\n', '     * in the issueRebalancingSet function.\n', '     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', '     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function issueRebalancingSetWrappingEther(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        payable\n', '        nonReentrant\n', '    {\n', '        // Get baseSet address and quantity required for issuance of Rebalancing Set\n', '        (\n', '            address baseSetAddress,\n', '            uint256 requiredBaseSetQuantity\n', '        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Validate that WETH is a component of baseSet\n', '        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\n', '\n', '        // Deposit all the required non-weth components to the vault under the name of this contract\n', '        // The required ether is wrapped and approved to the transferProxy\n', '        depositComponentsAndHandleEth(\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', '        // Issue base SetToken to this contract, with the base SetToken held in the Vault\n', '        coreInstance.issueInVault(\n', '            baseSetAddress,\n', '            requiredBaseSetQuantity\n', '        );\n', '\n', "        // Note: Don't need to set allowance of the base SetToken as the base SetToken is already in the vault\n", '\n', '        // Issue rebalancing SetToken to the sender and return any excess base to sender\n', '        issueRebalancingSetAndReturnExcessBase(\n', '            _rebalancingSetAddress,\n', '            baseSetAddress,\n', '            _rebalancingSetQuantity,\n', '            _keepChangeInVault\n', '        );\n', '\n', '        // Any eth that is not wrapped is sent back to the user\n', '        // Only the amount required for the base SetToken issuance is wrapped.\n', '        uint256 leftoverEth = address(this).balance;\n', '        if (leftoverEth > 0) {\n', '            msg.sender.transfer(leftoverEth);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Redeems a rebalancing SetToken into the base components of the base SetToken.\n', '     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\n', '     *                                     or left in the vault\n', '     */\n', '    function redeemRebalancingSet(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        // Redeem RB Set to the vault attributed to this contract\n', '        coreInstance.redeemModule(\n', '            msg.sender,\n', '            address(this),\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Calculate the base SetToken Redeem quantity\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\n', '\n', '        // Withdraw base SetToken to this contract\n', '        coreInstance.withdraw(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Redeem base SetToken and send components to the the user\n', '        // Set exclude to 0, as tokens in rebalancing SetToken are already whitelisted\n', '        coreInstance.redeemAndWithdrawTo(\n', '            baseSetAddress,\n', '            msg.sender,\n', '            baseSetRedeemQuantity,\n', '            0\n', '        );\n', '\n', '        // Transfer any change of the base SetToken to the end user\n', '        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetRedeem\n', '        emit LogRebalancingSetRedeem(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Redeems a rebalancing SetToken into the base components of the base SetToken. Unwraps\n', '     * wrapped ether and sends eth to the user. If no wrapped ether in Set then will REVERT.\n', '     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\n', '     * Be careful with balance checks.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                   or left in the vault\n', '     */\n', '    function redeemRebalancingSetUnwrappingEther(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '\n', '        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\n', '\n', '        // Redeem rebalancing SetToken to the vault attributed to this contract\n', '        coreInstance.redeemModule(\n', '            msg.sender,\n', '            address(this),\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Calculate the base SetToken Redeem quantity\n', '        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\n', '\n', '        // Withdraw base SetToken to this contract\n', '        coreInstance.withdraw(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Redeem the base SetToken. The components stay in the vault\n', '        coreInstance.redeem(\n', '            baseSetAddress,\n', '            baseSetRedeemQuantity\n', '        );\n', '\n', '        // Loop through the base SetToken components and transfer to sender.\n', '        withdrawComponentsToSenderWithEther(baseSetAddress);\n', '\n', '        // Transfer any change of the base SetToken to the end user\n', '        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetRedeem\n', '        emit LogRebalancingSetRedeem(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /* ============ Private Functions ============ */\n', '\n', '    /**\n', '     * Gets base set address from rebalancing set token and calculates amount of base set needed\n', '     * for issuance.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the RebalancingSetToken to issue\n', '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to issue\n', "     * @return baseSetAddress            The address of RebalancingSet's base SetToken\n", '     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\n', '     */\n', '    function getBaseSetAddressAndQuantity(\n', '        address _rebalancingSetAddress,\n', '        uint256 _rebalancingSetQuantity\n', '    )\n', '        internal\n', '        view\n', '        returns (address, uint256)\n', '    {\n', '        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\n', '        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\n', '\n', '        address baseSetAddress = IRebalancingSetTokenV2(_rebalancingSetAddress).currentSet();\n', '\n', '        // Calculate required base SetToken quantity\n', '        uint256 requiredBaseSetQuantity = getBaseSetIssuanceRequiredQuantity(\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        return (baseSetAddress, requiredBaseSetQuantity);\n', '    }\n', '\n', '    /**\n', '     * Issues the rebalancing set token to sender and returns any excess baseSet.\n', '     *\n', '     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\n', "     * @param  _baseSetAddress           Address of the rebalancing SetToken's base set\n", '     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\n', '     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\n', '     *                                   or left in the vault\n', '     */\n', '    function issueRebalancingSetAndReturnExcessBase(\n', '        address _rebalancingSetAddress,\n', '        address _baseSetAddress,\n', '        uint256 _rebalancingSetQuantity,\n', '        bool _keepChangeInVault\n', '    )\n', '        internal\n', '    {\n', '        // Issue rebalancing SetToken to the sender\n', '        coreInstance.issueTo(\n', '            msg.sender,\n', '            _rebalancingSetAddress,\n', '            _rebalancingSetQuantity\n', '        );\n', '\n', '        // Return any excess base SetToken token to the sender\n', '        returnExcessBaseSet(_baseSetAddress, transferProxy, _keepChangeInVault);\n', '\n', '        // Log RebalancingSetIssue\n', '        emit LogRebalancingSetIssue(\n', '            _rebalancingSetAddress,\n', '            msg.sender,\n', '            _rebalancingSetQuantity\n', '        );\n', '    }\n', '\n', '    /**\n', '     * During issuance, deposit the required quantity of base SetToken, wrap Ether, and deposit components\n', '     * (excluding Ether, which is deposited during issuance) to the Vault in the name of the module.\n', '     *\n', '     * @param  _baseSetAddress           Address of the base SetToken token\n', '     * @param  _baseSetQuantity          The Quantity of the base SetToken token to issue\n', '     */\n', '    function depositComponentsAndHandleEth(\n', '        address _baseSetAddress,\n', '        uint256 _baseSetQuantity\n', '    )\n', '        private\n', '    {\n', '        ISetToken baseSet = ISetToken(_baseSetAddress);\n', '\n', '        address[] memory baseSetComponents = baseSet.getComponents();\n', '        uint256[] memory baseSetUnits = baseSet.getUnits();\n', '        uint256 baseSetNaturalUnit = baseSet.naturalUnit();\n', '\n', '       // Loop through the base SetToken components and deposit components\n', '        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n', '            address currentComponent = baseSetComponents[i];\n', '            uint256 currentUnit = baseSetUnits[i];\n', '\n', '            // Calculate required component quantity\n', '            uint256 currentComponentQuantity = _baseSetQuantity.div(baseSetNaturalUnit).mul(currentUnit);\n', '\n', '            // If address is weth, deposit weth and transfer eth\n', '            if (currentComponent == address(weth)) {\n', '                // Expect the ether included exceeds the required Weth quantity\n', '                require(\n', '                    msg.value >= currentComponentQuantity,\n', '                    "RebalancingSetIssuanceModule.depositComponentsAndHandleEth: Not enough ether included for base SetToken"\n', '                );\n', '\n', '                // wrap the required ether quantity\n', '                weth.deposit.value(currentComponentQuantity)();\n', '\n', '                // Ensure weth allowance\n', '                ERC20Wrapper.ensureAllowance(\n', '                    address(weth),\n', '                    address(this),\n', '                    transferProxy,\n', '                    currentComponentQuantity\n', '                );\n', '            } else {\n', '                // Deposit components to the vault in the name of the contract\n', '                coreInstance.depositModule(\n', '                    msg.sender,\n', '                    address(this),\n', '                    currentComponent,\n', '                    currentComponentQuantity\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * During redemption, withdraw the required quantity of base SetToken, unwrapping Ether, and withdraw\n', '     * components to the sender\n', '     *\n', '     * @param  _baseSetAddress           Address of the base SetToken\n', '     */\n', '    function withdrawComponentsToSenderWithEther(\n', '        address _baseSetAddress\n', '    )\n', '        private\n', '    {\n', '        address[] memory baseSetComponents = ISetToken(_baseSetAddress).getComponents();\n', '\n', '        // Loop through the base SetToken components.\n', '        for (uint256 i = 0; i < baseSetComponents.length; i++) {\n', '            address currentComponent = baseSetComponents[i];\n', '            uint256 currentComponentQuantity = vaultInstance.getOwnerBalance(\n', '                currentComponent,\n', '                address(this)\n', '            );\n', '\n', '            // If address is weth, withdraw weth and transfer eth to sender\n', '            if (currentComponent == address(weth)) {\n', '                // Transfer the wrapped ether to this address from the Vault\n', '                coreInstance.withdrawModule(\n', '                    address(this),\n', '                    address(this),\n', '                    address(weth),\n', '                    currentComponentQuantity\n', '                );\n', '\n', '                // Unwrap wrapped ether\n', '                weth.withdraw(currentComponentQuantity);\n', '\n', '                // Transfer to recipient\n', '                msg.sender.transfer(currentComponentQuantity);\n', '            } else {\n', '                // Withdraw component from the Vault and send to the user\n', '                coreInstance.withdrawModule(\n', '                    address(this),\n', '                    msg.sender,\n', '                    currentComponent,\n', '                    currentComponentQuantity\n', '                );\n', '            }\n', '        }\n', '    }\n', '}']
