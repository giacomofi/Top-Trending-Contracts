['// File: contracts/acl/IACL.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'interface IACL {\n', '    function initialize(address permissionsCreator) external;\n', '\n', '    // TODO: this should be external\n', '    // See https://github.com/ethereum/solidity/issues/4832\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '}\n', '\n', '// File: contracts/common/IVaultRecoverable.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'interface IVaultRecoverable {\n', '    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n', '\n', '    function transferToVault(address token) external;\n', '\n', '    function allowRecoverability(address token) external view returns (bool);\n', '    function getRecoveryVault() external view returns (address);\n', '}\n', '\n', '// File: contracts/kernel/IKernel.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', 'interface IKernelEvents {\n', '    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\n', '}\n', '\n', '\n', "// This should be an interface, but interfaces can't inherit yet :(\n", 'contract IKernel is IKernelEvents, IVaultRecoverable {\n', '    function acl() public view returns (IACL);\n', '    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n', '\n', '    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n', '    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n', '}\n', '\n', '// File: contracts/kernel/KernelConstants.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract KernelAppIds {\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash("kernel");\n', '    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash("acl");\n', '    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash("vault");\n', '    */\n', '    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n', '    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n', '    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\n', '}\n', '\n', '\n', 'contract KernelNamespaceConstants {\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256("core");\n', '    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256("base");\n', '    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256("app");\n', '    */\n', '    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n', '    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n', '    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n', '}\n', '\n', '// File: contracts/kernel/KernelStorage.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'contract KernelStorage {\n', '    // namespace => app id => address\n', '    mapping (bytes32 => mapping (bytes32 => address)) public apps;\n', '    bytes32 public recoveryVaultAppId;\n', '}\n', '\n', '// File: contracts/acl/ACLSyntaxSugar.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract ACLSyntaxSugar {\n', '    function arr() internal pure returns (uint256[]) {\n', '        return new uint256[](0);\n', '    }\n', '\n', '    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a));\n', '    }\n', '\n', '    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), _b, _c);\n', '    }\n', '\n', '    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), _b, _c, _d);\n', '    }\n', '\n', '    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n', '    }\n', '\n', '    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        return arr(uint256(_a), uint256(_b), uint256(_c));\n', '    }\n', '\n', '    function arr(uint256 _a) internal pure returns (uint256[] r) {\n', '        r = new uint256[](1);\n', '        r[0] = _a;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n', '        r = new uint256[](2);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n', '        r = new uint256[](3);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n', '        r = new uint256[](4);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '    }\n', '\n', '    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n', '        r = new uint256[](5);\n', '        r[0] = _a;\n', '        r[1] = _b;\n', '        r[2] = _c;\n', '        r[3] = _d;\n', '        r[4] = _e;\n', '    }\n', '}\n', '\n', '\n', 'contract ACLHelpers {\n', '    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 30));\n', '    }\n', '\n', '    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n', '        return uint8(_x >> (8 * 31));\n', '    }\n', '\n', '    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n', '        a = uint32(_x);\n', '        b = uint32(_x >> (8 * 4));\n', '        c = uint32(_x >> (8 * 8));\n', '    }\n', '}\n', '\n', '// File: contracts/common/ConversionHelpers.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'library ConversionHelpers {\n', '    string private constant ERROR_IMPROPER_LENGTH = "CONVERSION_IMPROPER_LENGTH";\n', '\n', '    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n', '        // Force cast the uint256[] into a bytes array, by overwriting its length\n', "        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\n", '        // with the input and a new length. The input becomes invalid from this point forward.\n', '        uint256 byteLength = _input.length * 32;\n', '        assembly {\n', '            output := _input\n', '            mstore(output, byteLength)\n', '        }\n', '    }\n', '\n', '    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n', '        // Force cast the bytes array into a uint256[], by overwriting its length\n', "        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\n", '        // with the input and a new length. The input becomes invalid from this point forward.\n', '        uint256 intsLength = _input.length / 32;\n', '        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n', '\n', '        assembly {\n', '            output := _input\n', '            mstore(output, intsLength)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/IsContract.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract IsContract {\n', '    /*\n', '    * NOTE: this should NEVER be used for authentication\n', '    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n', '    *\n', '    * This is only intended to be used as a sanity check that an address is actually a contract,\n', '    * RATHER THAN an address not being a contract.\n', '    */\n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly { size := extcodesize(_target) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/common/Uint256Helpers.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'library Uint256Helpers {\n', '    uint256 private constant MAX_UINT64 = uint64(-1);\n', '\n', '    string private constant ERROR_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";\n', '\n', '    function toUint64(uint256 a) internal pure returns (uint64) {\n', '        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n', '        return uint64(a);\n', '    }\n', '}\n', '\n', '// File: contracts/common/TimeHelpers.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract TimeHelpers {\n', '    using Uint256Helpers for uint256;\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number, converted to uint64.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber64() internal view returns (uint64) {\n', '        return getBlockNumber().toUint64();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp() internal view returns (uint256) {\n', '        return block.timestamp; // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp, converted to uint64.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp64() internal view returns (uint64) {\n', '        return getTimestamp().toUint64();\n', '    }\n', '}\n', '\n', '// File: contracts/common/UnstructuredStorage.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'library UnstructuredStorage {\n', '    function getStorageBool(bytes32 position) internal view returns (bool data) {\n', '        assembly { data := sload(position) }\n', '    }\n', '\n', '    function getStorageAddress(bytes32 position) internal view returns (address data) {\n', '        assembly { data := sload(position) }\n', '    }\n', '\n', '    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n', '        assembly { data := sload(position) }\n', '    }\n', '\n', '    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n', '        assembly { data := sload(position) }\n', '    }\n', '\n', '    function setStorageBool(bytes32 position, bool data) internal {\n', '        assembly { sstore(position, data) }\n', '    }\n', '\n', '    function setStorageAddress(bytes32 position, address data) internal {\n', '        assembly { sstore(position, data) }\n', '    }\n', '\n', '    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n', '        assembly { sstore(position, data) }\n', '    }\n', '\n', '    function setStorageUint256(bytes32 position, uint256 data) internal {\n', '        assembly { sstore(position, data) }\n', '    }\n', '}\n', '\n', '// File: contracts/common/Initializable.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', 'contract Initializable is TimeHelpers {\n', '    using UnstructuredStorage for bytes32;\n', '\n', '    // keccak256("aragonOS.initializable.initializationBlock")\n', '    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n', '\n', '    string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";\n', '    string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";\n', '\n', '    modifier onlyInit {\n', '        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n', '        _;\n', '    }\n', '\n', '    modifier isInitialized {\n', '        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return Block number in which the contract was initialized\n', '    */\n', '    function getInitializationBlock() public view returns (uint256) {\n', '        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n', '    }\n', '\n', '    /**\n', '    * @return Whether the contract has been initialized by the time of the current block\n', '    */\n', '    function hasInitialized() public view returns (bool) {\n', '        uint256 initializationBlock = getInitializationBlock();\n', '        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract after initialization has finished.\n', '    */\n', '    function initialized() internal onlyInit {\n', '        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract after initialization to enable the contract\n', '    *      at a future block number rather than immediately.\n', '    */\n', '    function initializedAt(uint256 _blockNumber) internal onlyInit {\n', '        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n', '    }\n', '}\n', '\n', '// File: contracts/common/Petrifiable.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Petrifiable is Initializable {\n', '    // Use block UINT256_MAX (which should be never) as the initializable date\n', '    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n', '\n', '    function isPetrified() public view returns (bool) {\n', '        return getInitializationBlock() == PETRIFIED_BLOCK;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to be called by top level contract to prevent being initialized.\n', "    *      Useful for freezing base contracts when they're used behind proxies.\n", '    */\n', '    function petrify() internal onlyInit {\n', '        initializedAt(PETRIFIED_BLOCK);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/token/ERC20.sol\n', '\n', '// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '// File: contracts/common/EtherTokenConstant.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n', '// contracts where both tokens and ETH are accepted\n', 'contract EtherTokenConstant {\n', '    address internal constant ETH = address(0);\n', '}\n', '\n', '// File: contracts/common/SafeERC20.sol\n', '\n', '// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n', '// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n', '    // https://github.com/ethereum/solidity/issues/3544\n', '    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n', '\n', '    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n', '    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n', '\n', '    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n', '        private\n', '        returns (bool)\n', '    {\n', '        bool ret;\n', '        assembly {\n', '            let ptr := mload(0x40)    // free memory pointer\n', '\n', '            let success := call(\n', '                gas,                  // forward all gas\n', '                _addr,                // address\n', '                0,                    // no value\n', '                add(_calldata, 0x20), // calldata start\n', '                mload(_calldata),     // calldata length\n', '                ptr,                  // write output over free memory\n', '                0x20                  // uint256 return\n', '            )\n', '\n', '            if gt(success, 0) {\n', '                // Check number of bytes returned from last function call\n', '                switch returndatasize\n', '\n', '                // No bytes returned: assume success\n', '                case 0 {\n', '                    ret := 1\n', '                }\n', '\n', '                // 32 bytes returned: check if non-zero\n', '                case 0x20 {\n', '                    // Only return success if returned data was true\n', '                    // Already have output in ptr\n', '                    ret := eq(mload(ptr), 1)\n', '                }\n', '\n', "                // Not sure what was returned: don't mark as success\n", '                default { }\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    function staticInvoke(address _addr, bytes memory _calldata)\n', '        private\n', '        view\n', '        returns (bool, uint256)\n', '    {\n', '        bool success;\n', '        uint256 ret;\n', '        assembly {\n', '            let ptr := mload(0x40)    // free memory pointer\n', '\n', '            success := staticcall(\n', '                gas,                  // forward all gas\n', '                _addr,                // address\n', '                add(_calldata, 0x20), // calldata start\n', '                mload(_calldata),     // calldata length\n', '                ptr,                  // write output over free memory\n', '                0x20                  // uint256 return\n', '            )\n', '\n', '            if gt(success, 0) {\n', '                ret := mload(ptr)\n', '            }\n', '        }\n', '        return (success, ret);\n', '    }\n', '\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n', '    *      Note that this makes an external call to the token.\n', '    */\n', '    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n', '        bytes memory transferCallData = abi.encodeWithSelector(\n', '            TRANSFER_SELECTOR,\n', '            _to,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(_token, transferCallData);\n', '    }\n', '\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n', '    *      Note that this makes an external call to the token.\n', '    */\n', '    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n', '        bytes memory transferFromCallData = abi.encodeWithSelector(\n', '            _token.transferFrom.selector,\n', '            _from,\n', '            _to,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(_token, transferFromCallData);\n', '    }\n', '\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n', '    *      Note that this makes an external call to the token.\n', '    */\n', '    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n', '        bytes memory approveCallData = abi.encodeWithSelector(\n', '            _token.approve.selector,\n', '            _spender,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(_token, approveCallData);\n', '    }\n', '\n', '    /**\n', '    * @dev Static call into ERC20.balanceOf().\n', '    * Reverts if the call fails for some reason (should never fail).\n', '    */\n', '    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n', '        bytes memory balanceOfCallData = abi.encodeWithSelector(\n', '            _token.balanceOf.selector,\n', '            _owner\n', '        );\n', '\n', '        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n', '        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n', '\n', '        return tokenBalance;\n', '    }\n', '\n', '    /**\n', '    * @dev Static call into ERC20.allowance().\n', '    * Reverts if the call fails for some reason (should never fail).\n', '    */\n', '    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n', '        bytes memory allowanceCallData = abi.encodeWithSelector(\n', '            _token.allowance.selector,\n', '            _owner,\n', '            _spender\n', '        );\n', '\n', '        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n', '        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n', '\n', '        return allowance;\n', '    }\n', '}\n', '\n', '// File: contracts/common/VaultRecoverable.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n', '    using SafeERC20 for ERC20;\n', '\n', '    string private constant ERROR_DISALLOWED = "RECOVER_DISALLOWED";\n', '    string private constant ERROR_VAULT_NOT_CONTRACT = "RECOVER_VAULT_NOT_CONTRACT";\n', '    string private constant ERROR_TOKEN_TRANSFER_FAILED = "RECOVER_TOKEN_TRANSFER_FAILED";\n', '\n', '    /**\n', '     * @notice Send funds to recovery Vault. This contract should never receive funds,\n', '     *         but in case it does, this function allows one to recover them.\n', '     * @param _token Token balance to be sent to recovery vault.\n', '     */\n', '    function transferToVault(address _token) external {\n', '        require(allowRecoverability(_token), ERROR_DISALLOWED);\n', '        address vault = getRecoveryVault();\n', '        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n', '\n', '        uint256 balance;\n', '        if (_token == ETH) {\n', '            balance = address(this).balance;\n', '            vault.transfer(balance);\n', '        } else {\n', '            ERC20 token = ERC20(_token);\n', '            balance = token.staticBalanceOf(this);\n', '            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n', '        }\n', '\n', '        emit RecoverToVault(vault, _token, balance);\n', '    }\n', '\n', '    /**\n', '    * @dev By default deriving from AragonApp makes it recoverable\n', '    * @param token Token address that would be recovered\n', '    * @return bool whether the app allows the recovery\n', '    */\n', '    function allowRecoverability(address token) public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    // Cast non-implemented interface to be public so we can use it internally\n', '    function getRecoveryVault() public view returns (address);\n', '}\n', '\n', '// File: contracts/apps/AppStorage.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', 'contract AppStorage {\n', '    using UnstructuredStorage for bytes32;\n', '\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant KERNEL_POSITION = keccak256("aragonOS.appStorage.kernel");\n', '    bytes32 internal constant APP_ID_POSITION = keccak256("aragonOS.appStorage.appId");\n', '    */\n', '    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n', '    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n', '\n', '    function kernel() public view returns (IKernel) {\n', '        return IKernel(KERNEL_POSITION.getStorageAddress());\n', '    }\n', '\n', '    function appId() public view returns (bytes32) {\n', '        return APP_ID_POSITION.getStorageBytes32();\n', '    }\n', '\n', '    function setKernel(IKernel _kernel) internal {\n', '        KERNEL_POSITION.setStorageAddress(address(_kernel));\n', '    }\n', '\n', '    function setAppId(bytes32 _appId) internal {\n', '        APP_ID_POSITION.setStorageBytes32(_appId);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/misc/ERCProxy.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract ERCProxy {\n', '    uint256 internal constant FORWARDING = 1;\n', '    uint256 internal constant UPGRADEABLE = 2;\n', '\n', '    function proxyType() public pure returns (uint256 proxyTypeId);\n', '    function implementation() public view returns (address codeAddr);\n', '}\n', '\n', '// File: contracts/common/DelegateProxy.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', 'contract DelegateProxy is ERCProxy, IsContract {\n', '    uint256 internal constant FWD_GAS_LIMIT = 10000;\n', '\n', '    /**\n', '    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n', '    * @param _dst Destination address to perform the delegatecall\n', '    * @param _calldata Calldata for the delegatecall\n', '    */\n', '    function delegatedFwd(address _dst, bytes _calldata) internal {\n', '        require(isContract(_dst));\n', '        uint256 fwdGasLimit = FWD_GAS_LIMIT;\n', '\n', '        assembly {\n', '            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/DepositableStorage.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', 'contract DepositableStorage {\n', '    using UnstructuredStorage for bytes32;\n', '\n', '    // keccak256("aragonOS.depositableStorage.depositable")\n', '    bytes32 internal constant DEPOSITABLE_POSITION = 0x665fd576fbbe6f247aff98f5c94a561e3f71ec2d3c988d56f12d342396c50cea;\n', '\n', '    function isDepositable() public view returns (bool) {\n', '        return DEPOSITABLE_POSITION.getStorageBool();\n', '    }\n', '\n', '    function setDepositable(bool _depositable) internal {\n', '        DEPOSITABLE_POSITION.setStorageBool(_depositable);\n', '    }\n', '}\n', '\n', '// File: contracts/common/DepositableDelegateProxy.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', 'contract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\n', '    event ProxyDeposit(address sender, uint256 value);\n', '\n', '    function () external payable {\n', '        // send / transfer\n', '        if (gasleft() < FWD_GAS_LIMIT) {\n', '            require(msg.value > 0 && msg.data.length == 0);\n', '            require(isDepositable());\n', '            emit ProxyDeposit(msg.sender, msg.value);\n', '        } else { // all calls except for send or transfer\n', '            address target = implementation();\n', '            delegatedFwd(target, msg.data);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/apps/AppProxyBase.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyBase is AppStorage, DepositableDelegateProxy, KernelNamespaceConstants {\n', '    /**\n', '    * @dev Initialize AppProxy\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n', '        setKernel(_kernel);\n', '        setAppId(_appId);\n', '\n', '        // Implicit check that kernel is actually a Kernel\n', "        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n", '        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n', '        // it.\n', '        address appCode = getAppBase(_appId);\n', '\n', '        // If initialize payload is provided, it will be executed\n', '        if (_initializePayload.length > 0) {\n', '            require(isContract(appCode));\n', '            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n', '            // returns ending execution context and halts contract deployment\n', '            require(appCode.delegatecall(_initializePayload));\n', '        }\n', '    }\n', '\n', '    function getAppBase(bytes32 _appId) internal view returns (address) {\n', '        return kernel().getApp(KERNEL_APP_BASES_NAMESPACE, _appId);\n', '    }\n', '}\n', '\n', '// File: contracts/apps/AppProxyUpgradeable.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', 'contract AppProxyUpgradeable is AppProxyBase {\n', '    /**\n', '    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '        AppProxyBase(_kernel, _appId, _initializePayload)\n', '        public // solium-disable-line visibility-first\n', '    {\n', '        // solium-disable-previous-line no-empty-blocks\n', '    }\n', '\n', '    /**\n', '     * @dev ERC897, the address the proxy would delegate calls to\n', '     */\n', '    function implementation() public view returns (address) {\n', '        return getAppBase(appId());\n', '    }\n', '\n', '    /**\n', '     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n', '     */\n', '    function proxyType() public pure returns (uint256 proxyTypeId) {\n', '        return UPGRADEABLE;\n', '    }\n', '}\n', '\n', '// File: contracts/apps/AppProxyPinned.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract AppProxyPinned is IsContract, AppProxyBase {\n', '    using UnstructuredStorage for bytes32;\n', '\n', '    // keccak256("aragonOS.appStorage.pinnedCode")\n', '    bytes32 internal constant PINNED_CODE_POSITION = 0xdee64df20d65e53d7f51cb6ab6d921a0a6a638a91e942e1d8d02df28e31c038e;\n', '\n', '    /**\n', '    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n', '    * @param _kernel Reference to organization kernel for the app\n', '    * @param _appId Identifier for app\n', '    * @param _initializePayload Payload for call to be made after setup to initialize\n', '    */\n', '    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n', '        AppProxyBase(_kernel, _appId, _initializePayload)\n', '        public // solium-disable-line visibility-first\n', '    {\n', '        setPinnedCode(getAppBase(_appId));\n', '        require(isContract(pinnedCode()));\n', '    }\n', '\n', '    /**\n', '     * @dev ERC897, the address the proxy would delegate calls to\n', '     */\n', '    function implementation() public view returns (address) {\n', '        return pinnedCode();\n', '    }\n', '\n', '    /**\n', '     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n', '     */\n', '    function proxyType() public pure returns (uint256 proxyTypeId) {\n', '        return FORWARDING;\n', '    }\n', '\n', '    function setPinnedCode(address _pinnedCode) internal {\n', '        PINNED_CODE_POSITION.setStorageAddress(_pinnedCode);\n', '    }\n', '\n', '    function pinnedCode() internal view returns (address) {\n', '        return PINNED_CODE_POSITION.getStorageAddress();\n', '    }\n', '}\n', '\n', '// File: contracts/factory/AppProxyFactory.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', 'contract AppProxyFactory {\n', '    event NewAppProxy(address proxy, bool isUpgradeable, bytes32 appId);\n', '\n', '    /**\n', '    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId`\n', "    * @param _kernel App's Kernel reference\n", '    * @param _appId Identifier for app\n', '    * @return AppProxyUpgradeable\n', '    */\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n', '        return newAppProxy(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    /**\n', '    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\n', "    * @param _kernel App's Kernel reference\n", '    * @param _appId Identifier for app\n', '    * @return AppProxyUpgradeable\n', '    */\n', '    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n', '        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n', '        emit NewAppProxy(address(proxy), true, _appId);\n', '        return proxy;\n', '    }\n', '\n', '    /**\n', '    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId`\n', "    * @param _kernel App's Kernel reference\n", '    * @param _appId Identifier for app\n', '    * @return AppProxyPinned\n', '    */\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n', '        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n', '    }\n', '\n', '    /**\n', '    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\n', "    * @param _kernel App's Kernel reference\n", '    * @param _appId Identifier for app\n', '    * @param _initializePayload Proxy initialization payload\n', '    * @return AppProxyPinned\n', '    */\n', '    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n', '        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n', '        emit NewAppProxy(address(proxy), false, _appId);\n', '        return proxy;\n', '    }\n', '}\n', '\n', '// File: contracts/kernel/Kernel.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// solium-disable-next-line max-len\n', 'contract Kernel is IKernel, KernelStorage, KernelAppIds, KernelNamespaceConstants, Petrifiable, IsContract, VaultRecoverable, AppProxyFactory, ACLSyntaxSugar {\n', '    /* Hardcoded constants to save gas\n', '    bytes32 public constant APP_MANAGER_ROLE = keccak256("APP_MANAGER_ROLE");\n', '    */\n', '    bytes32 public constant APP_MANAGER_ROLE = 0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0;\n', '\n', '    string private constant ERROR_APP_NOT_CONTRACT = "KERNEL_APP_NOT_CONTRACT";\n', '    string private constant ERROR_INVALID_APP_CHANGE = "KERNEL_INVALID_APP_CHANGE";\n', '    string private constant ERROR_AUTH_FAILED = "KERNEL_AUTH_FAILED";\n', '\n', '    /**\n', '    * @dev Constructor that allows the deployer to choose if the base instance should be petrified immediately.\n', '    * @param _shouldPetrify Immediately petrify this instance so that it can never be initialized\n', '    */\n', '    constructor(bool _shouldPetrify) public {\n', '        if (_shouldPetrify) {\n', '            petrify();\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n', '    * @notice Initialize this kernel instance along with its ACL and set `_permissionsCreator` as the entity that can create other permissions\n', '    * @param _baseAcl Address of base ACL app\n', '    * @param _permissionsCreator Entity that will be given permission over createPermission\n', '    */\n', '    function initialize(IACL _baseAcl, address _permissionsCreator) public onlyInit {\n', '        initialized();\n', '\n', '        // Set ACL base\n', '        _setApp(KERNEL_APP_BASES_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, _baseAcl);\n', '\n', '        // Create ACL instance and attach it as the default ACL app\n', '        IACL acl = IACL(newAppProxy(this, KERNEL_DEFAULT_ACL_APP_ID));\n', '        acl.initialize(_permissionsCreator);\n', '        _setApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, acl);\n', '\n', '        recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID;\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new instance of an app linked to this kernel\n', '    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`\n', '    * @param _appId Identifier for app\n', "    * @param _appBase Address of the app's base implementation\n", '    * @return AppProxy instance\n', '    */\n', '    function newAppInstance(bytes32 _appId, address _appBase)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n', '        returns (ERCProxy appProxy)\n', '    {\n', '        return newAppInstance(_appId, _appBase, new bytes(0), false);\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new instance of an app linked to this kernel and set its base\n', '    *      implementation if it was not already set\n', "    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\n", '    * @param _appId Identifier for app\n', "    * @param _appBase Address of the app's base implementation\n", '    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\n', '    * @param _setDefault Whether the app proxy app is the default one.\n', '    *        Useful when the Kernel needs to know of an instance of a particular app,\n', '    *        like Vault for escape hatch mechanism.\n', '    * @return AppProxy instance\n', '    */\n', '    function newAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n', '        returns (ERCProxy appProxy)\n', '    {\n', '        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\n', '        appProxy = newAppProxy(this, _appId, _initializePayload);\n', '        // By calling setApp directly and not the internal functions, we make sure the params are checked\n', '        // and it will only succeed if sender has permissions to set something to the namespace.\n', '        if (_setDefault) {\n', '            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new pinned instance of an app linked to this kernel\n', '    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`.\n', '    * @param _appId Identifier for app\n', "    * @param _appBase Address of the app's base implementation\n", '    * @return AppProxy instance\n', '    */\n', '    function newPinnedAppInstance(bytes32 _appId, address _appBase)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n', '        returns (ERCProxy appProxy)\n', '    {\n', '        return newPinnedAppInstance(_appId, _appBase, new bytes(0), false);\n', '    }\n', '\n', '    /**\n', '    * @dev Create a new pinned instance of an app linked to this kernel and set\n', '    *      its base implementation if it was not already set\n', "    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\n", '    * @param _appId Identifier for app\n', "    * @param _appBase Address of the app's base implementation\n", '    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\n', '    * @param _setDefault Whether the app proxy app is the default one.\n', '    *        Useful when the Kernel needs to know of an instance of a particular app,\n', '    *        like Vault for escape hatch mechanism.\n', '    * @return AppProxy instance\n', '    */\n', '    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n', '        returns (ERCProxy appProxy)\n', '    {\n', '        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\n', '        appProxy = newAppProxyPinned(this, _appId, _initializePayload);\n', '        // By calling setApp directly and not the internal functions, we make sure the params are checked\n', '        // and it will only succeed if sender has permissions to set something to the namespace.\n', '        if (_setDefault) {\n', '            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Set the resolving address of an app instance or base implementation\n', '    * @notice Set the resolving address of `_appId` in namespace `_namespace` to `_app`\n', '    * @param _namespace App namespace to use\n', '    * @param _appId Identifier for app\n', '    * @param _app Address of the app instance or base implementation\n', '    * @return ID of app\n', '    */\n', '    function setApp(bytes32 _namespace, bytes32 _appId, address _app)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(_namespace, _appId))\n', '    {\n', '        _setApp(_namespace, _appId, _app);\n', '    }\n', '\n', '    /**\n', '    * @dev Set the default vault id for the escape hatch mechanism\n', '    * @param _recoveryVaultAppId Identifier of the recovery vault app\n', '    */\n', '    function setRecoveryVaultAppId(bytes32 _recoveryVaultAppId)\n', '        public\n', '        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_ADDR_NAMESPACE, _recoveryVaultAppId))\n', '    {\n', '        recoveryVaultAppId = _recoveryVaultAppId;\n', '    }\n', '\n', '    // External access to default app id and namespace constants to mimic default getters for constants\n', '    /* solium-disable function-order, mixedcase */\n', '    function CORE_NAMESPACE() external pure returns (bytes32) { return KERNEL_CORE_NAMESPACE; }\n', '    function APP_BASES_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_BASES_NAMESPACE; }\n', '    function APP_ADDR_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_ADDR_NAMESPACE; }\n', '    function KERNEL_APP_ID() external pure returns (bytes32) { return KERNEL_CORE_APP_ID; }\n', '    function DEFAULT_ACL_APP_ID() external pure returns (bytes32) { return KERNEL_DEFAULT_ACL_APP_ID; }\n', '    /* solium-enable function-order, mixedcase */\n', '\n', '    /**\n', '    * @dev Get the address of an app instance or base implementation\n', '    * @param _namespace App namespace to use\n', '    * @param _appId Identifier for app\n', '    * @return Address of the app\n', '    */\n', '    function getApp(bytes32 _namespace, bytes32 _appId) public view returns (address) {\n', '        return apps[_namespace][_appId];\n', '    }\n', '\n', '    /**\n', '    * @dev Get the address of the recovery Vault instance (to recover funds)\n', '    * @return Address of the Vault\n', '    */\n', '    function getRecoveryVault() public view returns (address) {\n', '        return apps[KERNEL_APP_ADDR_NAMESPACE][recoveryVaultAppId];\n', '    }\n', '\n', '    /**\n', '    * @dev Get the installed ACL app\n', '    * @return ACL app\n', '    */\n', '    function acl() public view returns (IACL) {\n', '        return IACL(getApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID));\n', '    }\n', '\n', '    /**\n', '    * @dev Function called by apps to check ACL on kernel or to check permission status\n', '    * @param _who Sender of the original call\n', '    * @param _where Address of the app\n', '    * @param _what Identifier for a group of actions in app\n', '    * @param _how Extra data for ACL auth\n', '    * @return Boolean indicating whether the ACL allows the role or not.\n', "    *         Always returns false if the kernel hasn't been initialized yet.\n", '    */\n', '    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n', '        IACL defaultAcl = acl();\n', "        return address(defaultAcl) != address(0) && // Poor man's initialization check (saves gas)\n", '            defaultAcl.hasPermission(_who, _where, _what, _how);\n', '    }\n', '\n', '    function _setApp(bytes32 _namespace, bytes32 _appId, address _app) internal {\n', '        require(isContract(_app), ERROR_APP_NOT_CONTRACT);\n', '        apps[_namespace][_appId] = _app;\n', '        emit SetApp(_namespace, _appId, _app);\n', '    }\n', '\n', '    function _setAppIfNew(bytes32 _namespace, bytes32 _appId, address _app) internal {\n', '        address app = getApp(_namespace, _appId);\n', '        if (app != address(0)) {\n', '            // The only way to set an app is if it passes the isContract check, so no need to check it again\n', '            require(app == _app, ERROR_INVALID_APP_CHANGE);\n', '        } else {\n', '            _setApp(_namespace, _appId, _app);\n', '        }\n', '    }\n', '\n', '    modifier auth(bytes32 _role, uint256[] memory _params) {\n', '        require(\n', '            hasPermission(msg.sender, address(this), _role, ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)),\n', '            ERROR_AUTH_FAILED\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/kernel/KernelProxy.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract KernelProxy is IKernelEvents, KernelStorage, KernelAppIds, KernelNamespaceConstants, IsContract, DepositableDelegateProxy {\n', '    /**\n', '    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\n', '    *      can update the reference, which effectively upgrades the contract\n', '    * @param _kernelImpl Address of the contract used as implementation for kernel\n', '    */\n', '    constructor(IKernel _kernelImpl) public {\n', '        require(isContract(address(_kernelImpl)));\n', '        apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID] = _kernelImpl;\n', '\n', '        // Note that emitting this event is important for verifying that a KernelProxy instance\n', '        // was never upgraded to a malicious Kernel logic contract over its lifespan.\n', '        // This starts the "chain of trust", that can be followed through later SetApp() events\n', '        // emitted during kernel upgrades.\n', '        emit SetApp(KERNEL_CORE_NAMESPACE, KERNEL_CORE_APP_ID, _kernelImpl);\n', '    }\n', '\n', '    /**\n', '     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n', '     */\n', '    function proxyType() public pure returns (uint256 proxyTypeId) {\n', '        return UPGRADEABLE;\n', '    }\n', '\n', '    /**\n', '    * @dev ERC897, the address the proxy would delegate calls to\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID];\n', '    }\n', '}\n', '\n', '// File: contracts/common/Autopetrified.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Autopetrified is Petrifiable {\n', '    constructor() public {\n', '        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n', '        // This renders them uninitializable (and unusable without a proxy).\n', '        petrify();\n', '    }\n', '}\n', '\n', '// File: contracts/common/ReentrancyGuard.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract ReentrancyGuard {\n', '    using UnstructuredStorage for bytes32;\n', '\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256("aragonOS.reentrancyGuard.mutex");\n', '    */\n', '    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\n', '\n', '    string private constant ERROR_REENTRANT = "REENTRANCY_REENTRANT_CALL";\n', '\n', '    modifier nonReentrant() {\n', '        // Ensure mutex is unlocked\n', '        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\n', '\n', '        // Lock mutex before function call\n', '        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\n', '\n', '        // Perform function call\n', '        _;\n', '\n', '        // Unlock mutex after function call\n', '        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\n', '    }\n', '}\n', '\n', '// File: contracts/evmscript/IEVMScriptExecutor.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'interface IEVMScriptExecutor {\n', '    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n', '    function executorType() external pure returns (bytes32);\n', '}\n', '\n', '// File: contracts/evmscript/IEVMScriptRegistry.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract EVMScriptRegistryConstants {\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash("evmreg");\n', '    */\n', '    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n', '}\n', '\n', '\n', 'interface IEVMScriptRegistry {\n', '    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n', '    function disableScriptExecutor(uint256 executorId) external;\n', '\n', '    // TODO: this should be external\n', '    // See https://github.com/ethereum/solidity/issues/4832\n', '    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n', '}\n', '\n', '// File: contracts/evmscript/EVMScriptRunner.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\n', '    string private constant ERROR_EXECUTOR_UNAVAILABLE = "EVMRUN_EXECUTOR_UNAVAILABLE";\n', '    string private constant ERROR_PROTECTED_STATE_MODIFIED = "EVMRUN_PROTECTED_STATE_MODIFIED";\n', '\n', '    /* This is manually crafted in assembly\n', '    string private constant ERROR_EXECUTOR_INVALID_RETURN = "EVMRUN_EXECUTOR_INVALID_RETURN";\n', '    */\n', '\n', '    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n', '\n', '    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n', '        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n', '    }\n', '\n', '    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n', '        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n', '        return IEVMScriptRegistry(registryAddr);\n', '    }\n', '\n', '    function runScript(bytes _script, bytes _input, address[] _blacklist)\n', '        internal\n', '        isInitialized\n', '        protectState\n', '        returns (bytes)\n', '    {\n', '        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n', '        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n', '\n', '        bytes4 sig = executor.execScript.selector;\n', '        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n', '\n', '        bytes memory output;\n', '        assembly {\n', '            let success := delegatecall(\n', '                gas,                // forward all gas\n', '                executor,           // address\n', '                add(data, 0x20),    // calldata start\n', '                mload(data),        // calldata length\n', "                0,                  // don't write output (we'll handle this ourselves)\n", "                0                   // don't write output\n", '            )\n', '\n', '            output := mload(0x40) // free mem ptr get\n', '\n', '            switch success\n', '            case 0 {\n', '                // If the call errored, forward its full error data\n', '                returndatacopy(output, 0, returndatasize)\n', '                revert(output, returndatasize)\n', '            }\n', '            default {\n', '                switch gt(returndatasize, 0x3f)\n', '                case 0 {\n', '                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n', '                    // revert with "EVMRUN_EXECUTOR_INVALID_RETURN"\n', '                    // See remix: doing a `revert("EVMRUN_EXECUTOR_INVALID_RETURN")` always results in\n', '                    // this memory layout\n', '                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n', '                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n', '                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n', '                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n', '\n', '                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n', '                }\n', '                default {\n', '                    // Copy result\n', '                    //\n', '                    // Needs to perform an ABI decode for the expected `bytes` return type of\n', '                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n', '                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n', '                    //    [ output length (32 bytes) ]\n', '                    //    [ output content (N bytes) ]\n', '                    //\n', '                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n', '                    let copysize := sub(returndatasize, 0x20)\n', '                    returndatacopy(output, 0x20, copysize)\n', '\n', '                    mstore(0x40, add(output, copysize)) // free mem ptr set\n', '                }\n', '            }\n', '        }\n', '\n', '        emit ScriptResult(address(executor), _script, _input, output);\n', '\n', '        return output;\n', '    }\n', '\n', '    modifier protectState {\n', '        address preKernel = address(kernel());\n', '        bytes32 preAppId = appId();\n', '        _; // exec\n', '        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n', '        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n', '    }\n', '}\n', '\n', '// File: contracts/apps/AragonApp.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\n', '// that they can never be initialized.\n', '// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\n', '// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\n', '// are included so that they are automatically usable by subclassing contracts\n', 'contract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\n', '    string private constant ERROR_AUTH_FAILED = "APP_AUTH_FAILED";\n', '\n', '    modifier auth(bytes32 _role) {\n', '        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n', '        _;\n', '    }\n', '\n', '    modifier authP(bytes32 _role, uint256[] _params) {\n', '        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Check whether an action can be performed by a sender for a particular role on this app\n', '    * @param _sender Sender of the call\n', '    * @param _role Role on this app\n', '    * @param _params Permission params for the role\n', '    * @return Boolean indicating whether the sender has the permissions to perform the action.\n', "    *         Always returns false if the app hasn't been initialized yet.\n", '    */\n', '    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n', '        if (!hasInitialized()) {\n', '            return false;\n', '        }\n', '\n', '        IKernel linkedKernel = kernel();\n', '        if (address(linkedKernel) == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        return linkedKernel.hasPermission(\n', '            _sender,\n', '            address(this),\n', '            _role,\n', '            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Get the recovery vault for the app\n', '    * @return Recovery vault address for the app\n', '    */\n', '    function getRecoveryVault() public view returns (address) {\n', '        // Funds recovery via a vault is only available when used with a kernel\n', '        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n', '    }\n', '}\n', '\n', '// File: contracts/acl/IACLOracle.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'interface IACLOracle {\n', '    function canPerform(address who, address where, bytes32 what, uint256[] how) external view returns (bool);\n', '}\n', '\n', '// File: contracts/acl/ACL.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/* solium-disable function-order */\n', '// Allow public initialize() to be first\n', 'contract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {\n', '    /* Hardcoded constants to save gas\n', '    bytes32 public constant CREATE_PERMISSIONS_ROLE = keccak256("CREATE_PERMISSIONS_ROLE");\n', '    */\n', '    bytes32 public constant CREATE_PERMISSIONS_ROLE = 0x0b719b33c83b8e5d300c521cb8b54ae9bd933996a14bef8c2f4e0285d2d2400a;\n', '\n', '    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, RET, NOT, AND, OR, XOR, IF_ELSE } // op types\n', '\n', '    struct Param {\n', '        uint8 id;\n', '        uint8 op;\n', '        uint240 value; // even though value is an uint240 it can store addresses\n', "        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n", '        // op and id take less than 1 byte each so it can be kept in 1 sstore\n', '    }\n', '\n', '    uint8 internal constant BLOCK_NUMBER_PARAM_ID = 200;\n', '    uint8 internal constant TIMESTAMP_PARAM_ID    = 201;\n', '    // 202 is unused\n', '    uint8 internal constant ORACLE_PARAM_ID       = 203;\n', '    uint8 internal constant LOGIC_OP_PARAM_ID     = 204;\n', '    uint8 internal constant PARAM_VALUE_PARAM_ID  = 205;\n', '    // TODO: Add execution times param type?\n', '\n', '    /* Hardcoded constant to save gas\n', '    bytes32 public constant EMPTY_PARAM_HASH = keccak256(uint256(0));\n', '    */\n', '    bytes32 public constant EMPTY_PARAM_HASH = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\n', '    bytes32 public constant NO_PERMISSION = bytes32(0);\n', '    address public constant ANY_ENTITY = address(-1);\n', '    address public constant BURN_ENTITY = address(1); // address(0) is already used as "no permission manager"\n', '\n', '    uint256 internal constant ORACLE_CHECK_GAS = 30000;\n', '\n', '    string private constant ERROR_AUTH_INIT_KERNEL = "ACL_AUTH_INIT_KERNEL";\n', '    string private constant ERROR_AUTH_NO_MANAGER = "ACL_AUTH_NO_MANAGER";\n', '    string private constant ERROR_EXISTENT_MANAGER = "ACL_EXISTENT_MANAGER";\n', '\n', '    // Whether someone has a permission\n', '    mapping (bytes32 => bytes32) internal permissions; // permissions hash => params hash\n', '    mapping (bytes32 => Param[]) internal permissionParams; // params hash => params\n', '\n', '    // Who is the manager of a permission\n', '    mapping (bytes32 => address) internal permissionManager;\n', '\n', '    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n', '    event SetPermissionParams(address indexed entity, address indexed app, bytes32 indexed role, bytes32 paramsHash);\n', '    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n', '\n', '    modifier onlyPermissionManager(address _app, bytes32 _role) {\n', '        require(msg.sender == getPermissionManager(_app, _role), ERROR_AUTH_NO_MANAGER);\n', '        _;\n', '    }\n', '\n', '    modifier noPermissionManager(address _app, bytes32 _role) {\n', '        // only allow permission creation (or re-creation) when there is no manager\n', '        require(getPermissionManager(_app, _role) == address(0), ERROR_EXISTENT_MANAGER);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n', '    * @notice Initialize an ACL instance and set `_permissionsCreator` as the entity that can create other permissions\n', '    * @param _permissionsCreator Entity that will be given permission over createPermission\n', '    */\n', '    function initialize(address _permissionsCreator) public onlyInit {\n', '        initialized();\n', '        require(msg.sender == address(kernel()), ERROR_AUTH_INIT_KERNEL);\n', '\n', '        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n', '    }\n', '\n', '    /**\n', "    * @dev Creates a permission that wasn't previously set and managed.\n", '    *      If a created permission is removed it is possible to reset it with createPermission.\n', "    *      This is the **ONLY** way to create permissions and set managers to permissions that don't\n", '    *      have a manager.\n', '    *      In terms of the ACL being initialized, this function implicitly protects all the other\n', '    *      state-changing external functions, as they all require the sender to be a manager.\n', "    * @notice Create a new permission granting `_entity` the ability to perform actions requiring `_role` on `_app`, setting `_manager` as the permission's manager\n", '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n', '    */\n', '    function createPermission(address _entity, address _app, bytes32 _role, address _manager)\n', '        external\n', '        auth(CREATE_PERMISSIONS_ROLE)\n', '        noPermissionManager(_app, _role)\n', '    {\n', '        _createPermission(_entity, _app, _role, _manager);\n', '    }\n', '\n', '    /**\n', '    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    */\n', '    function grantPermission(address _entity, address _app, bytes32 _role)\n', '        external\n', '    {\n', '        grantPermissionP(_entity, _app, _role, new uint256[](0));\n', '    }\n', '\n', '    /**\n', '    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n', '    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n', '    * @param _role Identifier for the group of actions in app given access to perform\n', '    * @param _params Permission parameters\n', '    */\n', '    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n', '        public\n', '        onlyPermissionManager(_app, _role)\n', '    {\n', '        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n', '        _setPermission(_entity, _app, _role, paramsHash);\n', '    }\n', '\n', '    /**\n', '    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n', '    * @notice Revoke from `_entity` the ability to perform actions requiring `_role` on `_app`\n', '    * @param _entity Address of the whitelisted entity to revoke access from\n', '    * @param _app Address of the app in which the role will be revoked\n', '    * @param _role Identifier for the group of actions in app being revoked\n', '    */\n', '    function revokePermission(address _entity, address _app, bytes32 _role)\n', '        external\n', '        onlyPermissionManager(_app, _role)\n', '    {\n', '        _setPermission(_entity, _app, _role, NO_PERMISSION);\n', '    }\n', '\n', '    /**\n', '    * @notice Set `_newManager` as the manager of `_role` in `_app`\n', '    * @param _newManager Address for the new manager\n', '    * @param _app Address of the app in which the permission management is being transferred\n', '    * @param _role Identifier for the group of actions being transferred\n', '    */\n', '    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n', '        external\n', '        onlyPermissionManager(_app, _role)\n', '    {\n', '        _setPermissionManager(_newManager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @notice Remove the manager of `_role` in `_app`\n', '    * @param _app Address of the app in which the permission is being unmanaged\n', '    * @param _role Identifier for the group of actions being unmanaged\n', '    */\n', '    function removePermissionManager(address _app, bytes32 _role)\n', '        external\n', '        onlyPermissionManager(_app, _role)\n', '    {\n', '        _setPermissionManager(address(0), _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @notice Burn non-existent `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\n', '    * @param _app Address of the app in which the permission is being burned\n', '    * @param _role Identifier for the group of actions being burned\n', '    */\n', '    function createBurnedPermission(address _app, bytes32 _role)\n', '        external\n', '        auth(CREATE_PERMISSIONS_ROLE)\n', '        noPermissionManager(_app, _role)\n', '    {\n', '        _setPermissionManager(BURN_ENTITY, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @notice Burn `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\n', '    * @param _app Address of the app in which the permission is being burned\n', '    * @param _role Identifier for the group of actions being burned\n', '    */\n', '    function burnPermissionManager(address _app, bytes32 _role)\n', '        external\n', '        onlyPermissionManager(_app, _role)\n', '    {\n', '        _setPermissionManager(BURN_ENTITY, _app, _role);\n', '    }\n', '\n', '    /**\n', '     * @notice Get parameters for permission array length\n', '     * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '     * @param _app Address of the app\n', '     * @param _role Identifier for a group of actions in app\n', '     * @return Length of the array\n', '     */\n', '    function getPermissionParamsLength(address _entity, address _app, bytes32 _role) external view returns (uint) {\n', '        return permissionParams[permissions[permissionHash(_entity, _app, _role)]].length;\n', '    }\n', '\n', '    /**\n', '    * @notice Get parameter for permission\n', '    * @param _entity Address of the whitelisted entity that will be able to perform the role\n', '    * @param _app Address of the app\n', '    * @param _role Identifier for a group of actions in app\n', '    * @param _index Index of parameter in the array\n', '    * @return Parameter (id, op, value)\n', '    */\n', '    function getPermissionParam(address _entity, address _app, bytes32 _role, uint _index)\n', '        external\n', '        view\n', '        returns (uint8, uint8, uint240)\n', '    {\n', '        Param storage param = permissionParams[permissions[permissionHash(_entity, _app, _role)]][_index];\n', '        return (param.id, param.op, param.value);\n', '    }\n', '\n', '    /**\n', '    * @dev Get manager for permission\n', '    * @param _app Address of the app\n', '    * @param _role Identifier for a group of actions in app\n', '    * @return address of the manager for the permission\n', '    */\n', '    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n', '        return permissionManager[roleHash(_app, _role)];\n', '    }\n', '\n', '    /**\n', '    * @dev Function called by apps to check ACL on kernel or to check permission statu\n', '    * @param _who Sender of the original call\n', '    * @param _where Address of the app\n', '    * @param _where Identifier for a group of actions in app\n', '    * @param _how Permission parameters\n', '    * @return boolean indicating whether the ACL allows the role or not\n', '    */\n', '    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n', '        return hasPermission(_who, _where, _what, ConversionHelpers.dangerouslyCastBytesToUintArray(_how));\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n', '        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n', '        if (whoParams != NO_PERMISSION && evalParams(whoParams, _who, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n', '        if (anyParams != NO_PERMISSION && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n', '        uint256[] memory empty = new uint256[](0);\n', '        return hasPermission(_who, _where, _what, empty);\n', '    }\n', '\n', '    function evalParams(\n', '        bytes32 _paramsHash,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) public view returns (bool)\n', '    {\n', '        if (_paramsHash == EMPTY_PARAM_HASH) {\n', '            return true;\n', '        }\n', '\n', '        return _evalParam(_paramsHash, 0, _who, _where, _what, _how);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal createPermission for access inside the kernel (on instantiation)\n', '    */\n', '    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n', '        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n', '        _setPermissionManager(_manager, _app, _role);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function called to actually save the permission\n', '    */\n', '    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n', '        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n', '        bool entityHasPermission = _paramsHash != NO_PERMISSION;\n', '        bool permissionHasParams = entityHasPermission && _paramsHash != EMPTY_PARAM_HASH;\n', '\n', '        emit SetPermission(_entity, _app, _role, entityHasPermission);\n', '        if (permissionHasParams) {\n', '            emit SetPermissionParams(_entity, _app, _role, _paramsHash);\n', '        }\n', '    }\n', '\n', '    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n', '        bytes32 paramHash = keccak256(abi.encodePacked(_encodedParams));\n', '        Param[] storage params = permissionParams[paramHash];\n', '\n', '        if (params.length == 0) { // params not saved before\n', '            for (uint256 i = 0; i < _encodedParams.length; i++) {\n', '                uint256 encodedParam = _encodedParams[i];\n', '                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n', '                params.push(param);\n', '            }\n', '        }\n', '\n', '        return paramHash;\n', '    }\n', '\n', '    function _evalParam(\n', '        bytes32 _paramsHash,\n', '        uint32 _paramId,\n', '        address _who,\n', '        address _where,\n', '        bytes32 _what,\n', '        uint256[] _how\n', '    ) internal view returns (bool)\n', '    {\n', '        if (_paramId >= permissionParams[_paramsHash].length) {\n', '            return false; // out of bounds\n', '        }\n', '\n', '        Param memory param = permissionParams[_paramsHash][_paramId];\n', '\n', '        if (param.id == LOGIC_OP_PARAM_ID) {\n', '            return _evalLogic(param, _paramsHash, _who, _where, _what, _how);\n', '        }\n', '\n', '        uint256 value;\n', '        uint256 comparedTo = uint256(param.value);\n', '\n', '        // get value\n', '        if (param.id == ORACLE_PARAM_ID) {\n', '            value = checkOracle(IACLOracle(param.value), _who, _where, _what, _how) ? 1 : 0;\n', '            comparedTo = 1;\n', '        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n', '            value = getBlockNumber();\n', '        } else if (param.id == TIMESTAMP_PARAM_ID) {\n', '            value = getTimestamp();\n', '        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n', '            value = uint256(param.value);\n', '        } else {\n', '            if (param.id >= _how.length) {\n', '                return false;\n', '            }\n', '            value = uint256(uint240(_how[param.id])); // force lost precision\n', '        }\n', '\n', '        if (Op(param.op) == Op.RET) {\n', '            return uint256(value) > 0;\n', '        }\n', '\n', '        return compare(value, Op(param.op), comparedTo);\n', '    }\n', '\n', '    function _evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (Op(_param.op) == Op.IF_ELSE) {\n', '            uint32 conditionParam;\n', '            uint32 successParam;\n', '            uint32 failureParam;\n', '\n', '            (conditionParam, successParam, failureParam) = decodeParamsList(uint256(_param.value));\n', '            bool result = _evalParam(_paramsHash, conditionParam, _who, _where, _what, _how);\n', '\n', '            return _evalParam(_paramsHash, result ? successParam : failureParam, _who, _where, _what, _how);\n', '        }\n', '\n', '        uint32 param1;\n', '        uint32 param2;\n', '\n', '        (param1, param2,) = decodeParamsList(uint256(_param.value));\n', '        bool r1 = _evalParam(_paramsHash, param1, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.NOT) {\n', '            return !r1;\n', '        }\n', '\n', '        if (r1 && Op(_param.op) == Op.OR) {\n', '            return true;\n', '        }\n', '\n', '        if (!r1 && Op(_param.op) == Op.AND) {\n', '            return false;\n', '        }\n', '\n', '        bool r2 = _evalParam(_paramsHash, param2, _who, _where, _what, _how);\n', '\n', '        if (Op(_param.op) == Op.XOR) {\n', '            return r1 != r2;\n', '        }\n', '\n', '        return r2; // both or and and depend on result of r2 after checks\n', '    }\n', '\n', '    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n', '        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n', '        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n', '        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n', '        return false;\n', '    }\n', '\n', '    function checkOracle(IACLOracle _oracleAddr, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n', '        bytes4 sig = _oracleAddr.canPerform.selector;\n', '\n', '        // a raw call is required so we can return false if the call reverts, rather than reverting\n', '        bytes memory checkCalldata = abi.encodeWithSelector(sig, _who, _where, _what, _how);\n', '        uint256 oracleCheckGas = ORACLE_CHECK_GAS;\n', '\n', '        bool ok;\n', '        assembly {\n', '            ok := staticcall(oracleCheckGas, _oracleAddr, add(checkCalldata, 0x20), mload(checkCalldata), 0, 0)\n', '        }\n', '\n', '        if (!ok) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly { size := returndatasize }\n', '        if (size != 32) {\n', '            return false;\n', '        }\n', '\n', '        bool result;\n', '        assembly {\n', '            let ptr := mload(0x40)       // get next free memory ptr\n', '            returndatacopy(ptr, 0, size) // copy return from above `staticcall`\n', '            result := mload(ptr)         // read data at ptr and set it to result\n', '            mstore(ptr, 0)               // set pointer memory to 0 so it still is the next free ptr\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function that sets management\n', '    */\n', '    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n', '        permissionManager[roleHash(_app, _role)] = _newManager;\n', '        emit ChangePermissionManager(_app, _role, _newManager);\n', '    }\n', '\n', '    function roleHash(address _where, bytes32 _what) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("ROLE", _where, _what));\n', '    }\n', '\n', '    function permissionHash(address _who, address _where, bytes32 _what) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("PERMISSION", _who, _where, _what));\n', '    }\n', '}\n', '\n', '// File: contracts/evmscript/ScriptHelpers.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'library ScriptHelpers {\n', '    function getSpecId(bytes _script) internal pure returns (uint32) {\n', '        return uint32At(_script, 0);\n', '    }\n', '\n', '    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := mload(add(_data, add(0x20, _location)))\n', '        }\n', '    }\n', '\n', '    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n', '            0x1000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n', '        uint256 word = uint256At(_data, _location);\n', '\n', '        assembly {\n', '            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n', '            0x100000000000000000000000000000000000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n', '        assembly {\n', '            result := add(_data, add(0x20, _location))\n', '        }\n', '    }\n', '\n', '    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n', '        bytes memory payload = new bytes(4);\n', '        assembly { mstore(add(payload, 0x20), _sig) }\n', '        return payload;\n', '    }\n', '}\n', '\n', '// File: contracts/evmscript/EVMScriptRegistry.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/* solium-disable function-order */\n', '// Allow public initialize() to be first\n', 'contract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\n', '    using ScriptHelpers for bytes;\n', '\n', '    /* Hardcoded constants to save gas\n', '    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = keccak256("REGISTRY_ADD_EXECUTOR_ROLE");\n', '    bytes32 public constant REGISTRY_MANAGER_ROLE = keccak256("REGISTRY_MANAGER_ROLE");\n', '    */\n', '    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = 0xc4e90f38eea8c4212a009ca7b8947943ba4d4a58d19b683417f65291d1cd9ed2;\n', '    // WARN: Manager can censor all votes and the like happening in an org\n', '    bytes32 public constant REGISTRY_MANAGER_ROLE = 0xf7a450ef335e1892cb42c8ca72e7242359d7711924b75db5717410da3f614aa3;\n', '\n', '    uint256 internal constant SCRIPT_START_LOCATION = 4;\n', '\n', '    string private constant ERROR_INEXISTENT_EXECUTOR = "EVMREG_INEXISTENT_EXECUTOR";\n', '    string private constant ERROR_EXECUTOR_ENABLED = "EVMREG_EXECUTOR_ENABLED";\n', '    string private constant ERROR_EXECUTOR_DISABLED = "EVMREG_EXECUTOR_DISABLED";\n', '    string private constant ERROR_SCRIPT_LENGTH_TOO_SHORT = "EVMREG_SCRIPT_LENGTH_TOO_SHORT";\n', '\n', '    struct ExecutorEntry {\n', '        IEVMScriptExecutor executor;\n', '        bool enabled;\n', '    }\n', '\n', '    uint256 private executorsNextIndex;\n', '    mapping (uint256 => ExecutorEntry) public executors;\n', '\n', '    event EnableExecutor(uint256 indexed executorId, address indexed executorAddress);\n', '    event DisableExecutor(uint256 indexed executorId, address indexed executorAddress);\n', '\n', '    modifier executorExists(uint256 _executorId) {\n', '        require(_executorId > 0 && _executorId < executorsNextIndex, ERROR_INEXISTENT_EXECUTOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Initialize the registry\n', '    */\n', '    function initialize() public onlyInit {\n', '        initialized();\n', '        // Create empty record to begin executor IDs at 1\n', '        executorsNextIndex = 1;\n', '    }\n', '\n', '    /**\n', '    * @notice Add a new script executor with address `_executor` to the registry\n', '    * @param _executor Address of the IEVMScriptExecutor that will be added to the registry\n', '    * @return id Identifier of the executor in the registry\n', '    */\n', '    function addScriptExecutor(IEVMScriptExecutor _executor) external auth(REGISTRY_ADD_EXECUTOR_ROLE) returns (uint256 id) {\n', '        uint256 executorId = executorsNextIndex++;\n', '        executors[executorId] = ExecutorEntry(_executor, true);\n', '        emit EnableExecutor(executorId, _executor);\n', '        return executorId;\n', '    }\n', '\n', '    /**\n', '    * @notice Disable script executor with ID `_executorId`\n', '    * @param _executorId Identifier of the executor in the registry\n', '    */\n', '    function disableScriptExecutor(uint256 _executorId)\n', '        external\n', '        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\n', '    {\n', "        // Note that we don't need to check for an executor's existence in this case, as only\n", '        // existing executors can be enabled\n', '        ExecutorEntry storage executorEntry = executors[_executorId];\n', '        require(executorEntry.enabled, ERROR_EXECUTOR_DISABLED);\n', '        executorEntry.enabled = false;\n', '        emit DisableExecutor(_executorId, executorEntry.executor);\n', '    }\n', '\n', '    /**\n', '    * @notice Enable script executor with ID `_executorId`\n', '    * @param _executorId Identifier of the executor in the registry\n', '    */\n', '    function enableScriptExecutor(uint256 _executorId)\n', '        external\n', '        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\n', '        executorExists(_executorId)\n', '    {\n', '        ExecutorEntry storage executorEntry = executors[_executorId];\n', '        require(!executorEntry.enabled, ERROR_EXECUTOR_ENABLED);\n', '        executorEntry.enabled = true;\n', '        emit EnableExecutor(_executorId, executorEntry.executor);\n', '    }\n', '\n', '    /**\n', '    * @dev Get the script executor that can execute a particular script based on its first 4 bytes\n', '    * @param _script EVMScript being inspected\n', '    */\n', '    function getScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n', '        require(_script.length >= SCRIPT_START_LOCATION, ERROR_SCRIPT_LENGTH_TOO_SHORT);\n', '        uint256 id = _script.getSpecId();\n', '\n', "        // Note that we don't need to check for an executor's existence in this case, as only\n", '        // existing executors can be enabled\n', '        ExecutorEntry storage entry = executors[id];\n', '        return entry.enabled ? entry.executor : IEVMScriptExecutor(0);\n', '    }\n', '}\n', '\n', '// File: contracts/evmscript/executors/BaseEVMScriptExecutor.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', 'contract BaseEVMScriptExecutor is IEVMScriptExecutor, Autopetrified {\n', '    uint256 internal constant SCRIPT_START_LOCATION = 4;\n', '}\n', '\n', '// File: contracts/evmscript/executors/CallsScript.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '// Inspired by https://github.com/reverendus/tx-manager\n', '\n', '\n', '\n', '\n', 'contract CallsScript is BaseEVMScriptExecutor {\n', '    using ScriptHelpers for bytes;\n', '\n', '    /* Hardcoded constants to save gas\n', '    bytes32 internal constant EXECUTOR_TYPE = keccak256("CALLS_SCRIPT");\n', '    */\n', '    bytes32 internal constant EXECUTOR_TYPE = 0x2dc858a00f3e417be1394b87c07158e989ec681ce8cc68a9093680ac1a870302;\n', '\n', '    string private constant ERROR_BLACKLISTED_CALL = "EVMCALLS_BLACKLISTED_CALL";\n', '    string private constant ERROR_INVALID_LENGTH = "EVMCALLS_INVALID_LENGTH";\n', '\n', '    /* This is manually crafted in assembly\n', '    string private constant ERROR_CALL_REVERTED = "EVMCALLS_CALL_REVERTED";\n', '    */\n', '\n', '    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\n', '\n', '    /**\n', '    * @notice Executes a number of call scripts\n', '    * @param _script [ specId (uint32) ] many calls with this structure ->\n', '    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\n', '    * @param _blacklist Addresses the script cannot call to, or will revert.\n', '    * @return Always returns empty byte array\n', '    */\n', '    function execScript(bytes _script, bytes, address[] _blacklist) external isInitialized returns (bytes) {\n', '        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\n', '        while (location < _script.length) {\n', "            // Check there's at least address + calldataLength available\n", '            require(_script.length - location >= 0x18, ERROR_INVALID_LENGTH);\n', '\n', '            address contractAddress = _script.addressAt(location);\n', '            // Check address being called is not blacklist\n', '            for (uint256 i = 0; i < _blacklist.length; i++) {\n', '                require(contractAddress != _blacklist[i], ERROR_BLACKLISTED_CALL);\n', '            }\n', '\n', '            // logged before execution to ensure event ordering in receipt\n', '            // if failed entire execution is reverted regardless\n', '            emit LogScriptCall(msg.sender, address(this), contractAddress);\n', '\n', '            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\n', '            uint256 startOffset = location + 0x14 + 0x04;\n', '            uint256 calldataStart = _script.locationOf(startOffset);\n', '\n', '            // compute end of script / next location\n', '            location = startOffset + calldataLength;\n', '            require(location <= _script.length, ERROR_INVALID_LENGTH);\n', '\n', '            bool success;\n', '            assembly {\n', '                success := call(\n', '                    sub(gas, 5000),       // forward gas left - 5000\n', '                    contractAddress,      // address\n', '                    0,                    // no value\n', '                    calldataStart,        // calldata start\n', '                    calldataLength,       // calldata length\n', "                    0,                    // don't write output\n", "                    0                     // don't write output\n", '                )\n', '\n', '                switch success\n', '                case 0 {\n', '                    let ptr := mload(0x40)\n', '\n', '                    switch returndatasize\n', '                    case 0 {\n', '                        // No error data was returned, revert with "EVMCALLS_CALL_REVERTED"\n', '                        // See remix: doing a `revert("EVMCALLS_CALL_REVERTED")` always results in\n', '                        // this memory layout\n', '                        mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n', '                        mstore(add(ptr, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n', '                        mstore(add(ptr, 0x24), 0x0000000000000000000000000000000000000000000000000000000000000016) // reason length\n', '                        mstore(add(ptr, 0x44), 0x45564d43414c4c535f43414c4c5f524556455254454400000000000000000000) // reason\n', '\n', '                        revert(ptr, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n', '                    }\n', '                    default {\n', '                        // Forward the full error data\n', '                        returndatacopy(ptr, 0, returndatasize)\n', '                        revert(ptr, returndatasize)\n', '                    }\n', '                }\n', '                default { }\n', '            }\n', '        }\n', '        // No need to allocate empty bytes for the return as this can only be called via an delegatecall\n', '        // (due to the isInitialized modifier)\n', '    }\n', '\n', '    function executorType() external pure returns (bytes32) {\n', '        return EXECUTOR_TYPE;\n', '    }\n', '}\n', '\n', '// File: contracts/factory/EVMScriptRegistryFactory.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract EVMScriptRegistryFactory is EVMScriptRegistryConstants {\n', '    EVMScriptRegistry public baseReg;\n', '    IEVMScriptExecutor public baseCallScript;\n', '\n', '    /**\n', '    * @notice Create a new EVMScriptRegistryFactory.\n', '    */\n', '    constructor() public {\n', '        baseReg = new EVMScriptRegistry();\n', '        baseCallScript = IEVMScriptExecutor(new CallsScript());\n', '    }\n', '\n', '    /**\n', '    * @notice Install a new pinned instance of EVMScriptRegistry on `_dao`.\n', '    * @param _dao Kernel\n', '    * @return Installed EVMScriptRegistry\n', '    */\n', '    function newEVMScriptRegistry(Kernel _dao) public returns (EVMScriptRegistry reg) {\n', '        bytes memory initPayload = abi.encodeWithSelector(reg.initialize.selector);\n', '        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg, initPayload, true));\n', '\n', '        ACL acl = ACL(_dao.acl());\n', '\n', '        acl.createPermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE(), this);\n', '\n', '        reg.addScriptExecutor(baseCallScript);     // spec 1 = CallsScript\n', '\n', '        // Clean up the permissions\n', '        acl.revokePermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\n', '        acl.removePermissionManager(reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\n', '\n', '        return reg;\n', '    }\n', '}\n', '\n', '// File: contracts/factory/DAOFactory.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract DAOFactory {\n', '    IKernel public baseKernel;\n', '    IACL public baseACL;\n', '    EVMScriptRegistryFactory public regFactory;\n', '\n', '    event DeployDAO(address dao);\n', '    event DeployEVMScriptRegistry(address reg);\n', '\n', '    /**\n', '    * @notice Create a new DAOFactory, creating DAOs with Kernels proxied to `_baseKernel`, ACLs proxied to `_baseACL`, and new EVMScriptRegistries created from `_regFactory`.\n', '    * @param _baseKernel Base Kernel\n', '    * @param _baseACL Base ACL\n', '    * @param _regFactory EVMScriptRegistry factory\n', '    */\n', '    constructor(IKernel _baseKernel, IACL _baseACL, EVMScriptRegistryFactory _regFactory) public {\n', '        // No need to init as it cannot be killed by devops199\n', '        if (address(_regFactory) != address(0)) {\n', '            regFactory = _regFactory;\n', '        }\n', '\n', '        baseKernel = _baseKernel;\n', '        baseACL = _baseACL;\n', '    }\n', '\n', '    /**\n', '    * @notice Create a new DAO with `_root` set as the initial admin\n', '    * @param _root Address that will be granted control to setup DAO permissions\n', '    * @return Newly created DAO\n', '    */\n', '    function newDAO(address _root) public returns (Kernel) {\n', '        Kernel dao = Kernel(new KernelProxy(baseKernel));\n', '\n', '        if (address(regFactory) == address(0)) {\n', '            dao.initialize(baseACL, _root);\n', '        } else {\n', '            dao.initialize(baseACL, this);\n', '\n', '            ACL acl = ACL(dao.acl());\n', '            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n', '            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\n', '\n', '            acl.grantPermission(regFactory, acl, permRole);\n', '\n', '            acl.createPermission(regFactory, dao, appManagerRole, this);\n', '\n', '            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao);\n', '            emit DeployEVMScriptRegistry(address(reg));\n', '\n', '            // Clean up permissions\n', '            // First, completely reset the APP_MANAGER_ROLE\n', '            acl.revokePermission(regFactory, dao, appManagerRole);\n', '            acl.removePermissionManager(dao, appManagerRole);\n', '\n', '            // Then, make root the only holder and manager of CREATE_PERMISSIONS_ROLE\n', '            acl.revokePermission(regFactory, acl, permRole);\n', '            acl.revokePermission(this, acl, permRole);\n', '            acl.grantPermission(_root, acl, permRole);\n', '            acl.setPermissionManager(_root, acl, permRole);\n', '        }\n', '\n', '        emit DeployDAO(address(dao));\n', '\n', '        return dao;\n', '    }\n', '}']