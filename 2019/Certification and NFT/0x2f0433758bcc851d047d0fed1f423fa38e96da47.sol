['pragma solidity ^0.5.5;\n', '\n', '//WLC VERSION 10\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'interface ERC721 {\n', '    // Required methods\n', '    function totalSupply() external view returns (uint256 total);\n', '    \n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function exists(uint256 _tokenId) external view returns (bool _exists);\n', '    \n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    // Optional\n', '    function tokensOfOwner(address _owner) external view returns (uint256[] memory tokenIds);\n', '    \n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721 {\n', '  function name() external view returns (string memory _name);\n', '  function symbol() external view returns (string memory _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string memory);\n', '}\n', '\n', 'contract DreamCarToken {\n', '    function getWLCReward(uint256 _boughtWLCAmount, address _owner) public returns (uint256 remaining) {}\n', '    \n', '    function getForWLC(address _owner) public {}\n', '}\n', '\n', 'contract WishListToken is ERC721, ERC721Metadata {\n', "    string internal constant tokenName   = 'WishListCoin';\n", "    string internal constant tokenSymbol = 'WLC';\n", '    \n', '    uint256 public constant decimals = 0;\n', '    \n', '    //ERC721 VARIABLES\n', '    \n', '    //the total count of wishes\n', '    uint256 public totalTokenSupply;\n', '    \n', '    //this address is the CEO\n', '    address payable public CEO;\n', '    \n', '    bytes4 constant InterfaceSignature_ERC165 =\n', "        bytes4(keccak256('supportsInterface(bytes4)'));\n", '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', "        bytes4(keccak256('name()')) ^\n", "        bytes4(keccak256('symbol()')) ^\n", "        bytes4(keccak256('totalSupply()')) ^\n", "        bytes4(keccak256('balanceOf(address)')) ^\n", "        bytes4(keccak256('ownerOf(uint256)')) ^\n", "        bytes4(keccak256('approve(address,uint256)')) ^\n", "        bytes4(keccak256('transfer(address,uint256)')) ^\n", "        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "        bytes4(keccak256('tokensOfOwner(address)')) ^\n", "        bytes4(keccak256('tokenMetadata(uint256,string)'));\n", '    \n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) internal tokenOwner;\n', '    \n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) internal ownedTokensIndex;\n', '    \n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) internal tokenURIs;\n', '    \n', '    //TOKEN SPECIFIC VARIABLES\n', '    \n', '    // Mapping from owner to ids of owned tokens\n', '    mapping (address => uint256[]) internal tokensOwnedBy;\n', '    \n', '    // Mapping from owner to ids of exchanged tokens\n', '    mapping (address => uint256[]) internal tokensExchangedBy;\n', '    \n', '    //Token price in WEI\n', '    uint256 public tokenPrice;\n', '    \n', '    //A list of price admins; they can change price, in addition to the CEO\n', '    address[] public priceAdmins;\n', '    \n', '    //Next id that will be assigned to token\n', '    uint256 internal nextTokenId = 1;\n', '    \n', '    //DCC INTERACTION VARIABLES\n', '    \n', '    //A list, containing the addresses of DreamCarToken contracts, which will be used to award bonus tokens,\n', '    //when an user purchases a large number of WLC tokens\n', '    DreamCarToken[] public dreamCarCoinContracts;\n', '    \n', '    //A DreamCarToken contract address, which will be used to allow the excange of WLC tokens for DCC tokens\n', '    DreamCarToken public dreamCarCoinExchanger;\n', '    \n', '    //ERC721 FUNCTIONS IMPLEMENTATIONS\n', '    \n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '    \n', '    /**\n', '     * Gets the total amount of tokens stored by the contract\n', '     * @return uint256 representing the total amount of tokens\n', '     */\n', '    function totalSupply() public view returns (uint256 total) {\n', '        return totalTokenSupply;\n', '    }\n', '    \n', '    /**\n', '     * Gets the balance of the specified address\n', '     * @param _owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256 _balance) {\n', '        return tokensOwnedBy[_owner].length;\n', '    }\n', '    \n', '    /**\n', '     * Gets the owner of the specified token ID\n', '     * @param _tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\n', '        return tokenOwner[_tokenId];\n', '    }\n', '    \n', '    /**\n', '     * Returns whether the specified token exists\n', '     * @param _tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function exists(uint256 _tokenId) public view returns (bool) {\n', '        address owner = tokenOwner[_tokenId];\n', '        return owner != address(0);\n', '    }\n', '    \n', '    /**\n', '     * Returns a list of the tokens ids, owned by the passed address\n', '     * @param _owner address the address to chesck\n', '     * @return the list of token ids\n', '     */\n', '    function tokensOfOwner(address _owner) external view returns (uint256[] memory tokenIds) {\n', '        return tokensOwnedBy[_owner];\n', '    }\n', '    \n', '    /**\n', '     * Transfers the specified token to the specified address\n', '     * @param _to address the receiver\n', '     * @param _tokenId uint256 the id of the token\n', '     */\n', '    function transfer(address _to, uint256 _tokenId) external {\n', '        require(_to != address(0));\n', '        \n', '        ensureAddressIsTokenOwner(msg.sender, _tokenId);\n', '        \n', '        //swap token for the last one in the list\n', '        tokensOwnedBy[msg.sender][ownedTokensIndex[_tokenId]] = tokensOwnedBy[msg.sender][tokensOwnedBy[msg.sender].length - 1];\n', '        \n', '        //record the changed position of the last element\n', '        ownedTokensIndex[tokensOwnedBy[msg.sender][tokensOwnedBy[msg.sender].length - 1]] = ownedTokensIndex[_tokenId];\n', '        \n', '        //remove last element of the list\n', '        tokensOwnedBy[msg.sender].pop();\n', '        \n', '        //delete tokensOwnedBy[msg.sender][ownedTokensIndex[_tokenId]];\n', '        tokensOwnedBy[_to].push(_tokenId);\n', '        \n', '        tokenOwner[_tokenId] = _to;\n', '        ownedTokensIndex[_tokenId] = tokensOwnedBy[_to].length - 1;\n', '        \n', '        emit Transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    /**\n', '     * Not necessary in the contract\n', '     */\n', '    function approve(address _to, uint256 _tokenId) external { }\n', '    \n', '    /**\n', '     * Not necessary in the contract\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external { }\n', '    \n', '    /**\n', '     * Internal function to set the token URI for a given token\n', '     * Reverts if the token ID does not exist\n', '     * @param _tokenId uint256 ID of the token to set its URI\n', '     * @param _uri string URI to assign\n', '     */\n', '    function _setTokenURI(uint256 _tokenId, string storage _uri) internal {\n', '        require(exists(_tokenId));\n', '        tokenURIs[_tokenId] = _uri;\n', '    }\n', '    \n', '    //ERC721Metadata FUNCTIONS IMPLEMENTATIONS\n', '    /**\n', '     * Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string memory _name) {\n', '        return tokenName;\n', '    }\n', '    \n', '    /**\n', '     * Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string memory _symbol) {\n', '        return tokenSymbol;\n', '    }\n', '    \n', '    /**\n', '     * Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param _tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 _tokenId) public view returns (string memory) {\n', '        require(exists(_tokenId));\n', '        return tokenURIs[_tokenId];\n', '    }\n', '    \n', '    //TOKEN SPECIFIC FUNCTIONS\n', '    \n', '    event Buy(address indexed from, uint256 amount, uint256 fromTokenId, uint256 toTokenId, uint256 timestamp);\n', '    \n', '    event Exchange(address indexed from, uint256 tokenId);\n', '    \n', '    event ExchangeForDCC(address indexed from, uint256 tokenId);\n', '    \n', '    /**\n', '     * Ensures that the caller of the function is the CEO of contract\n', '     */\n', '    modifier onlyCEO {\n', "        require(msg.sender == CEO, 'You need to be the CEO to do that!');\n", '        _;\n', '    }\n', '    \n', '    /**\n', '     * Constructor of the contract\n', '     * @param _ceo address the CEO (owner) of the contract\n', '     */\n', '    constructor (address payable _ceo) public {\n', '        CEO = _ceo;\n', '        \n', '        totalTokenSupply = 1001000;\n', '        \n', '        tokenPrice = 3067484662576687; // (if eth = 163USD, 0.5 USD for token)\n', '    }\n', '\n', '    /**\n', '     * Gets an array of all tokens ids, exchanged by the specified address\n', '     * @param _owner address The excanger of the tokens\n', '     * @return uint256[] The list of exchanged tokens ids\n', '     */\n', '    function exchangedBy(address _owner) external view returns (uint256[] memory tokenIds) {\n', '        return tokensExchangedBy[_owner];\n', '    }\n', '    \n', '    /**\n', '     * Gets the last existing token ids\n', '     * @return uint256 the id of the token\n', '     */\n', '    function lastTokenId() public view returns (uint256 tokenId) {\n', '        return nextTokenId - 1;\n', '    }\n', '    \n', '    /**\n', '     * Sets a new price for the tokensExchangedBy\n', '     * @param _newPrice uint256 the new price in WEI\n', '     */\n', '    function setTokenPriceInWEI(uint256 _newPrice) public {\n', '        bool transactionAllowed = false;\n', '        \n', '        if (msg.sender == CEO) {\n', '            transactionAllowed = true;\n', '        } else {\n', '            for (uint256 i = 0; i < priceAdmins.length; i++) {\n', '                if (msg.sender == priceAdmins[i]) {\n', '                    transactionAllowed = true;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        \n', "        require((transactionAllowed == true), 'You cannot do that!');\n", '        tokenPrice = _newPrice;\n', '    }\n', '    \n', '    /**\n', '     * Add a new price admin address to the list\n', '     * @param _newPriceAdmin address the address of the new price admin\n', '     */\n', '    function addPriceAdmin(address _newPriceAdmin) onlyCEO public {\n', '        priceAdmins.push(_newPriceAdmin);\n', '    }\n', '    \n', '    /**\n', '     * Remove existing price admin address from the list\n', '     * @param _existingPriceAdmin address the address of the existing price admin\n', '     */\n', '    function removePriceAdmin(address _existingPriceAdmin) onlyCEO public {\n', '        for (uint256 i = 0; i < priceAdmins.length; i++) {\n', '            if (_existingPriceAdmin == priceAdmins[i]) {\n', '                delete priceAdmins[i];\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Adds the specified number of tokens to the specified address\n', '     * Internal method, used when creating new tokens\n', '     * @param _to address The address, which is going to own the tokens\n', '     * @param _amount uint256 The number of tokens\n', '     */\n', '    function _addTokensToAddress(address _to, uint256 _amount) internal {\n', '        for (uint256 i = 0; i < _amount; i++) {\n', '            tokensOwnedBy[_to].push(nextTokenId + i);\n', '            tokenOwner[nextTokenId + i] = _to;\n', '            ownedTokensIndex[nextTokenId + i] = tokensOwnedBy[_to].length - 1;\n', '        }\n', '        \n', '        nextTokenId += _amount;\n', '    }\n', '    \n', '    /**\n', '     * Checks if the specified token is owned by the transaction sender\n', '     */\n', '    function ensureAddressIsTokenOwner(address _owner, uint256 _tokenId) internal view {\n', "        require(balanceOf(_owner) >= 1, 'You do not own any tokens!');\n", '        \n', "        require(tokenOwner[_tokenId] == _owner, 'You do not own this token!');\n", '    }\n', '    \n', '    /**\n', '     * Scales the amount of tokens in a purchase, to ensure it will be less or equal to the amount of unsold tokens\n', '     * If there are no tokens left, it will return 0\n', '     * @param _amount uint256 the amout of tokens in the purchase attempt\n', '     * @return _exactAmount uint256\n', '     */\n', '    function scalePurchaseTokenAmountToMatchRemainingTokens(uint256 _amount) internal view returns (uint256 _exactAmount) {\n', '        if (nextTokenId + _amount - 1 > totalTokenSupply) {\n', '            _amount = totalTokenSupply - nextTokenId + 1;\n', '        }\n', '        \n', '        if (balanceOf(msg.sender) + _amount > 100) {\n', '            _amount = 100 - balanceOf(msg.sender);\n', '            require(_amount > 0, "You can own maximum of 100 tokens!");\n', '        }\n', '        \n', '        return _amount;\n', '    }\n', '    \n', '    /**\n', '    * Buy new tokens with ETH\n', '    * Calculates the nubmer of tokens for the given ETH amount\n', '    * Creates the new tokens when they are purchased\n', '    * Returns the excessive ETH (if any) to the transaction sender\n', '    */\n', '    function buy() payable public {\n', '        require(msg.value >= tokenPrice, "You did\'t send enough ETH");\n', '        \n', '        uint256 amount = scalePurchaseTokenAmountToMatchRemainingTokens(msg.value / tokenPrice);\n', '        \n', '        require(amount > 0, "Not enough tokens are available for purchase!");\n', '        \n', '        _addTokensToAddress(msg.sender, amount);\n', '        \n', '        emit Buy(msg.sender, amount, nextTokenId - amount, nextTokenId - 1, now);\n', '        \n', '        //transfer ETH to CEO\n', '        CEO.transfer((amount * tokenPrice));\n', '        \n', '        getDCCRewards(amount);\n', '        \n', '        //returns excessive ETH\n', '        msg.sender.transfer(msg.value - (amount * tokenPrice));\n', '    }\n', '    \n', '    /**\n', '     * Removes a token from the provided address ballance and puts it in the tokensExchangedBy mapping\n', '     * @param _owner address the address of the token owner\n', '     * @param _tokenId uint256 the id of the token\n', '     */\n', '    function exchangeToken(address _owner, uint256 _tokenId) internal {\n', '        ensureAddressIsTokenOwner(_owner, _tokenId);\n', '        \n', '        //swap token for the last one in the list\n', '        tokensOwnedBy[_owner][ownedTokensIndex[_tokenId]] = tokensOwnedBy[_owner][tokensOwnedBy[_owner].length - 1];\n', '        \n', '        //record the changed position of the last element\n', '        ownedTokensIndex[tokensOwnedBy[_owner][tokensOwnedBy[_owner].length - 1]] = ownedTokensIndex[_tokenId];\n', '        \n', '        //remove last element of the list\n', '        tokensOwnedBy[_owner].pop();\n', '        \n', '        ownedTokensIndex[_tokenId] = 0;\n', '        \n', '        delete tokenOwner[_tokenId];\n', '        \n', '        tokensExchangedBy[_owner].push(_tokenId);\n', '    }\n', '    \n', '    /**\n', '    * Allows user to destroy a specified token in order to claim his prize for the it\n', '    * @param _tokenId uint256 ID of the token\n', '    */\n', '    function exchange(uint256 _tokenId) public {\n', '        exchangeToken(msg.sender, _tokenId);\n', '        \n', '        emit Exchange(msg.sender, _tokenId);\n', '    }\n', '    \n', '    /**\n', '     * Allows the CEO to increase the totalTokenSupply\n', '     * @param _amount uint256 the number of tokens to create\n', '     */\n', '    function mint(uint256 _amount) onlyCEO public {\n', "        require (_amount > 0, 'Amount must be bigger than 0!');\n", '        totalTokenSupply += _amount;\n', '    }\n', '    \n', '    //DCC INTERACTION FUNCTIONS\n', '    \n', '    /**\n', '     * Adds a DreamCarToken contract address to the list on a specific position.\n', '     * This allows to maintain and control the order of DreamCarToken contracts, according to their bonus rates\n', '     * @param _index uint256 the index where the address will be inserted/overwritten\n', '     * @param _address address the address of the DreamCarToken contract\n', '     */\n', '    function setDreamCarCoinAddress(uint256 _index, address _address) public onlyCEO {\n', '        require (_address != address(0));\n', '        if (dreamCarCoinContracts.length > 0 && dreamCarCoinContracts.length - 1 >= _index) {\n', '            dreamCarCoinContracts[_index] = DreamCarToken(_address);\n', '        } else {\n', '            dreamCarCoinContracts.push(DreamCarToken(_address));\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Removes a DreamCarToken contract address from the list, by its list index\n', '     * @param _index uint256 the position of the address\n', '     */\n', '    function removeDreamCarCoinAddress(uint256 _index) public onlyCEO {\n', '        delete(dreamCarCoinContracts[_index]);\n', '    }\n', '    \n', '    /**\n', '     * Allows the CEO to set an address of DreamCarToken contract, which will be used to excanger\n', '     * WLCs for DCCs\n', '     * @param _address address the address of the DreamCarToken contract\n', '     */\n', '    function setDreamCarCoinExchanger(address _address) public onlyCEO {\n', '        require (_address != address(0));\n', '        dreamCarCoinExchanger = DreamCarToken(_address);\n', '    }\n', '    \n', '    /**\n', '     * Allows the CEO to remove the address of DreamCarToken contract, which will be used to excanger\n', '     * WLCs for DCCs\n', '     */\n', '    function removeDreamCarCoinExchanger() public onlyCEO {\n', '        dreamCarCoinExchanger = DreamCarToken(address(0));\n', '    }\n', '    \n', '    /**\n', '     * Allows the buyer of WLC coins to receive DCCs as bonus.\n', '     * Works when a DreamCarToken address is set in the dreamCarCoinContracts array.\n', '     * Loops through the array, starting from the smallest index, where the DreamCarToken, which requires\n', '     * the highest number of WLCs in a single purchase should be.\n', '     * Gets the remaining WLCs, after the bonus is payed and tries to get bonus from the other DreamCarToken contracts\n', '     * in the list\n', '     * @param _amount uint256 how many tokens was purchased by the buyer\n', '     */\n', '    function getDCCRewards(uint256 _amount) internal {\n', '        for (uint256 i = 0; i < dreamCarCoinContracts.length; i++) {\n', '            if (_amount > 0 && address(dreamCarCoinContracts[i]) != address(0)) {\n', '                _amount = dreamCarCoinContracts[i].getWLCReward(_amount, msg.sender);\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Allows a user to exchange any WLC coin token a DCC token\n', '     * @param _tokenId uint256 the id of the owned token\n', '     */\n', '    function exchangeForDCC(uint256 _tokenId) public {\n', '        require (address(dreamCarCoinExchanger) != address(0));\n', '        \n', '        dreamCarCoinExchanger.getForWLC(msg.sender);\n', '        \n', '        exchangeToken(msg.sender, _tokenId);\n', '        \n', '        emit ExchangeForDCC(msg.sender, _tokenId);\n', '    }\n', '}']