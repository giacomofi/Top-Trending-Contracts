['pragma solidity 0.4.24;\n', '\n', 'contract SelfAuthorized {\n', '    modifier authorized() {\n', '        require(msg.sender == address(this), "Method can only be called from this contract");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract ErrorUtils {\n', '\n', '    event LogError(string methodSig, string errMsg);\n', '    event LogErrorWithHintBytes32(bytes32 indexed bytes32Value, string methodSig, string errMsg);\n', '    event LogErrorWithHintAddress(address indexed addressValue, string methodSig, string errMsg);\n', '\n', '}\n', '\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event  Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event  Deposit(address indexed _owner, uint _value);\n', '    event  Withdrawal(address indexed _owner, uint _value);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() public payable {\n', '        deposit();\n', '    }\n', '\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract Utils {\n', '\n', '    modifier addressValid(address _address) {\n', '        require(_address != address(0), "Utils::_ INVALID_ADDRESS");\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n', '}\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "DSAuth::_ SENDER_NOT_AUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '\n', '    function name() external view returns(string);\n', '    function symbol() external view returns(string);\n', '    function decimals() external view returns(uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract MasterCopy is SelfAuthorized {\n', '  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n', '  // It should also always be ensured that the address is stored alone (uses a full word)\n', '    address masterCopy;\n', '\n', '  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\n', '  /// @param _masterCopy New contract address.\n', '    function changeMasterCopy(address _masterCopy)\n', '        public\n', '        authorized\n', '    {\n', '        // Master copy address cannot be null.\n', '        require(_masterCopy != 0, "Invalid master copy address provided");\n', '        masterCopy = _masterCopy;\n', '    }\n', '}\n', '\n', '\n', 'contract Config is DSNote, DSAuth, Utils {\n', '\n', '    WETH9 public weth9;\n', '    mapping (address => bool) public isAccountHandler;\n', '    mapping (address => bool) public isAdmin;\n', '    address[] public admins;\n', '    bool public disableAdminControl = false;\n', '    \n', '    event LogAdminAdded(address indexed _admin, address _by);\n', '    event LogAdminRemoved(address indexed _admin, address _by);\n', '\n', '    constructor() public {\n', '        admins.push(msg.sender);\n', '        isAdmin[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyAdmin(){\n', '        require(isAdmin[msg.sender], "Config::_ SENDER_NOT_AUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    function setWETH9\n', '    (\n', '        address _weth9\n', '    ) \n', '        public\n', '        auth\n', '        note\n', '        addressValid(_weth9) \n', '    {\n', '        weth9 = WETH9(_weth9);\n', '    }\n', '\n', '    function setAccountHandler\n', '    (\n', '        address _accountHandler,\n', '        bool _isAccountHandler\n', '    )\n', '        public\n', '        auth\n', '        note\n', '        addressValid(_accountHandler)\n', '    {\n', '        isAccountHandler[_accountHandler] = _isAccountHandler;\n', '    }\n', '\n', '    function toggleAdminsControl() \n', '        public\n', '        auth\n', '        note\n', '    {\n', '        disableAdminControl = !disableAdminControl;\n', '    }\n', '\n', '    function isAdminValid(address _admin)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        if(disableAdminControl) {\n', '            return true;\n', '        } else {\n', '            return isAdmin[_admin];\n', '        }\n', '    }\n', '\n', '    function getAllAdmins()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return admins;\n', '    }\n', '\n', '    function addAdmin\n', '    (\n', '        address _admin\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_admin)\n', '    {   \n', '        require(!isAdmin[_admin], "Config::addAdmin ADMIN_ALREADY_EXISTS");\n', '\n', '        admins.push(_admin);\n', '        isAdmin[_admin] = true;\n', '\n', '        emit LogAdminAdded(_admin, msg.sender);\n', '    }\n', '\n', '    function removeAdmin\n', '    (\n', '        address _admin\n', '    ) \n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_admin)\n', '    {   \n', '        require(isAdmin[_admin], "Config::removeAdmin ADMIN_DOES_NOT_EXIST");\n', '        require(msg.sender != _admin, "Config::removeAdmin ADMIN_NOT_AUTHORIZED");\n', '\n', '        isAdmin[_admin] = false;\n', '\n', '        for (uint i = 0; i < admins.length - 1; i++) {\n', '            if (admins[i] == _admin) {\n', '                admins[i] = admins[admins.length - 1];\n', '                admins.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '\n', '        emit LogAdminRemoved(_admin, msg.sender);\n', '    }\n', '}\n', '\n', '\n', '\n', 'library ECRecovery {\n', '\n', '    function recover(bytes32 _hash, bytes _sig)\n', '        internal\n', '        pure\n', '    returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (_sig.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        assembly {\n', '            r := mload(add(_sig, 32))\n', '            s := mload(add(_sig, 64))\n', '            v := byte(0, mload(add(_sig, 96)))\n', '        }\n', '\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            return ecrecover(_hash, v, r, s);\n', '        }\n', '    }\n', '\n', '    function toEthSignedMessageHash(bytes32 _hash)\n', '        internal\n', '        pure\n', '    returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)\n', '        );\n', '    }\n', '}\n', '\n', '\n', 'contract Utils2 {\n', '    using ECRecovery for bytes32;\n', '    \n', '    function _recoverSigner(bytes32 _hash, bytes _signature) \n', '        internal\n', '        pure\n', '        returns(address _signer)\n', '    {\n', '        return _hash.toEthSignedMessageHash().recover(_signature);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract Account is MasterCopy, DSNote, Utils, Utils2, ErrorUtils {\n', '\n', '    address[] public users;\n', '    mapping (address => bool) public isUser;\n', '    mapping (bytes32 => bool) public actionCompleted;\n', '\n', '    WETH9 public weth9;\n', '    Config public config;\n', '    bool public isInitialized = false;\n', '\n', '    event LogTransferBySystem(address indexed token, address indexed to, uint value, address by);\n', '    event LogTransferByUser(address indexed token, address indexed to, uint value, address by);\n', '    event LogUserAdded(address indexed user, address by);\n', '    event LogUserRemoved(address indexed user, address by);\n', '    event LogImplChanged(address indexed newImpl, address indexed oldImpl);\n', '\n', '    modifier initialized() {\n', '        require(isInitialized, "Account::_ ACCOUNT_NOT_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier notInitialized() {\n', '        require(!isInitialized, "Account::_ ACCOUNT_ALREADY_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier userExists(address _user) {\n', '        require(isUser[_user], "Account::_ INVALID_USER");\n', '        _;\n', '    }\n', '\n', '    modifier userDoesNotExist(address _user) {\n', '        require(!isUser[_user], "Account::_ USER_DOES_NOT_EXISTS");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(config.isAdminValid(msg.sender), "Account::_ INVALID_ADMIN_ACCOUNT");\n', '        _;\n', '    }\n', '\n', '    modifier onlyHandler(){\n', '        require(config.isAccountHandler(msg.sender), "Account::_ INVALID_ACC_HANDLER");\n', '        _;\n', '    }\n', '\n', '    function init(address _user, address _config)\n', '        public \n', '        notInitialized\n', '    {\n', '        users.push(_user);\n', '        isUser[_user] = true;\n', '        config = Config(_config);\n', '        weth9 = config.weth9();\n', '        isInitialized = true;\n', '    }\n', '    \n', '    function getAllUsers() public view returns (address[]) {\n', '        return users;\n', '    }\n', '\n', '    function balanceFor(address _token) public view returns (uint _balance){\n', '        _balance = ERC20(_token).balanceOf(this);\n', '    }\n', '    \n', '    function transferBySystem\n', '    (   \n', '        address _token,\n', '        address _to,\n', '        uint _value\n', '    ) \n', '        external \n', '        onlyHandler\n', '        note \n', '        initialized\n', '    {\n', '        require(ERC20(_token).balanceOf(this) >= _value, "Account::transferBySystem INSUFFICIENT_BALANCE_IN_ACCOUNT");\n', '        ERC20(_token).transfer(_to, _value);\n', '\n', '        emit LogTransferBySystem(_token, _to, _value, msg.sender);\n', '    }\n', '    \n', '    function transferByUser\n', '    (   \n', '        address _token,\n', '        address _to,\n', '        uint _value,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external\n', '        addressValid(_to)\n', '        note\n', '        initialized\n', '        onlyAdmin\n', '    {\n', '        bytes32 actionHash = _getTransferActionHash(_token, _to, _value, _salt);\n', '\n', '        if(actionCompleted[actionHash]) {\n', '            emit LogError("Account::transferByUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(_token).balanceOf(this) < _value){\n', '            emit LogError("Account::transferByUser", "INSUFFICIENT_BALANCE_IN_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::transferByUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '        \n', '        if (_token == address(weth9)) {\n', '            weth9.withdraw(_value);\n', '            _to.transfer(_value);\n', '        } else {\n', '            require(ERC20(_token).transfer(_to, _value), "Account::transferByUser TOKEN_TRANSFER_FAILED");\n', '        }\n', '\n', '        emit LogTransferByUser(_token, _to, _value, signer);\n', '    }\n', '\n', '    function addUser\n', '    (\n', '        address _user,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external \n', '        note \n', '        addressValid(_user)\n', '        userDoesNotExist(_user)\n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_user, "ADD_USER", _salt);\n', '        if(actionCompleted[actionHash])\n', '        {\n', '            emit LogError("Account::addUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::addUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '\n', '        users.push(_user);\n', '        isUser[_user] = true;\n', '\n', '        emit LogUserAdded(_user, signer);\n', '    }\n', '\n', '    function removeUser\n', '    (\n', '        address _user,\n', '        uint _salt,\n', '        bytes _signature\n', '    ) \n', '        external\n', '        note\n', '        userExists(_user) \n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_user, "REMOVE_USER", _salt);\n', '\n', '        if(actionCompleted[actionHash]) {\n', '            emit LogError("Account::removeUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '        \n', '        if(users.length == 1){\n', '            emit LogError("Account::removeUser",  "ACC_SHOULD_HAVE_ATLEAST_ONE_USER");\n', '            return;\n', '        }\n', '        \n', '        if(!isUser[signer]){\n', '            emit LogError("Account::removeUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '        \n', '        actionCompleted[actionHash] = true;\n', '\n', '        // should delete value from isUser map? delete isUser[_user]?\n', '        isUser[_user] = false;\n', '        for (uint i = 0; i < users.length - 1; i++) {\n', '            if (users[i] == _user) {\n', '                users[i] = users[users.length - 1];\n', '                users.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '\n', '        emit LogUserRemoved(_user, signer);\n', '    }\n', '\n', '    function _getTransferActionHash\n', '    ( \n', '        address _token,\n', '        address _to,\n', '        uint _value,\n', '        uint _salt\n', '    ) \n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _token,\n', '                _to,\n', '                _value,\n', '                _salt\n', '            )\n', '        );\n', '    }\n', '\n', '    function _getUserActionHash\n', '    ( \n', '        address _user,\n', '        string _action,\n', '        uint _salt\n', '    ) \n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _user,\n', '                _action,\n', '                _salt\n', '            )\n', '        );\n', '    }\n', '\n', '    // to directly send ether to contract\n', '    function() external payable {\n', '        require(msg.data.length == 0 && msg.value > 0, "Account::fallback INVALID_ETHER_TRANSFER");\n', '\n', '        if(msg.sender != address(weth9)){\n', '            weth9.deposit.value(msg.value)();\n', '        }\n', '    }\n', '\n', '    function changeImpl\n', '    (\n', '        address _to,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external \n', '        note \n', '        addressValid(_to)\n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_to, "CHANGE_ACCOUNT_IMPLEMENTATION", _salt);\n', '        if(actionCompleted[actionHash])\n', '        {\n', '            emit LogError("Account::changeImpl", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::changeImpl", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '\n', '        address oldImpl = masterCopy;\n', '        this.changeMasterCopy(_to);\n', '        \n', '        emit LogImplChanged(_to, oldImpl);\n', '    }\n', '\n', '}']