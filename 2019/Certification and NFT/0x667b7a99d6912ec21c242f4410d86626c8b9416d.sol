['pragma solidity ^0.4.24;\n', '\n', '/*\n', '  __  __                                                    _       ___   ___  __  ___  \n', ' |  \\/  |                         /\\                       | |     |__ \\ / _ \\/_ |/ _ \\ \n', ' | \\  / | ___ _ __ ___   ___     /  \\__      ____ _ _ __ __| |___     ) | | | || | (_) |\n', ' | |\\/| |/ _ \\ &#39;_ ` _ \\ / _ \\   / /\\ \\ \\ /\\ / / _` | &#39;__/ _` / __|   / /| | | || |> _ < \n', ' | |  | |  __/ | | | | |  __/  / ____ \\ V  V / (_| | | | (_| \\__ \\  / /_| |_| || | (_) |\n', ' |_|  |_|\\___|_| |_| |_|\\___| /_/    \\_\\_/\\_/ \\__,_|_|  \\__,_|___/ |____|\\___/ |_|\\___/\n', '\n', '*/\n', '\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'contract IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes data) public returns (bytes4);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n', '    /**\n', '     * 0x01ffc9a7 ===\n', '     *     bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;))\n', '     */\n', '\n', '    /**\n', '     * @dev a mapping of interface id to whether or not it&#39;s supported\n', '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_InterfaceId_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Metadata {\n', '    function name() external view returns (string);\n', '    function symbol() external view returns (string);\n', '    function tokenURI(uint256 tokenId) external view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Enumerable {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '\n', 'contract ERC20Token {\n', '    function balanceOf(address owner) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard BrofistCoin custom implementation\n', ' * @dev Please report any issues to <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bdd4d3dbd2fddfcfd2dbd4cec9ded2d4d393d4d2">[email&#160;protected]</a> or @brofistcoin on Telegram \n', ' */\n', 'contract MemeAwards2018 is ERC165, IERC721, IERC721Metadata, IERC721Enumerable, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    \n', '    string private _name;\n', '    string private _symbol;\n', '    uint256 private releaseDate;\n', '    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n', '    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n', '    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '    \n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned tokens\n', '    mapping (address => uint256) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '    \n', '    // Mapping from airdrop receiver to boolean \n', '    mapping (address => bool) public hasClaimed;\n', '\n', '    // Meme struct holds the templateId\n', '    struct Meme {\n', '        uint32 templateId;\n', '    }\n', '    \n', '    // Template struct holds the uris for templateIds\n', '    struct Template {\n', '        string uri;\n', '    }\n', '    \n', '    // All the tokens in existence \n', '    Meme[] private claimedMemes;\n', '    \n', '    // Admin editable templates for each meme \n', '    Template[] private memeTemplates;\n', '\n', '    // Throws when msg.sender has already claimed the airdrop \n', '    modifier hasNotClaimed() {\n', '        require(hasClaimed[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    // Throws when the 30 day airdrop period has passed \n', '    modifier canClaim() {\n', '        require(releaseDate + 30 days >= now);\n', '        _;\n', '    }\n', '    \n', '    constructor(string name, string symbol) public {\n', '        // Set name\n', '        _name = name;\n', '        // Set symbol \n', '        _symbol = symbol;\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(InterfaceId_ERC721Metadata);\n', '        // register the supported interface to conform to ERC721 via ERC165\n', '        _registerInterface(_InterfaceId_ERC721Enumerable);\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_InterfaceId_ERC721);\n', '        // Set releaseDate\n', '        releaseDate = now;\n', '    }\n', '    \n', '    /* Returns a predictable and insecure pseudo random number between 0 - 9 \n', '    which represent the 10 MemeAwards 2018 meme templates (templateId) */\n', '    function _randomMeme() private view returns (uint8) {\n', '        return uint8(uint256(keccak256(abi.encodePacked(now, msg.sender))) % 10);\n', '    }\n', '    \n', '    // Function to claim the meme airdrop \n', '    function claimMeme() public hasNotClaimed canClaim {\n', '        // Store the random number for reference \n', '        uint32 randomMemeId = _randomMeme();\n', '        // Push new token to claimedMemes with randomMemeId as its templateId\n', '        uint id = claimedMemes.push(Meme(randomMemeId)) -1;\n', '        // Mint the token with the id from claimedMemes array \n', '        _mint(msg.sender, id);\n', '        // Set boolean for hasClaimed\n', '        hasClaimed[msg.sender] = true;\n', '    }\n', '    \n', '    // Iterate through claimed memes and get the count based on its templateId\n', '    // ie. how many of Bitch Lasagna exists \n', '    function getIndividualCount(uint32 _templateId) external view returns (uint) {\n', '        uint counter = 0;\n', '        for (uint i = 0; i < claimedMemes.length; i++) {\n', '            if (claimedMemes[i].templateId == _templateId) {\n', '                counter++;\n', '            }\n', '        }\n', '        // Total supply of n meme\n', '        return counter;\n', '    }\n', '    \n', '    // Get all the memes by owner \n', '    function getMemesByOwner(address _owner) public view returns(uint[]) {\n', '        uint[] memory result = new uint[](_ownedTokensCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < claimedMemes.length; i++) {\n', '            if (_tokenOwner[i] == _owner) {\n', '                result[counter] = i;\n', '                counter++;\n', '            }\n', '        }\n', '        // Array of ID&#39;s in claimedMemes that _owner owns \n', '        return result;\n', '    }\n', '    \n', '    // Get end time\n', '    function getEndTime() external view returns (uint) {\n', '        return releaseDate + 30 days;\n', '    }\n', '\n', '    // Function to withdraw any ERC20 tokens that might be sent here for whatever reasons \n', '    function withdrawERC20Tokens(address _tokenContract) external onlyOwner returns (bool) {\n', '        ERC20Token token = ERC20Token(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(msg.sender, amount);\n', '    }\n', '    \n', '    // And just in case for ETH too (shouldn&#39;t happen though)  \n', '    function withdraw() external onlyOwner {\n', '        uint256 etherBalance = address(this).balance;\n', '        msg.sender.transfer(etherBalance);\n', '    }\n', '    \n', '    // Admin function to set meme template uris\n', '    function setMemeTemplate(string _uri) external onlyOwner {\n', '        require(memeTemplates.length < 10);\n', '        memeTemplates.push(Template(_uri));\n', '    }\n', '    \n', '    // Admin function to edit meme template uris \n', '    // If we wanted to host elsewhere like IPFS for example \n', '    function editMemeTemplate(uint _templateId, string _newUri) external onlyOwner {\n', '        memeTemplates[_templateId].uri = _newUri;\n', '    }\n', '    \n', '    // Return the total supply\n', '    function totalSupply() public view returns (uint256) {\n', '        return claimedMemes.length;\n', '    }\n', '    \n', '    // Return the templateId of _index token \n', '    function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '        require(_index < totalSupply());\n', '        return claimedMemes[_index].templateId;\n', '    }\n', '    \n', '    // Return The token templateId for the index&#39;th token assigned to owner\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId) {\n', '        require(index < balanceOf(owner));\n', '        return getMemesByOwner(owner)[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string) {\n', '        require(_exists(tokenId));\n', '        uint tokenTemplateId = claimedMemes[tokenId].templateId;\n', '        return memeTemplates[tokenTemplateId].uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        // solium-disable-next-line arg-overflow\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        // solium-disable-next-line arg-overflow\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     *    is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        // Disable solium check because of\n', '        // https://github.com/duaraghav8/Solium/issues/175\n', '        // solium-disable-next-line operator-whitespace\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes _data) internal returns (bool) {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '  __  __                                                    _       ___   ___  __  ___  \n', ' |  \\/  |                         /\\                       | |     |__ \\ / _ \\/_ |/ _ \\ \n', ' | \\  / | ___ _ __ ___   ___     /  \\__      ____ _ _ __ __| |___     ) | | | || | (_) |\n', " | |\\/| |/ _ \\ '_ ` _ \\ / _ \\   / /\\ \\ \\ /\\ / / _` | '__/ _` / __|   / /| | | || |> _ < \n", ' | |  | |  __/ | | | | |  __/  / ____ \\ V  V / (_| | | | (_| \\__ \\  / /_| |_| || | (_) |\n', ' |_|  |_|\\___|_| |_| |_|\\___| /_/    \\_\\_/\\_/ \\__,_|_|  \\__,_|___/ |____|\\___/ |_|\\___/\n', '\n', '*/\n', '\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'contract IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes data) public returns (bytes4);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n', '    /**\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_InterfaceId_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Metadata {\n', '    function name() external view returns (string);\n', '    function symbol() external view returns (string);\n', '    function tokenURI(uint256 tokenId) external view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Enumerable {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '\n', 'contract ERC20Token {\n', '    function balanceOf(address owner) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard BrofistCoin custom implementation\n', ' * @dev Please report any issues to info@brofistcoin.io or @brofistcoin on Telegram \n', ' */\n', 'contract MemeAwards2018 is ERC165, IERC721, IERC721Metadata, IERC721Enumerable, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    \n', '    string private _name;\n', '    string private _symbol;\n', '    uint256 private releaseDate;\n', '    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n', '    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\n', '    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '    \n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned tokens\n', '    mapping (address => uint256) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '    \n', '    // Mapping from airdrop receiver to boolean \n', '    mapping (address => bool) public hasClaimed;\n', '\n', '    // Meme struct holds the templateId\n', '    struct Meme {\n', '        uint32 templateId;\n', '    }\n', '    \n', '    // Template struct holds the uris for templateIds\n', '    struct Template {\n', '        string uri;\n', '    }\n', '    \n', '    // All the tokens in existence \n', '    Meme[] private claimedMemes;\n', '    \n', '    // Admin editable templates for each meme \n', '    Template[] private memeTemplates;\n', '\n', '    // Throws when msg.sender has already claimed the airdrop \n', '    modifier hasNotClaimed() {\n', '        require(hasClaimed[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    // Throws when the 30 day airdrop period has passed \n', '    modifier canClaim() {\n', '        require(releaseDate + 30 days >= now);\n', '        _;\n', '    }\n', '    \n', '    constructor(string name, string symbol) public {\n', '        // Set name\n', '        _name = name;\n', '        // Set symbol \n', '        _symbol = symbol;\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(InterfaceId_ERC721Metadata);\n', '        // register the supported interface to conform to ERC721 via ERC165\n', '        _registerInterface(_InterfaceId_ERC721Enumerable);\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_InterfaceId_ERC721);\n', '        // Set releaseDate\n', '        releaseDate = now;\n', '    }\n', '    \n', '    /* Returns a predictable and insecure pseudo random number between 0 - 9 \n', '    which represent the 10 MemeAwards 2018 meme templates (templateId) */\n', '    function _randomMeme() private view returns (uint8) {\n', '        return uint8(uint256(keccak256(abi.encodePacked(now, msg.sender))) % 10);\n', '    }\n', '    \n', '    // Function to claim the meme airdrop \n', '    function claimMeme() public hasNotClaimed canClaim {\n', '        // Store the random number for reference \n', '        uint32 randomMemeId = _randomMeme();\n', '        // Push new token to claimedMemes with randomMemeId as its templateId\n', '        uint id = claimedMemes.push(Meme(randomMemeId)) -1;\n', '        // Mint the token with the id from claimedMemes array \n', '        _mint(msg.sender, id);\n', '        // Set boolean for hasClaimed\n', '        hasClaimed[msg.sender] = true;\n', '    }\n', '    \n', '    // Iterate through claimed memes and get the count based on its templateId\n', '    // ie. how many of Bitch Lasagna exists \n', '    function getIndividualCount(uint32 _templateId) external view returns (uint) {\n', '        uint counter = 0;\n', '        for (uint i = 0; i < claimedMemes.length; i++) {\n', '            if (claimedMemes[i].templateId == _templateId) {\n', '                counter++;\n', '            }\n', '        }\n', '        // Total supply of n meme\n', '        return counter;\n', '    }\n', '    \n', '    // Get all the memes by owner \n', '    function getMemesByOwner(address _owner) public view returns(uint[]) {\n', '        uint[] memory result = new uint[](_ownedTokensCount[_owner]);\n', '        uint counter = 0;\n', '        for (uint i = 0; i < claimedMemes.length; i++) {\n', '            if (_tokenOwner[i] == _owner) {\n', '                result[counter] = i;\n', '                counter++;\n', '            }\n', '        }\n', "        // Array of ID's in claimedMemes that _owner owns \n", '        return result;\n', '    }\n', '    \n', '    // Get end time\n', '    function getEndTime() external view returns (uint) {\n', '        return releaseDate + 30 days;\n', '    }\n', '\n', '    // Function to withdraw any ERC20 tokens that might be sent here for whatever reasons \n', '    function withdrawERC20Tokens(address _tokenContract) external onlyOwner returns (bool) {\n', '        ERC20Token token = ERC20Token(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(msg.sender, amount);\n', '    }\n', '    \n', "    // And just in case for ETH too (shouldn't happen though)  \n", '    function withdraw() external onlyOwner {\n', '        uint256 etherBalance = address(this).balance;\n', '        msg.sender.transfer(etherBalance);\n', '    }\n', '    \n', '    // Admin function to set meme template uris\n', '    function setMemeTemplate(string _uri) external onlyOwner {\n', '        require(memeTemplates.length < 10);\n', '        memeTemplates.push(Template(_uri));\n', '    }\n', '    \n', '    // Admin function to edit meme template uris \n', '    // If we wanted to host elsewhere like IPFS for example \n', '    function editMemeTemplate(uint _templateId, string _newUri) external onlyOwner {\n', '        memeTemplates[_templateId].uri = _newUri;\n', '    }\n', '    \n', '    // Return the total supply\n', '    function totalSupply() public view returns (uint256) {\n', '        return claimedMemes.length;\n', '    }\n', '    \n', '    // Return the templateId of _index token \n', '    function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '        require(_index < totalSupply());\n', '        return claimedMemes[_index].templateId;\n', '    }\n', '    \n', "    // Return The token templateId for the index'th token assigned to owner\n", '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId) {\n', '        require(index < balanceOf(owner));\n', '        return getMemesByOwner(owner)[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string) {\n', '        require(_exists(tokenId));\n', '        uint tokenTemplateId = claimedMemes[tokenId].templateId;\n', '        return memeTemplates[tokenTemplateId].uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        // solium-disable-next-line arg-overflow\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        // solium-disable-next-line arg-overflow\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     *    is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        // Disable solium check because of\n', '        // https://github.com/duaraghav8/Solium/issues/175\n', '        // solium-disable-next-line operator-whitespace\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes _data) internal returns (bool) {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}']
