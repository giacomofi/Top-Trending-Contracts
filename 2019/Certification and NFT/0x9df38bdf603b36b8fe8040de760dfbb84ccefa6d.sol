['/**\n', ' * Token recurring billing smart contract, which enable recurring billing feature for DREAM token.\n', ' * Developed by DreamTeam.GG contributors. Visit dreamteam.gg and github.com/dreamteam-gg/smart-contracts for more info.\n', ' * Copyright &#169; 2019 DREAMTEAM.\n', ' * Licensed under the Apache License, Version 2.0 (the "License").\n', ' */\n', '\n', 'pragma solidity 0.5.2;\n', '\n', 'interface ERC20CompatibleToken {\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '/**\n', ' * Smart contract for recurring billing in ERC20-compatible tokens. This smart contract defines workflow between\n', ' * a merchant and a customer. Workflow:\n', ' * 1. Merchant registers theirselves in this smart contract using `registerNewMerchant`.\n', ' *   1.1. Merchant specifies `beneficiary` address, which receives tokens.\n', ' *   1.2. Merchant specifies `merchant` address, which is able to change `merchant` and `beneficiary` addresses.\n', ' *   1.3. Merchant specified an address that is authorized to call `charge` related to this merchant.\n', ' *     1.3.1. Later, merchant can (de)authorize another addresses to call `charge` using `changeMerchantChargingAccount`.\n', ' *   1.4. As a result, merchant gets `merchantId`, which is used to initialize recurring billing by customers.\n', ' *   1.5. Merchant account can change their `beneficiary`, `merchant` and authorized charging addresses by calling:\n', ' *     1.4.1. Function `changeMerchantAccount`, which changes account that can control this merchant (`merchantId`).\n', ' *     1.4.2. Function `changeMerchantBeneficiaryAddress`, which changes merchant&#39;s `beneficiary`.\n', ' *     1.4.3. Function `changeMerchantChargingAccount`, which (de)authorizes addresses to call `charge` on behalf of this merchant.\n', ' * 2. According to an off-chain agreement with merchant, customer calls `allowRecurringBilling` and:\n', ' *   2.1. Specifies `billingId`, which is given off-chain by merchant (merchant will listen blockchain Event on this ID).\n', ' *   2.2. Specifies `merchantId`, the merchant which will receive tokens.\n', ' *   2.3. Specifies `period` in seconds, during which only one charge can occur.\n', ' *   2.4. Specifies `value`, amount in tokens which can be charged each `period`.\n', ' *     2.4.1. If the customer doesn&#39;t have at least `value` tokens, `allowRecurringBilling` errors.\n', ' *     2.4.2. If the customer haven&#39;t approved at least `value` tokens for a smart contract, `allowRecurringBilling` errors.\n', ' *   2.5. `billingId` is then used by merchant to charge customer each `period`.\n', ' * 3. Merchant use authorized accounts (1.3) to call the `charge` function each `period` to charge agreed amount from a customer.\n', ' *   3.1. It is impossible to call `charge` if the date of the last charge is less than `period`.\n', ' *   3.2. Calling `charge` cancels billing when called after 2 `period`s from the last charge.\n', ' *   3.3. Thus, to successfully charge an account, `charge` must be strictly called within 1 and 2 `period`s after the last charge.\n', ' *   3.4. Calling `charge` errors if any of the following occur:\n', ' *     3.4.1. Customer canceled recurring billing with `cancelRecurringBilling`.\n', ' *     3.4.2. Customer&#39;s balance is lower than the chargeable amount.\n', ' *     3.4.3. Customer&#39;s allowance to the smart contract is less than the chargable amount.\n', ' *     3.4.4. Specified `billingId` does not exists.\n', ' *     3.4.5. There&#39;s no `period` passed since the last charge.\n', ' *   3.5. Next charge date increments strictly by `period` each charge, thus, there&#39;s no need to exec `charge` strictly on time.\n', ' * 4. Customer can cancel further billing by calling `cancelRecurringBilling` and passing `billingId`.\n', ' * 5. TokenRecurringBilling smart contract implements `receiveApproval` function for allowing/cancelling billing within one call from\n', ' *    the token smart contract. Parameter `data` is encoded as tightly-packed (uint256 metadata, uint256 billingId).\n', ' *   5.1. `metadata` is encoded using `encodeBillingMetadata`.\n', ' *   5.2. As for `receiveApproval`, `lastChargeAt` in `metadata` is used as an action identifier.\n', ' *      5.2.1. `lastChargeAt=0` specifies that customer wants to allow new recurring billing.\n', ' *      5.2.2. `lastChargeAt=1` specifies that customer wants to cancel existing recurring billing.\n', ' *   5.3. Make sure that passed `bytes` parameter is exactly 64 bytes in length.\n', ' */\n', 'contract TokenRecurringBilling {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event BillingAllowed(uint256 indexed billingId, address customer, uint256 merchantId, uint256 timestamp, uint256 period, uint256 value);\n', '    event BillingCharged(uint256 indexed billingId, uint256 timestamp, uint256 nextChargeTimestamp);\n', '    event BillingCanceled(uint256 indexed billingId);\n', '    event MerchantRegistered(uint256 indexed merchantId, address merchantAccount, address beneficiaryAddress);\n', '    event MerchantAccountChanged(uint256 indexed merchantId, address merchantAccount);\n', '    event MerchantBeneficiaryAddressChanged(uint256 indexed merchantId, address beneficiaryAddress);\n', '    event MerchantChargingAccountAllowed(uint256 indexed merchantId, address chargingAccount, bool allowed);\n', '\n', '    struct BillingRecord {\n', '        address customer; // Billing address (those who pay).\n', '        uint256 metadata; // Metadata packs 5 values to save on storage. Metadata spec (from first to last byte):\n', '                          //   + uint32 period;       // Billing period in seconds; configurable period of up to 136 years.\n', '                          //   + uint32 merchantId;   // Merchant ID; up to ~4.2 Milliard IDs.\n', '                          //   + uint48 lastChargeAt; // When the last charge occurred; up to year 999999+.\n', '                          //   + uint144 value;       // Billing value charrged each period; up to ~22 septillion tokens with 18 decimals\n', '    }\n', '\n', '    struct Merchant {\n', '        address merchant;    // Merchant admin address that can change all merchant struct properties.\n', '        address beneficiary; // Address receiving tokens.\n', '    }\n', '\n', '    enum receiveApprovalAction { // In receiveApproval, `lastChargeAt` in passed `metadata` specifies an action to execute.\n', '        allowRecurringBilling,   // == 0\n', '        cancelRecurringBilling   // == 1\n', '    }\n', '\n', '    uint256 public lastMerchantId;     // This variable increments on each new merchant registered, generating unique ids for merchant.\n', '    ERC20CompatibleToken public token; // Token address.\n', '\n', '    mapping(uint256 => BillingRecord) public billingRegistry;                           // List of all billings registered by ID.\n', '    mapping(uint256 => Merchant) public merchantRegistry;                               // List of all merchants registered by ID.\n', '    mapping(uint256 => mapping(address => bool)) public merchantChargingAccountAllowed; // Accounts that are allowed to charge customers.\n', '\n', '    // Checks whether {merchant} owns {merchantId}\n', '    modifier isMerchant (uint256 merchantId) {\n', '        require(merchantRegistry[merchantId].merchant == msg.sender, "Sender is not a merchant");\n', '        _;\n', '    }\n', '\n', '    // Checks whether {customer} owns {billingId}\n', '    modifier isCustomer (uint256 billingId) {\n', '        require(billingRegistry[billingId].customer == msg.sender, "Sender is not a customer");\n', '        _;\n', '    }\n', '\n', '    // Guarantees that the transaction is sent by token smart contract only.\n', '    modifier tokenOnly () {\n', '        require(msg.sender == address(token), "Sender is not a token");\n', '        _;\n', '    }\n', '\n', '    /// ======================================================== Constructor ========================================================= \\\\\\\n', '\n', '    // Creates a recurring billing smart contract for particular token.\n', '    constructor (address tokenAddress) public {\n', '        token = ERC20CompatibleToken(tokenAddress);\n', '    }\n', '\n', '    /// ====================================================== Public Functions ====================================================== \\\\\\\n', '\n', '    // Enables merchant with {merchantId} to charge transaction signer&#39;s account according to specified {value} and {period}.\n', '    function allowRecurringBilling (uint256 billingId, uint256 merchantId, uint256 value, uint256 period) public {\n', '        allowRecurringBillingInternal(msg.sender, merchantId, billingId, value, period);\n', '    }\n', '\n', '    // Enables anyone to become a merchant, charging tokens for their services.\n', '    function registerNewMerchant (address beneficiary, address chargingAccount) public returns (uint256 merchantId) {\n', '\n', '        merchantId = ++lastMerchantId;\n', '        Merchant storage record = merchantRegistry[merchantId];\n', '        record.merchant = msg.sender;\n', '        record.beneficiary = beneficiary;\n', '        emit MerchantRegistered(merchantId, msg.sender, beneficiary);\n', '\n', '        changeMerchantChargingAccount(merchantId, chargingAccount, true);\n', '\n', '    }\n', '\n', '    /// =========================================== Public Functions with Restricted Access =========================================== \\\\\\\n', '\n', '    // Calcels recurring billing with id {billingId} if it is owned by a transaction signer.\n', '    function cancelRecurringBilling (uint256 billingId) public isCustomer(billingId) {\n', '        cancelRecurringBillingInternal(billingId);\n', '    }\n', '\n', '    // Charges customer&#39;s account according to defined {billingId} billing rules. Only merchant&#39;s authorized accounts can charge the customer.\n', '    function charge (uint256 billingId) public {\n', '\n', '        BillingRecord storage billingRecord = billingRegistry[billingId];\n', '        (uint256 value, uint256 lastChargeAt, uint256 merchantId, uint256 period) = decodeBillingMetadata(billingRecord.metadata);\n', '\n', '        require(merchantChargingAccountAllowed[merchantId][msg.sender], "Sender is not allowed to charge");\n', '        require(merchantId != 0, "Billing does not exist");\n', '        require(lastChargeAt.add(period) <= now, "Charged too early");\n', '\n', '        // If 2 periods have already passed since the last charge (or beginning), no further charges are possible\n', '        // and recurring billing is canceled in case of a charge.\n', '        if (now > lastChargeAt.add(period.mul(2))) {\n', '            cancelRecurringBillingInternal(billingId);\n', '            return;\n', '        }\n', '\n', '        require(\n', '            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\n', '            "Unable to charge customer"\n', '        );\n', '\n', '        billingRecord.metadata = encodeBillingMetadata(value, lastChargeAt.add(period), merchantId, period);\n', '\n', '        emit BillingCharged(billingId, now, lastChargeAt.add(period.mul(2)));\n', '\n', '    }\n', '\n', '    /**\n', '     * Invoked by a token smart contract on approveAndCall. Allows or cancels recurring billing.\n', '     * @param sender - Address that approved some tokens for this smart contract.\n', '     * @param data - Tightly-packed (uint256,uint256) values of (metadata, billingId). Metadata&#39;s `lastChargeAt`\n', '     *               specifies an action to perform (see `receiveApprovalAction` enum).\n', '     */\n', '    function receiveApproval (address sender, uint, address, bytes calldata data) external tokenOnly {\n', '\n', '        // The token contract MUST guarantee that "sender" is actually the token owner, and metadata is signed by a token owner.\n', '        require(data.length == 64, "Invalid data length");\n', '\n', '        // `action` is used instead of `lastCahrgeAt` to save some space.\n', '        (uint256 value, uint256 action, uint256 merchantId, uint256 period) = decodeBillingMetadata(bytesToUint256(data, 0));\n', '        uint256 billingId = bytesToUint256(data, 32);\n', '\n', '        if (action == uint256(receiveApprovalAction.allowRecurringBilling)) {\n', '            allowRecurringBillingInternal(sender, merchantId, billingId, value, period);\n', '        } else if (action == uint256(receiveApprovalAction.cancelRecurringBilling)) {\n', '            require(billingRegistry[billingId].customer == sender, "Unable to cancel recurring billing of another customer");\n', '            cancelRecurringBillingInternal(billingId);\n', '        } else {\n', '            revert("Unknown action provided");\n', '        }\n', '\n', '    }\n', '\n', '    // Changes merchant account with id {merchantId} to {newMerchantAccount}.\n', '    function changeMerchantAccount (uint256 merchantId, address newMerchantAccount) public isMerchant(merchantId) {\n', '        merchantRegistry[merchantId].merchant = newMerchantAccount;\n', '        emit MerchantAccountChanged(merchantId, newMerchantAccount);\n', '    }\n', '\n', '    // Changes merchant&#39;s beneficiary address (address that receives charged tokens) to {newBeneficiaryAddress}.\n', '    function changeMerchantBeneficiaryAddress (uint256 merchantId, address newBeneficiaryAddress) public isMerchant(merchantId) {\n', '        merchantRegistry[merchantId].beneficiary = newBeneficiaryAddress;\n', '        emit MerchantBeneficiaryAddressChanged(merchantId, newBeneficiaryAddress);\n', '    }\n', '\n', '    // Allows or disallows particular {account} to charge customers related to this merchant.\n', '    function changeMerchantChargingAccount (uint256 merchantId, address account, bool allowed) public isMerchant(merchantId) {\n', '        merchantChargingAccountAllowed[merchantId][account] = allowed;\n', '        emit MerchantChargingAccountAllowed(merchantId, account, allowed);\n', '    }\n', '\n', '    /// ================================================== Public Utility Functions ================================================== \\\\\\\n', '\n', '    // Used to encode 5 values into one uint256 value. This is primarily made for cheaper storage.\n', '    function encodeBillingMetadata (\n', '        uint256 value,\n', '        uint256 lastChargeAt,\n', '        uint256 merchantId,\n', '        uint256 period\n', '    ) public pure returns (uint256 result) {\n', '\n', '        require(\n', '            value < 2 ** 144\n', '            && lastChargeAt < 2 ** 48\n', '            && merchantId < 2 ** 32\n', '            && period < 2 ** 32,\n', '            "Invalid input sizes to encode"\n', '        );\n', '\n', '        result = value;\n', '        result |= lastChargeAt << (144);\n', '        result |= merchantId << (144 + 48);\n', '        result |= period << (144 + 48 + 32);\n', '\n', '        return result;\n', '\n', '    }\n', '\n', '    // Used to decode 5 values from one uint256 value encoded by `encodeBillingMetadata` function.\n', '    function decodeBillingMetadata (uint256 encodedData) public pure returns (\n', '        uint256 value,\n', '        uint256 lastChargeAt,\n', '        uint256 merchantId,\n', '        uint256 period\n', '    ) {\n', '        value = uint144(encodedData);\n', '        lastChargeAt = uint48(encodedData >> (144));\n', '        merchantId = uint32(encodedData >> (144 + 48));\n', '        period = uint32(encodedData >> (144 + 48 + 32));\n', '    }\n', '\n', '    /// ================================================ Internal (Private) Functions ================================================ \\\\\\\n', '\n', '    // Allows recurring billing. Noone but this contract can call this function.\n', '    function allowRecurringBillingInternal (\n', '        address customer,\n', '        uint256 merchantId,\n', '        uint256 billingId,\n', '        uint256 value,\n', '        uint256 period\n', '    ) internal {\n', '\n', '        require(merchantId <= lastMerchantId && merchantId != 0, "Invalid merchant specified");\n', '        require(period < now, "Invalid period specified");\n', '        require(token.balanceOf(customer) >= value, "Not enough tokens for the first charge");\n', '        require(token.allowance(customer, address(this)) >= value, "Tokens are not approved for this smart contract");\n', '        require(billingRegistry[billingId].customer == address(0x0), "Recurring billing with this ID is already registered");\n', '\n', '        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\n', '        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\n', '        newRecurringBilling.customer = customer;\n', '\n', '        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\n', '\n', '    }\n', '\n', '    // Cancels recurring billing. Noone but this contract can call this function.\n', '    function cancelRecurringBillingInternal (uint256 billingId) internal {\n', '        delete billingRegistry[billingId];\n', '        emit BillingCanceled(billingId);\n', '    }\n', '\n', '    // Utility function to convert bytes type to uint256. Noone but this contract can call this function.\n', '    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n', '        assembly { output := mload(add(add(input, 32), offset)) }\n', '    }\n', '\n', '}']
['/**\n', ' * Token recurring billing smart contract, which enable recurring billing feature for DREAM token.\n', ' * Developed by DreamTeam.GG contributors. Visit dreamteam.gg and github.com/dreamteam-gg/smart-contracts for more info.\n', ' * Copyright Â© 2019 DREAMTEAM.\n', ' * Licensed under the Apache License, Version 2.0 (the "License").\n', ' */\n', '\n', 'pragma solidity 0.5.2;\n', '\n', 'interface ERC20CompatibleToken {\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', ' \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\n', '/**\n', ' * Smart contract for recurring billing in ERC20-compatible tokens. This smart contract defines workflow between\n', ' * a merchant and a customer. Workflow:\n', ' * 1. Merchant registers theirselves in this smart contract using `registerNewMerchant`.\n', ' *   1.1. Merchant specifies `beneficiary` address, which receives tokens.\n', ' *   1.2. Merchant specifies `merchant` address, which is able to change `merchant` and `beneficiary` addresses.\n', ' *   1.3. Merchant specified an address that is authorized to call `charge` related to this merchant.\n', ' *     1.3.1. Later, merchant can (de)authorize another addresses to call `charge` using `changeMerchantChargingAccount`.\n', ' *   1.4. As a result, merchant gets `merchantId`, which is used to initialize recurring billing by customers.\n', ' *   1.5. Merchant account can change their `beneficiary`, `merchant` and authorized charging addresses by calling:\n', ' *     1.4.1. Function `changeMerchantAccount`, which changes account that can control this merchant (`merchantId`).\n', " *     1.4.2. Function `changeMerchantBeneficiaryAddress`, which changes merchant's `beneficiary`.\n", ' *     1.4.3. Function `changeMerchantChargingAccount`, which (de)authorizes addresses to call `charge` on behalf of this merchant.\n', ' * 2. According to an off-chain agreement with merchant, customer calls `allowRecurringBilling` and:\n', ' *   2.1. Specifies `billingId`, which is given off-chain by merchant (merchant will listen blockchain Event on this ID).\n', ' *   2.2. Specifies `merchantId`, the merchant which will receive tokens.\n', ' *   2.3. Specifies `period` in seconds, during which only one charge can occur.\n', ' *   2.4. Specifies `value`, amount in tokens which can be charged each `period`.\n', " *     2.4.1. If the customer doesn't have at least `value` tokens, `allowRecurringBilling` errors.\n", " *     2.4.2. If the customer haven't approved at least `value` tokens for a smart contract, `allowRecurringBilling` errors.\n", ' *   2.5. `billingId` is then used by merchant to charge customer each `period`.\n', ' * 3. Merchant use authorized accounts (1.3) to call the `charge` function each `period` to charge agreed amount from a customer.\n', ' *   3.1. It is impossible to call `charge` if the date of the last charge is less than `period`.\n', ' *   3.2. Calling `charge` cancels billing when called after 2 `period`s from the last charge.\n', ' *   3.3. Thus, to successfully charge an account, `charge` must be strictly called within 1 and 2 `period`s after the last charge.\n', ' *   3.4. Calling `charge` errors if any of the following occur:\n', ' *     3.4.1. Customer canceled recurring billing with `cancelRecurringBilling`.\n', " *     3.4.2. Customer's balance is lower than the chargeable amount.\n", " *     3.4.3. Customer's allowance to the smart contract is less than the chargable amount.\n", ' *     3.4.4. Specified `billingId` does not exists.\n', " *     3.4.5. There's no `period` passed since the last charge.\n", " *   3.5. Next charge date increments strictly by `period` each charge, thus, there's no need to exec `charge` strictly on time.\n", ' * 4. Customer can cancel further billing by calling `cancelRecurringBilling` and passing `billingId`.\n', ' * 5. TokenRecurringBilling smart contract implements `receiveApproval` function for allowing/cancelling billing within one call from\n', ' *    the token smart contract. Parameter `data` is encoded as tightly-packed (uint256 metadata, uint256 billingId).\n', ' *   5.1. `metadata` is encoded using `encodeBillingMetadata`.\n', ' *   5.2. As for `receiveApproval`, `lastChargeAt` in `metadata` is used as an action identifier.\n', ' *      5.2.1. `lastChargeAt=0` specifies that customer wants to allow new recurring billing.\n', ' *      5.2.2. `lastChargeAt=1` specifies that customer wants to cancel existing recurring billing.\n', ' *   5.3. Make sure that passed `bytes` parameter is exactly 64 bytes in length.\n', ' */\n', 'contract TokenRecurringBilling {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event BillingAllowed(uint256 indexed billingId, address customer, uint256 merchantId, uint256 timestamp, uint256 period, uint256 value);\n', '    event BillingCharged(uint256 indexed billingId, uint256 timestamp, uint256 nextChargeTimestamp);\n', '    event BillingCanceled(uint256 indexed billingId);\n', '    event MerchantRegistered(uint256 indexed merchantId, address merchantAccount, address beneficiaryAddress);\n', '    event MerchantAccountChanged(uint256 indexed merchantId, address merchantAccount);\n', '    event MerchantBeneficiaryAddressChanged(uint256 indexed merchantId, address beneficiaryAddress);\n', '    event MerchantChargingAccountAllowed(uint256 indexed merchantId, address chargingAccount, bool allowed);\n', '\n', '    struct BillingRecord {\n', '        address customer; // Billing address (those who pay).\n', '        uint256 metadata; // Metadata packs 5 values to save on storage. Metadata spec (from first to last byte):\n', '                          //   + uint32 period;       // Billing period in seconds; configurable period of up to 136 years.\n', '                          //   + uint32 merchantId;   // Merchant ID; up to ~4.2 Milliard IDs.\n', '                          //   + uint48 lastChargeAt; // When the last charge occurred; up to year 999999+.\n', '                          //   + uint144 value;       // Billing value charrged each period; up to ~22 septillion tokens with 18 decimals\n', '    }\n', '\n', '    struct Merchant {\n', '        address merchant;    // Merchant admin address that can change all merchant struct properties.\n', '        address beneficiary; // Address receiving tokens.\n', '    }\n', '\n', '    enum receiveApprovalAction { // In receiveApproval, `lastChargeAt` in passed `metadata` specifies an action to execute.\n', '        allowRecurringBilling,   // == 0\n', '        cancelRecurringBilling   // == 1\n', '    }\n', '\n', '    uint256 public lastMerchantId;     // This variable increments on each new merchant registered, generating unique ids for merchant.\n', '    ERC20CompatibleToken public token; // Token address.\n', '\n', '    mapping(uint256 => BillingRecord) public billingRegistry;                           // List of all billings registered by ID.\n', '    mapping(uint256 => Merchant) public merchantRegistry;                               // List of all merchants registered by ID.\n', '    mapping(uint256 => mapping(address => bool)) public merchantChargingAccountAllowed; // Accounts that are allowed to charge customers.\n', '\n', '    // Checks whether {merchant} owns {merchantId}\n', '    modifier isMerchant (uint256 merchantId) {\n', '        require(merchantRegistry[merchantId].merchant == msg.sender, "Sender is not a merchant");\n', '        _;\n', '    }\n', '\n', '    // Checks whether {customer} owns {billingId}\n', '    modifier isCustomer (uint256 billingId) {\n', '        require(billingRegistry[billingId].customer == msg.sender, "Sender is not a customer");\n', '        _;\n', '    }\n', '\n', '    // Guarantees that the transaction is sent by token smart contract only.\n', '    modifier tokenOnly () {\n', '        require(msg.sender == address(token), "Sender is not a token");\n', '        _;\n', '    }\n', '\n', '    /// ======================================================== Constructor ========================================================= \\\\\\\n', '\n', '    // Creates a recurring billing smart contract for particular token.\n', '    constructor (address tokenAddress) public {\n', '        token = ERC20CompatibleToken(tokenAddress);\n', '    }\n', '\n', '    /// ====================================================== Public Functions ====================================================== \\\\\\\n', '\n', "    // Enables merchant with {merchantId} to charge transaction signer's account according to specified {value} and {period}.\n", '    function allowRecurringBilling (uint256 billingId, uint256 merchantId, uint256 value, uint256 period) public {\n', '        allowRecurringBillingInternal(msg.sender, merchantId, billingId, value, period);\n', '    }\n', '\n', '    // Enables anyone to become a merchant, charging tokens for their services.\n', '    function registerNewMerchant (address beneficiary, address chargingAccount) public returns (uint256 merchantId) {\n', '\n', '        merchantId = ++lastMerchantId;\n', '        Merchant storage record = merchantRegistry[merchantId];\n', '        record.merchant = msg.sender;\n', '        record.beneficiary = beneficiary;\n', '        emit MerchantRegistered(merchantId, msg.sender, beneficiary);\n', '\n', '        changeMerchantChargingAccount(merchantId, chargingAccount, true);\n', '\n', '    }\n', '\n', '    /// =========================================== Public Functions with Restricted Access =========================================== \\\\\\\n', '\n', '    // Calcels recurring billing with id {billingId} if it is owned by a transaction signer.\n', '    function cancelRecurringBilling (uint256 billingId) public isCustomer(billingId) {\n', '        cancelRecurringBillingInternal(billingId);\n', '    }\n', '\n', "    // Charges customer's account according to defined {billingId} billing rules. Only merchant's authorized accounts can charge the customer.\n", '    function charge (uint256 billingId) public {\n', '\n', '        BillingRecord storage billingRecord = billingRegistry[billingId];\n', '        (uint256 value, uint256 lastChargeAt, uint256 merchantId, uint256 period) = decodeBillingMetadata(billingRecord.metadata);\n', '\n', '        require(merchantChargingAccountAllowed[merchantId][msg.sender], "Sender is not allowed to charge");\n', '        require(merchantId != 0, "Billing does not exist");\n', '        require(lastChargeAt.add(period) <= now, "Charged too early");\n', '\n', '        // If 2 periods have already passed since the last charge (or beginning), no further charges are possible\n', '        // and recurring billing is canceled in case of a charge.\n', '        if (now > lastChargeAt.add(period.mul(2))) {\n', '            cancelRecurringBillingInternal(billingId);\n', '            return;\n', '        }\n', '\n', '        require(\n', '            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\n', '            "Unable to charge customer"\n', '        );\n', '\n', '        billingRecord.metadata = encodeBillingMetadata(value, lastChargeAt.add(period), merchantId, period);\n', '\n', '        emit BillingCharged(billingId, now, lastChargeAt.add(period.mul(2)));\n', '\n', '    }\n', '\n', '    /**\n', '     * Invoked by a token smart contract on approveAndCall. Allows or cancels recurring billing.\n', '     * @param sender - Address that approved some tokens for this smart contract.\n', "     * @param data - Tightly-packed (uint256,uint256) values of (metadata, billingId). Metadata's `lastChargeAt`\n", '     *               specifies an action to perform (see `receiveApprovalAction` enum).\n', '     */\n', '    function receiveApproval (address sender, uint, address, bytes calldata data) external tokenOnly {\n', '\n', '        // The token contract MUST guarantee that "sender" is actually the token owner, and metadata is signed by a token owner.\n', '        require(data.length == 64, "Invalid data length");\n', '\n', '        // `action` is used instead of `lastCahrgeAt` to save some space.\n', '        (uint256 value, uint256 action, uint256 merchantId, uint256 period) = decodeBillingMetadata(bytesToUint256(data, 0));\n', '        uint256 billingId = bytesToUint256(data, 32);\n', '\n', '        if (action == uint256(receiveApprovalAction.allowRecurringBilling)) {\n', '            allowRecurringBillingInternal(sender, merchantId, billingId, value, period);\n', '        } else if (action == uint256(receiveApprovalAction.cancelRecurringBilling)) {\n', '            require(billingRegistry[billingId].customer == sender, "Unable to cancel recurring billing of another customer");\n', '            cancelRecurringBillingInternal(billingId);\n', '        } else {\n', '            revert("Unknown action provided");\n', '        }\n', '\n', '    }\n', '\n', '    // Changes merchant account with id {merchantId} to {newMerchantAccount}.\n', '    function changeMerchantAccount (uint256 merchantId, address newMerchantAccount) public isMerchant(merchantId) {\n', '        merchantRegistry[merchantId].merchant = newMerchantAccount;\n', '        emit MerchantAccountChanged(merchantId, newMerchantAccount);\n', '    }\n', '\n', "    // Changes merchant's beneficiary address (address that receives charged tokens) to {newBeneficiaryAddress}.\n", '    function changeMerchantBeneficiaryAddress (uint256 merchantId, address newBeneficiaryAddress) public isMerchant(merchantId) {\n', '        merchantRegistry[merchantId].beneficiary = newBeneficiaryAddress;\n', '        emit MerchantBeneficiaryAddressChanged(merchantId, newBeneficiaryAddress);\n', '    }\n', '\n', '    // Allows or disallows particular {account} to charge customers related to this merchant.\n', '    function changeMerchantChargingAccount (uint256 merchantId, address account, bool allowed) public isMerchant(merchantId) {\n', '        merchantChargingAccountAllowed[merchantId][account] = allowed;\n', '        emit MerchantChargingAccountAllowed(merchantId, account, allowed);\n', '    }\n', '\n', '    /// ================================================== Public Utility Functions ================================================== \\\\\\\n', '\n', '    // Used to encode 5 values into one uint256 value. This is primarily made for cheaper storage.\n', '    function encodeBillingMetadata (\n', '        uint256 value,\n', '        uint256 lastChargeAt,\n', '        uint256 merchantId,\n', '        uint256 period\n', '    ) public pure returns (uint256 result) {\n', '\n', '        require(\n', '            value < 2 ** 144\n', '            && lastChargeAt < 2 ** 48\n', '            && merchantId < 2 ** 32\n', '            && period < 2 ** 32,\n', '            "Invalid input sizes to encode"\n', '        );\n', '\n', '        result = value;\n', '        result |= lastChargeAt << (144);\n', '        result |= merchantId << (144 + 48);\n', '        result |= period << (144 + 48 + 32);\n', '\n', '        return result;\n', '\n', '    }\n', '\n', '    // Used to decode 5 values from one uint256 value encoded by `encodeBillingMetadata` function.\n', '    function decodeBillingMetadata (uint256 encodedData) public pure returns (\n', '        uint256 value,\n', '        uint256 lastChargeAt,\n', '        uint256 merchantId,\n', '        uint256 period\n', '    ) {\n', '        value = uint144(encodedData);\n', '        lastChargeAt = uint48(encodedData >> (144));\n', '        merchantId = uint32(encodedData >> (144 + 48));\n', '        period = uint32(encodedData >> (144 + 48 + 32));\n', '    }\n', '\n', '    /// ================================================ Internal (Private) Functions ================================================ \\\\\\\n', '\n', '    // Allows recurring billing. Noone but this contract can call this function.\n', '    function allowRecurringBillingInternal (\n', '        address customer,\n', '        uint256 merchantId,\n', '        uint256 billingId,\n', '        uint256 value,\n', '        uint256 period\n', '    ) internal {\n', '\n', '        require(merchantId <= lastMerchantId && merchantId != 0, "Invalid merchant specified");\n', '        require(period < now, "Invalid period specified");\n', '        require(token.balanceOf(customer) >= value, "Not enough tokens for the first charge");\n', '        require(token.allowance(customer, address(this)) >= value, "Tokens are not approved for this smart contract");\n', '        require(billingRegistry[billingId].customer == address(0x0), "Recurring billing with this ID is already registered");\n', '\n', '        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\n', '        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\n', '        newRecurringBilling.customer = customer;\n', '\n', '        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\n', '\n', '    }\n', '\n', '    // Cancels recurring billing. Noone but this contract can call this function.\n', '    function cancelRecurringBillingInternal (uint256 billingId) internal {\n', '        delete billingRegistry[billingId];\n', '        emit BillingCanceled(billingId);\n', '    }\n', '\n', '    // Utility function to convert bytes type to uint256. Noone but this contract can call this function.\n', '    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\n', '        assembly { output := mload(add(add(input, 32), offset)) }\n', '    }\n', '\n', '}']
