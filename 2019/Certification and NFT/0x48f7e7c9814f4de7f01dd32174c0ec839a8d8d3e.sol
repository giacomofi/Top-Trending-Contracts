['pragma solidity ^0.5.1;\n', '\n', 'contract VotingChallenge {\n', '    struct Team {\n', '        uint fullVotes;\n', '        uint weightedVotes;\n', '    }\n', '\n', '    struct Voter {\n', '        uint[2] fullVotes;\n', '        uint[2] weightedVotes;\n', '        address payable[2] referrers;\n', '    }\n', '\n', '    VotingChallengeForwarder forwarder;\n', '\n', '    uint public challengeDuration;\n', '    uint public challengeStarted;\n', '    address payable public creator;\n', '    uint16 public creatorFee = 17;       // measured in in tenths of a percent\n', '    address payable public cryptoVersusWallet = 0xa0bedE75cfeEF0266f8A31b47074F5f9fBE1df80;\n', '    uint16 public cryptoVersusFee = 53;  // measured in in tenths of a percent\n', '    uint public cryptoVersusPrize;\n', '    uint public challengePrize;\n', '    uint public winner;\n', '    bool public isVotingPeriod = false;\n', '    bool public beforeVoting = true;\n', '    Team[2] public teams;\n', '    mapping( address => Voter ) private voters;\n', '\n', '    modifier inVotingPeriod() {\n', '        require(isVotingPeriod);\n', '        _;\n', '    }\n', '\n', '    modifier afterVotingPeriod() {\n', '        require(!isVotingPeriod);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCreator() {\n', '        require(msg.sender == creator);\n', '        _;\n', '    }\n', '\n', '    event ChallengeBegins(address _creator, uint _challengeDuration);\n', '    event NewVotesFor(address _participant, uint _candidate, uint _votes, uint _coefficient);\n', '    event TransferVotes(address _from, address _to, uint _candidateIndex, uint _votes);\n', '    event EndOfChallenge(uint _winner, uint _winnerVotes, uint _challengePrize);\n', '    event RewardWasPaid(address _participant, uint _amount);\n', '    event ReferrerRewardWasPaid(address _via, address _to, uint amount);\n', '    event CreatorRewardWasPaid(address _creator, uint _amount);\n', '    event CryptoVersusRewardWasPaid(address _cryptoVersusWallet, uint _amount);\n', '\n', '    constructor(uint _challengeDuration, address _forwarder) public {\n', '        forwarder = VotingChallengeForwarder(_forwarder);\n', '        challengeDuration = _challengeDuration;\n', '        creator = msg.sender;\n', '    }\n', '\n', '    function getAllVotes() public view returns (uint[2] memory) {\n', '        return [ teams[0].fullVotes, teams[1].fullVotes ];\n', '    }\n', '\n', '    function currentCoefficient() public view returns (uint) {  // in 1/1000000\n', '        return 1000000 - 900000 * (now - challengeStarted) / challengeDuration;\n', '    }\n', '\n', '    function timeOver() public view returns (bool) {\n', '        return challengeStarted + challengeDuration <= now;\n', '    }\n', '\n', '    function startChallenge() public onlyCreator {\n', '        require(beforeVoting);\n', '        isVotingPeriod = true;\n', '        beforeVoting = false;\n', '        challengeStarted = now;\n', '\n', '        emit ChallengeBegins(creator, challengeDuration);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate) public payable inVotingPeriod {\n', '        require(0 <= candidate && candidate < 2);\n', '        require(msg.value > 0);\n', '        require(!timeOver());\n', '\n', '        uint coefficient = currentCoefficient();\n', '        uint weightedVotes = msg.value * coefficient / 1000000;\n', '        teams[candidate].fullVotes += msg.value;\n', '        teams[candidate].weightedVotes += weightedVotes;\n', '        voters[msg.sender].fullVotes[candidate] += msg.value;\n', '        voters[msg.sender].weightedVotes[candidate] += weightedVotes;\n', '\n', '        emit NewVotesFor(msg.sender, candidate, msg.value, coefficient);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate, address payable referrer1) public payable inVotingPeriod {\n', '        voters[msg.sender].referrers[0] = referrer1;\n', '        voteForCandidate(candidate);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate, address payable referrer1, address payable referrer2) public payable inVotingPeriod {\n', '        voters[msg.sender].referrers[1] = referrer2;\n', '        voteForCandidate(candidate, referrer1);\n', '    }\n', '\n', '    function checkEndOfChallenge() public inVotingPeriod returns (bool) {\n', '        if (!timeOver())\n', '            return false;\n', '\n', '        if (teams[0].fullVotes > teams[1].fullVotes)\n', '            winner = 0;\n', '        else\n', '            winner = 1;\n', '\n', '        uint loser = 1 - winner;\n', '        creator.transfer((teams[loser].fullVotes * creatorFee) / 1000);\n', '        cryptoVersusPrize = (teams[loser].fullVotes * cryptoVersusFee) / 1000;\n', '        challengePrize = teams[loser].fullVotes * (1000 - creatorFee - cryptoVersusFee) / 1000;\n', '        isVotingPeriod = false;\n', '\n', '        emit EndOfChallenge(winner, teams[winner].fullVotes, challengePrize);\n', '        return true;\n', '    }\n', '\n', '    function sendReward(address payable to) public afterVotingPeriod {\n', '        uint winnerVotes = voters[to].weightedVotes[winner];\n', '        uint loserVotes = voters[to].fullVotes[1-winner];\n', '        address payable referrer1 = voters[to].referrers[0];\n', '        address payable referrer2 = voters[to].referrers[1];\n', '        uint sum;\n', '\n', '        if (winnerVotes > 0) {\n', '            uint reward = challengePrize * winnerVotes / teams[winner].weightedVotes;\n', '            to.transfer(reward + voters[to].fullVotes[winner]);\n', '            if (referrer1 != address(0)) {\n', '                sum = reward / 100 * 2;  // 2%\n', '                forwarder.forward.value(sum)(referrer1, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer1, sum);\n', '            }\n', '            if (referrer2 != address(0)) {\n', '                sum = reward / 1000 * 2;  // 0.2%\n', '                forwarder.forward.value(sum)(referrer2, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer2, sum);\n', '            }\n', '            voters[to].fullVotes[winner] = 0;\n', '            voters[to].weightedVotes[winner] = 0;\n', '            emit RewardWasPaid(to, reward);\n', '        }\n', '        if (loserVotes > 0) {\n', '            if (referrer1 != address(0)) {\n', '                sum = loserVotes / 100 * 1;  // 1%\n', '                forwarder.forward.value(sum)(referrer1, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer1, sum);\n', '            }\n', '            if (referrer2 != address(0)) {\n', '                sum = loserVotes / 1000 * 1;  // 0.1%\n', '                forwarder.forward.value(sum)(referrer2, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer2, sum);\n', '            }\n', '            voters[to].fullVotes[1-winner] = 0;\n', '            voters[to].weightedVotes[1-winner] = 0;\n', '        }\n', '    }\n', '\n', '    function sendCryptoVersusReward() public afterVotingPeriod {\n', '        if (cryptoVersusPrize > 0) {\n', '            uint cryptoVersusReward = cryptoVersusPrize;\n', '            cryptoVersusPrize = 0;\n', '            cryptoVersusWallet.transfer(cryptoVersusReward);\n', '\n', '            emit CryptoVersusRewardWasPaid(cryptoVersusWallet, cryptoVersusReward);\n', '        }\n', '    }\n', '}\n', '\n', 'contract VotingChallengeForwarder {\n', '    mapping ( address => address[] ) public sendersHash;\n', '    mapping ( address => uint[] ) public sumsHash;\n', '\n', '    function forward(address payable to, address sender) public payable {\n', '        to.transfer(msg.value);\n', '        sendersHash[to].push(sender);\n', '        sumsHash[to].push(msg.value);\n', '    }\n', '\n', '    function getSendersHash(address user) public view returns (address[] memory) {\n', '        return sendersHash[user];\n', '    }\n', '\n', '    function getSumsHash(address user) public view returns (uint[] memory) {\n', '        return sumsHash[user];\n', '    }\n', '}']
['pragma solidity ^0.5.1;\n', '\n', 'contract VotingChallenge {\n', '    struct Team {\n', '        uint fullVotes;\n', '        uint weightedVotes;\n', '    }\n', '\n', '    struct Voter {\n', '        uint[2] fullVotes;\n', '        uint[2] weightedVotes;\n', '        address payable[2] referrers;\n', '    }\n', '\n', '    VotingChallengeForwarder forwarder;\n', '\n', '    uint public challengeDuration;\n', '    uint public challengeStarted;\n', '    address payable public creator;\n', '    uint16 public creatorFee = 17;       // measured in in tenths of a percent\n', '    address payable public cryptoVersusWallet = 0xa0bedE75cfeEF0266f8A31b47074F5f9fBE1df80;\n', '    uint16 public cryptoVersusFee = 53;  // measured in in tenths of a percent\n', '    uint public cryptoVersusPrize;\n', '    uint public challengePrize;\n', '    uint public winner;\n', '    bool public isVotingPeriod = false;\n', '    bool public beforeVoting = true;\n', '    Team[2] public teams;\n', '    mapping( address => Voter ) private voters;\n', '\n', '    modifier inVotingPeriod() {\n', '        require(isVotingPeriod);\n', '        _;\n', '    }\n', '\n', '    modifier afterVotingPeriod() {\n', '        require(!isVotingPeriod);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCreator() {\n', '        require(msg.sender == creator);\n', '        _;\n', '    }\n', '\n', '    event ChallengeBegins(address _creator, uint _challengeDuration);\n', '    event NewVotesFor(address _participant, uint _candidate, uint _votes, uint _coefficient);\n', '    event TransferVotes(address _from, address _to, uint _candidateIndex, uint _votes);\n', '    event EndOfChallenge(uint _winner, uint _winnerVotes, uint _challengePrize);\n', '    event RewardWasPaid(address _participant, uint _amount);\n', '    event ReferrerRewardWasPaid(address _via, address _to, uint amount);\n', '    event CreatorRewardWasPaid(address _creator, uint _amount);\n', '    event CryptoVersusRewardWasPaid(address _cryptoVersusWallet, uint _amount);\n', '\n', '    constructor(uint _challengeDuration, address _forwarder) public {\n', '        forwarder = VotingChallengeForwarder(_forwarder);\n', '        challengeDuration = _challengeDuration;\n', '        creator = msg.sender;\n', '    }\n', '\n', '    function getAllVotes() public view returns (uint[2] memory) {\n', '        return [ teams[0].fullVotes, teams[1].fullVotes ];\n', '    }\n', '\n', '    function currentCoefficient() public view returns (uint) {  // in 1/1000000\n', '        return 1000000 - 900000 * (now - challengeStarted) / challengeDuration;\n', '    }\n', '\n', '    function timeOver() public view returns (bool) {\n', '        return challengeStarted + challengeDuration <= now;\n', '    }\n', '\n', '    function startChallenge() public onlyCreator {\n', '        require(beforeVoting);\n', '        isVotingPeriod = true;\n', '        beforeVoting = false;\n', '        challengeStarted = now;\n', '\n', '        emit ChallengeBegins(creator, challengeDuration);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate) public payable inVotingPeriod {\n', '        require(0 <= candidate && candidate < 2);\n', '        require(msg.value > 0);\n', '        require(!timeOver());\n', '\n', '        uint coefficient = currentCoefficient();\n', '        uint weightedVotes = msg.value * coefficient / 1000000;\n', '        teams[candidate].fullVotes += msg.value;\n', '        teams[candidate].weightedVotes += weightedVotes;\n', '        voters[msg.sender].fullVotes[candidate] += msg.value;\n', '        voters[msg.sender].weightedVotes[candidate] += weightedVotes;\n', '\n', '        emit NewVotesFor(msg.sender, candidate, msg.value, coefficient);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate, address payable referrer1) public payable inVotingPeriod {\n', '        voters[msg.sender].referrers[0] = referrer1;\n', '        voteForCandidate(candidate);\n', '    }\n', '\n', '    function voteForCandidate(uint candidate, address payable referrer1, address payable referrer2) public payable inVotingPeriod {\n', '        voters[msg.sender].referrers[1] = referrer2;\n', '        voteForCandidate(candidate, referrer1);\n', '    }\n', '\n', '    function checkEndOfChallenge() public inVotingPeriod returns (bool) {\n', '        if (!timeOver())\n', '            return false;\n', '\n', '        if (teams[0].fullVotes > teams[1].fullVotes)\n', '            winner = 0;\n', '        else\n', '            winner = 1;\n', '\n', '        uint loser = 1 - winner;\n', '        creator.transfer((teams[loser].fullVotes * creatorFee) / 1000);\n', '        cryptoVersusPrize = (teams[loser].fullVotes * cryptoVersusFee) / 1000;\n', '        challengePrize = teams[loser].fullVotes * (1000 - creatorFee - cryptoVersusFee) / 1000;\n', '        isVotingPeriod = false;\n', '\n', '        emit EndOfChallenge(winner, teams[winner].fullVotes, challengePrize);\n', '        return true;\n', '    }\n', '\n', '    function sendReward(address payable to) public afterVotingPeriod {\n', '        uint winnerVotes = voters[to].weightedVotes[winner];\n', '        uint loserVotes = voters[to].fullVotes[1-winner];\n', '        address payable referrer1 = voters[to].referrers[0];\n', '        address payable referrer2 = voters[to].referrers[1];\n', '        uint sum;\n', '\n', '        if (winnerVotes > 0) {\n', '            uint reward = challengePrize * winnerVotes / teams[winner].weightedVotes;\n', '            to.transfer(reward + voters[to].fullVotes[winner]);\n', '            if (referrer1 != address(0)) {\n', '                sum = reward / 100 * 2;  // 2%\n', '                forwarder.forward.value(sum)(referrer1, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer1, sum);\n', '            }\n', '            if (referrer2 != address(0)) {\n', '                sum = reward / 1000 * 2;  // 0.2%\n', '                forwarder.forward.value(sum)(referrer2, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer2, sum);\n', '            }\n', '            voters[to].fullVotes[winner] = 0;\n', '            voters[to].weightedVotes[winner] = 0;\n', '            emit RewardWasPaid(to, reward);\n', '        }\n', '        if (loserVotes > 0) {\n', '            if (referrer1 != address(0)) {\n', '                sum = loserVotes / 100 * 1;  // 1%\n', '                forwarder.forward.value(sum)(referrer1, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer1, sum);\n', '            }\n', '            if (referrer2 != address(0)) {\n', '                sum = loserVotes / 1000 * 1;  // 0.1%\n', '                forwarder.forward.value(sum)(referrer2, to);\n', '                cryptoVersusPrize -= sum;\n', '                emit ReferrerRewardWasPaid(to, referrer2, sum);\n', '            }\n', '            voters[to].fullVotes[1-winner] = 0;\n', '            voters[to].weightedVotes[1-winner] = 0;\n', '        }\n', '    }\n', '\n', '    function sendCryptoVersusReward() public afterVotingPeriod {\n', '        if (cryptoVersusPrize > 0) {\n', '            uint cryptoVersusReward = cryptoVersusPrize;\n', '            cryptoVersusPrize = 0;\n', '            cryptoVersusWallet.transfer(cryptoVersusReward);\n', '\n', '            emit CryptoVersusRewardWasPaid(cryptoVersusWallet, cryptoVersusReward);\n', '        }\n', '    }\n', '}\n', '\n', 'contract VotingChallengeForwarder {\n', '    mapping ( address => address[] ) public sendersHash;\n', '    mapping ( address => uint[] ) public sumsHash;\n', '\n', '    function forward(address payable to, address sender) public payable {\n', '        to.transfer(msg.value);\n', '        sendersHash[to].push(sender);\n', '        sumsHash[to].push(msg.value);\n', '    }\n', '\n', '    function getSendersHash(address user) public view returns (address[] memory) {\n', '        return sendersHash[user];\n', '    }\n', '\n', '    function getSumsHash(address user) public view returns (uint[] memory) {\n', '        return sumsHash[user];\n', '    }\n', '}']
