['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t * @dev Multiplies two numbers, throws on overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '\t\t// Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '\t\t// benefit is lost if &#39;b&#39; is also tested.\n', '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tc = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Integer division of two numbers, truncating the quotient.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\t// uint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Adds two numbers, throws on overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '\t\tc = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', 'contract TheAO {\n', '\taddress public theAO;\n', '\taddress public nameTAOPositionAddress;\n', '\n', '\t// Check whether an address is whitelisted and granted access to transact\n', '\t// on behalf of others\n', '\tmapping (address => bool) public whitelist;\n', '\n', '\tconstructor() public {\n', '\t\ttheAO = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if msg.sender is in whitelist.\n', '\t */\n', '\tmodifier inWhitelist() {\n', '\t\trequire (whitelist[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '}\n', '\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '\n', '\n', '\n', 'contract TokenERC20 {\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals = 18;\n', '\t// 18 decimals is the strongly suggested default, avoid changing it\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\tmapping (address => uint256) public balanceOf;\n', '\tmapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply tokens to the creator of the contract\n', '\t */\n', '\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\n', '\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '\t\tname = tokenName;                                   // Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\n', '\t}\n', '\n', '\t/**\n', '\t * Internal transfer, only can be called by this contract\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint _value) internal {\n', '\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_to != 0x0);\n', '\t\t// Check if the sender has enough\n', '\t\trequire(balanceOf[_from] >= _value);\n', '\t\t// Check for overflows\n', '\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\n', '\t\t// Save this for an assertion in the future\n', '\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\t\t// Subtract from the sender\n', '\t\tbalanceOf[_from] -= _value;\n', '\t\t// Add the same to the recipient\n', '\t\tbalanceOf[_to] += _value;\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens\n', '\t *\n', '\t * Send `_value` tokens to `_to` from your account\n', '\t *\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens from other address\n', '\t *\n', '\t * Send `_value` tokens to `_to` in behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '\t\tallowance[_from][msg.sender] -= _value;\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address and notify\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t * @param _extraData some extra information to send to the approved contract\n', '\t */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly\n', '\t *\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '\t\ttotalSupply -= _value;                      // Updates totalSupply\n', '\t\temit Burn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens from other account\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '\t\ttotalSupply -= _value;                              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAOCurrency\n', ' */\n', 'contract TAOCurrency is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\n', '\t// To differentiate denomination of TAO Currency\n', '\tuint256 public powerOfTen;\n', '\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\t// address is the address of nameId, not the eth public address\n', '\tmapping (address => uint256) public balanceOf;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\t// address is the address of TAO/Name Id, not eth public address\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\t// address is the address of TAO/Name Id, not eth public address\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply tokens to the creator of the contract\n', '\t */\n', '\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\n', '\t\ttotalSupply = initialSupply;\t\t\t// Update total supply\n', '\t\tbalanceOf[msg.sender] = totalSupply;\t// Give the creator all initial tokens\n', '\t\tname = tokenName;\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;\t\t\t\t\t// Set the symbol for display purposes\n', '\n', '\t\tpowerOfTen = 0;\n', '\t\tdecimals = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_id` is a Name or a TAO\n', '\t */\n', '\tmodifier isNameOrTAO(address _id) {\n', '\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev transfer tokens from other address\n', '\t *\n', '\t * Send `_value` tokens to `_to` in behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public inWhitelist isNameOrTAO(_from) isNameOrTAO(_to) returns (bool) {\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` tokens and send it to `target`\n', '\t * @param target Address to receive the tokens\n', '\t * @param mintedAmount The amount of tokens it will receive\n', '\t * @return true on success\n', '\t */\n', '\tfunction mintToken(address target, uint256 mintedAmount) public inWhitelist isNameOrTAO(target) returns (bool) {\n', '\t\t_mintToken(target, mintedAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t *\n', '\t * @dev Whitelisted address remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\n', '\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Send `_value` tokens from `_from` to `_to`\n', '\t * @param _from The address of sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n', '\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n', '\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` tokens and send it to `target`\n', '\t * @param target Address to receive the tokens\n', '\t * @param mintedAmount The amount of tokens it will receive\n', '\t */\n', '\tfunction _mintToken(address target, uint256 mintedAmount) internal {\n', '\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\n', '\t\ttotalSupply = totalSupply.add(mintedAmount);\n', '\t\temit Transfer(0, this, mintedAmount);\n', '\t\temit Transfer(this, target, mintedAmount);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAO\n', ' */\n', 'contract TAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public vaultAddress;\n', '\tstring public name;\t\t\t\t// the name for this TAO\n', '\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it&#39;s the eth address\n', '\n', '\t// TAO&#39;s data\n', '\tstring public datHash;\n', '\tstring public database;\n', '\tstring public keyValue;\n', '\tbytes32 public contentId;\n', '\n', '\t/**\n', '\t * 0 = TAO\n', '\t * 1 = Name\n', '\t */\n', '\tuint8 public typeId;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string _name,\n', '\t\taddress _originId,\n', '\t\tstring _datHash,\n', '\t\tstring _database,\n', '\t\tstring _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _vaultAddress\n', '\t) public {\n', '\t\tname = _name;\n', '\t\toriginId = _originId;\n', '\t\tdatHash = _datHash;\n', '\t\tdatabase = _database;\n', '\t\tkeyValue = _keyValue;\n', '\t\tcontentId = _contentId;\n', '\n', '\t\t// Creating TAO\n', '\t\ttypeId = 0;\n', '\n', '\t\tvaultAddress = _vaultAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if calling address is Vault contract\n', '\t */\n', '\tmodifier onlyVault {\n', '\t\trequire (msg.sender == vaultAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferEth(address _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\t_recipient.transfer(_amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\n', '\t * @param _erc20TokenAddress The address of ERC20 Token\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\n', '\t\t_erc20.transfer(_recipient, _amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Position\n', ' */\n', 'contract Position is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals = 4;\n', '\n', '\tuint256 constant public MAX_SUPPLY_PER_NAME = 100 * (10 ** 4);\n', '\n', '\tuint256 public totalSupply;\n', '\n', '\t// Mapping from Name ID to bool value whether or not it has received Position Token\n', '\tmapping (address => bool) public receivedToken;\n', '\n', '\t// Mapping from Name ID to its total available balance\n', '\tmapping (address => uint256) public balanceOf;\n', '\n', '\t// Mapping from Name&#39;s TAO ID to its staked amount\n', '\tmapping (address => mapping(address => uint256)) public taoStakedBalance;\n', '\n', '\t// Mapping from TAO ID to its total staked amount\n', '\tmapping (address => uint256) public totalTAOStakedBalance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Mint(address indexed nameId, uint256 value);\n', '\tevent Stake(address indexed nameId, address indexed taoId, uint256 value);\n', '\tevent Unstake(address indexed nameId, address indexed taoId, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply tokens to the creator of the contract\n', '\t */\n', '\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\n', '\t\ttotalSupply = initialSupply;\t\t\t// Update total supply\n', '\t\tbalanceOf[msg.sender] = totalSupply;\t// Give the creator all initial tokens\n', '\t\tname = tokenName;\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;\t\t\t\t\t// Set the symbol for display purposes\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Create `MAX_SUPPLY_PER_NAME` tokens and send it to `_nameId`\n', '\t * @param _nameId Address to receive the tokens\n', '\t * @return true on success\n', '\t */\n', '\tfunction mintToken(address _nameId) public inWhitelist returns (bool) {\n', '\t\t// Make sure _nameId has not received Position Token\n', '\t\trequire (receivedToken[_nameId] == false);\n', '\n', '\t\treceivedToken[_nameId] = true;\n', '\t\tbalanceOf[_nameId] = balanceOf[_nameId].add(MAX_SUPPLY_PER_NAME);\n', '\t\ttotalSupply = totalSupply.add(MAX_SUPPLY_PER_NAME);\n', '\t\temit Mint(_nameId, MAX_SUPPLY_PER_NAME);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get staked balance of `_nameId`\n', '\t * @param _nameId The Name ID to be queried\n', '\t * @return total staked balance\n', '\t */\n', '\tfunction stakedBalance(address _nameId) public view returns (uint256) {\n', '\t\treturn MAX_SUPPLY_PER_NAME.sub(balanceOf[_nameId]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Stake `_value` tokens on `_taoId` from `_nameId`\n', '\t * @param _nameId The Name ID that wants to stake\n', '\t * @param _taoId The TAO ID to stake\n', '\t * @param _value The amount to stake\n', '\t * @return true on success\n', '\t */\n', '\tfunction stake(address _nameId, address _taoId, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (_value > 0 && _value <= MAX_SUPPLY_PER_NAME);\n', '\t\trequire (balanceOf[_nameId] >= _value);\t\t\t\t\t\t\t// Check if the targeted balance is enough\n', '\t\tbalanceOf[_nameId] = balanceOf[_nameId].sub(_value);\t\t\t// Subtract from the targeted balance\n', '\t\ttaoStakedBalance[_nameId][_taoId] = taoStakedBalance[_nameId][_taoId].add(_value);\t// Add to the targeted staked balance\n', '\t\ttotalTAOStakedBalance[_taoId] = totalTAOStakedBalance[_taoId].add(_value);\n', '\t\temit Stake(_nameId, _taoId, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Unstake `_value` tokens from `_nameId`&#39;s `_taoId`\n', '\t * @param _nameId The Name ID that wants to unstake\n', '\t * @param _taoId The TAO ID to unstake\n', '\t * @param _value The amount to unstake\n', '\t * @return true on success\n', '\t */\n', '\tfunction unstake(address _nameId, address _taoId, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (_value > 0 && _value <= MAX_SUPPLY_PER_NAME);\n', '\t\trequire (taoStakedBalance[_nameId][_taoId] >= _value);\t// Check if the targeted staked balance is enough\n', '\t\trequire (totalTAOStakedBalance[_taoId] >= _value);\t// Check if the total targeted staked balance is enough\n', '\t\ttaoStakedBalance[_nameId][_taoId] = taoStakedBalance[_nameId][_taoId].sub(_value);\t// Subtract from the targeted staked balance\n', '\t\ttotalTAOStakedBalance[_taoId] = totalTAOStakedBalance[_taoId].sub(_value);\n', '\t\tbalanceOf[_nameId] = balanceOf[_nameId].add(_value);\t\t\t// Add to the targeted balance\n', '\t\temit Unstake(_nameId, _taoId, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title NameTAOLookup\n', ' *\n', ' */\n', 'contract NameTAOLookup is TheAO {\n', '\taddress public nameFactoryAddress;\n', '\taddress public taoFactoryAddress;\n', '\n', '\tstruct NameTAOInfo {\n', '\t\tstring name;\n', '\t\taddress nameTAOAddress;\n', '\t\tstring parentName;\n', '\t\tuint256 typeId; // 0 = TAO. 1 = Name\n', '\t}\n', '\n', '\tuint256 public internalId;\n', '\tuint256 public totalNames;\n', '\tuint256 public totalTAOs;\n', '\n', '\tmapping (uint256 => NameTAOInfo) internal nameTAOInfos;\n', '\tmapping (bytes32 => uint256) internal internalIdLookup;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress) public {\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if calling address is Factory\n', '\t */\n', '\tmodifier onlyFactory {\n', '\t\trequire (msg.sender == nameFactoryAddress || msg.sender == taoFactoryAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the taoFactoryAddress Address\n', '\t * @param _taoFactoryAddress The address of TAOFactory\n', '\t */\n', '\tfunction setTAOFactoryAddress(address _taoFactoryAddress) public onlyTheAO {\n', '\t\trequire (_taoFactoryAddress != address(0));\n', '\t\ttaoFactoryAddress = _taoFactoryAddress;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Check whether or not a name exist in the list\n', '\t * @param _name The name to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isExist(string _name) public view returns (bool) {\n', '\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\n', '\t\treturn (internalIdLookup[_nameKey] > 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add a new NameTAOInfo\n', '\t * @param _name The name of the Name/TAO\n', '\t * @param _nameTAOAddress The address of the Name/TAO\n', '\t * @param _parentName The parent name of the Name/TAO\n', '\t * @param _typeId If TAO = 0. Name = 1\n', '\t * @return true on success\n', '\t */\n', '\tfunction add(string _name, address _nameTAOAddress, string _parentName, uint256 _typeId) public onlyFactory returns (bool) {\n', '\t\trequire (bytes(_name).length > 0);\n', '\t\trequire (_nameTAOAddress != address(0));\n', '\t\trequire (bytes(_parentName).length > 0);\n', '\t\trequire (_typeId == 0 || _typeId == 1);\n', '\t\trequire (!isExist(_name));\n', '\n', '\t\tinternalId++;\n', '\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\n', '\t\tinternalIdLookup[_nameKey] = internalId;\n', '\t\tNameTAOInfo storage _nameTAOInfo = nameTAOInfos[internalId];\n', '\t\t_nameTAOInfo.name = _name;\n', '\t\t_nameTAOInfo.nameTAOAddress = _nameTAOAddress;\n', '\t\t_nameTAOInfo.parentName = _parentName;\n', '\t\t_nameTAOInfo.typeId = _typeId;\n', '\n', '\t\tif (_typeId == 0) {\n', '\t\t\ttotalTAOs++;\n', '\t\t} else {\n', '\t\t\ttotalNames++;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the NameTAOInfo given a name\n', '\t * @param _name The name to be queried\n', '\t * @return the name of Name/TAO\n', '\t * @return the address of Name/TAO\n', '\t * @return the parent name of Name/TAO\n', '\t * @return type ID. 0 = TAO. 1 = Name\n', '\t */\n', '\tfunction getByName(string _name) public view returns (string, address, string, uint256) {\n', '\t\trequire (isExist(_name));\n', '\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\n', '\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[internalIdLookup[_nameKey]];\n', '\t\treturn (\n', '\t\t\t_nameTAOInfo.name,\n', '\t\t\t_nameTAOInfo.nameTAOAddress,\n', '\t\t\t_nameTAOInfo.parentName,\n', '\t\t\t_nameTAOInfo.typeId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the NameTAOInfo given an ID\n', '\t * @param _internalId The internal ID to be queried\n', '\t * @return the name of Name/TAO\n', '\t * @return the address of Name/TAO\n', '\t * @return the parent name of Name/TAO\n', '\t * @return type ID. 0 = TAO. 1 = Name\n', '\t */\n', '\tfunction getByInternalId(uint256 _internalId) public view returns (string, address, string, uint256) {\n', '\t\trequire (nameTAOInfos[_internalId].nameTAOAddress != address(0));\n', '\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[_internalId];\n', '\t\treturn (\n', '\t\t\t_nameTAOInfo.name,\n', '\t\t\t_nameTAOInfo.nameTAOAddress,\n', '\t\t\t_nameTAOInfo.parentName,\n', '\t\t\t_nameTAOInfo.typeId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the nameTAOAddress given a _name\n', '\t * @param _name The name to be queried\n', '\t * @return the nameTAOAddress of the name\n', '\t */\n', '\tfunction getAddressByName(string _name) public view returns (address) {\n', '\t\trequire (isExist(_name));\n', '\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\n', '\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[internalIdLookup[_nameKey]];\n', '\t\treturn _nameTAOInfo.nameTAOAddress;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title NamePublicKey\n', ' */\n', 'contract NamePublicKey {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public nameFactoryAddress;\n', '\n', '\tNameFactory internal _nameFactory;\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\n', '\tstruct PublicKey {\n', '\t\tbool created;\n', '\t\taddress defaultKey;\n', '\t\taddress[] keys;\n', '\t}\n', '\n', '\t// Mapping from nameId to its PublicKey\n', '\tmapping (address => PublicKey) internal publicKeys;\n', '\n', '\t// Event to be broadcasted to public when a publicKey is added to a Name\n', '\tevent AddKey(address indexed nameId, address publicKey, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when a publicKey is removed from a Name\n', '\tevent RemoveKey(address indexed nameId, address publicKey, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when a publicKey is set as default for a Name\n', '\tevent SetDefaultKey(address indexed nameId, address publicKey, uint256 nonce);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress) public {\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\n', '\t\t_nameFactory = NameFactory(_nameFactoryAddress);\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if calling address is Factory\n', '\t */\n', '\tmodifier onlyFactory {\n', '\t\trequire (msg.sender == nameFactoryAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of Name ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Check whether or not a Name ID exist in the list of Public Keys\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isExist(address _id) public view returns (bool) {\n', '\t\treturn publicKeys[_id].created;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store the PublicKey info for a Name\n', '\t * @param _id The ID of the Name\n', '\t * @param _defaultKey The default public key for this Name\n', '\t * @return true on success\n', '\t */\n', '\tfunction add(address _id, address _defaultKey)\n', '\t\tpublic\n', '\t\tisName(_id)\n', '\t\tonlyFactory returns (bool) {\n', '\t\trequire (!isExist(_id));\n', '\t\trequire (_defaultKey != address(0));\n', '\n', '\t\tPublicKey storage _publicKey = publicKeys[_id];\n', '\t\t_publicKey.created = true;\n', '\t\t_publicKey.defaultKey = _defaultKey;\n', '\t\t_publicKey.keys.push(_defaultKey);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get total publicKeys count for a Name\n', '\t * @param _id The ID of the Name\n', '\t * @return total publicKeys count\n', '\t */\n', '\tfunction getTotalPublicKeysCount(address _id) public isName(_id) view returns (uint256) {\n', '\t\trequire (isExist(_id));\n', '\t\treturn publicKeys[_id].keys.length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not a publicKey exist in the list for a Name\n', '\t * @param _id The ID of the Name\n', '\t * @param _key The publicKey to check\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isKeyExist(address _id, address _key) isName(_id) public view returns (bool) {\n', '\t\trequire (isExist(_id));\n', '\t\trequire (_key != address(0));\n', '\n', '\t\tPublicKey memory _publicKey = publicKeys[_id];\n', '\t\tfor (uint256 i = 0; i < _publicKey.keys.length; i++) {\n', '\t\t\tif (_publicKey.keys[i] == _key) {\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add publicKey to list for a Name\n', '\t * @param _id The ID of the Name\n', '\t * @param _key The publicKey to be added\n', '\t */\n', '\tfunction addKey(address _id, address _key) public isName(_id) onlyAdvocate(_id) {\n', '\t\trequire (!isKeyExist(_id, _key));\n', '\n', '\t\tPublicKey storage _publicKey = publicKeys[_id];\n', '\t\t_publicKey.keys.push(_key);\n', '\n', '\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit AddKey(_id, _key, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get default public key of a Name\n', '\t * @param _id The ID of the Name\n', '\t * @return the default public key\n', '\t */\n', '\tfunction getDefaultKey(address _id) public isName(_id) view returns (address) {\n', '\t\trequire (isExist(_id));\n', '\t\treturn publicKeys[_id].defaultKey;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get list of publicKeys of a Name\n', '\t * @param _id The ID of the Name\n', '\t * @param _from The starting index\n', '\t * @param _to The ending index\n', '\t * @return list of publicKeys\n', '\t */\n', '\tfunction getKeys(address _id, uint256 _from, uint256 _to) public isName(_id) view returns (address[]) {\n', '\t\trequire (isExist(_id));\n', '\t\trequire (_from >= 0 && _to >= _from);\n', '\n', '\t\tPublicKey memory _publicKey = publicKeys[_id];\n', '\t\trequire (_publicKey.keys.length > 0);\n', '\n', '\t\taddress[] memory _keys = new address[](_to.sub(_from).add(1));\n', '\t\tif (_to > _publicKey.keys.length.sub(1)) {\n', '\t\t\t_to = _publicKey.keys.length.sub(1);\n', '\t\t}\n', '\t\tfor (uint256 i = _from; i <= _to; i++) {\n', '\t\t\t_keys[i.sub(_from)] = _publicKey.keys[i];\n', '\t\t}\n', '\t\treturn _keys;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Remove publicKey from the list\n', '\t * @param _id The ID of the Name\n', '\t * @param _key The publicKey to be removed\n', '\t */\n', '\tfunction removeKey(address _id, address _key) public isName(_id) onlyAdvocate(_id) {\n', '\t\trequire (isExist(_id));\n', '\t\trequire (isKeyExist(_id, _key));\n', '\n', '\t\tPublicKey storage _publicKey = publicKeys[_id];\n', '\n', '\t\t// Can&#39;t remove default key\n', '\t\trequire (_key != _publicKey.defaultKey);\n', '\t\trequire (_publicKey.keys.length > 1);\n', '\n', '\t\tfor (uint256 i = 0; i < _publicKey.keys.length; i++) {\n', '\t\t\tif (_publicKey.keys[i] == _key) {\n', '\t\t\t\tdelete _publicKey.keys[i];\n', '\t\t\t\t_publicKey.keys.length--;\n', '\n', '\t\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit RemoveKey(_id, _key, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set a publicKey as the default for a Name\n', '\t * @param _id The ID of the Name\n', '\t * @param _defaultKey The defaultKey to be set\n', '\t * @param _signatureV The V part of the signature for this update\n', '\t * @param _signatureR The R part of the signature for this update\n', '\t * @param _signatureS The S part of the signature for this update\n', '\t */\n', '\tfunction setDefaultKey(address _id, address _defaultKey, uint8 _signatureV, bytes32 _signatureR, bytes32 _signatureS) public isName(_id) onlyAdvocate(_id) {\n', '\t\trequire (isExist(_id));\n', '\t\trequire (isKeyExist(_id, _defaultKey));\n', '\n', '\t\tbytes32 _hash = keccak256(abi.encodePacked(address(this), _id, _defaultKey));\n', '\t\trequire (ecrecover(_hash, _signatureV, _signatureR, _signatureS) == msg.sender);\n', '\n', '\t\tPublicKey storage _publicKey = publicKeys[_id];\n', '\t\t_publicKey.defaultKey = _defaultKey;\n', '\n', '\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\n', '\t\trequire (_nonce > 0);\n', '\t\temit SetDefaultKey(_id, _defaultKey, _nonce);\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title NameFactory\n', ' *\n', ' * The purpose of this contract is to allow node to create Name\n', ' */\n', 'contract NameFactory is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public positionAddress;\n', '\taddress public nameTAOVaultAddress;\n', '\taddress public nameTAOLookupAddress;\n', '\taddress public namePublicKeyAddress;\n', '\n', '\tPosition internal _position;\n', '\tNameTAOLookup internal _nameTAOLookup;\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\tNamePublicKey internal _namePublicKey;\n', '\n', '\taddress[] internal names;\n', '\n', '\t// Mapping from eth address to Name ID\n', '\tmapping (address => address) public ethAddressToNameId;\n', '\n', '\t// Mapping from Name ID to its nonce\n', '\tmapping (address => uint256) public nonces;\n', '\n', '\t// Event to be broadcasted to public when a Name is created\n', '\tevent CreateName(address indexed ethAddress, address nameId, uint256 index, string name);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _positionAddress, address _nameTAOVaultAddress) public {\n', '\t\tpositionAddress = _positionAddress;\n', '\t\tnameTAOVaultAddress = _nameTAOVaultAddress;\n', '\t\t_position = Position(positionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if calling address can update Name&#39;s nonce\n', '\t */\n', '\tmodifier canUpdateNonce {\n', '\t\trequire (msg.sender == nameTAOPositionAddress || msg.sender == namePublicKeyAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameTAOLookup Address\n', '\t * @param _nameTAOLookupAddress The address of NameTAOLookup\n', '\t */\n', '\tfunction setNameTAOLookupAddress(address _nameTAOLookupAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOLookupAddress != address(0));\n', '\t\tnameTAOLookupAddress = _nameTAOLookupAddress;\n', '\t\t_nameTAOLookup = NameTAOLookup(nameTAOLookupAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = NameTAOPosition(nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NamePublicKey Address\n', '\t * @param _namePublicKeyAddress The address of NamePublicKey\n', '\t */\n', '\tfunction setNamePublicKeyAddress(address _namePublicKeyAddress) public onlyTheAO {\n', '\t\trequire (_namePublicKeyAddress != address(0));\n', '\t\tnamePublicKeyAddress = _namePublicKeyAddress;\n', '\t\t_namePublicKey = NamePublicKey(namePublicKeyAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Increment the nonce of a Name\n', '\t * @param _nameId The ID of the Name\n', '\t * @return current nonce\n', '\t */\n', '\tfunction incrementNonce(address _nameId) public canUpdateNonce returns (uint256) {\n', '\t\t// Check if _nameId exist\n', '\t\trequire (nonces[_nameId] > 0);\n', '\t\tnonces[_nameId]++;\n', '\t\treturn nonces[_nameId];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create a Name\n', '\t * @param _name The name of the Name\n', '\t * @param _datHash The datHash to this Name&#39;s profile\n', '\t * @param _database The database for this Name\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this Name\n', '\t */\n', '\tfunction createName(string _name, string _datHash, string _database, string _keyValue, bytes32 _contentId) public {\n', '\t\trequire (bytes(_name).length > 0);\n', '\t\trequire (!_nameTAOLookup.isExist(_name));\n', '\n', '\t\t// Only one Name per ETH address\n', '\t\trequire (ethAddressToNameId[msg.sender] == address(0));\n', '\n', '\t\t// The address is the Name ID (which is also a TAO ID)\n', '\t\taddress nameId = new Name(_name, msg.sender, _datHash, _database, _keyValue, _contentId, nameTAOVaultAddress);\n', '\n', '\t\t// Increment the nonce\n', '\t\tnonces[nameId]++;\n', '\n', '\t\tethAddressToNameId[msg.sender] = nameId;\n', '\n', '\t\t// Store the name lookup information\n', '\t\trequire (_nameTAOLookup.add(_name, nameId, &#39;human&#39;, 1));\n', '\n', '\t\t// Store the Advocate/Listener/Speaker information\n', '\t\trequire (_nameTAOPosition.add(nameId, nameId, nameId, nameId));\n', '\n', '\t\t// Store the public key information\n', '\t\trequire (_namePublicKey.add(nameId, msg.sender));\n', '\n', '\t\tnames.push(nameId);\n', '\n', '\t\t// Need to mint Position token for this Name\n', '\t\trequire (_position.mintToken(nameId));\n', '\n', '\t\temit CreateName(msg.sender, nameId, names.length.sub(1), _name);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Name information\n', '\t * @param _nameId The ID of the Name to be queried\n', '\t * @return The name of the Name\n', '\t * @return The originId of the Name (in this case, it&#39;s the creator node&#39;s ETH address)\n', '\t * @return The datHash of the Name\n', '\t * @return The database of the Name\n', '\t * @return The keyValue of the Name\n', '\t * @return The contentId of the Name\n', '\t * @return The typeId of the Name\n', '\t */\n', '\tfunction getName(address _nameId) public view returns (string, address, string, string, string, bytes32, uint8) {\n', '\t\tName _name = Name(_nameId);\n', '\t\treturn (\n', '\t\t\t_name.name(),\n', '\t\t\t_name.originId(),\n', '\t\t\t_name.datHash(),\n', '\t\t\t_name.database(),\n', '\t\t\t_name.keyValue(),\n', '\t\t\t_name.contentId(),\n', '\t\t\t_name.typeId()\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get total Names count\n', '\t * @return total Names count\n', '\t */\n', '\tfunction getTotalNamesCount() public view returns (uint256) {\n', '\t\treturn names.length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get list of Name IDs\n', '\t * @param _from The starting index\n', '\t * @param _to The ending index\n', '\t * @return list of Name IDs\n', '\t */\n', '\tfunction getNameIds(uint256 _from, uint256 _to) public view returns (address[]) {\n', '\t\trequire (_from >= 0 && _to >= _from);\n', '\t\trequire (names.length > 0);\n', '\n', '\t\taddress[] memory _names = new address[](_to.sub(_from).add(1));\n', '\t\tif (_to > names.length.sub(1)) {\n', '\t\t\t_to = names.length.sub(1);\n', '\t\t}\n', '\t\tfor (uint256 i = _from; i <= _to; i++) {\n', '\t\t\t_names[i.sub(_from)] = names[i];\n', '\t\t}\n', '\t\treturn _names;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the signature is valid\n', '\t * @param _data The signed string data\n', '\t * @param _nonce The signed uint256 nonce (should be Name&#39;s current nonce + 1)\n', '\t * @param _validateAddress The ETH address to be validated (optional)\n', '\t * @param _name The name of the Name\n', '\t * @param _signatureV The V part of the signature\n', '\t * @param _signatureR The R part of the signature\n', '\t * @param _signatureS The S part of the signature\n', '\t * @return true if valid. false otherwise\n', '\t */\n', '\tfunction validateNameSignature(\n', '\t\tstring _data,\n', '\t\tuint256 _nonce,\n', '\t\taddress _validateAddress,\n', '\t\tstring _name,\n', '\t\tuint8 _signatureV,\n', '\t\tbytes32 _signatureR,\n', '\t\tbytes32 _signatureS\n', '\t) public view returns (bool) {\n', '\t\trequire (_nameTAOLookup.isExist(_name));\n', '\t\taddress _nameId = _nameTAOLookup.getAddressByName(_name);\n', '\t\taddress _signatureAddress = AOLibrary.getValidateSignatureAddress(address(this), _data, _nonce, _signatureV, _signatureR, _signatureS);\n', '\t\tif (_validateAddress != address(0)) {\n', '\t\t\treturn (\n', '\t\t\t\t_nonce == nonces[_nameId].add(1) &&\n', '\t\t\t\t_signatureAddress == _validateAddress &&\n', '\t\t\t\t_namePublicKey.isKeyExist(_nameId, _validateAddress)\n', '\t\t\t);\n', '\t\t} else {\n', '\t\t\treturn (\n', '\t\t\t\t_nonce == nonces[_nameId].add(1) &&\n', '\t\t\t\t_signatureAddress == _namePublicKey.getDefaultKey(_nameId)\n', '\t\t\t);\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOStringSetting\n', ' *\n', ' * This contract stores all AO string setting variables\n', ' */\n', 'contract AOStringSetting is TheAO {\n', '\t// Mapping from settingId to it&#39;s actual string value\n', '\tmapping (uint256 => string) public settingValue;\n', '\n', '\t// Mapping from settingId to it&#39;s potential string value that is at pending state\n', '\tmapping (uint256 => string) public pendingValue;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Set pending value\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _value The string value to be set\n', '\t */\n', '\tfunction setPendingValue(uint256 _settingId, string _value) public inWhitelist {\n', '\t\tpendingValue[_settingId] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value from pending to setting\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\n', '\t\tstring memory _tempValue = pendingValue[_settingId];\n', '\t\tdelete pendingValue[_settingId];\n', '\t\tsettingValue[_settingId] = _tempValue;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOBytesSetting\n', ' *\n', ' * This contract stores all AO bytes32 setting variables\n', ' */\n', 'contract AOBytesSetting is TheAO {\n', '\t// Mapping from settingId to it&#39;s actual bytes32 value\n', '\tmapping (uint256 => bytes32) public settingValue;\n', '\n', '\t// Mapping from settingId to it&#39;s potential bytes32 value that is at pending state\n', '\tmapping (uint256 => bytes32) public pendingValue;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Set pending value\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _value The bytes32 value to be set\n', '\t */\n', '\tfunction setPendingValue(uint256 _settingId, bytes32 _value) public inWhitelist {\n', '\t\tpendingValue[_settingId] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value from pending to setting\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\n', '\t\tbytes32 _tempValue = pendingValue[_settingId];\n', '\t\tdelete pendingValue[_settingId];\n', '\t\tsettingValue[_settingId] = _tempValue;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOAddressSetting\n', ' *\n', ' * This contract stores all AO address setting variables\n', ' */\n', 'contract AOAddressSetting is TheAO {\n', '\t// Mapping from settingId to it&#39;s actual address value\n', '\tmapping (uint256 => address) public settingValue;\n', '\n', '\t// Mapping from settingId to it&#39;s potential address value that is at pending state\n', '\tmapping (uint256 => address) public pendingValue;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Set pending value\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _value The address value to be set\n', '\t */\n', '\tfunction setPendingValue(uint256 _settingId, address _value) public inWhitelist {\n', '\t\tpendingValue[_settingId] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value from pending to setting\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\n', '\t\taddress _tempValue = pendingValue[_settingId];\n', '\t\tdelete pendingValue[_settingId];\n', '\t\tsettingValue[_settingId] = _tempValue;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOBoolSetting\n', ' *\n', ' * This contract stores all AO bool setting variables\n', ' */\n', 'contract AOBoolSetting is TheAO {\n', '\t// Mapping from settingId to it&#39;s actual bool value\n', '\tmapping (uint256 => bool) public settingValue;\n', '\n', '\t// Mapping from settingId to it&#39;s potential bool value that is at pending state\n', '\tmapping (uint256 => bool) public pendingValue;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Set pending value\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _value The bool value to be set\n', '\t */\n', '\tfunction setPendingValue(uint256 _settingId, bool _value) public inWhitelist {\n', '\t\tpendingValue[_settingId] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value from pending to setting\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\n', '\t\tbool _tempValue = pendingValue[_settingId];\n', '\t\tdelete pendingValue[_settingId];\n', '\t\tsettingValue[_settingId] = _tempValue;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOUintSetting\n', ' *\n', ' * This contract stores all AO uint256 setting variables\n', ' */\n', 'contract AOUintSetting is TheAO {\n', '\t// Mapping from settingId to it&#39;s actual uint256 value\n', '\tmapping (uint256 => uint256) public settingValue;\n', '\n', '\t// Mapping from settingId to it&#39;s potential uint256 value that is at pending state\n', '\tmapping (uint256 => uint256) public pendingValue;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Set pending value\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _value The uint256 value to be set\n', '\t */\n', '\tfunction setPendingValue(uint256 _settingId, uint256 _value) public inWhitelist {\n', '\t\tpendingValue[_settingId] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value from pending to setting\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\n', '\t\tuint256 _tempValue = pendingValue[_settingId];\n', '\t\tdelete pendingValue[_settingId];\n', '\t\tsettingValue[_settingId] = _tempValue;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOSettingAttribute\n', ' *\n', ' * This contract stores all AO setting data/state\n', ' */\n', 'contract AOSettingAttribute is TheAO {\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\n', '\tstruct SettingData {\n', '\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\n', '\t\taddress creatorNameId;\t\t\t// The nameId that created the setting\n', '\t\taddress creatorTAOId;\t\t// The taoId that created the setting\n', '\t\taddress associatedTAOId;\t// The taoId that the setting affects\n', '\t\tstring settingName;\t\t\t\t// The human-readable name of the setting\n', '\t\t/**\n', '\t\t * 1 => uint256\n', '\t\t * 2 => bool\n', '\t\t * 3 => address\n', '\t\t * 4 => bytes32\n', '\t\t * 5 => string (catch all)\n', '\t\t */\n', '\t\tuint8 settingType;\n', '\t\tbool pendingCreate;\t\t\t\t// State when associatedTAOId has not accepted setting\n', '\t\tbool locked;\t\t\t\t\t// State when pending anything (cannot change if locked)\n', '\t\tbool rejected;\t\t\t\t\t// State when associatedTAOId rejected this setting\n', '\t\tstring settingDataJSON;\t\t\t// Catch-all\n', '\t}\n', '\n', '\tstruct SettingState {\n', '\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\n', '\t\tbool pendingUpdate;\t\t\t\t// State when setting is in process of being updated\n', '\t\taddress updateAdvocateNameId;\t// The nameId of the Advocate that performed the update\n', '\n', '\t\t/**\n', '\t\t * A child of the associatedTAOId with the update Logos.\n', '\t\t * This tells the setting contract that there is a proposal TAO that is a Child TAO\n', '\t\t * of the associated TAO, which will be responsible for deciding if the update to the\n', '\t\t * setting is accepted or rejected.\n', '\t\t */\n', '\t\taddress proposalTAOId;\n', '\n', '\t\t/**\n', '\t\t * Signature of the proposalTAOId and update value by the associatedTAOId\n', '\t\t * Advocate&#39;s Name&#39;s address.\n', '\t\t */\n', '\t\tstring updateSignature;\n', '\n', '\t\t/**\n', '\t\t * The proposalTAOId moves here when setting value changes successfully\n', '\t\t */\n', '\t\taddress lastUpdateTAOId;\n', '\n', '\t\tstring settingStateJSON;\t\t// Catch-all\n', '\t}\n', '\n', '\tstruct SettingDeprecation {\n', '\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\n', '\t\taddress creatorNameId;\t\t\t// The nameId that created this deprecation\n', '\t\taddress creatorTAOId;\t\t// The taoId that created this deprecation\n', '\t\taddress associatedTAOId;\t// The taoId that the setting affects\n', '\t\tbool pendingDeprecated;\t\t\t// State when associatedTAOId has not accepted setting\n', '\t\tbool locked;\t\t\t\t\t// State when pending anything (cannot change if locked)\n', '\t\tbool rejected;\t\t\t\t\t// State when associatedTAOId rejected this setting\n', '\t\tbool migrated;\t\t\t\t\t// State when this setting is fully migrated\n', '\n', '\t\t// holds the pending new settingId value when a deprecation is set\n', '\t\tuint256 pendingNewSettingId;\n', '\n', '\t\t// holds the new settingId that has been approved by associatedTAOId\n', '\t\tuint256 newSettingId;\n', '\n', '\t\t// holds the pending new contract address for this setting\n', '\t\taddress pendingNewSettingContractAddress;\n', '\n', '\t\t// holds the new contract address for this setting\n', '\t\taddress newSettingContractAddress;\n', '\t}\n', '\n', '\tstruct AssociatedTAOSetting {\n', '\t\tbytes32 associatedTAOSettingId;\t\t// Identifier\n', '\t\taddress associatedTAOId;\t\t\t// The TAO ID that the setting is associated to\n', '\t\tuint256 settingId;\t\t\t\t\t\t// The Setting ID that is associated with the TAO ID\n', '\t}\n', '\n', '\tstruct CreatorTAOSetting {\n', '\t\tbytes32 creatorTAOSettingId;\t\t// Identifier\n', '\t\taddress creatorTAOId;\t\t\t\t// The TAO ID that the setting was created from\n', '\t\tuint256 settingId;\t\t\t\t\t\t// The Setting ID created from the TAO ID\n', '\t}\n', '\n', '\tstruct AssociatedTAOSettingDeprecation {\n', '\t\tbytes32 associatedTAOSettingDeprecationId;\t\t// Identifier\n', '\t\taddress associatedTAOId;\t\t\t\t\t\t// The TAO ID that the setting is associated to\n', '\t\tuint256 settingId;\t\t\t\t\t\t\t\t\t// The Setting ID that is associated with the TAO ID\n', '\t}\n', '\n', '\tstruct CreatorTAOSettingDeprecation {\n', '\t\tbytes32 creatorTAOSettingDeprecationId;\t\t\t// Identifier\n', '\t\taddress creatorTAOId;\t\t\t\t\t\t\t// The TAO ID that the setting was created from\n', '\t\tuint256 settingId;\t\t\t\t\t\t\t\t\t// The Setting ID created from the TAO ID\n', '\t}\n', '\n', '\t// Mapping from settingId to it&#39;s data\n', '\tmapping (uint256 => SettingData) internal settingDatas;\n', '\n', '\t// Mapping from settingId to it&#39;s state\n', '\tmapping (uint256 => SettingState) internal settingStates;\n', '\n', '\t// Mapping from settingId to it&#39;s deprecation info\n', '\tmapping (uint256 => SettingDeprecation) internal settingDeprecations;\n', '\n', '\t// Mapping from associatedTAOSettingId to AssociatedTAOSetting\n', '\tmapping (bytes32 => AssociatedTAOSetting) internal associatedTAOSettings;\n', '\n', '\t// Mapping from creatorTAOSettingId to CreatorTAOSetting\n', '\tmapping (bytes32 => CreatorTAOSetting) internal creatorTAOSettings;\n', '\n', '\t// Mapping from associatedTAOSettingDeprecationId to AssociatedTAOSettingDeprecation\n', '\tmapping (bytes32 => AssociatedTAOSettingDeprecation) internal associatedTAOSettingDeprecations;\n', '\n', '\t// Mapping from creatorTAOSettingDeprecationId to CreatorTAOSettingDeprecation\n', '\tmapping (bytes32 => CreatorTAOSettingDeprecation) internal creatorTAOSettingDeprecations;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameTAOPositionAddress) public {\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add setting data/state\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _creatorNameId The nameId that created the setting\n', '\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t * @return The ID of the "Associated" setting\n', '\t * @return The ID of the "Creator" setting\n', '\t */\n', '\tfunction add(uint256 _settingId, address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) public inWhitelist returns (bytes32, bytes32) {\n', '\t\t// Store setting data/state\n', '\t\trequire (_storeSettingDataState(_settingId, _creatorNameId, _settingType, _settingName, _creatorTAOId, _associatedTAOId, _extraData));\n', '\n', '\t\t// Store the associatedTAOSetting info\n', '\t\tbytes32 _associatedTAOSettingId = keccak256(abi.encodePacked(this, _associatedTAOId, _settingId));\n', '\t\tAssociatedTAOSetting storage _associatedTAOSetting = associatedTAOSettings[_associatedTAOSettingId];\n', '\t\t_associatedTAOSetting.associatedTAOSettingId = _associatedTAOSettingId;\n', '\t\t_associatedTAOSetting.associatedTAOId = _associatedTAOId;\n', '\t\t_associatedTAOSetting.settingId = _settingId;\n', '\n', '\t\t// Store the creatorTAOSetting info\n', '\t\tbytes32 _creatorTAOSettingId = keccak256(abi.encodePacked(this, _creatorTAOId, _settingId));\n', '\t\tCreatorTAOSetting storage _creatorTAOSetting = creatorTAOSettings[_creatorTAOSettingId];\n', '\t\t_creatorTAOSetting.creatorTAOSettingId = _creatorTAOSettingId;\n', '\t\t_creatorTAOSetting.creatorTAOId = _creatorTAOId;\n', '\t\t_creatorTAOSetting.settingId = _settingId;\n', '\n', '\t\treturn (_associatedTAOSettingId, _creatorTAOSettingId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Setting Data of a setting ID\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction getSettingData(uint256 _settingId) public view returns (uint256, address, address, address, string, uint8, bool, bool, bool, string) {\n', '\t\tSettingData memory _settingData = settingDatas[_settingId];\n', '\t\treturn (\n', '\t\t\t_settingData.settingId,\n', '\t\t\t_settingData.creatorNameId,\n', '\t\t\t_settingData.creatorTAOId,\n', '\t\t\t_settingData.associatedTAOId,\n', '\t\t\t_settingData.settingName,\n', '\t\t\t_settingData.settingType,\n', '\t\t\t_settingData.pendingCreate,\n', '\t\t\t_settingData.locked,\n', '\t\t\t_settingData.rejected,\n', '\t\t\t_settingData.settingDataJSON\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Associated TAO Setting info\n', '\t * @param _associatedTAOSettingId The ID of the associated tao setting\n', '\t */\n', '\tfunction getAssociatedTAOSetting(bytes32 _associatedTAOSettingId) public view returns (bytes32, address, uint256) {\n', '\t\tAssociatedTAOSetting memory _associatedTAOSetting = associatedTAOSettings[_associatedTAOSettingId];\n', '\t\treturn (\n', '\t\t\t_associatedTAOSetting.associatedTAOSettingId,\n', '\t\t\t_associatedTAOSetting.associatedTAOId,\n', '\t\t\t_associatedTAOSetting.settingId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Creator TAO Setting info\n', '\t * @param _creatorTAOSettingId The ID of the creator tao setting\n', '\t */\n', '\tfunction getCreatorTAOSetting(bytes32 _creatorTAOSettingId) public view returns (bytes32, address, uint256) {\n', '\t\tCreatorTAOSetting memory _creatorTAOSetting = creatorTAOSettings[_creatorTAOSettingId];\n', '\t\treturn (\n', '\t\t\t_creatorTAOSetting.creatorTAOSettingId,\n', '\t\t\t_creatorTAOSetting.creatorTAOId,\n', '\t\t\t_creatorTAOSetting.settingId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId approves setting creation\n', '\t * @param _settingId The ID of the setting to approve\n', '\t * @param _associatedTAOAdvocate The advocate of the associated TAO\n', '\t * @param _approved Whether to approve or reject\n', '\t * @return true on success\n', '\t */\n', '\tfunction approveAdd(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting exists and needs approval\n', '\t\tSettingData storage _settingData = settingDatas[_settingId];\n', '\t\trequire (_settingData.settingId == _settingId &&\n', '\t\t\t_settingData.pendingCreate == true &&\n', '\t\t\t_settingData.locked == true &&\n', '\t\t\t_settingData.rejected == false &&\n', '\t\t\t_associatedTAOAdvocate != address(0) &&\n', '\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId)\n', '\t\t);\n', '\n', '\t\tif (_approved) {\n', '\t\t\t// Unlock the setting so that advocate of creatorTAOId can finalize the creation\n', '\t\t\t_settingData.locked = false;\n', '\t\t} else {\n', '\t\t\t// Reject the setting\n', '\t\t\t_settingData.pendingCreate = false;\n', '\t\t\t_settingData.rejected = true;\n', '\t\t}\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _creatorTAOId finalizes the setting creation once the setting is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t * @param _creatorTAOAdvocate The advocate of the creator TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction finalizeAdd(uint256 _settingId, address _creatorTAOAdvocate) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting exists and needs approval\n', '\t\tSettingData storage _settingData = settingDatas[_settingId];\n', '\t\trequire (_settingData.settingId == _settingId &&\n', '\t\t\t_settingData.pendingCreate == true &&\n', '\t\t\t_settingData.locked == false &&\n', '\t\t\t_settingData.rejected == false &&\n', '\t\t\t_creatorTAOAdvocate != address(0) &&\n', '\t\t\t_creatorTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.creatorTAOId)\n', '\t\t);\n', '\n', '\t\t// Update the setting data\n', '\t\t_settingData.pendingCreate = false;\n', '\t\t_settingData.locked = true;\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store setting update data\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _settingType The type of this setting\n', '\t * @param _associatedTAOAdvocate The setting&#39;s associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by _associatedTAOAdvocate\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t * @return true on success\n', '\t */\n', '\tfunction update(uint256 _settingId, uint8 _settingType, address _associatedTAOAdvocate, address _proposalTAOId, string _updateSignature, string _extraData) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting is created\n', '\t\tSettingData memory _settingData = settingDatas[_settingId];\n', '\t\trequire (_settingData.settingId == _settingId &&\n', '\t\t\t_settingData.settingType == _settingType &&\n', '\t\t\t_settingData.pendingCreate == false &&\n', '\t\t\t_settingData.locked == true &&\n', '\t\t\t_settingData.rejected == false &&\n', '\t\t\t_associatedTAOAdvocate != address(0) &&\n', '\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId) &&\n', '\t\t\tbytes(_updateSignature).length > 0\n', '\t\t);\n', '\n', '\t\t// Make sure setting is not in the middle of updating\n', '\t\tSettingState storage _settingState = settingStates[_settingId];\n', '\t\trequire (_settingState.pendingUpdate == false);\n', '\n', '\t\t// Make sure setting is not yet deprecated\n', '\t\tSettingDeprecation memory _settingDeprecation = settingDeprecations[_settingId];\n', '\t\tif (_settingDeprecation.settingId == _settingId) {\n', '\t\t\trequire (_settingDeprecation.migrated == false);\n', '\t\t}\n', '\n', '\t\t// Store the SettingState data\n', '\t\t_settingState.pendingUpdate = true;\n', '\t\t_settingState.updateAdvocateNameId = _associatedTAOAdvocate;\n', '\t\t_settingState.proposalTAOId = _proposalTAOId;\n', '\t\t_settingState.updateSignature = _updateSignature;\n', '\t\t_settingState.settingStateJSON = _extraData;\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting state\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction getSettingState(uint256 _settingId) public view returns (uint256, bool, address, address, string, address, string) {\n', '\t\tSettingState memory _settingState = settingStates[_settingId];\n', '\t\treturn (\n', '\t\t\t_settingState.settingId,\n', '\t\t\t_settingState.pendingUpdate,\n', '\t\t\t_settingState.updateAdvocateNameId,\n', '\t\t\t_settingState.proposalTAOId,\n', '\t\t\t_settingState.updateSignature,\n', '\t\t\t_settingState.lastUpdateTAOId,\n', '\t\t\t_settingState.settingStateJSON\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s proposalTAOId approves the setting update\n', '\t * @param _settingId The ID of the setting to be approved\n', '\t * @param _proposalTAOAdvocate The advocate of the proposal TAO\n', '\t * @param _approved Whether to approve or reject\n', '\t * @return true on success\n', '\t */\n', '\tfunction approveUpdate(uint256 _settingId, address _proposalTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting is created\n', '\t\tSettingData storage _settingData = settingDatas[_settingId];\n', '\t\trequire (_settingData.settingId == _settingId && _settingData.pendingCreate == false && _settingData.locked == true && _settingData.rejected == false);\n', '\n', '\t\t// Make sure setting update exists and needs approval\n', '\t\tSettingState storage _settingState = settingStates[_settingId];\n', '\t\trequire (_settingState.settingId == _settingId &&\n', '\t\t\t_settingState.pendingUpdate == true &&\n', '\t\t\t_proposalTAOAdvocate != address(0) &&\n', '\t\t\t_proposalTAOAdvocate == _nameTAOPosition.getAdvocate(_settingState.proposalTAOId)\n', '\t\t);\n', '\n', '\t\tif (_approved) {\n', '\t\t\t// Unlock the setting so that advocate of associatedTAOId can finalize the update\n', '\t\t\t_settingData.locked = false;\n', '\t\t} else {\n', '\t\t\t// Set pendingUpdate to false\n', '\t\t\t_settingState.pendingUpdate = false;\n', '\t\t\t_settingState.proposalTAOId = address(0);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId finalizes the setting update once the setting is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t * @param _associatedTAOAdvocate The advocate of the associated TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction finalizeUpdate(uint256 _settingId, address _associatedTAOAdvocate) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting is created\n', '\t\tSettingData storage _settingData = settingDatas[_settingId];\n', '\t\trequire (_settingData.settingId == _settingId &&\n', '\t\t\t_settingData.pendingCreate == false &&\n', '\t\t\t_settingData.locked == false &&\n', '\t\t\t_settingData.rejected == false &&\n', '\t\t\t_associatedTAOAdvocate != address(0) &&\n', '\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId)\n', '\t\t);\n', '\n', '\t\t// Make sure setting update exists and needs approval\n', '\t\tSettingState storage _settingState = settingStates[_settingId];\n', '\t\trequire (_settingState.settingId == _settingId && _settingState.pendingUpdate == true && _settingState.proposalTAOId != address(0));\n', '\n', '\t\t// Update the setting data\n', '\t\t_settingData.locked = true;\n', '\n', '\t\t// Update the setting state\n', '\t\t_settingState.pendingUpdate = false;\n', '\t\t_settingState.updateAdvocateNameId = _associatedTAOAdvocate;\n', '\t\taddress _proposalTAOId = _settingState.proposalTAOId;\n', '\t\t_settingState.proposalTAOId = address(0);\n', '\t\t_settingState.lastUpdateTAOId = _proposalTAOId;\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add setting deprecation\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _creatorNameId The nameId that created the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _newSettingId The new settingId value to route\n', '\t * @param _newSettingContractAddress The address of the new setting contract to route\n', '\t * @return The ID of the "Associated" setting deprecation\n', '\t * @return The ID of the "Creator" setting deprecation\n', '\t */\n', '\tfunction addDeprecation(uint256 _settingId, address _creatorNameId, address _creatorTAOId, address _associatedTAOId, uint256 _newSettingId, address _newSettingContractAddress) public inWhitelist returns (bytes32, bytes32) {\n', '\t\trequire (_storeSettingDeprecation(_settingId, _creatorNameId, _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress));\n', '\n', '\t\t// Store the associatedTAOSettingDeprecation info\n', '\t\tbytes32 _associatedTAOSettingDeprecationId = keccak256(abi.encodePacked(this, _associatedTAOId, _settingId));\n', '\t\tAssociatedTAOSettingDeprecation storage _associatedTAOSettingDeprecation = associatedTAOSettingDeprecations[_associatedTAOSettingDeprecationId];\n', '\t\t_associatedTAOSettingDeprecation.associatedTAOSettingDeprecationId = _associatedTAOSettingDeprecationId;\n', '\t\t_associatedTAOSettingDeprecation.associatedTAOId = _associatedTAOId;\n', '\t\t_associatedTAOSettingDeprecation.settingId = _settingId;\n', '\n', '\t\t// Store the creatorTAOSettingDeprecation info\n', '\t\tbytes32 _creatorTAOSettingDeprecationId = keccak256(abi.encodePacked(this, _creatorTAOId, _settingId));\n', '\t\tCreatorTAOSettingDeprecation storage _creatorTAOSettingDeprecation = creatorTAOSettingDeprecations[_creatorTAOSettingDeprecationId];\n', '\t\t_creatorTAOSettingDeprecation.creatorTAOSettingDeprecationId = _creatorTAOSettingDeprecationId;\n', '\t\t_creatorTAOSettingDeprecation.creatorTAOId = _creatorTAOId;\n', '\t\t_creatorTAOSettingDeprecation.settingId = _settingId;\n', '\n', '\t\treturn (_associatedTAOSettingDeprecationId, _creatorTAOSettingDeprecationId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Setting Deprecation info of a setting ID\n', '\t * @param _settingId The ID of the setting\n', '\t */\n', '\tfunction getSettingDeprecation(uint256 _settingId) public view returns (uint256, address, address, address, bool, bool, bool, bool, uint256, uint256, address, address) {\n', '\t\tSettingDeprecation memory _settingDeprecation = settingDeprecations[_settingId];\n', '\t\treturn (\n', '\t\t\t_settingDeprecation.settingId,\n', '\t\t\t_settingDeprecation.creatorNameId,\n', '\t\t\t_settingDeprecation.creatorTAOId,\n', '\t\t\t_settingDeprecation.associatedTAOId,\n', '\t\t\t_settingDeprecation.pendingDeprecated,\n', '\t\t\t_settingDeprecation.locked,\n', '\t\t\t_settingDeprecation.rejected,\n', '\t\t\t_settingDeprecation.migrated,\n', '\t\t\t_settingDeprecation.pendingNewSettingId,\n', '\t\t\t_settingDeprecation.newSettingId,\n', '\t\t\t_settingDeprecation.pendingNewSettingContractAddress,\n', '\t\t\t_settingDeprecation.newSettingContractAddress\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Associated TAO Setting Deprecation info\n', '\t * @param _associatedTAOSettingDeprecationId The ID of the associated tao setting deprecation\n', '\t */\n', '\tfunction getAssociatedTAOSettingDeprecation(bytes32 _associatedTAOSettingDeprecationId) public view returns (bytes32, address, uint256) {\n', '\t\tAssociatedTAOSettingDeprecation memory _associatedTAOSettingDeprecation = associatedTAOSettingDeprecations[_associatedTAOSettingDeprecationId];\n', '\t\treturn (\n', '\t\t\t_associatedTAOSettingDeprecation.associatedTAOSettingDeprecationId,\n', '\t\t\t_associatedTAOSettingDeprecation.associatedTAOId,\n', '\t\t\t_associatedTAOSettingDeprecation.settingId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Creator TAO Setting Deprecation info\n', '\t * @param _creatorTAOSettingDeprecationId The ID of the creator tao setting deprecation\n', '\t */\n', '\tfunction getCreatorTAOSettingDeprecation(bytes32 _creatorTAOSettingDeprecationId) public view returns (bytes32, address, uint256) {\n', '\t\tCreatorTAOSettingDeprecation memory _creatorTAOSettingDeprecation = creatorTAOSettingDeprecations[_creatorTAOSettingDeprecationId];\n', '\t\treturn (\n', '\t\t\t_creatorTAOSettingDeprecation.creatorTAOSettingDeprecationId,\n', '\t\t\t_creatorTAOSettingDeprecation.creatorTAOId,\n', '\t\t\t_creatorTAOSettingDeprecation.settingId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of SettingDeprecation&#39;s _associatedTAOId approves deprecation\n', '\t * @param _settingId The ID of the setting to approve\n', '\t * @param _associatedTAOAdvocate The advocate of the associated TAO\n', '\t * @param _approved Whether to approve or reject\n', '\t * @return true on success\n', '\t */\n', '\tfunction approveDeprecation(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting exists and needs approval\n', '\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\n', '\t\trequire (_settingDeprecation.settingId == _settingId &&\n', '\t\t\t_settingDeprecation.migrated == false &&\n', '\t\t\t_settingDeprecation.pendingDeprecated == true &&\n', '\t\t\t_settingDeprecation.locked == true &&\n', '\t\t\t_settingDeprecation.rejected == false &&\n', '\t\t\t_associatedTAOAdvocate != address(0) &&\n', '\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingDeprecation.associatedTAOId)\n', '\t\t);\n', '\n', '\t\tif (_approved) {\n', '\t\t\t// Unlock the setting so that advocate of creatorTAOId can finalize the creation\n', '\t\t\t_settingDeprecation.locked = false;\n', '\t\t} else {\n', '\t\t\t// Reject the setting\n', '\t\t\t_settingDeprecation.pendingDeprecated = false;\n', '\t\t\t_settingDeprecation.rejected = true;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of SettingDeprecation&#39;s _creatorTAOId finalizes the deprecation once the setting deprecation is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t * @param _creatorTAOAdvocate The advocate of the creator TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction finalizeDeprecation(uint256 _settingId, address _creatorTAOAdvocate) public inWhitelist returns (bool) {\n', '\t\t// Make sure setting exists and needs approval\n', '\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\n', '\t\trequire (_settingDeprecation.settingId == _settingId &&\n', '\t\t\t_settingDeprecation.migrated == false &&\n', '\t\t\t_settingDeprecation.pendingDeprecated == true &&\n', '\t\t\t_settingDeprecation.locked == false &&\n', '\t\t\t_settingDeprecation.rejected == false &&\n', '\t\t\t_creatorTAOAdvocate != address(0) &&\n', '\t\t\t_creatorTAOAdvocate == _nameTAOPosition.getAdvocate(_settingDeprecation.creatorTAOId)\n', '\t\t);\n', '\n', '\t\t// Update the setting data\n', '\t\t_settingDeprecation.pendingDeprecated = false;\n', '\t\t_settingDeprecation.locked = true;\n', '\t\t_settingDeprecation.migrated = true;\n', '\t\tuint256 _newSettingId = _settingDeprecation.pendingNewSettingId;\n', '\t\t_settingDeprecation.pendingNewSettingId = 0;\n', '\t\t_settingDeprecation.newSettingId = _newSettingId;\n', '\n', '\t\taddress _newSettingContractAddress = _settingDeprecation.pendingNewSettingContractAddress;\n', '\t\t_settingDeprecation.pendingNewSettingContractAddress = address(0);\n', '\t\t_settingDeprecation.newSettingContractAddress = _newSettingContractAddress;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if a setting exist and not rejected\n', '\t * @param _settingId The ID of the setting\n', '\t * @return true if exist. false otherwise\n', '\t */\n', '\tfunction settingExist(uint256 _settingId) public view returns (bool) {\n', '\t\tSettingData memory _settingData = settingDatas[_settingId];\n', '\t\treturn (_settingData.settingId == _settingId && _settingData.rejected == false);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the latest ID of a deprecated setting, if exist\n', '\t * @param _settingId The ID of the setting\n', '\t * @return The latest setting ID\n', '\t */\n', '\tfunction getLatestSettingId(uint256 _settingId) public view returns (uint256) {\n', '\t\t(,,,,,,, bool _migrated,, uint256 _newSettingId,,) = getSettingDeprecation(_settingId);\n', '\t\twhile (_migrated && _newSettingId > 0) {\n', '\t\t\t_settingId = _newSettingId;\n', '\t\t\t(,,,,,,, _migrated,, _newSettingId,,) = getSettingDeprecation(_settingId);\n', '\t\t}\n', '\t\treturn _settingId;\n', '\t}\n', '\n', '\t/***** Internal Method *****/\n', '\t/**\n', '\t * @dev Store setting data/state\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _creatorNameId The nameId that created the setting\n', '\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t * @return true on success\n', '\t */\n', '\tfunction _storeSettingDataState(uint256 _settingId, address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) internal returns (bool) {\n', '\t\t// Store setting data\n', '\t\tSettingData storage _settingData = settingDatas[_settingId];\n', '\t\t_settingData.settingId = _settingId;\n', '\t\t_settingData.creatorNameId = _creatorNameId;\n', '\t\t_settingData.creatorTAOId = _creatorTAOId;\n', '\t\t_settingData.associatedTAOId = _associatedTAOId;\n', '\t\t_settingData.settingName = _settingName;\n', '\t\t_settingData.settingType = _settingType;\n', '\t\t_settingData.pendingCreate = true;\n', '\t\t_settingData.locked = true;\n', '\t\t_settingData.settingDataJSON = _extraData;\n', '\n', '\t\t// Store setting state\n', '\t\tSettingState storage _settingState = settingStates[_settingId];\n', '\t\t_settingState.settingId = _settingId;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store setting deprecation\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _creatorNameId The nameId that created the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _newSettingId The new settingId value to route\n', '\t * @param _newSettingContractAddress The address of the new setting contract to route\n', '\t * @return true on success\n', '\t */\n', '\tfunction _storeSettingDeprecation(uint256 _settingId, address _creatorNameId, address _creatorTAOId, address _associatedTAOId, uint256 _newSettingId, address _newSettingContractAddress) internal returns (bool) {\n', '\t\t// Make sure this setting exists\n', '\t\trequire (settingDatas[_settingId].creatorNameId != address(0) && settingDatas[_settingId].rejected == false && settingDatas[_settingId].pendingCreate == false);\n', '\n', '\t\t// Make sure deprecation is not yet exist for this setting Id\n', '\t\trequire (settingDeprecations[_settingId].creatorNameId == address(0));\n', '\n', '\t\t// Make sure newSettingId exists\n', '\t\trequire (settingDatas[_newSettingId].creatorNameId != address(0) && settingDatas[_newSettingId].rejected == false && settingDatas[_newSettingId].pendingCreate == false);\n', '\n', '\t\t// Make sure the settingType matches\n', '\t\trequire (settingDatas[_settingId].settingType == settingDatas[_newSettingId].settingType);\n', '\n', '\t\t// Store setting deprecation info\n', '\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\n', '\t\t_settingDeprecation.settingId = _settingId;\n', '\t\t_settingDeprecation.creatorNameId = _creatorNameId;\n', '\t\t_settingDeprecation.creatorTAOId = _creatorTAOId;\n', '\t\t_settingDeprecation.associatedTAOId = _associatedTAOId;\n', '\t\t_settingDeprecation.pendingDeprecated = true;\n', '\t\t_settingDeprecation.locked = true;\n', '\t\t_settingDeprecation.pendingNewSettingId = _newSettingId;\n', '\t\t_settingDeprecation.pendingNewSettingContractAddress = _newSettingContractAddress;\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOTokenInterface\n', ' */\n', 'contract AOTokenInterface is TheAO, TokenERC20 {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// To differentiate denomination of AO\n', '\tuint256 public powerOfTen;\n', '\n', '\t/***** NETWORK TOKEN VARIABLES *****/\n', '\tuint256 public sellPrice;\n', '\tuint256 public buyPrice;\n', '\n', '\tmapping (address => bool) public frozenAccount;\n', '\tmapping (address => uint256) public stakedBalance;\n', '\tmapping (address => uint256) public escrowedBalance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent FrozenFunds(address target, bool frozen);\n', '\tevent Stake(address indexed from, uint256 value);\n', '\tevent Unstake(address indexed from, uint256 value);\n', '\tevent Escrow(address indexed from, address indexed to, uint256 value);\n', '\tevent Unescrow(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\n', '\t\tTokenERC20(initialSupply, tokenName, tokenSymbol) public {\n', '\t\tpowerOfTen = 0;\n', '\t\tdecimals = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Prevent/Allow target from sending & receiving tokens\n', '\t * @param target Address to be frozen\n', '\t * @param freeze Either to freeze it or not\n', '\t */\n', '\tfunction freezeAccount(address target, bool freeze) public onlyTheAO {\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\temit FrozenFunds(target, freeze);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\n', '\t * @param newSellPrice Price users can sell to the contract\n', '\t * @param newBuyPrice Price users can buy from the contract\n', '\t */\n', '\tfunction setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyTheAO {\n', '\t\tsellPrice = newSellPrice;\n', '\t\tbuyPrice = newBuyPrice;\n', '\t}\n', '\n', '\t/***** NETWORK TOKEN WHITELISTED ADDRESS ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Create `mintedAmount` tokens and send it to `target`\n', '\t * @param target Address to receive the tokens\n', '\t * @param mintedAmount The amount of tokens it will receive\n', '\t * @return true on success\n', '\t */\n', '\tfunction mintToken(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\n', '\t\t_mintToken(target, mintedAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Stake `_value` tokens on behalf of `_from`\n', '\t * @param _from The address of the target\n', '\t * @param _value The amount to stake\n', '\t * @return true on success\n', '\t */\n', '\tfunction stakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\n', '\t\tstakedBalance[_from] = stakedBalance[_from].add(_value);\t// Add to the targeted staked balance\n', '\t\temit Stake(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Unstake `_value` tokens on behalf of `_from`\n', '\t * @param _from The address of the target\n', '\t * @param _value The amount to unstake\n', '\t * @return true on success\n', '\t */\n', '\tfunction unstakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (stakedBalance[_from] >= _value);\t\t\t\t\t// Check if the targeted staked balance is enough\n', '\t\tstakedBalance[_from] = stakedBalance[_from].sub(_value);\t// Subtract from the targeted staked balance\n', '\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t// Add to the targeted balance\n', '\t\temit Unstake(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store `_value` from `_from` to `_to` in escrow\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount of network tokens to put in escrow\n', '\t * @return true on success\n', '\t */\n', '\tfunction escrowFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\n', '\t\tescrowedBalance[_to] = escrowedBalance[_to].add(_value);\t// Add to the targeted escrowed balance\n', '\t\temit Escrow(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` tokens and send it to `target` escrow balance\n', '\t * @param target Address to receive the tokens\n', '\t * @param mintedAmount The amount of tokens it will receive in escrow\n', '\t */\n', '\tfunction mintTokenEscrow(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\n', '\t\tescrowedBalance[target] = escrowedBalance[target].add(mintedAmount);\n', '\t\ttotalSupply = totalSupply.add(mintedAmount);\n', '\t\temit Escrow(this, target, mintedAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Release escrowed `_value` from `_from`\n', '\t * @param _from The address of the sender\n', '\t * @param _value The amount of escrowed network tokens to be released\n', '\t * @return true on success\n', '\t */\n', '\tfunction unescrowFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\n', '\t\trequire (escrowedBalance[_from] >= _value);\t\t\t\t\t\t// Check if the targeted escrowed balance is enough\n', '\t\tescrowedBalance[_from] = escrowedBalance[_from].sub(_value);\t// Subtract from the targeted escrowed balance\n', '\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t\t// Add to the targeted balance\n', '\t\temit Unescrow(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t *\n', '\t * @dev Whitelisted address remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\n', '\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelisted address transfer tokens from other address\n', '\t *\n', '\t * Send `_value` tokens to `_to` on behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Buy tokens from contract by sending ether\n', '\t */\n', '\tfunction buy() public payable {\n', '\t\trequire (buyPrice > 0);\n', '\t\tuint256 amount = msg.value.div(buyPrice);\n', '\t\t_transfer(this, msg.sender, amount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Sell `amount` tokens to contract\n', '\t * @param amount The amount of tokens to be sold\n', '\t */\n', '\tfunction sell(uint256 amount) public {\n', '\t\trequire (sellPrice > 0);\n', '\t\taddress myAddress = this;\n', '\t\trequire (myAddress.balance >= amount.mul(sellPrice));\n', '\t\t_transfer(msg.sender, this, amount);\n', '\t\tmsg.sender.transfer(amount.mul(sellPrice));\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Send `_value` tokens from `_from` to `_to`\n', '\t * @param _from The address of sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n', '\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n', '\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t// Check if sender is frozen\n', '\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t// Check if recipient is frozen\n', '\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` tokens and send it to `target`\n', '\t * @param target Address to receive the tokens\n', '\t * @param mintedAmount The amount of tokens it will receive\n', '\t */\n', '\tfunction _mintToken(address target, uint256 mintedAmount) internal {\n', '\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\n', '\t\ttotalSupply = totalSupply.add(mintedAmount);\n', '\t\temit Transfer(0, this, mintedAmount);\n', '\t\temit Transfer(this, target, mintedAmount);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOToken\n', ' */\n', 'contract AOToken is AOTokenInterface {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public settingTAOId;\n', '\taddress public aoSettingAddress;\n', '\t// AO Dev Team addresses to receive Primordial/Network Tokens\n', '\taddress public aoDevTeam1 = 0x5C63644D01Ba385eBAc5bcf2DDc1e6dBC1182b52;\n', '\taddress public aoDevTeam2 = 0x156C79bf4347D1891da834Ea30662A14177CbF28;\n', '\n', '\tAOSetting internal _aoSetting;\n', '\n', '\t/***** PRIMORDIAL TOKEN VARIABLES *****/\n', '\tuint256 public primordialTotalSupply;\n', '\tuint256 public primordialTotalBought;\n', '\tuint256 public primordialSellPrice;\n', '\tuint256 public primordialBuyPrice;\n', '\n', '\t// Total available primordial token for sale 1,125,899,906,842,620 AO+\n', '\tuint256 constant public TOTAL_PRIMORDIAL_FOR_SALE = 1125899906842620;\n', '\n', '\tmapping (address => uint256) public primordialBalanceOf;\n', '\tmapping (address => mapping (address => uint256)) public primordialAllowance;\n', '\n', '\t// Mapping from owner&#39;s lot weighted multiplier to the amount of staked tokens\n', '\tmapping (address => mapping (uint256 => uint256)) public primordialStakedBalance;\n', '\n', '\tevent PrimordialTransfer(address indexed from, address indexed to, uint256 value);\n', '\tevent PrimordialApproval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\tevent PrimordialBurn(address indexed from, uint256 value);\n', '\tevent PrimordialStake(address indexed from, uint256 value, uint256 weightedMultiplier);\n', '\tevent PrimordialUnstake(address indexed from, uint256 value, uint256 weightedMultiplier);\n', '\n', '\tuint256 public totalLots;\n', '\tuint256 public totalBurnLots;\n', '\tuint256 public totalConvertLots;\n', '\n', '\tbool public networkExchangeEnded;\n', '\n', '\t/**\n', '\t * Stores Lot creation data (during network exchange)\n', '\t */\n', '\tstruct Lot {\n', '\t\tbytes32 lotId;\n', '\t\tuint256 multiplier;\t// This value is in 10^6, so 1000000 = 1\n', '\t\taddress lotOwner;\n', '\t\tuint256 tokenAmount;\n', '\t}\n', '\n', '\t/**\n', '\t * Struct to store info when account burns primordial token\n', '\t */\n', '\tstruct BurnLot {\n', '\t\tbytes32 burnLotId;\n', '\t\taddress lotOwner;\n', '\t\tuint256 tokenAmount;\n', '\t}\n', '\n', '\t/**\n', '\t * Struct to store info when account converts network token to primordial token\n', '\t */\n', '\tstruct ConvertLot {\n', '\t\tbytes32 convertLotId;\n', '\t\taddress lotOwner;\n', '\t\tuint256 tokenAmount;\n', '\t}\n', '\n', '\t// Mapping from Lot ID to Lot object\n', '\tmapping (bytes32 => Lot) internal lots;\n', '\n', '\t// Mapping from Burn Lot ID to BurnLot object\n', '\tmapping (bytes32 => BurnLot) internal burnLots;\n', '\n', '\t// Mapping from Convert Lot ID to ConvertLot object\n', '\tmapping (bytes32 => ConvertLot) internal convertLots;\n', '\n', '\t// Mapping from owner to list of owned lot IDs\n', '\tmapping (address => bytes32[]) internal ownedLots;\n', '\n', '\t// Mapping from owner to list of owned burn lot IDs\n', '\tmapping (address => bytes32[]) internal ownedBurnLots;\n', '\n', '\t// Mapping from owner to list of owned convert lot IDs\n', '\tmapping (address => bytes32[]) internal ownedConvertLots;\n', '\n', '\t// Mapping from owner to his/her current weighted multiplier\n', '\tmapping (address => uint256) internal ownerWeightedMultiplier;\n', '\n', '\t// Mapping from owner to his/her max multiplier (multiplier of account&#39;s first Lot)\n', '\tmapping (address => uint256) internal ownerMaxMultiplier;\n', '\n', '\t// Event to be broadcasted to public when a lot is created\n', '\t// multiplier value is in 10^6 to account for 6 decimal points\n', '\tevent LotCreation(address indexed lotOwner, bytes32 indexed lotId, uint256 multiplier, uint256 primordialTokenAmount, uint256 networkTokenBonusAmount);\n', '\n', '\t// Event to be broadcasted to public when burn lot is created (when account burns primordial tokens)\n', '\tevent BurnLotCreation(address indexed lotOwner, bytes32 indexed burnLotId, uint256 burnTokenAmount, uint256 multiplierAfterBurn);\n', '\n', '\t// Event to be broadcasted to public when convert lot is created (when account convert network tokens to primordial tokens)\n', '\tevent ConvertLotCreation(address indexed lotOwner, bytes32 indexed convertLotId, uint256 convertTokenAmount, uint256 multiplierAfterBurn);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol, address _settingTAOId, address _aoSettingAddress)\n', '\t\tAOTokenInterface(initialSupply, tokenName, tokenSymbol) public {\n', '\t\tsettingTAOId = _settingTAOId;\n', '\t\taoSettingAddress = _aoSettingAddress;\n', '\t\t_aoSetting = AOSetting(_aoSettingAddress);\n', '\n', '\t\tpowerOfTen = 0;\n', '\t\tdecimals = 0;\n', '\t\tsetPrimordialPrices(0, 10000); // Set Primordial buy price to 10000 Wei/token\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if buyer can buy primordial token\n', '\t */\n', '\tmodifier canBuyPrimordial(uint256 _sentAmount) {\n', '\t\trequire (networkExchangeEnded == false && primordialTotalBought < TOTAL_PRIMORDIAL_FOR_SALE && primordialBuyPrice > 0 && _sentAmount > 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Set AO Dev team addresses to receive Primordial/Network tokens during network exchange\n', '\t * @param _aoDevTeam1 The first AO dev team address\n', '\t * @param _aoDevTeam2 The second AO dev team address\n', '\t */\n', '\tfunction setAODevTeamAddresses(address _aoDevTeam1, address _aoDevTeam2) public onlyTheAO {\n', '\t\taoDevTeam1 = _aoDevTeam1;\n', '\t\taoDevTeam2 = _aoDevTeam2;\n', '\t}\n', '\n', '\t/***** PRIMORDIAL TOKEN The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Allow users to buy Primordial tokens for `newBuyPrice` eth and sell Primordial tokens for `newSellPrice` eth\n', '\t * @param newPrimordialSellPrice Price users can sell to the contract\n', '\t * @param newPrimordialBuyPrice Price users can buy from the contract\n', '\t */\n', '\tfunction setPrimordialPrices(uint256 newPrimordialSellPrice, uint256 newPrimordialBuyPrice) public onlyTheAO {\n', '\t\tprimordialSellPrice = newPrimordialSellPrice;\n', '\t\tprimordialBuyPrice = newPrimordialBuyPrice;\n', '\t}\n', '\n', '\t/***** PRIMORDIAL TOKEN WHITELISTED ADDRESS ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Stake `_value` Primordial tokens at `_weightedMultiplier ` multiplier on behalf of `_from`\n', '\t * @param _from The address of the target\n', '\t * @param _value The amount of Primordial tokens to stake\n', '\t * @param _weightedMultiplier The weighted multiplier of the Primordial tokens\n', '\t * @return true on success\n', '\t */\n', '\tfunction stakePrimordialTokenFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\n', '\t\t// Check if the targeted balance is enough\n', '\t\trequire (primordialBalanceOf[_from] >= _value);\n', '\t\t// Make sure the weighted multiplier is the same as account&#39;s current weighted multiplier\n', '\t\trequire (_weightedMultiplier == ownerWeightedMultiplier[_from]);\n', '\t\t// Subtract from the targeted balance\n', '\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\n', '\t\t// Add to the targeted staked balance\n', '\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].add(_value);\n', '\t\temit PrimordialStake(_from, _value, _weightedMultiplier);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Unstake `_value` Primordial tokens at `_weightedMultiplier` on behalf of `_from`\n', '\t * @param _from The address of the target\n', '\t * @param _value The amount to unstake\n', '\t * @param _weightedMultiplier The weighted multiplier of the Primordial tokens\n', '\t * @return true on success\n', '\t */\n', '\tfunction unstakePrimordialTokenFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\n', '\t\t// Check if the targeted staked balance is enough\n', '\t\trequire (primordialStakedBalance[_from][_weightedMultiplier] >= _value);\n', '\t\t// Subtract from the targeted staked balance\n', '\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].sub(_value);\n', '\t\t// Add to the targeted balance\n', '\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].add(_value);\n', '\t\temit PrimordialUnstake(_from, _value, _weightedMultiplier);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Send `_value` primordial tokens to `_to` on behalf of `_from`\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t * @return true on success\n', '\t */\n', '\tfunction whitelistTransferPrimordialTokenFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\n', '\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\n', '\t\tLot memory _lot = lots[_createdLotId];\n', '\n', '\t\t// Make sure the new lot is created successfully\n', '\t\trequire (_lot.lotOwner == _to);\n', '\n', '\t\t// Update the weighted multiplier of the recipient\n', '\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\n', '\n', '\t\t// Transfer the Primordial tokens\n', '\t\trequire (_transferPrimordialToken(_from, _to, _value));\n', '\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/***** Primordial TOKEN PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Buy Primordial tokens from contract by sending ether\n', '\t */\n', '\tfunction buyPrimordialToken() public payable canBuyPrimordial(msg.value) {\n', '\t\t(uint256 tokenAmount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateTokenAmountAndRemainderBudget(msg.value);\n', '\t\trequire (tokenAmount > 0);\n', '\n', '\t\t// Ends network exchange if necessary\n', '\t\tif (shouldEndNetworkExchange) {\n', '\t\t\tnetworkExchangeEnded = true;\n', '\t\t}\n', '\n', '\t\t// Send the primordial token to buyer and reward AO devs\n', '\t\t_sendPrimordialTokenAndRewardDev(tokenAmount, msg.sender);\n', '\n', '\t\t// Send remainder budget back to buyer if exist\n', '\t\tif (remainderBudget > 0) {\n', '\t\t\tmsg.sender.transfer(remainderBudget);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Send `_value` Primordial tokens to `_to` from your account\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferPrimordialToken(address _to, uint256 _value) public returns (bool success) {\n', '\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[msg.sender]);\n', '\t\tLot memory _lot = lots[_createdLotId];\n', '\n', '\t\t// Make sure the new lot is created successfully\n', '\t\trequire (_lot.lotOwner == _to);\n', '\n', '\t\t// Update the weighted multiplier of the recipient\n', '\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[msg.sender], _value);\n', '\n', '\t\t// Transfer the Primordial tokens\n', '\t\trequire (_transferPrimordialToken(msg.sender, _to, _value));\n', '\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Send `_value` Primordial tokens to `_to` from `_from`\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferPrimordialTokenFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t\trequire (_value <= primordialAllowance[_from][msg.sender]);\n', '\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\n', '\n', '\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\n', '\t\tLot memory _lot = lots[_createdLotId];\n', '\n', '\t\t// Make sure the new lot is created successfully\n', '\t\trequire (_lot.lotOwner == _to);\n', '\n', '\t\t// Update the weighted multiplier of the recipient\n', '\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\n', '\n', '\t\t// Transfer the Primordial tokens\n', '\t\trequire (_transferPrimordialToken(_from, _to, _value));\n', '\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows `_spender` to spend no more than `_value` Primordial tokens in your behalf\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value The max amount they can spend\n', '\t * @return true on success\n', '\t */\n', '\tfunction approvePrimordialToken(address _spender, uint256 _value) public returns (bool success) {\n', '\t\tprimordialAllowance[msg.sender][_spender] = _value;\n', '\t\temit PrimordialApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows `_spender` to spend no more than `_value` Primordial tokens in your behalf, and then ping the contract about it\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value The max amount they can spend\n', '\t * @param _extraData some extra information to send to the approved contract\n', '\t * @return true on success\n', '\t */\n', '\tfunction approvePrimordialTokenAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approvePrimordialToken(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Remove `_value` Primordial tokens from the system irreversibly\n', '\t *\t\tand re-weight the account&#39;s multiplier after burn\n', '\t * @param _value The amount to burn\n', '\t * @return true on success\n', '\t */\n', '\tfunction burnPrimordialToken(uint256 _value) public returns (bool success) {\n', '\t\trequire (primordialBalanceOf[msg.sender] >= _value);\n', '\t\trequire (calculateMaximumBurnAmount(msg.sender) >= _value);\n', '\n', '\t\t// Update the account&#39;s multiplier\n', '\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterBurn(msg.sender, _value);\n', '\t\tprimordialBalanceOf[msg.sender] = primordialBalanceOf[msg.sender].sub(_value);\n', '\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\n', '\n', '\t\t// Store burn lot info\n', '\t\t_createBurnLot(msg.sender, _value);\n', '\t\temit PrimordialBurn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Remove `_value` Primordial tokens from the system irreversibly on behalf of `_from`\n', '\t *\t\tand re-weight `_from`&#39;s multiplier after burn\n', '\t * @param _from The address of sender\n', '\t * @param _value The amount to burn\n', '\t * @return true on success\n', '\t */\n', '\tfunction burnPrimordialTokenFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t\trequire (primordialBalanceOf[_from] >= _value);\n', '\t\trequire (primordialAllowance[_from][msg.sender] >= _value);\n', '\t\trequire (calculateMaximumBurnAmount(_from) >= _value);\n', '\n', '\t\t// Update `_from`&#39;s multiplier\n', '\t\townerWeightedMultiplier[_from] = calculateMultiplierAfterBurn(_from, _value);\n', '\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\n', '\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\n', '\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\n', '\n', '\t\t// Store burn lot info\n', '\t\t_createBurnLot(_from, _value);\n', '\t\temit PrimordialBurn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return all lot IDs owned by an address\n', '\t * @param _lotOwner The address of the lot owner\n', '\t * @return array of lot IDs\n', '\t */\n', '\tfunction lotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\n', '\t\treturn ownedLots[_lotOwner];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the total lots owned by an address\n', '\t * @param _lotOwner The address of the lot owner\n', '\t * @return total lots owner by the address\n', '\t */\n', '\tfunction totalLotsByAddress(address _lotOwner) public view returns (uint256) {\n', '\t\treturn ownedLots[_lotOwner].length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the lot information at a given index of the lots list of the requested owner\n', '\t * @param _lotOwner The address owning the lots list to be accessed\n', '\t * @param _index uint256 representing the index to be accessed of the requested lots list\n', '\t * @return id of the lot\n', '\t * @return The address of the lot owner\n', '\t * @return multiplier of the lot in (10 ** 6)\n', '\t * @return Primordial token amount in the lot\n', '\t */\n', '\tfunction lotOfOwnerByIndex(address _lotOwner, uint256 _index) public view returns (bytes32, address, uint256, uint256) {\n', '\t\trequire (_index < ownedLots[_lotOwner].length);\n', '\t\tLot memory _lot = lots[ownedLots[_lotOwner][_index]];\n', '\t\treturn (_lot.lotId, _lot.lotOwner, _lot.multiplier, _lot.tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the lot information at a given ID\n', '\t * @param _lotId The lot ID in question\n', '\t * @return id of the lot\n', '\t * @return The lot owner address\n', '\t * @return multiplier of the lot in (10 ** 6)\n', '\t * @return Primordial token amount in the lot\n', '\t */\n', '\tfunction lotById(bytes32 _lotId) public view returns (bytes32, address, uint256, uint256) {\n', '\t\tLot memory _lot = lots[_lotId];\n', '\t\treturn (_lot.lotId, _lot.lotOwner, _lot.multiplier, _lot.tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return all Burn Lot IDs owned by an address\n', '\t * @param _lotOwner The address of the burn lot owner\n', '\t * @return array of Burn Lot IDs\n', '\t */\n', '\tfunction burnLotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\n', '\t\treturn ownedBurnLots[_lotOwner];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the total burn lots owned by an address\n', '\t * @param _lotOwner The address of the burn lot owner\n', '\t * @return total burn lots owner by the address\n', '\t */\n', '\tfunction totalBurnLotsByAddress(address _lotOwner) public view returns (uint256) {\n', '\t\treturn ownedBurnLots[_lotOwner].length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the burn lot information at a given ID\n', '\t * @param _burnLotId The burn lot ID in question\n', '\t * @return id of the lot\n', '\t * @return The address of the burn lot owner\n', '\t * @return Primordial token amount in the burn lot\n', '\t */\n', '\tfunction burnLotById(bytes32 _burnLotId) public view returns (bytes32, address, uint256) {\n', '\t\tBurnLot memory _burnLot = burnLots[_burnLotId];\n', '\t\treturn (_burnLot.burnLotId, _burnLot.lotOwner, _burnLot.tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return all Convert Lot IDs owned by an address\n', '\t * @param _lotOwner The address of the convert lot owner\n', '\t * @return array of Convert Lot IDs\n', '\t */\n', '\tfunction convertLotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\n', '\t\treturn ownedConvertLots[_lotOwner];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the total convert lots owned by an address\n', '\t * @param _lotOwner The address of the convert lot owner\n', '\t * @return total convert lots owner by the address\n', '\t */\n', '\tfunction totalConvertLotsByAddress(address _lotOwner) public view returns (uint256) {\n', '\t\treturn ownedConvertLots[_lotOwner].length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the convert lot information at a given ID\n', '\t * @param _convertLotId The convert lot ID in question\n', '\t * @return id of the lot\n', '\t * @return The address of the convert lot owner\n', '\t * @return Primordial token amount in the convert lot\n', '\t */\n', '\tfunction convertLotById(bytes32 _convertLotId) public view returns (bytes32, address, uint256) {\n', '\t\tConvertLot memory _convertLot = convertLots[_convertLotId];\n', '\t\treturn (_convertLot.convertLotId, _convertLot.lotOwner, _convertLot.tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the average weighted multiplier of all lots owned by an address\n', '\t * @param _lotOwner The address of the lot owner\n', '\t * @return the weighted multiplier of the address (in 10 ** 6)\n', '\t */\n', '\tfunction weightedMultiplierByAddress(address _lotOwner) public view returns (uint256) {\n', '\t\treturn ownerWeightedMultiplier[_lotOwner];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the max multiplier of an address\n', '\t * @param _target The address to query\n', '\t * @return the max multiplier of the address (in 10 ** 6)\n', '\t */\n', '\tfunction maxMultiplierByAddress(address _target) public view returns (uint256) {\n', '\t\treturn (ownedLots[_target].length > 0) ? ownerMaxMultiplier[_target] : 0;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the primordial token multiplier, bonus network token percentage, and the\n', '\t *\t\tbonus network token amount on a given lot when someone purchases primordial token\n', '\t *\t\tduring network exchange\n', '\t * @param _purchaseAmount The amount of primordial token intended to be purchased\n', '\t * @return The multiplier in (10 ** 6)\n', '\t * @return The bonus percentage\n', '\t * @return The amount of network token as bonus\n', '\t */\n', '\tfunction calculateMultiplierAndBonus(uint256 _purchaseAmount) public view returns (uint256, uint256, uint256) {\n', '\t\t(uint256 startingPrimordialMultiplier, uint256 endingPrimordialMultiplier, uint256 startingNetworkTokenBonusMultiplier, uint256 endingNetworkTokenBonusMultiplier) = _getSettingVariables();\n', '\t\treturn (\n', '\t\t\tAOLibrary.calculatePrimordialMultiplier(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingPrimordialMultiplier, endingPrimordialMultiplier),\n', '\t\t\tAOLibrary.calculateNetworkTokenBonusPercentage(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier),\n', '\t\t\tAOLibrary.calculateNetworkTokenBonusAmount(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the maximum amount of Primordial an account can burn\n', '\t * @param _account The address of the account\n', '\t * @return The maximum primordial token amount to burn\n', '\t */\n', '\tfunction calculateMaximumBurnAmount(address _account) public view returns (uint256) {\n', '\t\treturn AOLibrary.calculateMaximumBurnAmount(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], ownerMaxMultiplier[_account]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate account&#39;s new multiplier after burn `_amountToBurn` primordial tokens\n', '\t * @param _account The address of the account\n', '\t * @param _amountToBurn The amount of primordial token to burn\n', '\t * @return The new multiplier in (10 ** 6)\n', '\t */\n', '\tfunction calculateMultiplierAfterBurn(address _account, uint256 _amountToBurn) public view returns (uint256) {\n', '\t\trequire (calculateMaximumBurnAmount(_account) >= _amountToBurn);\n', '\t\treturn AOLibrary.calculateMultiplierAfterBurn(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToBurn);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate account&#39;s new multiplier after converting `amountToConvert` network token to primordial token\n', '\t * @param _account The address of the account\n', '\t * @param _amountToConvert The amount of network token to convert\n', '\t * @return The new multiplier in (10 ** 6)\n', '\t */\n', '\tfunction calculateMultiplierAfterConversion(address _account, uint256 _amountToConvert) public view returns (uint256) {\n', '\t\treturn AOLibrary.calculateMultiplierAfterConversion(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToConvert);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Convert `_value` of network tokens to primordial tokens\n', '\t *\t\tand re-weight the account&#39;s multiplier after conversion\n', '\t * @param _value The amount to convert\n', '\t * @return true on success\n', '\t */\n', '\tfunction convertToPrimordial(uint256 _value) public returns (bool success) {\n', '\t\trequire (balanceOf[msg.sender] >= _value);\n', '\n', '\t\t// Update the account&#39;s multiplier\n', '\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterConversion(msg.sender, _value);\n', '\t\t// Burn network token\n', '\t\tburn(_value);\n', '\t\t// mint primordial token\n', '\t\t_mintPrimordialToken(msg.sender, _value);\n', '\n', '\t\t// Store convert lot info\n', '\t\ttotalConvertLots++;\n', '\n', '\t\t// Generate convert lot Id\n', '\t\tbytes32 convertLotId = keccak256(abi.encodePacked(this, msg.sender, totalConvertLots));\n', '\n', '\t\t// Make sure no one owns this lot yet\n', '\t\trequire (convertLots[convertLotId].lotOwner == address(0));\n', '\n', '\t\tConvertLot storage convertLot = convertLots[convertLotId];\n', '\t\tconvertLot.convertLotId = convertLotId;\n', '\t\tconvertLot.lotOwner = msg.sender;\n', '\t\tconvertLot.tokenAmount = _value;\n', '\t\townedConvertLots[msg.sender].push(convertLotId);\n', '\t\temit ConvertLotCreation(convertLot.lotOwner, convertLot.convertLotId, convertLot.tokenAmount, ownerWeightedMultiplier[convertLot.lotOwner]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** NETWORK TOKEN & PRIMORDIAL TOKEN METHODS *****/\n', '\t/**\n', '\t * @dev Send `_value` network tokens and `_primordialValue` primordial tokens to `_to` from your account\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount of network tokens to send\n', '\t * @param _primordialValue The amount of Primordial tokens to send\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferTokens(address _to, uint256 _value, uint256 _primordialValue) public returns (bool success) {\n', '\t\trequire (super.transfer(_to, _value));\n', '\t\trequire (transferPrimordialToken(_to, _primordialValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Send `_value` network tokens and `_primordialValue` primordial tokens to `_to` from `_from`\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount of network tokens tokens to send\n', '\t * @param _primordialValue The amount of Primordial tokens to send\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferTokensFrom(address _from, address _to, uint256 _value, uint256 _primordialValue) public returns (bool success) {\n', '\t\trequire (super.transferFrom(_from, _to, _value));\n', '\t\trequire (transferPrimordialTokenFrom(_from, _to, _primordialValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows `_spender` to spend no more than `_value` network tokens and `_primordialValue` Primordial tokens in your behalf\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value The max amount of network tokens they can spend\n', '\t * @param _primordialValue The max amount of network tokens they can spend\n', '\t * @return true on success\n', '\t */\n', '\tfunction approveTokens(address _spender, uint256 _value, uint256 _primordialValue) public returns (bool success) {\n', '\t\trequire (super.approve(_spender, _value));\n', '\t\trequire (approvePrimordialToken(_spender, _primordialValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows `_spender` to spend no more than `_value` network tokens and `_primordialValue` Primordial tokens in your behalf, and then ping the contract about it\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value The max amount of network tokens they can spend\n', '\t * @param _primordialValue The max amount of Primordial Tokens they can spend\n', '\t * @param _extraData some extra information to send to the approved contract\n', '\t * @return true on success\n', '\t */\n', '\tfunction approveTokensAndCall(address _spender, uint256 _value, uint256 _primordialValue, bytes _extraData) public returns (bool success) {\n', '\t\trequire (super.approveAndCall(_spender, _value, _extraData));\n', '\t\trequire (approvePrimordialTokenAndCall(_spender, _primordialValue, _extraData));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Remove `_value` network tokens and `_primordialValue` Primordial tokens from the system irreversibly\n', '\t * @param _value The amount of network tokens to burn\n', '\t * @param _primordialValue The amount of Primordial tokens to burn\n', '\t * @return true on success\n', '\t */\n', '\tfunction burnTokens(uint256 _value, uint256 _primordialValue) public returns (bool success) {\n', '\t\trequire (super.burn(_value));\n', '\t\trequire (burnPrimordialToken(_primordialValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Remove `_value` network tokens and `_primordialValue` Primordial tokens from the system irreversibly on behalf of `_from`\n', '\t * @param _from The address of sender\n', '\t * @param _value The amount of network tokens to burn\n', '\t * @param _primordialValue The amount of Primordial tokens to burn\n', '\t * @return true on success\n', '\t */\n', '\tfunction burnTokensFrom(address _from, uint256 _value, uint256 _primordialValue) public returns (bool success) {\n', '\t\trequire (super.burnFrom(_from, _value));\n', '\t\trequire (burnPrimordialTokenFrom(_from, _primordialValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/***** PRIMORDIAL TOKEN INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Calculate the amount of token the buyer will receive and remaining budget if exist\n', '\t *\t\twhen he/she buys primordial token\n', '\t * @param _budget The amount of ETH sent by buyer\n', '\t * @return uint256 of the tokenAmount the buyer will receiver\n', '\t * @return uint256 of the remaining budget, if exist\n', '\t * @return bool whether or not the network exchange should end\n', '\t */\n', '\tfunction _calculateTokenAmountAndRemainderBudget(uint256 _budget) internal view returns (uint256, uint256, bool) {\n', '\t\t// Calculate the amount of tokens\n', '\t\tuint256 tokenAmount = _budget.div(primordialBuyPrice);\n', '\n', '\t\t// If we need to return ETH to the buyer, in the case\n', '\t\t// where the buyer sends more ETH than available primordial token to be purchased\n', '\t\tuint256 remainderEth = 0;\n', '\n', '\t\t// Make sure primordialTotalBought is not overflowing\n', '\t\tbool shouldEndNetworkExchange = false;\n', '\t\tif (primordialTotalBought.add(tokenAmount) >= TOTAL_PRIMORDIAL_FOR_SALE) {\n', '\t\t\ttokenAmount = TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\n', '\t\t\tshouldEndNetworkExchange = true;\n', '\t\t\tremainderEth = msg.value.sub(tokenAmount.mul(primordialBuyPrice));\n', '\t\t}\n', '\t\treturn (tokenAmount, remainderEth, shouldEndNetworkExchange);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Actually sending the primordial token to buyer and reward AO devs accordingly\n', '\t * @param tokenAmount The amount of primordial token to be sent to buyer\n', '\t * @param to The recipient of the token\n', '\t */\n', '\tfunction _sendPrimordialTokenAndRewardDev(uint256 tokenAmount, address to) internal {\n', '\t\t(uint256 startingPrimordialMultiplier,, uint256 startingNetworkTokenBonusMultiplier, uint256 endingNetworkTokenBonusMultiplier) = _getSettingVariables();\n', '\n', '\t\t// Update primordialTotalBought\n', '\t\t(uint256 multiplier, uint256 networkTokenBonusPercentage, uint256 networkTokenBonusAmount) = calculateMultiplierAndBonus(tokenAmount);\n', '\t\tprimordialTotalBought = primordialTotalBought.add(tokenAmount);\n', '\t\t_createPrimordialLot(to, tokenAmount, multiplier, networkTokenBonusAmount);\n', '\n', '\t\t// Calculate The AO and AO Dev Team&#39;s portion of Primordial and Network Token Bonus\n', '\t\tuint256 inverseMultiplier = startingPrimordialMultiplier.sub(multiplier); // Inverse of the buyer&#39;s multiplier\n', '\t\tuint256 theAONetworkTokenBonusAmount = (startingNetworkTokenBonusMultiplier.sub(networkTokenBonusPercentage).add(endingNetworkTokenBonusMultiplier)).mul(tokenAmount).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\t\tif (aoDevTeam1 != address(0)) {\n', '\t\t\t_createPrimordialLot(aoDevTeam1, tokenAmount.div(2), inverseMultiplier, theAONetworkTokenBonusAmount.div(2));\n', '\t\t}\n', '\t\tif (aoDevTeam2 != address(0)) {\n', '\t\t\t_createPrimordialLot(aoDevTeam2, tokenAmount.div(2), inverseMultiplier, theAONetworkTokenBonusAmount.div(2));\n', '\t\t}\n', '\t\t_mintToken(theAO, theAONetworkTokenBonusAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create a lot with `primordialTokenAmount` of primordial tokens with `_multiplier` for an `account`\n', '\t *\t\tduring network exchange, and reward `_networkTokenBonusAmount` if exist\n', '\t * @param _account Address of the lot owner\n', '\t * @param _primordialTokenAmount The amount of primordial tokens to be stored in the lot\n', '\t * @param _multiplier The multiplier for this lot in (10 ** 6)\n', '\t * @param _networkTokenBonusAmount The network token bonus amount\n', '\t */\n', '\tfunction _createPrimordialLot(address _account, uint256 _primordialTokenAmount, uint256 _multiplier, uint256 _networkTokenBonusAmount) internal {\n', '\t\ttotalLots++;\n', '\n', '\t\t// Generate lotId\n', '\t\tbytes32 lotId = keccak256(abi.encodePacked(this, _account, totalLots));\n', '\n', '\t\t// Make sure no one owns this lot yet\n', '\t\trequire (lots[lotId].lotOwner == address(0));\n', '\n', '\t\tLot storage lot = lots[lotId];\n', '\t\tlot.lotId = lotId;\n', '\t\tlot.multiplier = _multiplier;\n', '\t\tlot.lotOwner = _account;\n', '\t\tlot.tokenAmount = _primordialTokenAmount;\n', '\t\townedLots[_account].push(lotId);\n', '\t\townerWeightedMultiplier[_account] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_account], primordialBalanceOf[_account], lot.multiplier, lot.tokenAmount);\n', '\t\t// If this is the first lot, set this as the max multiplier of the account\n', '\t\tif (ownedLots[_account].length == 1) {\n', '\t\t\townerMaxMultiplier[_account] = lot.multiplier;\n', '\t\t}\n', '\t\t_mintPrimordialToken(_account, lot.tokenAmount);\n', '\t\t_mintToken(_account, _networkTokenBonusAmount);\n', '\n', '\t\temit LotCreation(lot.lotOwner, lot.lotId, lot.multiplier, lot.tokenAmount, _networkTokenBonusAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` Primordial tokens and send it to `target`\n', '\t * @param target Address to receive the Primordial tokens\n', '\t * @param mintedAmount The amount of Primordial tokens it will receive\n', '\t */\n', '\tfunction _mintPrimordialToken(address target, uint256 mintedAmount) internal {\n', '\t\tprimordialBalanceOf[target] = primordialBalanceOf[target].add(mintedAmount);\n', '\t\tprimordialTotalSupply = primordialTotalSupply.add(mintedAmount);\n', '\t\temit PrimordialTransfer(0, this, mintedAmount);\n', '\t\temit PrimordialTransfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create a lot with `tokenAmount` of tokens at `weightedMultiplier` for an `account`\n', '\t * @param _account Address of lot owner\n', '\t * @param _tokenAmount The amount of tokens\n', '\t * @param _weightedMultiplier The multiplier of the lot (in 10^6)\n', '\t * @return bytes32 of new created lot ID\n', '\t */\n', '\tfunction _createWeightedMultiplierLot(address _account, uint256 _tokenAmount, uint256 _weightedMultiplier) internal returns (bytes32) {\n', '\t\trequire (_account != address(0));\n', '\t\trequire (_tokenAmount > 0);\n', '\n', '\t\ttotalLots++;\n', '\n', '\t\t// Generate lotId\n', '\t\tbytes32 lotId = keccak256(abi.encodePacked(this, _account, totalLots));\n', '\n', '\t\t// Make sure no one owns this lot yet\n', '\t\trequire (lots[lotId].lotOwner == address(0));\n', '\n', '\t\tLot storage lot = lots[lotId];\n', '\t\tlot.lotId = lotId;\n', '\t\tlot.multiplier = _weightedMultiplier;\n', '\t\tlot.lotOwner = _account;\n', '\t\tlot.tokenAmount = _tokenAmount;\n', '\t\townedLots[_account].push(lotId);\n', '\t\t// If this is the first lot, set this as the max multiplier of the account\n', '\t\tif (ownedLots[_account].length == 1) {\n', '\t\t\townerMaxMultiplier[_account] = lot.multiplier;\n', '\t\t}\n', '\t\treturn lotId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Send `_value` Primordial tokens from `_from` to `_to`\n', '\t * @param _from The address of sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t */\n', '\tfunction _transferPrimordialToken(address _from, address _to, uint256 _value) internal returns (bool) {\n', '\t\trequire (_to != address(0));\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire (primordialBalanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (primordialBalanceOf[_to].add(_value) >= primordialBalanceOf[_to]);\t// Check for overflows\n', '\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t\t\t// Check if sender is frozen\n', '\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t\t\t// Check if recipient is frozen\n', '\t\tuint256 previousBalances = primordialBalanceOf[_from].add(primordialBalanceOf[_to]);\n', '\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\t\t\t// Subtract from the sender\n', '\t\tprimordialBalanceOf[_to] = primordialBalanceOf[_to].add(_value);\t\t\t\t// Add the same to the recipient\n', '\t\temit PrimordialTransfer(_from, _to, _value);\n', '\t\tassert(primordialBalanceOf[_from].add(primordialBalanceOf[_to]) == previousBalances);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store burn lot information\n', '\t * @param _account The address of the account\n', '\t * @param _tokenAmount The amount of primordial tokens to burn\n', '\t */\n', '\tfunction _createBurnLot(address _account, uint256 _tokenAmount) internal {\n', '\t\ttotalBurnLots++;\n', '\n', '\t\t// Generate burn lot Id\n', '\t\tbytes32 burnLotId = keccak256(abi.encodePacked(this, _account, totalBurnLots));\n', '\n', '\t\t// Make sure no one owns this lot yet\n', '\t\trequire (burnLots[burnLotId].lotOwner == address(0));\n', '\n', '\t\tBurnLot storage burnLot = burnLots[burnLotId];\n', '\t\tburnLot.burnLotId = burnLotId;\n', '\t\tburnLot.lotOwner = _account;\n', '\t\tburnLot.tokenAmount = _tokenAmount;\n', '\t\townedBurnLots[_account].push(burnLotId);\n', '\t\temit BurnLotCreation(burnLot.lotOwner, burnLot.burnLotId, burnLot.tokenAmount, ownerWeightedMultiplier[burnLot.lotOwner]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting variables\n', '\t * @return startingPrimordialMultiplier The starting multiplier used to calculate primordial token\n', '\t * @return endingPrimordialMultiplier The ending multiplier used to calculate primordial token\n', '\t * @return startingNetworkTokenBonusMultiplier The starting multiplier used to calculate network token bonus\n', '\t * @return endingNetworkTokenBonusMultiplier The ending multiplier used to calculate network token bonus\n', '\t */\n', '\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256, uint256) {\n', '\t\t(uint256 startingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;startingPrimordialMultiplier&#39;);\n', '\t\t(uint256 endingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;endingPrimordialMultiplier&#39;);\n', '\n', '\t\t(uint256 startingNetworkTokenBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;startingNetworkTokenBonusMultiplier&#39;);\n', '\t\t(uint256 endingNetworkTokenBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;endingNetworkTokenBonusMultiplier&#39;);\n', '\n', '\t\treturn (startingPrimordialMultiplier, endingPrimordialMultiplier, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOTreasury\n', ' *\n', ' * The purpose of this contract is to list all of the valid denominations of AO Token and do the conversion between denominations\n', ' */\n', 'contract AOTreasury is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\tbool public paused;\n', '\tbool public killed;\n', '\n', '\tstruct Denomination {\n', '\t\tbytes8 name;\n', '\t\taddress denominationAddress;\n', '\t}\n', '\n', '\t// Mapping from denomination index to Denomination object\n', '\t// The list is in order from lowest denomination to highest denomination\n', '\t// i.e, denominations[1] is the base denomination\n', '\tmapping (uint256 => Denomination) internal denominations;\n', '\n', '\t// Mapping from denomination ID to index of denominations\n', '\tmapping (bytes8 => uint256) internal denominationIndex;\n', '\n', '\tuint256 public totalDenominations;\n', '\n', '\t// Event to be broadcasted to public when a token exchange happens\n', '\tevent Exchange(address indexed account, uint256 amount, bytes8 fromDenominationName, bytes8 toDenominationName);\n', '\n', '\t// Event to be broadcasted to public when emergency mode is triggered\n', '\tevent EscapeHatch();\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor() public {}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if contract is currently active\n', '\t */\n', '\tmodifier isContractActive {\n', '\t\trequire (paused == false && killed == false);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if denomination is valid\n', '\t */\n', '\tmodifier isValidDenomination(bytes8 denominationName) {\n', '\t\trequire (denominationIndex[denominationName] > 0 && denominations[denominationIndex[denominationName]].denominationAddress != address(0));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO pauses/unpauses contract\n', '\t * @param _paused Either to pause contract or not\n', '\t */\n', '\tfunction setPaused(bool _paused) public onlyTheAO {\n', '\t\tpaused = _paused;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO triggers emergency mode.\n', '\t *\n', '\t */\n', '\tfunction escapeHatch() public onlyTheAO {\n', '\t\trequire (killed == false);\n', '\t\tkilled = true;\n', '\t\temit EscapeHatch();\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO adds denomination and the contract address associated with it\n', '\t * @param denominationName The name of the denomination, i.e ao, kilo, mega, etc.\n', '\t * @param denominationAddress The address of the denomination token\n', '\t * @return true on success\n', '\t */\n', '\tfunction addDenomination(bytes8 denominationName, address denominationAddress) public onlyTheAO returns (bool) {\n', '\t\trequire (denominationName.length != 0);\n', '\t\trequire (denominationAddress != address(0));\n', '\t\trequire (denominationIndex[denominationName] == 0);\n', '\t\ttotalDenominations++;\n', '\t\t// Make sure the new denomination is higher than the previous\n', '\t\tif (totalDenominations > 1) {\n', '\t\t\tAOTokenInterface _lastDenominationToken = AOTokenInterface(denominations[totalDenominations - 1].denominationAddress);\n', '\t\t\tAOTokenInterface _newDenominationToken = AOTokenInterface(denominationAddress);\n', '\t\t\trequire (_newDenominationToken.powerOfTen() > _lastDenominationToken.powerOfTen());\n', '\t\t}\n', '\t\tdenominations[totalDenominations].name = denominationName;\n', '\t\tdenominations[totalDenominations].denominationAddress = denominationAddress;\n', '\t\tdenominationIndex[denominationName] = totalDenominations;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO updates denomination address or activates/deactivates the denomination\n', '\t * @param denominationName The name of the denomination, i.e ao, kilo, mega, etc.\n', '\t * @param denominationAddress The address of the denomination token\n', '\t * @return true on success\n', '\t */\n', '\tfunction updateDenomination(bytes8 denominationName, address denominationAddress) public onlyTheAO returns (bool) {\n', '\t\trequire (denominationName.length != 0);\n', '\t\trequire (denominationIndex[denominationName] > 0);\n', '\t\trequire (denominationAddress != address(0));\n', '\t\tuint256 _denominationNameIndex = denominationIndex[denominationName];\n', '\t\tAOTokenInterface _newDenominationToken = AOTokenInterface(denominationAddress);\n', '\t\tif (_denominationNameIndex > 1) {\n', '\t\t\tAOTokenInterface _prevDenominationToken = AOTokenInterface(denominations[_denominationNameIndex - 1].denominationAddress);\n', '\t\t\trequire (_newDenominationToken.powerOfTen() > _prevDenominationToken.powerOfTen());\n', '\t\t}\n', '\t\tif (_denominationNameIndex < totalDenominations) {\n', '\t\t\tAOTokenInterface _lastDenominationToken = AOTokenInterface(denominations[totalDenominations].denominationAddress);\n', '\t\t\trequire (_newDenominationToken.powerOfTen() < _lastDenominationToken.powerOfTen());\n', '\t\t}\n', '\t\tdenominations[denominationIndex[denominationName]].denominationAddress = denominationAddress;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Get denomination info based on name\n', '\t * @param denominationName The name to be queried\n', '\t * @return the denomination short name\n', '\t * @return the denomination address\n', '\t * @return the denomination public name\n', '\t * @return the denomination symbol\n', '\t * @return the denomination num of decimals\n', '\t * @return the denomination multiplier (power of ten)\n', '\t */\n', '\tfunction getDenominationByName(bytes8 denominationName) public view returns (bytes8, address, string, string, uint8, uint256) {\n', '\t\trequire (denominationName.length != 0);\n', '\t\trequire (denominationIndex[denominationName] > 0);\n', '\t\trequire (denominations[denominationIndex[denominationName]].denominationAddress != address(0));\n', '\t\tAOTokenInterface _ao = AOTokenInterface(denominations[denominationIndex[denominationName]].denominationAddress);\n', '\t\treturn (\n', '\t\t\tdenominations[denominationIndex[denominationName]].name,\n', '\t\t\tdenominations[denominationIndex[denominationName]].denominationAddress,\n', '\t\t\t_ao.name(),\n', '\t\t\t_ao.symbol(),\n', '\t\t\t_ao.decimals(),\n', '\t\t\t_ao.powerOfTen()\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get denomination info by index\n', '\t * @param index The index to be queried\n', '\t * @return the denomination short name\n', '\t * @return the denomination address\n', '\t * @return the denomination public name\n', '\t * @return the denomination symbol\n', '\t * @return the denomination num of decimals\n', '\t * @return the denomination multiplier (power of ten)\n', '\t */\n', '\tfunction getDenominationByIndex(uint256 index) public view returns (bytes8, address, string, string, uint8, uint256) {\n', '\t\trequire (index > 0 && index <= totalDenominations);\n', '\t\trequire (denominations[index].denominationAddress != address(0));\n', '\t\tAOTokenInterface _ao = AOTokenInterface(denominations[index].denominationAddress);\n', '\t\treturn (\n', '\t\t\tdenominations[index].name,\n', '\t\t\tdenominations[index].denominationAddress,\n', '\t\t\t_ao.name(),\n', '\t\t\t_ao.symbol(),\n', '\t\t\t_ao.decimals(),\n', '\t\t\t_ao.powerOfTen()\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get base denomination info\n', '\t * @return the denomination short name\n', '\t * @return the denomination address\n', '\t * @return the denomination public name\n', '\t * @return the denomination symbol\n', '\t * @return the denomination num of decimals\n', '\t * @return the denomination multiplier (power of ten)\n', '\t */\n', '\tfunction getBaseDenomination() public view returns (bytes8, address, string, string, uint8, uint256) {\n', '\t\trequire (totalDenominations > 1);\n', '\t\treturn getDenominationByIndex(1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev convert token from `denominationName` denomination to base denomination,\n', '\t *\t\tin this case it&#39;s similar to web3.toWei() functionality\n', '\t *\n', '\t * Example:\n', '\t * 9.1 Kilo should be entered as 9 integerAmount and 100 fractionAmount\n', '\t * 9.02 Kilo should be entered as 9 integerAmount and 20 fractionAmount\n', '\t * 9.001 Kilo should be entered as 9 integerAmount and 1 fractionAmount\n', '\t *\n', '\t * @param integerAmount uint256 of the integer amount to be converted\n', '\t * @param fractionAmount uint256 of the frational amount to be converted\n', '\t * @param denominationName bytes8 name of the token denomination\n', '\t * @return uint256 converted amount in base denomination from target denomination\n', '\t */\n', '\tfunction toBase(uint256 integerAmount, uint256 fractionAmount, bytes8 denominationName) public view returns (uint256) {\n', '\t\tif (denominationName.length > 0 &&\n', '\t\t\tdenominationIndex[denominationName] > 0 &&\n', '\t\t\tdenominations[denominationIndex[denominationName]].denominationAddress != address(0) &&\n', '\t\t\t(integerAmount > 0 || fractionAmount > 0)) {\n', '\n', '\t\t\tDenomination memory _denomination = denominations[denominationIndex[denominationName]];\n', '\t\t\tAOTokenInterface _denominationToken = AOTokenInterface(_denomination.denominationAddress);\n', '\t\t\tuint8 fractionNumDigits = _numDigits(fractionAmount);\n', '\t\t\trequire (fractionNumDigits <= _denominationToken.decimals());\n', '\t\t\tuint256 baseInteger = integerAmount.mul(10 ** _denominationToken.powerOfTen());\n', '\t\t\tif (_denominationToken.decimals() == 0) {\n', '\t\t\t\tfractionAmount = 0;\n', '\t\t\t}\n', '\t\t\treturn baseInteger.add(fractionAmount);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev convert token from base denomination to `denominationName` denomination,\n', '\t *\t\tin this case it&#39;s similar to web3.fromWei() functionality\n', '\t * @param integerAmount uint256 of the base amount to be converted\n', '\t * @param denominationName bytes8 name of the target token denomination\n', '\t * @return uint256 of the converted integer amount in target denomination\n', '\t * @return uint256 of the converted fraction amount in target denomination\n', '\t */\n', '\tfunction fromBase(uint256 integerAmount, bytes8 denominationName) public isValidDenomination(denominationName) view returns (uint256, uint256) {\n', '\t\tDenomination memory _denomination = denominations[denominationIndex[denominationName]];\n', '\t\tAOTokenInterface _denominationToken = AOTokenInterface(_denomination.denominationAddress);\n', '\t\tuint256 denominationInteger = integerAmount.div(10 ** _denominationToken.powerOfTen());\n', '\t\tuint256 denominationFraction = integerAmount.sub(denominationInteger.mul(10 ** _denominationToken.powerOfTen()));\n', '\t\treturn (denominationInteger, denominationFraction);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev exchange `amount` token from `fromDenominationName` denomination to token in `toDenominationName` denomination\n', '\t * @param amount The amount of token to exchange\n', '\t * @param fromDenominationName The origin denomination\n', '\t * @param toDenominationName The target denomination\n', '\t */\n', '\tfunction exchange(uint256 amount, bytes8 fromDenominationName, bytes8 toDenominationName) public isContractActive isValidDenomination(fromDenominationName) isValidDenomination(toDenominationName) {\n', '\t\trequire (amount > 0);\n', '\t\tDenomination memory _fromDenomination = denominations[denominationIndex[fromDenominationName]];\n', '\t\tDenomination memory _toDenomination = denominations[denominationIndex[toDenominationName]];\n', '\t\tAOTokenInterface _fromDenominationToken = AOTokenInterface(_fromDenomination.denominationAddress);\n', '\t\tAOTokenInterface _toDenominationToken = AOTokenInterface(_toDenomination.denominationAddress);\n', '\t\trequire (_fromDenominationToken.whitelistBurnFrom(msg.sender, amount));\n', '\t\trequire (_toDenominationToken.mintToken(msg.sender, amount));\n', '\t\temit Exchange(msg.sender, amount, fromDenominationName, toDenominationName);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the highest possible denomination given a base amount\n', '\t * @param amount The amount to be converted\n', '\t * @return the denomination short name\n', '\t * @return the denomination address\n', '\t * @return the integer amount at the denomination level\n', '\t * @return the fraction amount at the denomination level\n', '\t * @return the denomination public name\n', '\t * @return the denomination symbol\n', '\t * @return the denomination num of decimals\n', '\t * @return the denomination multiplier (power of ten)\n', '\t */\n', '\tfunction toHighestDenomination(uint256 amount) public view returns (bytes8, address, uint256, uint256, string, string, uint8, uint256) {\n', '\t\tuint256 integerAmount;\n', '\t\tuint256 fractionAmount;\n', '\t\tuint256 index;\n', '\t\tfor (uint256 i=totalDenominations; i>0; i--) {\n', '\t\t\tDenomination memory _denomination = denominations[i];\n', '\t\t\t(integerAmount, fractionAmount) = fromBase(amount, _denomination.name);\n', '\t\t\tif (integerAmount > 0) {\n', '\t\t\t\tindex = i;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire (index > 0 && index <= totalDenominations);\n', '\t\trequire (integerAmount > 0 || fractionAmount > 0);\n', '\t\trequire (denominations[index].denominationAddress != address(0));\n', '\t\tAOTokenInterface _ao = AOTokenInterface(denominations[index].denominationAddress);\n', '\t\treturn (\n', '\t\t\tdenominations[index].name,\n', '\t\t\tdenominations[index].denominationAddress,\n', '\t\t\tintegerAmount,\n', '\t\t\tfractionAmount,\n', '\t\t\t_ao.name(),\n', '\t\t\t_ao.symbol(),\n', '\t\t\t_ao.decimals(),\n', '\t\t\t_ao.powerOfTen()\n', '\t\t);\n', '\t}\n', '\n', '\t/***** INTERNAL METHOD *****/\n', '\t/**\n', '\t * @dev count num of digits\n', '\t * @param number uint256 of the nuumber to be checked\n', '\t * @return uint8 num of digits\n', '\t */\n', '\tfunction _numDigits(uint256 number) internal pure returns (uint8) {\n', '\t\tuint8 digits = 0;\n', '\t\twhile(number != 0) {\n', '\t\t\tnumber = number.div(10);\n', '\t\t\tdigits++;\n', '\t\t}\n', '\t\treturn digits;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Pathos is TAOCurrency {\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\n', '\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {}\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract Ethos is TAOCurrency {\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\n', '\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAOController\n', ' */\n', 'contract TAOController {\n', '\tNameFactory internal _nameFactory;\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress) public {\n', '\t\t_nameFactory = NameFactory(_nameFactoryAddress);\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_id` is a Name or a TAO\n', '\t */\n', '\tmodifier isNameOrTAO(address _id) {\n', '\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check is msg.sender address is a Name\n', '\t */\n', '\t modifier senderIsName() {\n', '\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\n', '\t\t_;\n', '\t }\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of TAO ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', '\t\t// Store the name lookup for a Name/TAO\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAOFamily\n', ' */\n', 'contract TAOFamily is TAOController {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public taoFactoryAddress;\n', '\n', '\tTAOFactory internal _taoFactory;\n', '\n', '\tstruct Child {\n', '\t\taddress taoId;\n', '\t\tbool approved;\t\t// If false, then waiting for parent TAO approval\n', '\t\tbool connected;\t\t// If false, then parent TAO want to remove this child TAO\n', '\t}\n', '\n', '\tstruct Family {\n', '\t\taddress taoId;\n', '\t\taddress parentId;\t// The parent of this TAO ID (could be a Name or TAO)\n', '\t\tuint256 childMinLogos;\n', '\t\tmapping (uint256 => Child) children;\n', '\t\tmapping (address => uint256) childInternalIdLookup;\n', '\t\tuint256 totalChildren;\n', '\t\tuint256 childInternalId;\n', '\t}\n', '\n', '\tmapping (address => Family) internal families;\n', '\n', '\t// Event to be broadcasted to public when Advocate updates min required Logos to create a child TAO\n', '\tevent UpdateChildMinLogos(address indexed taoId, uint256 childMinLogos, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when a TAO adds a child TAO\n', '\tevent AddChild(address indexed taoId, address childId, bool approved, bool connected, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when a TAO approves a child TAO\n', '\tevent ApproveChild(address indexed taoId, address childId, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when a TAO removes a child TAO\n', '\tevent RemoveChild(address indexed taoId, address childId, uint256 nonce);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress, address _taoFactoryAddress)\n', '\t\tTAOController(_nameFactoryAddress, _nameTAOPositionAddress) public {\n', '\t\ttaoFactoryAddress = _taoFactoryAddress;\n', '\t\t_taoFactory = TAOFactory(_taoFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if calling address is Factory\n', '\t */\n', '\tmodifier onlyFactory {\n', '\t\trequire (msg.sender == taoFactoryAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Check whether or not a TAO ID exist in the list of families\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isExist(address _id) public view returns (bool) {\n', '\t\treturn families[_id].taoId != address(0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Store the Family info for a TAO\n', '\t * @param _id The ID of the TAO\n', '\t * @param _parentId The parent ID of this TAO\n', '\t * @param _childMinLogos The min required Logos to create a TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction add(address _id, address _parentId, uint256 _childMinLogos)\n', '\t\tpublic\n', '\t\tisTAO(_id)\n', '\t\tisNameOrTAO(_parentId)\n', '\t\tonlyFactory returns (bool) {\n', '\t\trequire (!isExist(_id));\n', '\n', '\t\tFamily storage _family = families[_id];\n', '\t\t_family.taoId = _id;\n', '\t\t_family.parentId = _parentId;\n', '\t\t_family.childMinLogos = _childMinLogos;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Family info given a TAO ID\n', '\t * @param _id The ID of the TAO\n', '\t * @return the parent ID of this TAO (could be a Name/TAO)\n', '\t * @return the min required Logos to create a child TAO\n', '\t * @return the total child TAOs count\n', '\t */\n', '\tfunction getFamilyById(address _id) public view returns (address, uint256, uint256) {\n', '\t\trequire (isExist(_id));\n', '\t\tFamily memory _family = families[_id];\n', '\t\treturn (\n', '\t\t\t_family.parentId,\n', '\t\t\t_family.childMinLogos,\n', '\t\t\t_family.totalChildren\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set min required Logos to create a child from this TAO\n', '\t * @param _childMinLogos The min Logos to set\n', '\t * @return the nonce for this transaction\n', '\t */\n', '\tfunction updateChildMinLogos(address _id, uint256 _childMinLogos)\n', '\t\tpublic\n', '\t\tisTAO(_id)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_id) {\n', '\t\trequire (isExist(_id));\n', '\n', '\t\tFamily storage _family = families[_id];\n', '\t\t_family.childMinLogos = _childMinLogos;\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_id);\n', '\t\trequire (_nonce > 0);\n', '\t\temit UpdateChildMinLogos(_id, _family.childMinLogos, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_childId` is a child TAO of `_taoId`\n', '\t * @param _taoId The TAO ID to be checked\n', '\t * @param _childId The child TAO ID to check\n', '\t * @return true if yes. Otherwise return false.\n', '\t */\n', '\tfunction isChild(address _taoId, address _childId) public view returns (bool) {\n', '\t\trequire (isExist(_taoId) && isExist(_childId));\n', '\t\tFamily storage _family = families[_taoId];\n', '\t\tFamily memory _childFamily = families[_childId];\n', '\t\tuint256 _childInternalId = _family.childInternalIdLookup[_childId];\n', '\t\treturn (\n', '\t\t\t_childInternalId > 0 &&\n', '\t\t\t_family.children[_childInternalId].approved &&\n', '\t\t\t_family.children[_childInternalId].connected &&\n', '\t\t\t_childFamily.parentId == _taoId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add child TAO\n', '\t * @param _taoId The TAO ID to be added to\n', '\t * @param _childId The ID to be added to as child TAO\n', '\t */\n', '\tfunction addChild(address _taoId, address _childId)\n', '\t\tpublic\n', '\t\tisTAO(_taoId)\n', '\t\tisTAO(_childId)\n', '\t\tonlyFactory returns (bool) {\n', '\t\trequire (!isChild(_taoId, _childId));\n', '\t\tFamily storage _family = families[_taoId];\n', '\t\trequire (_family.childInternalIdLookup[_childId] == 0);\n', '\n', '\t\t_family.childInternalId++;\n', '\t\t_family.childInternalIdLookup[_childId] = _family.childInternalId;\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\tChild storage _child = _family.children[_family.childInternalId];\n', '\t\t_child.taoId = _childId;\n', '\n', '\t\t// If _taoId&#39;s Advocate == _childId&#39;s Advocate, then the child is automatically approved and connected\n', '\t\t// Otherwise, child TAO needs parent TAO approval\n', '\t\taddress _taoAdvocate = _nameTAOPosition.getAdvocate(_taoId);\n', '\t\taddress _childAdvocate = _nameTAOPosition.getAdvocate(_childId);\n', '\t\tif (_taoAdvocate == _childAdvocate) {\n', '\t\t\t_family.totalChildren++;\n', '\t\t\t_child.approved = true;\n', '\t\t\t_child.connected = true;\n', '\n', '\t\t\tFamily storage _childFamily = families[_childId];\n', '\t\t\t_childFamily.parentId = _taoId;\n', '\t\t}\n', '\n', '\t\temit AddChild(_taoId, _childId, _child.approved, _child.connected, _nonce);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of `_taoId` approves child `_childId`\n', '\t * @param _taoId The TAO ID to be checked\n', '\t * @param _childId The child TAO ID to be approved\n', '\t */\n', '\tfunction approveChild(address _taoId, address _childId)\n', '\t\tpublic\n', '\t\tisTAO(_taoId)\n', '\t\tisTAO(_childId)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_taoId) {\n', '\t\trequire (isExist(_taoId) && isExist(_childId));\n', '\t\tFamily storage _family = families[_taoId];\n', '\t\tFamily storage _childFamily = families[_childId];\n', '\t\tuint256 _childInternalId = _family.childInternalIdLookup[_childId];\n', '\n', '\t\trequire (_childInternalId > 0 &&\n', '\t\t\t!_family.children[_childInternalId].approved &&\n', '\t\t\t!_family.children[_childInternalId].connected\n', '\t\t);\n', '\n', '\t\t_family.totalChildren++;\n', '\n', '\t\tChild storage _child = _family.children[_childInternalId];\n', '\t\t_child.approved = true;\n', '\t\t_child.connected = true;\n', '\n', '\t\t_childFamily.parentId = _taoId;\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit ApproveChild(_taoId, _childId, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of `_taoId` removes child `_childId`\n', '\t * @param _taoId The TAO ID to be checked\n', '\t * @param _childId The child TAO ID to be removed\n', '\t */\n', '\tfunction removeChild(address _taoId, address _childId)\n', '\t\tpublic\n', '\t\tisTAO(_taoId)\n', '\t\tisTAO(_childId)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_taoId) {\n', '\t\trequire (isChild(_taoId, _childId));\n', '\n', '\t\tFamily storage _family = families[_taoId];\n', '\t\t_family.totalChildren--;\n', '\n', '\t\tChild storage _child = _family.children[_family.childInternalIdLookup[_childId]];\n', '\t\t_child.connected = false;\n', '\t\t_family.childInternalIdLookup[_childId] = 0;\n', '\n', '\t\tFamily storage _childFamily = families[_childId];\n', '\t\t_childFamily.parentId = address(0);\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit RemoveChild(_taoId, _childId, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get list of child TAO IDs\n', '\t * @param _taoId The TAO ID to be checked\n', '\t * @param _from The starting index (start from 1)\n', '\t * @param _to The ending index, (max is childInternalId)\n', '\t * @return list of child TAO IDs\n', '\t */\n', '\tfunction getChildIds(address _taoId, uint256 _from, uint256 _to) public view returns (address[]) {\n', '\t\trequire (isExist(_taoId));\n', '\t\tFamily storage _family = families[_taoId];\n', '\t\trequire (_from >= 1 && _to >= _from && _family.childInternalId >= _to);\n', '\t\taddress[] memory _childIds = new address[](_to.sub(_from).add(1));\n', '\t\tfor (uint256 i = _from; i <= _to; i++) {\n', '\t\t\t_childIds[i.sub(_from)] = _family.children[i].approved && _family.children[i].connected ? _family.children[i].taoId : address(0);\n', '\t\t}\n', '\t\treturn _childIds;\n', '\t}\n', '}\n', '\t\t\t// Store TAO&#39;s child information\n', '\n', '\n', '\n', '/**\n', ' * @title TAOFactory\n', ' *\n', ' * The purpose of this contract is to allow node to create TAO\n', ' */\n', 'contract TAOFactory is TheAO, TAOController {\n', '\tusing SafeMath for uint256;\n', '\taddress[] internal taos;\n', '\n', '\taddress public taoFamilyAddress;\n', '\taddress public nameTAOVaultAddress;\n', '\taddress public settingTAOId;\n', '\n', '\tNameTAOLookup internal _nameTAOLookup;\n', '\tTAOFamily internal _taoFamily;\n', '\tAOSetting internal _aoSetting;\n', '\tLogos internal _logos;\n', '\n', '\t// Mapping from TAO ID to its nonce\n', '\tmapping (address => uint256) public nonces;\n', '\n', '\t// Event to be broadcasted to public when Advocate creates a TAO\n', '\tevent CreateTAO(address indexed ethAddress, address advocateId, address taoId, uint256 index, address parent, uint8 parentTypeId);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress, address _nameTAOLookupAddress, address _nameTAOPositionAddress, address _aoSettingAddress, address _logosAddress, address _nameTAOVaultAddress)\n', '\t\tTAOController(_nameFactoryAddress, _nameTAOPositionAddress) public {\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\tnameTAOVaultAddress = _nameTAOVaultAddress;\n', '\n', '\t\t_nameTAOLookup = NameTAOLookup(_nameTAOLookupAddress);\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t\t_aoSetting = AOSetting(_aoSettingAddress);\n', '\t\t_logos = Logos(_logosAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if calling address can update TAO&#39;s nonce\n', '\t */\n', '\tmodifier canUpdateNonce {\n', '\t\trequire (msg.sender == nameTAOPositionAddress || msg.sender == taoFamilyAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the TAOFamily Address\n', '\t * @param _taoFamilyAddress The address of TAOFamily\n', '\t */\n', '\tfunction setTAOFamilyAddress(address _taoFamilyAddress) public onlyTheAO {\n', '\t\trequire (_taoFamilyAddress != address(0));\n', '\t\ttaoFamilyAddress = _taoFamilyAddress;\n', '\t\t_taoFamily = TAOFamily(taoFamilyAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set settingTAOId (The TAO ID that holds the setting values)\n', '\t * @param _settingTAOId The address of settingTAOId\n', '\t */\n', '\tfunction setSettingTAOId(address _settingTAOId) public onlyTheAO isTAO(_settingTAOId) {\n', '\t\tsettingTAOId = _settingTAOId;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Increment the nonce of a TAO\n', '\t * @param _taoId The ID of the TAO\n', '\t * @return current nonce\n', '\t */\n', '\tfunction incrementNonce(address _taoId) public canUpdateNonce returns (uint256) {\n', '\t\t// Check if _taoId exist\n', '\t\trequire (nonces[_taoId] > 0);\n', '\t\tnonces[_taoId]++;\n', '\t\treturn nonces[_taoId];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Name creates a TAO\n', '\t * @param _name The name of the TAO\n', '\t * @param _datHash The datHash of this TAO\n', '\t * @param _database The database for this TAO\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this TAO\n', '\t * @param _parentId The parent of this TAO (has to be a Name or TAO)\n', '\t * @param _childMinLogos The min required Logos to create a child from this TAO\n', '\t */\n', '\tfunction createTAO(\n', '\t\tstring _name,\n', '\t\tstring _datHash,\n', '\t\tstring _database,\n', '\t\tstring _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _parentId,\n', '\t\tuint256 _childMinLogos\n', '\t) public senderIsName() isNameOrTAO(_parentId) {\n', '\t\trequire (bytes(_name).length > 0);\n', '\t\trequire (!_nameTAOLookup.isExist(_name));\n', '\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(msg.sender);\n', '\n', '\t\tuint256 _parentCreateChildTAOMinLogos;\n', '\t\tuint256 _createChildTAOMinLogos = _getSettingVariables();\n', '\t\tif (AOLibrary.isTAO(_parentId)) {\n', '\t\t\t(, _parentCreateChildTAOMinLogos,) = _taoFamily.getFamilyById(_parentId);\n', '\t\t}\n', '\t\tif (_parentCreateChildTAOMinLogos > 0) {\n', '\t\t\trequire (_logos.sumBalanceOf(_nameId) >= _parentCreateChildTAOMinLogos);\n', '\t\t} else if (_createChildTAOMinLogos > 0) {\n', '\t\t\trequire (_logos.sumBalanceOf(_nameId) >= _createChildTAOMinLogos);\n', '\t\t}\n', '\n', '\t\t// Create the TAO\n', '\t\taddress taoId = new TAO(_name, _nameId, _datHash, _database, _keyValue, _contentId, nameTAOVaultAddress);\n', '\n', '\t\t// Increment the nonce\n', '\t\tnonces[taoId]++;\n', '\n', '\t\t// Store the name lookup information\n', '\t\trequire (_nameTAOLookup.add(_name, taoId, TAO(_parentId).name(), 0));\n', '\n', '\t\t// Store the Advocate/Listener/Speaker information\n', '\t\trequire (_nameTAOPosition.add(taoId, _nameId, _nameId, _nameId));\n', '\n', '\t\trequire (_taoFamily.add(taoId, _parentId, _childMinLogos));\n', '\t\ttaos.push(taoId);\n', '\n', '\t\temit CreateTAO(msg.sender, _nameId, taoId, taos.length.sub(1), _parentId, TAO(_parentId).typeId());\n', '\n', '\t\tif (AOLibrary.isTAO(_parentId)) {\n', '\t\t\trequire (_taoFamily.addChild(_parentId, taoId));\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get TAO information\n', '\t * @param _taoId The ID of the TAO to be queried\n', '\t * @return The name of the TAO\n', '\t * @return The origin Name ID that created the TAO\n', '\t * @return The name of Name that created the TAO\n', '\t * @return The datHash of the TAO\n', '\t * @return The database of the TAO\n', '\t * @return The keyValue of the TAO\n', '\t * @return The contentId of the TAO\n', '\t * @return The typeId of the TAO\n', '\t */\n', '\tfunction getTAO(address _taoId) public view returns (string, address, string, string, string, string, bytes32, uint8) {\n', '\t\tTAO _tao = TAO(_taoId);\n', '\t\treturn (\n', '\t\t\t_tao.name(),\n', '\t\t\t_tao.originId(),\n', '\t\t\tName(_tao.originId()).name(),\n', '\t\t\t_tao.datHash(),\n', '\t\t\t_tao.database(),\n', '\t\t\t_tao.keyValue(),\n', '\t\t\t_tao.contentId(),\n', '\t\t\t_tao.typeId()\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get total TAOs count\n', '\t * @return total TAOs count\n', '\t */\n', '\tfunction getTotalTAOsCount() public view returns (uint256) {\n', '\t\treturn taos.length;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get list of TAO IDs\n', '\t * @param _from The starting index\n', '\t * @param _to The ending index\n', '\t * @return list of TAO IDs\n', '\t */\n', '\tfunction getTAOIds(uint256 _from, uint256 _to) public view returns (address[]) {\n', '\t\trequire (_from >= 0 && _to >= _from && taos.length > _to);\n', '\n', '\t\taddress[] memory _taos = new address[](_to.sub(_from).add(1));\n', '\t\tfor (uint256 i = _from; i <= _to; i++) {\n', '\t\t\t_taos[i.sub(_from)] = taos[i];\n', '\t\t}\n', '\t\treturn _taos;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the signature is valid\n', '\t * @param _data The signed string data\n', '\t * @param _nonce The signed uint256 nonce (should be TAO&#39;s current nonce + 1)\n', '\t * @param _validateAddress The ETH address to be validated (optional)\n', '\t * @param _name The Name of the TAO\n', '\t * @param _signatureV The V part of the signature\n', '\t * @param _signatureR The R part of the signature\n', '\t * @param _signatureS The S part of the signature\n', '\t * @return true if valid. false otherwise\n', '\t * @return The name of the Name that created the signature\n', '\t * @return The Position of the Name that created the signature.\n', '\t *\t\t\t0 == unknown. 1 == Advocate. 2 == Listener. 3 == Speaker\n', '\t */\n', '\tfunction validateTAOSignature(\n', '\t\tstring _data,\n', '\t\tuint256 _nonce,\n', '\t\taddress _validateAddress,\n', '\t\tstring _name,\n', '\t\tuint8 _signatureV,\n', '\t\tbytes32 _signatureR,\n', '\t\tbytes32 _signatureS\n', '\t) public isTAO(_getTAOIdByName(_name)) view returns (bool, string, uint256) {\n', '\t\taddress _signatureAddress = AOLibrary.getValidateSignatureAddress(address(this), _data, _nonce, _signatureV, _signatureR, _signatureS);\n', '\t\tif (_isTAOSignatureAddressValid(_validateAddress, _signatureAddress, _getTAOIdByName(_name), _nonce)) {\n', '\t\t\treturn (true, Name(_nameFactory.ethAddressToNameId(_signatureAddress)).name(), _nameTAOPosition.determinePosition(_signatureAddress, _getTAOIdByName(_name)));\n', '\t\t} else {\n', '\t\t\treturn (false, "", 0);\n', '\t\t}\n', '\t}\n', '\n', '\t/***** INTERNAL METHOD *****/\n', '\t/**\n', '\t * @dev Check whether or not the address recovered from the signature is valid\n', '\t * @param _validateAddress The ETH address to be validated (optional)\n', '\t * @param _signatureAddress The address recovered from the signature\n', '\t * @param _taoId The ID of the TAO\n', '\t * @param _nonce The signed uint256 nonce\n', '\t * @return true if valid. false otherwise\n', '\t */\n', '\tfunction _isTAOSignatureAddressValid(\n', '\t\taddress _validateAddress,\n', '\t\taddress _signatureAddress,\n', '\t\taddress _taoId,\n', '\t\tuint256 _nonce\n', '\t) internal view returns (bool) {\n', '\t\tif (_validateAddress != address(0)) {\n', '\t\t\treturn (_nonce == nonces[_taoId].add(1) &&\n', '\t\t\t\t_signatureAddress == _validateAddress &&\n', '\t\t\t\t_nameTAOPosition.senderIsPosition(_validateAddress, _taoId)\n', '\t\t\t);\n', '\t\t} else {\n', '\t\t\treturn (\n', '\t\t\t\t_nonce == nonces[_taoId].add(1) &&\n', '\t\t\t\t_nameTAOPosition.senderIsPosition(_signatureAddress, _taoId)\n', '\t\t\t);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Internal function to get the TAO Id by name\n', '\t * @param _name The name of the TAO\n', '\t * @return the TAO ID\n', '\t */\n', '\tfunction _getTAOIdByName(string _name) internal view returns (address) {\n', '\t\treturn _nameTAOLookup.getAddressByName(_name);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting variables\n', '\t * @return createChildTAOMinLogos The minimum required Logos to create a TAO\n', '\t */\n', '\tfunction _getSettingVariables() internal view returns (uint256) {\n', '\t\t(uint256 createChildTAOMinLogos,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;createChildTAOMinLogos&#39;);\n', '\t\treturn createChildTAOMinLogos;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title NameTAOPosition\n', ' */\n', 'contract NameTAOPosition is TheAO {\n', '\taddress public nameFactoryAddress;\n', '\taddress public taoFactoryAddress;\n', '\n', '\tNameFactory internal _nameFactory;\n', '\tTAOFactory internal _taoFactory;\n', '\n', '\tstruct Position {\n', '\t\taddress advocateId;\n', '\t\taddress listenerId;\n', '\t\taddress speakerId;\n', '\t\tbool created;\n', '\t}\n', '\n', '\tmapping (address => Position) internal positions;\n', '\n', '\t// Event to be broadcasted to public when current Advocate of TAO sets New Advocate\n', '\tevent SetAdvocate(address indexed taoId, address oldAdvocateId, address newAdvocateId, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when current Advocate of Name/TAO sets New Listener\n', '\tevent SetListener(address indexed taoId, address oldListenerId, address newListenerId, uint256 nonce);\n', '\n', '\t// Event to be broadcasted to public when current Advocate of Name/TAO sets New Speaker\n', '\tevent SetSpeaker(address indexed taoId, address oldSpeakerId, address newSpeakerId, uint256 nonce);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress) public {\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\t\t_nameFactory = NameFactory(_nameFactoryAddress);\n', '\t\tnameTAOPositionAddress = address(this);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if calling address is Factory\n', '\t */\n', '\tmodifier onlyFactory {\n', '\t\trequire (msg.sender == nameFactoryAddress || msg.sender == taoFactoryAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_id` is a Name or a TAO\n', '\t */\n', '\tmodifier isNameOrTAO(address _id) {\n', '\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check is msg.sender address is a Name\n', '\t */\n', '\t modifier senderIsName() {\n', '\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\n', '\t\t_;\n', '\t }\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of a Name/TAO ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the taoFactoryAddress Address\n', '\t * @param _taoFactoryAddress The address of TAOFactory\n', '\t */\n', '\tfunction setTAOFactoryAddress(address _taoFactoryAddress) public onlyTheAO {\n', '\t\trequire (_taoFactoryAddress != address(0));\n', '\t\ttaoFactoryAddress = _taoFactoryAddress;\n', '\t\t_taoFactory = TAOFactory(_taoFactoryAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Check whether or not a Name/TAO ID exist in the list\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isExist(address _id) public view returns (bool) {\n', '\t\treturn positions[_id].created;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not eth address is advocate of _id\n', '\t * @param _sender The eth address to check\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction senderIsAdvocate(address _sender, address _id) public view returns (bool) {\n', '\t\treturn (positions[_id].created && positions[_id].advocateId == _nameFactory.ethAddressToNameId(_sender));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not eth address is either Advocate/Listener/Speaker of _id\n', '\t * @param _sender The eth address to check\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction senderIsPosition(address _sender, address _id) public view returns (bool) {\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(_sender);\n', '\t\tif (_nameId == address(0)) {\n', '\t\t\treturn false;\n', '\t\t} else {\n', '\t\t\treturn (positions[_id].created &&\n', '\t\t\t\t(positions[_id].advocateId == _nameId ||\n', '\t\t\t\t positions[_id].listenerId == _nameId ||\n', '\t\t\t\t positions[_id].speakerId == _nameId\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not _nameId is advocate of _id\n', '\t * @param _nameId The name ID to be checked\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction nameIsAdvocate(address _nameId, address _id) public view returns (bool) {\n', '\t\treturn (positions[_id].created && positions[_id].advocateId == _nameId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Determine whether or not `_sender` is Advocate/Listener/Speaker of the Name/TAO\n', '\t * @param _sender The ETH address that to check\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @return 1 if Advocate. 2 if Listener. 3 if Speaker\n', '\t */\n', '\tfunction determinePosition(address _sender, address _id) public view returns (uint256) {\n', '\t\trequire (senderIsPosition(_sender, _id));\n', '\t\tPosition memory _position = positions[_id];\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(_sender);\n', '\t\tif (_nameId == _position.advocateId) {\n', '\t\t\treturn 1;\n', '\t\t} else if (_nameId == _position.listenerId) {\n', '\t\t\treturn 2;\n', '\t\t} else {\n', '\t\t\treturn 3;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add Position for a Name/TAO\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @param _advocateId The Advocate ID of the Name/TAO\n', '\t * @param _listenerId The Listener ID of the Name/TAO\n', '\t * @param _speakerId The Speaker ID of the Name/TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction add(address _id, address _advocateId, address _listenerId, address _speakerId)\n', '\t\tpublic\n', '\t\tisNameOrTAO(_id)\n', '\t\tisName(_advocateId)\n', '\t\tisNameOrTAO(_listenerId)\n', '\t\tisNameOrTAO(_speakerId)\n', '\t\tonlyFactory returns (bool) {\n', '\t\trequire (!isExist(_id));\n', '\n', '\t\tPosition storage _position = positions[_id];\n', '\t\t_position.advocateId = _advocateId;\n', '\t\t_position.listenerId = _listenerId;\n', '\t\t_position.speakerId = _speakerId;\n', '\t\t_position.created = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Name/TAO&#39;s Position info\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @return the Advocate ID of Name/TAO\n', '\t * @return the Listener ID of Name/TAO\n', '\t * @return the Speaker ID of Name/TAO\n', '\t */\n', '\tfunction getPositionById(address _id) public view returns (address, address, address) {\n', '\t\trequire (isExist(_id));\n', '\t\tPosition memory _position = positions[_id];\n', '\t\treturn (\n', '\t\t\t_position.advocateId,\n', '\t\t\t_position.listenerId,\n', '\t\t\t_position.speakerId\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Name/TAO&#39;s Advocate\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @return the Advocate ID of Name/TAO\n', '\t */\n', '\tfunction getAdvocate(address _id) public view returns (address) {\n', '\t\trequire (isExist(_id));\n', '\t\tPosition memory _position = positions[_id];\n', '\t\treturn _position.advocateId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Name/TAO&#39;s Listener\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @return the Listener ID of Name/TAO\n', '\t */\n', '\tfunction getListener(address _id) public view returns (address) {\n', '\t\trequire (isExist(_id));\n', '\t\tPosition memory _position = positions[_id];\n', '\t\treturn _position.listenerId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get Name/TAO&#39;s Speaker\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @return the Speaker ID of Name/TAO\n', '\t */\n', '\tfunction getSpeaker(address _id) public view returns (address) {\n', '\t\trequire (isExist(_id));\n', '\t\tPosition memory _position = positions[_id];\n', '\t\treturn _position.speakerId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set Advocate for a TAO\n', '\t * @param _taoId The ID of the TAO\n', '\t * @param _newAdvocateId The new advocate ID to be set\n', '\t */\n', '\tfunction setAdvocate(address _taoId, address _newAdvocateId)\n', '\t\tpublic\n', '\t\tisTAO(_taoId)\n', '\t\tisName(_newAdvocateId)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_taoId) {\n', '\n', '\t\tPosition storage _position = positions[_taoId];\n', '\t\taddress _currentAdvocateId = _position.advocateId;\n', '\t\t_position.advocateId = _newAdvocateId;\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\t\temit SetAdvocate(_taoId, _currentAdvocateId, _position.advocateId, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set Listener for a Name/TAO\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @param _newListenerId The new listener ID to be set\n', '\t */\n', '\tfunction setListener(address _id, address _newListenerId)\n', '\t\tpublic\n', '\t\tisNameOrTAO(_id)\n', '\t\tisNameOrTAO(_newListenerId)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_id) {\n', '\n', '\t\t// If _id is a Name, then new Listener can only be a Name\n', '\t\t// If _id is a TAO, then new Listener can be a TAO/Name\n', '\t\tbool _isName = false;\n', '\t\tif (AOLibrary.isName(_id)) {\n', '\t\t\t_isName = true;\n', '\t\t\trequire (AOLibrary.isName(_newListenerId));\n', '\t\t}\n', '\n', '\t\tPosition storage _position = positions[_id];\n', '\t\taddress _currentListenerId = _position.listenerId;\n', '\t\t_position.listenerId = _newListenerId;\n', '\n', '\t\tif (_isName) {\n', '\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\n', '\t\t} else {\n', '\t\t\t_nonce = _taoFactory.incrementNonce(_id);\n', '\t\t}\n', '\t\temit SetListener(_id, _currentListenerId, _position.listenerId, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set Speaker for a Name/TAO\n', '\t * @param _id The ID of the Name/TAO\n', '\t * @param _newSpeakerId The new speaker ID to be set\n', '\t */\n', '\tfunction setSpeaker(address _id, address _newSpeakerId)\n', '\t\tpublic\n', '\t\tisNameOrTAO(_id)\n', '\t\tisNameOrTAO(_newSpeakerId)\n', '\t\tsenderIsName()\n', '\t\tonlyAdvocate(_id) {\n', '\n', '\t\t// If _id is a Name, then new Speaker can only be a Name\n', '\t\t// If _id is a TAO, then new Speaker can be a TAO/Name\n', '\t\tbool _isName = false;\n', '\t\tif (AOLibrary.isName(_id)) {\n', '\t\t\t_isName = true;\n', '\t\t\trequire (AOLibrary.isName(_newSpeakerId));\n', '\t\t}\n', '\n', '\t\tPosition storage _position = positions[_id];\n', '\t\taddress _currentSpeakerId = _position.speakerId;\n', '\t\t_position.speakerId = _newSpeakerId;\n', '\n', '\t\tif (_isName) {\n', '\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\n', '\t\t} else {\n', '\t\t\t_nonce = _taoFactory.incrementNonce(_id);\n', '\t\t}\n', '\t\temit SetSpeaker(_id, _currentSpeakerId, _position.speakerId, _nonce);\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title AOSetting\n', ' *\n', ' * This contract stores all AO setting variables\n', ' */\n', 'contract AOSetting {\n', '\taddress public aoSettingAttributeAddress;\n', '\taddress public aoUintSettingAddress;\n', '\taddress public aoBoolSettingAddress;\n', '\taddress public aoAddressSettingAddress;\n', '\taddress public aoBytesSettingAddress;\n', '\taddress public aoStringSettingAddress;\n', '\n', '\tNameFactory internal _nameFactory;\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\tAOSettingAttribute internal _aoSettingAttribute;\n', '\tAOUintSetting internal _aoUintSetting;\n', '\tAOBoolSetting internal _aoBoolSetting;\n', '\tAOAddressSetting internal _aoAddressSetting;\n', '\tAOBytesSetting internal _aoBytesSetting;\n', '\tAOStringSetting internal _aoStringSetting;\n', '\n', '\tuint256 public totalSetting;\n', '\n', '\t/**\n', '\t * Mapping from associatedTAOId&#39;s setting name to Setting ID.\n', '\t *\n', '\t * Instead of concatenating the associatedTAOID and setting name to create a unique ID for lookup,\n', '\t * use nested mapping to achieve the same result.\n', '\t *\n', '\t * The setting&#39;s name needs to be converted to bytes32 since solidity does not support mapping by string.\n', '\t */\n', '\tmapping (address => mapping (bytes32 => uint256)) internal nameSettingLookup;\n', '\n', '\t// Mapping from updateHashKey to it&#39;s settingId\n', '\tmapping (bytes32 => uint256) public updateHashLookup;\n', '\n', '\t// Event to be broadcasted to public when a setting is created and waiting for approval\n', '\tevent SettingCreation(uint256 indexed settingId, address indexed creatorNameId, address creatorTAOId, address associatedTAOId, string settingName, uint8 settingType, bytes32 associatedTAOSettingId, bytes32 creatorTAOSettingId);\n', '\n', '\t// Event to be broadcasted to public when setting creation is approved/rejected by the advocate of associatedTAOId\n', '\tevent ApproveSettingCreation(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate, bool approved);\n', '\t// Event to be broadcasted to public when setting creation is finalized by the advocate of creatorTAOId\n', '\tevent FinalizeSettingCreation(uint256 indexed settingId, address creatorTAOId, address creatorTAOAdvocate);\n', '\n', '\t// Event to be broadcasted to public when a proposed update for a setting is created\n', '\tevent SettingUpdate(uint256 indexed settingId, address indexed updateAdvocateNameId, address proposalTAOId);\n', '\n', '\t// Event to be broadcasted to public when setting update is approved/rejected by the advocate of proposalTAOId\n', '\tevent ApproveSettingUpdate(uint256 indexed settingId, address proposalTAOId, address proposalTAOAdvocate, bool approved);\n', '\n', '\t// Event to be broadcasted to public when setting update is finalized by the advocate of associatedTAOId\n', '\tevent FinalizeSettingUpdate(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate);\n', '\n', '\t// Event to be broadcasted to public when a setting deprecation is created and waiting for approval\n', '\tevent SettingDeprecation(uint256 indexed settingId, address indexed creatorNameId, address creatorTAOId, address associatedTAOId, uint256 newSettingId, address newSettingContractAddress, bytes32 associatedTAOSettingDeprecationId, bytes32 creatorTAOSettingDeprecationId);\n', '\n', '\t// Event to be broadcasted to public when setting deprecation is approved/rejected by the advocate of associatedTAOId\n', '\tevent ApproveSettingDeprecation(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate, bool approved);\n', '\n', '\t// Event to be broadcasted to public when setting deprecation is finalized by the advocate of creatorTAOId\n', '\tevent FinalizeSettingDeprecation(uint256 indexed settingId, address creatorTAOId, address creatorTAOAdvocate);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress,\n', '\t\taddress _nameTAOPositionAddress,\n', '\t\taddress _aoSettingAttributeAddress,\n', '\t\taddress _aoUintSettingAddress,\n', '\t\taddress _aoBoolSettingAddress,\n', '\t\taddress _aoAddressSettingAddress,\n', '\t\taddress _aoBytesSettingAddress,\n', '\t\taddress _aoStringSettingAddress) public {\n', '\t\taoSettingAttributeAddress = _aoSettingAttributeAddress;\n', '\t\taoUintSettingAddress = _aoUintSettingAddress;\n', '\t\taoBoolSettingAddress = _aoBoolSettingAddress;\n', '\t\taoAddressSettingAddress = _aoAddressSettingAddress;\n', '\t\taoBytesSettingAddress = _aoBytesSettingAddress;\n', '\t\taoStringSettingAddress = _aoStringSettingAddress;\n', '\n', '\t\t_nameFactory = NameFactory(_nameFactoryAddress);\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t\t_aoSettingAttribute = AOSettingAttribute(_aoSettingAttributeAddress);\n', '\t\t_aoUintSetting = AOUintSetting(_aoUintSettingAddress);\n', '\t\t_aoBoolSetting = AOBoolSetting(_aoBoolSettingAddress);\n', '\t\t_aoAddressSetting = AOAddressSetting(_aoAddressSettingAddress);\n', '\t\t_aoBytesSetting = AOBytesSetting(_aoBytesSettingAddress);\n', '\t\t_aoStringSetting = AOStringSetting(_aoStringSettingAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_settingName` of `_associatedTAOId` is taken\n', '\t */\n', '\tmodifier settingNameNotTaken(string _settingName, address _associatedTAOId) {\n', '\t\trequire (settingNameExist(_settingName, _associatedTAOId) == false);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of Name ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** Public Methods *****/\n', '\t/**\n', '\t * @dev Check whether or not a setting name of an associatedTAOId exist\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction settingNameExist(string _settingName, address _associatedTAOId) public view returns (bool) {\n', '\t\treturn (nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))] > 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a uint setting\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _value The uint256 value of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction addUintSetting(string _settingName, uint256 _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t// Update global variables\n', '\t\ttotalSetting++;\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoUintSetting.setPendingValue(totalSetting, _value);\n', '\n', '\t\t// Store setting creation data\n', '\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 1, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a bool setting\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _value The bool value of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction addBoolSetting(string _settingName, bool _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t// Update global variables\n', '\t\ttotalSetting++;\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoBoolSetting.setPendingValue(totalSetting, _value);\n', '\n', '\t\t// Store setting creation data\n', '\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 2, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds an address setting\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _value The address value of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction addAddressSetting(string _settingName, address _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t// Update global variables\n', '\t\ttotalSetting++;\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoAddressSetting.setPendingValue(totalSetting, _value);\n', '\n', '\t\t// Store setting creation data\n', '\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 3, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a bytes32 setting\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _value The bytes32 value of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction addBytesSetting(string _settingName, bytes32 _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t// Update global variables\n', '\t\ttotalSetting++;\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoBytesSetting.setPendingValue(totalSetting, _value);\n', '\n', '\t\t// Store setting creation data\n', '\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 4, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a string setting\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _value The string value of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction addStringSetting(string _settingName, string _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t// Update global variables\n', '\t\ttotalSetting++;\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoStringSetting.setPendingValue(totalSetting, _value);\n', '\n', '\t\t// Store setting creation data\n', '\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 5, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId approves setting creation\n', '\t * @param _settingId The ID of the setting to approve\n', '\t * @param _approved Whether to approve or reject\n', '\t */\n', '\tfunction approveSettingCreation(uint256 _settingId, bool _approved) public {\n', '\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.approveAdd(_settingId, _associatedTAOAdvocate, _approved));\n', '\n', '\t\t(,,,address _associatedTAOId, string memory _settingName,,,,,) = _aoSettingAttribute.getSettingData(_settingId);\n', '\t\tif (!_approved) {\n', '\t\t\t// Clear the settingName from nameSettingLookup so it can be added again in the future\n', '\t\t\tdelete nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))];\n', '\t\t}\n', '\t\temit ApproveSettingCreation(_settingId, _associatedTAOId, _associatedTAOAdvocate, _approved);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _creatorTAOId finalizes the setting creation once the setting is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t */\n', '\tfunction finalizeSettingCreation(uint256 _settingId) public {\n', '\t\taddress _creatorTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.finalizeAdd(_settingId, _creatorTAOAdvocate));\n', '\n', '\t\t(,,address _creatorTAOId,,, uint8 _settingType,,,,) = _aoSettingAttribute.getSettingData(_settingId);\n', '\n', '\t\t_movePendingToSetting(_settingId, _settingType);\n', '\n', '\t\temit FinalizeSettingCreation(_settingId, _creatorTAOId, _creatorTAOAdvocate);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId submits a uint256 setting update after an update has been proposed\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _newValue The new uint256 value for this setting\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction updateUintSetting(uint256 _settingId, uint256 _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\n', '\t\t// Store the setting state data\n', '\t\trequire (_aoSettingAttribute.update(_settingId, 1, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoUintSetting.setPendingValue(_settingId, _newValue);\n', '\n', '\t\t// Store the update hash key lookup\n', '\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoUintSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\n', '\n', '\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId submits a bool setting update after an update has been proposed\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _newValue The new bool value for this setting\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction updateBoolSetting(uint256 _settingId, bool _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\n', '\t\t// Store the setting state data\n', '\t\trequire (_aoSettingAttribute.update(_settingId, 2, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoBoolSetting.setPendingValue(_settingId, _newValue);\n', '\n', '\t\t// Store the update hash key lookup\n', '\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoBoolSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\n', '\n', '\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId submits an address setting update after an update has been proposed\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _newValue The new address value for this setting\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction updateAddressSetting(uint256 _settingId, address _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\n', '\t\t// Store the setting state data\n', '\t\trequire (_aoSettingAttribute.update(_settingId, 3, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoAddressSetting.setPendingValue(_settingId, _newValue);\n', '\n', '\t\t// Store the update hash key lookup\n', '\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoAddressSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\n', '\n', '\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId submits a bytes32 setting update after an update has been proposed\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _newValue The new bytes32 value for this setting\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction updateBytesSetting(uint256 _settingId, bytes32 _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\n', '\t\t// Store the setting state data\n', '\t\trequire (_aoSettingAttribute.update(_settingId, 4, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoBytesSetting.setPendingValue(_settingId, _newValue);\n', '\n', '\t\t// Store the update hash key lookup\n', '\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoBytesSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\n', '\n', '\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId submits a string setting update after an update has been proposed\n', '\t * @param _settingId The ID of the setting to be updated\n', '\t * @param _newValue The new string value for this setting\n', '\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\n', '\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId&#39;s advocate&#39;s name address\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction updateStringSetting(uint256 _settingId, string _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\n', '\t\t// Store the setting state data\n', '\t\trequire (_aoSettingAttribute.update(_settingId, 5, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\n', '\n', '\t\t// Store the value as pending value\n', '\t\t_aoStringSetting.setPendingValue(_settingId, _newValue);\n', '\n', '\t\t// Store the update hash key lookup\n', '\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoStringSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\n', '\n', '\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s proposalTAOId approves the setting update\n', '\t * @param _settingId The ID of the setting to be approved\n', '\t * @param _approved Whether to approve or reject\n', '\t */\n', '\tfunction approveSettingUpdate(uint256 _settingId, bool _approved) public {\n', '\t\taddress _proposalTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\t(,,, address _proposalTAOId,,,) = _aoSettingAttribute.getSettingState(_settingId);\n', '\n', '\t\trequire (_aoSettingAttribute.approveUpdate(_settingId, _proposalTAOAdvocate, _approved));\n', '\n', '\t\temit ApproveSettingUpdate(_settingId, _proposalTAOId, _proposalTAOAdvocate, _approved);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of Setting&#39;s _associatedTAOId finalizes the setting update once the setting is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t */\n', '\tfunction finalizeSettingUpdate(uint256 _settingId) public {\n', '\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.finalizeUpdate(_settingId, _associatedTAOAdvocate));\n', '\n', '\t\t(,,, address _associatedTAOId,, uint8 _settingType,,,,) = _aoSettingAttribute.getSettingData(_settingId);\n', '\n', '\t\t_movePendingToSetting(_settingId, _settingType);\n', '\n', '\t\temit FinalizeSettingUpdate(_settingId, _associatedTAOId, _associatedTAOAdvocate);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a setting deprecation\n', '\t * @param _settingId The ID of the setting to be deprecated\n', '\t * @param _newSettingId The new setting ID to route\n', '\t * @param _newSettingContractAddress The new setting contract address to route\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t */\n', '\tfunction addSettingDeprecation(uint256 _settingId, uint256 _newSettingId, address _newSettingContractAddress, address _creatorTAOId, address _associatedTAOId) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) onlyAdvocate(_creatorTAOId) {\n', '\t\t(bytes32 _associatedTAOSettingDeprecationId, bytes32 _creatorTAOSettingDeprecationId) = _aoSettingAttribute.addDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress);\n', '\n', '\t\temit SettingDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress, _associatedTAOSettingDeprecationId, _creatorTAOSettingDeprecationId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of SettingDeprecation&#39;s _associatedTAOId approves setting deprecation\n', '\t * @param _settingId The ID of the setting to approve\n', '\t * @param _approved Whether to approve or reject\n', '\t */\n', '\tfunction approveSettingDeprecation(uint256 _settingId, bool _approved) public {\n', '\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.approveDeprecation(_settingId, _associatedTAOAdvocate, _approved));\n', '\n', '\t\t(,,, address _associatedTAOId,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\n', '\t\temit ApproveSettingDeprecation(_settingId, _associatedTAOId, _associatedTAOAdvocate, _approved);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Advocate of SettingDeprecation&#39;s _creatorTAOId finalizes the setting deprecation once the setting deprecation is approved\n', '\t * @param _settingId The ID of the setting to be finalized\n', '\t */\n', '\tfunction finalizeSettingDeprecation(uint256 _settingId) public {\n', '\t\taddress _creatorTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.finalizeDeprecation(_settingId, _creatorTAOAdvocate));\n', '\n', '\t\t(,, address _creatorTAOId,,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\n', '\t\temit FinalizeSettingDeprecation(_settingId, _creatorTAOId, _creatorTAOAdvocate);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting Id given an associatedTAOId and settingName\n', '\t * @param _associatedTAOId The ID of the AssociatedTAO\n', '\t * @param _settingName The name of the setting\n', '\t * @return the ID of the setting\n', '\t */\n', '\tfunction getSettingIdByTAOName(address _associatedTAOId, string _settingName) public view returns (uint256) {\n', '\t\treturn nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting values by setting ID.\n', '\t *\t\tWill throw error if the setting is not exist or rejected.\n', '\t * @param _settingId The ID of the setting\n', '\t * @return the uint256 value of this setting ID\n', '\t * @return the bool value of this setting ID\n', '\t * @return the address value of this setting ID\n', '\t * @return the bytes32 value of this setting ID\n', '\t * @return the string value of this setting ID\n', '\t */\n', '\tfunction getSettingValuesById(uint256 _settingId) public view returns (uint256, bool, address, bytes32, string) {\n', '\t\trequire (_aoSettingAttribute.settingExist(_settingId));\n', '\t\t_settingId = _aoSettingAttribute.getLatestSettingId(_settingId);\n', '\t\treturn (\n', '\t\t\t_aoUintSetting.settingValue(_settingId),\n', '\t\t\t_aoBoolSetting.settingValue(_settingId),\n', '\t\t\t_aoAddressSetting.settingValue(_settingId),\n', '\t\t\t_aoBytesSetting.settingValue(_settingId),\n', '\t\t\t_aoStringSetting.settingValue(_settingId)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting values by taoId and settingName.\n', '\t *\t\tWill throw error if the setting is not exist or rejected.\n', '\t * @param _taoId The ID of the TAO\n', '\t * @param _settingName The name of the setting\n', '\t * @return the uint256 value of this setting ID\n', '\t * @return the bool value of this setting ID\n', '\t * @return the address value of this setting ID\n', '\t * @return the bytes32 value of this setting ID\n', '\t * @return the string value of this setting ID\n', '\t */\n', '\tfunction getSettingValuesByTAOName(address _taoId, string _settingName) public view returns (uint256, bool, address, bytes32, string) {\n', '\t\treturn getSettingValuesById(getSettingIdByTAOName(_taoId, _settingName));\n', '\t}\n', '\n', '\t/***** Internal Method *****/\n', '\t/**\n', '\t * @dev Store setting creation data\n', '\t * @param _creatorNameId The nameId that created the setting\n', '\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\n', '\t * @param _settingName The human-readable name of the setting\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t * @param _extraData Catch-all string value to be stored if exist\n', '\t */\n', '\tfunction _storeSettingCreation(address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) internal {\n', '\t\t// Make sure _settingType is in supported list\n', '\t\trequire (_settingType >= 1 && _settingType <= 5);\n', '\n', '\t\t// Store nameSettingLookup\n', '\t\tnameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))] = totalSetting;\n', '\n', '\t\t// Store setting data/state\n', '\t\t(bytes32 _associatedTAOSettingId, bytes32 _creatorTAOSettingId) = _aoSettingAttribute.add(totalSetting, _creatorNameId, _settingType, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\n', '\n', '\t\temit SettingCreation(totalSetting, _creatorNameId, _creatorTAOId, _associatedTAOId, _settingName, _settingType, _associatedTAOSettingId, _creatorTAOSettingId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Move value of _settingId from pending variable to setting variable\n', '\t * @param _settingId The ID of the setting\n', '\t * @param _settingType The type of the setting\n', '\t */\n', '\tfunction _movePendingToSetting(uint256 _settingId, uint8 _settingType) internal {\n', '\t\t// If settingType == uint256\n', '\t\tif (_settingType == 1) {\n', '\t\t\t_aoUintSetting.movePendingToSetting(_settingId);\n', '\t\t} else if (_settingType == 2) {\n', '\t\t\t// Else if settingType == bool\n', '\t\t\t_aoBoolSetting.movePendingToSetting(_settingId);\n', '\t\t} else if (_settingType == 3) {\n', '\t\t\t// Else if settingType == address\n', '\t\t\t_aoAddressSetting.movePendingToSetting(_settingId);\n', '\t\t} else if (_settingType == 4) {\n', '\t\t\t// Else if settingType == bytes32\n', '\t\t\t_aoBytesSetting.movePendingToSetting(_settingId);\n', '\t\t} else {\n', '\t\t\t// Else if settingType == string\n', '\t\t\t_aoStringSetting.movePendingToSetting(_settingId);\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOEarning\n', ' *\n', ' * This contract stores the earning from staking/hosting content on AO\n', ' */\n', 'contract AOEarning is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public settingTAOId;\n', '\taddress public aoSettingAddress;\n', '\taddress public baseDenominationAddress;\n', '\taddress public treasuryAddress;\n', '\taddress public nameFactoryAddress;\n', '\taddress public pathosAddress;\n', '\taddress public ethosAddress;\n', '\n', '\tbool public paused;\n', '\tbool public killed;\n', '\n', '\tAOToken internal _baseAO;\n', '\tAOTreasury internal _treasury;\n', '\tNameFactory internal _nameFactory;\n', '\tPathos internal _pathos;\n', '\tEthos internal _ethos;\n', '\tAOSetting internal _aoSetting;\n', '\n', '\t// Total earning from staking content from all nodes\n', '\tuint256 public totalStakeContentEarning;\n', '\n', '\t// Total earning from hosting content from all nodes\n', '\tuint256 public totalHostContentEarning;\n', '\n', '\t// Total The AO earning\n', '\tuint256 public totalTheAOEarning;\n', '\n', '\t// Mapping from address to his/her earning from content that he/she staked\n', '\tmapping (address => uint256) public stakeContentEarning;\n', '\n', '\t// Mapping from address to his/her earning from content that he/she hosted\n', '\tmapping (address => uint256) public hostContentEarning;\n', '\n', '\t// Mapping from address to his/her network price earning\n', '\t// i.e, when staked amount = filesize\n', '\tmapping (address => uint256) public networkPriceEarning;\n', '\n', '\t// Mapping from address to his/her content price earning\n', '\t// i.e, when staked amount > filesize\n', '\tmapping (address => uint256) public contentPriceEarning;\n', '\n', '\t// Mapping from address to his/her inflation bonus\n', '\tmapping (address => uint256) public inflationBonusAccrued;\n', '\n', '\tstruct Earning {\n', '\t\tbytes32 purchaseId;\n', '\t\tuint256 paymentEarning;\n', '\t\tuint256 inflationBonus;\n', '\t\tuint256 pathosAmount;\n', '\t\tuint256 ethosAmount;\n', '\t}\n', '\n', '\t// Mapping from address to earning from staking content of a purchase ID\n', '\tmapping (address => mapping(bytes32 => Earning)) public stakeEarnings;\n', '\n', '\t// Mapping from address to earning from hosting content of a purchase ID\n', '\tmapping (address => mapping(bytes32 => Earning)) public hostEarnings;\n', '\n', '\t// Mapping from purchase ID to earning for The AO\n', '\tmapping (bytes32 => Earning) public theAOEarnings;\n', '\n', '\t// Mapping from stake ID to it&#39;s total earning from staking\n', '\tmapping (bytes32 => uint256) public totalStakedContentStakeEarning;\n', '\n', '\t// Mapping from stake ID to it&#39;s total earning from hosting\n', '\tmapping (bytes32 => uint256) public totalStakedContentHostEarning;\n', '\n', '\t// Mapping from stake ID to it&#39;s total earning earned by The AO\n', '\tmapping (bytes32 => uint256) public totalStakedContentTheAOEarning;\n', '\n', '\t// Mapping from content host ID to it&#39;s total earning\n', '\tmapping (bytes32 => uint256) public totalHostContentEarningById;\n', '\n', '\t// Event to be broadcasted to public when content creator/host earns the payment split in escrow when request node buys the content\n', '\t// recipientType:\n', '\t// 0 => Content Creator (Stake Owner)\n', '\t// 1 => Node Host\n', '\t// 2 => The AO\n', '\tevent PaymentEarningEscrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 totalPaymentAmount, uint256 recipientProfitPercentage, uint256 recipientPaymentEarning, uint8 recipientType);\n', '\n', '\t// Event to be broadcasted to public when content creator/host/The AO earns inflation bonus in escrow when request node buys the content\n', '\t// recipientType:\n', '\t// 0 => Content Creator (Stake Owner)\n', '\t// 1 => Node Host\n', '\t// 2 => The AO\n', '\tevent InflationBonusEscrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 totalInflationBonusAmount, uint256 recipientProfitPercentage, uint256 recipientInflationBonus, uint8 recipientType);\n', '\n', '\t// Event to be broadcasted to public when content creator/host/The AO earning is released from escrow\n', '\t// recipientType:\n', '\t// 0 => Content Creator (Stake Owner)\n', '\t// 1 => Node Host\n', '\t// 2 => The AO\n', '\tevent EarningUnescrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 paymentEarning, uint256 inflationBonus, uint8 recipientType);\n', '\n', '\t// Event to be broadcasted to public when content creator&#39;s Name earns Pathos when a node buys a content\n', '\tevent PathosEarned(address indexed nameId, bytes32 indexed purchaseId, uint256 amount);\n', '\n', '\t// Event to be broadcasted to public when host&#39;s Name earns Ethos when a node buys a content\n', '\tevent EthosEarned(address indexed nameId, bytes32 indexed purchaseId, uint256 amount);\n', '\n', '\t// Event to be broadcasted to public when emergency mode is triggered\n', '\tevent EscapeHatch();\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t * @param _settingTAOId The TAO ID that controls the setting\n', '\t * @param _aoSettingAddress The address of AOSetting\n', '\t * @param _baseDenominationAddress The address of AO base token\n', '\t * @param _treasuryAddress The address of AOTreasury\n', '\t * @param _nameFactoryAddress The address of NameFactory\n', '\t * @param _pathosAddress The address of Pathos\n', '\t * @param _ethosAddress The address of Ethos\n', '\t */\n', '\tconstructor(address _settingTAOId, address _aoSettingAddress, address _baseDenominationAddress, address _treasuryAddress, address _nameFactoryAddress, address _pathosAddress, address _ethosAddress) public {\n', '\t\tsettingTAOId = _settingTAOId;\n', '\t\taoSettingAddress = _aoSettingAddress;\n', '\t\tbaseDenominationAddress = _baseDenominationAddress;\n', '\t\ttreasuryAddress = _treasuryAddress;\n', '\t\tpathosAddress = _pathosAddress;\n', '\t\tethosAddress = _ethosAddress;\n', '\n', '\t\t_aoSetting = AOSetting(_aoSettingAddress);\n', '\t\t_baseAO = AOToken(_baseDenominationAddress);\n', '\t\t_treasury = AOTreasury(_treasuryAddress);\n', '\t\t_nameFactory = NameFactory(_nameFactoryAddress);\n', '\t\t_pathos = Pathos(_pathosAddress);\n', '\t\t_ethos = Ethos(_ethosAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if contract is currently active\n', '\t */\n', '\tmodifier isContractActive {\n', '\t\trequire (paused == false && killed == false);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO pauses/unpauses contract\n', '\t * @param _paused Either to pause contract or not\n', '\t */\n', '\tfunction setPaused(bool _paused) public onlyTheAO {\n', '\t\tpaused = _paused;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO triggers emergency mode.\n', '\t *\n', '\t */\n', '\tfunction escapeHatch() public onlyTheAO {\n', '\t\trequire (killed == false);\n', '\t\tkilled = true;\n', '\t\temit EscapeHatch();\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO updates base denomination address\n', '\t * @param _newBaseDenominationAddress The new address\n', '\t */\n', '\tfunction setBaseDenominationAddress(address _newBaseDenominationAddress) public onlyTheAO {\n', '\t\trequire (AOToken(_newBaseDenominationAddress).powerOfTen() == 0);\n', '\t\tbaseDenominationAddress = _newBaseDenominationAddress;\n', '\t\t_baseAO = AOToken(baseDenominationAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Calculate the content creator/host/The AO earning when request node buys the content.\n', '\t *\t\tAlso at this stage, all of the earnings are stored in escrow\n', '\t * @param _buyer The request node address that buys the content\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _networkAmountStaked The amount of network tokens at stake\n', '\t * @param _primordialAmountStaked The amount of primordial tokens at stake\n', '\t * @param _primordialWeightedMultiplierStaked The weighted multiplier of primordial tokens at stake\n', '\t * @param _profitPercentage The content creator&#39;s profit percentage\n', '\t * @param _stakeOwner The address of the stake owner\n', '\t * @param _host The address of the host\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\n', '\t */\n', '\tfunction calculateEarning(\n', '\t\taddress _buyer,\n', '\t\tbytes32 _purchaseId,\n', '\t\tuint256 _networkAmountStaked,\n', '\t\tuint256 _primordialAmountStaked,\n', '\t\tuint256 _primordialWeightedMultiplierStaked,\n', '\t\tuint256 _profitPercentage,\n', '\t\taddress _stakeOwner,\n', '\t\taddress _host,\n', '\t\tbool _isAOContentUsageType\n', '\t) public isContractActive inWhitelist returns (bool) {\n', '\t\t// Split the payment earning between content creator and host and store them in escrow\n', '\t\t_escrowPaymentEarning(_buyer, _purchaseId, _networkAmountStaked.add(_primordialAmountStaked), _profitPercentage, _stakeOwner, _host, _isAOContentUsageType);\n', '\n', '\t\t// Calculate the inflation bonus earning for content creator/node/The AO in escrow\n', '\t\t_escrowInflationBonus(_purchaseId, _calculateInflationBonus(_networkAmountStaked, _primordialAmountStaked, _primordialWeightedMultiplierStaked), _profitPercentage, _stakeOwner, _host, _isAOContentUsageType);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Release the payment earning and inflation bonus that is in escrow for specific purchase ID\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _contentHostId The ID of the hosted content\n', '\t * @param _purchaseId The purchase receipt ID to check\n', '\t * @param _buyerPaidMoreThanFileSize Whether or not the request node paid more than filesize when buying the content\n', '\t * @param _stakeOwner The address of the stake owner\n', '\t * @param _host The address of the node that host the file\n', '\t * @return true on success\n', '\t */\n', '\tfunction releaseEarning(bytes32 _stakeId, bytes32 _contentHostId, bytes32 _purchaseId, bool _buyerPaidMoreThanFileSize, address _stakeOwner, address _host) public isContractActive inWhitelist returns (bool) {\n', '\t\t// Release the earning in escrow for stake owner\n', '\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, _stakeOwner, 0);\n', '\n', '\t\t// Release the earning in escrow for host\n', '\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, _host, 1);\n', '\n', '\t\t// Release the earning in escrow for The AO\n', '\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, theAO, 2);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Calculate the payment split for content creator/host and store them in escrow\n', '\t * @param _buyer the request node address that buys the content\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _totalStaked The total staked amount of the content\n', '\t * @param _profitPercentage The content creator&#39;s profit percentage\n', '\t * @param _stakeOwner The address of the stake owner\n', '\t * @param _host The address of the host\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\n', '\t */\n', '\tfunction _escrowPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _stakeOwner, address _host, bool _isAOContentUsageType) internal {\n', '\t\t(uint256 _stakeOwnerEarning, uint256 _pathosAmount) = _escrowStakeOwnerPaymentEarning(_buyer, _purchaseId, _totalStaked, _profitPercentage, _stakeOwner, _isAOContentUsageType);\n', '\t\t(uint256 _ethosAmount) = _escrowHostPaymentEarning(_buyer, _purchaseId, _totalStaked, _profitPercentage, _host, _isAOContentUsageType, _stakeOwnerEarning);\n', '\n', '\t\t_escrowTheAOPaymentEarning(_purchaseId, _totalStaked, _pathosAmount, _ethosAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the inflation bonus amount\n', '\t * @param _networkAmountStaked The amount of network tokens at stake\n', '\t * @param _primordialAmountStaked The amount of primordial tokens at stake\n', '\t * @param _primordialWeightedMultiplierStaked The weighted multiplier of primordial tokens at stake\n', '\t * @return the bonus network amount\n', '\t */\n', '\tfunction _calculateInflationBonus(uint256 _networkAmountStaked, uint256 _primordialAmountStaked, uint256 _primordialWeightedMultiplierStaked) internal view returns (uint256) {\n', '\t\t(uint256 inflationRate,,) = _getSettingVariables();\n', '\n', '\t\tuint256 _networkBonus = _networkAmountStaked.mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\t\tuint256 _primordialBonus = _primordialAmountStaked.mul(_primordialWeightedMultiplierStaked).div(AOLibrary.MULTIPLIER_DIVISOR()).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\t\treturn _networkBonus.add(_primordialBonus);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Mint the inflation bonus for content creator/host/The AO and store them in escrow\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _inflationBonusAmount The amount of inflation bonus earning\n', '\t * @param _profitPercentage The content creator&#39;s profit percentage\n', '\t * @param _stakeOwner The address of the stake owner\n', '\t * @param _host The address of the host\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\n', '\t */\n', '\tfunction _escrowInflationBonus(\n', '\t\tbytes32 _purchaseId,\n', '\t\tuint256 _inflationBonusAmount,\n', '\t\tuint256 _profitPercentage,\n', '\t\taddress _stakeOwner,\n', '\t\taddress _host,\n', '\t\tbool _isAOContentUsageType\n', '\t) internal {\n', '\t\t(, uint256 theAOCut,) = _getSettingVariables();\n', '\n', '\t\tif (_inflationBonusAmount > 0) {\n', '\t\t\t// Store how much the content creator earns in escrow\n', '\t\t\tuint256 _stakeOwnerInflationBonus = _isAOContentUsageType ? (_inflationBonusAmount.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\n', '\t\t\tEarning storage _stakeEarning = stakeEarnings[_stakeOwner][_purchaseId];\n', '\t\t\t_stakeEarning.inflationBonus = _stakeOwnerInflationBonus;\n', '\t\t\trequire (_baseAO.mintTokenEscrow(_stakeOwner, _stakeEarning.inflationBonus));\n', '\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseId, _inflationBonusAmount, _profitPercentage, _stakeEarning.inflationBonus, 0);\n', '\n', '\t\t\t// Store how much the host earns in escrow\n', '\t\t\tEarning storage _hostEarning = hostEarnings[_host][_purchaseId];\n', '\t\t\t_hostEarning.inflationBonus = _inflationBonusAmount.sub(_stakeOwnerInflationBonus);\n', '\t\t\trequire (_baseAO.mintTokenEscrow(_host, _hostEarning.inflationBonus));\n', '\t\t\temit InflationBonusEscrowed(_host, _purchaseId, _inflationBonusAmount, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _hostEarning.inflationBonus, 1);\n', '\n', '\t\t\t// Store how much the The AO earns in escrow\n', '\t\t\tEarning storage _theAOEarning = theAOEarnings[_purchaseId];\n', '\t\t\t_theAOEarning.inflationBonus = (_inflationBonusAmount.mul(theAOCut)).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\t\t\trequire (_baseAO.mintTokenEscrow(theAO, _theAOEarning.inflationBonus));\n', '\t\t\temit InflationBonusEscrowed(theAO, _purchaseId, _inflationBonusAmount, theAOCut, _theAOEarning.inflationBonus, 2);\n', '\t\t} else {\n', '\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseId, 0, _profitPercentage, 0, 0);\n', '\t\t\temit InflationBonusEscrowed(_host, _purchaseId, 0, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), 0, 1);\n', '\t\t\temit InflationBonusEscrowed(theAO, _purchaseId, 0, theAOCut, 0, 2);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Release the escrowed earning for a specific purchase ID for an account\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _contentHostId The ID of the hosted content\n', '\t * @param _purchaseId The purchase receipt ID\n', '\t * @param _buyerPaidMoreThanFileSize Whether or not the request node paid more than filesize when buying the content\n', '\t * @param _account The address of account that made the earning (content creator/host)\n', '\t * @param _recipientType The type of the earning recipient (0 => content creator. 1 => host. 2 => theAO)\n', '\t */\n', '\tfunction _releaseEarning(bytes32 _stakeId, bytes32 _contentHostId, bytes32 _purchaseId, bool _buyerPaidMoreThanFileSize, address _account, uint8 _recipientType) internal {\n', '\t\t// Make sure the recipient type is valid\n', '\t\trequire (_recipientType >= 0 && _recipientType <= 2);\n', '\n', '\t\tuint256 _paymentEarning;\n', '\t\tuint256 _inflationBonus;\n', '\t\tuint256 _totalEarning;\n', '\t\tuint256 _pathosAmount;\n', '\t\tuint256 _ethosAmount;\n', '\t\tif (_recipientType == 0) {\n', '\t\t\tEarning storage _earning = stakeEarnings[_account][_purchaseId];\n', '\t\t\t_paymentEarning = _earning.paymentEarning;\n', '\t\t\t_inflationBonus = _earning.inflationBonus;\n', '\t\t\t_pathosAmount = _earning.pathosAmount;\n', '\t\t\t_earning.paymentEarning = 0;\n', '\t\t\t_earning.inflationBonus = 0;\n', '\t\t\t_earning.pathosAmount = 0;\n', '\t\t\t_earning.ethosAmount = 0;\n', '\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\n', '\n', '\t\t\t// Update the global var settings\n', '\t\t\ttotalStakeContentEarning = totalStakeContentEarning.add(_totalEarning);\n', '\t\t\tstakeContentEarning[_account] = stakeContentEarning[_account].add(_totalEarning);\n', '\t\t\ttotalStakedContentStakeEarning[_stakeId] = totalStakedContentStakeEarning[_stakeId].add(_totalEarning);\n', '\t\t\tif (_buyerPaidMoreThanFileSize) {\n', '\t\t\t\tcontentPriceEarning[_account] = contentPriceEarning[_account].add(_totalEarning);\n', '\t\t\t} else {\n', '\t\t\t\tnetworkPriceEarning[_account] = networkPriceEarning[_account].add(_totalEarning);\n', '\t\t\t}\n', '\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\n', '\n', '\t\t\t// Reward the content creator/stake owner with some Pathos\n', '\t\t\trequire (_pathos.mintToken(_nameFactory.ethAddressToNameId(_account), _pathosAmount));\n', '\t\t\temit PathosEarned(_nameFactory.ethAddressToNameId(_account), _purchaseId, _pathosAmount);\n', '\t\t} else if (_recipientType == 1) {\n', '\t\t\t_earning = hostEarnings[_account][_purchaseId];\n', '\t\t\t_paymentEarning = _earning.paymentEarning;\n', '\t\t\t_inflationBonus = _earning.inflationBonus;\n', '\t\t\t_ethosAmount = _earning.ethosAmount;\n', '\t\t\t_earning.paymentEarning = 0;\n', '\t\t\t_earning.inflationBonus = 0;\n', '\t\t\t_earning.pathosAmount = 0;\n', '\t\t\t_earning.ethosAmount = 0;\n', '\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\n', '\n', '\t\t\t// Update the global var settings\n', '\t\t\ttotalHostContentEarning = totalHostContentEarning.add(_totalEarning);\n', '\t\t\thostContentEarning[_account] = hostContentEarning[_account].add(_totalEarning);\n', '\t\t\ttotalStakedContentHostEarning[_stakeId] = totalStakedContentHostEarning[_stakeId].add(_totalEarning);\n', '\t\t\ttotalHostContentEarningById[_contentHostId] = totalHostContentEarningById[_contentHostId].add(_totalEarning);\n', '\t\t\tif (_buyerPaidMoreThanFileSize) {\n', '\t\t\t\tcontentPriceEarning[_account] = contentPriceEarning[_account].add(_totalEarning);\n', '\t\t\t} else {\n', '\t\t\t\tnetworkPriceEarning[_account] = networkPriceEarning[_account].add(_totalEarning);\n', '\t\t\t}\n', '\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\n', '\n', '\t\t\t// Reward the host node with some Ethos\n', '\t\t\trequire (_ethos.mintToken(_nameFactory.ethAddressToNameId(_account), _ethosAmount));\n', '\t\t\temit EthosEarned(_nameFactory.ethAddressToNameId(_account), _purchaseId, _ethosAmount);\n', '\t\t} else {\n', '\t\t\t_earning = theAOEarnings[_purchaseId];\n', '\t\t\t_paymentEarning = _earning.paymentEarning;\n', '\t\t\t_inflationBonus = _earning.inflationBonus;\n', '\t\t\t_earning.paymentEarning = 0;\n', '\t\t\t_earning.inflationBonus = 0;\n', '\t\t\t_earning.pathosAmount = 0;\n', '\t\t\t_earning.ethosAmount = 0;\n', '\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\n', '\n', '\t\t\t// Update the global var settings\n', '\t\t\ttotalTheAOEarning = totalTheAOEarning.add(_totalEarning);\n', '\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\n', '\t\t\ttotalStakedContentTheAOEarning[_stakeId] = totalStakedContentTheAOEarning[_stakeId].add(_totalEarning);\n', '\t\t}\n', '\t\trequire (_baseAO.unescrowFrom(_account, _totalEarning));\n', '\t\temit EarningUnescrowed(_account, _purchaseId, _paymentEarning, _inflationBonus, _recipientType);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting variables\n', '\t * @return inflationRate The rate to use when calculating inflation bonus\n', '\t * @return theAOCut The rate to use when calculating the AO earning\n', '\t * @return theAOEthosEarnedRate The rate to use when calculating the Ethos to AO rate for the AO\n', '\t */\n', '\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256) {\n', '\t\t(uint256 inflationRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;inflationRate&#39;);\n', '\t\t(uint256 theAOCut,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;theAOCut&#39;);\n', '\t\t(uint256 theAOEthosEarnedRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;theAOEthosEarnedRate&#39;);\n', '\n', '\t\treturn (inflationRate, theAOCut, theAOEthosEarnedRate);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the payment split for content creator and store them in escrow\n', '\t * @param _buyer the request node address that buys the content\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _totalStaked The total staked amount of the content\n', '\t * @param _profitPercentage The content creator&#39;s profit percentage\n', '\t * @param _stakeOwner The address of the stake owner\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\n', '\t * @return The stake owner&#39;s earning amount\n', '\t * @return The pathos earned from this transaction\n', '\t */\n', '\tfunction _escrowStakeOwnerPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _stakeOwner, bool _isAOContentUsageType) internal returns (uint256, uint256) {\n', '\t\t(uint256 inflationRate,,) = _getSettingVariables();\n', '\n', '\t\tEarning storage _stakeEarning = stakeEarnings[_stakeOwner][_purchaseId];\n', '\t\t_stakeEarning.purchaseId = _purchaseId;\n', '\t\t// Store how much the content creator (stake owner) earns in escrow\n', '\t\t// If content is AO Content Usage Type, stake owner earns 0%\n', '\t\t// and all profit goes to the serving host node\n', '\t\t_stakeEarning.paymentEarning = _isAOContentUsageType ? (_totalStaked.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\n', '\t\t// Pathos = Price X Node Share X Inflation Rate\n', '\t\t_stakeEarning.pathosAmount = _totalStaked.mul(AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage)).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\t\trequire (_baseAO.escrowFrom(_buyer, _stakeOwner, _stakeEarning.paymentEarning));\n', '\t\temit PaymentEarningEscrowed(_stakeOwner, _purchaseId, _totalStaked, _profitPercentage, _stakeEarning.paymentEarning, 0);\n', '\t\treturn (_stakeEarning.paymentEarning, _stakeEarning.pathosAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the payment split for host node and store them in escrow\n', '\t * @param _buyer the request node address that buys the content\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _totalStaked The total staked amount of the content\n', '\t * @param _profitPercentage The content creator&#39;s profit percentage\n', '\t * @param _host The address of the host node\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\n', '\t * @param _stakeOwnerEarning The stake owner&#39;s earning amount\n', '\t * @return The ethos earned from this transaction\n', '\t */\n', '\tfunction _escrowHostPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _host, bool _isAOContentUsageType, uint256 _stakeOwnerEarning) internal returns (uint256) {\n', '\t\t(uint256 inflationRate,,) = _getSettingVariables();\n', '\n', '\t\t// Store how much the node host earns in escrow\n', '\t\tEarning storage _hostEarning = hostEarnings[_host][_purchaseId];\n', '\t\t_hostEarning.purchaseId = _purchaseId;\n', '\t\t_hostEarning.paymentEarning = _totalStaked.sub(_stakeOwnerEarning);\n', '\t\t// Ethos = Price X Creator Share X Inflation Rate\n', '\t\t_hostEarning.ethosAmount = _totalStaked.mul(_profitPercentage).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\n', '\n', '\t\tif (_isAOContentUsageType) {\n', '\t\t\trequire (_baseAO.escrowFrom(_buyer, _host, _hostEarning.paymentEarning));\n', '\t\t} else {\n', '\t\t\t// If not AO Content usage type, we want to mint to the host\n', '\t\t\trequire (_baseAO.mintTokenEscrow(_host, _hostEarning.paymentEarning));\n', '\t\t}\n', '\t\temit PaymentEarningEscrowed(_host, _purchaseId, _totalStaked, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _hostEarning.paymentEarning, 1);\n', '\t\treturn _hostEarning.ethosAmount;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the earning for The AO and store them in escrow\n', '\t * @param _purchaseId The ID of the purchase receipt object\n', '\t * @param _totalStaked The total staked amount of the content\n', '\t * @param _pathosAmount The amount of pathos earned by stake owner\n', '\t * @param _ethosAmount The amount of ethos earned by host node\n', '\t */\n', '\tfunction _escrowTheAOPaymentEarning(bytes32 _purchaseId, uint256 _totalStaked, uint256 _pathosAmount, uint256 _ethosAmount) internal {\n', '\t\t(,,uint256 theAOEthosEarnedRate) = _getSettingVariables();\n', '\n', '\t\t// Store how much The AO earns in escrow\n', '\t\tEarning storage _theAOEarning = theAOEarnings[_purchaseId];\n', '\t\t_theAOEarning.purchaseId = _purchaseId;\n', '\t\t// Pathos + X% of Ethos\n', '\t\t_theAOEarning.paymentEarning = _pathosAmount.add(_ethosAmount.mul(theAOEthosEarnedRate).div(AOLibrary.PERCENTAGE_DIVISOR()));\n', '\t\trequire (_baseAO.mintTokenEscrow(theAO, _theAOEarning.paymentEarning));\n', '\t\temit PaymentEarningEscrowed(theAO, _purchaseId, _totalStaked, 0, _theAOEarning.paymentEarning, 2);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOContent\n', ' *\n', ' * The purpose of this contract is to allow content creator to stake network ERC20 AO tokens and/or primordial AO Tokens\n', ' * on his/her content\n', ' */\n', 'contract AOContent is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 public totalContents;\n', '\tuint256 public totalContentHosts;\n', '\tuint256 public totalStakedContents;\n', '\tuint256 public totalPurchaseReceipts;\n', '\n', '\taddress public settingTAOId;\n', '\taddress public baseDenominationAddress;\n', '\taddress public treasuryAddress;\n', '\n', '\tAOToken internal _baseAO;\n', '\tAOTreasury internal _treasury;\n', '\tAOEarning internal _earning;\n', '\tAOSetting internal _aoSetting;\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\n', '\tbool public paused;\n', '\tbool public killed;\n', '\n', '\tstruct Content {\n', '\t\tbytes32 contentId;\n', '\t\taddress creator;\n', '\t\t/**\n', '\t\t * baseChallenge is the content&#39;s PUBLIC KEY\n', '\t\t * When a request node wants to be a host, it is required to send a signed base challenge (its content&#39;s PUBLIC KEY)\n', '\t\t * so that the contract can verify the authenticity of the content by comparing what the contract has and what the request node\n', '\t\t * submit\n', '\t\t */\n', '\t\tstring baseChallenge;\n', '\t\tuint256 fileSize;\n', '\t\tbytes32 contentUsageType; // i.e AO Content, Creative Commons, or T(AO) Content\n', '\t\taddress taoId;\n', '\t\tbytes32 taoContentState; // i.e Submitted, Pending Review, Accepted to TAO\n', '\t\tuint8 updateTAOContentStateV;\n', '\t\tbytes32 updateTAOContentStateR;\n', '\t\tbytes32 updateTAOContentStateS;\n', '\t\tstring extraData;\n', '\t}\n', '\n', '\tstruct StakedContent {\n', '\t\tbytes32 stakeId;\n', '\t\tbytes32 contentId;\n', '\t\taddress stakeOwner;\n', '\t\tuint256 networkAmount; // total network token staked in base denomination\n', '\t\tuint256 primordialAmount;\t// the amount of primordial AO Token to stake (always in base denomination)\n', '\t\tuint256 primordialWeightedMultiplier;\n', '\t\tuint256 profitPercentage; // support up to 4 decimals, 100% = 1000000\n', '\t\tbool active; // true if currently staked, false when unstaked\n', '\t\tuint256 createdOnTimestamp;\n', '\t}\n', '\n', '\tstruct ContentHost {\n', '\t\tbytes32 contentHostId;\n', '\t\tbytes32 stakeId;\n', '\t\taddress host;\n', '\t\t/**\n', '\t\t * encChallenge is the content&#39;s PUBLIC KEY unique to the host\n', '\t\t */\n', '\t\tstring encChallenge;\n', '\t\tstring contentDatKey;\n', '\t\tstring metadataDatKey;\n', '\t}\n', '\n', '\tstruct PurchaseReceipt {\n', '\t\tbytes32 purchaseId;\n', '\t\tbytes32 contentHostId;\n', '\t\taddress buyer;\n', '\t\tuint256 price;\n', '\t\tuint256 amountPaidByBuyer;\t// total network token paid in base denomination\n', '\t\tuint256 amountPaidByAO; // total amount paid by AO\n', '\t\tstring publicKey; // The public key provided by request node\n', '\t\taddress publicAddress; // The public address provided by request node\n', '\t\tuint256 createdOnTimestamp;\n', '\t}\n', '\n', '\t// Mapping from Content index to the Content object\n', '\tmapping (uint256 => Content) internal contents;\n', '\n', '\t// Mapping from content ID to index of the contents list\n', '\tmapping (bytes32 => uint256) internal contentIndex;\n', '\n', '\t// Mapping from StakedContent index to the StakedContent object\n', '\tmapping (uint256 => StakedContent) internal stakedContents;\n', '\n', '\t// Mapping from stake ID to index of the stakedContents list\n', '\tmapping (bytes32 => uint256) internal stakedContentIndex;\n', '\n', '\t// Mapping from ContentHost index to the ContentHost object\n', '\tmapping (uint256 => ContentHost) internal contentHosts;\n', '\n', '\t// Mapping from content host ID to index of the contentHosts list\n', '\tmapping (bytes32 => uint256) internal contentHostIndex;\n', '\n', '\t// Mapping from PurchaseReceipt index to the PurchaseReceipt object\n', '\tmapping (uint256 => PurchaseReceipt) internal purchaseReceipts;\n', '\n', '\t// Mapping from purchase ID to index of the purchaseReceipts list\n', '\tmapping (bytes32 => uint256) internal purchaseReceiptIndex;\n', '\n', '\t// Mapping from buyer&#39;s content host ID to the buy ID\n', '\t// To check whether or not buyer has bought/paid for a content\n', '\tmapping (address => mapping (bytes32 => bytes32)) public buyerPurchaseReceipts;\n', '\n', '\t// Event to be broadcasted to public when `content` is stored\n', '\tevent StoreContent(address indexed creator, bytes32 indexed contentId, uint256 fileSize, bytes32 contentUsageType);\n', '\n', '\t// Event to be broadcasted to public when `stakeOwner` stakes a new content\n', '\tevent StakeContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 baseNetworkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier, uint256 profitPercentage, uint256 createdOnTimestamp);\n', '\n', '\t// Event to be broadcasted to public when a node hosts a content\n', '\tevent HostContent(address indexed host, bytes32 indexed contentHostId, bytes32 stakeId, string contentDatKey, string metadataDatKey);\n', '\n', '\t// Event to be broadcasted to public when `stakeOwner` updates the staked content&#39;s profit percentage\n', '\tevent SetProfitPercentage(address indexed stakeOwner, bytes32 indexed stakeId, uint256 newProfitPercentage);\n', '\n', '\t// Event to be broadcasted to public when `stakeOwner` unstakes some network/primordial token from an existing content\n', '\tevent UnstakePartialContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 remainingNetworkAmount, uint256 remainingPrimordialAmount, uint256 primordialWeightedMultiplier);\n', '\n', '\t// Event to be broadcasted to public when `stakeOwner` unstakes all token amount on an existing content\n', '\tevent UnstakeContent(address indexed stakeOwner, bytes32 indexed stakeId);\n', '\n', '\t// Event to be broadcasted to public when `stakeOwner` re-stakes an existing content\n', '\tevent StakeExistingContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 currentNetworkAmount, uint256 currentPrimordialAmount, uint256 currentPrimordialWeightedMultiplier);\n', '\n', '\t// Event to be broadcasted to public when a request node buys a content\n', '\tevent BuyContent(address indexed buyer, bytes32 indexed purchaseId, bytes32 indexed contentHostId, uint256 price, uint256 amountPaidByAO, uint256 amountPaidByBuyer, string publicKey, address publicAddress, uint256 createdOnTimestamp);\n', '\n', '\t// Event to be broadcasted to public when Advocate/Listener/Speaker wants to update the TAO Content&#39;s State\n', '\tevent UpdateTAOContentState(bytes32 indexed contentId, address indexed taoId, address signer, bytes32 taoContentState);\n', '\n', '\t// Event to be broadcasted to public when emergency mode is triggered\n', '\tevent EscapeHatch();\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t * @param _settingTAOId The TAO ID that controls the setting\n', '\t * @param _aoSettingAddress The address of AOSetting\n', '\t * @param _baseDenominationAddress The address of AO base token\n', '\t * @param _treasuryAddress The address of AOTreasury\n', '\t * @param _earningAddress The address of AOEarning\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tconstructor(address _settingTAOId, address _aoSettingAddress, address _baseDenominationAddress, address _treasuryAddress, address _earningAddress, address _nameTAOPositionAddress) public {\n', '\t\tsettingTAOId = _settingTAOId;\n', '\t\tbaseDenominationAddress = _baseDenominationAddress;\n', '\t\ttreasuryAddress = _treasuryAddress;\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\n', '\t\t_baseAO = AOToken(_baseDenominationAddress);\n', '\t\t_treasury = AOTreasury(_treasuryAddress);\n', '\t\t_earning = AOEarning(_earningAddress);\n', '\t\t_aoSetting = AOSetting(_aoSettingAddress);\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if contract is currently active\n', '\t */\n', '\tmodifier isContractActive {\n', '\t\trequire (paused == false && killed == false);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO pauses/unpauses contract\n', '\t * @param _paused Either to pause contract or not\n', '\t */\n', '\tfunction setPaused(bool _paused) public onlyTheAO {\n', '\t\tpaused = _paused;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO triggers emergency mode.\n', '\t *\n', '\t */\n', '\tfunction escapeHatch() public onlyTheAO {\n', '\t\trequire (killed == false);\n', '\t\tkilled = true;\n', '\t\temit EscapeHatch();\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO updates base denomination address\n', '\t * @param _newBaseDenominationAddress The new address\n', '\t */\n', '\tfunction setBaseDenominationAddress(address _newBaseDenominationAddress) public onlyTheAO {\n', '\t\trequire (AOToken(_newBaseDenominationAddress).powerOfTen() == 0);\n', '\t\tbaseDenominationAddress = _newBaseDenominationAddress;\n', '\t\t_baseAO = AOToken(baseDenominationAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for an AO Content\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\n', '\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\n', '\t * @param _contentDatKey The dat key of the content\n', '\t * @param _metadataDatKey The dat key of the content&#39;s metadata\n', '\t * @param _fileSize The size of the file\n', '\t * @param _profitPercentage The percentage of profit the stake owner&#39;s media will charge\n', '\t */\n', '\tfunction stakeAOContent(\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount,\n', '\t\tstring _baseChallenge,\n', '\t\tstring _encChallenge,\n', '\t\tstring _contentDatKey,\n', '\t\tstring _metadataDatKey,\n', '\t\tuint256 _fileSize,\n', '\t\tuint256 _profitPercentage)\n', '\t\tpublic isContractActive {\n', '\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, _profitPercentage));\n', '\t\t(bytes32 _contentUsageType_aoContent,,,,,) = _getSettingVariables();\n', '\n', '\t\t/**\n', '\t\t * 1. Store this content\n', '\t\t * 2. Stake the network/primordial token on content\n', '\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\n', '\t\t */\n', '\t\t_hostContent(\n', '\t\t\tmsg.sender,\n', '\t\t\t_stakeContent(\n', '\t\t\t\tmsg.sender,\n', '\t\t\t\t_storeContent(\n', '\t\t\t\t\tmsg.sender,\n', '\t\t\t\t\t_baseChallenge,\n', '\t\t\t\t\t_fileSize,\n', '\t\t\t\t\t_contentUsageType_aoContent,\n', '\t\t\t\t\taddress(0)\n', '\t\t\t\t),\n', '\t\t\t\t_networkIntegerAmount,\n', '\t\t\t\t_networkFractionAmount,\n', '\t\t\t\t_denomination,\n', '\t\t\t\t_primordialAmount,\n', '\t\t\t\t_profitPercentage\n', '\t\t\t),\n', '\t\t\t_encChallenge,\n', '\t\t\t_contentDatKey,\n', '\t\t\t_metadataDatKey\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for a Creative Commons Content\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\n', '\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\n', '\t * @param _contentDatKey The dat key of the content\n', '\t * @param _metadataDatKey The dat key of the content&#39;s metadata\n', '\t * @param _fileSize The size of the file\n', '\t */\n', '\tfunction stakeCreativeCommonsContent(\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount,\n', '\t\tstring _baseChallenge,\n', '\t\tstring _encChallenge,\n', '\t\tstring _contentDatKey,\n', '\t\tstring _metadataDatKey,\n', '\t\tuint256 _fileSize)\n', '\t\tpublic isContractActive {\n', '\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, 0));\n', '\t\trequire (_treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) == _fileSize);\n', '\n', '\t\t(,bytes32 _contentUsageType_creativeCommons,,,,) = _getSettingVariables();\n', '\n', '\t\t/**\n', '\t\t * 1. Store this content\n', '\t\t * 2. Stake the network/primordial token on content\n', '\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\n', '\t\t */\n', '\t\t_hostContent(\n', '\t\t\tmsg.sender,\n', '\t\t\t_stakeContent(\n', '\t\t\t\tmsg.sender,\n', '\t\t\t\t_storeContent(\n', '\t\t\t\t\tmsg.sender,\n', '\t\t\t\t\t_baseChallenge,\n', '\t\t\t\t\t_fileSize,\n', '\t\t\t\t\t_contentUsageType_creativeCommons,\n', '\t\t\t\t\taddress(0)\n', '\t\t\t\t),\n', '\t\t\t\t_networkIntegerAmount,\n', '\t\t\t\t_networkFractionAmount,\n', '\t\t\t\t_denomination,\n', '\t\t\t\t_primordialAmount,\n', '\t\t\t\t0\n', '\t\t\t),\n', '\t\t\t_encChallenge,\n', '\t\t\t_contentDatKey,\n', '\t\t\t_metadataDatKey\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for a T(AO) Content\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\n', '\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\n', '\t * @param _contentDatKey The dat key of the content\n', '\t * @param _metadataDatKey The dat key of the content&#39;s metadata\n', '\t * @param _fileSize The size of the file\n', '\t * @param _taoId The TAO (TAO) ID for this content (if this is a T(AO) Content)\n', '\t */\n', '\tfunction stakeTAOContent(\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount,\n', '\t\tstring _baseChallenge,\n', '\t\tstring _encChallenge,\n', '\t\tstring _contentDatKey,\n', '\t\tstring _metadataDatKey,\n', '\t\tuint256 _fileSize,\n', '\t\taddress _taoId)\n', '\t\tpublic isContractActive {\n', '\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, 0));\n', '\t\trequire (\n', '\t\t\t_treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) == _fileSize &&\n', '\t\t\t_nameTAOPosition.senderIsPosition(msg.sender, _taoId)\n', '\t\t);\n', '\n', '\t\t(,,bytes32 _contentUsageType_taoContent,,,) = _getSettingVariables();\n', '\n', '\t\t/**\n', '\t\t * 1. Store this content\n', '\t\t * 2. Stake the network/primordial token on content\n', '\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\n', '\t\t */\n', '\t\t_hostContent(\n', '\t\t\tmsg.sender,\n', '\t\t\t_stakeContent(\n', '\t\t\t\tmsg.sender,\n', '\t\t\t\t_storeContent(\n', '\t\t\t\t\tmsg.sender,\n', '\t\t\t\t\t_baseChallenge,\n', '\t\t\t\t\t_fileSize,\n', '\t\t\t\t\t_contentUsageType_taoContent,\n', '\t\t\t\t\t_taoId\n', '\t\t\t\t),\n', '\t\t\t\t_networkIntegerAmount,\n', '\t\t\t\t_networkFractionAmount,\n', '\t\t\t\t_denomination,\n', '\t\t\t\t_primordialAmount,\n', '\t\t\t\t0\n', '\t\t\t),\n', '\t\t\t_encChallenge,\n', '\t\t\t_contentDatKey,\n', '\t\t\t_metadataDatKey\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set profit percentage on existing staked content\n', '\t *\t\tWill throw error if this is a Creative Commons/T(AO) Content\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _profitPercentage The new value to be set\n', '\t */\n', '\tfunction setProfitPercentage(bytes32 _stakeId, uint256 _profitPercentage) public isContractActive {\n', '\t\trequire (_profitPercentage <= AOLibrary.PERCENTAGE_DIVISOR());\n', '\n', '\t\t// Make sure the staked content exist\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\n', '\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\t// Make sure the staked content owner is the same as the sender\n', '\t\trequire (_stakedContent.stakeOwner == msg.sender);\n', '\n', '\t\t// Make sure we are updating profit percentage for AO Content only\n', '\t\t// Creative Commons/T(AO) Content has 0 profit percentage\n', '\t\trequire (_isAOContentUsageType(_stakedContent.contentId));\n', '\n', '\t\t_stakedContent.profitPercentage = _profitPercentage;\n', '\n', '\t\temit SetProfitPercentage(msg.sender, _stakeId, _profitPercentage);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set extra data on existing content\n', '\t * @param _contentId The ID of the content\n', '\t * @param _extraData some extra information to send to the contract for a content\n', '\t */\n', '\tfunction setContentExtraData(bytes32 _contentId, string _extraData) public isContractActive {\n', '\t\t// Make sure the content exist\n', '\t\trequire (contentIndex[_contentId] > 0);\n', '\n', '\t\tContent storage _content = contents[contentIndex[_contentId]];\n', '\t\t// Make sure the content creator is the same as the sender\n', '\t\trequire (_content.creator == msg.sender);\n', '\n', '\t\t_content.extraData = _extraData;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return content info at a given ID\n', '\t * @param _contentId The ID of the content\n', '\t * @return address of the creator\n', '\t * @return file size of the content\n', '\t * @return the content usage type, i.e AO Content, Creative Commons, or T(AO) Content\n', '\t * @return The TAO ID for this content (if this is a T(AO) Content)\n', '\t * @return The TAO Content state, i.e Submitted, Pending Review, or Accepted to TAO\n', '\t * @return The V part of signature that is used to update the TAO Content State\n', '\t * @return The R part of signature that is used to update the TAO Content State\n', '\t * @return The S part of signature that is used to update the TAO Content State\n', '\t * @return the extra information sent to the contract when creating a content\n', '\t */\n', '\tfunction contentById(bytes32 _contentId) public view returns (address, uint256, bytes32, address, bytes32, uint8, bytes32, bytes32, string) {\n', '\t\t// Make sure the content exist\n', '\t\trequire (contentIndex[_contentId] > 0);\n', '\t\tContent memory _content = contents[contentIndex[_contentId]];\n', '\t\treturn (\n', '\t\t\t_content.creator,\n', '\t\t\t_content.fileSize,\n', '\t\t\t_content.contentUsageType,\n', '\t\t\t_content.taoId,\n', '\t\t\t_content.taoContentState,\n', '\t\t\t_content.updateTAOContentStateV,\n', '\t\t\t_content.updateTAOContentStateR,\n', '\t\t\t_content.updateTAOContentStateS,\n', '\t\t\t_content.extraData\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return content host info at a given ID\n', '\t * @param _contentHostId The ID of the hosted content\n', '\t * @return The ID of the staked content\n', '\t * @return address of the host\n', '\t * @return the dat key of the content\n', '\t * @return the dat key of the content&#39;s metadata\n', '\t */\n', '\tfunction contentHostById(bytes32 _contentHostId) public view returns (bytes32, address, string, string) {\n', '\t\t// Make sure the content host exist\n', '\t\trequire (contentHostIndex[_contentHostId] > 0);\n', '\t\tContentHost memory _contentHost = contentHosts[contentHostIndex[_contentHostId]];\n', '\t\treturn (\n', '\t\t\t_contentHost.stakeId,\n', '\t\t\t_contentHost.host,\n', '\t\t\t_contentHost.contentDatKey,\n', '\t\t\t_contentHost.metadataDatKey\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return staked content information at a given ID\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @return The ID of the content being staked\n', '\t * @return address of the staked content&#39;s owner\n', '\t * @return the network base token amount staked for this content\n', '\t * @return the primordial token amount staked for this content\n', '\t * @return the primordial weighted multiplier of the staked content\n', '\t * @return the profit percentage of the content\n', '\t * @return status of the staked content\n', '\t * @return the timestamp when the staked content was created\n', '\t */\n', '\tfunction stakedContentById(bytes32 _stakeId) public view returns (bytes32, address, uint256, uint256, uint256, uint256, bool, uint256) {\n', '\t\t// Make sure the staked content exist\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\n', '\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\treturn (\n', '\t\t\t_stakedContent.contentId,\n', '\t\t\t_stakedContent.stakeOwner,\n', '\t\t\t_stakedContent.networkAmount,\n', '\t\t\t_stakedContent.primordialAmount,\n', '\t\t\t_stakedContent.primordialWeightedMultiplier,\n', '\t\t\t_stakedContent.profitPercentage,\n', '\t\t\t_stakedContent.active,\n', '\t\t\t_stakedContent.createdOnTimestamp\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Unstake existing staked content and refund partial staked amount to the stake owner\n', '\t *\t\tUse unstakeContent() to unstake all staked token amount. unstakePartialContent() can unstake only up to\n', '\t *\t\tthe mininum required to pay the fileSize\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _networkIntegerAmount The integer amount of network token to unstake\n', '\t * @param _networkFractionAmount The fraction amount of network token to unstake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to unstake\n', '\t */\n', '\tfunction unstakePartialContent(bytes32 _stakeId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount) public isContractActive {\n', '\t\t// Make sure the staked content exist\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\t\trequire (_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0);\n', '\n', '\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\tuint256 _fileSize = contents[contentIndex[_stakedContent.contentId]].fileSize;\n', '\n', '\t\t// Make sure the staked content owner is the same as the sender\n', '\t\trequire (_stakedContent.stakeOwner == msg.sender);\n', '\t\t// Make sure the staked content is currently active (staked) with some amounts\n', '\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\n', '\t\t// Make sure the staked content has enough balance to unstake\n', '\t\trequire (AOLibrary.canUnstakePartial(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _stakedContent.networkAmount, _stakedContent.primordialAmount, _fileSize));\n', '\n', '\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\n', '\t\t\tuint256 _unstakeNetworkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\n', '\t\t\t_stakedContent.networkAmount = _stakedContent.networkAmount.sub(_unstakeNetworkAmount);\n', '\t\t\trequire (_baseAO.unstakeFrom(msg.sender, _unstakeNetworkAmount));\n', '\t\t}\n', '\t\tif (_primordialAmount > 0) {\n', '\t\t\t_stakedContent.primordialAmount = _stakedContent.primordialAmount.sub(_primordialAmount);\n', '\t\t\trequire (_baseAO.unstakePrimordialTokenFrom(msg.sender, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\n', '\t\t}\n', '\t\temit UnstakePartialContent(_stakedContent.stakeOwner, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Unstake existing staked content and refund the total staked amount to the stake owner\n', '\t * @param _stakeId The ID of the staked content\n', '\t */\n', '\tfunction unstakeContent(bytes32 _stakeId) public isContractActive {\n', '\t\t// Make sure the staked content exist\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\n', '\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\t// Make sure the staked content owner is the same as the sender\n', '\t\trequire (_stakedContent.stakeOwner == msg.sender);\n', '\t\t// Make sure the staked content is currently active (staked) with some amounts\n', '\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\n', '\n', '\t\t_stakedContent.active = false;\n', '\n', '\t\tif (_stakedContent.networkAmount > 0) {\n', '\t\t\tuint256 _unstakeNetworkAmount = _stakedContent.networkAmount;\n', '\t\t\t_stakedContent.networkAmount = 0;\n', '\t\t\trequire (_baseAO.unstakeFrom(msg.sender, _unstakeNetworkAmount));\n', '\t\t}\n', '\t\tif (_stakedContent.primordialAmount > 0) {\n', '\t\t\tuint256 _primordialAmount = _stakedContent.primordialAmount;\n', '\t\t\tuint256 _primordialWeightedMultiplier = _stakedContent.primordialWeightedMultiplier;\n', '\t\t\t_stakedContent.primordialAmount = 0;\n', '\t\t\t_stakedContent.primordialWeightedMultiplier = 0;\n', '\t\t\trequire (_baseAO.unstakePrimordialTokenFrom(msg.sender, _primordialAmount, _primordialWeightedMultiplier));\n', '\t\t}\n', '\t\temit UnstakeContent(_stakedContent.stakeOwner, _stakeId);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Stake existing content with more tokens (this is to increase the price)\n', '\t *\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake. (The primordial weighted multiplier has to match the current staked weighted multiplier)\n', '\t */\n', '\tfunction stakeExistingContent(bytes32 _stakeId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount) public isContractActive {\n', '\t\t// Make sure the staked content exist\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\n', '\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\tuint256 _fileSize = contents[contentIndex[_stakedContent.contentId]].fileSize;\n', '\n', '\t\t// Make sure the staked content owner is the same as the sender\n', '\t\trequire (_stakedContent.stakeOwner == msg.sender);\n', '\t\trequire (_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0);\n', '\t\trequire (AOLibrary.canStakeExisting(treasuryAddress, _isAOContentUsageType(_stakedContent.contentId), _fileSize, _stakedContent.networkAmount.add(_stakedContent.primordialAmount), _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount));\n', '\n', '\t\t// Make sure we can stake primordial token\n', '\t\t// If we are currently staking an active staked content, then the stake owner&#39;s weighted multiplier has to match `stakedContent.primordialWeightedMultiplier`\n', '\t\t// i.e, can&#39;t use a combination of different weighted multiplier. Stake owner has to call unstakeContent() to unstake all tokens first\n', '\t\tif (_primordialAmount > 0 && _stakedContent.active && _stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0) {\n', '\t\t\trequire (_baseAO.weightedMultiplierByAddress(msg.sender) == _stakedContent.primordialWeightedMultiplier);\n', '\t\t}\n', '\n', '\t\t_stakedContent.active = true;\n', '\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\n', '\t\t\tuint256 _stakeNetworkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\n', '\t\t\t_stakedContent.networkAmount = _stakedContent.networkAmount.add(_stakeNetworkAmount);\n', '\t\t\trequire (_baseAO.stakeFrom(_stakedContent.stakeOwner, _stakeNetworkAmount));\n', '\t\t}\n', '\t\tif (_primordialAmount > 0) {\n', '\t\t\t_stakedContent.primordialAmount = _stakedContent.primordialAmount.add(_primordialAmount);\n', '\n', '\t\t\t// Primordial Token is the base AO Token\n', '\t\t\t_stakedContent.primordialWeightedMultiplier = _baseAO.weightedMultiplierByAddress(_stakedContent.stakeOwner);\n', '\t\t\trequire (_baseAO.stakePrimordialTokenFrom(_stakedContent.stakeOwner, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\n', '\t\t}\n', '\n', '\t\temit StakeExistingContent(msg.sender, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Determine the content price hosted by a host\n', '\t * @param _contentHostId The content host ID to be checked\n', '\t * @return the price of the content\n', '\t */\n', '\tfunction contentHostPrice(bytes32 _contentHostId) public isContractActive view returns (uint256) {\n', '\t\t// Make sure content host exist\n', '\t\trequire (contentHostIndex[_contentHostId] > 0);\n', '\n', '\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_contentHostId]].stakeId;\n', '\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\n', '\t\t// Make sure content is currently staked\n', '\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\n', '\t\treturn _stakedContent.networkAmount.add(_stakedContent.primordialAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Determine the how much the content is paid by AO given a contentHostId\n', '\t * @param _contentHostId The content host ID to be checked\n', '\t * @return the amount paid by AO\n', '\t */\n', '\tfunction contentHostPaidByAO(bytes32 _contentHostId) public isContractActive view returns (uint256) {\n', '\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_contentHostId]].stakeId;\n', '\t\tbytes32 _contentId = stakedContents[stakedContentIndex[_stakeId]].contentId;\n', '\t\tif (_isAOContentUsageType(_contentId)) {\n', '\t\t\treturn 0;\n', '\t\t} else {\n', '\t\t\treturn contentHostPrice(_contentHostId);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Bring content in to the requesting node by sending network tokens to the contract to pay for the content\n', '\t * @param _contentHostId The ID of hosted content\n', '\t * @param _networkIntegerAmount The integer amount of network token to pay\n', '\t * @param _networkFractionAmount The fraction amount of network token to pay\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _publicKey The public key of the request node\n', '\t * @param _publicAddress The public address of the request node\n', '\t */\n', '\tfunction buyContent(bytes32 _contentHostId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, string _publicKey, address _publicAddress) public isContractActive {\n', '\t\t// Make sure the content host exist\n', '\t\trequire (contentHostIndex[_contentHostId] > 0);\n', '\n', '\t\t// Make sure public key is not empty\n', '\t\trequire (bytes(_publicKey).length > 0);\n', '\n', '\t\t// Make sure public address is valid\n', '\t\trequire (_publicAddress != address(0));\n', '\n', '\t\tContentHost memory _contentHost = contentHosts[contentHostIndex[_contentHostId]];\n', '\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_contentHost.stakeId]];\n', '\n', '\t\t// Make sure the content currently has stake\n', '\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\n', '\n', '\t\t// Make sure the buyer has not bought this content previously\n', '\t\trequire (buyerPurchaseReceipts[msg.sender][_contentHostId][0] == 0);\n', '\n', '\t\t// Make sure the token amount can pay for the content price\n', '\t\tif (_isAOContentUsageType(_stakedContent.contentId)) {\n', '\t\t\trequire (AOLibrary.canBuy(treasuryAddress, _stakedContent.networkAmount.add(_stakedContent.primordialAmount), _networkIntegerAmount, _networkFractionAmount, _denomination));\n', '\t\t}\n', '\n', '\t\t// Increment totalPurchaseReceipts;\n', '\t\ttotalPurchaseReceipts++;\n', '\n', '\t\t// Generate purchaseId\n', '\t\tbytes32 _purchaseId = keccak256(abi.encodePacked(this, msg.sender, _contentHostId));\n', '\t\tPurchaseReceipt storage _purchaseReceipt = purchaseReceipts[totalPurchaseReceipts];\n', '\n', '\t\t// Make sure the node doesn&#39;t buy the same content twice\n', '\t\trequire (_purchaseReceipt.buyer == address(0));\n', '\n', '\t\t_purchaseReceipt.purchaseId = _purchaseId;\n', '\t\t_purchaseReceipt.contentHostId = _contentHostId;\n', '\t\t_purchaseReceipt.buyer = msg.sender;\n', '\t\t// Update the receipt with the correct network amount\n', '\t\t_purchaseReceipt.price = _stakedContent.networkAmount.add(_stakedContent.primordialAmount);\n', '\t\t_purchaseReceipt.amountPaidByAO = contentHostPaidByAO(_contentHostId);\n', '\t\t_purchaseReceipt.amountPaidByBuyer = _purchaseReceipt.price.sub(_purchaseReceipt.amountPaidByAO);\n', '\t\t_purchaseReceipt.publicKey = _publicKey;\n', '\t\t_purchaseReceipt.publicAddress = _publicAddress;\n', '\t\t_purchaseReceipt.createdOnTimestamp = now;\n', '\n', '\t\tpurchaseReceiptIndex[_purchaseId] = totalPurchaseReceipts;\n', '\t\tbuyerPurchaseReceipts[msg.sender][_contentHostId] = _purchaseId;\n', '\n', '\t\t// Calculate content creator/host/The AO earning from this purchase and store them in escrow\n', '\t\trequire (_earning.calculateEarning(\n', '\t\t\tmsg.sender,\n', '\t\t\t_purchaseId,\n', '\t\t\t_stakedContent.networkAmount,\n', '\t\t\t_stakedContent.primordialAmount,\n', '\t\t\t_stakedContent.primordialWeightedMultiplier,\n', '\t\t\t_stakedContent.profitPercentage,\n', '\t\t\t_stakedContent.stakeOwner,\n', '\t\t\t_contentHost.host,\n', '\t\t\t_isAOContentUsageType(_stakedContent.contentId)\n', '\t\t));\n', '\n', '\t\temit BuyContent(_purchaseReceipt.buyer, _purchaseReceipt.purchaseId, _purchaseReceipt.contentHostId, _purchaseReceipt.price, _purchaseReceipt.amountPaidByAO, _purchaseReceipt.amountPaidByBuyer, _purchaseReceipt.publicKey, _purchaseReceipt.publicAddress, _purchaseReceipt.createdOnTimestamp);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return purchase receipt info at a given ID\n', '\t * @param _purchaseId The ID of the purchased content\n', '\t * @return The ID of the content host\n', '\t * @return address of the buyer\n', '\t * @return price of the content\n', '\t * @return amount paid by AO\n', '\t * @return amount paid by Buyer\n', '\t * @return request node&#39;s public key\n', '\t * @return request node&#39;s public address\n', '\t * @return created on timestamp\n', '\t */\n', '\tfunction purchaseReceiptById(bytes32 _purchaseId) public view returns (bytes32, address, uint256, uint256, uint256, string, address, uint256) {\n', '\t\t// Make sure the purchase receipt exist\n', '\t\trequire (purchaseReceiptIndex[_purchaseId] > 0);\n', '\t\tPurchaseReceipt memory _purchaseReceipt = purchaseReceipts[purchaseReceiptIndex[_purchaseId]];\n', '\t\treturn (\n', '\t\t\t_purchaseReceipt.contentHostId,\n', '\t\t\t_purchaseReceipt.buyer,\n', '\t\t\t_purchaseReceipt.price,\n', '\t\t\t_purchaseReceipt.amountPaidByAO,\n', '\t\t\t_purchaseReceipt.amountPaidByBuyer,\n', '\t\t\t_purchaseReceipt.publicKey,\n', '\t\t\t_purchaseReceipt.publicAddress,\n', '\t\t\t_purchaseReceipt.createdOnTimestamp\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Request node wants to become a distribution node after buying the content\n', '\t *\t\tAlso, if this transaction succeeds, contract will release all of the earnings that are\n', '\t *\t\tcurrently in escrow for content creator/host/The AO\n', '\t */\n', '\tfunction becomeHost(\n', '\t\tbytes32 _purchaseId,\n', '\t\tuint8 _baseChallengeV,\n', '\t\tbytes32 _baseChallengeR,\n', '\t\tbytes32 _baseChallengeS,\n', '\t\tstring _encChallenge,\n', '\t\tstring _contentDatKey,\n', '\t\tstring _metadataDatKey\n', '\t) public isContractActive {\n', '\t\t// Make sure the purchase receipt exist\n', '\t\trequire (purchaseReceiptIndex[_purchaseId] > 0);\n', '\n', '\t\tPurchaseReceipt memory _purchaseReceipt = purchaseReceipts[purchaseReceiptIndex[_purchaseId]];\n', '\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_purchaseReceipt.contentHostId]].stakeId;\n', '\t\tbytes32 _contentId = stakedContents[stakedContentIndex[_stakeId]].contentId;\n', '\n', '\t\t// Make sure the purchase receipt owner is the same as the sender\n', '\t\trequire (_purchaseReceipt.buyer == msg.sender);\n', '\n', '\t\t// Verify that the file is not tampered by validating the base challenge signature\n', '\t\t// The signed base challenge key should match the one from content creator\n', '\t\tContent memory _content = contents[contentIndex[_contentId]];\n', '\t\trequire (AOLibrary.getBecomeHostSignatureAddress(address(this), _content.baseChallenge, _baseChallengeV, _baseChallengeR, _baseChallengeS) == _purchaseReceipt.publicAddress);\n', '\n', '\t\t_hostContent(msg.sender, _stakeId, _encChallenge, _contentDatKey, _metadataDatKey);\n', '\n', '\t\t// Release earning from escrow\n', '\t\trequire (_earning.releaseEarning(\n', '\t\t\t_stakeId,\n', '\t\t\t_purchaseReceipt.contentHostId,\n', '\t\t\t_purchaseId,\n', '\t\t\t(_purchaseReceipt.amountPaidByBuyer > _content.fileSize),\n', '\t\t\tstakedContents[stakedContentIndex[_stakeId]].stakeOwner,\n', '\t\t\tcontentHosts[contentHostIndex[_purchaseReceipt.contentHostId]].host)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Update the TAO Content State of a T(AO) Content\n', '\t * @param _contentId The ID of the Content\n', '\t * @param _taoId The ID of the TAO that initiates the update\n', '\t * @param _taoContentState The TAO Content state value, i.e Submitted, Pending Review, or Accepted to TAO\n', '\t * @param _updateTAOContentStateV The V part of the signature for this update\n', '\t * @param _updateTAOContentStateR The R part of the signature for this update\n', '\t * @param _updateTAOContentStateS The S part of the signature for this update\n', '\t */\n', '\tfunction updateTAOContentState(\n', '\t\tbytes32 _contentId,\n', '\t\taddress _taoId,\n', '\t\tbytes32 _taoContentState,\n', '\t\tuint8 _updateTAOContentStateV,\n', '\t\tbytes32 _updateTAOContentStateR,\n', '\t\tbytes32 _updateTAOContentStateS\n', '\t) public isContractActive {\n', '\t\t// Make sure the content exist\n', '\t\trequire (contentIndex[_contentId] > 0);\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t(,, bytes32 _contentUsageType_taoContent, bytes32 taoContentState_submitted, bytes32 taoContentState_pendingReview, bytes32 taoContentState_acceptedToTAO) = _getSettingVariables();\n', '\t\trequire (_taoContentState == taoContentState_submitted || _taoContentState == taoContentState_pendingReview || _taoContentState == taoContentState_acceptedToTAO);\n', '\n', '\t\taddress _signatureAddress = AOLibrary.getUpdateTAOContentStateSignatureAddress(address(this), _contentId, _taoId, _taoContentState, _updateTAOContentStateV, _updateTAOContentStateR, _updateTAOContentStateS);\n', '\n', '\t\tContent storage _content = contents[contentIndex[_contentId]];\n', '\t\t// Make sure that the signature address is one of content&#39;s TAO ID&#39;s Advocate/Listener/Speaker\n', '\t\trequire (_signatureAddress == msg.sender && _nameTAOPosition.senderIsPosition(_signatureAddress, _content.taoId));\n', '\t\trequire (_content.contentUsageType == _contentUsageType_taoContent);\n', '\n', '\t\t_content.taoContentState = _taoContentState;\n', '\t\t_content.updateTAOContentStateV = _updateTAOContentStateV;\n', '\t\t_content.updateTAOContentStateR = _updateTAOContentStateR;\n', '\t\t_content.updateTAOContentStateS = _updateTAOContentStateS;\n', '\n', '\t\temit UpdateTAOContentState(_contentId, _taoId, _signatureAddress, _taoContentState);\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Store the content information (content creation during staking)\n', '\t * @param _creator the address of the content creator\n', '\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\n', '\t * @param _fileSize The size of the file\n', '\t * @param _contentUsageType The content usage type, i.e AO Content, Creative Commons, or T(AO) Content\n', '\t * @param _taoId The TAO (TAO) ID for this content (if this is a T(AO) Content)\n', '\t * @return the ID of the content\n', '\t */\n', '\tfunction _storeContent(address _creator, string _baseChallenge, uint256 _fileSize, bytes32 _contentUsageType, address _taoId) internal returns (bytes32) {\n', '\t\t// Increment totalContents\n', '\t\ttotalContents++;\n', '\n', '\t\t// Generate contentId\n', '\t\tbytes32 _contentId = keccak256(abi.encodePacked(this, _creator, totalContents));\n', '\t\tContent storage _content = contents[totalContents];\n', '\n', '\t\t// Make sure the node does&#39;t store the same content twice\n', '\t\trequire (_content.creator == address(0));\n', '\n', '\t\t(,,bytes32 contentUsageType_taoContent, bytes32 taoContentState_submitted,,) = _getSettingVariables();\n', '\n', '\t\t_content.contentId = _contentId;\n', '\t\t_content.creator = _creator;\n', '\t\t_content.baseChallenge = _baseChallenge;\n', '\t\t_content.fileSize = _fileSize;\n', '\t\t_content.contentUsageType = _contentUsageType;\n', '\n', '\t\t// If this is a TAO Content\n', '\t\tif (_contentUsageType == contentUsageType_taoContent) {\n', '\t\t\t_content.taoContentState = taoContentState_submitted;\n', '\t\t\t_content.taoId = _taoId;\n', '\t\t}\n', '\n', '\t\tcontentIndex[_contentId] = totalContents;\n', '\n', '\t\temit StoreContent(_content.creator, _content.contentId, _content.fileSize, _content.contentUsageType);\n', '\t\treturn _content.contentId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add the distribution node info that hosts the content\n', '\t * @param _host the address of the host\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\n', '\t * @param _contentDatKey The dat key of the content\n', '\t * @param _metadataDatKey The dat key of the content&#39;s metadata\n', '\t */\n', '\tfunction _hostContent(address _host, bytes32 _stakeId, string _encChallenge, string _contentDatKey, string _metadataDatKey) internal {\n', '\t\trequire (bytes(_encChallenge).length > 0);\n', '\t\trequire (bytes(_contentDatKey).length > 0);\n', '\t\trequire (bytes(_metadataDatKey).length > 0);\n', '\t\trequire (stakedContentIndex[_stakeId] > 0);\n', '\n', '\t\t// Increment totalContentHosts\n', '\t\ttotalContentHosts++;\n', '\n', '\t\t// Generate contentId\n', '\t\tbytes32 _contentHostId = keccak256(abi.encodePacked(this, _host, _stakeId));\n', '\n', '\t\tContentHost storage _contentHost = contentHosts[totalContentHosts];\n', '\n', '\t\t// Make sure the node doesn&#39;t host the same content twice\n', '\t\trequire (_contentHost.host == address(0));\n', '\n', '\t\t_contentHost.contentHostId = _contentHostId;\n', '\t\t_contentHost.stakeId = _stakeId;\n', '\t\t_contentHost.host = _host;\n', '\t\t_contentHost.encChallenge = _encChallenge;\n', '\t\t_contentHost.contentDatKey = _contentDatKey;\n', '\t\t_contentHost.metadataDatKey = _metadataDatKey;\n', '\n', '\t\tcontentHostIndex[_contentHostId] = totalContentHosts;\n', '\n', '\t\temit HostContent(_contentHost.host, _contentHost.contentHostId, _contentHost.stakeId, _contentHost.contentDatKey, _contentHost.metadataDatKey);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev actual staking the content\n', '\t * @param _stakeOwner the address that stake the content\n', '\t * @param _contentId The ID of the content\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _profitPercentage The percentage of profit the stake owner&#39;s media will charge\n', '\t * @return the newly created staked content ID\n', '\t */\n', '\tfunction _stakeContent(address _stakeOwner, bytes32 _contentId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount, uint256 _profitPercentage) internal returns (bytes32) {\n', '\t\t// Increment totalStakedContents\n', '\t\ttotalStakedContents++;\n', '\n', '\t\t// Generate stakeId\n', '\t\tbytes32 _stakeId = keccak256(abi.encodePacked(this, _stakeOwner, _contentId));\n', '\t\tStakedContent storage _stakedContent = stakedContents[totalStakedContents];\n', '\n', '\t\t// Make sure the node doesn&#39;t stake the same content twice\n', '\t\trequire (_stakedContent.stakeOwner == address(0));\n', '\n', '\t\t_stakedContent.stakeId = _stakeId;\n', '\t\t_stakedContent.contentId = _contentId;\n', '\t\t_stakedContent.stakeOwner = _stakeOwner;\n', '\t\t_stakedContent.profitPercentage = _profitPercentage;\n', '\t\t_stakedContent.active = true;\n', '\t\t_stakedContent.createdOnTimestamp = now;\n', '\n', '\t\tstakedContentIndex[_stakeId] = totalStakedContents;\n', '\n', '\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\n', '\t\t\t_stakedContent.networkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\n', '\t\t\trequire (_baseAO.stakeFrom(_stakeOwner, _stakedContent.networkAmount));\n', '\t\t}\n', '\t\tif (_primordialAmount > 0) {\n', '\t\t\t_stakedContent.primordialAmount = _primordialAmount;\n', '\n', '\t\t\t// Primordial Token is the base AO Token\n', '\t\t\t_stakedContent.primordialWeightedMultiplier = _baseAO.weightedMultiplierByAddress(_stakedContent.stakeOwner);\n', '\t\t\trequire (_baseAO.stakePrimordialTokenFrom(_stakedContent.stakeOwner, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\n', '\t\t}\n', '\n', '\t\temit StakeContent(_stakedContent.stakeOwner, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier, _stakedContent.profitPercentage, _stakedContent.createdOnTimestamp);\n', '\n', '\t\treturn _stakedContent.stakeId;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get setting variables\n', '\t * @return contentUsageType_aoContent Content Usage Type = AO Content\n', '\t * @return contentUsageType_creativeCommons Content Usage Type = Creative Commons\n', '\t * @return contentUsageType_taoContent Content Usage Type = T(AO) Content\n', '\t * @return taoContentState_submitted TAO Content State = Submitted\n', '\t * @return taoContentState_pendingReview TAO Content State = Pending Review\n', '\t * @return taoContentState_acceptedToTAO TAO Content State = Accepted to TAO\n', '\t */\n', '\tfunction _getSettingVariables() internal view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bytes32) {\n', '\t\t(,,,bytes32 contentUsageType_aoContent,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;contentUsageType_aoContent&#39;);\n', '\t\t(,,,bytes32 contentUsageType_creativeCommons,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;contentUsageType_creativeCommons&#39;);\n', '\t\t(,,,bytes32 contentUsageType_taoContent,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;contentUsageType_taoContent&#39;);\n', '\t\t(,,,bytes32 taoContentState_submitted,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;taoContentState_submitted&#39;);\n', '\t\t(,,,bytes32 taoContentState_pendingReview,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;taoContentState_pendingReview&#39;);\n', '\t\t(,,,bytes32 taoContentState_acceptedToTAO,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, &#39;taoContentState_acceptedToTAO&#39;);\n', '\n', '\t\treturn (\n', '\t\t\tcontentUsageType_aoContent,\n', '\t\t\tcontentUsageType_creativeCommons,\n', '\t\t\tcontentUsageType_taoContent,\n', '\t\t\ttaoContentState_submitted,\n', '\t\t\ttaoContentState_pendingReview,\n', '\t\t\ttaoContentState_acceptedToTAO\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the content is of AO Content Usage Type\n', '\t * @param _contentId The ID of the content\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction _isAOContentUsageType(bytes32 _contentId) internal view returns (bool) {\n', '\t\t(bytes32 _contentUsageType_aoContent,,,,,) = _getSettingVariables();\n', '\t\treturn contents[contentIndex[_contentId]].contentUsageType == _contentUsageType_aoContent;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Name\n', ' */\n', 'contract Name is TAO {\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string _name, address _originId, string _datHash, string _database, string _keyValue, bytes32 _contentId, address _vaultAddress)\n', '\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\n', '\t\t// Creating Name\n', '\t\ttypeId = 1;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Logos is TAOCurrency {\n', '\tNameTAOPosition internal _nameTAOPosition;\n', '\n', '\t// Mapping of a Name ID to the amount of Logos positioned by others to itself\n', '\t// address is the address of nameId, not the eth public address\n', '\tmapping (address => uint256) public positionFromOthers;\n', '\n', '\t// Mapping of Name ID to other Name ID and the amount of Logos positioned by itself\n', '\tmapping (address => mapping(address => uint256)) public positionToOthers;\n', '\n', '\t// Mapping of a Name ID to the total amount of Logos positioned by itself to others\n', '\tmapping (address => uint256) public totalPositionToOthers;\n', '\n', '\t// Mapping of Name ID to it&#39;s advocated TAO ID and the amount of Logos earned\n', '\tmapping (address => mapping(address => uint256)) public advocatedTAOLogos;\n', '\n', '\t// Mapping of a Name ID to the total amount of Logos earned from advocated TAO\n', '\tmapping (address => uint256) public totalAdvocatedTAOLogos;\n', '\n', '\t// Event broadcasted to public when `from` address position `value` Logos to `to`\n', '\tevent PositionFrom(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// Event broadcasted to public when `from` address unposition `value` Logos from `to`\n', '\tevent UnpositionFrom(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// Event broadcasted to public when `nameId` receives `amount` of Logos from advocating `taoId`\n', '\tevent AddAdvocatedTAOLogos(address indexed nameId, address indexed taoId, uint256 amount);\n', '\n', '\t// Event broadcasted to public when Logos from advocating `taoId` is transferred from `fromNameId` to `toNameId`\n', '\tevent TransferAdvocatedTAOLogos(address indexed fromNameId, address indexed toNameId, address indexed taoId, uint256 amount);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol, address _nameTAOPositionAddress)\n', '\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of _id\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Get the total sum of Logos for an address\n', '\t * @param _target The address to check\n', '\t * @return The total sum of Logos (own + positioned + advocated TAOs)\n', '\t */\n', '\tfunction sumBalanceOf(address _target) public isNameOrTAO(_target) view returns (uint256) {\n', '\t\treturn balanceOf[_target].add(positionFromOthers[_target]).add(totalAdvocatedTAOLogos[_target]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev `_from` Name position `_value` Logos onto `_to` Name\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to position\n', '\t * @return true on success\n', '\t */\n', '\tfunction positionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) onlyAdvocate(_from) returns (bool) {\n', '\t\trequire (_from != _to);\t// Can&#39;t position Logos to itself\n', '\t\trequire (balanceOf[_from].sub(totalPositionToOthers[_from]) >= _value); // should have enough balance to position\n', '\t\trequire (positionFromOthers[_to].add(_value) >= positionFromOthers[_to]); // check for overflows\n', '\n', '\t\tuint256 previousPositionToOthers = totalPositionToOthers[_from];\n', '\t\tuint256 previousPositionFromOthers = positionFromOthers[_to];\n', '\t\tuint256 previousAvailPositionBalance = balanceOf[_from].sub(totalPositionToOthers[_from]);\n', '\n', '\t\tpositionToOthers[_from][_to] = positionToOthers[_from][_to].add(_value);\n', '\t\ttotalPositionToOthers[_from] = totalPositionToOthers[_from].add(_value);\n', '\t\tpositionFromOthers[_to] = positionFromOthers[_to].add(_value);\n', '\n', '\t\temit PositionFrom(_from, _to, _value);\n', '\t\tassert(totalPositionToOthers[_from].sub(_value) == previousPositionToOthers);\n', '\t\tassert(positionFromOthers[_to].sub(_value) == previousPositionFromOthers);\n', '\t\tassert(balanceOf[_from].sub(totalPositionToOthers[_from]) <= previousAvailPositionBalance);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev `_from` Name unposition `_value` Logos from `_to` Name\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to unposition\n', '\t * @return true on success\n', '\t */\n', '\tfunction unpositionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) onlyAdvocate(_from) returns (bool) {\n', '\t\trequire (_from != _to);\t// Can&#39;t unposition Logos to itself\n', '\t\trequire (positionToOthers[_from][_to] >= _value);\n', '\n', '\t\tuint256 previousPositionToOthers = totalPositionToOthers[_from];\n', '\t\tuint256 previousPositionFromOthers = positionFromOthers[_to];\n', '\t\tuint256 previousAvailPositionBalance = balanceOf[_from].sub(totalPositionToOthers[_from]);\n', '\n', '\t\tpositionToOthers[_from][_to] = positionToOthers[_from][_to].sub(_value);\n', '\t\ttotalPositionToOthers[_from] = totalPositionToOthers[_from].sub(_value);\n', '\t\tpositionFromOthers[_to] = positionFromOthers[_to].sub(_value);\n', '\n', '\t\temit UnpositionFrom(_from, _to, _value);\n', '\t\tassert(totalPositionToOthers[_from].add(_value) == previousPositionToOthers);\n', '\t\tassert(positionFromOthers[_to].add(_value) == previousPositionFromOthers);\n', '\t\tassert(balanceOf[_from].sub(totalPositionToOthers[_from]) >= previousAvailPositionBalance);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add `_amount` logos earned from advocating a TAO `_taoId` to its Advocate\n', '\t * @param _taoId The ID of the advocated TAO\n', '\t * @param _amount the amount to reward\n', '\t * @return true on success\n', '\t */\n', '\tfunction addAdvocatedTAOLogos(address _taoId, uint256 _amount) public inWhitelist isTAO(_taoId) returns (bool) {\n', '\t\trequire (_amount > 0);\n', '\t\taddress _nameId = _nameTAOPosition.getAdvocate(_taoId);\n', '\n', '\t\tadvocatedTAOLogos[_nameId][_taoId] = advocatedTAOLogos[_nameId][_taoId].add(_amount);\n', '\t\ttotalAdvocatedTAOLogos[_nameId] = totalAdvocatedTAOLogos[_nameId].add(_amount);\n', '\n', '\t\temit AddAdvocatedTAOLogos(_nameId, _taoId, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer logos earned from advocating a TAO `_taoId` from `_fromNameId` to `_toNameId`\n', '\t * @param _fromNameId The ID of the Name that sends the Logos\n', '\t * @param _toNameId The ID of the Name that receives the Logos\n', '\t * @param _taoId The ID of the advocated TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferAdvocatedTAOLogos(address _fromNameId, address _toNameId, address _taoId) public inWhitelist isName(_fromNameId) isName(_toNameId) isTAO(_taoId) returns (bool) {\n', '\t\trequire (_nameTAOPosition.nameIsAdvocate(_toNameId, _taoId));\n', '\t\trequire (advocatedTAOLogos[_fromNameId][_taoId] > 0);\n', '\t\trequire (totalAdvocatedTAOLogos[_fromNameId] >= advocatedTAOLogos[_fromNameId][_taoId]);\n', '\n', '\t\tuint256 _amount = advocatedTAOLogos[_fromNameId][_taoId];\n', '\t\tadvocatedTAOLogos[_fromNameId][_taoId] = advocatedTAOLogos[_fromNameId][_taoId].sub(_amount);\n', '\t\ttotalAdvocatedTAOLogos[_fromNameId] = totalAdvocatedTAOLogos[_fromNameId].sub(_amount);\n', '\t\tadvocatedTAOLogos[_toNameId][_taoId] = advocatedTAOLogos[_toNameId][_taoId].add(_amount);\n', '\t\ttotalAdvocatedTAOLogos[_toNameId] = totalAdvocatedTAOLogos[_toNameId].add(_amount);\n', '\n', '\t\temit TransferAdvocatedTAOLogos(_fromNameId, _toNameId, _taoId, _amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AOLibrary\n', ' */\n', 'library AOLibrary {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\n', '\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given TAO ID is a TAO\n', '\t * @param _taoId The ID of the TAO\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isTAO(address _taoId) public view returns (bool) {\n', '\t\treturn (_taoId != address(0) && bytes(TAO(_taoId).name()).length > 0 && TAO(_taoId).originId() != address(0) && TAO(_taoId).typeId() == 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given Name ID is a Name\n', '\t * @param _nameId The ID of the Name\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isName(address _nameId) public view returns (bool) {\n', '\t\treturn (_nameId != address(0) && bytes(TAO(_nameId).name()).length > 0 && Name(_nameId).originId() != address(0) && Name(_nameId).typeId() == 1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t * @param _sender The address to check\n', '\t * @param _theAO The AO address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\n', '\t\treturn (_sender == _theAO ||\n', '\t\t\t(\n', '\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\n', '\t\t\t\t_nameTAOPositionAddress != address(0) &&\n', '\t\t\t\tNameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\n', '\t\t\t)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate percentage.\n', '\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\n', '\t *\t\tso 1% is 10000, 1.25% is 12500, etc\n', '\t */\n', '\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _PERCENTAGE_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate multiplier.\n', '\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\n', '\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\n', '\t */\n', '\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _MULTIPLIER_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not content creator can stake a content based on the provided params\n', '\t * @param _treasuryAddress AO treasury contract address\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\n', '\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\n', '\t * @param _contentDatKey The dat key of the content\n', '\t * @param _metadataDatKey The dat key of the content&#39;s metadata\n', '\t * @param _fileSize The size of the file\n', '\t * @param _profitPercentage The percentage of profit the stake owner&#39;s media will charge\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction canStake(address _treasuryAddress,\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount,\n', '\t\tstring _baseChallenge,\n', '\t\tstring _encChallenge,\n', '\t\tstring _contentDatKey,\n', '\t\tstring _metadataDatKey,\n', '\t\tuint256 _fileSize,\n', '\t\tuint256 _profitPercentage) public view returns (bool) {\n', '\t\treturn (\n', '\t\t\tbytes(_baseChallenge).length > 0 &&\n', '\t\t\tbytes(_encChallenge).length > 0 &&\n', '\t\t\tbytes(_contentDatKey).length > 0 &&\n', '\t\t\tbytes(_metadataDatKey).length > 0 &&\n', '\t\t\t_fileSize > 0 &&\n', '\t\t\t(_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0) &&\n', '\t\t\t_stakeAmountValid(_treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _fileSize) == true &&\n', '\t\t\t_profitPercentage <= _PERCENTAGE_DIVISOR\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or the requested unstake amount is valid\n', '\t * @param _treasuryAddress AO treasury contract address\n', '\t * @param _networkIntegerAmount The integer amount of the network token\n', '\t * @param _networkFractionAmount The fraction amount of the network token\n', '\t * @param _denomination The denomination of the the network token\n', '\t * @param _primordialAmount The amount of primordial token\n', '\t * @param _stakedNetworkAmount The current staked network token amount\n', '\t * @param _stakedPrimordialAmount The current staked primordial token amount\n', '\t * @param _stakedFileSize The file size of the staked content\n', '\t * @return true if can unstake, false otherwise\n', '\t */\n', '\tfunction canUnstakePartial(\n', '\t\taddress _treasuryAddress,\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount,\n', '\t\tuint256 _stakedNetworkAmount,\n', '\t\tuint256 _stakedPrimordialAmount,\n', '\t\tuint256 _stakedFileSize) public view returns (bool) {\n', '\t\tif (\n', '\t\t\t(_denomination.length > 0 &&\n', '\t\t\t\t(_networkIntegerAmount > 0 || _networkFractionAmount > 0) &&\n', '\t\t\t\t_stakedNetworkAmount < AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination)\n', '\t\t\t) ||\n', '\t\t\t_stakedPrimordialAmount < _primordialAmount ||\n', '\t\t\t(\n', '\t\t\t\t_denomination.length > 0\n', '\t\t\t\t\t&& (_networkIntegerAmount > 0 || _networkFractionAmount > 0)\n', '\t\t\t\t\t&& (_stakedNetworkAmount.sub(AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination)).add(_stakedPrimordialAmount.sub(_primordialAmount)) < _stakedFileSize)\n', '\t\t\t) ||\n', '\t\t\t( _denomination.length == 0 && _networkIntegerAmount == 0 && _networkFractionAmount == 0 && _primordialAmount > 0 && _stakedPrimordialAmount.sub(_primordialAmount) < _stakedFileSize)\n', '\t\t) {\n', '\t\t\treturn false;\n', '\t\t} else {\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether the network token and/or primordial token is adequate to pay for existing staked content\n', '\t * @param _treasuryAddress AO treasury contract address\n', '\t * @param _isAOContentUsageType whether or not the content is of AO Content usage type\n', '\t * @param _fileSize The size of the file\n', '\t * @param _stakedAmount The total staked amount\n', '\t * @param _networkIntegerAmount The integer amount of the network token\n', '\t * @param _networkFractionAmount The fraction amount of the network token\n', '\t * @param _denomination The denomination of the the network token\n', '\t * @param _primordialAmount The amount of primordial token\n', '\t * @return true when the amount is sufficient, false otherwise\n', '\t */\n', '\tfunction canStakeExisting(\n', '\t\taddress _treasuryAddress,\n', '\t\tbool _isAOContentUsageType,\n', '\t\tuint256 _fileSize,\n', '\t\tuint256 _stakedAmount,\n', '\t\tuint256 _networkIntegerAmount,\n', '\t\tuint256 _networkFractionAmount,\n', '\t\tbytes8 _denomination,\n', '\t\tuint256 _primordialAmount\n', '\t) public view returns (bool) {\n', '\t\tif (_isAOContentUsageType) {\n', '\t\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount).add(_stakedAmount) >= _fileSize;\n', '\t\t} else {\n', '\t\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount).add(_stakedAmount) == _fileSize;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether the network token is adequate to pay for existing staked content\n', '\t * @param _treasuryAddress AO treasury contract address\n', '\t * @param _price The price of the content\n', '\t * @param _networkIntegerAmount The integer amount of the network token\n', '\t * @param _networkFractionAmount The fraction amount of the network token\n', '\t * @param _denomination The denomination of the the network token\n', '\t * @return true when the amount is sufficient, false otherwise\n', '\t */\n', '\tfunction canBuy(address _treasuryAddress, uint256 _price, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination) public view returns (bool) {\n', '\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination) >= _price;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\n', '\t * @param _currentWeightedMultiplier Account&#39;s current weighted multiplier\n', '\t * @param _currentPrimordialBalance Account&#39;s current primordial token balance\n', '\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\n', '\t * @param _additionalPrimordialAmount The primordial token amount to be added\n', '\t * @return the new primordial weighted multiplier\n', '\t */\n', '\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\n', '\t\tif (_currentWeightedMultiplier > 0) {\n', '\t\t\tuint256 _totalWeightedTokens = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\n', '\t\t\tuint256 _totalTokens = _currentPrimordialBalance.add(_additionalPrimordialAmount);\n', '\t\t\treturn _totalWeightedTokens.div(_totalTokens);\n', '\t\t} else {\n', '\t\t\treturn _additionalWeightedMultiplier;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the address that signed the message when a node wants to become a host\n', '\t * @param _callingContractAddress the address of the calling contract\n', '\t * @param _message the message that was signed\n', '\t * @param _v part of the signature\n', '\t * @param _r part of the signature\n', '\t * @param _s part of the signature\n', '\t * @return the address that signed the message\n', '\t */\n', '\tfunction getBecomeHostSignatureAddress(address _callingContractAddress, string _message, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', '\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _message));\n', '\t\treturn ecrecover(_hash, _v, _r, _s);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the address that signed the TAO content state update\n', '\t * @param _callingContractAddress the address of the calling contract\n', '\t * @param _contentId the ID of the content\n', '\t * @param _taoId the ID of the TAO\n', '\t * @param _taoContentState the TAO Content State value, i.e Submitted, Pending Review, or Accepted to TAO\n', '\t * @param _v part of the signature\n', '\t * @param _r part of the signature\n', '\t * @param _s part of the signature\n', '\t * @return the address that signed the message\n', '\t */\n', '\tfunction getUpdateTAOContentStateSignatureAddress(address _callingContractAddress, bytes32 _contentId, address _taoId, bytes32 _taoContentState, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', '\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _contentId, _taoId, _taoContentState));\n', '\t\treturn ecrecover(_hash, _v, _r, _s);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the staking and earning information of a stake ID\n', '\t * @param _contentAddress The address of AOContent\n', '\t * @param _earningAddress The address of AOEarning\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @return the network base token amount staked for this content\n', '\t * @return the primordial token amount staked for this content\n', '\t * @return the primordial weighted multiplier of the staked content\n', '\t * @return the total earning from staking this content\n', '\t * @return the total earning from hosting this content\n', '\t * @return the total The AO earning of this content\n', '\t */\n', '\tfunction getContentMetrics(address _contentAddress, address _earningAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '\t\t(uint256 networkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier) = getStakingMetrics(_contentAddress, _stakeId);\n', '\t\t(uint256 totalStakeEarning, uint256 totalHostEarning, uint256 totalTheAOEarning) = getEarningMetrics(_earningAddress, _stakeId);\n', '\t\treturn (\n', '\t\t\tnetworkAmount,\n', '\t\t\tprimordialAmount,\n', '\t\t\tprimordialWeightedMultiplier,\n', '\t\t\ttotalStakeEarning,\n', '\t\t\ttotalHostEarning,\n', '\t\t\ttotalTheAOEarning\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the staking information of a stake ID\n', '\t * @param _contentAddress The address of AOContent\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @return the network base token amount staked for this content\n', '\t * @return the primordial token amount staked for this content\n', '\t * @return the primordial weighted multiplier of the staked content\n', '\t */\n', '\tfunction getStakingMetrics(address _contentAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256) {\n', '\t\t(,, uint256 networkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier,,,) = AOContent(_contentAddress).stakedContentById(_stakeId);\n', '\t\treturn (\n', '\t\t\tnetworkAmount,\n', '\t\t\tprimordialAmount,\n', '\t\t\tprimordialWeightedMultiplier\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the earning information of a stake ID\n', '\t * @param _earningAddress The address of AOEarning\n', '\t * @param _stakeId The ID of the staked content\n', '\t * @return the total earning from staking this content\n', '\t * @return the total earning from hosting this content\n', '\t * @return the total The AO earning of this content\n', '\t */\n', '\tfunction getEarningMetrics(address _earningAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256) {\n', '\t\treturn (\n', '\t\t\tAOEarning(_earningAddress).totalStakedContentStakeEarning(_stakeId),\n', '\t\t\tAOEarning(_earningAddress).totalStakedContentHostEarning(_stakeId),\n', '\t\t\tAOEarning(_earningAddress).totalStakedContentTheAOEarning(_stakeId)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the primordial token multiplier on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Multiplier = S\n', '\t *\t\tEnding Multiplier = E\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial token intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial token intable\n', '\t * @param _totalPrimordialMinted Total Primordial token minted so far\n', '\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\n', '\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\n', '\t * @return The multiplier in (10 ** 6)\n', '\t */\n', '\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\n', '\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\n', '\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\n', '\t\t\t/**\n', '\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\n', '\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\n', '\t\t\t */\n', '\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus percentage of network token on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Network Token Bonus Multiplier = Bs\n', '\t *\t\tEnding Network Token Bonus Multiplier = Be\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial token intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial token intable\n', '\t * @param _totalPrimordialMinted Total Primordial token minted so far\n', '\t * @param _startingMultiplier The starting Network token bonus multiplier\n', '\t * @param _endingMultiplier The ending Network token bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkTokenBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\n', '\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\n', '\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\n', '\t\t\t */\n', '\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\n', '\t\t\treturn bonusPercentage;\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus amount of network token on a given lot\n', '\t *\t\tAO Bonus Amount = B% x P\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial token intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial token intable\n', '\t * @param _totalPrimordialMinted Total Primordial token minted so far\n', '\t * @param _startingMultiplier The starting Network token bonus multiplier\n', '\t * @param _endingMultiplier The ending Network token bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkTokenBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tuint256 bonusPercentage = calculateNetworkTokenBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\n', '\t\t/**\n', '\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\n', '\t\t * when calculating the network token bonus amount\n', '\t\t */\n', '\t\tuint256 networkTokenBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\n', '\t\treturn networkTokenBonus;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the maximum amount of Primordial an account can burn\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_maximumMultiplier = S\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\tB = ((S x P) - (P x M)) / S\n', '\t *\n', '\t * @param _primordialBalance Account&#39;s primordial token balance\n', '\t * @param _currentWeightedMultiplier Account&#39;s current weighted multiplier\n', '\t * @param _maximumMultiplier The maximum multiplier of this account\n', '\t * @return The maximum burn amount\n', '\t */\n', '\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\n', '\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after burning primordial token\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P - B)\n', '\t *\n', '\t * @param _primordialBalance Account&#39;s primordial token balance\n', '\t * @param _currentWeightedMultiplier Account&#39;s current weighted multiplier\n', '\t * @param _amountToBurn The amount of primordial token to burn\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after converting network token to primordial token\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToConvert = C\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P + C)\n', '\t *\n', '\t * @param _primordialBalance Account&#39;s primordial token balance\n', '\t * @param _currentWeightedMultiplier Account&#39;s current weighted multiplier\n', '\t * @param _amountToConvert The amount of network token to convert\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get TAO Currency Balances given a nameId\n', '\t * @param _nameId The ID of the Name\n', '\t * @param _logosAddress The address of Logos\n', '\t * @param _ethosAddress The address of Ethos\n', '\t * @param _pathosAddress The address of Pathos\n', '\t * @return sum Logos balance of the Name ID\n', '\t * @return Ethos balance of the Name ID\n', '\t * @return Pathos balance of the Name ID\n', '\t */\n', '\tfunction getTAOCurrencyBalances(\n', '\t\taddress _nameId,\n', '\t\taddress _logosAddress,\n', '\t\taddress _ethosAddress,\n', '\t\taddress _pathosAddress\n', '\t) public view returns (uint256, uint256, uint256) {\n', '\t\treturn (\n', '\t\t\tLogos(_logosAddress).sumBalanceOf(_nameId),\n', '\t\t\tTAOCurrency(_ethosAddress).balanceOf(_nameId),\n', '\t\t\tTAOCurrency(_pathosAddress).balanceOf(_nameId)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the address that signed the data and nonce when validating signature\n', '\t * @param _callingContractAddress the address of the calling contract\n', '\t * @param _data the data that was signed\n', '\t * @param _nonce The signed uint256 nonce\n', '\t * @param _v part of the signature\n', '\t * @param _r part of the signature\n', '\t * @param _s part of the signature\n', '\t * @return the address that signed the message\n', '\t */\n', '\tfunction getValidateSignatureAddress(address _callingContractAddress, string _data, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', '\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _data, _nonce));\n', '\t\treturn ecrecover(_hash, _v, _r, _s);\n', '\t}\n', '\n', '\t/***** Internal Methods *****/\n', '\t/**\n', '\t * @dev Check whether the network token and/or primordial token is adequate to pay for the filesize\n', '\t * @param _treasuryAddress AO treasury contract address\n', '\t * @param _networkIntegerAmount The integer amount of network token to stake\n', '\t * @param _networkFractionAmount The fraction amount of network token to stake\n', '\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\n', '\t * @param _primordialAmount The amount of primordial Token to stake\n', '\t * @param _fileSize The size of the file\n', '\t * @return true when the amount is sufficient, false otherwise\n', '\t */\n', '\tfunction _stakeAmountValid(address _treasuryAddress, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount, uint256 _fileSize) internal view returns (bool) {\n', '\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) >= _fileSize;\n', '\t}\n', '}\n', '\n', '\n', 'contract Epiphany is TheAO {\n', '\tstring public what;\n', '\tstring public when;\n', '\tstring public why;\n', '\tstring public who;\n', '\taddress public where;\n', '\tstring public aSign;\n', '\tstring public logos;\n', '\n', '\tconstructor() public {\n', '\t\twhat = &#39;The AO&#39;;\n', '\t\twhen = &#39;January 6th, 2019 a.d, year 1 a.c. Epiphany. An appearance or manifestation especially of a divine being. An illuminating discovery, realization, or disclosure.&#39;;\n', '\t\twhy = &#39;To Hear, See, and Speak the Human inside Humanity.&#39;;\n', '\t\twho = &#39;You.  Set the world, Free. – Truth&#39;;\n', '\t\taSign = &#39;08e2c4e1ccf3bccfb3b8eef14679b28442649a2a733960661210a0b00d9c93bf&#39;;\n', '\t\tlogos = &#39;0920c6ab1848df83a332a21e8c9ec1a393e694c396b872aee053722d023e2a32&#39;;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set `where` value\n', '\t * @param _where The new value to be set\n', '\t */\n', '\tfunction setWhere(address _where) public onlyTheAO {\n', '\t\twhere = _where;\n', '\t}\n', '}']