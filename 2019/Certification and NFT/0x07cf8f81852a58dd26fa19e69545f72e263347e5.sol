['pragma solidity 0.5.9; // optimization enabled, runs: 10000, evm: constantinople\n', '\n', '\n', '/**\n', ' * @title HomeWork Interface (version 1) - EIP165 ID 0xe5399799\n', ' * @author 0age\n', ' * @notice Homework is a utility to find, share, and reuse "home" addresses for\n', ' * contracts. Anyone can work to find a new home address by searching for keys,\n', " * a 32-byte value with the first 20 bytes equal to the finder's calling address\n", " * (or derived by hashing an arbitrary 32-byte salt and the caller's address),\n", ' * and can then deploy any contract they like (even one with a constructor) to\n', ' * the address, or mint an ERC721 token that the owner can redeem that will then\n', ' * allow them to do the same. Also, if the contract is `SELFDESTRUCT`ed, a new\n', ' * contract can be redeployed by the current controller to the same address!\n', ' * @dev This contract allows contract addresses to be located ahead of time, and\n', ' * for arbitrary bytecode to be deployed (and redeployed if so desired, i.e.\n', ' * metamorphic contracts) to the located address by a designated controller. To\n', ' * enable this, the contract first deploys an "initialization-code-in-runtime"\n', ' * contract, with the creation code of the contract you want to deploy stored in\n', ' * RUNTIME code. Then, to deploy the actual contract, it retrieves the address\n', ' * of the storage contract and `DELEGATECALL`s into it to execute the init code\n', ' * and, if successful, retrieves and returns the contract runtime code. Rather\n', ' * than using a located address directly, you can also lock it in the contract\n', ' * and mint and ERC721 token for it, which can then be redeemed in order to gain\n', ' * control over deployment to the address (note that tokens may not be minted if\n', ' * the contract they control currently has a deployed contract at that address).\n', ' * Once a contract undergoes metamorphosis, all existing storage will be deleted\n', ' * and any existing contract code will be replaced with the deployed contract\n', ' * code of the new implementation contract. The mechanisms behind this contract \n', ' * are highly experimental - proceed with caution and please share any exploits\n', ' * or optimizations you discover.\n', ' */\n', 'interface IHomeWork {\n', '  // Fires when a contract is deployed or redeployed to a given home address.\n', '  event NewResident(\n', '    address indexed homeAddress,\n', '    bytes32 key,\n', '    bytes32 runtimeCodeHash\n', '  );\n', '\n', '  // Fires when a new runtime storage contract is deployed.\n', '  event NewRuntimeStorageContract(\n', '    address runtimeStorageContract,\n', '    bytes32 runtimeCodeHash\n', '  );\n', '\n', '  // Fires when a controller is changed from the default controller.\n', '  event NewController(bytes32 indexed key, address newController);\n', '\n', '  // Fires when a new high score is submitted.\n', '  event NewHighScore(bytes32 key, address submitter, uint256 score);\n', '\n', '  // Track total contract deploys and current controller for each home address.\n', '  struct HomeAddress {\n', '    bool exists;\n', '    address controller;\n', '    uint88 deploys;\n', '  }\n', '\n', '  // Track derivation of key for a given home address based on salt & submitter.\n', '  struct KeyInformation {\n', '    bytes32 key;\n', '    bytes32 salt;\n', '    address submitter;\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the desired initialization code to the\n', '   * home address corresponding to a given key. Two conditions must be met: the\n', '   * submitter must be designated as the controller of the home address (with\n', '   * the initial controller set to the address corresponding to the first twenty\n', '   * bytes of the key), and there must not be a contract currently deployed at\n', '   * the home address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address of the deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may also want to provide the\n', '   * key to `setReverseLookup` in order to find it again using only the home\n', '   * address to prevent accidentally losing the key.\n', '   */\n', '  function deploy(bytes32 key, bytes calldata initializationCode)\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\n', '   * order to gain control of a home address corresponding to a given key. Two\n', '   * conditions must be met: the submitter must be designated as the controller\n', '   * of the home address (with the initial controller set to the address\n', '   * corresponding to the first 20 bytes of the key), and there must not be a\n', '   * contract currently deployed at the home address. These conditions can be\n', '   * checked by calling `getHomeAddressInformation` and `isDeployable` with the\n', '   * same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 token.\n', '   * @dev In order to mint an ERC721 token, the assocated home address cannot be\n', '   * in use, or else the token will not be able to deploy to the home address.\n', '   * The controller is set to this contract until the token is redeemed, at\n', '   * which point the redeemer designates a new controller for the home address.\n', '   * The key of the home address and the tokenID of the ERC721 token are the\n', '   * same value, but different types (bytes32 vs. uint256).\n', '   */\n', '  function lock(bytes32 key, address owner) external;\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token to allow the supplied controller to gain the\n', '   * ability to deploy to the home address corresponding to the key matching the\n', '   * burned token. The submitter must be designated as either the owner of the\n', '   * token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function redeem(uint256 tokenId, address controller) external;\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given key. The caller must be designated as the current controller of\n', '   * the home address (with the initial controller set to the address\n', '   * corresponding to the first 20 bytes of the key) - This condition can be\n', '   * checked by calling `getHomeAddressInformation` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given key.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function assignController(bytes32 key, address controller) external;\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given key to the null address, which will prevent it from being\n', '   * deployed to again in the future. The caller must be designated as the\n', '   * current controller of the corresponding home address (with the initial\n', '   * controller set to the address corresponding to the first 20 bytes of the\n', '   * key) - This condition can be checked by calling `getHomeAddressInformation`\n', '   * with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  function relinquishControl(bytes32 key) external;\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\n', '   * contract with the supplied initialization code to the corresponding home\n', '   * address for the given token. The submitter must be designated as either the\n', '   * owner of the token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may also want to provide the\n', '   * key to `setReverseLookup` in order to find it again using only the home\n', '   * address to prevent accidentally losing the key. The controller cannot be\n', '   * designated as the address of this contract, the null address, or the home\n', '   * address (the restriction on setting the home address as the controller is\n', '   * due to the fact that the home address will not be able to deploy to itself,\n', '   * as it needs to be empty before a contract can be deployed to it). Also,\n', '   * checks on the contract at the home address being empty or not having the\n', '   * correct controller are unnecessary, as they are performed when minting the\n', '   * token and cannot be altered until the token is redeemed.\n', '   */\n', '  function redeemAndDeploy(\n', '    uint256 tokenId,\n', '    address controller,\n', '    bytes calldata initializationCode\n', '  )\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Derive a new key by concatenating an arbitrary 32-byte salt value\n', '   * and the address of the caller and performing a keccak256 hash. This allows\n', '   * for the creation of keys with additional entropy where desired while also\n', '   * preventing collisions with standard keys. The caller will be set as the\n', '   * controller of the derived key.\n', '   * @param salt bytes32 The desired salt value to use (along with the address\n', '   * of the caller) when deriving the resultant key and corresponding home\n', '   * address.\n', '   * @return The derived key.\n', '   * @dev Home addresses from derived keys will take longer to "mine" or locate,\n', '   * as an additional hash must be performed when computing the corresponding\n', '   * home address for each given salt input. Each caller will derive a different\n', '   * key even if they are supplying the same salt value.\n', '   */\n', '  function deriveKey(bytes32 salt) external returns (bytes32 key);\n', '\n', '  /**\n', '   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\n', '   * order to gain control of a home address corresponding to a given derived\n', '   * key. Two conditions must be met: the submitter must be designated as the\n', '   * current controller of the home address, and there must not be a contract\n', '   * currently deployed at the home address. These conditions can be checked by\n', '   * calling `getHomeAddressInformation` and `isDeployable` with the key\n', '   * determined by calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 token.\n', '   * @return The derived key.\n', '   * @dev In order to mint an ERC721 token, the assocated home address cannot be\n', '   * in use, or else the token will not be able to deploy to the home address.\n', '   * The controller is set to this contract until the token is redeemed, at\n', '   * which point the redeemer designates a new controller for the home address.\n', '   * The key of the home address and the tokenID of the ERC721 token are the\n', '   * same value, but different types (bytes32 vs. uint256).\n', '   */\n', '  function deriveKeyAndLock(bytes32 salt, address owner)\n', '    external\n', '    returns (bytes32 key);\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given derived key. The caller must be designated as the current\n', '   * controller of the home address - This condition can be checked by calling\n', '   * `getHomeAddressInformation` with the key obtained via `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given derived key.\n', '   * @return The derived key.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function deriveKeyAndAssignController(bytes32 salt, address controller)\n', '    external\n', '    returns (bytes32 key);\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given derived key to the null address, which will prevent it from\n', '   * being deployed to again in the future. The caller must be designated as the\n', '   * current controller of the home address - This condition can be checked by\n', '   * calling `getHomeAddressInformation` with the key determined by calling\n', '   * `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @return The derived key.\n', '   */\n', '  function deriveKeyAndRelinquishControl(bytes32 salt)\n', '    external\n', '    returns (bytes32 key);\n', '\n', '  /**\n', '   * @notice Record a key that corresponds to a given home address by supplying\n', '   * said key and using it to derive the address. This enables reverse lookup\n', '   * of a key using only the home address in question. This method may be called\n', '   * by anyone - control of the key is not required.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @dev This does not set the salt or submitter fields, as those apply only to\n', '   * derived keys (although a derived key may also be set with this method, just\n', '   * without the derived fields).\n', '   */\n', '  function setReverseLookup(bytes32 key) external;\n', '\n', '  /**\n', '   * @notice Record the derived key that corresponds to a given home address by\n', '   * supplying the salt and submitter that were used to derive the key. This\n', '   * facititates reverse lookup of the derivation method of a key using only the\n', '   * home address in question. This method may be called by anyone - control of\n', '   * the derived key is not required.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param submitter address The account that submits the salt that is used to\n', '   * derive the key.\n', '   */\n', '  function setDerivedReverseLookup(bytes32 salt, address submitter) external;\n', '\n', '  /**\n', '   * @notice Deploy a new storage contract with the supplied code as runtime\n', '   * code without deploying a contract to a home address. This can be used to\n', '   * store the contract creation code for use in future deployments of contracts\n', '   * to home addresses.\n', '   * @param codePayload bytes The code to set as the runtime code of the\n', '   * deployed contract.\n', '   * @return The address of the deployed storage contract.\n', '   * @dev Consider placing adequate protections on the storage contract to\n', '   * prevent unwanted callers from modifying or destroying it. Also, if you are\n', '   * placing contract contract creation code into the runtime storage contract,\n', '   * remember to include any constructor parameters as ABI-encoded arguments at\n', '   * the end of the contract creation code, similar to how you would perform a\n', '   * standard deployment.\n', '   */\n', '  function deployRuntimeStorageContract(bytes calldata codePayload)\n', '    external\n', '    returns (address runtimeStorageContract);\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the initialization code stored in the\n', '   * runtime code at the specified initialization runtime storage contract to\n', '   * the home address corresponding to a given key. Two conditions must be met:\n', '   * the submitter must be designated as the controller of the home address\n', '   * (with the initial controller set to the address corresponding to the first\n', '   * 20 bytes of the key), and there must not be a contract currently deployed\n', '   * at the home address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may also want to provide the key to\n', '   * `setReverseLookup` in order to find it again using only the home address to\n', '   * prevent accidentally losing the key.\n', '   */\n', '  function deployViaExistingRuntimeStorageContract(\n', '    bytes32 key,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\n', '   * contract with the initialization code stored in the runtime code at the\n', '   * specified initialization runtime storage contract to the home address\n', '   * corresponding to a given key. The submitter must be designated as either\n', '   * the owner of the token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may also want to provide the key to\n', '   * `setReverseLookup` in order to find it again using only the home address to\n', '   * prevent accidentally losing the key. The controller cannot be designated as\n', '   * the address of this contract, the null address, or the home address (the\n', '   * restriction on setting the home address as the controller is due to the\n', '   * fact that the home address will not be able to deploy to itself, as it\n', '   * needs to be empty before a contract can be deployed to it). Also, checks on\n', '   * the contract at the home address being empty or not having the correct\n', '   * controller are unnecessary, as they are performed when minting the token\n', '   * and cannot be altered until the token is redeemed.\n', '   */\n', '  function redeemAndDeployViaExistingRuntimeStorageContract(\n', '    uint256 tokenId,\n', '    address controller,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the desired initialization code to the\n', '   * home address corresponding to a given derived key. Two conditions must be\n', '   * met: the submitter must be designated as the controller of the home\n', '   * address, and there must not be a contract currently deployed at the home\n', '   * address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\n', '   * calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address, derived key, and runtime code hash of the\n', '   * deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may want to provide the salt\n', '   * and submitter to `setDerivedReverseLookup` in order to find the salt,\n', '   * submitter, and derived key using only the home address to prevent\n', '   * accidentally losing them.\n', '   */\n', '  function deriveKeyAndDeploy(bytes32 salt, bytes calldata initializationCode)\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the initialization code stored in the\n', '   * runtime code at the specified initialization runtime storage contract to\n', '   * the home address corresponding to a given derived key. Two conditions must\n', '   * be met: the submitter must be designated as the controller of the home\n', '   * address, and there must not be a contract currently deployed at the home\n', '   * address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\n', '   * calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address, derived key, and runtime code hash of the\n', '   * deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may want to provide the salt and\n', '   * submitter to `setDerivedReverseLookup` in order to find the salt,\n', '   * submitter, and derived key using only the home address to prevent\n', '   * accidentally losing them.\n', '   */\n', '  function deriveKeyAndDeployViaExistingRuntimeStorageContract(\n', '    bytes32 salt,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash);\n', '\n', '  /**\n', '   * @notice Mint multiple ERC721 tokens, designated by their keys, to the\n', "   * specified owner. Keys that aren't controlled, or that point to home\n", '   * addresses that are currently deployed, will be skipped.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 tokens.\n', '   * @param keys bytes32[] An array of values used to derive each home address.\n', '   * @dev If you plan to use this method regularly or want to keep gas costs to\n', '   * an absolute minimum, and are willing to go without standard ABI encoding,\n', '   * see `batchLock_63efZf` for a more efficient (and unforgiving)\n', '   * implementation. For batch token minting with *derived* keys, see\n', '   * `deriveKeysAndBatchLock`.\n', '   */\n', '  function batchLock(address owner, bytes32[] calldata keys) external;\n', '\n', '  /**\n', '   * @notice Mint multiple ERC721 tokens, designated by salts that are hashed\n', "   * with the caller's address to derive each key, to the specified owner.\n", "   * Derived keys that aren't controlled, or that point to home addresses that\n", '   * are currently deployed, will be skipped.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 tokens.\n', '   * @param salts bytes32[] An array of values used to derive each key and\n', '   * corresponding home address.\n', '   * @dev See `batchLock` for batch token minting with standard, non-derived\n', '   * keys.\n', '   */\n', '  function deriveKeysAndBatchLock(address owner, bytes32[] calldata salts)\n', '    external;\n', '\n', '  /**\n', '   * @notice Efficient version of `batchLock` that uses less gas. The first 20\n', '   * bytes of each key are automatically populated using msg.sender, and the\n', '   * remaining key segments are passed in as a packed byte array, using twelve\n', '   * bytes per segment, with a function selector of 0x00000000 followed by a\n', '   * twenty-byte segment for the desired owner of the minted ERC721 tokens. Note\n', '   * that an attempt to lock a key that is not controlled or with its contract\n', '   * already deployed will cause the entire batch to revert. Checks on whether\n', '   * the owner is a valid ERC721 receiver are also skipped, similar to using\n', '   * `transferFrom` instead of `safeTransferFrom`.\n', '   */\n', '  function batchLock_63efZf(/* packed owner and key segments */) external;\n', '\n', '  /**\n', '   * @notice Submit a key to claim the "high score" - the lower the uint160\n', "   * value of the key's home address, the higher the score. The high score\n", '   * holder has the exclusive right to recover lost ether and tokens on this\n', '   * contract.\n', '   * @param key bytes32 The unique value used to derive the home address that\n', '   * will determine the resultant score.\n', '   * @dev The high score must be claimed by a direct key (one that is submitted\n', '   * by setting the first 20 bytes of the key to the address of the submitter)\n', '   * and not by a derived key, and is non-transferrable. If you want to help\n', '   * people recover their lost tokens, you might consider deploying a contract\n', '   * to the high score address (probably a metamorphic one so that you can use\n', '   * the home address later) with your contact information.\n', '   */\n', '  function claimHighScore(bytes32 key) external;\n', '\n', '  /**\n', '   * @notice Transfer any ether or ERC20 tokens that have somehow ended up at\n', '   * this contract by specifying a token address (set to the null address for\n', '   * ether) as well as a recipient address. Only the high score holder can\n', '   * recover lost ether and tokens on this contract.\n', '   * @param token address The contract address of the ERC20 token to recover, or\n', '   * the null address for recovering Ether.\n', '   * @param recipient address payable The account where recovered funds should\n', '   * be transferred.\n', '   * @dev If you are trying to recover funds that were accidentally sent into\n', '   * this contract, see if you can contact the holder of the current high score,\n', '   * found by calling `getHighScore`. Better yet, try to find a new high score\n', '   * yourself!\n', '   */\n', '  function recover(IERC20 token, address payable recipient) external;\n', '\n', '  /**\n', '   * @notice "View" function to determine if a contract can currently be\n', '   * deployed to a home address given the corresponding key. A contract is only\n', '   * deployable if no account currently exists at the address - any existing\n', '   * contract must be destroyed via `SELFDESTRUCT` before a new contract can be\n', '   * deployed to a home address. This method does not modify state but is\n', '   * inaccessible via staticcall.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return A boolean signifying if a contract can be deployed to the home\n', '   * address that corresponds to the provided key.\n', '   * @dev This will not detect if a contract is not deployable due control\n', '   * having been relinquished on the key.\n', '   */\n', '  function isDeployable(bytes32 key)\n', '    external\n', '    /* view */\n', '    returns (bool deployable);\n', '\n', '  /**\n', '   * @notice View function to get the current "high score", or the lowest\n', '   * uint160 value of a home address of all keys submitted. The high score\n', '   * holder has the exclusive right to recover lost ether and tokens on this\n', '   * contract.\n', '   * @return The current high score holder, their score, and the submitted key.\n', '   */\n', '  function getHighScore()\n', '    external\n', '    view\n', '    returns (address holder, uint256 score, bytes32 key);\n', '\n', '  /**\n', '   * @notice View function to get information on a home address given the\n', '   * corresponding key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The home address, the current controller of the address, the number\n', '   * of times the home address has been deployed to, and the code hash of the\n', '   * runtime currently found at the home address, if any.\n', '   * @dev There is also an `isDeployable` method for determining if a contract\n', '   * can be deployed to the address, but in extreme cases it must actually\n', '   * perform a dry-run to determine if the contract is deployable, which means\n', '   * that it does not support staticcalls. There is also a convenience method,\n', '   * `hasNeverBeenDeployed`, but the information it conveys can be determined\n', '   * from this method alone as well.\n', '   */\n', '  function getHomeAddressInformation(bytes32 key)\n', '    external\n', '    view\n', '    returns (\n', '      address homeAddress,\n', '      address controller,\n', '      uint256 deploys,\n', '      bytes32 currentRuntimeCodeHash\n', '    );\n', '\n', '  /**\n', '   * @notice View function to determine if no contract has ever been deployed to\n', '   * a home address given the corresponding key. This can be used to ensure that\n', '   * a given key or corresponding token is "new" or not.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return A boolean signifying if a contract has never been deployed using\n', '   * the supplied key before.\n', '   */\n', '  function hasNeverBeenDeployed(bytes32 key)\n', '    external\n', '    view\n', '    returns (bool neverBeenDeployed);\n', '\n', '  /**\n', '   * @notice View function to search for a known key, salt, and/or submitter\n', '   * given a supplied home address. Keys can be controlled directly by an\n', '   * address that matches the first 20 bytes of the key, or they can be derived\n', '   * from a salt and a submitter - if the key is not a derived key, the salt and\n', '   * submitter fields will both have a value of zero.\n', '   * @param homeAddress address The home address to check for key information.\n', '   * @return The key, salt, and/or submitter used to deploy to the home address,\n', '   * assuming they have been submitted to the reverse lookup.\n', '   * @dev To populate these values, call `setReverseLookup` for cases where keys\n', '   * are used directly or are the only value known, or `setDerivedReverseLookup`\n', '   * for cases where keys are derived from a known salt and submitter.\n', '   */\n', '  function reverseLookup(address homeAddress)\n', '    external\n', '    view\n', '    returns (bytes32 key, bytes32 salt, address submitter);\n', '\n', '  /**\n', '   * @notice Pure function to determine the key that is derived from a given\n', '   * salt and submitting address.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param submitter address The submitter of the salt value used to derive the\n', '   * key.\n', '   * @return The derived key.\n', '   */\n', '  function getDerivedKey(bytes32 salt, address submitter)\n', '    external\n', '    pure\n', '    returns (bytes32 key);\n', '\n', '  /**\n', '   * @notice Pure function to determine the home address that corresponds to\n', '   * a given key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The home address.\n', '   */\n', '  function getHomeAddress(bytes32 key)\n', '    external\n', '    pure\n', '    returns (address homeAddress);\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the metamorphic initialization code\n', '   * used to deploy arbitrary contracts to home addresses. Provided for easy\n', '   * verification and for use in other applications.\n', '   * @return The 32-byte metamorphic initialization code.\n', '   * @dev This metamorphic init code works via the "metamorphic delegator"\n', '   * mechanism, which is explained in greater detail at `_deployToHomeAddress`.\n', '   */\n', '  function getMetamorphicDelegatorInitializationCode()\n', '    external\n', '    pure\n', '    returns (bytes32 metamorphicDelegatorInitializationCode);\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the keccak256 of the metamorphic\n', '   * initialization code used to deploy arbitrary contracts to home addresses.\n', "   * This is the value that you should use, along with this contract's address\n", '   * and a caller address that you control, to mine for an partucular type of\n', '   * home address (such as one at a compact or gas-efficient address).\n', '   * @return The keccak256 hash of the metamorphic initialization code.\n', '   */\n', '  function getMetamorphicDelegatorInitializationCodeHash()\n', '    external\n', '    pure\n', '    returns (bytes32 metamorphicDelegatorInitializationCodeHash);\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the prelude that will be inserted\n', '   * ahead of the code payload in order to deploy a runtime storage contract.\n', '   * @return The 11-byte "arbitrary runtime" prelude.\n', '   */\n', '  function getArbitraryRuntimeCodePrelude()\n', '    external\n', '    pure\n', '    returns (bytes11 prelude);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata {\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n', '      external\n', '      returns (bytes4);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC1412 Batch Transfers For Non-Fungible Tokens\n', ' * @dev the ERC-165 identifier for this interface is 0x2b89bcaa\n', ' */\n', 'interface IERC1412 {\n', '  /// @notice Transfers the ownership of multiple NFTs from one address to another address\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenIds The NFTs to transfer\n', '  /// @param _data Additional data with no specified format, sent in call to `_to`  \n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds, bytes calldata _data) external;\n', '  \n', '  /// @notice Transfers the ownership of multiple NFTs from one address to another address\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenIds The NFTs to transfer  \n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds) external; \n', '}\n', '\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://eips.ethereum.org/EIPS/eip-165\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Counters\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', ' * of elements in a mapping, issuing ERC721 ids, or counting request ids\n', ' *\n', ' * Include with `using Counters for Counters.Counter;`\n', ' * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n', ' * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', ' * directly accessed.\n', ' */\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of the `IERC165` interface.\n', ' *\n', ' * Contracts may inherit from this and call `_registerInterface` to declare\n', ' * their support of an interface.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        // Derived contracts need only register support for their own interfaces,\n', '        // we register support for ERC165 itself here\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC165.supportsInterface`.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev Registers the contract as an implementer of the interface defined by\n', '     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n', '     * registering its interface id is not required.\n', '     *\n', '     * See `IERC165.supportsInterface`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using Counters for Counters.Counter;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => Counters.Counter) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner].current();\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return bool whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     * is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to].increment();\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner);\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner].decrement();\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from].decrement();\n', '        _ownedTokensCount[to].increment();\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    /*\n', "     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n", "     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n", '     *\n', '     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '    /**\n', '     * @dev Constructor function.\n', '     */\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721Enumerable via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n', '     * @param owner address owning the tokens list to be accessed\n', '     * @param index uint256 representing the index to be accessed of the requested tokens list\n', '     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the total amount of tokens stored by the contract.\n', '     * @return uint256 representing the total amount of tokens\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of all the tokens in this contract\n', '     * Reverts if the index is greater or equal to the total number of tokens.\n', '     * @param index uint256 representing the index to be accessed of the tokens list\n', '     * @return uint256 token ID at the given index of the tokens list\n', '     */\n', '    function tokenByIndex(uint256 index) public view returns (uint256) {\n', '        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token.\n', '     * Reverts if the given token ID already exists.\n', '     * @param to address the beneficiary that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token.\n', '     * Reverts if the token does not exist.\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        _ownedTokens[from].length--;\n', '\n', "        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n", '        // lastTokenId, or just over the end of the array if the token was the last one).\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        _allTokens.length--;\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title HomeWork (version 1)\n', ' * @author 0age\n', ' * @notice Homework is a utility to find, share, and reuse "home" addresses for\n', ' * contracts. Anyone can work to find a new home address by searching for keys,\n', " * a 32-byte value with the first 20 bytes equal to the finder's calling address\n", " * (or derived by hashing an arbitrary 32-byte salt and the caller's address),\n", ' * and can then deploy any contract they like (even one with a constructor) to\n', ' * the address, or mint an ERC721 token that the owner can redeem that will then\n', ' * allow them to do the same. Also, if the contract is `SELFDESTRUCT`ed, a new\n', ' * contract can be redeployed by the current controller to the same address!\n', ' * @dev This contract allows contract addresses to be located ahead of time, and\n', ' * for arbitrary bytecode to be deployed (and redeployed if so desired, i.e.\n', ' * metamorphic contracts) to the located address by a designated controller. To\n', ' * enable this, the contract first deploys an "initialization-code-in-runtime"\n', ' * contract, with the creation code of the contract you want to deploy stored in\n', ' * RUNTIME code. Then, to deploy the actual contract, it retrieves the address\n', ' * of the storage contract and `DELEGATECALL`s into it to execute the init code\n', ' * and, if successful, retrieves and returns the contract runtime code. Rather\n', ' * than using a located address directly, you can also lock it in the contract\n', ' * and mint and ERC721 token for it, which can then be redeemed in order to gain\n', ' * control over deployment to the address (note that tokens may not be minted if\n', ' * the contract they control currently has a deployed contract at that address).\n', ' * Once a contract undergoes metamorphosis, all existing storage will be deleted\n', ' * and any existing contract code will be replaced with the deployed contract\n', ' * code of the new implementation contract. The mechanisms behind this contract \n', ' * are highly experimental - proceed with caution and please share any exploits\n', ' * or optimizations you discover.\n', ' */\n', 'contract HomeWork is IHomeWork, ERC721Enumerable, IERC721Metadata, IERC1412 {\n', '  // Allocate storage to track the current initialization-in-runtime contract.\n', '  address private _initializationRuntimeStorageContract;\n', '\n', '  // Finder of home address with lowest uint256 value can recover lost funds.\n', '  bytes32 private _highScoreKey;\n', '\n', '  // Track information on the Home address corresponding to each key.\n', '  mapping (bytes32 => HomeAddress) private _home;\n', '\n', '  // Provide optional reverse-lookup for key derivation of a given home address.\n', '  mapping (address => KeyInformation) private _key;\n', '\n', '  // Set 0xff + address(this) as a constant to use when deriving home addresses.\n', '  bytes21 private constant _FF_AND_THIS_CONTRACT = bytes21(\n', '    0xff0000000000001b84b1cb32787B0D64758d019317\n', '  );\n', '\n', '  // Set the address of the tokenURI runtime storage contract as a constant.\n', '  address private constant _URI_END_SEGMENT_STORAGE = address(\n', '    0x000000000071C1c84915c17BF21728BfE4Dac3f3\n', '  );\n', '\n', '  // Deploy arbitrary contracts to home addresses using metamorphic init code.\n', '  bytes32 private constant _HOME_INIT_CODE = bytes32(\n', '    0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '  );\n', '\n', '  // Compute hash of above metamorphic init code in order to compute addresses.\n', '  bytes32 private constant _HOME_INIT_CODE_HASH = bytes32(\n', '    0x7816562e7f85866cae07183593075f3b5ec32aeff914a0693e20aaf39672babc\n', '  );\n', '\n', "  // Write arbitrary code to a contract's runtime using the following prelude.\n", '  bytes11 private constant _ARBITRARY_RUNTIME_PRELUDE = bytes11(\n', '    0x600b5981380380925939f3\n', '  );\n', '\n', '  // Set EIP165 interface IDs as constants (already set 165 and 721+enumerable).\n', '  bytes4 private constant _INTERFACE_ID_HOMEWORK = 0xe5399799;\n', '  /* this.deploy.selector ^ this.lock.selector ^ this.redeem.selector ^\n', '     this.assignController.selector ^ this.relinquishControl.selector ^\n', '     this.redeemAndDeploy.selector ^ this.deriveKey.selector ^\n', '     this.deriveKeyAndLock.selector ^\n', '     this.deriveKeyAndAssignController.selector ^\n', '     this.deriveKeyAndRelinquishControl.selector ^\n', '     this.setReverseLookup.selector ^ this.setDerivedReverseLookup.selector ^\n', '     this.deployRuntimeStorageContract.selector ^\n', '     this.deployViaExistingRuntimeStorageContract.selector ^\n', '     this.redeemAndDeployViaExistingRuntimeStorageContract.selector ^\n', '     this.deriveKeyAndDeploy.selector ^\n', '     this.deriveKeyAndDeployViaExistingRuntimeStorageContract.selector ^\n', '     this.batchLock.selector ^ this.deriveKeysAndBatchLock.selector ^\n', '     this.batchLock_63efZf.selector ^ this.claimHighScore.selector ^\n', '     this.recover.selector ^ this.isDeployable.selector ^\n', '     this.getHighScore.selector ^ this.getHomeAddressInformation.selector ^\n', '     this.hasNeverBeenDeployed.selector ^ this.reverseLookup.selector ^\n', '     this.getDerivedKey.selector ^ this.getHomeAddress.selector ^\n', '     this.getMetamorphicDelegatorInitializationCode.selector ^\n', '     this.getMetamorphicDelegatorInitializationCodeHash.selector ^\n', '     this.getArbitraryRuntimeCodePrelude.selector == 0xe5399799\n', '  */\n', '\n', '  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '  bytes4 private constant _INTERFACE_ID_ERC1412_BATCH_TRANSFERS = 0x2b89bcaa;\n', '\n', '  // Set name of this contract as a constant (hex encoding is to support emoji).\n', '  string private constant _NAME = (\n', '    hex"486f6d65576f726b20f09f8fa0f09f9ba0efb88f"\n', '  );\n', '\n', '  // Set symbol of this contract as a constant.\n', '  string private constant _SYMBOL = "HWK";\n', '\n', '  // Set the start of each token URI for issued ERC721 tokens as a constant.\n', '  bytes private constant _URI_START_SEGMENT = abi.encodePacked(\n', '    hex"646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a22486f6d65",\n', '    hex"253230416464726573732532302d2532303078"\n', '  ); /* data:application/json,{"name":"Home%20Address%20-%200x */\n', '\n', '  // Store reused revert messages as constants.\n', '  string private constant _ACCOUNT_EXISTS = string(\n', '    "Only non-existent accounts can be deployed or used to mint tokens."\n', '  );\n', '\n', '  string private constant _ONLY_CONTROLLER = string(\n', '    "Only the designated controller can call this function."\n', '  );\n', '\n', '  string private constant _NO_INIT_CODE_SUPPLIED = string(\n', '    "Cannot deploy a contract with no initialization code supplied."\n', '  );\n', '\n', '  /**\n', '   * @notice In the constructor, verify that deployment addresses are correct\n', '   * and that supplied constant hash value of the contract creation code used to\n', '   * deploy arbitrary contracts to home addresses is valid, and set an initial\n', '   * high score key with the null address as the high score "holder". ERC165\n', '   * supported interfaces are all registered during initizialization as well.\n', '   */\n', '  constructor() public {\n', '    // Verify that the deployment address is set correctly as a constant.\n', '    assert(address(this) == address(uint160(uint168(_FF_AND_THIS_CONTRACT))));\n', '\n', '    // Verify the derivation of the deployment address.\n', '    bytes32 initialDeployKey = bytes32(\n', '      0x486f6d65576f726b20f09f8fa0f09f9ba0efb88faa3c548a76f9bd3c000c0000\n', '    );    \n', '    assert(address(this) == address(\n', '      uint160(                      // Downcast to match the address type.\n', '        uint256(                    // Convert to uint to truncate upper digits.\n', '          keccak256(                // Compute the CREATE2 hash using 4 inputs.\n', '            abi.encodePacked(       // Pack all inputs to the hash together.\n', '              bytes1(0xff),         // Start with 0xff to distinguish from RLP.\n', '              msg.sender,           // The deployer will be the caller.\n', '              initialDeployKey,     // Pass in the supplied key as the salt.\n', '              _HOME_INIT_CODE_HASH  // The metamorphic initialization code hash.\n', '            )\n', '          )\n', '        )\n', '      )\n', '    ));\n', '\n', '    // Verify the derivation of the tokenURI runtime storage address.\n', '    bytes32 uriDeployKey = bytes32(\n', '      0x486f6d65576f726b202d20746f6b656e55524920c21352fee5a62228db000000\n', '    );\n', '    bytes32 uriInitCodeHash = bytes32(\n', '      0xdea98294867e3fdc48eb5975ecc53a79e2e1ea6e7e794137a9c34c4dd1565ba2\n', '    );\n', '    assert(_URI_END_SEGMENT_STORAGE == address(\n', '      uint160(                      // Downcast to match the address type.\n', '        uint256(                    // Convert to uint to truncate upper digits.\n', '          keccak256(                // Compute the CREATE2 hash using 4 inputs.\n', '            abi.encodePacked(       // Pack all inputs to the hash together.\n', '              bytes1(0xff),         // Start with 0xff to distinguish from RLP.\n', '              msg.sender,           // The deployer will be the caller.\n', '              uriDeployKey,         // Pass in the supplied key as the salt.\n', '              uriInitCodeHash       // The storage contract init code hash.\n', '            )\n', '          )\n', '        )\n', '      )\n', '    ));\n', '\n', '    // Verify that the correct runtime code is at the tokenURI storage contract.\n', '    bytes32 expectedRuntimeStorageHash = bytes32(\n', '      0x8834602968080bb1df9c44c9834c0a93533b72bbfa3865ee2c5be6a0c4125fc3\n', '    );\n', '    address runtimeStorage = _URI_END_SEGMENT_STORAGE;\n', '    bytes32 runtimeStorageHash;\n', '    assembly { runtimeStorageHash := extcodehash(runtimeStorage) }\n', '    assert(runtimeStorageHash == expectedRuntimeStorageHash);\n', '\n', '    // Verify that the supplied hash for the metamorphic init code is valid.\n', '    assert(keccak256(abi.encode(_HOME_INIT_CODE)) == _HOME_INIT_CODE_HASH);\n', '\n', '    // Set an initial high score key with the null address as the submitter.\n', '    _highScoreKey = bytes32(\n', '      0x0000000000000000000000000000000000000000ffffffffffffffffffffffff\n', '    );\n', '\n', '    // Register EIP165 interface for HomeWork.\n', '    _registerInterface(_INTERFACE_ID_HOMEWORK);\n', '\n', '    // Register EIP165 interface for ERC721 metadata.\n', '    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '\n', '    // Register EIP165 interface for ERC1412 (batch transfers).\n', '    _registerInterface(_INTERFACE_ID_ERC1412_BATCH_TRANSFERS);\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the desired initialization code to the\n', '   * home address corresponding to a given key. Two conditions must be met: the\n', '   * submitter must be designated as the controller of the home address (with\n', '   * the initial controller set to the address corresponding to the first twenty\n', '   * bytes of the key), and there must not be a contract currently deployed at\n', '   * the home address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address of the deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may also want to provide the\n', '   * key to `setReverseLookup` in order to find it again using only the home\n', '   * address to prevent accidentally losing the key.\n', '   */\n', '  function deploy(bytes32 key, bytes calldata initializationCode)\n', '    external\n', '    payable\n', '    onlyEmpty(key)\n', '    onlyControllerDeployer(key)\n', '    returns (address homeAddress, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that initialization code was supplied.\n', '    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\n', '\n', '    // Deploy the initialization storage contract and set address in storage.\n', '    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\n', '      initializationCode\n', '    );\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\n', '   * order to gain control of a home address corresponding to a given key. Two\n', '   * conditions must be met: the submitter must be designated as the controller\n', '   * of the home address (with the initial controller set to the address\n', '   * corresponding to the first 20 bytes of the key), and there must not be a\n', '   * contract currently deployed at the home address. These conditions can be\n', '   * checked by calling `getHomeAddressInformation` and `isDeployable` with the\n', '   * same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 token.\n', '   * @dev In order to mint an ERC721 token, the assocated home address cannot be\n', '   * in use, or else the token will not be able to deploy to the home address.\n', '   * The controller is set to this contract until the token is redeemed, at\n', '   * which point the redeemer designates a new controller for the home address.\n', '   * The key of the home address and the tokenID of the ERC721 token are the\n', '   * same value, but different types (bytes32 vs. uint256).\n', '   */\n', '  function lock(bytes32 key, address owner)\n', '    external\n', '    onlyEmpty(key)\n', '    onlyController(key)\n', '  {\n', '    // Ensure that the specified owner is a valid ERC721 receiver.\n', '    _validateOwner(owner, key);\n', '\n', '    // Get the HomeAddress storage struct from the mapping using supplied key.\n', '    HomeAddress storage home = _home[key];\n', '\n', '    // Set the exists flag to true and the controller to this contract.\n', '    home.exists = true;\n', '    home.controller = address(this);\n', '\n', '    // Emit an event signifying that this contract is now the controller. \n', '    emit NewController(key, address(this));\n', '\n', '    // Mint the ERC721 token to the designated owner.\n', '    _mint(owner, uint256(key));\n', '  }\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token to allow the supplied controller to gain the\n', '   * ability to deploy to the home address corresponding to the key matching the\n', '   * burned token. The submitter must be designated as either the owner of the\n', '   * token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function redeem(uint256 tokenId, address controller)\n', '    external\n', '    onlyTokenOwnerOrApprovedSpender(tokenId)\n', '  {\n', '    // Convert the token ID to a bytes32 key.\n', '    bytes32 key = bytes32(tokenId);\n', '\n', '    // Prevent the controller from being set to prohibited account values.\n', '    _validateController(controller, key);\n', '\n', '    // Burn the ERC721 token in question.\n', '    _burn(tokenId);\n', '\n', '    // Assign the new controller to the corresponding home address.\n', '    _home[key].controller = controller;\n', '\n', '    // Emit an event with the new controller. \n', '    emit NewController(key, controller);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given key. The caller must be designated as the current controller of\n', '   * the home address (with the initial controller set to the address\n', '   * corresponding to the first 20 bytes of the key) - This condition can be\n', '   * checked by calling `getHomeAddressInformation` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given key.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function assignController(bytes32 key, address controller)\n', '    external\n', '    onlyController(key)\n', '  {\n', '    // Prevent the controller from being set to prohibited account values.\n', '    _validateController(controller, key);\n', '\n', '    // Assign the new controller to the corresponding home address.\n', '    HomeAddress storage home = _home[key];\n', '    home.exists = true;\n', '    home.controller = controller;\n', '\n', '    // Emit an event with the new controller. \n', '    emit NewController(key, controller);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given key to the null address, which will prevent it from being\n', '   * deployed to again in the future. The caller must be designated as the\n', '   * current controller of the corresponding home address (with the initial\n', '   * controller set to the address corresponding to the first 20 bytes of the\n', '   * key) - This condition can be checked by calling `getHomeAddressInformation`\n', '   * with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  function relinquishControl(bytes32 key)\n', '    external\n', '    onlyController(key)\n', '  {\n', '    // Assign the null address as the controller of the given key.\n', '    HomeAddress storage home = _home[key];\n', '    home.exists = true;\n', '    home.controller = address(0);\n', '\n', '    // Emit an event with the null address as the controller. \n', '    emit NewController(key, address(0));\n', '  }\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\n', '   * contract with the supplied initialization code to the corresponding home\n', '   * address for the given token. The submitter must be designated as either the\n', '   * owner of the token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may also want to provide the\n', '   * key to `setReverseLookup` in order to find it again using only the home\n', '   * address to prevent accidentally losing the key. The controller cannot be\n', '   * designated as the address of this contract, the null address, or the home\n', '   * address (the restriction on setting the home address as the controller is\n', '   * due to the fact that the home address will not be able to deploy to itself,\n', '   * as it needs to be empty before a contract can be deployed to it). Also,\n', '   * checks on the contract at the home address being empty or not having the\n', '   * correct controller are unnecessary, as they are performed when minting the\n', '   * token and cannot be altered until the token is redeemed.\n', '   */\n', '  function redeemAndDeploy(\n', '    uint256 tokenId,\n', '    address controller,\n', '    bytes calldata initializationCode\n', '  )\n', '    external\n', '    payable\n', '    onlyTokenOwnerOrApprovedSpender(tokenId)\n', '    returns (address homeAddress, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that initialization code was supplied.\n', '    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\n', '\n', '    // Convert the token ID to a bytes32 key.\n', '    bytes32 key = bytes32(tokenId);\n', '\n', '    // Prevent the controller from being set to prohibited account values.\n', '    _validateController(controller, key);\n', '\n', '    // Burn the ERC721 token in question.\n', '    _burn(tokenId);\n', '\n', '    // Deploy the initialization storage contract and set address in storage.\n', '    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\n', '      initializationCode\n', '    );\n', '\n', '    // Set provided controller and increment contract deploy count at once.\n', '    HomeAddress storage home = _home[key];\n', '    home.exists = true;\n', '    home.controller = controller;\n', '    home.deploys += 1;\n', '\n', '    // Emit an event with the new controller. \n', '    emit NewController(key, controller);\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Derive a new key by concatenating an arbitrary 32-byte salt value\n', '   * and the address of the caller and performing a keccak256 hash. This allows\n', '   * for the creation of keys with additional entropy where desired while also\n', '   * preventing collisions with standard keys. The caller will be set as the\n', '   * controller of the derived key.\n', '   * @param salt bytes32 The desired salt value to use (along with the address\n', '   * of the caller) when deriving the resultant key and corresponding home\n', '   * address.\n', '   * @return The derived key.\n', '   * @dev Home addresses from derived keys will take longer to "mine" or locate,\n', '   * as an additional hash must be performed when computing the corresponding\n', '   * home address for each given salt input. Each caller will derive a different\n', '   * key even if they are supplying the same salt value.\n', '   */\n', '  function deriveKey(bytes32 salt) external returns (bytes32 key) {\n', '    // Derive the key using the supplied salt and the calling address.\n', '    key = _deriveKey(salt, msg.sender);\n', '\n', '    // Register key and set caller as controller if it is not yet registered.\n', '    HomeAddress storage home = _home[key];\n', '    if (!home.exists) {\n', '      home.exists = true;\n', '      home.controller = msg.sender;\n', '\n', '      // Emit an event with the sender as the new controller. \n', '      emit NewController(key, msg.sender);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\n', '   * order to gain control of a home address corresponding to a given derived\n', '   * key. Two conditions must be met: the submitter must be designated as the\n', '   * current controller of the home address, and there must not be a contract\n', '   * currently deployed at the home address. These conditions can be checked by\n', '   * calling `getHomeAddressInformation` and `isDeployable` with the key\n', '   * determined by calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 token.\n', '   * @return The derived key.\n', '   * @dev In order to mint an ERC721 token, the assocated home address cannot be\n', '   * in use, or else the token will not be able to deploy to the home address.\n', '   * The controller is set to this contract until the token is redeemed, at\n', '   * which point the redeemer designates a new controller for the home address.\n', '   * The key of the home address and the tokenID of the ERC721 token are the\n', '   * same value, but different types (bytes32 vs. uint256).\n', '   */\n', '  function deriveKeyAndLock(bytes32 salt, address owner)\n', '    external\n', '    returns (bytes32 key)\n', '  {\n', '    // Derive the key using the supplied salt and the calling address.\n', '    key = _deriveKey(salt, msg.sender);\n', '\n', '    // Ensure that the specified owner is a valid ERC721 receiver.\n', '    _validateOwner(owner, key);\n', '\n', '    // Ensure that a contract is not currently deployed to the home address.\n', '    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\n', '\n', '    // Ensure that the caller is the controller of the derived key.\n', '    HomeAddress storage home = _home[key];\n', '    if (home.exists) {\n', '      require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '    }\n', '\n', '    // Set the exists flag to true and the controller to this contract.\n', '    home.exists = true;\n', '    home.controller = address(this);\n', '\n', '    // Mint the ERC721 token to the designated owner.\n', '    _mint(owner, uint256(key));\n', '\n', '    // Emit an event signifying that this contract is now the controller. \n', '    emit NewController(key, address(this));\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given derived key. The caller must be designated as the current\n', '   * controller of the home address - This condition can be checked by calling\n', '   * `getHomeAddressInformation` with the key obtained via `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given derived key.\n', '   * @return The derived key.\n', '   * @dev The controller cannot be designated as the address of this contract,\n', '   * the null address, or the home address (the restriction on setting the home\n', '   * address as the controller is due to the fact that the home address will not\n', '   * be able to deploy to itself, as it needs to be empty before a contract can\n', '   * be deployed to it).\n', '   */\n', '  function deriveKeyAndAssignController(bytes32 salt, address controller)\n', '    external\n', '    returns (bytes32 key)\n', '  {\n', '    // Derive the key using the supplied salt and the calling address.\n', '    key = _deriveKey(salt, msg.sender);\n', '\n', '    // Prevent the controller from being set to prohibited account values.\n', '    _validateController(controller, key);\n', '\n', '    // Ensure that the caller is the controller of the derived key.\n', '    HomeAddress storage home = _home[key];\n', '    if (home.exists) {\n', '      require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '    }\n', '\n', '    // Assign the new controller to the corresponding home address.\n', '    home.exists = true;\n', '    home.controller = controller;\n', '\n', '    // Emit an event with the new controller. \n', '    emit NewController(key, controller);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer control over deployment to the home address corresponding\n', '   * to a given derived key to the null address, which will prevent it from\n', '   * being deployed to again in the future. The caller must be designated as the\n', '   * current controller of the home address - This condition can be checked by\n', '   * calling `getHomeAddressInformation` with the key determined by calling\n', '   * `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @return The derived key.\n', '   */\n', '  function deriveKeyAndRelinquishControl(bytes32 salt)\n', '    external\n', '    returns (bytes32 key)\n', '  {\n', '    // Derive the key using the supplied salt and the calling address.\n', '    key = _deriveKey(salt, msg.sender);\n', '\n', '    // Ensure that the caller is the controller of the derived key.\n', '    HomeAddress storage home = _home[key];\n', '    if (home.exists) {\n', '      require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '    }\n', '\n', '    // Assign the null address as the controller of the given derived key.\n', '    home.exists = true;\n', '    home.controller = address(0);\n', '\n', '    // Emit an event with the null address as the controller. \n', '    emit NewController(key, address(0));\n', '  }\n', '\n', '  /**\n', '   * @notice Record a key that corresponds to a given home address by supplying\n', '   * said key and using it to derive the address. This enables reverse lookup\n', '   * of a key using only the home address in question. This method may be called\n', '   * by anyone - control of the key is not required.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @dev This does not set the salt or submitter fields, as those apply only to\n', '   * derived keys (although a derived key may also be set with this method, just\n', '   * without the derived fields).\n', '   */\n', '  function setReverseLookup(bytes32 key) external {\n', '    // Derive home address of given key and set home address and key in mapping.\n', '    _key[_getHomeAddress(key)].key = key;\n', '  }\n', '\n', '  /**\n', '   * @notice Record the derived key that corresponds to a given home address by\n', '   * supplying the salt and submitter that were used to derive the key. This\n', '   * facititates reverse lookup of the derivation method of a key using only the\n', '   * home address in question. This method may be called by anyone - control of\n', '   * the derived key is not required.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param submitter address The account that submits the salt that is used to\n', '   * derive the key.\n', '   */\n', '  function setDerivedReverseLookup(bytes32 salt, address submitter) external {\n', '    // Derive the key using the supplied salt and submitter.\n', '    bytes32 key = _deriveKey(salt, submitter);\n', '\n', '    // Derive home address and set it along with all other relevant information.\n', '    _key[_getHomeAddress(key)] = KeyInformation({\n', '      key: key,\n', '      salt: salt,\n', '      submitter: submitter\n', '    });\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new storage contract with the supplied code as runtime\n', '   * code without deploying a contract to a home address. This can be used to\n', '   * store the contract creation code for use in future deployments of contracts\n', '   * to home addresses.\n', '   * @param codePayload bytes The code to set as the runtime code of the\n', '   * deployed contract.\n', '   * @return The address of the deployed storage contract.\n', '   * @dev Consider placing adequate protections on the storage contract to\n', '   * prevent unwanted callers from modifying or destroying it. Also, if you are\n', '   * placing contract contract creation code into the runtime storage contract,\n', '   * remember to include any constructor parameters as ABI-encoded arguments at\n', '   * the end of the contract creation code, similar to how you would perform a\n', '   * standard deployment.\n', '   */\n', '  function deployRuntimeStorageContract(bytes calldata codePayload)\n', '    external\n', '    returns (address runtimeStorageContract)\n', '  {\n', '    // Ensure that a code payload was supplied.\n', '    require(codePayload.length > 0, "No runtime code payload supplied.");\n', '\n', '    // Deploy payload to the runtime storage contract and return the address.\n', '    runtimeStorageContract = _deployRuntimeStorageContract(codePayload);\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the initialization code stored in the\n', '   * runtime code at the specified initialization runtime storage contract to\n', '   * the home address corresponding to a given key. Two conditions must be met:\n', '   * the submitter must be designated as the controller of the home address\n', '   * (with the initial controller set to the address corresponding to the first\n', '   * 20 bytes of the key), and there must not be a contract currently deployed\n', '   * at the home address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the same key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may also want to provide the key to\n', '   * `setReverseLookup` in order to find it again using only the home address to\n', '   * prevent accidentally losing the key.\n', '   */\n', '  function deployViaExistingRuntimeStorageContract(\n', '    bytes32 key,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    onlyEmpty(key)\n', '    onlyControllerDeployer(key)\n', '    returns (address homeAddress, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that the supplied runtime storage contract is not empty.\n', '    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\n', '\n', '    // Set initialization runtime storage contract address in contract storage.\n', '    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\n', '   * contract with the initialization code stored in the runtime code at the\n', '   * specified initialization runtime storage contract to the home address\n', '   * corresponding to a given key. The submitter must be designated as either\n', '   * the owner of the token or as an approved spender.\n', '   * @param tokenId uint256 The ID of the ERC721 token to redeem.\n', '   * @param controller address The account that will be granted control of the\n', '   * home address corresponding to the given token.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address and runtime code hash of the deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may also want to provide the key to\n', '   * `setReverseLookup` in order to find it again using only the home address to\n', '   * prevent accidentally losing the key. The controller cannot be designated as\n', '   * the address of this contract, the null address, or the home address (the\n', '   * restriction on setting the home address as the controller is due to the\n', '   * fact that the home address will not be able to deploy to itself, as it\n', '   * needs to be empty before a contract can be deployed to it). Also, checks on\n', '   * the contract at the home address being empty or not having the correct\n', '   * controller are unnecessary, as they are performed when minting the token\n', '   * and cannot be altered until the token is redeemed.\n', '   */\n', '  function redeemAndDeployViaExistingRuntimeStorageContract(\n', '    uint256 tokenId,\n', '    address controller,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    onlyTokenOwnerOrApprovedSpender(tokenId)\n', '    returns (address homeAddress, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that the supplied runtime storage contract is not empty.\n', '    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\n', '\n', '    // Convert the token ID to a bytes32 key.\n', '    bytes32 key = bytes32(tokenId);\n', '\n', '    // Prevent the controller from being set to prohibited account values.\n', '    _validateController(controller, key);\n', '\n', '    // Burn the ERC721 token in question.\n', '    _burn(tokenId);\n', '\n', '    // Set initialization runtime storage contract address in contract storage.\n', '    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\n', '\n', '    // Set provided controller and increment contract deploy count at once.\n', '    HomeAddress storage home = _home[key];\n', '    home.exists = true;\n', '    home.controller = controller;\n', '    home.deploys += 1;\n', '\n', '    // Emit an event with the new controller. \n', '    emit NewController(key, controller);\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the desired initialization code to the\n', '   * home address corresponding to a given derived key. Two conditions must be\n', '   * met: the submitter must be designated as the controller of the home\n', '   * address, and there must not be a contract currently deployed at the home\n', '   * address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\n', '   * calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param initializationCode bytes The contract creation code that will be\n', '   * used to deploy the contract to the home address.\n', '   * @return The home address, derived key, and runtime code hash of the\n', '   * deployed contract.\n', '   * @dev In order to deploy the contract to the home address, a new contract\n', '   * will be deployed with runtime code set to the initialization code of the\n', '   * contract that will be deployed to the home address. Then, metamorphic\n', '   * initialization code will retrieve that initialization code and use it to\n', '   * set up and deploy the desired contract to the home address. Bear in mind\n', '   * that the deployed contract will interpret msg.sender as the address of THIS\n', '   * contract, and not the address of the submitter - if the constructor of the\n', '   * deployed contract uses msg.sender to set up ownership or other variables,\n', '   * you must modify it to accept a constructor argument with the appropriate\n', '   * address, or alternately to hard-code the intended address. Also, if your\n', '   * contract DOES have constructor arguments, remember to include them as\n', '   * ABI-encoded arguments at the end of the initialization code, just as you\n', '   * would when performing a standard deploy. You may want to provide the salt\n', '   * and submitter to `setDerivedReverseLookup` in order to find the salt,\n', '   * submitter, and derived key using only the home address to prevent\n', '   * accidentally losing them.\n', '   */\n', '  function deriveKeyAndDeploy(bytes32 salt, bytes calldata initializationCode)\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that initialization code was supplied.\n', '    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\n', '\n', '    // Derive key and prepare to deploy using supplied salt and calling address.\n', '    key = _deriveKeyAndPrepareToDeploy(salt);\n', '\n', '    // Deploy the initialization storage contract and set address in storage.\n', '    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\n', '      initializationCode\n', '    );\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Deploy a new contract with the initialization code stored in the\n', '   * runtime code at the specified initialization runtime storage contract to\n', '   * the home address corresponding to a given derived key. Two conditions must\n', '   * be met: the submitter must be designated as the controller of the home\n', '   * address, and there must not be a contract currently deployed at the home\n', '   * address. These conditions can be checked by calling\n', '   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\n', '   * calling `getDerivedKey`.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param initializationRuntimeStorageContract address The storage contract\n', '   * with runtime code equal to the contract creation code that will be used to\n', '   * deploy the contract to the home address.\n', '   * @return The home address, derived key, and runtime code hash of the\n', '   * deployed contract.\n', '   * @dev When deploying a contract to a home address via this method, the\n', '   * metamorphic initialization code will retrieve whatever initialization code\n', '   * currently resides at the specified address and use it to set up and deploy\n', '   * the desired contract to the home address. Bear in mind that the deployed\n', '   * contract will interpret msg.sender as the address of THIS contract, and not\n', '   * the address of the submitter - if the constructor of the deployed contract\n', '   * uses msg.sender to set up ownership or other variables, you must modify it\n', '   * to accept a constructor argument with the appropriate address, or\n', '   * alternately to hard-code the intended address. Also, if your contract DOES\n', '   * have constructor arguments, remember to include them as ABI-encoded\n', '   * arguments at the end of the initialization code, just as you would when\n', '   * performing a standard deploy. You may want to provide the salt and\n', '   * submitter to `setDerivedReverseLookup` in order to find the salt,\n', '   * submitter, and derived key using only the home address to prevent\n', '   * accidentally losing them.\n', '   */\n', '  function deriveKeyAndDeployViaExistingRuntimeStorageContract(\n', '    bytes32 salt,\n', '    address initializationRuntimeStorageContract\n', '  )\n', '    external\n', '    payable\n', '    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash)\n', '  {\n', '    // Ensure that the supplied runtime storage contract is not empty.\n', '    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\n', '\n', '    // Derive key and prepare to deploy using supplied salt and calling address.\n', '    key = _deriveKeyAndPrepareToDeploy(salt);\n', '\n', '    // Set the initialization runtime storage contract in contract storage.\n', '    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\n', '\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Mint multiple ERC721 tokens, designated by their keys, to the\n', "   * specified owner. Keys that aren't controlled, or that point to home\n", '   * addresses that are currently deployed, will be skipped.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 tokens.\n', '   * @param keys bytes32[] An array of values used to derive each home address.\n', '   * @dev If you plan to use this method regularly or want to keep gas costs to\n', '   * an absolute minimum, and are willing to go without standard ABI encoding,\n', '   * see `batchLock_63efZf` for a more efficient (and unforgiving)\n', '   * implementation. For batch token minting with *derived* keys, see\n', '   * `deriveKeysAndBatchLock`.\n', '   */\n', '  function batchLock(address owner, bytes32[] calldata keys) external {\n', '    // Track each key in the array of keys.\n', '    bytes32 key;\n', '\n', '    // Ensure that the specified owner is a valid ERC721 receiver.\n', '    if (keys.length > 0) {\n', '      _validateOwner(owner, keys[0]);\n', '    }\n', '\n', '    // Iterate through each provided key argument.\n', '    for (uint256 i; i < keys.length; i++) {\n', '      key = keys[i];\n', '\n', '      // Skip if the key currently has a contract deployed to its home address.\n', '      if (!_isNotDeployed(key)) {\n', '        continue;\n', '      }\n', '\n', '      // Skip if the caller is not the controller.\n', '      if (_getController(key) != msg.sender) {\n', '        continue;\n', '      }\n', '\n', '      // Set the exists flag to true and the controller to this contract.\n', '      HomeAddress storage home = _home[key];\n', '      home.exists = true;\n', '      home.controller = address(this);\n', '\n', '      // Emit an event signifying that this contract is now the controller. \n', '      emit NewController(key, address(this));\n', '\n', '      // Mint the ERC721 token to the designated owner.\n', '      _mint(owner, uint256(key));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Mint multiple ERC721 tokens, designated by salts that are hashed\n', "   * with the caller's address to derive each key, to the specified owner.\n", "   * Derived keys that aren't controlled, or that point to home addresses that\n", '   * are currently deployed, will be skipped.\n', '   * @param owner address The account that will be granted ownership of the\n', '   * ERC721 tokens.\n', '   * @param salts bytes32[] An array of values used to derive each key and\n', '   * corresponding home address.\n', '   * @dev See `batchLock` for batch token minting with standard, non-derived\n', '   * keys.\n', '   */\n', '  function deriveKeysAndBatchLock(address owner, bytes32[] calldata salts)\n', '    external\n', '  {\n', '    // Track each key derived from the array of salts.\n', '    bytes32 key;\n', '\n', '    // Ensure that the specified owner is a valid ERC721 receiver.\n', '    if (salts.length > 0) {\n', '      _validateOwner(owner, _deriveKey(salts[0], msg.sender));\n', '    }\n', '\n', '    // Iterate through each provided salt argument.\n', '    for (uint256 i; i < salts.length; i++) {\n', '      // Derive the key using the supplied salt and the calling address.\n', '      key = _deriveKey(salts[i], msg.sender);\n', '\n', '      // Skip if the key currently has a contract deployed to its home address.\n', '      if (!_isNotDeployed(key)) {\n', '        continue;\n', '      }\n', '\n', '      // Skip if the caller is not the controller.\n', '      HomeAddress storage home = _home[key];\n', '      if (home.exists && home.controller != msg.sender) {\n', '        continue;\n', '      }\n', '\n', '      // Set the exists flag to true and the controller to this contract.\n', '      home.exists = true;\n', '      home.controller = address(this);\n', '\n', '      // Emit an event signifying that this contract is now the controller. \n', '      emit NewController(key, address(this));\n', '\n', '      // Mint the ERC721 token to the designated owner.\n', '      _mint(owner, uint256(key));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Safely transfers the ownership of a group of token IDs to another\n', '   * address in a batch. If the target address is a contract, it must implement\n', '   * `onERC721Received`, called upon a safe transfer, and return the magic value\n', '   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`;\n', '   * otherwise, or if another error occurs, the entire batch is reverted.\n', '   * Requires msg.sender to be the owner, approved, or operator of the tokens.\n', '   * @param from address The current owner of the tokens.\n', '   * @param to address The account to receive ownership of the given tokens.\n', '   * @param tokenIds uint256[] ID of the tokens to be transferred.\n', '   */\n', '  function safeBatchTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256[] calldata tokenIds\n', '  )\n', '    external\n', '  {\n', '    // Track each token ID in the batch.\n', '    uint256 tokenId;\n', '\n', '    // Iterate over each supplied token ID.\n', '    for (uint256 i = 0; i < tokenIds.length; i++) {\n', '      // Set the current token ID.\n', '      tokenId = tokenIds[i];\n', '\n', '      // Perform the token transfer.\n', '      safeTransferFrom(from, to, tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Safely transfers the ownership of a group of token IDs to another\n', '   * address in a batch. If the target address is a contract, it must implement\n', '   * `onERC721Received`, called upon a safe transfer, and return the magic value\n', '   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`;\n', '   * otherwise, or if another error occurs, the entire batch is reverted.\n', '   * Requires msg.sender to be the owner, approved, or operator of the tokens.\n', '   * @param from address The current owner of the tokens.\n', '   * @param to address The account to receive ownership of the given tokens.\n', '   * @param tokenIds uint256[] ID of the tokens to be transferred.\n', '   * @param data bytes A data payload to include with each transfer.   \n', '   */\n', '  function safeBatchTransferFrom(\n', '    address from,\n', '    address to,\n', '    uint256[] calldata tokenIds,\n', '    bytes calldata data\n', '  )\n', '    external\n', '  {\n', '    // Track each token ID in the batch.\n', '    uint256 tokenId;\n', '\n', '    // Iterate over each supplied token ID.\n', '    for (uint256 i = 0; i < tokenIds.length; i++) {\n', '      // Set the current token ID.\n', '      tokenId = tokenIds[i];\n', '\n', '      // Perform the token transfer.\n', '      safeTransferFrom(from, to, tokenId, data);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Efficient version of `batchLock` that uses less gas. The first 20\n', '   * bytes of each key are automatically populated using msg.sender, and the\n', '   * remaining key segments are passed in as a packed byte array, using twelve\n', '   * bytes per segment, with a function selector of 0x00000000 followed by a\n', '   * twenty-byte segment for the desired owner of the minted ERC721 tokens. Note\n', '   * that an attempt to lock a key that is not controlled or with its contract\n', '   * already deployed will cause the entire batch to revert. Checks on whether\n', '   * the owner is a valid ERC721 receiver are also skipped, similar to using\n', '   * `transferFrom` instead of `safeTransferFrom`.\n', '   */\n', '  function batchLock_63efZf(/* packed owner and key segments */) external {\n', '    // Get the owner from calldata, located at bytes 4-23 (sig is bytes 0-3).\n', '    address owner;\n', '\n', '    // Determine number of 12-byte key segments in calldata from byte 24 on.\n', '    uint256 passedSaltSegments;\n', '\n', '    // Get the owner and calculate the total number of key segments.\n', '    assembly {\n', '      owner := shr(0x60, calldataload(4))                  // comes after sig\n', '      passedSaltSegments := div(sub(calldatasize, 24), 12) // after sig & owner\n', '    }\n', '\n', '    // Track each key, located at each 12-byte segment from byte 24 on.\n', '    bytes32 key;\n', '\n', '    // Iterate through each provided key segment argument.\n', '    for (uint256 i; i < passedSaltSegments; i++) {\n', '      // Construct keys by concatenating msg.sender with each key segment.\n', '      assembly {\n', '        key := add(                   // Combine msg.sender & provided key.\n', '          shl(0x60, caller),          // Place msg.sender at start of word.\n', '          shr(0xa0, calldataload(add(24, mul(i, 12))))   // Segment at end.\n', '        )\n', '      }\n', '\n', '      // Ensure that the key does not currently have a deployed contract.\n', '      require(_isNotDeployed(key), _ACCOUNT_EXISTS);\n', '\n', '      // Ensure that the caller is the controller of the key.\n', '      HomeAddress storage home = _home[key];\n', '      if (home.exists) {\n', '        require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '      }\n', '\n', '      // Set the exists flag to true and the controller to this contract.\n', '      home.exists = true;\n', '      home.controller = address(this);\n', '\n', '      // Emit an event signifying that this contract is now the controller. \n', '      emit NewController(key, address(this));\n', '\n', '      // Mint the ERC721 token to the designated owner.\n', '      _mint(owner, uint256(key));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Perform a dry-run of the deployment of a contract using a given key\n', '   * and revert on successful deployment. It cannot be called from outside the\n', '   * contract (even though it is marked as external).\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @dev This contract is called by `_isNotDeployable` in extreme cases where\n', '   * the deployability of the contract cannot be determined conclusively.\n', '   */\n', '  function staticCreate2Check(bytes32 key) external {\n', '    require(\n', '      msg.sender == address(this),\n', '      "This function can only be called by this contract."\n', '    );\n', '\n', '    assembly {\n', '      // Write the 32-byte metamorphic initialization code to scratch space.\n', '      mstore(\n', '        0,\n', '        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '      )\n', '\n', '      // Call `CREATE2` using metamorphic init code with supplied key as salt.\n', '      let deploymentAddress := create2(0, 0, 32, key)\n', '\n', '      // Revert and return the metamorphic init code on successful deployment.\n', '      if deploymentAddress {        \n', '        revert(0, 32)\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Submit a key to claim the "high score" - the lower the uint160\n', "   * value of the key's home address, the higher the score. The high score\n", '   * holder has the exclusive right to recover lost ether and tokens on this\n', '   * contract.\n', '   * @param key bytes32 The unique value used to derive the home address that\n', '   * will determine the resultant score.\n', '   * @dev The high score must be claimed by a direct key (one that is submitted\n', '   * by setting the first 20 bytes of the key to the address of the submitter)\n', '   * and not by a derived key, and is non-transferrable. If you want to help\n', '   * people recover their lost tokens, you might consider deploying a contract\n', '   * to the high score address (probably a metamorphic one so that you can use\n', '   * the home address later) with your contact information.\n', '   */\n', '  function claimHighScore(bytes32 key) external {\n', '    require(\n', '      msg.sender == address(bytes20(key)),\n', '      "Only submitters directly encoded in a given key may claim a high score."\n', '    );\n', '\n', '    // Derive the "home address" of the current high score key.\n', '    address currentHighScore = _getHomeAddress(_highScoreKey);\n', '\n', '    // Derive the "home address" of the new high score key.\n', '    address newHighScore = _getHomeAddress(key);\n', '\n', '    // Use addresses to ensure that supplied key is in fact a new high score.\n', '    require(\n', '      uint160(newHighScore) < uint160(currentHighScore),\n', '      "Submitted high score is not better than the current high score."\n', '    );\n', '\n', '    // Set the new high score to the supplied key.\n', '    _highScoreKey = key;\n', '\n', '    // The score is equal to (2^160 - 1) - ("home address" of high score key).\n', '    uint256 score = uint256(uint160(-1) - uint160(newHighScore));\n', '\n', '    // Emit an event to signify that a new high score has been reached.\n', '    emit NewHighScore(key, msg.sender, score);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer any ether or ERC20 tokens that have somehow ended up at\n', '   * this contract by specifying a token address (set to the null address for\n', '   * ether) as well as a recipient address. Only the high score holder can\n', '   * recover lost ether and tokens on this contract.\n', '   * @param token address The contract address of the ERC20 token to recover, or\n', '   * the null address for recovering Ether.\n', '   * @param recipient address payable The account where recovered funds should\n', '   * be transferred.\n', '   * @dev If you are trying to recover funds that were accidentally sent into\n', '   * this contract, see if you can contact the holder of the current high score,\n', '   * found by calling `getHighScore`. Better yet, try to find a new high score\n', '   * yourself!\n', '   */\n', '  function recover(IERC20 token, address payable recipient) external {\n', '    require(\n', '      msg.sender == address(bytes20(_highScoreKey)),\n', '      "Only the current high score holder may recover tokens."\n', '    );\n', '\n', '    if (address(token) == address(0)) {\n', "      // Recover ETH if the token's contract address is set to the null address.\n", '      recipient.transfer(address(this).balance);\n', '    } else {\n', '      // Determine the given ERC20 token balance and transfer to the recipient.\n', '      uint256 balance = token.balanceOf(address(this));\n', '      token.transfer(recipient, balance);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice "View" function to determine if a contract can currently be\n', '   * deployed to a home address given the corresponding key. A contract is only\n', '   * deployable if no account currently exists at the address - any existing\n', '   * contract must be destroyed via `SELFDESTRUCT` before a new contract can be\n', '   * deployed to a home address. This method does not modify state but is\n', '   * inaccessible via staticcall.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return A boolean signifying if a contract can be deployed to the home\n', '   * address that corresponds to the provided key.\n', '   * @dev This will not detect if a contract is not deployable due control\n', '   * having been relinquished on the key.\n', '   */\n', '  function isDeployable(bytes32 key)\n', '    external\n', '    /* view */\n', '    returns (bool deployable)\n', '  {\n', '    deployable = _isNotDeployed(key);\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the current "high score", or the lowest\n', '   * uint160 value of a home address of all keys submitted. The high score\n', '   * holder has the exclusive right to recover lost ether and tokens on this\n', '   * contract.\n', '   * @return The current high score holder, their score, and the submitted key.\n', '   */\n', '  function getHighScore()\n', '    external\n', '    view\n', '    returns (address holder, uint256 score, bytes32 key)\n', '  {\n', '    // Get the key and subbmitter holding the current high score.\n', '    key = _highScoreKey;\n', '    holder = address(bytes20(key));\n', '\n', '    // The score is equal to (2^160 - 1) - ("home address" of high score key).\n', '    score = uint256(uint160(-1) - uint160(_getHomeAddress(key)));\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get information on a home address given the\n', '   * corresponding key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The home address, the current controller of the address, the number\n', '   * of times the home address has been deployed to, and the code hash of the\n', '   * runtime currently found at the home address, if any.\n', '   * @dev There is also an `isDeployable` method for determining if a contract\n', '   * can be deployed to the address, but in extreme cases it must actually\n', '   * perform a dry-run to determine if the contract is deployable, which means\n', '   * that it does not support staticcalls. There is also a convenience method,\n', '   * `hasNeverBeenDeployed`, but the information it conveys can be determined\n', '   * from this method alone as well.\n', '   */\n', '  function getHomeAddressInformation(bytes32 key)\n', '    external\n', '    view\n', '    returns (\n', '      address homeAddress,\n', '      address controller,\n', '      uint256 deploys,\n', '      bytes32 currentRuntimeCodeHash\n', '    )\n', '  {\n', '    // Derive home address and retrieve other information using supplied key.\n', '    homeAddress = _getHomeAddress(key);\n', '    HomeAddress memory home = _home[key];\n', '\n', '    // If the home address has not been seen before, use the default controller.\n', '    if (!home.exists) {\n', '      controller = address(bytes20(key));\n', '    } else {\n', '      controller = home.controller;\n', '    }\n', '\n', '    // Retrieve the count of total deploys to the home address.\n', '    deploys = home.deploys;\n', '\n', '    // Retrieve keccak256 hash of runtime code currently at the home address.\n', '    assembly { currentRuntimeCodeHash := extcodehash(homeAddress) }\n', '  }\n', '\n', '  /**\n', '   * @notice View function to determine if no contract has ever been deployed to\n', '   * a home address given the corresponding key. This can be used to ensure that\n', '   * a given key or corresponding token is "new" or not.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return A boolean signifying if a contract has never been deployed using\n', '   * the supplied key before.\n', '   */\n', '  function hasNeverBeenDeployed(bytes32 key)\n', '    external\n', '    view\n', '    returns (bool neverBeenDeployed)\n', '  {\n', '    neverBeenDeployed = (_home[key].deploys == 0);\n', '  }\n', '\n', '  /**\n', '   * @notice View function to search for a known key, salt, and/or submitter\n', '   * given a supplied home address. Keys can be controlled directly by an\n', '   * address that matches the first 20 bytes of the key, or they can be derived\n', '   * from a salt and a submitter - if the key is not a derived key, the salt and\n', '   * submitter fields will both have a value of zero.\n', '   * @param homeAddress address The home address to check for key information.\n', '   * @return The key, salt, and/or submitter used to deploy to the home address,\n', '   * assuming they have been submitted to the reverse lookup.\n', '   * @dev To populate these values, call `setReverseLookup` for cases where keys\n', '   * are used directly or are the only value known, or `setDerivedReverseLookup`\n', '   * for cases where keys are derived from a known salt and submitter.\n', '   */\n', '  function reverseLookup(address homeAddress)\n', '    external\n', '    view\n', '    returns (bytes32 key, bytes32 salt, address submitter)\n', '  {\n', '    KeyInformation memory keyInformation = _key[homeAddress];\n', '    key = keyInformation.key;\n', '    salt = keyInformation.salt;\n', '    submitter = keyInformation.submitter;\n', '  }\n', '\n', '  /**\n', '   * @notice View function used by the metamorphic initialization code when\n', '   * deploying a contract to a home address. It returns the address of the\n', '   * runtime storage contract that holds the contract creation code, which the\n', '   * metamorphic creation code then `DELEGATECALL`s into in order to set up the\n', '   * contract and deploy the target runtime code.\n', '   * @return The current runtime storage contract that contains the target\n', '   * contract creation code.\n', '   * @dev This method is not meant to be part of the user-facing contract API,\n', '   * but is rather a mechanism for enabling the deployment of arbitrary code via\n', '   * fixed initialization code. The odd naming is chosen so that function\n', '   * selector will be 0x00000009 - that way, the metamorphic contract can simply\n', '   * use the `PC` opcode in order to push the selector to the stack.\n', '   */\n', '  function getInitializationCodeFromContractRuntime_6CLUNS()\n', '    external\n', '    view\n', '    returns (address initializationRuntimeStorageContract)\n', '  {\n', '    // Return address of contract with initialization code set as runtime code.\n', '    initializationRuntimeStorageContract = _initializationRuntimeStorageContract;\n', '  }\n', '\n', '  /**\n', '   * @notice View function to return an URI for a given token ID. Throws if the\n', '   * token ID does not exist.\n', '   * @param tokenId uint256 ID of the token to query.\n', '   * @return String representing the URI data encoding of JSON metadata.\n', '   * @dev The URI returned by this method takes the following form (with all\n', "   * returns and initial whitespace removed - it's just here for clarity):\n", '   *\n', '   * data:application/json,{\n', '   *   "name":"Home%20Address%20-%200x********************",\n', '   *   "description":"< ... HomeWork NFT desription ... >",\n', '   *   "image":"data:image/svg+xml;charset=utf-8;base64,< ... Image ... >"}\n', '   *\n', '   * where ******************** represents the checksummed home address that the\n', '   * token confers control over.\n', '   */\n', '  function tokenURI(uint256 tokenId)\n', '    external\n', '    view\n', '    returns (string memory)\n', '  {\n', '    // Only return a URI for tokens that exist.\n', '    require(_exists(tokenId), "A token with the given ID does not exist.");\n', '\n', '    // Get the home address that the given tokenId corresponds to.\n', '    address homeAddress = _getHomeAddress(bytes32(tokenId));\n', '\n', '    // Get the checksummed, ascii-encoded representation of the home address.\n', '    string memory asciiHomeAddress = _toChecksummedAsciiString(homeAddress);\n', '    \n', '    bytes memory uriEndSegment = _getTokenURIStorageRuntime();\n', '\n', '    // Insert checksummed address into URI in name and image fields and return.\n', '    return string(\n', '      abi.encodePacked(      // Concatenate all the string segments together.\n', '        _URI_START_SEGMENT,  // Data URI ID and initial formatting is constant.\n', '        asciiHomeAddress,    // Checksummed home address is in the name field.\n', '        uriEndSegment        // Description, image, and formatting is constant.\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the token name.\n', '   * @return String representing the token name.\n', '   */\n', '  function name() external pure returns (string memory) {\n', '    return _NAME;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the token symbol.\n', '   * @return String representing the token symbol.\n', '   */\n', '  function symbol() external pure returns (string memory) {\n', '    return _SYMBOL;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to determine the key that is derived from a given\n', '   * salt and submitting address.\n', '   * @param salt bytes32 The salt value that is used to derive the key.\n', '   * @param submitter address The submitter of the salt value used to derive the\n', '   * key.\n', '   * @return The derived key.\n', '   */\n', '  function getDerivedKey(bytes32 salt, address submitter)\n', '    external\n', '    pure\n', '    returns (bytes32 key)\n', '  {\n', '    // Derive the key using the supplied salt and submitter.\n', '    key = _deriveKey(salt, submitter);\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to determine the home address that corresponds to\n', '   * a given key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The home address.\n', '   */\n', '  function getHomeAddress(bytes32 key)\n', '    external\n', '    pure\n', '    returns (address homeAddress)\n', '  {\n', '    // Derive the home address using the supplied key.\n', '    homeAddress = _getHomeAddress(key);\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the metamorphic initialization code\n', '   * used to deploy arbitrary contracts to home addresses. Provided for easy\n', '   * verification and for use in other applications.\n', '   * @return The 32-byte metamorphic initialization code.\n', '   * @dev This metamorphic init code works via the "metamorphic delegator"\n', '   * mechanism, which is explained in greater detail at `_deployToHomeAddress`.\n', '   */\n', '  function getMetamorphicDelegatorInitializationCode()\n', '    external\n', '    pure\n', '    returns (bytes32 metamorphicDelegatorInitializationCode)\n', '  {\n', '    metamorphicDelegatorInitializationCode = _HOME_INIT_CODE;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the keccak256 of the metamorphic\n', '   * initialization code used to deploy arbitrary contracts to home addresses.\n', "   * This is the value that you should use, along with this contract's address\n", '   * and a caller address that you control, to mine for an partucular type of\n', '   * home address (such as one at a compact or gas-efficient address).\n', '   * @return The keccak256 hash of the metamorphic initialization code.\n', '   */\n', '  function getMetamorphicDelegatorInitializationCodeHash()\n', '    external\n', '    pure\n', '    returns (bytes32 metamorphicDelegatorInitializationCodeHash)\n', '  {\n', '    metamorphicDelegatorInitializationCodeHash = _HOME_INIT_CODE_HASH;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function for retrieving the prelude that will be inserted\n', '   * ahead of the code payload in order to deploy a runtime storage contract.\n', '   * @return The 11-byte "arbitrary runtime" prelude.\n', '   */\n', '  function getArbitraryRuntimeCodePrelude()\n', '    external\n', '    pure\n', '    returns (bytes11 prelude)\n', '  {\n', '    prelude = _ARBITRARY_RUNTIME_PRELUDE;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for deploying a runtime storage contract given a\n', '   * particular payload.\n', '   * @return The address of the runtime storage contract.\n', '   * @dev To take the provided code payload and deploy a contract with that\n', '   * payload as its runtime code, use the following prelude:\n', '   *\n', '   * 0x600b5981380380925939f3...\n', '   *\n', '   * 00  60  push1 0b      [11 -> offset]\n', '   * 02  59  msize         [offset, 0]\n', '   * 03  81  dup2          [offset, 0, offset]\n', '   * 04  38  codesize      [offset, 0, offset, codesize]\n', '   * 05  03  sub           [offset, 0, codesize - offset]\n', '   * 06  80  dup1          [offset, 0, codesize - offset, codesize - offset]\n', '   * 07  92  swap3         [codesize - offset, 0, codesize - offset, offset]\n', '   * 08  59  msize         [codesize - offset, 0, codesize - offset, offset, 0]\n', '   * 09  39  codecopy      [codesize - offset, 0] <init_code_in_runtime>\n', '   * 10  f3  return        [] *init_code_in_runtime*\n', '   * ... init_code\n', '   */\n', '  function _deployRuntimeStorageContract(bytes memory payload)\n', '    internal\n', '    returns (address runtimeStorageContract)\n', '  {\n', '    // Construct the contract creation code using the prelude and the payload.\n', '    bytes memory runtimeStorageContractCreationCode = abi.encodePacked(\n', '      _ARBITRARY_RUNTIME_PRELUDE,\n', '      payload\n', '    );\n', '\n', '    assembly {\n', '      // Get the location and length of the newly-constructed creation code.\n', '      let encoded_data := add(0x20, runtimeStorageContractCreationCode)\n', '      let encoded_size := mload(runtimeStorageContractCreationCode)\n', '\n', '      // Deploy the runtime storage contract via standard `CREATE`.\n', '      runtimeStorageContract := create(0, encoded_data, encoded_size)\n', '\n', '      // Pass along revert message if the contract did not deploy successfully.\n', '      if iszero(runtimeStorageContract) {\n', '        returndatacopy(0, 0, returndatasize)\n', '        revert(0, returndatasize)\n', '      }\n', '    }\n', '\n', '    // Emit an event with address of newly-deployed runtime storage contract.\n', '    emit NewRuntimeStorageContract(runtimeStorageContract, keccak256(payload));\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for deploying arbitrary contract code to the home\n', '   * address corresponding to a suppied key via metamorphic initialization code.\n', '   * @return The home address and the hash of the deployed runtime code.\n', '   * @dev This deployment method uses the "metamorphic delegator" pattern, where\n', '   * it will retrieve the address of the contract that contains the target\n', '   * initialization code, then delegatecall into it, which executes the\n', '   * initialization code stored there and returns the runtime code (or reverts).\n', '   * Then, the runtime code returned by the delegatecall is returned, and since\n', '   * we are still in the initialization context, it will be set as the runtime\n', '   * code of the metamorphic contract. The 32-byte metamorphic initialization\n', '   * code is as follows:\n', '   *\n', '   * 0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '   *\n', '   * 00  58  PC               [0]\n', '   * 01  59  MSIZE            [0, 0]\n', '   * 02  38  CODESIZE         [0, 0, codesize -> 32]\n', '   * returndatac03  59  MSIZE            [0, 0, 32, 0]\n', '   * 04  58  PC               [0, 0, 32, 0, 4]\n', '   * 05  60  PUSH1 0x1c       [0, 0, 32, 0, 4, 28]\n', '   * 07  33  CALLER           [0, 0, 32, 0, 4, 28, caller]\n', '   * 08  5a  GAS              [0, 0, 32, 0, 4, 28, caller, gas]\n', '   * 09  58  PC               [0, 0, 32, 0, 4, 28, caller, gas, 9 -> selector]\n', '   * 10  59  MSIZE            [0, 0, 32, 0, 4, 28, caller, gas, selector, 0]\n', '   * 11  52  MSTORE           [0, 0, 32, 0, 4, 28, caller, gas] <selector>\n', '   * 12  fa  STATICCALL       [0, 0, 1 => success] <init_in_runtime_address>\n', '   * 13  15  ISZERO           [0, 0, 0]\n', '   * 14  82  DUP3             [0, 0, 0, 0]\n', '   * 15  83  DUP4             [0, 0, 0, 0, 0]\n', '   * 16  83  DUP4             [0, 0, 0, 0, 0, 0]\n', '   * 17  82  DUP3             [0, 0, 0, 0, 0, 0, 0]\n', '   * 18  51  MLOAD            [0, 0, 0, 0, 0, 0, init_in_runtime_address]\n', '   * 19  5a  GAS              [0, 0, 0, 0, 0, 0, init_in_runtime_address, gas]\n', '   * 20  f4  DELEGATECALL     [0, 0, 1 => success] {runtime_code}\n', '   * 21  3d  RETURNDATASIZE   [0, 0, 1 => success, size]\n', '   * 22  3d  RETURNDATASIZE   [0, 0, 1 => success, size, size]\n', '   * 23  93  SWAP4            [size, 0, 1 => success, size, 0]\n', '   * 24  83  DUP4             [size, 0, 1 => success, size, 0, 0]\n', '   * 25  3e  RETURNDATACOPY   [size, 0, 1 => success] <runtime_code>\n', '   * 26  60  PUSH1 0x1e       [size, 0, 1 => success, 30]\n', '   * 28  57  JUMPI            [size, 0]\n', '   * 29  fd  REVERT           [] *runtime_code*\n', '   * 30  5b  JUMPDEST         [size, 0]\n', '   * 31  f3  RETURN           []\n', '   */\n', '  function _deployToHomeAddress(bytes32 key)\n', '    internal\n', '    returns (address homeAddress, bytes32 runtimeCodeHash)\n', '  {    \n', '    assembly {\n', '      // Write the 32-byte metamorphic initialization code to scratch space.\n', '      mstore(\n', '        0,\n', '        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '      )\n', '\n', '      // Call `CREATE2` using above init code with the supplied key as the salt.\n', '      homeAddress := create2(callvalue, 0, 32, key)\n', '\n', '      // Pass along revert message if the contract did not deploy successfully.\n', '      if iszero(homeAddress) {\n', '        returndatacopy(0, 0, returndatasize)\n', '        revert(0, returndatasize)\n', '      }\n', '\n', '      // Get the runtime hash of the deployed contract.\n', '      runtimeCodeHash := extcodehash(homeAddress)\n', '    }\n', '\n', '    // Clear the address of the runtime storage contract from storage.\n', '    delete _initializationRuntimeStorageContract;\n', '\n', '    // Emit an event with home address, key, and runtime hash of new contract.\n', '    emit NewResident(homeAddress, key, runtimeCodeHash);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for deriving a key given a particular salt and\n', '   * caller and for performing verifications of, and modifications to, the\n', '   * information set on that key.\n', '   * @param salt bytes32 The value used to derive the key.\n', '   * @return The derived key.\n', '   */\n', '  function _deriveKeyAndPrepareToDeploy(bytes32 salt)\n', '    internal\n', '    returns (bytes32 key)\n', '  {\n', '    // Derive the key using the supplied salt and the calling address.\n', '    key = _deriveKey(salt, msg.sender);\n', '\n', '    // Ensure that a contract is not currently deployed to the home address.\n', '    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\n', '\n', '    // Set appropriate controller and increment contract deploy count at once.\n', '    HomeAddress storage home = _home[key];\n', '    if (!home.exists) {\n', '      home.exists = true;\n', '      home.controller = msg.sender;\n', '      home.deploys += 1;\n', '\n', '      // Emit an event signifying that this contract is now the controller. \n', '      emit NewController(key, msg.sender);\n', '    \n', '    } else {\n', '      home.deploys += 1;\n', '    }\n', '\n', '    // Ensure that the caller is the designated controller before proceeding.\n', '    require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for verifying that an owner that cannot accept\n', '   * ERC721 tokens has not been supplied.\n', '   * @param owner address The specified owner.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  function _validateOwner(address owner, bytes32 key) internal {\n', '    // Ensure that the specified owner is a valid ERC721 receiver.\n', '    require(\n', '      _checkOnERC721Received(address(0), owner, uint256(key), bytes("")),\n', '      "Owner must be an EOA or a contract that implements `onERC721Received`."\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal "view" function for determining if a contract currently\n', '   * exists at a given home address corresponding to a particular key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return A boolean signifying whether the home address has a contract\n', '   * deployed or not.\n', '   */\n', '  function _isNotDeployed(bytes32 key)\n', '    internal\n', '    /* view */\n', '    returns (bool notDeployed)\n', '  {\n', '    // Derive the home address using the supplied key.\n', '    address homeAddress = _getHomeAddress(key);\n', '\n', '    // Check whether account at home address is non-existent using EXTCODEHASH.\n', '    bytes32 hash;\n', '    assembly { hash := extcodehash(homeAddress) }\n', '\n', '    // Account does not exist, and contract is not deployed, if hash equals 0.\n', '    if (hash == bytes32(0)) {\n', '      return true;\n', '    }\n', '\n', '    // Contract is deployed (notDeployed = false) if codesize is greater than 0.\n', '    uint256 size;\n', '    assembly { size := extcodesize(homeAddress) }\n', '    if (size > 0) {\n', '      return false;\n', '    }\n', '\n', '    // Declare variable to move current runtime storage from storage to memory.\n', '    address currentStorage;\n', '\n', '    // Set runtime storage contract to null address temporarily if necessary.\n', '    if (_initializationRuntimeStorageContract != address(0)) {\n', '      // Place the current runtime storage contract address in memory.\n', '      currentStorage = _initializationRuntimeStorageContract;\n', '      \n', '      // Remove the existing runtime storage contract address from storage.\n', '      delete _initializationRuntimeStorageContract;\n', '    }\n', '\n', '    // Set gas to use when performing dry-run deployment (future-proof a bit).\n', '    uint256 checkGas = 27000 + (block.gaslimit / 1000);\n', '    \n', '    // As a last resort, deploy a contract to the address and revert on success.\n', '    (bool contractExists, bytes memory code) = address(this).call.gas(checkGas)(\n', '      abi.encodeWithSelector(this.staticCreate2Check.selector, key)\n', '    );\n', '\n', '    // Place runtime storage contract back in storage if necessary.\n', '    if (currentStorage != address(0)) {\n', '      _initializationRuntimeStorageContract = currentStorage;\n', '    }\n', '\n', '    // Check revert string to ensure failure is due to successful deployment.\n', '    bytes32 revertMessage;\n', '    assembly { revertMessage := mload(add(code, 32)) }\n', '\n', '    // Contract is not deployed if `staticCreate2Check` reverted with message.\n', '    notDeployed = !contractExists && revertMessage == _HOME_INIT_CODE;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function for verifying that a restricted controller\n', '   * has not been supplied.\n', '   * @param controller address The specified controller.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  function _validateController(address controller, bytes32 key) internal view {\n', '    // Prevent the controller from being set to prohibited account values.\n', '    require(\n', '      controller != address(0),\n', '      "The null address may not be set as the controller using this function."\n', '    );\n', '    require(\n', '      controller != address(this),\n', '      "This contract may not be set as the controller using this function."\n', '    );\n', '    require(\n', '      controller != _getHomeAddress(key),\n', '      "Home addresses cannot be set as the controller of themselves."\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function for verifying that a supplied runtime\n', '   * storage contract is not empty.\n', '   * @param target address The runtime storage contract.\n', '   */\n', '  function _validateRuntimeStorageIsNotEmpty(address target) internal view {\n', '    // Ensure that the runtime storage contract is not empty.\n', '    require(\n', '      target.isContract(),\n', '      "No runtime code found at the supplied runtime storage address."\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function for retrieving the controller of a home\n', '   * address corresponding to a particular key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The controller of the home address corresponding to the supplied\n', '   * key.\n', '   */\n', '  function _getController(bytes32 key)\n', '    internal\n', '    view\n', '    returns (address controller)\n', '  {\n', '    // Get controller from mapping, defaulting to first 20 bytes of the key.\n', '    HomeAddress memory home = _home[key];\n', '    if (!home.exists) {\n', '      controller = address(bytes20(key));\n', '    } else {\n', '      controller = home.controller;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function for getting the runtime code at the tokenURI\n', '   * data storage address.\n', '   * @return The runtime code at the tokenURI storage address.\n', '   */\n', '  function _getTokenURIStorageRuntime()\n', '    internal\n', '    view\n', '    returns (bytes memory runtime)\n', '  {\n', '    // Bring the tokenURI storage address into memory for use in assembly block.\n', '    address target = _URI_END_SEGMENT_STORAGE;\n', '    \n', '    assembly {\n', '      // Retrieve the size of the external code.\n', '      let size := extcodesize(target)\n', '      \n', '      // Allocate output byte array.\n', '      runtime := mload(0x40)\n', '      \n', '      // Set new "memory end" including padding.\n', '      mstore(0x40, add(runtime, and(add(size, 0x3f), not(0x1f))))\n', '      \n', '      // Store length in memory.\n', '      mstore(runtime, size)\n', '      \n', '      // Get the code using extcodecopy.\n', '      extcodecopy(target, add(runtime, 0x20), 0, size)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function for calculating a home address given a\n', '   * particular key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   * @return The home address corresponding to the supplied key.\n', '   */\n', '  function _getHomeAddress(bytes32 key)\n', '    internal\n', '    pure\n', '    returns (address homeAddress)\n', '  {\n', '    // Determine the home address by replicating CREATE2 logic.\n', '    homeAddress = address(\n', '      uint160(                       // Downcast to match the address type.\n', '        uint256(                     // Cast to uint to truncate upper digits.\n', '          keccak256(                 // Compute CREATE2 hash using 4 inputs.\n', '            abi.encodePacked(        // Pack all inputs to the hash together.\n', '              _FF_AND_THIS_CONTRACT, // This contract will be the caller.\n', '              key,                   // Pass in the supplied key as the salt.\n', '              _HOME_INIT_CODE_HASH   // The metamorphic init code hash.\n', '            )\n', '          )\n', '        )\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function for deriving a key given a particular salt\n', '   * and caller.\n', '   * @param salt bytes32 The value used to derive the key.\n', '   * @param submitter address The submitter of the salt used to derive the key.\n', '   * @return The derived key.\n', '   */\n', '  function _deriveKey(bytes32 salt, address submitter)\n', '    internal\n', '    pure\n', '    returns (bytes32 key)\n', '  {\n', '    // Set the key as the keccak256 hash of the salt and submitter.\n', '    key = keccak256(abi.encodePacked(salt, submitter));\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function for converting the bytes representation of\n', '   * an address to an ASCII string. This function is derived from the function\n', '   * at https://ethereum.stackexchange.com/a/56499/48410\n', '   * @param data bytes20 The account address to be converted.\n', '   * @return The account string in ASCII format. Note that leading "0x" is not\n', '   * included.\n', '   */\n', '  function _toAsciiString(bytes20 data)\n', '    internal\n', '    pure\n', '    returns (string memory asciiString)\n', '  {\n', '    // Create an in-memory fixed-size bytes array.\n', '    bytes memory asciiBytes = new bytes(40);\n', '\n', '    // Declare variable types.\n', '    uint8 oneByte;\n', '    uint8 leftNibble;\n', '    uint8 rightNibble;\n', '\n', '    // Iterate over bytes, processing left and right nibble in each iteration.\n', '    for (uint256 i = 0; i < data.length; i++) {\n', '      // locate the byte and extract each nibble.\n', '      oneByte = uint8(uint160(data) / (2 ** (8 * (19 - i))));\n', '      leftNibble = oneByte / 16;\n', '      rightNibble = oneByte - 16 * leftNibble;\n', '\n', '      // To convert to ascii characters, add 48 to 0-9 and 87 to a-f.\n', '      asciiBytes[2 * i] = byte(leftNibble + (leftNibble < 10 ? 48 : 87));\n', '      asciiBytes[2 * i + 1] = byte(rightNibble + (rightNibble < 10 ? 48 : 87));\n', '    }\n', '\n', '    asciiString = string(asciiBytes);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function for getting a fixed-size array of whether or\n', '   * not each character in an account will be capitalized in the checksum.\n', '   * @param account address The account to get the checksum capitalization\n', '   * information for.\n', '   * @return A fixed-size array of booleans that signify if each character or\n', '   * "nibble" of the hex encoding of the address will be capitalized by the\n', '   * checksum.\n', '   */\n', '  function _getChecksumCapitalizedCharacters(address account)\n', '    internal\n', '    pure\n', '    returns (bool[40] memory characterIsCapitalized)\n', '  {\n', '    // Convert the address to bytes.\n', '    bytes20 addressBytes = bytes20(account);\n', '\n', '    // Hash the address (used to calculate checksum).\n', '    bytes32 hash = keccak256(abi.encodePacked(_toAsciiString(addressBytes)));\n', '\n', '    // Declare variable types.\n', '    uint8 leftNibbleAddress;\n', '    uint8 rightNibbleAddress;\n', '    uint8 leftNibbleHash;\n', '    uint8 rightNibbleHash;\n', '\n', '    // Iterate over bytes, processing left and right nibble in each iteration.\n', '    for (uint256 i; i < addressBytes.length; i++) {\n', '      // locate the byte and extract each nibble for the address and the hash.\n', '      rightNibbleAddress = uint8(addressBytes[i]) % 16;\n', '      leftNibbleAddress = (uint8(addressBytes[i]) - rightNibbleAddress) / 16;\n', '      rightNibbleHash = uint8(hash[i]) % 16;\n', '      leftNibbleHash = (uint8(hash[i]) - rightNibbleHash) / 16;\n', '\n', '      // Set the capitalization flags based on the characters and the checksums.\n', '      characterIsCapitalized[2 * i] = (\n', '        leftNibbleAddress > 9 &&\n', '        leftNibbleHash > 7\n', '      );\n', '      characterIsCapitalized[2 * i + 1] = (\n', '        rightNibbleAddress > 9 &&\n', '        rightNibbleHash > 7\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function for converting the bytes representation of\n', '   * an address to a checksummed ASCII string.\n', '   * @param account address The account address to be converted.\n', '   * @return The checksummed account string in ASCII format. Note that leading\n', '   * "0x" is not included.\n', '   */\n', '  function _toChecksummedAsciiString(address account)\n', '    internal\n', '    pure\n', '    returns (string memory checksummedAsciiString)\n', '  {\n', '    // Get capitalized characters in the checksum.\n', '    bool[40] memory caps = _getChecksumCapitalizedCharacters(account);\n', '\n', '    // Create an in-memory fixed-size bytes array.\n', '    bytes memory asciiBytes = new bytes(40);\n', '\n', '    // Declare variable types.\n', '    uint8 oneByte;\n', '    uint8 leftNibble;\n', '    uint8 rightNibble;\n', '    uint8 leftNibbleOffset;\n', '    uint8 rightNibbleOffset;\n', '\n', '    // Convert account to bytes20.\n', '    bytes20 data = bytes20(account);\n', '\n', '    // Iterate over bytes, processing left and right nibble in each iteration.\n', '    for (uint256 i = 0; i < data.length; i++) {\n', '      // locate the byte and extract each nibble.\n', '      oneByte = uint8(uint160(data) / (2 ** (8 * (19 - i))));\n', '      leftNibble = oneByte / 16;\n', '      rightNibble = oneByte - 16 * leftNibble;\n', '\n', '      // To convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\n', '      if (leftNibble < 10) {\n', '        leftNibbleOffset = 48;\n', '      } else if (caps[i * 2]) {\n', '        leftNibbleOffset = 55;\n', '      } else {\n', '        leftNibbleOffset = 87;\n', '      }\n', '\n', '      if (rightNibble < 10) {\n', '        rightNibbleOffset = 48;\n', '      } else {\n', '        rightNibbleOffset = caps[(i * 2) + 1] ? 55 : 87; // instrumentation fix\n', '      }\n', '\n', '      asciiBytes[2 * i] = byte(leftNibble + leftNibbleOffset);\n', '      asciiBytes[2 * i + 1] = byte(rightNibble + rightNibbleOffset);\n', '    }\n', '\n', '    checksummedAsciiString = string(asciiBytes);\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier to ensure that a contract is not currently deployed to the\n', '   * home address corresponding to a given key on the decorated function.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  modifier onlyEmpty(bytes32 key) {\n', '    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier to ensure that the caller of the decorated function is the\n', '   * controller of the home address corresponding to a given key.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  modifier onlyController(bytes32 key) {\n', '    require(_getController(key) == msg.sender, _ONLY_CONTROLLER);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier to track initial controllers and to count deploys, and to\n', '   * validate that only the designated controller has access to the decorated\n', '   * function.\n', '   * @param key bytes32 The unique value used to derive the home address.\n', '   */\n', '  modifier onlyControllerDeployer(bytes32 key) {\n', '    HomeAddress storage home = _home[key];\n', '\n', '    // Set appropriate controller and increment contract deploy count at once.\n', '    if (!home.exists) {\n', '      home.exists = true;\n', '      home.controller = address(bytes20(key));\n', '      home.deploys += 1;\n', '    } else {\n', '      home.deploys += 1;\n', '    }\n', '\n', '    require(home.controller == msg.sender, _ONLY_CONTROLLER);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier to ensure that only the owner of the supplied ERC721\n', '   * token, or an approved spender, can access the decorated function.\n', '   * @param tokenId uint256 The ID of the ERC721 token.\n', '   */\n', '  modifier onlyTokenOwnerOrApprovedSpender(uint256 tokenId) {\n', '    require(\n', '      _isApprovedOrOwner(msg.sender, tokenId),\n', '      "Only the token owner or an approved spender may call this function."\n', '    );\n', '    _;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title HomeWork Deployer (alpha version)\n', ' * @author 0age\n', ' * @notice This contract is a stripped-down version of HomeWork that is used to\n', ' * deploy HomeWork itself.\n', ' *   HomeWork Deploy code at runtime: 0x7Cf7708ab4A064B14B02F34aecBd2511f3605395\n', ' *   HomeWork Runtime code at:        0x0000000000001b84b1cb32787b0d64758d019317\n', ' */\n', 'contract HomeWorkDeployer {\n', '  // Fires when HomeWork has been deployed.\n', '  event HomeWorkDeployment(address homeAddress, bytes32 key);\n', '\n', "  // Fires HomeWork's initialization-in-runtime storage contract is deployed.\n", '  event StorageContractDeployment(address runtimeStorageContract);\n', '\n', '  // Allocate storage to track the current initialization-in-runtime contract.\n', '  address private _initializationRuntimeStorageContract;\n', '\n', '  // Once HomeWork has been deployed, disable this contract.\n', '  bool private _disabled;\n', '\n', "  // Write arbitrary code to a contract's runtime using the following prelude.\n", '  bytes11 private constant _ARBITRARY_RUNTIME_PRELUDE = bytes11(\n', '    0x600b5981380380925939f3\n', '  );\n', '\n', '  /**\n', '   * @notice Perform phase one of the deployment.\n', '   * @param code bytes The contract creation code for HomeWork.\n', '   */\n', '  function phaseOne(bytes calldata code) external onlyUntilDisabled {\n', '    // Deploy payload to the runtime storage contract and set the address.\n', '    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\n', '      bytes32(0),\n', '      code\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Perform phase two of the deployment (tokenURI data).\n', '   * @param key bytes32 The salt to provide to create2.\n', '   */\n', '  function phaseTwo(bytes32 key) external onlyUntilDisabled {\n', '    // Deploy runtime storage contract with the string used to construct end of\n', '    // token URI for issued ERC721s (data URI with a base64-encoded jpeg image).    \n', '    bytes memory code = abi.encodePacked(\n', '      hex"222c226465736372697074696f6e223a22546869732532304e465425323063616e25",\n', '      hex"3230626525323072656465656d65642532306f6e253230486f6d65576f726b253230",\n', '      hex"746f2532306772616e7425323061253230636f6e74726f6c6c657225323074686525",\n', '      hex"32306578636c75736976652532307269676874253230746f2532306465706c6f7925",\n', '      hex"3230636f6e7472616374732532307769746825323061726269747261727925323062",\n', '      hex"797465636f6465253230746f25323074686525323064657369676e61746564253230",\n', '      hex"686f6d65253230616464726573732e222c22696d616765223a22646174613a696d61",\n', '      hex"67652f7376672b786d6c3b636861727365743d7574662d383b6261736536342c5048",\n', '      hex"4e325a79423462577875637a30696148523063446f764c336433647935334d793576",\n', '      hex"636d63764d6a41774d43397a646d636949485a705a58644362336739496a41674d43",\n', '      hex"41784e4451674e7a4969506a787a64486c735a543438495674445245465551567375",\n', '      hex"516e747a64484a766132557462476c755a57707661573436636d3931626d52394c6b",\n', '      hex"4e37633352796232746c4c5731706447567962476c74615851364d5442394c6b5237",\n', '      hex"633352796232746c4c5864705a48526f4f6a4a394c6b56375a6d6c7362446f6a4f57",\n', '      hex"4935596a6c686653354765334e30636d39725a5331736157356c593246774f6e4a76",\n', '      hex"6457356b66563164506a7776633352356247552b5047636764484a68626e4e6d6233",\n', '      hex"4a7450534a74595852796158676f4d5334774d694177494441674d5334774d694134",\n', '      hex"4c6a45674d436b69506a78775958526f49475a706247773949694e6d5a6d59694947",\n', '      hex"5139496b30784f53417a4d6d677a4e4859794e4567784f586f694c7a34385a79427a",\n', '      hex"64484a766132553949694d774d44416949474e7359584e7a50534a4349454d675243",\n', '      hex"492b50484268644767675a6d6c7362443069493245314e7a6b7a4f5349675a443069",\n', '      hex"545449314944517761446c324d545a6f4c546c364969382b50484268644767675a6d",\n', '      hex"6c7362443069497a6b795a444e6d4e5349675a443069545451774944517761446832",\n', '      hex"4e3267744f486f694c7a3438634746306143426d615778735053496a5a5745315954",\n', '      hex"51334969426b50534a4e4e544d674d7a4a494d546c324c5446734d5459744d545967",\n', '      hex"4d5467674d545a364969382b50484268644767675a6d6c7362443069626d39755a53",\n', '      hex"49675a4430695454453549444d7961444d30646a49305344453565694976506a7877",\n', '      hex"5958526f49475a706247773949694e6c595456684e44636949475139496b30794f53",\n', '      hex"41794d5777744e53413164693035614456364969382b5043396e506a77765a7a3438",\n', '      hex"5a794230636d467563325a76636d3039496d316864484a70654367754f4451674d43",\n', '      hex"4177494334344e4341324e5341314b53492b50484268644767675a44306954546b75",\n', '      hex"4e5341794d693435624451754f4341324c6a52684d7934784d69417a4c6a45794944",\n', '      hex"41674d4341784c544d674d693479624330304c6a67744e6934305979347a4c544575",\n', '      hex"4e4341784c6a59744d69343049444d744d693479656949675a6d6c73624430694932",\n', '      hex"517759325a6a5a534976506a78775958526f49475a706247773949694d774d544178",\n', '      hex"4d44456949475139496b30304d53343349444d344c6a56734e5334784c5459754e53",\n', '      hex"4976506a78775958526f49475139496b30304d693435494449334c6a684d4d546775",\n', '      hex"4e4341314f4334784944493049445979624449784c6a67744d6a63754d7941794c6a",\n', '      hex"4d744d693434656949675932786863334d39496b55694c7a3438634746306143426d",\n', '      hex"615778735053496a4d4445774d5441784969426b50534a4e4e444d754e4341794f53",\n', '      hex"347a624330304c6a63674e5334344969382b50484268644767675a44306954545132",\n', '      hex"4c6a67674d7a4a6a4d793479494449754e6941344c6a63674d533479494445794c6a",\n', '      hex"45744d793479637a4d754e6930354c6a6b754d7930784d693431624330314c6a4567",\n', '      hex"4e6934314c5449754f4330754d5330754e7930794c6a63674e5334784c5459754e57",\n', '      hex"4d744d7934794c5449754e6930344c6a63744d5334794c5445794c6a45674d793479",\n', '      hex"6379307a4c6a59674f5334354c53347a494445794c6a556949474e7359584e7a5053",\n', '      hex"4a464969382b50484268644767675a6d6c7362443069493245314e7a6b7a4f534967",\n', '      hex"5a443069545449334c6a4d674d6a5a734d5445754f4341784e53343349444d754e43",\n', '      hex"41794c6a51674f533478494445304c6a51744d793479494449754d79307849433433",\n', '      hex"4c5445774c6a49744d544d754e6930784c6a4d744d7934354c5445784c6a67744d54",\n', '      hex"55754e336f694c7a3438634746306143426b50534a4e4d5449674d546b754f577731",\n', '      hex"4c6a6b674e793435494445774c6a49744e7934324c544d754e4330304c6a567a4e69",\n', '      hex"34344c5455754d5341784d4334334c5451754e574d77494441744e6934324c544d74",\n', '      hex"4d544d754d7941784c6a46544d5449674d546b754f5341784d6941784f5334356569",\n', '      hex"49675932786863334d39496b55694c7a34385a79426d6157787350534a756232356c",\n', '      hex"4969427a64484a766132553949694d774d44416949474e7359584e7a50534a434945",\n', '      hex"4d675243492b50484268644767675a44306954545579494455344c6a6c4d4e444175",\n', '      hex"4f5341304d7934796243307a4c6a45744d69347a4c5445774c6a59744d5451754e79",\n', '      hex"30794c6a6b674d693479494445774c6a59674d5451754e7941784c6a45674d793432",\n', '      hex"494445784c6a55674d5455754e58704e4d5449754e5341784f533434624455754f43",\n', '      hex"4134494445774c6a4d744e7934304c544d754d7930304c6a5a7a4e6934354c545567",\n', '      hex"4d5441754f4330304c6a4e6a4d4341774c5459754e69307a4c6a45744d544d754d79",\n', '      hex"3435637930784d43347a494463754e4330784d43347a494463754e4870744c544975",\n', '      hex"4e6941794c6a6c734e433433494459754e574d744c6a55674d53347a4c5445754e79",\n', '      hex"41794c6a45744d7941794c6a4a734c5451754e7930324c6a566a4c6a4d744d533430",\n', '      hex"494445754e6930794c6a51674d7930794c6a4a364969382b50484268644767675a44",\n', '      hex"3069545451784c6a4d674d7a67754e5777314c6a45744e6934316253307a4c6a5574",\n', '      hex"4d693433624330304c6a59674e533434625467754d53307a4c6a466a4d7934794944",\n', '      hex"49754e6941344c6a63674d533479494445794c6a45744d793479637a4d754e693035",\n', '      hex"4c6a6b754d7930784d693431624330314c6a45674e6934314c5449754f4330754d53",\n', '      hex"30754f4330794c6a63674e5334784c5459754e574d744d7934794c5449754e693034",\n', '      hex"4c6a63744d5334794c5445794c6a45674d7934794c544d754e4341304c6a4d744d79",\n', '      hex"343249446b754f5330754d7941784d6934314969426a6247467a637a306952694976",\n', '      hex"506a78775958526f49475139496b307a4d433434494451304c6a524d4d546b674e54",\n', '      hex"67754f57773049444d674d5441744d5449754e7949675932786863334d39496b5969",\n', '      hex"4c7a34384c32632b5043396e506a777663335a6e50673d3d227d"\n', '    ); /* ","description":"This%20NFT%20can%20be%20redeemed%20on%20HomeWork%20\n', '          to%20grant%20a%20controller%20the%20exclusive%20right%20to%20deploy%20\n', '          contracts%20with%20arbitrary%20bytecode%20to%20the%20designated%20home\n', '          %20address.","image":"data:image/svg+xml;charset=utf-8;base64,..."} */\n', '\n', '    // Deploy payload to the runtime storage contract.\n', '    _deployRuntimeStorageContract(key, code);\n', '  }\n', '\n', '  /**\n', '   * @notice Perform phase three of the deployment and disable this contract.\n', '   * @param key bytes32 The salt to provide to create2.\n', '   */\n', '  function phaseThree(bytes32 key) external onlyUntilDisabled {\n', '    // Use metamorphic initialization code to deploy contract to home address.\n', '    _deployToHomeAddress(key);\n', '\n', '    // Disable this contract from here on out - use HomeWork itself instead.\n', '    _disabled = true;\n', '  }\n', '\n', '  /**\n', '   * @notice View function used by the metamorphic initialization code when\n', '   * deploying a contract to a home address. It returns the address of the\n', '   * runtime storage contract that holds the contract creation code, which the\n', '   * metamorphic creation code then `DELEGATECALL`s into in order to set up the\n', '   * contract and deploy the target runtime code.\n', '   * @return The current runtime storage contract that contains the target\n', '   * contract creation code.\n', '   * @dev This method is not meant to be part of the user-facing contract API,\n', '   * but is rather a mechanism for enabling the deployment of arbitrary code via\n', '   * fixed initialization code. The odd naming is chosen so that function\n', '   * selector will be 0x00000009 - that way, the metamorphic contract can simply\n', '   * use the `PC` opcode in order to push the selector to the stack.\n', '   */\n', '  function getInitializationCodeFromContractRuntime_6CLUNS()\n', '    external\n', '    view\n', '    returns (address initializationRuntimeStorageContract)\n', '  {\n', '    // Return address of contract with initialization code set as runtime code.\n', '    initializationRuntimeStorageContract = _initializationRuntimeStorageContract;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for deploying a runtime storage contract given a\n', '   * particular payload.\n', '   * @dev To take the provided code payload and deploy a contract with that\n', '   * payload as its runtime code, use the following prelude:\n', '   *\n', '   * 0x600b5981380380925939f3...\n', '   *\n', '   * 00  60  push1 0b      [11 -> offset]\n', '   * 02  59  msize         [offset, 0]\n', '   * 03  81  dup2          [offset, 0, offset]\n', '   * 04  38  codesize      [offset, 0, offset, codesize]\n', '   * 05  03  sub           [offset, 0, codesize - offset]\n', '   * 06  80  dup1          [offset, 0, codesize - offset, codesize - offset]\n', '   * 07  92  swap3         [codesize - offset, 0, codesize - offset, offset]\n', '   * 08  59  msize         [codesize - offset, 0, codesize - offset, offset, 0]\n', '   * 09  39  codecopy      [codesize - offset, 0] <init_code_in_runtime>\n', '   * 10  f3  return        [] *init_code_in_runtime*\n', '   * ... init_code\n', '   */\n', '  function _deployRuntimeStorageContract(bytes32 key, bytes memory payload)\n', '    internal\n', '    returns (address runtimeStorageContract)\n', '  {\n', '    // Construct the contract creation code using the prelude and the payload.\n', '    bytes memory runtimeStorageContractCreationCode = abi.encodePacked(\n', '      _ARBITRARY_RUNTIME_PRELUDE,\n', '      payload\n', '    );\n', '\n', '    assembly {\n', '      // Get the location and length of the newly-constructed creation code.\n', '      let encoded_data := add(0x20, runtimeStorageContractCreationCode)\n', '      let encoded_size := mload(runtimeStorageContractCreationCode)\n', '\n', '      // Deploy the runtime storage contract via `CREATE2`.\n', '      runtimeStorageContract := create2(0, encoded_data, encoded_size, key)\n', '\n', '      // Pass along revert message if the contract did not deploy successfully.\n', '      if iszero(runtimeStorageContract) {\n', '        returndatacopy(0, 0, returndatasize)\n', '        revert(0, returndatasize)\n', '      }\n', '    }\n', '\n', '    // Emit an event with address of newly-deployed runtime storage contract.\n', '    emit StorageContractDeployment(runtimeStorageContract);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for deploying arbitrary contract code to the home\n', '   * address corresponding to a suppied key via metamorphic initialization code.\n', '   * @dev This deployment method uses the "metamorphic delegator" pattern, where\n', '   * it will retrieve the address of the contract that contains the target\n', '   * initialization code, then delegatecall into it, which executes the\n', '   * initialization code stored there and returns the runtime code (or reverts).\n', '   * Then, the runtime code returned by the delegatecall is returned, and since\n', '   * we are still in the initialization context, it will be set as the runtime\n', '   * code of the metamorphic contract. The 32-byte metamorphic initialization\n', '   * code is as follows:\n', '   *\n', '   * 0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '   *\n', '   * 00  58  PC               [0]\n', '   * 01  59  MSIZE            [0, 0]\n', '   * 02  38  CODESIZE         [0, 0, codesize -> 32]\n', '   * returndatac03  59  MSIZE            [0, 0, 32, 0]\n', '   * 04  58  PC               [0, 0, 32, 0, 4]\n', '   * 05  60  PUSH1 0x1c       [0, 0, 32, 0, 4, 28]\n', '   * 07  33  CALLER           [0, 0, 32, 0, 4, 28, caller]\n', '   * 08  5a  GAS              [0, 0, 32, 0, 4, 28, caller, gas]\n', '   * 09  58  PC               [0, 0, 32, 0, 4, 28, caller, gas, 9 -> selector]\n', '   * 10  59  MSIZE            [0, 0, 32, 0, 4, 28, caller, gas, selector, 0]\n', '   * 11  52  MSTORE           [0, 0, 32, 0, 4, 28, caller, gas] <selector>\n', '   * 12  fa  STATICCALL       [0, 0, 1 => success] <init_in_runtime_address>\n', '   * 13  15  ISZERO           [0, 0, 0]\n', '   * 14  82  DUP3             [0, 0, 0, 0]\n', '   * 15  83  DUP4             [0, 0, 0, 0, 0]\n', '   * 16  83  DUP4             [0, 0, 0, 0, 0, 0]\n', '   * 17  82  DUP3             [0, 0, 0, 0, 0, 0, 0]\n', '   * 18  51  MLOAD            [0, 0, 0, 0, 0, 0, init_in_runtime_address]\n', '   * 19  5a  GAS              [0, 0, 0, 0, 0, 0, init_in_runtime_address, gas]\n', '   * 20  f4  DELEGATECALL     [0, 0, 1 => success] {runtime_code}\n', '   * 21  3d  RETURNDATASIZE   [0, 0, 1 => success, size]\n', '   * 22  3d  RETURNDATASIZE   [0, 0, 1 => success, size, size]\n', '   * 23  93  SWAP4            [size, 0, 1 => success, size, 0]\n', '   * 24  83  DUP4             [size, 0, 1 => success, size, 0, 0]\n', '   * 25  3e  RETURNDATACOPY   [size, 0, 1 => success] <runtime_code>\n', '   * 26  60  PUSH1 0x1e       [size, 0, 1 => success, 30]\n', '   * 28  57  JUMPI            [size, 0]\n', '   * 29  fd  REVERT           [] *runtime_code*\n', '   * 30  5b  JUMPDEST         [size, 0]\n', '   * 31  f3  RETURN           []\n', '   */\n', '  function _deployToHomeAddress(bytes32 key) internal {\n', '    // Declare a variable for the home address.\n', '    address homeAddress;\n', '\n', '    assembly {\n', '      // Write the 32-byte metamorphic initialization code to scratch space.\n', '      mstore(\n', '        0,\n', '        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\n', '      )\n', '\n', '      // Call `CREATE2` using above init code with the supplied key as the salt.\n', '      homeAddress := create2(callvalue, 0, 32, key)\n', '\n', '      // Pass along revert message if the contract did not deploy successfully.\n', '      if iszero(homeAddress) {\n', '        returndatacopy(0, 0, returndatasize)\n', '        revert(0, returndatasize)\n', '      }\n', '    }\n', '\n', '    // Clear the address of the runtime storage contract from storage.\n', '    delete _initializationRuntimeStorageContract;\n', '\n', '    // Emit an event with home address and key for the newly-deployed contract.\n', '    emit HomeWorkDeployment(homeAddress, key);\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier to disable the contract once deployment is complete.\n', '   */\n', '  modifier onlyUntilDisabled() {\n', '    require(!_disabled, "Contract is disabled.");\n', '    _;\n', '  }\n', '}']