['pragma solidity ^0.4.25;\n', '\n', 'contract ContractResolver {\n', '    bool public locked_forever;\n', '\n', '    function get_contract(bytes32) public view returns (address);\n', '\n', '    function init_register_contract(bytes32, address) public returns (bool);\n', '}\n', '\n', 'contract ResolverClient {\n', '\n', '  /// The address of the resolver contract for this project\n', '  address public resolver;\n', '  bytes32 public key;\n', '\n', '  /// Make our own address available to us as a constant\n', '  address public CONTRACT_ADDRESS;\n', '\n', '  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n', '  /// @param _contract The resolver key\n', '  modifier if_sender_is(bytes32 _contract) {\n', '    require(sender_is(_contract));\n', '    _;\n', '  }\n', '\n', '  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\n', '    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\n', '  }\n', '\n', '  modifier if_sender_is_from(bytes32[3] _contracts) {\n', '    require(sender_is_from(_contracts));\n', '    _;\n', '  }\n', '\n', '  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\n', '    uint256 _n = _contracts.length;\n', '    for (uint256 i = 0; i < _n; i++) {\n', '      if (_contracts[i] == bytes32(0x0)) continue;\n', '      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\n', '        _isFrom = true;\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', "  /// Function modifier to check resolver's locking status.\n", '  modifier unless_resolver_is_locked() {\n', '    require(is_locked() == false);\n', '    _;\n', '  }\n', '\n', '  /// @dev Initialize new contract\n', '  /// @param _key the resolver key for this contract\n', '  /// @return _success if the initialization is successful\n', '  function init(bytes32 _key, address _resolver)\n', '           internal\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(_resolver).locked_forever();\n', '    if (_is_locked == false) {\n', '      CONTRACT_ADDRESS = address(this);\n', '      resolver = _resolver;\n', '      key = _key;\n', '      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n', '      _success = true;\n', '    }  else {\n', '      _success = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Check if resolver is locked\n', '  /// @return _locked if the resolver is currently locked\n', '  function is_locked()\n', '           private\n', '           view\n', '           returns (bool _locked)\n', '  {\n', '    _locked = ContractResolver(resolver).locked_forever();\n', '  }\n', '\n', '  /// @dev Get the address of a contract\n', '  /// @param _key the resolver key to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           view\n', '           returns (address _contract)\n', '  {\n', '    _contract = ContractResolver(resolver).get_contract(_key);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract DaoConstants {\n', '    using SafeMath for uint256;\n', '    bytes32 EMPTY_BYTES = bytes32(0x0);\n', '    address EMPTY_ADDRESS = address(0x0);\n', '\n', '\n', '    bytes32 PROPOSAL_STATE_PREPROPOSAL = "proposal_state_preproposal";\n', '    bytes32 PROPOSAL_STATE_DRAFT = "proposal_state_draft";\n', '    bytes32 PROPOSAL_STATE_MODERATED = "proposal_state_moderated";\n', '    bytes32 PROPOSAL_STATE_ONGOING = "proposal_state_ongoing";\n', '    bytes32 PROPOSAL_STATE_CLOSED = "proposal_state_closed";\n', '    bytes32 PROPOSAL_STATE_ARCHIVED = "proposal_state_archived";\n', '\n', '    uint256 PRL_ACTION_STOP = 1;\n', '    uint256 PRL_ACTION_PAUSE = 2;\n', '    uint256 PRL_ACTION_UNPAUSE = 3;\n', '\n', '    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\n', '    uint256 COLLATERAL_STATUS_LOCKED = 2;\n', '    uint256 COLLATERAL_STATUS_CLAIMED = 3;\n', '\n', '    bytes32 INTERMEDIATE_DGD_IDENTIFIER = "inter_dgd_id";\n', '    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = "inter_mod_dgd_id";\n', '    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = "inter_bonus_calculation_id";\n', '\n', '    // interactive contracts\n', '    bytes32 CONTRACT_DAO = "dao";\n', '    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = "dao:special:proposal";\n', '    bytes32 CONTRACT_DAO_STAKE_LOCKING = "dao:stake-locking";\n', '    bytes32 CONTRACT_DAO_VOTING = "dao:voting";\n', '    bytes32 CONTRACT_DAO_VOTING_CLAIMS = "dao:voting:claims";\n', '    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = "dao:svoting:claims";\n', '    bytes32 CONTRACT_DAO_IDENTITY = "dao:identity";\n', '    bytes32 CONTRACT_DAO_REWARDS_MANAGER = "dao:rewards-manager";\n', '    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = "dao:rewards-extras";\n', '    bytes32 CONTRACT_DAO_ROLES = "dao:roles";\n', '    bytes32 CONTRACT_DAO_FUNDING_MANAGER = "dao:funding-manager";\n', '    bytes32 CONTRACT_DAO_WHITELISTING = "dao:whitelisting";\n', '    bytes32 CONTRACT_DAO_INFORMATION = "dao:information";\n', '\n', '    // service contracts\n', '    bytes32 CONTRACT_SERVICE_ROLE = "service:role";\n', '    bytes32 CONTRACT_SERVICE_DAO_INFO = "service:dao:info";\n', '    bytes32 CONTRACT_SERVICE_DAO_LISTING = "service:dao:listing";\n', '    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = "service:dao:calculator";\n', '\n', '    // storage contracts\n', '    bytes32 CONTRACT_STORAGE_DAO = "storage:dao";\n', '    bytes32 CONTRACT_STORAGE_DAO_COUNTER = "storage:dao:counter";\n', '    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = "storage:dao:upgrade";\n', '    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = "storage:dao:identity";\n', '    bytes32 CONTRACT_STORAGE_DAO_POINTS = "storage:dao:points";\n', '    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = "storage:dao:special";\n', '    bytes32 CONTRACT_STORAGE_DAO_CONFIG = "storage:dao:config";\n', '    bytes32 CONTRACT_STORAGE_DAO_STAKE = "storage:dao:stake";\n', '    bytes32 CONTRACT_STORAGE_DAO_REWARDS = "storage:dao:rewards";\n', '    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = "storage:dao:whitelisting";\n', '    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = "storage:intermediate:results";\n', '\n', '    bytes32 CONTRACT_DGD_TOKEN = "t:dgd";\n', '    bytes32 CONTRACT_DGX_TOKEN = "t:dgx";\n', '    bytes32 CONTRACT_BADGE_TOKEN = "t:badge";\n', '\n', '    uint8 ROLES_ROOT = 1;\n', '    uint8 ROLES_FOUNDERS = 2;\n', '    uint8 ROLES_PRLS = 3;\n', '    uint8 ROLES_KYC_ADMINS = 4;\n', '\n', '    uint256 QUARTER_DURATION = 90 days;\n', '\n', '    bytes32 CONFIG_MINIMUM_LOCKED_DGD = "min_dgd_participant";\n', '    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = "min_dgd_moderator";\n', '    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = "min_reputation_moderator";\n', '\n', '    bytes32 CONFIG_LOCKING_PHASE_DURATION = "locking_phase_duration";\n', '    bytes32 CONFIG_QUARTER_DURATION = "quarter_duration";\n', '    bytes32 CONFIG_VOTING_COMMIT_PHASE = "voting_commit_phase";\n', '    bytes32 CONFIG_VOTING_PHASE_TOTAL = "voting_phase_total";\n', '    bytes32 CONFIG_INTERIM_COMMIT_PHASE = "interim_voting_commit_phase";\n', '    bytes32 CONFIG_INTERIM_PHASE_TOTAL = "interim_voting_phase_total";\n', '\n', '    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = "draft_quorum_fixed_numerator";\n', '    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = "draft_quorum_fixed_denominator";\n', '    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = "draft_quorum_sfactor_numerator";\n', '    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = "draft_quorum_sfactor_denominator";\n', '    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = "vote_quorum_fixed_numerator";\n', '    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = "vote_quorum_fixed_denominator";\n', '    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = "vote_quorum_sfactor_numerator";\n', '    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = "vote_quorum_sfactor_denominator";\n', '    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = "final_reward_sfactor_numerator";\n', '    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = "final_reward_sfactor_denominator";\n', '\n', '    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = "draft_quota_numerator";\n', '    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = "draft_quota_denominator";\n', '    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = "voting_quota_numerator";\n', '    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = "voting_quota_denominator";\n', '\n', '    bytes32 CONFIG_MINIMAL_QUARTER_POINT = "minimal_qp";\n', '    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = "quarter_point_scaling_factor";\n', '    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = "rep_point_scaling_factor";\n', '\n', '    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = "minimal_mod_qp";\n', '    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = "mod_qp_scaling_factor";\n', '    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = "mod_rep_point_scaling_factor";\n', '\n', '    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = "quarter_point_draft_vote";\n', '    bytes32 CONFIG_QUARTER_POINT_VOTE = "quarter_point_vote";\n', '    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = "quarter_point_interim_vote";\n', '\n', '    /// this is per 10000 ETHs\n', '    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = "q_p_milestone_completion";\n', '\n', '    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = "bonus_reputation_numerator";\n', '    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = "bonus_reputation_denominator";\n', '\n', '    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = "special_proposal_commit_phase";\n', '    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = "special_proposal_phase_total";\n', '\n', '    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = "config_special_quota_numerator";\n', '    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = "config_special_quota_denominator";\n', '\n', '    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = "special_quorum_numerator";\n', '    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = "special_quorum_denominator";\n', '\n', '    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = "config_max_reputation_deduction";\n', '    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = "config_punishment_not_locking";\n', '\n', '    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = "config_rep_per_extra_qp_num";\n', '    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = "config_rep_per_extra_qp_den";\n', '\n', '    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = "config_max_m_rp_deduction";\n', '    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = "config_rep_per_extra_m_qp_num";\n', '    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = "config_rep_per_extra_m_qp_den";\n', '\n', '    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = "config_mod_portion_num";\n', '    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = "config_mod_portion_den";\n', '\n', '    bytes32 CONFIG_DRAFT_VOTING_PHASE = "config_draft_voting_phase";\n', '\n', '    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = "config_rp_boost_per_badge";\n', '\n', '    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = "config_claiming_deadline";\n', '\n', '    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = "config_preproposal_collateral";\n', '\n', '    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = "config_max_funding_nonDigix";\n', '    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = "config_max_milestones_nonDigix";\n', '    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = "config_nonDigix_proposal_cap";\n', '\n', '    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = "config_dead_duration";\n', '    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = "config_cv_reputation";\n', '}\n', '\n', 'contract DaoWhitelistingStorage is ResolverClient, DaoConstants {\n', '    mapping (address => bool) public whitelist;\n', '}\n', '\n', 'contract DaoWhitelistingCommon is ResolverClient, DaoConstants {\n', '\n', '    function daoWhitelistingStorage()\n', '        internal\n', '        view\n', '        returns (DaoWhitelistingStorage _contract)\n', '    {\n', '        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\n', '    }\n', '\n', '    /**\n', '    @notice Check if a certain address is whitelisted to read sensitive information in the storage layer\n', '    @dev if the address is an account, it is allowed to read. If the address is a contract, it has to be in the whitelist\n', '    */\n', '    function senderIsAllowedToRead()\n', '        internal\n', '        view\n', '        returns (bool _senderIsAllowedToRead)\n', '    {\n', '        // msg.sender is allowed to read only if its an EOA or a whitelisted contract\n', '        _senderIsAllowedToRead = (msg.sender == tx.origin) || daoWhitelistingStorage().whitelist(msg.sender);\n', '    }\n', '}\n', '\n', 'contract DaoIdentityStorage {\n', '    function read_user_role_id(address) constant public returns (uint256);\n', '\n', '    function is_kyc_approved(address) public view returns (bool);\n', '}\n', '\n', 'contract IdentityCommon is DaoWhitelistingCommon {\n', '\n', '    modifier if_root() {\n', '        require(identity_storage().read_user_role_id(msg.sender) == ROLES_ROOT);\n', '        _;\n', '    }\n', '\n', '    modifier if_founder() {\n', '        require(is_founder());\n', '        _;\n', '    }\n', '\n', '    function is_founder()\n', '        internal\n', '        view\n', '        returns (bool _isFounder)\n', '    {\n', '        _isFounder = identity_storage().read_user_role_id(msg.sender) == ROLES_FOUNDERS;\n', '    }\n', '\n', '    modifier if_prl() {\n', '        require(identity_storage().read_user_role_id(msg.sender) == ROLES_PRLS);\n', '        _;\n', '    }\n', '\n', '    modifier if_kyc_admin() {\n', '        require(identity_storage().read_user_role_id(msg.sender) == ROLES_KYC_ADMINS);\n', '        _;\n', '    }\n', '\n', '    function identity_storage()\n', '        internal\n', '        view\n', '        returns (DaoIdentityStorage _contract)\n', '    {\n', '        _contract = DaoIdentityStorage(get_contract(CONTRACT_STORAGE_DAO_IDENTITY));\n', '    }\n', '}\n', '\n', 'library MathHelper {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256 _max){\n', '      _max = b;\n', '      if (a > b) {\n', '          _max = a;\n', '      }\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256 _min){\n', '      _min = b;\n', '      if (a < b) {\n', '          _min = a;\n', '      }\n', '  }\n', '\n', '  function sumNumbers(uint256[] _numbers) internal pure returns (uint256 _sum) {\n', '      for (uint256 i=0;i<_numbers.length;i++) {\n', '          _sum = _sum.add(_numbers[i]);\n', '      }\n', '  }\n', '}\n', '\n', 'contract DaoListingService {\n', '    function listParticipants(uint256, bool) public view returns (address[]);\n', '\n', '    function listParticipantsFrom(address, uint256, bool) public view returns (address[]);\n', '\n', '    function listModerators(uint256, bool) public view returns (address[]);\n', '\n', '    function listModeratorsFrom(address, uint256, bool) public view returns (address[]);\n', '}\n', '\n', 'contract DaoConfigsStorage {\n', '    mapping (bytes32 => uint256) public uintConfigs;\n', '    mapping (bytes32 => address) public addressConfigs;\n', '    mapping (bytes32 => bytes32) public bytesConfigs;\n', '\n', '    function updateUintConfigs(uint256[]) external;\n', '\n', '    function readUintConfigs() public view returns (uint256[]);\n', '}\n', '\n', 'contract DaoStakeStorage {\n', '    mapping (address => uint256) public lockedDGDStake;\n', '\n', '    function readLastModerator() public view returns (address);\n', '\n', '    function readLastParticipant() public view returns (address);\n', '}\n', '\n', 'contract DaoProposalCounterStorage {\n', '    mapping (uint256 => uint256) public proposalCountByQuarter;\n', '\n', '    function addNonDigixProposalCountInQuarter(uint256) public;\n', '}\n', '\n', 'contract DaoStorage {\n', '    function readProposal(bytes32) public view returns (bytes32, address, address, bytes32, uint256, uint256, bytes32, bytes32, bool, bool);\n', '\n', '    function readProposalProposer(bytes32) public view returns (address);\n', '\n', '    function readProposalDraftVotingResult(bytes32) public view returns (bool);\n', '\n', '    function readProposalVotingResult(bytes32, uint256) public view returns (bool);\n', '\n', '    function readProposalDraftVotingTime(bytes32) public view returns (uint256);\n', '\n', '    function readProposalVotingTime(bytes32, uint256) public view returns (uint256);\n', '\n', '    function readVote(bytes32, uint256, address) public view returns (bool, uint256);\n', '\n', '    function readVotingCount(bytes32, uint256, address[]) external view returns (uint256, uint256);\n', '\n', '    function isDraftClaimed(bytes32) public view returns (bool);\n', '\n', '    function isClaimed(bytes32, uint256) public view returns (bool);\n', '\n', '    function setProposalDraftPass(bytes32, bool) public;\n', '\n', '    function setDraftVotingClaim(bytes32, bool) public;\n', '\n', '    function readDraftVotingCount(bytes32, address[]) external view returns (uint256, uint256);\n', '\n', '    function setProposalVotingTime(bytes32, uint256, uint256) public;\n', '\n', '    function setProposalCollateralStatus(bytes32, uint256) public;\n', '\n', '    function setVotingClaim(bytes32, uint256, bool) public;\n', '\n', '    function setProposalPass(bytes32, uint256, bool) public;\n', '\n', '    function readProposalFunding(bytes32) public view returns (uint256[] memory, uint256);\n', '\n', '    function archiveProposal(bytes32) public;\n', '\n', '    function readProposalMilestone(bytes32, uint256) public view returns (uint256);\n', '\n', '    function readVotingRoundVotes(bytes32, uint256, address[], bool) external view returns (address[] memory, uint256);\n', '\n', '    function addProposal(bytes32, address, uint256[], uint256, bool) external;\n', '\n', '    function setProposalCollateralAmount(bytes32, uint256) public;\n', '\n', '    function editProposal(bytes32, bytes32, uint256[], uint256) external;\n', '\n', '    function changeFundings(bytes32, uint256[], uint256) external;\n', '\n', '    function finalizeProposal(bytes32) public;\n', '\n', '    function setProposalDraftVotingTime(bytes32, uint256) public;\n', '\n', '    function addProposalDoc(bytes32, bytes32) public;\n', '\n', '    function updateProposalEndorse(bytes32, address) public;\n', '\n', '    function updateProposalPRL(bytes32, uint256, bytes32, uint256) public;\n', '\n', '    function readProposalCollateralStatus(bytes32) public view returns (uint256);\n', '\n', '    function closeProposal(bytes32) public;\n', '}\n', '\n', 'contract DaoUpgradeStorage {\n', '    address public newDaoContract;\n', '    address public newDaoFundingManager;\n', '    address public newDaoRewardsManager;\n', '    uint256 public startOfFirstQuarter;\n', '    bool public isReplacedByNewDao;\n', '\n', '    function setStartOfFirstQuarter(uint256) public;\n', '\n', '    function setNewContractAddresses(address, address, address) public;\n', '\n', '    function updateForDaoMigration() public;\n', '}\n', '\n', 'contract DaoSpecialStorage {\n', '    function readProposalProposer(bytes32) public view returns (address);\n', '\n', '    function readConfigs(bytes32) public view returns (uint256[] memory, address[] memory, bytes32[] memory);\n', '\n', '    function readVotingCount(bytes32, address[]) external view returns (uint256, uint256);\n', '\n', '    function readVotingTime(bytes32) public view returns (uint256);\n', '\n', '    function setPass(bytes32, bool) public;\n', '\n', '    function setVotingClaim(bytes32, bool) public;\n', '\n', '    function isClaimed(bytes32) public view returns (bool);\n', '\n', '    function readVote(bytes32, address) public view returns (bool, uint256);\n', '}\n', '\n', 'contract DaoPointsStorage {\n', '  function getReputation(address) public view returns (uint256);\n', '\n', '  function addQuarterPoint(address, uint256, uint256) public returns (uint256, uint256);\n', '\n', '  function increaseReputation(address, uint256) public returns (uint256, uint256);\n', '}\n', '\n', 'contract DaoRewardsStorage {\n', '    mapping (address => uint256) public lastParticipatedQuarter;\n', '\n', '    function readDgxDistributionDay(uint256) public view returns (uint256);\n', '}\n', '\n', 'contract IntermediateResultsStorage {\n', '    function getIntermediateResults(bytes32) public view returns (address, uint256, uint256, uint256);\n', '\n', '    function setIntermediateResults(bytes32, address, uint256, uint256, uint256) public;\n', '\n', '    function resetIntermediateResults(bytes32) public;\n', '}\n', '\n', 'contract DaoCommonMini is IdentityCommon {\n', '\n', '    using MathHelper for MathHelper;\n', '\n', '    /**\n', '    @notice Check if the DAO contracts have been replaced by a new set of contracts\n', '    @return _isNotReplaced true if it is not replaced, false if it has already been replaced\n', '    */\n', '    function isDaoNotReplaced()\n', '        public\n', '        view\n', '        returns (bool _isNotReplaced)\n', '    {\n', '        _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao();\n', '    }\n', '\n', '    /**\n', '    @notice Check if it is currently in the locking phase\n', '    @dev No governance activities can happen in the locking phase. The locking phase is from t=0 to t=CONFIG_LOCKING_PHASE_DURATION-1\n', '    @return _isLockingPhase true if it is in the locking phase\n', '    */\n', '    function isLockingPhase()\n', '        public\n', '        view\n', '        returns (bool _isLockingPhase)\n', '    {\n', '        _isLockingPhase = currentTimeInQuarter() < getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\n', '    }\n', '\n', '    /**\n', '    @notice Check if it is currently in a main phase.\n', '    @dev The main phase is where all the governance activities could take plase. If the DAO is replaced, there can never be any more main phase.\n', '    @return _isMainPhase true if it is in a main phase\n', '    */\n', '    function isMainPhase()\n', '        public\n', '        view\n', '        returns (bool _isMainPhase)\n', '    {\n', '        _isMainPhase =\n', '            isDaoNotReplaced() &&\n', '            currentTimeInQuarter() >= getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\n', '    }\n', '\n', '    /**\n', '    @notice Check if the calculateGlobalRewardsBeforeNewQuarter function has been done for a certain quarter\n', '    @dev However, there is no need to run calculateGlobalRewardsBeforeNewQuarter for the first quarter\n', '    */\n', '    modifier ifGlobalRewardsSet(uint256 _quarterNumber) {\n', '        if (_quarterNumber > 1) {\n', '            require(daoRewardsStorage().readDgxDistributionDay(_quarterNumber) > 0);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '    @notice require that it is currently during a phase, which is within _relativePhaseStart and _relativePhaseEnd seconds, after the _startingPoint\n', '    */\n', '    function requireInPhase(uint256 _startingPoint, uint256 _relativePhaseStart, uint256 _relativePhaseEnd)\n', '        internal\n', '        view\n', '    {\n', '        require(_startingPoint > 0);\n', '        require(now < _startingPoint.add(_relativePhaseEnd));\n', '        require(now >= _startingPoint.add(_relativePhaseStart));\n', '    }\n', '\n', '    /**\n', '    @notice Get the current quarter index\n', '    @dev Quarter indexes starts from 1\n', '    @return _quarterNumber the current quarter index\n', '    */\n', '    function currentQuarterNumber()\n', '        public\n', '        view\n', '        returns(uint256 _quarterNumber)\n', '    {\n', '        _quarterNumber = getQuarterNumber(now);\n', '    }\n', '\n', '    /**\n', '    @notice Get the quarter index of a timestamp\n', '    @dev Quarter indexes starts from 1\n', '    @return _index the quarter index\n', '    */\n', '    function getQuarterNumber(uint256 _time)\n', '        internal\n', '        view\n', '        returns (uint256 _index)\n', '    {\n', '        require(startOfFirstQuarterIsSet());\n', '        _index =\n', '            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\n', '            .div(getUintConfig(CONFIG_QUARTER_DURATION))\n', '            .add(1);\n', '    }\n', '\n', '    /**\n', '    @notice Get the relative time in quarter of a timestamp\n', '    @dev For example, the timeInQuarter of the first second of any quarter n-th is always 1\n', '    */\n', '    function timeInQuarter(uint256 _time)\n', '        internal\n', '        view\n', '        returns (uint256 _timeInQuarter)\n', '    {\n', '        require(startOfFirstQuarterIsSet()); // must be already set\n', '        _timeInQuarter =\n', '            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\n', '            % getUintConfig(CONFIG_QUARTER_DURATION);\n', '    }\n', '\n', '    /**\n', '    @notice Check if the start of first quarter is already set\n', '    @return _isSet true if start of first quarter is already set\n', '    */\n', '    function startOfFirstQuarterIsSet()\n', '        internal\n', '        view\n', '        returns (bool _isSet)\n', '    {\n', '        _isSet = daoUpgradeStorage().startOfFirstQuarter() != 0;\n', '    }\n', '\n', '    /**\n', '    @notice Get the current relative time in the quarter\n', '    @dev For example: the currentTimeInQuarter of the first second of any quarter is 1\n', '    @return _currentT the current relative time in the quarter\n', '    */\n', '    function currentTimeInQuarter()\n', '        public\n', '        view\n', '        returns (uint256 _currentT)\n', '    {\n', '        _currentT = timeInQuarter(now);\n', '    }\n', '\n', '    /**\n', '    @notice Get the time remaining in the quarter\n', '    */\n', '    function getTimeLeftInQuarter(uint256 _time)\n', '        internal\n', '        view\n', '        returns (uint256 _timeLeftInQuarter)\n', '    {\n', '        _timeLeftInQuarter = getUintConfig(CONFIG_QUARTER_DURATION).sub(timeInQuarter(_time));\n', '    }\n', '\n', '    function daoListingService()\n', '        internal\n', '        view\n', '        returns (DaoListingService _contract)\n', '    {\n', '        _contract = DaoListingService(get_contract(CONTRACT_SERVICE_DAO_LISTING));\n', '    }\n', '\n', '    function daoConfigsStorage()\n', '        internal\n', '        view\n', '        returns (DaoConfigsStorage _contract)\n', '    {\n', '        _contract = DaoConfigsStorage(get_contract(CONTRACT_STORAGE_DAO_CONFIG));\n', '    }\n', '\n', '    function daoStakeStorage()\n', '        internal\n', '        view\n', '        returns (DaoStakeStorage _contract)\n', '    {\n', '        _contract = DaoStakeStorage(get_contract(CONTRACT_STORAGE_DAO_STAKE));\n', '    }\n', '\n', '    function daoStorage()\n', '        internal\n', '        view\n', '        returns (DaoStorage _contract)\n', '    {\n', '        _contract = DaoStorage(get_contract(CONTRACT_STORAGE_DAO));\n', '    }\n', '\n', '    function daoProposalCounterStorage()\n', '        internal\n', '        view\n', '        returns (DaoProposalCounterStorage _contract)\n', '    {\n', '        _contract = DaoProposalCounterStorage(get_contract(CONTRACT_STORAGE_DAO_COUNTER));\n', '    }\n', '\n', '    function daoUpgradeStorage()\n', '        internal\n', '        view\n', '        returns (DaoUpgradeStorage _contract)\n', '    {\n', '        _contract = DaoUpgradeStorage(get_contract(CONTRACT_STORAGE_DAO_UPGRADE));\n', '    }\n', '\n', '    function daoSpecialStorage()\n', '        internal\n', '        view\n', '        returns (DaoSpecialStorage _contract)\n', '    {\n', '        _contract = DaoSpecialStorage(get_contract(CONTRACT_STORAGE_DAO_SPECIAL));\n', '    }\n', '\n', '    function daoPointsStorage()\n', '        internal\n', '        view\n', '        returns (DaoPointsStorage _contract)\n', '    {\n', '        _contract = DaoPointsStorage(get_contract(CONTRACT_STORAGE_DAO_POINTS));\n', '    }\n', '\n', '    function daoRewardsStorage()\n', '        internal\n', '        view\n', '        returns (DaoRewardsStorage _contract)\n', '    {\n', '        _contract = DaoRewardsStorage(get_contract(CONTRACT_STORAGE_DAO_REWARDS));\n', '    }\n', '\n', '    function intermediateResultsStorage()\n', '        internal\n', '        view\n', '        returns (IntermediateResultsStorage _contract)\n', '    {\n', '        _contract = IntermediateResultsStorage(get_contract(CONTRACT_STORAGE_INTERMEDIATE_RESULTS));\n', '    }\n', '\n', '    function getUintConfig(bytes32 _configKey)\n', '        public\n', '        view\n', '        returns (uint256 _configValue)\n', '    {\n', '        _configValue = daoConfigsStorage().uintConfigs(_configKey);\n', '    }\n', '}\n', '\n', 'contract DaoCommon is DaoCommonMini {\n', '\n', '    using MathHelper for MathHelper;\n', '\n', '    /**\n', '    @notice Check if the transaction is called by the proposer of a proposal\n', '    @return _isFromProposer true if the caller is the proposer\n', '    */\n', '    function isFromProposer(bytes32 _proposalId)\n', '        internal\n', '        view\n', '        returns (bool _isFromProposer)\n', '    {\n', '        _isFromProposer = msg.sender == daoStorage().readProposalProposer(_proposalId);\n', '    }\n', '\n', '    /**\n', '    @notice Check if the proposal can still be "editted", or in other words, added more versions\n', '    @dev Once the proposal is finalized, it can no longer be editted. The proposer will still be able to add docs and change fundings though.\n', '    @return _isEditable true if the proposal is editable\n', '    */\n', '    function isEditable(bytes32 _proposalId)\n', '        internal\n', '        view\n', '        returns (bool _isEditable)\n', '    {\n', '        bytes32 _finalVersion;\n', '        (,,,,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n', '        _isEditable = _finalVersion == EMPTY_BYTES;\n', '    }\n', '\n', '    /**\n', '    @notice returns the balance of DaoFundingManager, which is the wei in DigixDAO\n', '    */\n', '    function weiInDao()\n', '        internal\n', '        view\n', '        returns (uint256 _wei)\n', '    {\n', '        _wei = get_contract(CONTRACT_DAO_FUNDING_MANAGER).balance;\n', '    }\n', '\n', '    /**\n', '    @notice Check if it is after the draft voting phase of the proposal\n', '    */\n', '    modifier ifAfterDraftVotingPhase(bytes32 _proposalId) {\n', '        uint256 _start = daoStorage().readProposalDraftVotingTime(_proposalId);\n', '        require(_start > 0); // Draft voting must have started. In other words, proposer must have finalized the proposal\n', '        require(now >= _start.add(getUintConfig(CONFIG_DRAFT_VOTING_PHASE)));\n', '        _;\n', '    }\n', '\n', '    modifier ifCommitPhase(bytes32 _proposalId, uint8 _index) {\n', '        requireInPhase(\n', '            daoStorage().readProposalVotingTime(_proposalId, _index),\n', '            0,\n', '            getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier ifRevealPhase(bytes32 _proposalId, uint256 _index) {\n', '      requireInPhase(\n', '          daoStorage().readProposalVotingTime(_proposalId, _index),\n', '          getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE),\n', '          getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)\n', '      );\n', '      _;\n', '    }\n', '\n', '    modifier ifAfterProposalRevealPhase(bytes32 _proposalId, uint256 _index) {\n', '      uint256 _start = daoStorage().readProposalVotingTime(_proposalId, _index);\n', '      require(_start > 0);\n', '      require(now >= _start.add(getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)));\n', '      _;\n', '    }\n', '\n', '    modifier ifDraftVotingPhase(bytes32 _proposalId) {\n', '        requireInPhase(\n', '            daoStorage().readProposalDraftVotingTime(_proposalId),\n', '            0,\n', '            getUintConfig(CONFIG_DRAFT_VOTING_PHASE)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier isProposalState(bytes32 _proposalId, bytes32 _STATE) {\n', '        bytes32 _currentState;\n', '        (,,,_currentState,,,,,,) = daoStorage().readProposal(_proposalId);\n', '        require(_currentState == _STATE);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    @notice Check if the DAO has enough ETHs for a particular funding request\n', '    */\n', '    modifier ifFundingPossible(uint256[] _fundings, uint256 _finalReward) {\n', '        require(MathHelper.sumNumbers(_fundings).add(_finalReward) <= weiInDao());\n', '        _;\n', '    }\n', '\n', '    modifier ifDraftNotClaimed(bytes32 _proposalId) {\n', '        require(daoStorage().isDraftClaimed(_proposalId) == false);\n', '        _;\n', '    }\n', '\n', '    modifier ifNotClaimed(bytes32 _proposalId, uint256 _index) {\n', '        require(daoStorage().isClaimed(_proposalId, _index) == false);\n', '        _;\n', '    }\n', '\n', '    modifier ifNotClaimedSpecial(bytes32 _proposalId) {\n', '        require(daoSpecialStorage().isClaimed(_proposalId) == false);\n', '        _;\n', '    }\n', '\n', '    modifier hasNotRevealed(bytes32 _proposalId, uint256 _index) {\n', '        uint256 _voteWeight;\n', '        (, _voteWeight) = daoStorage().readVote(_proposalId, _index, msg.sender);\n', '        require(_voteWeight == uint(0));\n', '        _;\n', '    }\n', '\n', '    modifier hasNotRevealedSpecial(bytes32 _proposalId) {\n', '        uint256 _weight;\n', '        (,_weight) = daoSpecialStorage().readVote(_proposalId, msg.sender);\n', '        require(_weight == uint256(0));\n', '        _;\n', '    }\n', '\n', '    modifier ifAfterRevealPhaseSpecial(bytes32 _proposalId) {\n', '      uint256 _start = daoSpecialStorage().readVotingTime(_proposalId);\n', '      require(_start > 0);\n', '      require(now.sub(_start) >= getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL));\n', '      _;\n', '    }\n', '\n', '    modifier ifCommitPhaseSpecial(bytes32 _proposalId) {\n', '        requireInPhase(\n', '            daoSpecialStorage().readVotingTime(_proposalId),\n', '            0,\n', '            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier ifRevealPhaseSpecial(bytes32 _proposalId) {\n', '        requireInPhase(\n', '            daoSpecialStorage().readVotingTime(_proposalId),\n', '            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE),\n', '            getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL)\n', '        );\n', '        _;\n', '    }\n', '\n', '    function daoWhitelistingStorage()\n', '        internal\n', '        view\n', '        returns (DaoWhitelistingStorage _contract)\n', '    {\n', '        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\n', '    }\n', '\n', '    function getAddressConfig(bytes32 _configKey)\n', '        public\n', '        view\n', '        returns (address _configValue)\n', '    {\n', '        _configValue = daoConfigsStorage().addressConfigs(_configKey);\n', '    }\n', '\n', '    function getBytesConfig(bytes32 _configKey)\n', '        public\n', '        view\n', '        returns (bytes32 _configValue)\n', '    {\n', '        _configValue = daoConfigsStorage().bytesConfigs(_configKey);\n', '    }\n', '\n', '    /**\n', '    @notice Check if a user is a participant in the current quarter\n', '    */\n', '    function isParticipant(address _user)\n', '        public\n', '        view\n', '        returns (bool _is)\n', '    {\n', '        _is =\n', '            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\n', '            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_LOCKED_DGD));\n', '    }\n', '\n', '    /**\n', '    @notice Check if a user is a moderator in the current quarter\n', '    */\n', '    function isModerator(address _user)\n', '        public\n', '        view\n', '        returns (bool _is)\n', '    {\n', '        _is =\n', '            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\n', '            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_DGD_FOR_MODERATOR))\n', '            && (daoPointsStorage().getReputation(_user) >= getUintConfig(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR));\n', '    }\n', '\n', '    /**\n', '    @notice Calculate the start of a specific milestone of a specific proposal.\n', '    @dev This is calculated from the voting start of the voting round preceding the milestone\n', '         This would throw if the voting start is 0 (the voting round has not started yet)\n', '         Note that if the milestoneIndex is exactly the same as the number of milestones,\n', '         This will just return the end of the last voting round.\n', '    */\n', '    function startOfMilestone(bytes32 _proposalId, uint256 _milestoneIndex)\n', '        internal\n', '        view\n', '        returns (uint256 _milestoneStart)\n', '    {\n', '        uint256 _startOfPrecedingVotingRound = daoStorage().readProposalVotingTime(_proposalId, _milestoneIndex);\n', '        require(_startOfPrecedingVotingRound > 0);\n', '        // the preceding voting round must have started\n', '\n', '        if (_milestoneIndex == 0) { // This is the 1st milestone, which starts after voting round 0\n', '            _milestoneStart =\n', '                _startOfPrecedingVotingRound\n', '                .add(getUintConfig(CONFIG_VOTING_PHASE_TOTAL));\n', '        } else { // if its the n-th milestone, it starts after voting round n-th\n', '            _milestoneStart =\n', '                _startOfPrecedingVotingRound\n', '                .add(getUintConfig(CONFIG_INTERIM_PHASE_TOTAL));\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Calculate the actual voting start for a voting round, given the tentative start\n', '    @dev The tentative start is the ideal start. For example, when a proposer finish a milestone, it should be now\n', '         However, sometimes the tentative start is too close to the end of the quarter, hence, the actual voting start should be pushed to the next quarter\n', '    */\n', '    function getTimelineForNextVote(\n', '        uint256 _index,\n', '        uint256 _tentativeVotingStart\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256 _actualVotingStart)\n', '    {\n', '        uint256 _timeLeftInQuarter = getTimeLeftInQuarter(_tentativeVotingStart);\n', '        uint256 _votingDuration = getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL);\n', '        _actualVotingStart = _tentativeVotingStart;\n', '        if (timeInQuarter(_tentativeVotingStart) < getUintConfig(CONFIG_LOCKING_PHASE_DURATION)) { // if the tentative start is during a locking phase\n', '            _actualVotingStart = _tentativeVotingStart.add(\n', '                getUintConfig(CONFIG_LOCKING_PHASE_DURATION).sub(timeInQuarter(_tentativeVotingStart))\n', '            );\n', '        } else if (_timeLeftInQuarter < _votingDuration.add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE))) { // if the time left in quarter is not enough to vote and claim voting\n', '            _actualVotingStart = _tentativeVotingStart.add(\n', '                _timeLeftInQuarter.add(getUintConfig(CONFIG_LOCKING_PHASE_DURATION)).add(1)\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Check if we can add another non-Digix proposal in this quarter\n', '    @dev There is a max cap to the number of non-Digix proposals CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER\n', '    */\n', '    function checkNonDigixProposalLimit(bytes32 _proposalId)\n', '        internal\n', '        view\n', '    {\n', '        require(isNonDigixProposalsWithinLimit(_proposalId));\n', '    }\n', '\n', '    function isNonDigixProposalsWithinLimit(bytes32 _proposalId)\n', '        internal\n', '        view\n', '        returns (bool _withinLimit)\n', '    {\n', '        bool _isDigixProposal;\n', '        (,,,,,,,,,_isDigixProposal) = daoStorage().readProposal(_proposalId);\n', '        _withinLimit = true;\n', '        if (!_isDigixProposal) {\n', '            _withinLimit = daoProposalCounterStorage().proposalCountByQuarter(currentQuarterNumber()) < getUintConfig(CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice If its a non-Digix proposal, check if the fundings are within limit\n', '    @dev There is a max cap to the fundings and number of milestones for non-Digix proposals\n', '    */\n', '    function checkNonDigixFundings(uint256[] _milestonesFundings, uint256 _finalReward)\n', '        internal\n', '        view\n', '    {\n', '        if (!is_founder()) {\n', '            require(_milestonesFundings.length <= getUintConfig(CONFIG_MAX_MILESTONES_FOR_NON_DIGIX));\n', '            require(MathHelper.sumNumbers(_milestonesFundings).add(_finalReward) <= getUintConfig(CONFIG_MAX_FUNDING_FOR_NON_DIGIX));\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Check if msg.sender can do operations as a proposer\n', '    @dev Note that this function does not check if he is the proposer of the proposal\n', '    */\n', '    function senderCanDoProposerOperations()\n', '        internal\n', '        view\n', '    {\n', '        require(isMainPhase());\n', '        require(isParticipant(msg.sender));\n', '        require(identity_storage().is_kyc_approved(msg.sender));\n', '    }\n', '}\n', '\n', 'library DaoIntermediateStructs {\n', '    struct VotingCount {\n', '        // weight of votes "FOR" the voting round\n', '        uint256 forCount;\n', '        // weight of votes "AGAINST" the voting round\n', '        uint256 againstCount;\n', '    }\n', '\n', '    // Struct used in large functions to cut down on variables\n', '    struct Users {\n', '        // Length of the above list\n', '        uint256 usersLength;\n', '        // List of addresses, participants of DigixDAO\n', '        address[] users;\n', '    }\n', '}\n', '\n', 'library DaoStructs {\n', '    struct IntermediateResults {\n', '        // weight of "FOR" votes counted up until the current calculation step\n', '        uint256 currentForCount;\n', '\n', '        // weight of "AGAINST" votes counted up until the current calculation step\n', '        uint256 currentAgainstCount;\n', '\n', '        // summation of effectiveDGDs up until the iteration of calculation\n', '        uint256 currentSumOfEffectiveBalance;\n', '\n', '        // Address of user until which the calculation has been done\n', '        address countedUntil;\n', '    }\n', '}\n', '\n', 'contract DaoCalculatorService {\n', '    function minimumVotingQuorumForSpecial() public view returns (uint256);\n', '\n', '    function votingQuotaForSpecialPass(uint256, uint256) public view returns (bool);\n', '\n', '    function minimumDraftQuorum(bytes32) public view returns (uint256);\n', '\n', '    function draftQuotaPass(uint256, uint256) public view returns (bool);\n', '\n', '    function minimumVotingQuorum(bytes32, uint256) public view returns (uint256);\n', '\n', '    function votingQuotaPass(uint256, uint256) public view returns (bool);\n', '}\n', '\n', 'contract DaoFundingManager {\n', '    function refundCollateral(address, bytes32) public returns (bool);\n', '\n', '    function moveFundsToNewDao(address) public;\n', '}\n', '\n', 'contract DaoRewardsManager {\n', '    function moveDGXsToNewDao(address) public;\n', '}\n', '\n', 'contract DaoVotingClaims {\n', '}\n', '\n', '/**\n', '@title Interactive DAO contract for creating/modifying/endorsing proposals\n', '@author Digix Holdings\n', '*/\n', 'contract Dao is DaoCommon {\n', '\n', '    event NewProposal(bytes32 indexed _proposalId, address _proposer);\n', '    event ModifyProposal(bytes32 indexed _proposalId, bytes32 _newDoc);\n', '    event ChangeProposalFunding(bytes32 indexed _proposalId);\n', '    event FinalizeProposal(bytes32 indexed _proposalId);\n', '    event FinishMilestone(bytes32 indexed _proposalId, uint256 indexed _milestoneIndex);\n', '    event AddProposalDoc(bytes32 indexed _proposalId, bytes32 _newDoc);\n', '    event PRLAction(bytes32 indexed _proposalId, uint256 _actionId, bytes32 _doc);\n', '    event CloseProposal(bytes32 indexed _proposalId);\n', '    event MigrateToNewDao(address _newDaoContract, address _newDaoFundingManager, address _newDaoRewardsManager);\n', '\n', '    constructor(address _resolver) public {\n', '        require(init(CONTRACT_DAO, _resolver));\n', '    }\n', '\n', '    function daoFundingManager()\n', '        internal\n', '        view\n', '        returns (DaoFundingManager _contract)\n', '    {\n', '        _contract = DaoFundingManager(get_contract(CONTRACT_DAO_FUNDING_MANAGER));\n', '    }\n', '\n', '    function daoRewardsManager()\n', '        internal\n', '        view\n', '        returns (DaoRewardsManager _contract)\n', '    {\n', '        _contract = DaoRewardsManager(get_contract(CONTRACT_DAO_REWARDS_MANAGER));\n', '    }\n', '\n', '    function daoVotingClaims()\n', '        internal\n', '        view\n', '        returns (DaoVotingClaims _contract)\n', '    {\n', '        _contract = DaoVotingClaims(get_contract(CONTRACT_DAO_VOTING_CLAIMS));\n', '    }\n', '\n', '    /**\n', '    @notice Set addresses for the new Dao and DaoFundingManager contracts\n', '    @dev This is the first step of the 2-step migration\n', '    @param _newDaoContract Address of the new Dao contract\n', '    @param _newDaoFundingManager Address of the new DaoFundingManager contract\n', '    @param _newDaoRewardsManager Address of the new daoRewardsManager contract\n', '    */\n', '    function setNewDaoContracts(\n', '        address _newDaoContract,\n', '        address _newDaoFundingManager,\n', '        address _newDaoRewardsManager\n', '    )\n', '        public\n', '        if_root()\n', '    {\n', '        require(daoUpgradeStorage().isReplacedByNewDao() == false);\n', '        daoUpgradeStorage().setNewContractAddresses(\n', '            _newDaoContract,\n', '            _newDaoFundingManager,\n', '            _newDaoRewardsManager\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Migrate this DAO to a new DAO contract\n', '    @dev This is the second step of the 2-step migration\n', '         Migration can only be done during the locking phase, after the global rewards for current quarter are set.\n', '         This is to make sure that there is no rewards calculation pending before the DAO is migrated to new contracts\n', '         The addresses of the new Dao contracts have to be provided again, and be double checked against the addresses that were set in setNewDaoContracts()\n', '    @param _newDaoContract Address of the new DAO contract\n', '    @param _newDaoFundingManager Address of the new DaoFundingManager contract, which would receive the remaining ETHs in this DaoFundingManager\n', '    @param _newDaoRewardsManager Address of the new daoRewardsManager contract, which would receive the claimableDGXs from this daoRewardsManager\n', '    */\n', '    function migrateToNewDao(\n', '        address _newDaoContract,\n', '        address _newDaoFundingManager,\n', '        address _newDaoRewardsManager\n', '    )\n', '        public\n', '        if_root()\n', '        ifGlobalRewardsSet(currentQuarterNumber())\n', '    {\n', '        require(isLockingPhase());\n', '        require(daoUpgradeStorage().isReplacedByNewDao() == false);\n', '        require(\n', '          (daoUpgradeStorage().newDaoContract() == _newDaoContract) &&\n', '          (daoUpgradeStorage().newDaoFundingManager() == _newDaoFundingManager) &&\n', '          (daoUpgradeStorage().newDaoRewardsManager() == _newDaoRewardsManager)\n', '        );\n', '        daoUpgradeStorage().updateForDaoMigration();\n', '        daoFundingManager().moveFundsToNewDao(_newDaoFundingManager);\n', '        daoRewardsManager().moveDGXsToNewDao(_newDaoRewardsManager);\n', '        emit MigrateToNewDao(_newDaoContract, _newDaoFundingManager, _newDaoRewardsManager);\n', '    }\n', '\n', '    /**\n', "    @notice Call this function to mark the start of the DAO's first quarter. This can only be done once, by a founder\n", '    @param _start Start time of the first quarter in the DAO\n', '    */\n', '    function setStartOfFirstQuarter(uint256 _start) public if_founder() {\n', '        require(daoUpgradeStorage().startOfFirstQuarter() == 0);\n', '        require(_start > now);\n', '        daoUpgradeStorage().setStartOfFirstQuarter(_start);\n', '    }\n', '\n', '    /**\n', '    @notice Submit a new preliminary idea / Pre-proposal\n', '    @dev The proposer has to send in a collateral == getUintConfig(CONFIG_PREPROPOSAL_COLLATERAL)\n', '         which he could claim back in these scenarios:\n', '          - Before the proposal is finalized, by calling closeProposal()\n', '          - After all milestones are done and the final voting round is passed\n', '\n', '    @param _docIpfsHash Hash of the IPFS doc containing details of proposal\n', '    @param _milestonesFundings Array of fundings of the proposal milestones (in wei)\n', '    @param _finalReward Final reward asked by proposer at successful completion of all milestones of proposal\n', '    */\n', '    function submitPreproposal(\n', '        bytes32 _docIpfsHash,\n', '        uint256[] _milestonesFundings,\n', '        uint256 _finalReward\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        senderCanDoProposerOperations();\n', '        bool _isFounder = is_founder();\n', '\n', '        require(MathHelper.sumNumbers(_milestonesFundings).add(_finalReward) <= weiInDao());\n', '\n', '        require(msg.value == getUintConfig(CONFIG_PREPROPOSAL_COLLATERAL));\n', '        require(address(daoFundingManager()).call.gas(25000).value(msg.value)());\n', '\n', '        checkNonDigixFundings(_milestonesFundings, _finalReward);\n', '\n', '        daoStorage().addProposal(_docIpfsHash, msg.sender, _milestonesFundings, _finalReward, _isFounder);\n', '        daoStorage().setProposalCollateralStatus(_docIpfsHash, COLLATERAL_STATUS_UNLOCKED);\n', '        daoStorage().setProposalCollateralAmount(_docIpfsHash, msg.value);\n', '\n', '        emit NewProposal(_docIpfsHash, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Modify a proposal (this can be done only before setting the final version)\n', '    @param _proposalId Proposal ID (hash of IPFS doc of the first version of the proposal)\n', '    @param _docIpfsHash Hash of IPFS doc of the modified version of the proposal\n', '    @param _milestonesFundings Array of fundings of the modified version of the proposal (in wei)\n', '    @param _finalReward Final reward on successful completion of all milestones of the modified version of proposal (in wei)\n', '    */\n', '    function modifyProposal(\n', '        bytes32 _proposalId,\n', '        bytes32 _docIpfsHash,\n', '        uint256[] _milestonesFundings,\n', '        uint256 _finalReward\n', '    )\n', '        external\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '\n', '        require(isEditable(_proposalId));\n', '        bytes32 _currentState;\n', '        (,,,_currentState,,,,,,) = daoStorage().readProposal(_proposalId);\n', '        require(_currentState == PROPOSAL_STATE_PREPROPOSAL ||\n', '          _currentState == PROPOSAL_STATE_DRAFT);\n', '\n', '        checkNonDigixFundings(_milestonesFundings, _finalReward);\n', '\n', '        daoStorage().editProposal(_proposalId, _docIpfsHash, _milestonesFundings, _finalReward);\n', '\n', '        emit ModifyProposal(_proposalId, _docIpfsHash);\n', '    }\n', '\n', '    /**\n', '    @notice Function to change the funding structure for a proposal\n', '    @dev Proposers can only change fundings for the subsequent milestones,\n', '    during the duration of an on-going milestone (so, cannot be before proposal finalization or during any voting phase)\n', '    @param _proposalId ID of the proposal\n', '    @param _milestonesFundings Array of fundings for milestones\n', '    @param _finalReward Final reward needed for completion of proposal\n', '    @param _currentMilestone the milestone number the proposal is currently in\n', '    */\n', '    function changeFundings(\n', '        bytes32 _proposalId,\n', '        uint256[] _milestonesFundings,\n', '        uint256 _finalReward,\n', '        uint256 _currentMilestone\n', '    )\n', '        external\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '\n', '        checkNonDigixFundings(_milestonesFundings, _finalReward);\n', '\n', '        uint256[] memory _currentFundings;\n', '        (_currentFundings,) = daoStorage().readProposalFunding(_proposalId);\n', '\n', '        // If there are N milestones, the milestone index must be < N. Otherwise, putting a milestone index of N will actually return a valid timestamp that is\n', '        // right after the final voting round (voting round index N is the final voting round)\n', '        // Which could be abused ( to add more milestones even after the final voting round)\n', '        require(_currentMilestone < _currentFundings.length);\n', '\n', '        uint256 _startOfCurrentMilestone = startOfMilestone(_proposalId, _currentMilestone);\n', '\n', '        // must be after the start of the milestone, and the milestone has not been finished yet (next voting hasnt started)\n', '        require(now > _startOfCurrentMilestone);\n', '        require(daoStorage().readProposalVotingTime(_proposalId, _currentMilestone.add(1)) == 0);\n', '\n', '        // can only modify the fundings after _currentMilestone\n', '        // so, all the fundings from 0 to _currentMilestone must be the same\n', '        for (uint256 i=0;i<=_currentMilestone;i++) {\n', '            require(_milestonesFundings[i] == _currentFundings[i]);\n', '        }\n', '\n', '        daoStorage().changeFundings(_proposalId, _milestonesFundings, _finalReward);\n', '\n', '        emit ChangeProposalFunding(_proposalId);\n', '    }\n', '\n', '    /**\n', '    @notice Finalize a proposal\n', '    @dev After finalizing a proposal, no more proposal version can be added. Proposer will only be able to change fundings and add more docs\n', '         Right after finalizing a proposal, the draft voting round starts. The proposer would also not be able to closeProposal() anymore\n', '         (hence, cannot claim back the collateral anymore, until the final voting round passes)\n', '    @param _proposalId ID of the proposal\n', '    */\n', '    function finalizeProposal(bytes32 _proposalId)\n', '        public\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '        require(isEditable(_proposalId));\n', '        checkNonDigixProposalLimit(_proposalId);\n', '\n', '        // make sure we have reasonably enough time left in the quarter to conduct the Draft Voting.\n', '        // Otherwise, the proposer must wait until the next quarter to finalize the proposal\n', '        require(getTimeLeftInQuarter(now) > getUintConfig(CONFIG_DRAFT_VOTING_PHASE).add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE)));\n', '        address _endorser;\n', '        (,,_endorser,,,,,,,) = daoStorage().readProposal(_proposalId);\n', '        require(_endorser != EMPTY_ADDRESS);\n', '        daoStorage().finalizeProposal(_proposalId);\n', '        daoStorage().setProposalDraftVotingTime(_proposalId, now);\n', '\n', '        emit FinalizeProposal(_proposalId);\n', '    }\n', '\n', '    /**\n', '    @notice Function to set milestone to be completed\n', '    @dev This can only be called in the Main Phase of DigixDAO by the proposer. It sets the\n', '         voting time for the next milestone, which is immediately, for most of the times. If there is not enough time left in the current\n', '         quarter, then the next voting is postponed to the start of next quarter\n', '    @param _proposalId ID of the proposal\n', '    @param _milestoneIndex Index of the milestone. Index starts from 0 (for the first milestone)\n', '    */\n', '    function finishMilestone(bytes32 _proposalId, uint256 _milestoneIndex)\n', '        public\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '\n', '        uint256[] memory _currentFundings;\n', '        (_currentFundings,) = daoStorage().readProposalFunding(_proposalId);\n', '\n', '        // If there are N milestones, the milestone index must be < N. Otherwise, putting a milestone index of N will actually return a valid timestamp that is\n', '        // right after the final voting round (voting round index N is the final voting round)\n', '        // Which could be abused ( to "finish" a milestone even after the final voting round)\n', '        require(_milestoneIndex < _currentFundings.length);\n', '\n', '        // must be after the start of this milestone, and the milestone has not been finished yet (voting hasnt started)\n', '        uint256 _startOfCurrentMilestone = startOfMilestone(_proposalId, _milestoneIndex);\n', '        require(now > _startOfCurrentMilestone);\n', '        require(daoStorage().readProposalVotingTime(_proposalId, _milestoneIndex.add(1)) == 0);\n', '\n', '        daoStorage().setProposalVotingTime(\n', '            _proposalId,\n', '            _milestoneIndex.add(1),\n', '            getTimelineForNextVote(_milestoneIndex.add(1), now)\n', '        ); // set the voting time of next voting\n', '\n', '        emit FinishMilestone(_proposalId, _milestoneIndex);\n', '    }\n', '\n', '    /**\n', '    @notice Add IPFS docs to a proposal\n', '    @dev This is allowed only after a proposal is finalized. Before finalizing\n', '         a proposal, proposer can modifyProposal and basically create a different ProposalVersion. After the proposal is finalized,\n', '         they can only allProposalDoc to the final version of that proposal\n', '    @param _proposalId ID of the proposal\n', '    @param _newDoc hash of the new IPFS doc\n', '    */\n', '    function addProposalDoc(bytes32 _proposalId, bytes32 _newDoc)\n', '        public\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '        bytes32 _finalVersion;\n', '        (,,,,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n', '        require(_finalVersion != EMPTY_BYTES);\n', '        daoStorage().addProposalDoc(_proposalId, _newDoc);\n', '\n', '        emit AddProposalDoc(_proposalId, _newDoc);\n', '    }\n', '\n', '    /**\n', '    @notice Function to endorse a pre-proposal (can be called only by DAO Moderator)\n', '    @param _proposalId ID of the proposal (hash of IPFS doc of the first version of the proposal)\n', '    */\n', '    function endorseProposal(bytes32 _proposalId)\n', '        public\n', '        isProposalState(_proposalId, PROPOSAL_STATE_PREPROPOSAL)\n', '    {\n', '        require(isMainPhase());\n', '        require(isModerator(msg.sender));\n', '        daoStorage().updateProposalEndorse(_proposalId, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Function to update the PRL (regulatory status) status of a proposal\n', '    @dev if a proposal is paused or stopped, the proposer wont be able to withdraw the funding\n', '    @param _proposalId ID of the proposal\n', '    @param _doc hash of IPFS uploaded document, containing details of PRL Action\n', '    */\n', '    function updatePRL(\n', '        bytes32 _proposalId,\n', '        uint256 _action,\n', '        bytes32 _doc\n', '    )\n', '        public\n', '        if_prl()\n', '    {\n', '        require(_action == PRL_ACTION_STOP || _action == PRL_ACTION_PAUSE || _action == PRL_ACTION_UNPAUSE);\n', '        daoStorage().updateProposalPRL(_proposalId, _action, _doc, now);\n', '\n', '        emit PRLAction(_proposalId, _action, _doc);\n', '    }\n', '\n', '    /**\n', '    @notice Function to close proposal (also get back collateral)\n', '    @dev Can only be closed if the proposal has not been finalized yet\n', '    @param _proposalId ID of the proposal\n', '    */\n', '    function closeProposal(bytes32 _proposalId)\n', '        public\n', '    {\n', '        senderCanDoProposerOperations();\n', '        require(isFromProposer(_proposalId));\n', '        bytes32 _finalVersion;\n', '        bytes32 _status;\n', '        (,,,_status,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n', '        require(_finalVersion == EMPTY_BYTES);\n', '        require(_status != PROPOSAL_STATE_CLOSED);\n', '        require(daoStorage().readProposalCollateralStatus(_proposalId) == COLLATERAL_STATUS_UNLOCKED);\n', '\n', '        daoStorage().closeProposal(_proposalId);\n', '        daoStorage().setProposalCollateralStatus(_proposalId, COLLATERAL_STATUS_CLAIMED);\n', '        emit CloseProposal(_proposalId);\n', '        require(daoFundingManager().refundCollateral(msg.sender, _proposalId));\n', '    }\n', '\n', '    /**\n', '    @notice Function for founders to close all the dead proposals\n', '    @dev Dead proposals = all proposals who are not yet finalized, and been there for more than the threshold time\n', '         The proposers of dead proposals will not get the collateral back\n', '    @param _proposalIds Array of proposal IDs\n', '    */\n', '    function founderCloseProposals(bytes32[] _proposalIds)\n', '        external\n', '        if_founder()\n', '    {\n', '        uint256 _length = _proposalIds.length;\n', '        uint256 _timeCreated;\n', '        bytes32 _finalVersion;\n', '        bytes32 _currentState;\n', '        for (uint256 _i = 0; _i < _length; _i++) {\n', '            (,,,_currentState,_timeCreated,,,_finalVersion,,) = daoStorage().readProposal(_proposalIds[_i]);\n', '            require(_finalVersion == EMPTY_BYTES);\n', '            require(\n', '                (_currentState == PROPOSAL_STATE_PREPROPOSAL) ||\n', '                (_currentState == PROPOSAL_STATE_DRAFT)\n', '            );\n', '            require(now > _timeCreated.add(getUintConfig(CONFIG_PROPOSAL_DEAD_DURATION)));\n', '            emit CloseProposal(_proposalIds[_i]);\n', '            daoStorage().closeProposal(_proposalIds[_i]);\n', '        }\n', '    }\n', '}']