['pragma solidity ^0.5.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath\n', '{\n', '\t/**\n', '\t* @dev Adds two unsigned integers, reverts on overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a);\n', '\t\tuint256 c = a - b;\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Multiplies two unsigned integers, reverts on overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\t\t// Solidity only automatically asserts when dividing by 0\n', '\t\t\trequire(b > 0);\n', '\t\t\tuint256 c = a / b;\n', "\t\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '\t* reverts when dividing by zero.\n', '\t*/\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b != 0);\n', '\t\treturn a % b;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the largest of two numbers.\n', '\t*/\n', '\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a >= b ? a : b;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the smallest of two numbers.\n', '\t*/\n', '\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn a < b ? a : b;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Multiplies the a by the fraction b/c\n', '\t*/\n', '\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\n', '\t{\n', '\t\treturn div(mul(a, b), c);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Return b percents of a (equivalent to a percents of b)\n', '\t*/\n', '\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn mulByFraction(a, b, 100);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the base 2 log of x\n', '\t* @notice Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\n', '\t*/\n', '\tfunction log(uint x) internal pure returns (uint y)\n', '\t{\n', '\t\tassembly\n', '\t\t{\n', '\t\t\tlet arg := x\n', '\t\t\tx := sub(x,1)\n', '\t\t\tx := or(x, div(x, 0x02))\n', '\t\t\tx := or(x, div(x, 0x04))\n', '\t\t\tx := or(x, div(x, 0x10))\n', '\t\t\tx := or(x, div(x, 0x100))\n', '\t\t\tx := or(x, div(x, 0x10000))\n', '\t\t\tx := or(x, div(x, 0x100000000))\n', '\t\t\tx := or(x, div(x, 0x10000000000000000))\n', '\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\n', '\t\t\tx := add(x, 1)\n', '\t\t\tlet m := mload(0x40)\n', '\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n', '\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n', '\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n', '\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n', '\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n', '\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n', '\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n', '\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n', '\t\t\tmstore(0x40, add(m, 0x100))\n', '\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n', '\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\n', '\t\t\tlet a := div(mul(x, magic), shift)\n', '\t\t\ty := div(mload(add(m,sub(255,a))), shift)\n', '\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n', '\t\t}\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' */\n', 'interface IERC20\n', '{\n', '\tfunction totalSupply()\n', '\t\texternal view returns (uint256);\n', '\n', '\tfunction balanceOf(address who)\n', '\t\texternal view returns (uint256);\n', '\n', '\tfunction allowance(address owner, address spender)\n', '\t\texternal view returns (uint256);\n', '\n', '\tfunction transfer(address to, uint256 value)\n', '\t\texternal returns (bool);\n', '\n', '\tfunction approve(address spender, uint256 value)\n', '\t\texternal returns (bool);\n', '\n', '\tfunction transferFrom(address from, address to, uint256 value)\n', '\t\texternal returns (bool);\n', '\n', '\tevent Transfer(\n', '\t\taddress indexed from,\n', '\t\taddress indexed to,\n', '\t\tuint256 value\n', '\t);\n', '\n', '\tevent Approval(\n', '\t\taddress indexed owner,\n', '\t\taddress indexed spender,\n', '\t\tuint256 value\n', '\t);\n', '}\n', '\n', 'contract IERC734\n', '{\n', '\t// 1: MANAGEMENT keys, which can manage the identity\n', '\tuint256 public constant MANAGEMENT_KEY = 1;\n', '\t// 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n', '\tuint256 public constant ACTION_KEY = 2;\n', '\t// 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n', '\tuint256 public constant CLAIM_SIGNER_KEY = 3;\n', '\t// 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n', '\tuint256 public constant ENCRYPTION_KEY = 4;\n', '\n', '\t// KeyType\n', '\tuint256 public constant ECDSA_TYPE = 1;\n', '\t// https://medium.com/@alexberegszaszi/lets-bring-the-70s-to-ethereum-48daa16a4b51\n', '\tuint256 public constant RSA_TYPE = 2;\n', '\n', '\t// Events\n', '\tevent KeyAdded          (bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n', '\tevent KeyRemoved        (bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n', '\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n', '\tevent Executed          (uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n', '\tevent ExecutionFailed   (uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n', '\tevent Approved          (uint256 indexed executionId, bool approved);\n', '\n', '\t// Functions\n', '\tfunction getKey          (bytes32 _key                                     ) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n', '\tfunction keyHasPurpose   (bytes32 _key, uint256 purpose                    ) external view returns (bool exists);\n', '\tfunction getKeysByPurpose(uint256 _purpose                                 ) external view returns (bytes32[] memory keys);\n', '\tfunction addKey          (bytes32 _key, uint256 _purpose, uint256 _keyType ) external      returns (bool success);\n', '\tfunction removeKey       (bytes32 _key, uint256 _purpose                   ) external      returns (bool success);\n', '\tfunction execute         (address _to, uint256 _value, bytes calldata _data) external      returns (uint256 executionId);\n', '\tfunction approve         (uint256 _id, bool _approve                       ) external      returns (bool success);\n', '}\n', '\n', 'contract IERC1271\n', '{\n', '\t// bytes4(keccak256("isValidSignature(bytes,bytes)")\n', '\tbytes4 constant internal MAGICVALUE = 0x20c13b0b;\n', '\n', '\t/**\n', '\t * @dev Should return whether the signature provided is valid for the provided data\n', '\t * @param _data Arbitrary length data signed on the behalf of address(this)\n', '\t * @param _signature Signature byte array associated with _data\n', '\t *\n', '\t * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n', '\t * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n', '\t * MUST allow external calls\n', '\t */\n', '\t// function isValidSignature(\n', '\t// \tbytes memory _data,\n', '\t// \tbytes memory _signature)\n', '\t// \tpublic\n', '\t// \tview\n', '\t// \treturns (bytes4 magicValue);\n', '\n', '\t// Newer version ? From 0x V2\n', '\tfunction isValidSignature(\n', '\t\tbytes32 _data,\n', '\t\tbytes memory _signature\n', '\t)\n', '\tpublic\n', '\tview\n', '\treturns (bool isValid);\n', '}\n', '\n', '/**\n', ' * @title EIP1154 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-1154\n', ' */\n', 'interface IOracleConsumer\n', '{\n', '\tfunction receiveResult(bytes32, bytes calldata)\n', '\t\texternal;\n', '}\n', '\n', 'interface IOracle\n', '{\n', '\tfunction resultFor(bytes32)\n', '\t\texternal view returns (bytes memory);\n', '}\n', '\n', 'library IexecODBLibCore\n', '{\n', '\t/**\n', '\t* Tools\n', '\t*/\n', '\tstruct Account\n', '\t{\n', '\t\tuint256 stake;\n', '\t\tuint256 locked;\n', '\t}\n', '\tstruct Category\n', '\t{\n', '\t\tstring  name;\n', '\t\tstring  description;\n', '\t\tuint256 workClockTimeRef;\n', '\t}\n', '\n', '\t/**\n', '\t * Clerk - Deals\n', '\t */\n', '\tstruct Resource\n', '\t{\n', '\t\taddress pointer;\n', '\t\taddress owner;\n', '\t\tuint256 price;\n', '\t}\n', '\tstruct Deal\n', '\t{\n', '\t\t// Ressources\n', '\t\tResource app;\n', '\t\tResource dataset;\n', '\t\tResource workerpool;\n', '\t\tuint256 trust;\n', '\t\tuint256 category;\n', '\t\tbytes32 tag;\n', '\t\t// execution details\n', '\t\taddress requester;\n', '\t\taddress beneficiary;\n', '\t\taddress callback;\n', '\t\tstring  params;\n', '\t\t// execution settings\n', '\t\tuint256 startTime;\n', '\t\tuint256 botFirst;\n', '\t\tuint256 botSize;\n', '\t\t// consistency\n', '\t\tuint256 workerStake;\n', '\t\tuint256 schedulerRewardRatio;\n', '\t}\n', '\n', '\t/**\n', '\t * Tasks\n', '\t // TODO: rename Workorder → Task\n', '\t */\n', '\tenum TaskStatusEnum\n', '\t{\n', '\t\tUNSET,     // Work order not yet initialized (invalid address)\n', '\t\tACTIVE,    // Marketed → constributions are open\n', '\t\tREVEALING, // Starting consensus reveal\n', '\t\tCOMPLETED, // Concensus achieved\n', '\t\tFAILLED    // Failled consensus\n', '\t}\n', '\tstruct Task\n', '\t{\n', '\t\tTaskStatusEnum status;\n', '\t\tbytes32   dealid;\n', '\t\tuint256   idx;\n', '\t\tuint256   timeref;\n', '\t\tuint256   contributionDeadline;\n', '\t\tuint256   revealDeadline;\n', '\t\tuint256   finalDeadline;\n', '\t\tbytes32   consensusValue;\n', '\t\tuint256   revealCounter;\n', '\t\tuint256   winnerCounter;\n', '\t\taddress[] contributors;\n', '\t\tbytes32   resultDigest;\n', '\t\tbytes     results;\n', '\t}\n', '\n', '\t/**\n', '\t * Consensus\n', '\t */\n', '\tenum ContributionStatusEnum\n', '\t{\n', '\t\tUNSET,\n', '\t\tCONTRIBUTED,\n', '\t\tPROVED,\n', '\t\tREJECTED\n', '\t}\n', '\tstruct Contribution\n', '\t{\n', '\t\tContributionStatusEnum status;\n', '\t\tbytes32 resultHash;\n', '\t\tbytes32 resultSeal;\n', '\t\taddress enclaveChallenge;\n', '\t}\n', '\n', '}\n', '\n', 'library IexecODBLibOrders\n', '{\n', '\t// bytes32 public constant    EIP712DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '\t// bytes32 public constant        APPORDER_TYPEHASH = keccak256("AppOrder(address app,uint256 appprice,uint256 volume,bytes32 tag,address datasetrestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)");\n', '\t// bytes32 public constant    DATASETORDER_TYPEHASH = keccak256("DatasetOrder(address dataset,uint256 datasetprice,uint256 volume,bytes32 tag,address apprestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)");\n', '\t// bytes32 public constant WORKERPOOLORDER_TYPEHASH = keccak256("WorkerpoolOrder(address workerpool,uint256 workerpoolprice,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address apprestrict,address datasetrestrict,address requesterrestrict,bytes32 salt)");\n', '\t// bytes32 public constant    REQUESTORDER_TYPEHASH = keccak256("RequestOrder(address app,uint256 appmaxprice,address dataset,uint256 datasetmaxprice,address workerpool,uint256 workerpoolmaxprice,address requester,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address beneficiary,address callback,string params,bytes32 salt)");\n', '\tbytes32 public constant    EIP712DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n', '\tbytes32 public constant        APPORDER_TYPEHASH = 0x60815a0eeec47dddf1615fe53b31d016c31444e01b9d796db365443a6445d008;\n', '\tbytes32 public constant    DATASETORDER_TYPEHASH = 0x6cfc932a5a3d22c4359295b9f433edff52b60703fa47690a04a83e40933dd47c;\n', '\tbytes32 public constant WORKERPOOLORDER_TYPEHASH = 0xaa3429fb281b34691803133d3d978a75bb77c617ed6bc9aa162b9b30920022bb;\n', '\tbytes32 public constant    REQUESTORDER_TYPEHASH = 0xf24e853034a3a450aba845a82914fbb564ad85accca6cf62be112a154520fae0;\n', '\n', '\tstruct EIP712Domain\n', '\t{\n', '\t\tstring  name;\n', '\t\tstring  version;\n', '\t\tuint256 chainId;\n', '\t\taddress verifyingContract;\n', '\t}\n', '\tstruct AppOrder\n', '\t{\n', '\t\taddress app;\n', '\t\tuint256 appprice;\n', '\t\tuint256 volume;\n', '\t\tbytes32 tag;\n', '\t\taddress datasetrestrict;\n', '\t\taddress workerpoolrestrict;\n', '\t\taddress requesterrestrict;\n', '\t\tbytes32 salt;\n', '\t\tbytes   sign;\n', '\t}\n', '\tstruct DatasetOrder\n', '\t{\n', '\t\taddress dataset;\n', '\t\tuint256 datasetprice;\n', '\t\tuint256 volume;\n', '\t\tbytes32 tag;\n', '\t\taddress apprestrict;\n', '\t\taddress workerpoolrestrict;\n', '\t\taddress requesterrestrict;\n', '\t\tbytes32 salt;\n', '\t\tbytes   sign;\n', '\t}\n', '\tstruct WorkerpoolOrder\n', '\t{\n', '\t\taddress workerpool;\n', '\t\tuint256 workerpoolprice;\n', '\t\tuint256 volume;\n', '\t\tbytes32 tag;\n', '\t\tuint256 category;\n', '\t\tuint256 trust;\n', '\t\taddress apprestrict;\n', '\t\taddress datasetrestrict;\n', '\t\taddress requesterrestrict;\n', '\t\tbytes32 salt;\n', '\t\tbytes   sign;\n', '\t}\n', '\tstruct RequestOrder\n', '\t{\n', '\t\taddress app;\n', '\t\tuint256 appmaxprice;\n', '\t\taddress dataset;\n', '\t\tuint256 datasetmaxprice;\n', '\t\taddress workerpool;\n', '\t\tuint256 workerpoolmaxprice;\n', '\t\taddress requester;\n', '\t\tuint256 volume;\n', '\t\tbytes32 tag;\n', '\t\tuint256 category;\n', '\t\tuint256 trust;\n', '\t\taddress beneficiary;\n', '\t\taddress callback;\n', '\t\tstring  params;\n', '\t\tbytes32 salt;\n', '\t\tbytes   sign;\n', '\t}\n', '\n', '\tfunction hash(EIP712Domain memory _domain)\n', '\tpublic pure returns (bytes32 domainhash)\n', '\t{\n', '\t\t/**\n', '\t\t * Readeable but expensive\n', '\t\t */\n', '\t\t// return keccak256(abi.encode(\n', '\t\t// \tEIP712DOMAIN_TYPEHASH\n', '\t\t// , keccak256(bytes(_domain.name))\n', '\t\t// , keccak256(bytes(_domain.version))\n', '\t\t// , _domain.chainId\n', '\t\t// , _domain.verifyingContract\n', '\t\t// ));\n', '\n', '\t\t// Compute sub-hashes\n', '\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\n', '\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\n', '\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\n', '\t\tassembly {\n', '\t\t\t// Back up select memory\n', '\t\t\tlet temp1 := mload(sub(_domain, 0x20))\n', '\t\t\tlet temp2 := mload(add(_domain, 0x00))\n', '\t\t\tlet temp3 := mload(add(_domain, 0x20))\n', '\t\t\t// Write typeHash and sub-hashes\n', '\t\t\tmstore(sub(_domain, 0x20),    typeHash)\n', '\t\t\tmstore(add(_domain, 0x00),    nameHash)\n', '\t\t\tmstore(add(_domain, 0x20), versionHash)\n', '\t\t\t// Compute hash\n', '\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\n', '\t\t\t// Restore memory\n', '\t\t\tmstore(sub(_domain, 0x20), temp1)\n', '\t\t\tmstore(add(_domain, 0x00), temp2)\n', '\t\t\tmstore(add(_domain, 0x20), temp3)\n', '\t\t}\n', '\t}\n', '\tfunction hash(AppOrder memory _apporder)\n', '\tpublic pure returns (bytes32 apphash)\n', '\t{\n', '\t\t/**\n', '\t\t * Readeable but expensive\n', '\t\t */\n', '\t\t// return keccak256(abi.encode(\n', '\t\t// \tAPPORDER_TYPEHASH\n', '\t\t// , _apporder.app\n', '\t\t// , _apporder.appprice\n', '\t\t// , _apporder.volume\n', '\t\t// , _apporder.tag\n', '\t\t// , _apporder.datasetrestrict\n', '\t\t// , _apporder.workerpoolrestrict\n', '\t\t// , _apporder.requesterrestrict\n', '\t\t// , _apporder.salt\n', '\t\t// ));\n', '\n', '\t\t// Compute sub-hashes\n', '\t\tbytes32 typeHash = APPORDER_TYPEHASH;\n', '\t\tassembly {\n', '\t\t\t// Back up select memory\n', '\t\t\tlet temp1 := mload(sub(_apporder, 0x20))\n', '\t\t\t// Write typeHash and sub-hashes\n', '\t\t\tmstore(sub(_apporder, 0x20), typeHash)\n', '\t\t\t// Compute hash\n', '\t\t\tapphash := keccak256(sub(_apporder, 0x20), 0x120) // 288 = 32 + 256\n', '\t\t\t// Restore memory\n', '\t\t\tmstore(sub(_apporder, 0x20), temp1)\n', '\t\t}\n', '\t}\n', '\tfunction hash(DatasetOrder memory _datasetorder)\n', '\tpublic pure returns (bytes32 datasethash)\n', '\t{\n', '\t\t/**\n', '\t\t * Readeable but expensive\n', '\t\t */\n', '\t\t// return keccak256(abi.encode(\n', '\t\t// \tDATASETORDER_TYPEHASH\n', '\t\t// , _datasetorder.dataset\n', '\t\t// , _datasetorder.datasetprice\n', '\t\t// , _datasetorder.volume\n', '\t\t// , _datasetorder.tag\n', '\t\t// , _datasetorder.apprestrict\n', '\t\t// , _datasetorder.workerpoolrestrict\n', '\t\t// , _datasetorder.requesterrestrict\n', '\t\t// , _datasetorder.salt\n', '\t\t// ));\n', '\n', '\t\t// Compute sub-hashes\n', '\t\tbytes32 typeHash = DATASETORDER_TYPEHASH;\n', '\t\tassembly {\n', '\t\t\t// Back up select memory\n', '\t\t\tlet temp1 := mload(sub(_datasetorder, 0x20))\n', '\t\t\t// Write typeHash and sub-hashes\n', '\t\t\tmstore(sub(_datasetorder, 0x20), typeHash)\n', '\t\t\t// Compute hash\n', '\t\t\tdatasethash := keccak256(sub(_datasetorder, 0x20), 0x120) // 288 = 32 + 256\n', '\t\t\t// Restore memory\n', '\t\t\tmstore(sub(_datasetorder, 0x20), temp1)\n', '\t\t}\n', '\t}\n', '\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\n', '\tpublic pure returns (bytes32 workerpoolhash)\n', '\t{\n', '\t\t/**\n', '\t\t * Readeable but expensive\n', '\t\t */\n', '\t\t// return keccak256(abi.encode(\n', '\t\t// \tWORKERPOOLORDER_TYPEHASH\n', '\t\t// , _workerpoolorder.workerpool\n', '\t\t// , _workerpoolorder.workerpoolprice\n', '\t\t// , _workerpoolorder.volume\n', '\t\t// , _workerpoolorder.tag\n', '\t\t// , _workerpoolorder.category\n', '\t\t// , _workerpoolorder.trust\n', '\t\t// , _workerpoolorder.apprestrict\n', '\t\t// , _workerpoolorder.datasetrestrict\n', '\t\t// , _workerpoolorder.requesterrestrict\n', '\t\t// , _workerpoolorder.salt\n', '\t\t// ));\n', '\n', '\t\t// Compute sub-hashes\n', '\t\tbytes32 typeHash = WORKERPOOLORDER_TYPEHASH;\n', '\t\tassembly {\n', '\t\t\t// Back up select memory\n', '\t\t\tlet temp1 := mload(sub(_workerpoolorder, 0x20))\n', '\t\t\t// Write typeHash and sub-hashes\n', '\t\t\tmstore(sub(_workerpoolorder, 0x20), typeHash)\n', '\t\t\t// Compute hash\n', '\t\t\tworkerpoolhash := keccak256(sub(_workerpoolorder, 0x20), 0x160) // 352 = 32 + 320\n', '\t\t\t// Restore memory\n', '\t\t\tmstore(sub(_workerpoolorder, 0x20), temp1)\n', '\t\t}\n', '\t}\n', '\tfunction hash(RequestOrder memory _requestorder)\n', '\tpublic pure returns (bytes32 requesthash)\n', '\t{\n', '\t\t/**\n', '\t\t * Readeable but expensive\n', '\t\t */\n', '\t\t//return keccak256(abi.encodePacked(\n', '\t\t//\tabi.encode(\n', '\t\t//\t\tREQUESTORDER_TYPEHASH\n', '\t\t//\t, _requestorder.app\n', '\t\t//\t, _requestorder.appmaxprice\n', '\t\t//\t, _requestorder.dataset\n', '\t\t//\t, _requestorder.datasetmaxprice\n', '\t\t//\t, _requestorder.workerpool\n', '\t\t//\t, _requestorder.workerpoolmaxprice\n', '\t\t//\t, _requestorder.requester\n', '\t\t//\t, _requestorder.volume\n', '\t\t//\t, _requestorder.tag\n', '\t\t//\t, _requestorder.category\n', '\t\t//\t, _requestorder.trust\n', '\t\t//\t, _requestorder.beneficiary\n', '\t\t//\t, _requestorder.callback\n', '\t\t//\t, keccak256(bytes(_requestorder.params))\n', '\t\t//\t, _requestorder.salt\n', '\t\t//\t)\n', '\t\t//));\n', '\n', '\t\t// Compute sub-hashes\n', '\t\tbytes32 typeHash = REQUESTORDER_TYPEHASH;\n', '\t\tbytes32 paramsHash = keccak256(bytes(_requestorder.params));\n', '\t\tassembly {\n', '\t\t\t// Back up select memory\n', '\t\t\tlet temp1 := mload(sub(_requestorder, 0x020))\n', '\t\t\tlet temp2 := mload(add(_requestorder, 0x1A0))\n', '\t\t\t// Write typeHash and sub-hashes\n', '\t\t\tmstore(sub(_requestorder, 0x020), typeHash)\n', '\t\t\tmstore(add(_requestorder, 0x1A0), paramsHash)\n', '\t\t\t// Compute hash\n', '\t\t\trequesthash := keccak256(sub(_requestorder, 0x20), 0x200) // 512 = 32 + 480\n', '\t\t\t// Restore memory\n', '\t\t\tmstore(sub(_requestorder, 0x020), temp1)\n', '\t\t\tmstore(add(_requestorder, 0x1A0), temp2)\n', '\t\t}\n', '\t}\n', '\n', '\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\n', '\tpublic pure returns (bytes32 typedStructHash)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("\\x19\\x01", _domainHash, _structHash));\n', '\t}\n', '}\n', '\n', '\n', 'contract RegistryBase\n', '{\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tmapping(address => bool                       ) m_registered;\n', '\tmapping(address => mapping(uint256 => address)) m_byOwnerByIndex;\n', '\tmapping(address => uint256                    ) m_countByOwner;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Accessors\n', '\t */\n', '\tfunction isRegistered(address _entry)\n', '\tpublic view returns (bool)\n', '\t{\n', '\t\treturn m_registered[_entry];\n', '\t}\n', '\n', '\tfunction viewEntry(address _owner, uint256 _index)\n', '\tpublic view returns (address)\n', '\t{\n', '\t\treturn m_byOwnerByIndex[_owner][_index];\n', '\t}\n', '\n', '\tfunction viewCount(address _owner)\n', '\tpublic view returns (uint256)\n', '\t{\n', '\t\treturn m_countByOwner[_owner];\n', '\t}\n', '\n', '\t/**\n', '\t * Internal\n', '\t */\n', '\tfunction insert(\n', '\t\taddress _entry,\n', '\t\taddress _owner)\n', '\tinternal returns (bool)\n', '\t{\n', '\t\tuint id = m_countByOwner[_owner].add(1);\n', '\t\tm_countByOwner  [_owner]     = id;\n', '\t\tm_byOwnerByIndex[_owner][id] = _entry;\n', '\t\tm_registered    [_entry]     = true;\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'contract App is Ownable\n', '{\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring  public m_appName;\n', '\tstring  public m_appType;\n', '\tbytes   public m_appMultiaddr;\n', '\tbytes32 public m_appChecksum;\n', '\tbytes   public m_appMREnclave;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor(\n', '\t\taddress        _appOwner,\n', '\t\tstring  memory _appName,\n', '\t\tstring  memory _appType,\n', '\t\tbytes   memory _appMultiaddr,\n', '\t\tbytes32        _appChecksum,\n', '\t\tbytes   memory _appMREnclave)\n', '\tpublic\n', '\t{\n', '\t\t_transferOwnership(_appOwner);\n', '\t\tm_appName      = _appName;\n', '\t\tm_appType      = _appType;\n', '\t\tm_appMultiaddr = _appMultiaddr;\n', '\t\tm_appChecksum  = _appChecksum;\n', '\t\tm_appMREnclave = _appMREnclave;\n', '\t}\n', '\n', '\tfunction transferOwnership(address) public { revert("disabled"); }\n', '\n', '}\n', '\n', '\n', 'contract AppRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\n', '{\n', '\tevent CreateApp(address indexed appOwner, address app);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * App creation\n', '\t */\n', '\tfunction createApp(\n', '\t\taddress          _appOwner,\n', '\t\tstring  calldata _appName,\n', '\t\tstring  calldata _appType,\n', '\t\tbytes   calldata _appMultiaddr,\n', '\t\tbytes32          _appChecksum,\n', '\t\tbytes   calldata _appMREnclave)\n', '\texternal /* onlyOwner /*owner == IexecHub*/ returns (App)\n', '\t{\n', '\t\tApp newApp = new App(\n', '\t\t\t_appOwner,\n', '\t\t\t_appName,\n', '\t\t\t_appType,\n', '\t\t\t_appMultiaddr,\n', '\t\t\t_appChecksum,\n', '\t\t\t_appMREnclave\n', '\t\t);\n', '\t\trequire(insert(address(newApp), _appOwner));\n', '\t\temit CreateApp(_appOwner, address(newApp));\n', '\t\treturn newApp;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'contract Dataset is Ownable\n', '{\n', '\t/**\n', '\t * Members\n', '\t */\n', '\tstring  public m_datasetName;\n', '\tbytes   public m_datasetMultiaddr;\n', '\tbytes32 public m_datasetChecksum;\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor(\n', '\t\taddress        _datasetOwner,\n', '\t\tstring  memory _datasetName,\n', '\t\tbytes   memory _datasetMultiaddr,\n', '\t\tbytes32        _datasetChecksum)\n', '\tpublic\n', '\t{\n', '\t\t_transferOwnership(_datasetOwner);\n', '\t\tm_datasetName      = _datasetName;\n', '\t\tm_datasetMultiaddr = _datasetMultiaddr;\n', '\t\tm_datasetChecksum  = _datasetChecksum;\n', '\t}\n', '\n', '\tfunction transferOwnership(address) public { revert("disabled"); }\n', '\n', '}\n', '\n', '\n', 'contract DatasetRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\n', '{\n', '\tevent CreateDataset(address indexed datasetOwner, address dataset);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Dataset creation\n', '\t */\n', '\tfunction createDataset(\n', '\t\taddress          _datasetOwner,\n', '\t\tstring  calldata _datasetName,\n', '\t\tbytes   calldata _datasetMultiaddr,\n', '\t\tbytes32          _datasetChecksum)\n', '\texternal /* onlyOwner /*owner == IexecHub*/ returns (Dataset)\n', '\t{\n', '\t\tDataset newDataset = new Dataset(\n', '\t\t\t_datasetOwner,\n', '\t\t\t_datasetName,\n', '\t\t\t_datasetMultiaddr,\n', '\t\t\t_datasetChecksum\n', '\t\t);\n', '\t\trequire(insert(address(newDataset), _datasetOwner));\n', '\t\temit CreateDataset(_datasetOwner, address(newDataset));\n', '\t\treturn newDataset;\n', '\t}\n', '}\n', '\n', '\n', 'contract Workerpool is Ownable\n', '{\n', '\t/**\n', '\t * Parameters\n', '\t */\n', '\tstring  public m_workerpoolDescription;\n', '\tuint256 public m_workerStakeRatioPolicy;     // % of reward to stake\n', '\tuint256 public m_schedulerRewardRatioPolicy; // % of reward given to scheduler\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent PolicyUpdate(\n', '\t\tuint256 oldWorkerStakeRatioPolicy,     uint256 newWorkerStakeRatioPolicy,\n', '\t\tuint256 oldSchedulerRewardRatioPolicy, uint256 newSchedulerRewardRatioPolicy);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor(\n', '\t\taddress        _workerpoolOwner,\n', '\t\tstring  memory _workerpoolDescription)\n', '\tpublic\n', '\t{\n', '\t\t_transferOwnership(_workerpoolOwner);\n', '\t\tm_workerpoolDescription      = _workerpoolDescription;\n', '\t\tm_workerStakeRatioPolicy     = 30; // mutable\n', '\t\tm_schedulerRewardRatioPolicy = 1;  // mutable\n', '\t}\n', '\n', '\tfunction changePolicy(\n', '\t\tuint256 _newWorkerStakeRatioPolicy,\n', '\t\tuint256 _newSchedulerRewardRatioPolicy)\n', '\tpublic onlyOwner\n', '\t{\n', '\t\trequire(_newSchedulerRewardRatioPolicy <= 100);\n', '\n', '\t\temit PolicyUpdate(\n', '\t\t\tm_workerStakeRatioPolicy,     _newWorkerStakeRatioPolicy,\n', '\t\t\tm_schedulerRewardRatioPolicy, _newSchedulerRewardRatioPolicy\n', '\t\t);\n', '\n', '\t\tm_workerStakeRatioPolicy     = _newWorkerStakeRatioPolicy;\n', '\t\tm_schedulerRewardRatioPolicy = _newSchedulerRewardRatioPolicy;\n', '\t}\n', '\n', '\tfunction transferOwnership(address) public { revert("disabled"); }\n', '\n', '}\n', '\n', '\n', 'contract WorkerpoolRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\n', '{\n', '\tevent CreateWorkerpool(address indexed workerpoolOwner, address indexed workerpool, string workerpoolDescription);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Pool creation\n', '\t */\n', '\tfunction createWorkerpool(\n', '\t\taddress          _workerpoolOwner,\n', '\t\tstring  calldata _workerpoolDescription)\n', '\texternal /* onlyOwner /*owner == IexecHub*/ returns (Workerpool)\n', '\t{\n', '\t\tWorkerpool newWorkerpool = new Workerpool(\n', '\t\t\t_workerpoolOwner,\n', '\t\t\t_workerpoolDescription\n', '\t\t);\n', '\t\trequire(insert(address(newWorkerpool), _workerpoolOwner));\n', '\t\temit CreateWorkerpool(_workerpoolOwner, address(newWorkerpool), _workerpoolDescription);\n', '\t\treturn newWorkerpool;\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract CategoryManager is Ownable\n', '{\n', '\t/**\n', '\t * Content\n', '\t */\n', '\tIexecODBLibCore.Category[] m_categories;\n', '\n', '\t/**\n', '\t * Event\n', '\t */\n', '\tevent CreateCategory(\n', '\t\tuint256 catid,\n', '\t\tstring  name,\n', '\t\tstring  description,\n', '\t\tuint256 workClockTimeRef);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\t/**\n', '\t * Accessors\n', '\t */\n', '\tfunction viewCategory(uint256 _catid)\n', '\texternal view returns (IexecODBLibCore.Category memory category)\n', '\t{\n', '\t\treturn m_categories[_catid];\n', '\t}\n', '\n', '\tfunction countCategory()\n', '\texternal view returns (uint256 count)\n', '\t{\n', '\t\treturn m_categories.length;\n', '\t}\n', '\n', '\t/**\n', '\t * Methods\n', '\t */\n', '\tfunction createCategory(\n', '\t\tstring  calldata name,\n', '\t\tstring  calldata description,\n', '\t\tuint256          workClockTimeRef)\n', '\texternal onlyOwner returns (uint256)\n', '\t{\n', '\t\tuint256 catid = m_categories.push(IexecODBLibCore.Category(\n', '\t\t\tname,\n', '\t\t\tdescription,\n', '\t\t\tworkClockTimeRef\n', '\t\t)) - 1;\n', '\n', '\t\temit CreateCategory(\n', '\t\t\tcatid,\n', '\t\t\tname,\n', '\t\t\tdescription,\n', '\t\t\tworkClockTimeRef\n', '\t\t);\n', '\t\treturn catid;\n', '\t}\n', '\t/**\n', '\t * TODO: move to struct based initialization ?\n', '\t *\n', '\tfunction createCategory(IexecODBLib.Category _category)\n', '\tpublic onlyOwner returns (uint256)\n', '\t{\n', '\t\tuint256 catid = m_categories.push(_category);\n', '\t\temit CreateCategory(\n', '\t\t\tcatid,\n', '\t\t\t_category.name,\n', '\t\t\t_category.description,\n', '\t\t\t_category.workClockTimeRef\n', '\t\t);\n', '\t\treturn catid;\n', '\t}\n', '\t*/\n', '\n', '}\n', '\n', '\n', '\n', 'contract Escrow\n', '{\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '\t* token contract for transfers.\n', '\t*/\n', '\tIERC20 public token;\n', '\n', '\t/**\n', '\t * Escrow content\n', '\t */\n', '\tmapping(address => IexecODBLibCore.Account) m_accounts;\n', '\n', '\t/**\n', '\t * Events\n', '\t */\n', '\tevent Deposit   (address owner, uint256 amount);\n', '\tevent DepositFor(address owner, uint256 amount, address target);\n', '\tevent Withdraw  (address owner, uint256 amount);\n', '\tevent Reward    (address user,  uint256 amount, bytes32 ref);\n', '\tevent Seize     (address user,  uint256 amount, bytes32 ref);\n', '\tevent Lock      (address user,  uint256 amount);\n', '\tevent Unlock    (address user,  uint256 amount);\n', '\n', '\t/**\n', '\t * Constructor\n', '\t */\n', '\tconstructor(address _token)\n', '\tpublic\n', '\t{\n', '\t\ttoken = IERC20(_token);\n', '\t}\n', '\n', '\t/**\n', '\t * Accessor\n', '\t */\n', '\tfunction viewAccount(address _user)\n', '\texternal view returns (IexecODBLibCore.Account memory account)\n', '\t{\n', '\t\treturn m_accounts[_user];\n', '\t}\n', '\n', '\t/**\n', '\t * Wallet methods: public\n', '\t */\n', '\tfunction deposit(uint256 _amount)\n', '\texternal returns (bool)\n', '\t{\n', '\t\trequire(token.transferFrom(msg.sender, address(this), _amount));\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount);\n', '\t\temit Deposit(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction depositFor(uint256 _amount, address _target)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\trequire(_target != address(0));\n', '\n', '\t\trequire(token.transferFrom(msg.sender, address(this), _amount));\n', '\t\tm_accounts[_target].stake = m_accounts[_target].stake.add(_amount);\n', '\t\temit DepositFor(msg.sender, _amount, _target);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction depositForArray(uint256[] calldata _amounts, address[] calldata _targets)\n', '\texternal returns (bool)\n', '\t{\n', '\t\trequire(_amounts.length == _targets.length);\n', '\t\tfor (uint i = 0; i < _amounts.length; ++i)\n', '\t\t{\n', '\t\t\tdepositFor(_amounts[i], _targets[i]);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction withdraw(uint256 _amount)\n', '\texternal returns (bool)\n', '\t{\n', '\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.sub(_amount);\n', '\t\trequire(token.transfer(msg.sender, _amount));\n', '\t\temit Withdraw(msg.sender, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Wallet methods: Internal\n', '\t */\n', '\tfunction reward(address _user, uint256 _amount, bytes32 _reference) internal /* returns (bool) */\n', '\t{\n', '\t\tm_accounts[_user].stake = m_accounts[_user].stake.add(_amount);\n', '\t\temit Reward(_user, _amount, _reference);\n', '\t\t/* return true; */\n', '\t}\n', '\tfunction seize(address _user, uint256 _amount, bytes32 _reference) internal /* returns (bool) */\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\temit Seize(_user, _amount, _reference);\n', '\t\t/* return true; */\n', '\t}\n', '\tfunction lock(address _user, uint256 _amount) internal /* returns (bool) */\n', '\t{\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.sub(_amount);\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.add(_amount);\n', '\t\temit Lock(_user, _amount);\n', '\t\t/* return true; */\n', '\t}\n', '\tfunction unlock(address _user, uint256 _amount) internal /* returns (bool) */\n', '\t{\n', '\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\n', '\t\tm_accounts[_user].stake  = m_accounts[_user].stake.add(_amount);\n', '\t\temit Unlock(_user, _amount);\n', '\t\t/* return true; */\n', '\t}\n', '}\n', '\n', '\n', 'contract Relay\n', '{\n', '\tevent BroadcastAppOrder       (IexecODBLibOrders.AppOrder        apporder       );\n', '\tevent BroadcastDatasetOrder   (IexecODBLibOrders.DatasetOrder    datasetorder   );\n', '\tevent BroadcastWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder workerpoolorder);\n', '\tevent BroadcastRequestOrder   (IexecODBLibOrders.RequestOrder    requestorder   );\n', '\n', '\tconstructor() public {}\n', '\n', '\tfunction broadcastAppOrder       (IexecODBLibOrders.AppOrder        memory _apporder       ) public { emit BroadcastAppOrder       (_apporder       ); }\n', '\tfunction broadcastDatasetOrder   (IexecODBLibOrders.DatasetOrder    memory _datasetorder   ) public { emit BroadcastDatasetOrder   (_datasetorder   ); }\n', '\tfunction broadcastWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder) public { emit BroadcastWorkerpoolOrder(_workerpoolorder); }\n', '\tfunction broadcastRequestOrder   (IexecODBLibOrders.RequestOrder    memory _requestorder   ) public { emit BroadcastRequestOrder   (_requestorder   ); }\n', '}\n', '\n', '\n', 'contract SignatureVerifier\n', '{\n', '\tfunction addrToKey(address _addr)\n', '\tinternal pure returns (bytes32)\n', '\t{\n', '\t\treturn bytes32(uint256(_addr));\n', '\t}\n', '\n', '\tfunction checkIdentity(address _identity, address _candidate, uint256 _purpose)\n', '\tinternal view returns (bool valid)\n', '\t{\n', '\t\treturn _identity == _candidate || IERC734(_identity).keyHasPurpose(addrToKey(_candidate), _purpose); // Simple address || ERC 734 identity contract\n', '\t}\n', '\n', '\t// internal ?\n', '\tfunction verifySignature(\n', '\t\taddress      _identity,\n', '\t\tbytes32      _hash,\n', '\t\tbytes memory _signature)\n', '\tpublic view returns (bool)\n', '\t{\n', '\t\treturn recoverCheck(_identity, _hash, _signature) || IERC1271(_identity).isValidSignature(_hash, _signature);\n', '\t}\n', '\n', '\t// recoverCheck does not revert if signature has invalid format\n', '\tfunction recoverCheck(address candidate, bytes32 hash, bytes memory sign)\n', '\tinternal pure returns (bool)\n', '\t{\n', '\t\tbytes32 r;\n', '\t\tbytes32 s;\n', '\t\tuint8   v;\n', '\t\tif (sign.length != 65) return false;\n', '\t\tassembly\n', '\t\t{\n', '\t\t\tr :=         mload(add(sign, 0x20))\n', '\t\t\ts :=         mload(add(sign, 0x40))\n', '\t\t\tv := byte(0, mload(add(sign, 0x60)))\n', '\t\t}\n', '\t\tif (v < 27) v += 27;\n', '\t\tif (v != 27 && v != 28) return false;\n', '\t\treturn candidate == ecrecover(hash, v, r, s);\n', '\t}\n', '\n', '\tfunction toEthSignedMessageHash(bytes32 hash)\n', '\tinternal pure returns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '\t}\n', '}\n', '\n', 'interface IexecHubInterface\n', '{\n', '\tfunction checkResources(address, address, address)\n', '\texternal view returns (bool);\n', '}\n', '\n', '\n', 'contract IexecHubAccessor\n', '{\n', '\tIexecHubInterface public iexechub;\n', '\n', '\tmodifier onlyIexecHub()\n', '\t{\n', '\t\trequire(msg.sender == address(iexechub));\n', '\t\t_;\n', '\t}\n', '\n', '\tconstructor(address _iexechub)\n', '\tpublic\n', '\t{\n', '\t\trequire(_iexechub != address(0));\n', '\t\tiexechub = IexecHubInterface(_iexechub);\n', '\t}\n', '\n', '}\n', '\n', 'contract IexecClerkABILegacy\n', '{\n', '\tuint256 public constant POOL_STAKE_RATIO = 30;\n', '\tuint256 public constant KITTY_RATIO      = 10;\n', '\tuint256 public constant KITTY_MIN        = 1000000000; // TODO: 1RLC ?\n', '\n', '\tbytes32 public /* immutable */ EIP712DOMAIN_SEPARATOR;\n', '\n', '\tmapping(bytes32 => bytes32[]) public m_requestdeals;\n', '\tmapping(bytes32 => uint256  ) public m_consumed;\n', '\tmapping(bytes32 => bool     ) public m_presigned;\n', '\n', '\tevent OrdersMatched        (bytes32 dealid, bytes32 appHash, bytes32 datasetHash, bytes32 workerpoolHash, bytes32 requestHash, uint256 volume);\n', '\tevent ClosedAppOrder       (bytes32 appHash);\n', '\tevent ClosedDatasetOrder   (bytes32 datasetHash);\n', '\tevent ClosedWorkerpoolOrder(bytes32 workerpoolHash);\n', '\tevent ClosedRequestOrder   (bytes32 requestHash);\n', '\tevent SchedulerNotice      (address indexed workerpool, bytes32 dealid);\n', '\n', '\tfunction viewRequestDeals(bytes32 _id)\n', '\texternal view returns (bytes32[] memory);\n', '\n', '\tfunction viewConsumed(bytes32 _id)\n', '\texternal view returns (uint256);\n', '\n', '\tfunction lockContribution(bytes32 _dealid, address _worker)\n', '\texternal;\n', '\n', '\tfunction unlockContribution(bytes32 _dealid, address _worker)\n', '\texternal;\n', '\n', '\tfunction unlockAndRewardForContribution(bytes32 _dealid, address _worker, uint256 _amount, bytes32 _taskid)\n', '\texternal;\n', '\n', '\tfunction seizeContribution(bytes32 _dealid, address _worker, bytes32 _taskid)\n', '\texternal;\n', '\n', '\tfunction rewardForScheduling(bytes32 _dealid, uint256 _amount, bytes32 _taskid)\n', '\texternal;\n', '\n', '\tfunction successWork(bytes32 _dealid, bytes32 _taskid)\n', '\texternal;\n', '\n', '\tfunction failedWork(bytes32 _dealid, bytes32 _taskid)\n', '\texternal;\n', '\n', '\n', '\n', '\n', '\tfunction viewDealABILegacy_pt1(bytes32 _id)\n', '\texternal view returns\n', '\t( address\n', '\t, address\n', '\t, uint256\n', '\t, address\n', '\t, address\n', '\t, uint256\n', '\t, address\n', '\t, address\n', '\t, uint256\n', '\t);\n', '\n', '\tfunction viewDealABILegacy_pt2(bytes32 _id)\n', '\texternal view returns\n', '\t( uint256\n', '\t, bytes32\n', '\t, address\n', '\t, address\n', '\t, address\n', '\t, string memory\n', '\t);\n', '\n', '\tfunction viewConfigABILegacy(bytes32 _id)\n', '\texternal view returns\n', '\t( uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t);\n', '\n', '\tfunction viewAccountABILegacy(address _user)\n', '\texternal view returns (uint256, uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * /!\\ TEMPORARY LEGACY /!\\\n', ' */\n', '\n', 'contract IexecClerk is Escrow, Relay, IexecHubAccessor, SignatureVerifier, IexecClerkABILegacy\n', '{\n', '\tusing SafeMath          for uint256;\n', '\tusing IexecODBLibOrders for bytes32;\n', '\tusing IexecODBLibOrders for IexecODBLibOrders.EIP712Domain;\n', '\tusing IexecODBLibOrders for IexecODBLibOrders.AppOrder;\n', '\tusing IexecODBLibOrders for IexecODBLibOrders.DatasetOrder;\n', '\tusing IexecODBLibOrders for IexecODBLibOrders.WorkerpoolOrder;\n', '\tusing IexecODBLibOrders for IexecODBLibOrders.RequestOrder;\n', '\n', '\t/***************************************************************************\n', '\t *                                Constants                                *\n', '\t ***************************************************************************/\n', '\tuint256 public constant WORKERPOOL_STAKE_RATIO = 30;\n', '\tuint256 public constant KITTY_RATIO            = 10;\n', '\tuint256 public constant KITTY_MIN              = 1000000000; // TODO: 1RLC ?\n', '\n', '\t// For authorizations\n', '\tuint256 public constant GROUPMEMBER_PURPOSE    = 4;\n', '\n', '\t/***************************************************************************\n', '\t *                            EIP712 signature                             *\n', '\t ***************************************************************************/\n', '\tbytes32 public /* immutable */ EIP712DOMAIN_SEPARATOR;\n', '\n', '\t/***************************************************************************\n', '\t *                               Clerk data                                *\n', '\t ***************************************************************************/\n', '\tmapping(bytes32 => bytes32[]           ) m_requestdeals;\n', '\tmapping(bytes32 => IexecODBLibCore.Deal) m_deals;\n', '\tmapping(bytes32 => uint256             ) m_consumed;\n', '\tmapping(bytes32 => bool                ) m_presigned;\n', '\n', '\t/***************************************************************************\n', '\t *                                 Events                                  *\n', '\t ***************************************************************************/\n', '\tevent OrdersMatched        (bytes32 dealid, bytes32 appHash, bytes32 datasetHash, bytes32 workerpoolHash, bytes32 requestHash, uint256 volume);\n', '\tevent ClosedAppOrder       (bytes32 appHash);\n', '\tevent ClosedDatasetOrder   (bytes32 datasetHash);\n', '\tevent ClosedWorkerpoolOrder(bytes32 workerpoolHash);\n', '\tevent ClosedRequestOrder   (bytes32 requestHash);\n', '\tevent SchedulerNotice      (address indexed workerpool, bytes32 dealid);\n', '\n', '\t/***************************************************************************\n', '\t *                               Constructor                               *\n', '\t ***************************************************************************/\n', '\tconstructor(\n', '\t\taddress _token,\n', '\t\taddress _iexechub,\n', '\t\tuint256 _chainid)\n', '\tpublic\n', '\tEscrow(_token)\n', '\tIexecHubAccessor(_iexechub)\n', '\t{\n', '\t\tEIP712DOMAIN_SEPARATOR = IexecODBLibOrders.EIP712Domain({\n', '\t\t\tname:              "iExecODB"\n', '\t\t, version:           "3.0-alpha"\n', '\t\t, chainId:           _chainid\n', '\t\t, verifyingContract: address(this)\n', '\t\t}).hash();\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                                Accessor                                 *\n', '\t ***************************************************************************/\n', '\tfunction viewRequestDeals(bytes32 _id)\n', '\texternal view returns (bytes32[] memory requestdeals)\n', '\t{\n', '\t\treturn m_requestdeals[_id];\n', '\t}\n', '\n', '\tfunction viewDeal(bytes32 _id)\n', '\texternal view returns (IexecODBLibCore.Deal memory deal)\n', '\t{\n', '\t\treturn m_deals[_id];\n', '\t}\n', '\n', '\tfunction viewConsumed(bytes32 _id)\n', '\texternal view returns (uint256 consumed)\n', '\t{\n', '\t\treturn m_consumed[_id];\n', '\t}\n', '\n', '\tfunction viewPresigned(bytes32 _id)\n', '\texternal view returns (bool presigned)\n', '\t{\n', '\t\treturn m_presigned[_id];\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                            pre-signing tools                            *\n', '\t ***************************************************************************/\n', '\t// should be external\n', '\tfunction signAppOrder(IexecODBLibOrders.AppOrder memory _apporder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\trequire(msg.sender == App(_apporder.app).owner());\n', '\t\tm_presigned[_apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction signDatasetOrder(IexecODBLibOrders.DatasetOrder memory _datasetorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\trequire(msg.sender == Dataset(_datasetorder.dataset).owner());\n', '\t\tm_presigned[_datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction signWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\trequire(msg.sender == Workerpool(_workerpoolorder.workerpool).owner());\n', '\t\tm_presigned[_workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction signRequestOrder(IexecODBLibOrders.RequestOrder memory _requestorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\trequire(msg.sender == _requestorder.requester);\n', '\t\tm_presigned[_requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                              Clerk methods                              *\n', '\t ***************************************************************************/\n', '\tstruct Identities\n', '\t{\n', '\t\tbytes32 appHash;\n', '\t\taddress appOwner;\n', '\t\tbytes32 datasetHash;\n', '\t\taddress datasetOwner;\n', '\t\tbytes32 workerpoolHash;\n', '\t\taddress workerpoolOwner;\n', '\t\tbytes32 requestHash;\n', '\t\tbool    hasDataset;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction matchOrders(\n', '\t\tIexecODBLibOrders.AppOrder        memory _apporder,\n', '\t\tIexecODBLibOrders.DatasetOrder    memory _datasetorder,\n', '\t\tIexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder,\n', '\t\tIexecODBLibOrders.RequestOrder    memory _requestorder)\n', '\tpublic returns (bytes32)\n', '\t{\n', '\t\t/**\n', '\t\t * Check orders compatibility\n', '\t\t */\n', '\n', '\t\t// computation environment & allowed enough funds\n', '\t\trequire(_requestorder.category           == _workerpoolorder.category       );\n', '\t\trequire(_requestorder.trust              <= _workerpoolorder.trust          );\n', '\t\trequire(_requestorder.appmaxprice        >= _apporder.appprice              );\n', '\t\trequire(_requestorder.datasetmaxprice    >= _datasetorder.datasetprice      );\n', '\t\trequire(_requestorder.workerpoolmaxprice >= _workerpoolorder.workerpoolprice);\n', '\t\trequire((_apporder.tag | _datasetorder.tag | _requestorder.tag) & ~_workerpoolorder.tag == 0x0);\n', '\n', '\t\t// Check matching and restrictions\n', '\t\trequire(_requestorder.app     == _apporder.app        );\n', '\t\trequire(_requestorder.dataset == _datasetorder.dataset);\n', '\t\trequire(_requestorder.workerpool           == address(0) || checkIdentity(_requestorder.workerpool,           _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE)); // requestorder.workerpool is a restriction\n', '\t\trequire(_apporder.datasetrestrict          == address(0) || checkIdentity(_apporder.datasetrestrict,          _datasetorder.dataset,       GROUPMEMBER_PURPOSE));\n', '\t\trequire(_apporder.workerpoolrestrict       == address(0) || checkIdentity(_apporder.workerpoolrestrict,       _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE));\n', '\t\trequire(_apporder.requesterrestrict        == address(0) || checkIdentity(_apporder.requesterrestrict,        _requestorder.requester,     GROUPMEMBER_PURPOSE));\n', '\t\trequire(_datasetorder.apprestrict          == address(0) || checkIdentity(_datasetorder.apprestrict,          _apporder.app,               GROUPMEMBER_PURPOSE));\n', '\t\trequire(_datasetorder.workerpoolrestrict   == address(0) || checkIdentity(_datasetorder.workerpoolrestrict,   _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE));\n', '\t\trequire(_datasetorder.requesterrestrict    == address(0) || checkIdentity(_datasetorder.requesterrestrict,    _requestorder.requester,     GROUPMEMBER_PURPOSE));\n', '\t\trequire(_workerpoolorder.apprestrict       == address(0) || checkIdentity(_workerpoolorder.apprestrict,       _apporder.app,               GROUPMEMBER_PURPOSE));\n', '\t\trequire(_workerpoolorder.datasetrestrict   == address(0) || checkIdentity(_workerpoolorder.datasetrestrict,   _datasetorder.dataset,       GROUPMEMBER_PURPOSE));\n', '\t\trequire(_workerpoolorder.requesterrestrict == address(0) || checkIdentity(_workerpoolorder.requesterrestrict, _requestorder.requester,     GROUPMEMBER_PURPOSE));\n', '\n', '\t\trequire(iexechub.checkResources(_apporder.app, _datasetorder.dataset, _workerpoolorder.workerpool));\n', '\n', '\t\t/**\n', '\t\t * Check orders authenticity\n', '\t\t */\n', '\t\tIdentities memory ids;\n', '\t\tids.hasDataset = _datasetorder.dataset != address(0);\n', '\n', '\t\t// app\n', '\t\tids.appHash  = _apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\tids.appOwner = App(_apporder.app).owner();\n', '\t\trequire(m_presigned[ids.appHash] || verifySignature(ids.appOwner, ids.appHash, _apporder.sign));\n', '\n', '\t\t// dataset\n', '\t\tif (ids.hasDataset) // only check if dataset is enabled\n', '\t\t{\n', '\t\t\tids.datasetHash  = _datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\t\tids.datasetOwner = Dataset(_datasetorder.dataset).owner();\n', '\t\t\trequire(m_presigned[ids.datasetHash] || verifySignature(ids.datasetOwner, ids.datasetHash, _datasetorder.sign));\n', '\t\t}\n', '\n', '\t\t// workerpool\n', '\t\tids.workerpoolHash  = _workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\tids.workerpoolOwner = Workerpool(_workerpoolorder.workerpool).owner();\n', '\t\trequire(m_presigned[ids.workerpoolHash] || verifySignature(ids.workerpoolOwner, ids.workerpoolHash, _workerpoolorder.sign));\n', '\n', '\t\t// request\n', '\t\tids.requestHash = _requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\trequire(m_presigned[ids.requestHash] || verifySignature(_requestorder.requester, ids.requestHash, _requestorder.sign));\n', '\n', '\t\t/**\n', '\t\t * Check availability\n', '\t\t */\n', '\t\tuint256 volume;\n', '\t\tvolume =                             _apporder.volume.sub       (m_consumed[ids.appHash       ]);\n', '\t\tvolume = ids.hasDataset ? volume.min(_datasetorder.volume.sub   (m_consumed[ids.datasetHash   ])) : volume;\n', '\t\tvolume =                  volume.min(_workerpoolorder.volume.sub(m_consumed[ids.workerpoolHash]));\n', '\t\tvolume =                  volume.min(_requestorder.volume.sub   (m_consumed[ids.requestHash   ]));\n', '\t\trequire(volume > 0);\n', '\n', '\t\t/**\n', '\t\t * Record\n', '\t\t */\n', '\t\tbytes32 dealid = keccak256(abi.encodePacked(\n', '\t\t\tids.requestHash,            // requestHash\n', '\t\t\tm_consumed[ids.requestHash] // idx of first subtask\n', '\t\t));\n', '\n', '\t\tIexecODBLibCore.Deal storage deal = m_deals[dealid];\n', '\t\tdeal.app.pointer          = _apporder.app;\n', '\t\tdeal.app.owner            = ids.appOwner;\n', '\t\tdeal.app.price            = _apporder.appprice;\n', '\t\tdeal.dataset.owner        = ids.datasetOwner;\n', '\t\tdeal.dataset.pointer      = _datasetorder.dataset;\n', '\t\tdeal.dataset.price        = ids.hasDataset ? _datasetorder.datasetprice : 0;\n', '\t\tdeal.workerpool.pointer   = _workerpoolorder.workerpool;\n', '\t\tdeal.workerpool.owner     = ids.workerpoolOwner;\n', '\t\tdeal.workerpool.price     = _workerpoolorder.workerpoolprice;\n', '\t\tdeal.trust                = _requestorder.trust.max(1);\n', '\t\tdeal.category             = _requestorder.category;\n', '\t\tdeal.tag                  = _apporder.tag | _datasetorder.tag | _requestorder.tag;\n', '\t\tdeal.requester            = _requestorder.requester;\n', '\t\tdeal.beneficiary          = _requestorder.beneficiary;\n', '\t\tdeal.callback             = _requestorder.callback;\n', '\t\tdeal.params               = _requestorder.params;\n', '\t\tdeal.startTime            = now;\n', '\t\tdeal.botFirst             = m_consumed[ids.requestHash];\n', '\t\tdeal.botSize              = volume;\n', '\t\tdeal.workerStake          = _workerpoolorder.workerpoolprice.percentage(Workerpool(_workerpoolorder.workerpool).m_workerStakeRatioPolicy());\n', '\t\tdeal.schedulerRewardRatio = Workerpool(_workerpoolorder.workerpool).m_schedulerRewardRatioPolicy();\n', '\n', '\t\tm_requestdeals[ids.requestHash].push(dealid);\n', '\n', '\t\t/**\n', '\t\t * Update consumed\n', '\t\t */\n', '\t\tm_consumed[ids.appHash       ] = m_consumed[ids.appHash       ].add(                 volume    );\n', '\t\tm_consumed[ids.datasetHash   ] = m_consumed[ids.datasetHash   ].add(ids.hasDataset ? volume : 0);\n', '\t\tm_consumed[ids.workerpoolHash] = m_consumed[ids.workerpoolHash].add(                 volume    );\n', '\t\tm_consumed[ids.requestHash   ] = m_consumed[ids.requestHash   ].add(                 volume    );\n', '\n', '\t\t/**\n', '\t\t * Lock\n', '\t\t */\n', '\t\tlock(\n', '\t\t\tdeal.requester,\n', '\t\t\tdeal.app.price\n', '\t\t\t.add(deal.dataset.price)\n', '\t\t\t.add(deal.workerpool.price)\n', '\t\t\t.mul(volume)\n', '\t\t);\n', '\t\tlock(\n', '\t\t\tdeal.workerpool.owner,\n', '\t\t\tdeal.workerpool.price\n', '\t\t\t.percentage(WORKERPOOL_STAKE_RATIO) // ORDER IS IMPORTANT HERE!\n', '\t\t\t.mul(volume)                        // ORDER IS IMPORTANT HERE!\n', '\t\t);\n', '\n', '\t\t/**\n', '\t\t * Advertize deal\n', '\t\t */\n', '\t\temit SchedulerNotice(deal.workerpool.pointer, dealid);\n', '\n', '\t\t/**\n', '\t\t * Advertize consumption\n', '\t\t */\n', '\t\temit OrdersMatched(\n', '\t\t\tdealid,\n', '\t\t\tids.appHash,\n', '\t\t\tids.datasetHash,\n', '\t\t\tids.workerpoolHash,\n', '\t\t\tids.requestHash,\n', '\t\t\tvolume\n', '\t\t);\n', '\n', '\t\treturn dealid;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction cancelAppOrder(IexecODBLibOrders.AppOrder memory _apporder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\tbytes32 dapporderHash = _apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\trequire(msg.sender == App(_apporder.app).owner());\n', '\t\tm_consumed[dapporderHash] = _apporder.volume;\n', '\t\temit ClosedAppOrder(dapporderHash);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction cancelDatasetOrder(IexecODBLibOrders.DatasetOrder memory _datasetorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\tbytes32 dataorderHash = _datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\trequire(msg.sender == Dataset(_datasetorder.dataset).owner());\n', '\t\tm_consumed[dataorderHash] = _datasetorder.volume;\n', '\t\temit ClosedDatasetOrder(dataorderHash);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction cancelWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\tbytes32 poolorderHash = _workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\trequire(msg.sender == Workerpool(_workerpoolorder.workerpool).owner());\n', '\t\tm_consumed[poolorderHash] = _workerpoolorder.volume;\n', '\t\temit ClosedWorkerpoolOrder(poolorderHash);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// should be external\n', '\tfunction cancelRequestOrder(IexecODBLibOrders.RequestOrder memory _requestorder)\n', '\tpublic returns (bool)\n', '\t{\n', '\t\tbytes32 requestorderHash = _requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\n', '\t\trequire(msg.sender == _requestorder.requester);\n', '\t\tm_consumed[requestorderHash] = _requestorder.volume;\n', '\t\temit ClosedRequestOrder(requestorderHash);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                    Escrow overhead for contribution                     *\n', '\t ***************************************************************************/\n', '\tfunction lockContribution(bytes32 _dealid, address _worker)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tlock(_worker, m_deals[_dealid].workerStake);\n', '\t}\n', '\n', '\tfunction unlockContribution(bytes32 _dealid, address _worker)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tunlock(_worker, m_deals[_dealid].workerStake);\n', '\t}\n', '\n', '\tfunction unlockAndRewardForContribution(bytes32 _dealid, address _worker, uint256 _amount, bytes32 _taskid)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tunlock(_worker, m_deals[_dealid].workerStake);\n', '\t\treward(_worker, _amount, _taskid);\n', '\t}\n', '\n', '\tfunction seizeContribution(bytes32 _dealid, address _worker, bytes32 _taskid)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tseize(_worker, m_deals[_dealid].workerStake, _taskid);\n', '\t}\n', '\n', '\tfunction rewardForScheduling(bytes32 _dealid, uint256 _amount, bytes32 _taskid)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\treward(m_deals[_dealid].workerpool.owner, _amount, _taskid);\n', '\t}\n', '\n', '\tfunction successWork(bytes32 _dealid, bytes32 _taskid)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tIexecODBLibCore.Deal storage deal = m_deals[_dealid];\n', '\n', '\t\tuint256 requesterstake = deal.app.price\n', '\t\t                         .add(deal.dataset.price)\n', '\t\t                         .add(deal.workerpool.price);\n', '\t\tuint256 poolstake = deal.workerpool.price\n', '\t\t                    .percentage(WORKERPOOL_STAKE_RATIO);\n', '\n', '\t\t// seize requester funds\n', '\t\tseize(deal.requester, requesterstake, _taskid);\n', '\t\t// dapp reward\n', '\t\tif (deal.app.price > 0)\n', '\t\t{\n', '\t\t\treward(deal.app.owner, deal.app.price, _taskid);\n', '\t\t}\n', '\t\t// data reward\n', '\t\tif (deal.dataset.price > 0 && deal.dataset.pointer != address(0))\n', '\t\t{\n', '\t\t\treward(deal.dataset.owner, deal.dataset.price, _taskid);\n', '\t\t}\n', '\t\t// unlock pool stake\n', '\t\tunlock(deal.workerpool.owner, poolstake);\n', '\t\t// pool reward performed by consensus manager\n', '\n', '\t\t/**\n', '\t\t * Retrieve part of the kitty\n', '\t\t * TODO: remove / keep ?\n', '\t\t */\n', '\t\tuint256 kitty = m_accounts[address(0)].locked;\n', '\t\tif (kitty > 0)\n', '\t\t{\n', '\t\t\tkitty = kitty\n', '\t\t\t        .percentage(KITTY_RATIO) // fraction\n', '\t\t\t        .max(KITTY_MIN)          // at least this\n', '\t\t\t        .min(kitty);             // but not more than available\n', '\t\t\tseize (address(0),            kitty, _taskid);\n', '\t\t\treward(deal.workerpool.owner, kitty, _taskid);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction failedWork(bytes32 _dealid, bytes32 _taskid)\n', '\texternal onlyIexecHub\n', '\t{\n', '\t\tIexecODBLibCore.Deal storage deal = m_deals[_dealid];\n', '\n', '\t\tuint256 requesterstake = deal.app.price\n', '\t\t                         .add(deal.dataset.price)\n', '\t\t                         .add(deal.workerpool.price);\n', '\t\tuint256 poolstake = deal.workerpool.price\n', '\t\t                    .percentage(WORKERPOOL_STAKE_RATIO);\n', '\n', '\t\tunlock(deal.requester,        requesterstake    );\n', '\t\tseize (deal.workerpool.owner, poolstake, _taskid);\n', '\t\treward(address(0),            poolstake, _taskid); // → Kitty / Burn\n', '\t\tlock  (address(0),            poolstake         ); // → Kitty / Burn\n', '\t}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\t/**\n', '\t * /!\\ TEMPORARY LEGACY /!\\\n', '\t */\n', '\n', '\tfunction viewDealABILegacy_pt1(bytes32 _id)\n', '\texternal view returns\n', '\t( address\n', '\t, address\n', '\t, uint256\n', '\t, address\n', '\t, address\n', '\t, uint256\n', '\t, address\n', '\t, address\n', '\t, uint256\n', '\t)\n', '\t{\n', '\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\n', '\t\treturn (\n', '\t\t\tdeal.app.pointer,\n', '\t\t\tdeal.app.owner,\n', '\t\t\tdeal.app.price,\n', '\t\t\tdeal.dataset.pointer,\n', '\t\t\tdeal.dataset.owner,\n', '\t\t\tdeal.dataset.price,\n', '\t\t\tdeal.workerpool.pointer,\n', '\t\t\tdeal.workerpool.owner,\n', '\t\t\tdeal.workerpool.price\n', '\t\t);\n', '\t}\n', '\n', '\tfunction viewDealABILegacy_pt2(bytes32 _id)\n', '\texternal view returns\n', '\t( uint256\n', '\t, bytes32\n', '\t, address\n', '\t, address\n', '\t, address\n', '\t, string memory\n', '\t)\n', '\t{\n', '\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\n', '\t\treturn (\n', '\t\t\tdeal.trust,\n', '\t\t\tdeal.tag,\n', '\t\t\tdeal.requester,\n', '\t\t\tdeal.beneficiary,\n', '\t\t\tdeal.callback,\n', '\t\t\tdeal.params\n', '\t\t);\n', '\t}\n', '\n', '\tfunction viewConfigABILegacy(bytes32 _id)\n', '\texternal view returns\n', '\t( uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t)\n', '\t{\n', '\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\n', '\t\treturn (\n', '\t\t\tdeal.category,\n', '\t\t\tdeal.startTime,\n', '\t\t\tdeal.botFirst,\n', '\t\t\tdeal.botSize,\n', '\t\t\tdeal.workerStake,\n', '\t\t\tdeal.schedulerRewardRatio\n', '\t\t);\n', '\t}\n', '\n', '\tfunction viewAccountABILegacy(address _user)\n', '\texternal view returns (uint256, uint256)\n', '\t{\n', '\t\tIexecODBLibCore.Account memory account = m_accounts[_user];\n', '\t\treturn ( account.stake, account.locked );\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract IexecHubABILegacy\n', '{\n', '\tuint256 public constant CONSENSUS_DURATION_RATIO = 10;\n', '\tuint256 public constant REVEAL_DURATION_RATIO    = 2;\n', '\n', '\tIexecClerk   public iexecclerk;\n', '\tRegistryBase public appregistry;\n', '\tRegistryBase public datasetregistry;\n', '\tRegistryBase public workerpoolregistry;\n', '\n', '\tevent TaskInitialize(bytes32 indexed taskid, address indexed workerpool               );\n', '\tevent TaskContribute(bytes32 indexed taskid, address indexed worker, bytes32 hash     );\n', '\tevent TaskConsensus (bytes32 indexed taskid,                         bytes32 consensus);\n', '\tevent TaskReveal    (bytes32 indexed taskid, address indexed worker, bytes32 digest   );\n', '\tevent TaskReopen    (bytes32 indexed taskid                                           );\n', '\tevent TaskFinalize  (bytes32 indexed taskid,                         bytes   results  );\n', '\tevent TaskClaimed   (bytes32 indexed taskid                                           );\n', '\n', '\tevent AccurateContribution(address indexed worker, bytes32 indexed taskid);\n', '\tevent FaultyContribution  (address indexed worker, bytes32 indexed taskid);\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _iexecclerkAddress,\n', '\t\taddress _appregistryAddress,\n', '\t\taddress _datasetregistryAddress,\n', '\t\taddress _workerpoolregistryAddress)\n', '\texternal;\n', '\n', '\tfunction viewScore(address _worker)\n', '\texternal view returns (uint256);\n', '\n', '\tfunction checkResources(address aap, address dataset, address workerpool)\n', '\texternal view returns (bool);\n', '\n', '\tfunction resultFor(bytes32 id)\n', '\texternal view returns (bytes memory);\n', '\n', '\tfunction initialize(\n', '\t\tbytes32 _dealid,\n', '\t\tuint256 idx)\n', '\tpublic returns (bytes32);\n', '\n', '\tfunction contribute(\n', '\t\tbytes32      _taskid,\n', '\t\tbytes32      _resultHash,\n', '\t\tbytes32      _resultSeal,\n', '\t\taddress      _enclaveChallenge,\n', '\t\tbytes memory _enclaveSign,\n', '\t\tbytes memory _workerpoolSign)\n', '\tpublic;\n', '\n', '\tfunction reveal(\n', '\t\tbytes32 _taskid,\n', '\t\tbytes32 _resultDigest)\n', '\texternal;\n', '\n', '\tfunction reopen(\n', '\t\tbytes32 _taskid)\n', '\texternal;\n', '\n', '\tfunction finalize(\n', '\t\tbytes32 _taskid,\n', '\t\tbytes calldata  _results)\n', '\texternal;\n', '\n', '\tfunction claim(\n', '\t\tbytes32 _taskid)\n', '\tpublic;\n', '\n', '\tfunction initializeArray(\n', '\t\tbytes32[] calldata _dealid,\n', '\t\tuint256[] calldata _idx)\n', '\texternal returns (bool);\n', '\n', '\tfunction claimArray(\n', '\t\tbytes32[] calldata _taskid)\n', '\texternal returns (bool);\n', '\n', '\tfunction initializeAndClaimArray(\n', '\t\tbytes32[] calldata _dealid,\n', '\t\tuint256[] calldata _idx)\n', '\texternal returns (bool);\n', '\n', '\tfunction viewTaskABILegacy(bytes32 _taskid)\n', '\texternal view returns\n', '\t( IexecODBLibCore.TaskStatusEnum\n', '\t, bytes32\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, bytes32\n', '\t, uint256\n', '\t, uint256\n', '\t, address[] memory\n', '\t, bytes     memory\n', '\t);\n', '\n', '\tfunction viewContributionABILegacy(bytes32 _taskid, address _worker)\n', '\texternal view returns\n', '\t( IexecODBLibCore.ContributionStatusEnum\n', '\t, bytes32\n', '\t, bytes32\n', '\t, address\n', '\t);\n', '\n', '\tfunction viewCategoryABILegacy(uint256 _catid)\n', '\texternal view returns (string memory, string memory, uint256);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * /!\\ TEMPORARY LEGACY /!\\\n', ' */\n', '\n', 'contract IexecHub is CategoryManager, IOracle, SignatureVerifier, IexecHubABILegacy\n', '{\n', '\tusing SafeMath for uint256;\n', '\n', '\t/***************************************************************************\n', '\t *                                Constants                                *\n', '\t ***************************************************************************/\n', '\tuint256 public constant CONTRIBUTION_DEADLINE_RATIO = 7;\n', '\tuint256 public constant       REVEAL_DEADLINE_RATIO = 2;\n', '\tuint256 public constant        FINAL_DEADLINE_RATIO = 10;\n', '\n', '\t/***************************************************************************\n', '\t *                             Other contracts                             *\n', '\t ***************************************************************************/\n', '\tIexecClerk   public iexecclerk;\n', '\tRegistryBase public appregistry;\n', '\tRegistryBase public datasetregistry;\n', '\tRegistryBase public workerpoolregistry;\n', '\n', '\t/***************************************************************************\n', '\t *                          Consensuses & Workers                          *\n', '\t ***************************************************************************/\n', '\tmapping(bytes32 =>                    IexecODBLibCore.Task         ) m_tasks;\n', '\tmapping(bytes32 => mapping(address => IexecODBLibCore.Contribution)) m_contributions;\n', '\tmapping(address =>                    uint256                      ) m_workerScores;\n', '\n', '\tmapping(bytes32 => mapping(address => uint256                     )) m_logweight;\n', '\tmapping(bytes32 => mapping(bytes32 => uint256                     )) m_groupweight;\n', '\tmapping(bytes32 =>                    uint256                      ) m_totalweight;\n', '\n', '\t/***************************************************************************\n', '\t *                                 Events                                  *\n', '\t ***************************************************************************/\n', '\tevent TaskInitialize(bytes32 indexed taskid, address indexed workerpool               );\n', '\tevent TaskContribute(bytes32 indexed taskid, address indexed worker, bytes32 hash     );\n', '\tevent TaskConsensus (bytes32 indexed taskid,                         bytes32 consensus);\n', '\tevent TaskReveal    (bytes32 indexed taskid, address indexed worker, bytes32 digest   );\n', '\tevent TaskReopen    (bytes32 indexed taskid                                           );\n', '\tevent TaskFinalize  (bytes32 indexed taskid,                         bytes results    );\n', '\tevent TaskClaimed   (bytes32 indexed taskid                                           );\n', '\n', '\tevent AccurateContribution(address indexed worker, bytes32 indexed taskid);\n', '\tevent FaultyContribution  (address indexed worker, bytes32 indexed taskid);\n', '\n', '\t/***************************************************************************\n', '\t *                                Modifiers                                *\n', '\t ***************************************************************************/\n', '\tmodifier onlyScheduler(bytes32 _taskid)\n', '\t{\n', '\t\trequire(msg.sender == iexecclerk.viewDeal(m_tasks[_taskid].dealid).workerpool.owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                               Constructor                               *\n', '\t ***************************************************************************/\n', '\tconstructor()\n', '\tpublic\n', '\t{\n', '\t}\n', '\n', '\tfunction attachContracts(\n', '\t\taddress _iexecclerkAddress,\n', '\t\taddress _appregistryAddress,\n', '\t\taddress _datasetregistryAddress,\n', '\t\taddress _workerpoolregistryAddress)\n', '\texternal onlyOwner\n', '\t{\n', '\t\trequire(address(iexecclerk) == address(0));\n', '\t\tiexecclerk         = IexecClerk  (_iexecclerkAddress  );\n', '\t\tappregistry        = RegistryBase(_appregistryAddress);\n', '\t\tdatasetregistry    = RegistryBase(_datasetregistryAddress);\n', '\t\tworkerpoolregistry = RegistryBase(_workerpoolregistryAddress);\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                                Accessors                                *\n', '\t ***************************************************************************/\n', '\tfunction viewTask(bytes32 _taskid)\n', '\texternal view returns (IexecODBLibCore.Task memory)\n', '\t{\n', '\t\treturn m_tasks[_taskid];\n', '\t}\n', '\n', '\tfunction viewContribution(bytes32 _taskid, address _worker)\n', '\texternal view returns (IexecODBLibCore.Contribution memory)\n', '\t{\n', '\t\treturn m_contributions[_taskid][_worker];\n', '\t}\n', '\n', '\tfunction viewScore(address _worker)\n', '\texternal view returns (uint256)\n', '\t{\n', '\t\treturn m_workerScores[_worker];\n', '\t}\n', '\n', '\tfunction checkResources(address app, address dataset, address workerpool)\n', '\texternal view returns (bool)\n', '\t{\n', '\t\trequire(                         appregistry.isRegistered(app));\n', '\t\trequire(dataset == address(0) || datasetregistry.isRegistered(dataset));\n', '\t\trequire(                         workerpoolregistry.isRegistered(workerpool));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                         EIP 1154 PULL INTERFACE                         *\n', '\t ***************************************************************************/\n', '\tfunction resultFor(bytes32 id)\n', '\texternal view returns (bytes memory)\n', '\t{\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[id];\n', '\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.COMPLETED);\n', '\t\treturn task.results;\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                            Consensus methods                            *\n', '\t ***************************************************************************/\n', '\tfunction initialize(bytes32 _dealid, uint256 idx)\n', '\tpublic returns (bytes32)\n', '\t{\n', '\t\tIexecODBLibCore.Deal memory deal = iexecclerk.viewDeal(_dealid);\n', '\n', '\t\trequire(idx >= deal.botFirst                  );\n', '\t\trequire(idx <  deal.botFirst.add(deal.botSize));\n', '\n', '\t\tbytes32 taskid  = keccak256(abi.encodePacked(_dealid, idx));\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[taskid];\n', '\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.UNSET);\n', '\n', '\t\ttask.status               = IexecODBLibCore.TaskStatusEnum.ACTIVE;\n', '\t\ttask.dealid               = _dealid;\n', '\t\ttask.idx                  = idx;\n', '\t\ttask.timeref              = m_categories[deal.category].workClockTimeRef;\n', '\t\ttask.contributionDeadline = task.timeref.mul(CONTRIBUTION_DEADLINE_RATIO).add(deal.startTime);\n', '\t\ttask.finalDeadline        = task.timeref.mul(       FINAL_DEADLINE_RATIO).add(deal.startTime);\n', '\n', '\t\t// setup denominator\n', '\t\tm_totalweight[taskid] = 1;\n', '\n', '\t\temit TaskInitialize(taskid, iexecclerk.viewDeal(_dealid).workerpool.pointer);\n', '\n', '\t\treturn taskid;\n', '\t}\n', '\n', '\t// TODO: make external w/ calldata\n', '\tfunction contribute(\n', '\t\tbytes32      _taskid,\n', '\t\tbytes32      _resultHash,\n', '\t\tbytes32      _resultSeal,\n', '\t\taddress      _enclaveChallenge,\n', '\t\tbytes memory _enclaveSign,\n', '\t\tbytes memory _workerpoolSign)\n', '\tpublic\n', '\t{\n', '\t\tIexecODBLibCore.Task         storage task         = m_tasks[_taskid];\n', '\t\tIexecODBLibCore.Contribution storage contribution = m_contributions[_taskid][msg.sender];\n', '\t\tIexecODBLibCore.Deal         memory  deal         = iexecclerk.viewDeal(task.dealid);\n', '\n', '\t\trequire(task.status               == IexecODBLibCore.TaskStatusEnum.ACTIVE       );\n', '\t\trequire(task.contributionDeadline >  now                                         );\n', '\t\trequire(contribution.status       == IexecODBLibCore.ContributionStatusEnum.UNSET);\n', '\n', '\t\t// Check that the worker + taskid + enclave combo is authorized to contribute (scheduler signature)\n', '\t\trequire(verifySignature(\n', '\t\t\tdeal.workerpool.owner,\n', '\t\t\ttoEthSignedMessageHash(\n', '\t\t\t\tkeccak256(abi.encodePacked(\n', '\t\t\t\t\tmsg.sender,\n', '\t\t\t\t\t_taskid,\n', '\t\t\t\t\t_enclaveChallenge\n', '\t\t\t\t))\n', '\t\t\t),\n', '\t\t\t_workerpoolSign\n', '\t\t));\n', '\n', '\t\t// need enclave challenge if tag is set\n', '\t\trequire(_enclaveChallenge != address(0) || (deal.tag[31] & 0x01 == 0));\n', '\n', '\t\t// Check enclave signature\n', '\t\trequire(_enclaveChallenge == address(0) || verifySignature(\n', '\t\t\t_enclaveChallenge,\n', '\t\t\ttoEthSignedMessageHash(\n', '\t\t\t\tkeccak256(abi.encodePacked(\n', '\t\t\t\t\t_resultHash,\n', '\t\t\t\t\t_resultSeal\n', '\t\t\t\t))\n', '\t\t\t),\n', '\t\t\t_enclaveSign\n', '\t\t));\n', '\n', '\t\t// Update contribution entry\n', '\t\tcontribution.status           = IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED;\n', '\t\tcontribution.resultHash       = _resultHash;\n', '\t\tcontribution.resultSeal       = _resultSeal;\n', '\t\tcontribution.enclaveChallenge = _enclaveChallenge;\n', '\t\ttask.contributors.push(msg.sender);\n', '\n', '\t\tiexecclerk.lockContribution(task.dealid, msg.sender);\n', '\n', '\t\temit TaskContribute(_taskid, msg.sender, _resultHash);\n', '\n', '\t\t// Contribution done → updating and checking concensus\n', '\n', '\t\t/*************************************************************************\n', '\t\t *                           SCORE POLICY 1/3                            *\n', '\t\t *                                                                       *\n', '\t\t *                          see documentation!                           *\n', '\t\t *************************************************************************/\n', '\t\t// k = 3\n', '\t\tuint256 weight = m_workerScores[msg.sender].div(3).max(3).sub(1);\n', '\t\tuint256 group  = m_groupweight[_taskid][_resultHash];\n', '\t\tuint256 delta  = group.max(1).mul(weight).sub(group);\n', '\n', '\t\tm_logweight  [_taskid][msg.sender ] = weight.log();\n', '\t\tm_groupweight[_taskid][_resultHash] = m_groupweight[_taskid][_resultHash].add(delta);\n', '\t\tm_totalweight[_taskid]              = m_totalweight[_taskid].add(delta);\n', '\n', '\t\t// Check consensus\n', '\t\tcheckConsensus(_taskid, _resultHash);\n', '\t}\n', '\tfunction checkConsensus(\n', '\t\tbytes32 _taskid,\n', '\t\tbytes32 _consensus)\n', '\tprivate\n', '\t{\n', '\t\tuint256 trust = iexecclerk.viewDeal(m_tasks[_taskid].dealid).trust;\n', '\t\tif (m_groupweight[_taskid][_consensus].mul(trust) > m_totalweight[_taskid].mul(trust.sub(1)))\n', '\t\t{\n', '\t\t\t// Preliminary checks done in "contribute()"\n', '\n', '\t\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\n', '\t\t\tuint256 winnerCounter = 0;\n', '\t\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\n', '\t\t\t{\n', '\t\t\t\taddress w = task.contributors[i];\n', '\t\t\t\tif\n', '\t\t\t\t(\n', '\t\t\t\t\tm_contributions[_taskid][w].resultHash == _consensus\n', '\t\t\t\t\t&&\n', '\t\t\t\t\tm_contributions[_taskid][w].status == IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED // REJECTED contribution must not be count\n', '\t\t\t\t)\n', '\t\t\t\t{\n', '\t\t\t\t\twinnerCounter = winnerCounter.add(1);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t// msg.sender is a contributor: no need to check\n', '\t\t\t// require(winnerCounter > 0);\n', '\t\t\ttask.status         = IexecODBLibCore.TaskStatusEnum.REVEALING;\n', '\t\t\ttask.consensusValue = _consensus;\n', '\t\t\ttask.revealDeadline = task.timeref.mul(REVEAL_DEADLINE_RATIO).add(now);\n', '\t\t\ttask.revealCounter  = 0;\n', '\t\t\ttask.winnerCounter  = winnerCounter;\n', '\n', '\t\t\temit TaskConsensus(_taskid, _consensus);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction reveal(\n', '\t\tbytes32 _taskid,\n', '\t\tbytes32 _resultDigest)\n', '\texternal // worker\n', '\t{\n', '\t\tIexecODBLibCore.Task         storage task         = m_tasks[_taskid];\n', '\t\tIexecODBLibCore.Contribution storage contribution = m_contributions[_taskid][msg.sender];\n', '\t\trequire(task.status             == IexecODBLibCore.TaskStatusEnum.REVEALING                       );\n', '\t\trequire(task.revealDeadline     >  now                                                            );\n', '\t\trequire(contribution.status     == IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED             );\n', '\t\trequire(contribution.resultHash == task.consensusValue                                            );\n', '\t\trequire(contribution.resultHash == keccak256(abi.encodePacked(            _taskid, _resultDigest)));\n', '\t\trequire(contribution.resultSeal == keccak256(abi.encodePacked(msg.sender, _taskid, _resultDigest)));\n', '\n', '\t\tcontribution.status = IexecODBLibCore.ContributionStatusEnum.PROVED;\n', '\t\ttask.revealCounter  = task.revealCounter.add(1);\n', '\t\ttask.resultDigest   = _resultDigest;\n', '\n', '\t\temit TaskReveal(_taskid, msg.sender, _resultDigest);\n', '\t}\n', '\n', '\tfunction reopen(\n', '\t\tbytes32 _taskid)\n', '\texternal onlyScheduler(_taskid)\n', '\t{\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\n', '\t\trequire(task.status         == IexecODBLibCore.TaskStatusEnum.REVEALING);\n', '\t\trequire(task.finalDeadline  >  now                                     );\n', '\t\trequire(task.revealDeadline <= now\n', '\t\t     && task.revealCounter  == 0                                       );\n', '\n', '\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress worker = task.contributors[i];\n', '\t\t\tif (m_contributions[_taskid][worker].resultHash == task.consensusValue)\n', '\t\t\t{\n', '\t\t\t\tm_contributions[_taskid][worker].status = IexecODBLibCore.ContributionStatusEnum.REJECTED;\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tm_totalweight[_taskid]                      = m_totalweight[_taskid].sub(m_groupweight[_taskid][task.consensusValue]);\n', '\t\tm_groupweight[_taskid][task.consensusValue] = 0;\n', '\n', '\t\ttask.status         = IexecODBLibCore.TaskStatusEnum.ACTIVE;\n', '\t\ttask.consensusValue = 0x0;\n', '\t\ttask.revealDeadline = 0;\n', '\t\ttask.winnerCounter  = 0;\n', '\n', '\t\temit TaskReopen(_taskid);\n', '\t}\n', '\n', '\tfunction finalize(\n', '\t\tbytes32          _taskid,\n', '\t\tbytes   calldata _results)\n', '\texternal onlyScheduler(_taskid)\n', '\t{\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\n', '\t\trequire(task.status        == IexecODBLibCore.TaskStatusEnum.REVEALING);\n', '\t\trequire(task.finalDeadline >  now                                     );\n', '\t\trequire(task.revealCounter == task.winnerCounter\n', '\t\t    || (task.revealCounter >  0  && task.revealDeadline <= now)       );\n', '\n', '\t\ttask.status  = IexecODBLibCore.TaskStatusEnum.COMPLETED;\n', '\t\ttask.results = _results;\n', '\n', '\t\t/**\n', '\t\t * Stake and reward management\n', '\t\t */\n', '\t\tiexecclerk.successWork(task.dealid, _taskid);\n', '\t\tdistributeRewards(_taskid);\n', '\n', '\t\t/**\n', '\t\t * Event\n', '\t\t */\n', '\t\temit TaskFinalize(_taskid, _results);\n', '\n', '\t\t/**\n', '\t\t * Callback for smartcontracts using EIP1154\n', '\t\t */\n', '\t\taddress callbackTarget = iexecclerk.viewDeal(task.dealid).callback;\n', '\t\tif (callbackTarget != address(0))\n', '\t\t{\n', '\t\t\t/**\n', '\t\t\t * Call does not revert if the target smart contract is incompatible or reverts\n', '\t\t\t *\n', '\t\t\t * ATTENTION!\n', '\t\t\t * This call is dangerous and target smart contract can charge the stack.\n', '\t\t\t * Assume invalid state after the call.\n', '\t\t\t * See: https://solidity.readthedocs.io/en/develop/types.html#members-of-addresses\n', '\t\t\t *\n', '\t\t\t * TODO: gas provided?\n', '\t\t\t */\n', '\t\t\trequire(gasleft() > 100000);\n', '\t\t\tbool success;\n', '\t\t\t(success,) = callbackTarget.call.gas(100000)(abi.encodeWithSignature(\n', '\t\t\t\t"receiveResult(bytes32,bytes)",\n', '\t\t\t\t_taskid,\n', '\t\t\t\t_results\n', '\t\t\t));\n', '\t\t}\n', '\t}\n', '\n', '\tfunction distributeRewards(bytes32 _taskid)\n', '\tprivate\n', '\t{\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\n', '\t\tIexecODBLibCore.Deal memory  deal = iexecclerk.viewDeal(task.dealid);\n', '\n', '\t\tuint256 i;\n', '\t\taddress worker;\n', '\n', '\t\tuint256 totalLogWeight = 0;\n', '\t\tuint256 totalReward = iexecclerk.viewDeal(task.dealid).workerpool.price;\n', '\n', '\t\tfor (i = 0; i < task.contributors.length; ++i)\n', '\t\t{\n', '\t\t\tworker = task.contributors[i];\n', '\t\t\tif (m_contributions[_taskid][worker].status == IexecODBLibCore.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\ttotalLogWeight = totalLogWeight.add(m_logweight[_taskid][worker]);\n', '\t\t\t}\n', '\t\t\telse // ContributionStatusEnum.REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\ttotalReward = totalReward.add(deal.workerStake);\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(totalLogWeight > 0);\n', '\n', '\t\t// compute how much is going to the workers\n', '\t\tuint256 workersReward = totalReward.percentage(uint256(100).sub(deal.schedulerRewardRatio));\n', '\n', '\t\tfor (i = 0; i < task.contributors.length; ++i)\n', '\t\t{\n', '\t\t\tworker = task.contributors[i];\n', '\t\t\tif (m_contributions[_taskid][worker].status == IexecODBLibCore.ContributionStatusEnum.PROVED)\n', '\t\t\t{\n', '\t\t\t\tuint256 workerReward = workersReward.mulByFraction(m_logweight[_taskid][worker], totalLogWeight);\n', '\t\t\t\ttotalReward          = totalReward.sub(workerReward);\n', '\n', '\t\t\t\tiexecclerk.unlockAndRewardForContribution(task.dealid, worker, workerReward, _taskid);\n', '\n', '\t\t\t\t// Only reward if replication happened\n', '\t\t\t\tif (task.contributors.length > 1)\n', '\t\t\t\t{\n', '\t\t\t\t\t/*******************************************************************\n', '\t\t\t\t\t *                        SCORE POLICY 2/3                         *\n', '\t\t\t\t\t *                                                                 *\n', '\t\t\t\t\t *                       see documentation!                        *\n', '\t\t\t\t\t *******************************************************************/\n', '\t\t\t\t\tm_workerScores[worker] = m_workerScores[worker].add(1);\n', '\t\t\t\t\temit AccurateContribution(worker, _taskid);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\telse // WorkStatusEnum.POCO_REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\n', '\t\t\t{\n', '\t\t\t\t// No Reward\n', '\t\t\t\tiexecclerk.seizeContribution(task.dealid, worker, _taskid);\n', '\n', '\t\t\t\t// Always punish bad contributors\n', '\t\t\t\t{\n', '\t\t\t\t\t/*******************************************************************\n', '\t\t\t\t\t *                        SCORE POLICY 3/3                         *\n', '\t\t\t\t\t *                                                                 *\n', '\t\t\t\t\t *                       see documentation!                        *\n', '\t\t\t\t\t *******************************************************************/\n', '\t\t\t\t\t// k = 3\n', '\t\t\t\t\tm_workerScores[worker] = m_workerScores[worker].mulByFraction(2,3);\n', '\t\t\t\t\temit FaultyContribution(worker, _taskid);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t// totalReward now contains the scheduler share\n', '\t\tiexecclerk.rewardForScheduling(task.dealid, totalReward, _taskid);\n', '\t}\n', '\n', '\tfunction claim(\n', '\t\tbytes32 _taskid)\n', '\tpublic\n', '\t{\n', '\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\n', '\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.ACTIVE\n', '\t\t     || task.status == IexecODBLibCore.TaskStatusEnum.REVEALING);\n', '\t\trequire(task.finalDeadline <= now);\n', '\n', '\t\ttask.status = IexecODBLibCore.TaskStatusEnum.FAILLED;\n', '\n', '\t\t/**\n', '\t\t * Stake management\n', '\t\t */\n', '\t\tiexecclerk.failedWork(task.dealid, _taskid);\n', '\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\n', '\t\t{\n', '\t\t\taddress worker = task.contributors[i];\n', '\t\t\tiexecclerk.unlockContribution(task.dealid, worker);\n', '\t\t}\n', '\n', '\t\temit TaskClaimed(_taskid);\n', '\t}\n', '\n', '\t/***************************************************************************\n', '\t *                            Array operations                             *\n', '\t ***************************************************************************/\n', '\tfunction initializeArray(\n', '\t\tbytes32[] calldata _dealid,\n', '\t\tuint256[] calldata _idx)\n', '\texternal returns (bool)\n', '\t{\n', '\t\trequire(_dealid.length == _idx.length);\n', '\t\tfor (uint i = 0; i < _dealid.length; ++i)\n', '\t\t{\n', '\t\t\tinitialize(_dealid[i], _idx[i]);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction claimArray(\n', '\t\tbytes32[] calldata _taskid)\n', '\texternal returns (bool)\n', '\t{\n', '\t\tfor (uint i = 0; i < _taskid.length; ++i)\n', '\t\t{\n', '\t\t\tclaim(_taskid[i]);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction initializeAndClaimArray(\n', '\t\tbytes32[] calldata _dealid,\n', '\t\tuint256[] calldata _idx)\n', '\texternal returns (bool)\n', '\t{\n', '\t\trequire(_dealid.length == _idx.length);\n', '\t\tfor (uint i = 0; i < _dealid.length; ++i)\n', '\t\t{\n', '\t\t\tclaim(initialize(_dealid[i], _idx[i]));\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * /!\\ TEMPORARY LEGACY /!\\\n', '\t */\n', '\n', '\tfunction viewTaskABILegacy(bytes32 _taskid)\n', '\texternal view returns\n', '\t( IexecODBLibCore.TaskStatusEnum\n', '\t, bytes32\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, uint256\n', '\t, bytes32\n', '\t, uint256\n', '\t, uint256\n', '\t, address[] memory\n', '\t, bytes     memory\n', '\t)\n', '\t{\n', '\t\tIexecODBLibCore.Task memory task = m_tasks[_taskid];\n', '\t\treturn (\n', '\t\t\ttask.status,\n', '\t\t\ttask.dealid,\n', '\t\t\ttask.idx,\n', '\t\t\ttask.timeref,\n', '\t\t\ttask.contributionDeadline,\n', '\t\t\ttask.revealDeadline,\n', '\t\t\ttask.finalDeadline,\n', '\t\t\ttask.consensusValue,\n', '\t\t\ttask.revealCounter,\n', '\t\t\ttask.winnerCounter,\n', '\t\t\ttask.contributors,\n', '\t\t\ttask.results\n', '\t\t);\n', '\t}\n', '\n', '\tfunction viewContributionABILegacy(bytes32 _taskid, address _worker)\n', '\texternal view returns\n', '\t( IexecODBLibCore.ContributionStatusEnum\n', '\t, bytes32\n', '\t, bytes32\n', '\t, address\n', '\t)\n', '\t{\n', '\t\tIexecODBLibCore.Contribution memory contribution = m_contributions[_taskid][_worker];\n', '\t\treturn (\n', '\t\t\tcontribution.status,\n', '\t\t\tcontribution.resultHash,\n', '\t\t\tcontribution.resultSeal,\n', '\t\t\tcontribution.enclaveChallenge\n', '\t\t);\n', '\t}\n', '\n', '\tfunction viewCategoryABILegacy(uint256 _catid)\n', '\texternal view returns (string memory, string memory, uint256)\n', '\t{\n', '\t\tIexecODBLibCore.Category memory category = m_categories[_catid];\n', '\t\treturn ( category.name, category.description, category.workClockTimeRef );\n', '\t}\n', '}\n', '\n', '\n', 'contract IexecDoracle is SignatureVerifier, IOracleConsumer\n', '{\n', '\taddress constant IEXEC_HUB_MAINNET = 0x1383c16c927c4A853684d1a9c676986f25E22111;\n', '\taddress constant IEXEC_HUB_ROPSTEN = 0xDbe30645EA7d216c31D09f8c5736FE74de774e63;\n', '\taddress constant IEXEC_HUB_RINKEBY = 0x0000000000000000000000000000000000000000;\n', '\taddress constant IEXEC_HUB_KOVAN   = 0xb3901d04CF645747b99DBbe8f2eE9cb41A89CeBF;\n', '\taddress constant IEXEC_HUB_GOERLI  = 0x0000000000000000000000000000000000000000;\n', '\n', '\tIexecHub   public m_iexecHub;\n', '\tIexecClerk public m_iexecClerk;\n', '\taddress    public m_authorizedApp;\n', '\taddress    public m_authorizedDataset;\n', '\taddress    public m_authorizedWorkerpool;\n', '\tbytes32    public m_requiredtag;\n', '\tuint256    public m_requiredtrust;\n', '\n', '\tevent ResultReady(bytes32 indexed doracleCallId);\n', '\n', '\tconstructor(address _iexecHubAddr)\n', '\tpublic\n', '\t{\n', '\t\tif      (getCodeSize(_iexecHubAddr    ) > 0) { m_iexecHub = IexecHub(_iexecHubAddr    ); }\n', '\t\telse if (getCodeSize(IEXEC_HUB_MAINNET) > 0) { m_iexecHub = IexecHub(IEXEC_HUB_MAINNET); }\n', '\t\telse if (getCodeSize(IEXEC_HUB_ROPSTEN) > 0) { m_iexecHub = IexecHub(IEXEC_HUB_ROPSTEN); }\n', '\t\telse if (getCodeSize(IEXEC_HUB_RINKEBY) > 0) { m_iexecHub = IexecHub(IEXEC_HUB_RINKEBY); }\n', '\t\telse if (getCodeSize(IEXEC_HUB_KOVAN  ) > 0) { m_iexecHub = IexecHub(IEXEC_HUB_KOVAN  ); }\n', '\t\telse if (getCodeSize(IEXEC_HUB_GOERLI ) > 0) { m_iexecHub = IexecHub(IEXEC_HUB_GOERLI ); }\n', '\t\telse                                         { revert("invalid-hub-address");            }\n', '\t\tm_iexecClerk = m_iexecHub.iexecclerk();\n', '\t}\n', '\n', '\tfunction getCodeSize(address _addr)\n', '\tinternal view returns (uint _size)\n', '\t{\n', '\t\tassembly { _size := extcodesize(_addr) }\n', '\t}\n', '\n', '\tfunction receiveResult(bytes32 _doracleCallId, bytes calldata)\n', '\texternal\n', '\t{\n', '\t\temit ResultReady(_doracleCallId);\n', '\t}\n', '\n', '\tfunction _iexecDoracleUpdateSettings(\n', '\t\taddress _authorizedApp\n', '\t,\taddress _authorizedDataset\n', '\t,\taddress _authorizedWorkerpool\n', '\t, bytes32 _requiredtag\n', '\t, uint256 _requiredtrust\n', '\t)\n', '\tinternal\n', '\t{\n', '\t\tm_authorizedApp        = _authorizedApp;\n', '\t\tm_authorizedDataset    = _authorizedDataset;\n', '\t\tm_authorizedWorkerpool = _authorizedWorkerpool;\n', '\t\tm_requiredtag          = _requiredtag;\n', '\t\tm_requiredtrust        = _requiredtrust;\n', '\t}\n', '\n', '\tfunction _iexecDoracleGetVerifiedResult(bytes32 _doracleCallId)\n', '\tinternal view returns (bytes memory)\n', '\t{\n', '\t\tIexecODBLibCore.Task memory task = m_iexecHub.viewTask(_doracleCallId);\n', '\t\tIexecODBLibCore.Deal memory deal = m_iexecClerk.viewDeal(task.dealid);\n', '\n', '\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.COMPLETED,                                                                                    "result-not-available"             );\n', '\t\trequire(task.resultDigest == keccak256(task.results),                                                                                               "result-not-validated-by-consensus");\n', '\t\trequire(m_authorizedApp        == address(0) || checkIdentity(m_authorizedApp,        deal.app.pointer,        m_iexecClerk.GROUPMEMBER_PURPOSE()), "unauthorized-app"                 );\n', '\t\trequire(m_authorizedDataset    == address(0) || checkIdentity(m_authorizedDataset,    deal.dataset.pointer,    m_iexecClerk.GROUPMEMBER_PURPOSE()), "unauthorized-dataset"             );\n', '\t\trequire(m_authorizedWorkerpool == address(0) || checkIdentity(m_authorizedWorkerpool, deal.workerpool.pointer, m_iexecClerk.GROUPMEMBER_PURPOSE()), "unauthorized-workerpool"          );\n', '\t\trequire(m_requiredtag & ~deal.tag == bytes32(0),                                                                                                    "invalid-tag"                      );\n', '\t\trequire(m_requiredtrust <= deal.trust,                                                                                                              "invalid-trust"                    );\n', '\t\treturn task.results;\n', '\t}\n', '}\n', '\n', '\n', 'contract PriceOracle is Ownable, IexecDoracle\n', '{\n', '\tstruct timedValue\n', '\t{\n', '\t\tbytes32 oracleCallID;\n', '\t\tuint256 date;\n', '\t\tuint256 value;\n', '\t\tstring  details;\n', '\t}\n', '\n', '\tmapping(bytes32 => timedValue) public values;\n', '\n', '\tevent ValueChange(\n', '\t\tbytes32 indexed id,\n', '\t\tbytes32 indexed oracleCallID,\n', '\t\tuint256 oldDate,\n', '\t\tuint256 oldValue,\n', '\t\tuint256 newDate,\n', '\t\tuint256 newValue\n', '\t);\n', '\n', '\t// Use _iexecHubAddr to force use of custom iexechub, leave 0x0 for autodetect\n', '\tconstructor(address _iexecHubAddr)\n', '\tpublic IexecDoracle(_iexecHubAddr)\n', '\t{\n', '\t}\n', '\n', '\tfunction updateEnv(\n', '\t  address _authorizedApp\n', '\t, address _authorizedDataset\n', '\t, address _authorizedWorkerpool\n', '\t, bytes32 _requiredtag\n', '\t, uint256 _requiredtrust\n', '\t)\n', '\tpublic onlyOwner\n', '\t{\n', '\t\t_iexecDoracleUpdateSettings(_authorizedApp, _authorizedDataset, _authorizedWorkerpool, _requiredtag, _requiredtrust);\n', '\t}\n', '\n', '\tfunction decodeResults(bytes memory results)\n', '\tpublic pure returns(uint256, string memory, uint256)\n', '\t{ return abi.decode(results, (uint256, string, uint256)); }\n', '\n', '\tfunction processResult(bytes32 _oracleCallID)\n', '\tpublic\n', '\t{\n', '\t\tuint256       date;\n', '\t\tstring memory details;\n', '\t\tuint256       value;\n', '\n', '\t\t// Parse results\n', '\t\t(date, details, value) = decodeResults(_iexecDoracleGetVerifiedResult(_oracleCallID));\n', '\n', '\t\t// Process results\n', '\t\tbytes32 id = keccak256(bytes(details));\n', '\t\trequire(values[id].date < date, "new-value-is-too-old");\n', '\t\temit ValueChange(id, _oracleCallID, values[id].date, values[id].value, date, value);\n', '\t\tvalues[id].oracleCallID = _oracleCallID;\n', '\t\tvalues[id].date         = date;\n', '\t\tvalues[id].value        = value;\n', '\t\tvalues[id].details      = details;\n', '\t}\n', '}']