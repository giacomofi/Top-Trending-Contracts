['pragma solidity ^0.4.21;\n', '\n', 'contract LockRequestable {\n', '\n', '    uint256 public lockRequestCount;\n', '\n', '    function LockRequestable() public {\n', '        lockRequestCount = 0;\n', '    }\n', '\n', '    function generateLockId() internal returns (bytes32 lockId) {\n', '        return keccak256(block.blockhash(block.number - 1), address(this), ++lockRequestCount);\n', '    }\n', '}\n', '\n', 'contract CustodianUpgradeable is LockRequestable {\n', '\n', '    struct CustodianChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '    address public custodian;\n', '\n', '    mapping(bytes32 => CustodianChangeRequest) public custodianChangeReqs;\n', '\n', '    function CustodianUpgradeable(\n', '        address _custodian\n', '    )\n', '    LockRequestable()\n', '    public\n', '    {\n', '        custodian = _custodian;\n', '    }\n', '\n', '    modifier onlyCustodian {\n', '        require(msg.sender == custodian);\n', '        _;\n', '    }\n', '\n', '    function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n', '        require(_proposedCustodian != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        custodianChangeReqs[lockId] = CustodianChangeRequest({\n', '            proposedNew : _proposedCustodian\n', '            });\n', '\n', '        emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n', '    }\n', '\n', '    function confirmCustodianChange(bytes32 _lockId) public onlyCustodian {\n', '        custodian = getCustodianChangeReq(_lockId);\n', '        delete custodianChangeReqs[_lockId];\n', '        emit CustodianChangeConfirmed(_lockId, custodian);\n', '    }\n', '\n', '    function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\n', '        CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\n', '        require(changeRequest.proposedNew != 0);\n', '        return changeRequest.proposedNew;\n', '    }\n', '\n', '    event CustodianChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedCustodian\n', '    );\n', '\n', '    event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\n', '}\n', '\n', 'contract ERC20ImplUpgradeable is CustodianUpgradeable {\n', '\n', '    struct ImplChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '    ERC20Impl public erc20Impl;\n', '\n', '    mapping(bytes32 => ImplChangeRequest) public implChangeReqs;\n', '\n', '    function ERC20ImplUpgradeable(address _custodian) CustodianUpgradeable(_custodian) public {\n', '        erc20Impl = ERC20Impl(0x0);\n', '    }\n', '\n', '    modifier onlyImpl {\n', '        require(msg.sender == address(erc20Impl));\n', '        _;\n', '    }\n', '\n', '    function requestImplChange(address _proposedImpl) public returns (bytes32 lockId) {\n', '        require(_proposedImpl != address(0));\n', '        lockId = generateLockId();\n', '        implChangeReqs[lockId] = ImplChangeRequest({\n', '            proposedNew : _proposedImpl\n', '            });\n', '        emit ImplChangeRequested(lockId, msg.sender, _proposedImpl);\n', '    }\n', '\n', '    function confirmImplChange(bytes32 _lockId) public onlyCustodian {\n', '        erc20Impl = getImplChangeReq(_lockId);\n', '        delete implChangeReqs[_lockId];\n', '        emit ImplChangeConfirmed(_lockId, address(erc20Impl));\n', '    }\n', '\n', '    function getImplChangeReq(bytes32 _lockId) private view returns (ERC20Impl _proposedNew) {\n', '        ImplChangeRequest storage changeRequest = implChangeReqs[_lockId];\n', '        require(changeRequest.proposedNew != address(0));\n', '        return ERC20Impl(changeRequest.proposedNew);\n', '    }\n', '\n', '    event ImplChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedImpl\n', '    );\n', '\n', '    event ImplChangeConfirmed(bytes32 _lockId, address _newImpl);\n', '}\n', '\n', '\n', 'contract NianLunServiceUpgradeable is CustodianUpgradeable {\n', '\n', '    struct NianLunServiceChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '    NianLunService public nianLunService;\n', '\n', '    mapping(bytes32 => NianLunServiceChangeRequest) public nianLunServiceChangeReqs;\n', '\n', '    function NianLunServiceUpgradeable(address _custodian) CustodianUpgradeable(_custodian) public {\n', '        nianLunService = NianLunService(0x0);\n', '    }\n', '\n', '    modifier onlyNianLunService {\n', '        require(msg.sender == address(nianLunService));\n', '        _;\n', '    }\n', '\n', '    function requestNianLunServiceChange(address _proposedNianLunService) public returns (bytes32 lockId) {\n', '        require(_proposedNianLunService != address(0));\n', '        lockId = generateLockId();\n', '        nianLunServiceChangeReqs[lockId] = NianLunServiceChangeRequest({\n', '            proposedNew : _proposedNianLunService\n', '            });\n', '        emit NianLunServiceChangeRequested(lockId, msg.sender, _proposedNianLunService);\n', '    }\n', '\n', '    function confirmNianLunServiceChange(bytes32 _lockId) public onlyCustodian {\n', '        nianLunService = getNianLunServiceChangeReq(_lockId);\n', '        delete nianLunServiceChangeReqs[_lockId];\n', '        emit NianLunServiceChangeConfirmed(_lockId, address(nianLunService));\n', '    }\n', '\n', '    function getNianLunServiceChangeReq(bytes32 _lockId) private view returns (NianLunService _proposedNew) {\n', '        NianLunServiceChangeRequest storage changeRequest = nianLunServiceChangeReqs[_lockId];\n', '        require(changeRequest.proposedNew != address(0));\n', '        return NianLunService(changeRequest.proposedNew);\n', '    }\n', '\n', '    event NianLunServiceChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedNianLunService\n', '    );\n', '\n', '    event NianLunServiceChangeConfirmed(bytes32 _lockId, address _newNianLunService);\n', '}\n', '\n', 'contract ERC20Interface {\n', '    // METHODS\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#totalsupply\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#balanceof\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transferfrom\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#allowance\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // EVENTS\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approval\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ERC20Proxy is ERC20Interface, ERC20ImplUpgradeable, NianLunServiceUpgradeable {\n', '\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint8 public decimals;\n', '\n', '    function ERC20Proxy(\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        address _custodian\n', '    )\n', '    ERC20ImplUpgradeable(_custodian) NianLunServiceUpgradeable(_custodian)\n', '    public\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    modifier onlyPermitted() {\n', '        require(\n', '            msg.sender == address(nianLunService) ||\n', '            msg.sender == address(erc20Impl)\n', '        );\n', '        _;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Impl.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Impl.balanceOf(_owner);\n', '    }\n', '\n', '    function emitTransfer(address _from, address _to, uint256 _value) public onlyPermitted {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferWithSender(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);\n', '    }\n', '\n', '    function emitApproval(address _owner, address _spender, uint256 _value) public onlyImpl {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.approveWithSender(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n', '        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n', '        return erc20Impl.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Impl.allowance(_owner, _spender);\n', '    }\n', '}\n', '\n', 'contract ERC20Impl {\n', '\n', '    ERC20Proxy public erc20Proxy;\n', '\n', '    ERC20Store public erc20Store;\n', '\n', '    function ERC20Impl(\n', '        address _erc20Proxy,\n', '        address _erc20Store\n', '    )\n', '    public\n', '    {\n', '        erc20Proxy = ERC20Proxy(_erc20Proxy);\n', '        erc20Store = ERC20Store(_erc20Store);\n', '    }\n', '\n', '    modifier onlyProxy {\n', '        require(msg.sender == address(erc20Proxy));\n', '        _;\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    function approveWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '    public\n', '    onlyProxy\n', '    returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        // disallow unspendable approvals\n', '        erc20Store.setAllowance(_sender, _spender, _value);\n', '        erc20Proxy.emitApproval(_sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    onlyProxy\n', '    returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        // disallow unspendable approvals\n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance + _addedValue;\n', '\n', '        require(newAllowance >= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    onlyProxy\n', '    returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        // disallow unspendable approvals\n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance - _subtractedValue;\n', '\n', '        require(newAllowance <= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    function transferFromWithSender(\n', '        address _sender,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    onlyProxy onlyPayloadSize(4 * 32)\n', '    returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '\n', '        uint256 balanceOfFrom = erc20Store.balances(_from);\n', '        require(_value <= balanceOfFrom);\n', '\n', '        uint256 senderAllowance = erc20Store.allowed(_from, _sender);\n', '        require(_value <= senderAllowance);\n', '\n', '        erc20Store.setBalance(_from, balanceOfFrom - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '        erc20Store.setAllowance(_from, _sender, senderAllowance - _value);\n', '        erc20Proxy.emitTransfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferWithSender(\n', '        address _sender,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public onlyProxy onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '\n', '        uint256 balanceOfSender = erc20Store.balances(_sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        erc20Store.setBalance(_sender, balanceOfSender - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Proxy.emitTransfer(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Store.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Store.balances(_owner);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Store.allowed(_owner, _spender);\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Store is ERC20ImplUpgradeable, NianLunServiceUpgradeable {\n', '\n', '    uint256 public totalSupply;\n', '    uint256 public createDate;\n', '\n', '    address public foundation;\n', '    address public team;\n', '    address public partner;\n', '    address public transit;\n', '\n', '    mapping(address => uint256) public balances;\n', '\n', '    mapping(address => mapping(address => uint256)) public allowed;\n', '\n', '    mapping(address => uint256) public availableMap;\n', '\n', '    function ERC20Store(address _custodian, address _foundation, address _team, address _partner, address _transit)\n', '    ERC20ImplUpgradeable(_custodian) NianLunServiceUpgradeable(_custodian)\n', '    public\n', '    {\n', '        createDate = now;\n', '        foundation = _foundation;\n', '        partner = _partner;\n', '        team = _team;\n', '        transit = _transit;\n', '        availableMap[foundation] = 15120000000000000;\n', '        availableMap[partner] = 3360000000000000;\n', '        availableMap[team] = 2520000000000000;\n', '    }\n', '\n', '    modifier onlyPermitted\n', '    {\n', '        require(\n', '            msg.sender == address(nianLunService) ||\n', '            msg.sender == address(erc20Impl)\n', '        );\n', '        _;\n', '    }\n', '\n', '    function setTotalSupply(uint256 _newTotalSupply)\n', '    public onlyPermitted\n', '    {\n', '        totalSupply = _newTotalSupply;\n', '    }\n', '\n', '    function setAllowance(address _owner, address _spender, uint256 _value)\n', '    public onlyImpl\n', '    {\n', '        allowed[_owner][_spender] = _value;\n', '    }\n', '\n', '    function setBalance(address _owner, uint256 _newBalance)\n', '    public onlyPermitted\n', '    {\n', '        balances[_owner] = _newBalance;\n', '    }\n', '\n', '    function addBalance(address _owner, uint256 _balanceIncrease)\n', '    public onlyPermitted\n', '    {\n', '        balances[_owner] = balances[_owner] + _balanceIncrease;\n', '    }\n', '\n', '    function reduceAvailable(address _owner, uint256 _value)\n', '    public onlyNianLunService\n', '    {\n', '        availableMap[_owner] = availableMap[_owner] - _value;\n', '    }\n', '\n', '}\n', '\n', 'contract NianLunService is LockRequestable, CustodianUpgradeable {\n', '\n', '    struct PendingService {\n', '        address sender;\n', '        uint256 value;\n', '        bool isPrint;\n', '    }\n', '\n', '    ERC20Proxy public erc20Proxy;\n', '\n', '    ERC20Store public erc20Store;\n', '\n', '    mapping(address => bool) public primaryBank;\n', '\n', '    mapping(bytes32 => PendingService) public pendingServiceMap;\n', '\n', '    function NianLunService(address _erc20Proxy, address _erc20Store, address _custodian)\n', '    CustodianUpgradeable(_custodian)\n', '    public\n', '    {\n', '        erc20Proxy = ERC20Proxy(_erc20Proxy);\n', '        erc20Store = ERC20Store(_erc20Store);\n', '    }\n', '\n', '    modifier onlyPrimary\n', '    {\n', '        require(primaryBank[address(msg.sender)]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    function addPrimary(address _newPrimary)\n', '    public onlyCustodian\n', '    {\n', '        primaryBank[_newPrimary] = true;\n', '        emit PrimaryChanged(_newPrimary, true);\n', '    }\n', '\n', '    function removePrimary(address _removePrimary)\n', '    public onlyCustodian\n', '    {\n', '        delete primaryBank[_removePrimary];\n', '        emit PrimaryChanged(_removePrimary, false);\n', '    }\n', '\n', '    function authTransfer(address _from, address _to, uint256 _value)\n', '    public onlyPrimary onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '        uint256 balanceOfFrom = erc20Store.balances(_from);\n', '        require(_value <= balanceOfFrom);\n', '\n', '        erc20Store.setBalance(_from, balanceOfFrom - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Proxy.emitTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function batchPublishService(address[] _senders, uint256[] _values, bool[] _isPrints)\n', '    public onlyPrimary\n', '    returns (bool success)\n', '    {\n', '        require(_senders.length == _values.length);\n', '        require(_isPrints.length == _values.length);\n', '\n', '        uint256 numPublish = _senders.length;\n', '        for (uint256 i = 0; i < numPublish; i++) {\n', '            publishService(_senders[i], _values[i], _isPrints[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function publishService(address _sender, uint256 _value, bool _isPrint)\n', '    public onlyPrimary onlyPayloadSize(3 * 32)\n', '    {\n', '        require(_sender != address(0));\n', '\n', '        bytes32 lockId = generateLockId();\n', '\n', '        pendingServiceMap[lockId] = PendingService({\n', '            sender : _sender,\n', '            value : _value,\n', '            isPrint : _isPrint\n', '            });\n', '\n', '        if (_isPrint) {\n', '            // print value to transit;\n', '            erc20Store.setTotalSupply(erc20Store.totalSupply() + _value);\n', '            erc20Proxy.emitTransfer(address(0), erc20Store.transit(), _value);\n', '        } else {\n', '            // transfer value from sender to transit\n', '            uint256 balanceOfSender = erc20Store.balances(_sender);\n', '            if (_value > balanceOfSender) {\n', '                delete pendingServiceMap[lockId];\n', '                emit ServicePublished(lockId, _sender, _value, false);\n', '                return;\n', '            }\n', '            erc20Store.setBalance(_sender, balanceOfSender - _value);\n', '            erc20Proxy.emitTransfer(_sender, erc20Store.transit(), _value);\n', '        }\n', '        erc20Store.addBalance(erc20Store.transit(), _value);\n', '        emit ServicePublished(lockId, _sender, _value, true);\n', '    }\n', '\n', '    function batchConfirmService(bytes32[] _lockIds, uint256[] _values, address[] _tos)\n', '    public onlyPrimary\n', '    returns (bool result)\n', '    {\n', '        require(_lockIds.length == _values.length);\n', '        require(_lockIds.length == _tos.length);\n', '\n', '        uint256 numConfirms = _lockIds.length;\n', '        for (uint256 i = 0; i < numConfirms; i++) {\n', '            confirmService(_lockIds[i], _values[i], _tos[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function confirmService(bytes32 _lockId, uint256 _value, address _to)\n', '    public onlyPrimary\n', '    {\n', '        PendingService storage service = pendingServiceMap[_lockId];\n', '\n', '        address _sender = service.sender;\n', '        uint256 _availableValue = service.value;\n', '        bool _isPrint = service.isPrint;\n', '\n', '        if (_value > _availableValue) {\n', '            emit ServiceConfirmed(_lockId, _sender, _to, _value, false);\n', '            return;\n', '        }\n', '\n', '        uint256 _restValue = _availableValue - _value;\n', '\n', '        if (_restValue == 0) {\n', '            delete pendingServiceMap[_lockId];\n', '        } else {\n', '            service.value = _restValue;\n', '        }\n', '\n', '        if (_isPrint) {\n', '            releaseFoundation(_value);\n', '        }\n', '\n', '        uint256 balanceOfTransit = erc20Store.balances(erc20Store.transit());\n', '        erc20Store.setBalance(erc20Store.transit(), balanceOfTransit - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '        erc20Proxy.emitTransfer(erc20Store.transit(), _to, _value);\n', '        emit ServiceConfirmed(_lockId, _sender, _to, _value, true);\n', '    }\n', '\n', '    function releaseFoundation(uint256 _value)\n', '    private\n', '    {\n', '        uint256 foundationAvailable = erc20Store.availableMap(erc20Store.foundation());\n', '        if (foundationAvailable <= 0) {\n', '            return;\n', '        }\n', '        if (foundationAvailable < _value) {\n', '            _value = foundationAvailable;\n', '        }\n', '        erc20Store.addBalance(erc20Store.foundation(), _value);\n', '        erc20Store.setTotalSupply(erc20Store.totalSupply() + _value);\n', '        erc20Store.reduceAvailable(erc20Store.foundation(), _value);\n', '        erc20Proxy.emitTransfer(address(0), erc20Store.foundation(), _value);\n', '    }\n', '\n', '    function batchCancelService(bytes32[] _lockIds)\n', '    public onlyPrimary\n', '    returns (bool result)\n', '    {\n', '        uint256 numCancels = _lockIds.length;\n', '        for (uint256 i = 0; i < numCancels; i++) {\n', '            cancelService(_lockIds[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function cancelService(bytes32 _lockId)\n', '    public onlyPrimary\n', '    {\n', '        PendingService storage service = pendingServiceMap[_lockId];\n', '        address _sender = service.sender;\n', '        uint256 _value = service.value;\n', '        bool _isPrint = service.isPrint;\n', '\n', '        delete pendingServiceMap[_lockId];\n', '\n', '        if (_isPrint) {\n', '            // burn\n', '            erc20Store.setTotalSupply(erc20Store.totalSupply() - _value);\n', '            erc20Proxy.emitTransfer(erc20Store.transit(), address(0), _value);\n', '        } else {\n', '            // send back\n', '            erc20Store.addBalance(_sender, _value);\n', '            erc20Proxy.emitTransfer(erc20Store.transit(), _sender, _value);\n', '        }\n', '        uint256 balanceOfTransit = erc20Store.balances(erc20Store.transit());\n', '        erc20Store.setBalance(erc20Store.transit(), balanceOfTransit - _value);\n', '        emit ServiceCanceled(_lockId, _sender, _value);\n', '    }\n', '\n', '    function queryService(bytes32 _lockId)\n', '    public view\n', '    returns (address _sender, uint256 _value, bool _isPrint)\n', '    {\n', '        PendingService storage service = pendingServiceMap[_lockId];\n', '        _sender = service.sender;\n', '        _value = service.value;\n', '        _isPrint = service.isPrint;\n', '    }\n', '\n', '    function releaseTeam()\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint256 teamAvailable = erc20Store.availableMap(erc20Store.team());\n', '        if (teamAvailable > 0 && now > erc20Store.createDate() + 3 * 1 years) {\n', '            erc20Store.addBalance(erc20Store.team(), teamAvailable);\n', '            erc20Store.setTotalSupply(erc20Store.totalSupply() + teamAvailable);\n', '            erc20Store.reduceAvailable(erc20Store.team(), teamAvailable);\n', '            erc20Proxy.emitTransfer(address(0), erc20Store.team(), teamAvailable);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function releasePartner()\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint256 partnerAvailable = erc20Store.availableMap(erc20Store.partner());\n', '        if (partnerAvailable > 0) {\n', '            erc20Store.addBalance(erc20Store.partner(), partnerAvailable);\n', '            erc20Store.setTotalSupply(erc20Store.totalSupply() + partnerAvailable);\n', '            erc20Store.reduceAvailable(erc20Store.partner(), partnerAvailable);\n', '            erc20Proxy.emitTransfer(address(0), erc20Store.partner(), partnerAvailable);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    event ServicePublished(bytes32 _lockId, address _sender, uint256 _value, bool _result);\n', '\n', '    event ServiceConfirmed(bytes32 _lockId, address _sender, address _to, uint256 _value, bool _result);\n', '\n', '    event ServiceCanceled(bytes32 _lockId, address _sender, uint256 _value);\n', '\n', '    event PrimaryChanged(address _primary, bool opt);\n', '\n', '}']