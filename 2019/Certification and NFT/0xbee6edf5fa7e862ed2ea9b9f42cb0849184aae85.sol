['pragma solidity 0.5.9;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '\tstruct Role {\n', '\t\tmapping (address => bool) bearer;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev give an account access to this role\n', '\t */\n', '\tfunction add(Role storage role, address account) internal {\n', '\t\trequire(account != address(0));\n', '\t\trequire(!has(role, account));\n', '\n', '\t\trole.bearer[account] = true;\n', '\t}\n', '\n', '\t/**\n', "\t * @dev remove an account's access to this role\n", '\t */\n', '\tfunction remove(Role storage role, address account) internal {\n', '\t\trequire(account != address(0));\n', '\t\trequire(has(role, account));\n', '\n', '\t\trole.bearer[account] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev check if an account has this role\n', '\t * @return bool\n', '\t */\n', '\tfunction has(Role storage role, address account) internal view returns (bool) {\n', '\t\trequire(account != address(0));\n', '\t\treturn role.bearer[account];\n', '\t}\n', '}\n', 'contract ETORoles {\n', '\tusing Roles for Roles.Role;\n', '\n', '\tconstructor() internal {\n', '\t\t_addAuditWriter(msg.sender);\n', '\t\t_addAssetSeizer(msg.sender);\n', '\t\t_addKycProvider(msg.sender);\n', '\t\t_addUserManager(msg.sender);\n', '\t\t_addOwner(msg.sender);\n', '\t}\n', '\n', '\t/*\n', '\t * Audit Writer functions\n', '\t */\n', '\tevent AuditWriterAdded(address indexed account);\n', '\tevent AuditWriterRemoved(address indexed account);\n', '\n', '\tRoles.Role private _auditWriters;\n', '\n', '\tmodifier onlyAuditWriter() {\n', '\t\trequire(isAuditWriter(msg.sender), "Sender is not auditWriter");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isAuditWriter(address account) public view returns (bool) {\n', '\t\treturn _auditWriters.has(account);\n', '\t}\n', '\n', '\tfunction addAuditWriter(address account) public onlyUserManager {\n', '\t\t_addAuditWriter(account);\n', '\t}\n', '\n', '\tfunction renounceAuditWriter() public {\n', '\t\t_removeAuditWriter(msg.sender);\n', '\t}\n', '\n', '\tfunction _addAuditWriter(address account) internal {\n', '\t\t_auditWriters.add(account);\n', '\t\temit AuditWriterAdded(account);\n', '\t}\n', '\n', '\tfunction _removeAuditWriter(address account) internal {\n', '\t\t_auditWriters.remove(account);\n', '\t\temit AuditWriterRemoved(account);\n', '\t}\n', '\n', '\t/*\n', '\t* KYC Provider functions\n', '\t*/\n', '\tevent KycProviderAdded(address indexed account);\n', '\tevent KycProviderRemoved(address indexed account);\n', '\n', '\tRoles.Role private _kycProviders;\n', '\n', '\tmodifier onlyKycProvider() {\n', '\t\trequire(isKycProvider(msg.sender), "Sender is not kycProvider");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isKycProvider(address account) public view returns (bool) {\n', '\t\treturn _kycProviders.has(account);\n', '\t}\n', '\n', '\tfunction addKycProvider(address account) public onlyUserManager {\n', '\t\t_addKycProvider(account);\n', '\t}\n', '\n', '\tfunction renounceKycProvider() public {\n', '\t\t_removeKycProvider(msg.sender);\n', '\t}\n', '\n', '\tfunction _addKycProvider(address account) internal {\n', '\t\t_kycProviders.add(account);\n', '\t\temit KycProviderAdded(account);\n', '\t}\n', '\n', '\tfunction _removeKycProvider(address account) internal {\n', '\t\t_kycProviders.remove(account);\n', '\t\temit KycProviderRemoved(account);\n', '\t}\n', '\n', '\t/*\n', '\t* Asset Seizer functions\n', '\t*/\n', '\tevent AssetSeizerAdded(address indexed account);\n', '\tevent AssetSeizerRemoved(address indexed account);\n', '\n', '\tRoles.Role private _assetSeizers;\n', '\n', '\tmodifier onlyAssetSeizer() {\n', '\t\trequire(isAssetSeizer(msg.sender), "Sender is not assetSeizer");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isAssetSeizer(address account) public view returns (bool) {\n', '\t\treturn _assetSeizers.has(account);\n', '\t}\n', '\n', '\tfunction addAssetSeizer(address account) public onlyUserManager {\n', '\t\t_addAssetSeizer(account);\n', '\t}\n', '\n', '\tfunction renounceAssetSeizer() public {\n', '\t\t_removeAssetSeizer(msg.sender);\n', '\t}\n', '\n', '\tfunction _addAssetSeizer(address account) internal {\n', '\t\t_assetSeizers.add(account);\n', '\t\temit AssetSeizerAdded(account);\n', '\t}\n', '\n', '\tfunction _removeAssetSeizer(address account) internal {\n', '\t\t_assetSeizers.remove(account);\n', '\t\temit AssetSeizerRemoved(account);\n', '\t}\n', '\n', '\t/*\n', '\t* User Manager functions\n', '\t*/\n', '\tevent UserManagerAdded(address indexed account);\n', '\tevent UserManagerRemoved(address indexed account);\n', '\n', '\tRoles.Role private _userManagers;\n', '\n', '\tmodifier onlyUserManager() {\n', '\t\trequire(isUserManager(msg.sender), "Sender is not UserManager");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isUserManager(address account) public view returns (bool) {\n', '\t\treturn _userManagers.has(account);\n', '\t}\n', '\n', '\tfunction addUserManager(address account) public onlyUserManager {\n', '\t\t_addUserManager(account);\n', '\t}\n', '\n', '\tfunction renounceUserManager() public {\n', '\t\t_removeUserManager(msg.sender);\n', '\t}\n', '\n', '\tfunction _addUserManager(address account) internal {\n', '\t\t_userManagers.add(account);\n', '\t\temit UserManagerAdded(account);\n', '\t}\n', '\n', '\tfunction _removeUserManager(address account) internal {\n', '\t\t_userManagers.remove(account);\n', '\t\temit UserManagerRemoved(account);\n', '\t}\n', '\n', '\t/*\n', '\t* Owner functions\n', '\t*/\n', '\tevent OwnerAdded(address indexed account);\n', '\tevent OwnerRemoved(address indexed account);\n', '\n', '\tRoles.Role private _owners;\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(isOwner(msg.sender), "Sender is not owner");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isOwner(address account) public view returns (bool) {\n', '\t\treturn _owners.has(account);\n', '\t}\n', '\n', '\tfunction addOwner(address account) public onlyUserManager {\n', '\t\t_addOwner(account);\n', '\t}\n', '\n', '\tfunction renounceOwner() public {\n', '\t\t_removeOwner(msg.sender);\n', '\t}\n', '\n', '\tfunction _addOwner(address account) internal {\n', '\t\t_owners.add(account);\n', '\t\temit OwnerAdded(account);\n', '\t}\n', '\n', '\tfunction _removeOwner(address account) internal {\n', '\t\t_owners.remove(account);\n', '\t\temit OwnerRemoved(account);\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '\tfunction transfer(address to, uint256 value) external returns (bool);\n', '\n', '\tfunction approve(address spender, uint256 value) external returns (bool);\n', '\n', '\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '\tfunction totalSupply() external view returns (uint256);\n', '\n', '\tfunction balanceOf(address who) external view returns (uint256);\n', '\n', '\tfunction allowance(address owner, address spender) external view returns (uint256);\n', '\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\t/**\n', '\t* @dev Multiplies two unsigned integers, reverts on overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b);\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// Solidity only automatically asserts when dividing by 0\n', '\t\trequire(b > 0);\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\trequire(b <= a);\n', '\t\tuint256 c = a - b;\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Adds two unsigned integers, reverts on overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a);\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '\t* reverts when dividing by zero.\n', '\t\t*/\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\trequire(b != 0);\n', '\t\treturn a % b;\n', '\t}\n', '}\n', '\n', 'contract ERC20 is IERC20 {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping (address => uint256) private _balances;\n', '\n', '\tmapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '\tuint256 private _totalSupply;\n', '\n', '\t/**\n', '\t* @dev Total number of tokens in existence\n', '\t*/\n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Gets the balance of the specified address.\n', '\t* @param owner The address to query the balance of.\n', '\t\t* @return A uint256 representing the amount owned by the passed address.\n', '\t\t*/\n', '\tfunction balanceOf(address owner) public view returns (uint256) {\n', '\t\treturn _balances[owner];\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '\t* @param owner address The address which owns the funds.\n', '\t\t* @param spender address The address which will spend the funds.\n', '\t\t* @return A uint256 specifying the amount of tokens still available for the spender.\n', '\t\t*/\n', '\tfunction allowance(address owner, address spender) public view returns (uint256) {\n', '\t\treturn _allowed[owner][spender];\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer token to a specified address\n', '\t* @param to The address to transfer to.\n', '\t\t* @param value The amount to be transferred.\n', '\t\t*/\n', '\tfunction transfer(address to, uint256 value) public returns (bool) {\n', '\t\t_transfer(msg.sender, to, value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '\t* Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '\t* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "\t* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '\t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t* @param spender The address which will spend the funds.\n', '\t\t* @param value The amount of tokens to be spent.\n', '\t\t*/\n', '\tfunction approve(address spender, uint256 value) public returns (bool) {\n', '\t\t_approve(msg.sender, spender, value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer tokens from one address to another.\n', '\t* Note that while this function emits an Approval event, this is not required as per the specification,\n', '\t\t* and other compliant implementations may not emit the event.\n', '\t\t* @param from address The address which you want to send tokens from\n', '\t* @param to address The address which you want to transfer to\n', '\t* @param value uint256 the amount of tokens to be transferred\n', '\t*/\n', '\tfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '\t\t_transfer(from, to, value);\n', '\t\t_approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Increase the amount of tokens that an owner allowed to a spender.\n', '\t* approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '\t* allowed value is better to use this function to avoid 2 calls \n', '\t*/\n', '\tfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '\t\t_approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '\t* approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '\t* allowed value is better to use this function to avoid 2 calls (and wait until\n', '\n', '\t */\n', '\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '\t\t_approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer token for a specified addresses\n', '\t* @param from The address to transfer from.\n', '\t\t* @param to The address to transfer to.\n', '\t\t\t* @param value The amount to be transferred.\n', '\t\t\t*/\n', '\tfunction _transfer(address from, address to, uint256 value) internal {\n', '\t\trequire(to != address(0));\n', '\n', '\t\t_balances[from] = _balances[from].sub(value);\n', '\t\t_balances[to] = _balances[to].add(value);\n', '\t\temit Transfer(from, to, value);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Internal function that mints an amount of the token and assigns it to\n', '\t* an account. This encapsulates the modification of balances such that the\n', '\t* proper events are emitted.\n', '\t\t* @param account The account that will receive the created tokens.\n', '\t\t* @param value The amount that will be created.\n', '\t\t*/\n', '\tfunction _mint(address account, uint256 value) internal {\n', '\t\trequire(account != address(0));\n', '\n', '\t\t_totalSupply = _totalSupply.add(value);\n', '\t\t_balances[account] = _balances[account].add(value);\n', '\t\temit Transfer(address(0), account, value);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Internal function that burns an amount of the token of a given\n', '\t* account.\n', '\t\t* @param account The account whose tokens will be burnt.\n', '\t\t* @param value The amount that will be burnt.\n', '\t\t*/\n', '\tfunction _burn(address account, uint256 value) internal {\n', '\t\trequire(account != address(0));\n', '\n', '\t\t_totalSupply = _totalSupply.sub(value);\n', '\t\t_balances[account] = _balances[account].sub(value);\n', '\t\temit Transfer(account, address(0), value);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Approve an address to spend another addresses' tokens.\n", '\t* @param owner The address that owns the tokens.\n', '\t\t* @param spender The address that will spend the tokens.\n', '\t\t* @param value The number of tokens that can be spent.\n', '\t\t*/\n', '\tfunction _approve(address owner, address spender, uint256 value) internal {\n', '\t\trequire(spender != address(0));\n', '\t\trequire(owner != address(0));\n', '\n', '\t\t_allowed[owner][spender] = value;\n', '\t\temit Approval(owner, spender, value);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Internal function that burns an amount of the token of a given\n', "\t* account, deducting from the sender's allowance for said account. Uses the\n", '\t* internal burn function.\n', '\t* Emits an Approval event (reflecting the reduced allowance).\n', '\t\t* @param account The account whose tokens will be burnt.\n', '\t\t* @param value The amount that will be burnt.\n', '\t\t*/\n', '\tfunction _burnFrom(address account, uint256 value) internal {\n', '\t\t_burn(account, value);\n', '\t\t_approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '\t}\n', '}\n', '\n', 'contract MinterRole {\n', '\tusing Roles for Roles.Role;\n', '\n', '\tevent MinterAdded(address indexed account);\n', '\tevent MinterRemoved(address indexed account);\n', '\n', '\tRoles.Role private _minters;\n', '\n', '\tconstructor () internal {\n', '\t\t_addMinter(msg.sender);\n', '\t}\n', '\n', '\tmodifier onlyMinter() {\n', '\t\trequire(isMinter(msg.sender));\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction isMinter(address account) public view returns (bool) {\n', '\t\treturn _minters.has(account);\n', '\t}\n', '\n', '\tfunction addMinter(address account) public onlyMinter {\n', '\t\t_addMinter(account);\n', '\t}\n', '\n', '\tfunction renounceMinter() public {\n', '\t\t_removeMinter(msg.sender);\n', '\t}\n', '\n', '\tfunction _addMinter(address account) internal {\n', '\t\t_minters.add(account);\n', '\t\temit MinterAdded(account);\n', '\t}\n', '\n', '\tfunction _removeMinter(address account) internal {\n', '\t\t_minters.remove(account);\n', '\t\temit MinterRemoved(account);\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title ERC20Mintable\n', ' * @dev ERC20 minting logic\n', ' */\n', 'contract ERC20Mintable is ERC20, MinterRole {\n', '\t/**\n', '\t* @dev Function to mint tokens\n', '\t* @param to The address that will receive the minted tokens.\n', '\t\t* @param value The amount of tokens to mint.\n', '\t\t* @return A boolean that indicates if the operation was successful.\n', '\t\t*/\n', '\tfunction mint(address to, uint256 value) public onlyMinter returns (bool) {\n', '\t\t_mint(to, value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'contract ETOToken is ERC20Mintable, ETORoles {\n', '\t/* ETO investors */\n', '\tmapping(address => bool) public investorWhitelist;\n', '\taddress[] public investorWhitelistLUT;\n', '\n', '\t/* ETO contract parameters */\n', '\tstring public constant name = "Blockstate STO Token";\n', '\tstring public constant symbol = "BKN";\n', '\tuint8 public constant decimals = 0;\n', '\n', '\t/* Listing parameters */\n', '\tstring public ITIN;\n', '\n', '\t/* Audit logging */\n', '\tmapping(uint256 => uint256) public auditHashes;\n', '\n', '\t/* Document hashes */\n', '\tmapping(uint256 => uint256) public documentHashes;\n', '\n', '\t/* Events in the ETO contract */\n', '\t// Transaction related events\n', '\tevent AssetsSeized(address indexed seizee, uint256 indexed amount);\n', '\tevent AssetsUnseized(address indexed seizee, uint256 indexed amount);\n', '\tevent InvestorWhitelisted(address indexed investor);\n', '\tevent InvestorBlacklisted(address indexed investor);\n', '\tevent DividendPayout(address indexed receiver, uint256 indexed amount);\n', '\tevent TokensGenerated(uint256 indexed amount);\n', '\tevent OwnershipUpdated(address indexed newOwner);\n', '\n', '\t/**\n', '\t* @dev Constructor that defines contract parameters\n', '\t*/\n', '\tconstructor() public {\n', '\t\tITIN = "CCF5-T3UQ-2";\n', '\t}\n', '\n', '\t/* Variable update events */\n', '\tevent ITINUpdated(string newValue);\n', '\n', '\t/* Variable Update Functions */\n', '\tfunction setITIN(string memory newValue) public onlyOwner {\n', '\t\tITIN = newValue;\n', '\t\temit ITINUpdated(newValue);\n', '\t}\n', '\t\n', '\t/* Function to set the required allowance before seizing assets */\n', '\tfunction approveFor(address seizee, uint256 seizableAmount) public onlyAssetSeizer {\n', '\t    _approve(seizee, msg.sender, seizableAmount);\n', '\t}\n', '\t\n', '\t/* Seize assets */\n', '\tfunction seizeAssets(address seizee, uint256 seizableAmount) public onlyAssetSeizer {\n', '\t\ttransferFrom(seizee, msg.sender, seizableAmount);\n', '\t\temit AssetsSeized(seizee, seizableAmount);\n', '\t}\n', '\n', '\tfunction releaseAssets(address seizee, uint256 seizedAmount) public onlyAssetSeizer {\n', '\t\trequire(balanceOf(msg.sender) >= seizedAmount, "AssetSeizer has insufficient funds");\n', '\t\ttransfer(seizee, seizedAmount);\n', '\t\temit AssetsUnseized(seizee, seizedAmount);\n', '\t}\n', '\n', '\t/* Add investor to the whitelist */\n', '\tfunction whitelistInvestor(address investor) public onlyKycProvider {\n', '\t\trequire(investorWhitelist[investor] == false, "Investor already whitelisted");\n', '\t\tinvestorWhitelist[investor] = true;\n', '\t\tinvestorWhitelistLUT.push(investor);\n', '\t\temit InvestorWhitelisted(investor);\n', '\t}\n', '\n', '\t/* Remove investor from the whitelist */\n', '\tfunction blacklistInvestor(address investor) public onlyKycProvider {\n', '\t\trequire(investorWhitelist[investor] == true, "Investor not on whitelist");\n', '\t\tinvestorWhitelist[investor] = false;\n', '\t\tuint256 arrayLen = investorWhitelistLUT.length;\n', '\t\tfor (uint256 i = 0; i < arrayLen; i++) {\n', '\t\t\tif (investorWhitelistLUT[i] == investor) {\n', '\t\t\t\tinvestorWhitelistLUT[i] = investorWhitelistLUT[investorWhitelistLUT.length - 1];\n', '\t\t\t\tdelete investorWhitelistLUT[investorWhitelistLUT.length - 1];\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\temit InvestorBlacklisted(investor);\n', '\t}\n', '\n', '\t/* Overwrite transfer() to respect the whitelist, tag- and drag along rules */\n', '\tfunction transfer(address to, uint256 value) public returns (bool) {\n', '\t\trequire(investorWhitelist[to] == true, "Investor not whitelisted");\n', '\t\treturn super.transfer(to, value);\n', '\t}\n', '\n', '\tfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '\t\trequire(investorWhitelist[to] == true, "Investor not whitelisted");\n', '\t\treturn super.transferFrom(from, to, value);\n', '\t}\n', '\n', '\tfunction approve(address spender, uint256 value) public returns (bool) {\n', '\t\trequire(investorWhitelist[spender] == true, "Investor not whitelisted");\n', '\t\treturn super.approve(spender, value);\n', '\t}\n', '\n', '\t/* Generate tokens */\n', '\tfunction generateTokens(uint256 amount, address assetReceiver) public onlyMinter {\n', '\t\t_mint(assetReceiver, amount);\n', '\t}\n', '\n', '\tfunction initiateDividendPayments(uint amount) onlyOwner public returns (bool) {\n', '\t\tuint dividendPerToken = amount / totalSupply();\n', '\t\tuint256 arrayLen = investorWhitelistLUT.length;\n', '\t\tfor (uint256 i = 0; i < arrayLen; i++) {\n', '\t\t\taddress currentInvestor = investorWhitelistLUT[i];\n', '\t\t\tuint256 currentInvestorShares = balanceOf(currentInvestor);\n', '\t\t\tuint256 currentInvestorPayout = dividendPerToken * currentInvestorShares;\n', '\t\t\temit DividendPayout(currentInvestor, currentInvestorPayout);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction addAuditHash(uint256 hash) public onlyAuditWriter {\n', '\t\tauditHashes[now] = hash;\n', '\t}\n', '\n', '\tfunction getAuditHash(uint256 timestamp) public view returns (uint256) {\n', '\t\treturn auditHashes[timestamp];\n', '\t}\n', '\n', '\tfunction addDocumentHash(uint256 hash) public onlyOwner {\n', '\t\tdocumentHashes[now] = hash;\n', '\t}\n', '\n', '\tfunction getDocumentHash(uint256 timestamp) public view returns (uint256) {\n', '\t\treturn documentHashes[timestamp];\n', '\t}\n', '}\n', '\n', 'contract ETOVotes is ETOToken {\n', '\tevent VoteOpen(uint256 _id, uint _deadline);\n', '\tevent VoteFinished(uint256 _id, bool _result);\n', '\n', '\t// How many blocks should we wait before the vote can be closed\n', '\tmapping (uint256 => Vote) private votes;\n', '\n', '\tstruct Voter {\n', '\t\taddress id;\n', '\t\tbool vote;\n', '\t}\n', '\n', '\tstruct Vote {\n', '\t\tuint256 deadline;\n', '\t\tVoter[] voters;\n', '\t\tmapping(address => uint) votersIndex;\n', '\t\tuint256 documentHash;\n', '\t}\n', '\n', '\tconstructor() public {}\n', '\n', '\tfunction vote(uint256 _id, bool _vote) public {\n', '\t\t// Allow changing opinion until vote deadline\n', '\t\trequire (votes[_id].deadline > 0, "Vote not available");\n', '\t\trequire(now <= votes[_id].deadline, "Vote deadline exceeded");\n', '\t\tif (didCastVote(_id)) {\n', '\t\t\tuint256 currentIndex = votes[_id].votersIndex[msg.sender];\n', '\t\t\tVoter memory newVoter = Voter(msg.sender, _vote);\n', '\t\t\tvotes[_id].voters[currentIndex - 1] = newVoter;\n', '\t\t} else {\n', '\t\t\tvotes[_id].voters.push(Voter(msg.sender, _vote));\n', '\t\t\tvotes[_id].votersIndex[msg.sender] = votes[_id].voters.length;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getVoteDocumentHash(uint256 _id) public view returns (uint256) {\n', '\t\treturn votes[_id].documentHash;\n', '\t}\n', '\n', '\tfunction openVote(uint256 _id, uint256 documentHash, uint256 voteDuration) onlyOwner external {\n', '\t\trequire(votes[_id].deadline == 0, "Vote already ongoing");\n', '\t\tvotes[_id].deadline = now + (voteDuration * 1 seconds);\n', '\t\tvotes[_id].documentHash = documentHash;\n', '\t\temit VoteOpen(_id, votes[_id].deadline);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Once the deadline is reached this function should be called to get decision.\n', '\t* @param _id data source id.\n', '\t\t*/\n', '\tfunction triggerDecision(uint256 _id) external {\n', '\t\trequire(votes[_id].deadline > 0, "Vote not available");\n', '\t\trequire(now > votes[_id].deadline, "Vote deadline not reached");\n', '\t\t// prevent method to be called again before its done\n', '\t\tvotes[_id].deadline = 0;\n', '\t\tbool result = (getCurrentPositives(_id) > getCurrentNegatives(_id));\n', '\t\temit VoteFinished(_id, result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev get vote status.\n', '\t* @param _id data source id.\n', '\t\t*/\n', '\tfunction isVoteOpen(uint256 _id) external view returns (bool) {\n', '\t\treturn (votes[_id].deadline > 0) && (now <= votes[_id].deadline);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev check if address voted already.\n', '\t* @param _id data source identifier.\n', '\t*/\n', '\tfunction didCastVote(uint256 _id) public view returns (bool) {\n', '\t\treturn (votes[_id].votersIndex[msg.sender] > 0);\n', '\t}\n', '\n', '\tfunction getOwnVote(uint256 _id) public view returns (bool) {\n', '\t\tuint voterId = votes[_id].votersIndex[msg.sender];\n', '\t\treturn votes[_id].voters[voterId-1].vote;\n', '\t}\n', '\n', '\tfunction getCurrentPositives(uint256 _id) public view returns (uint256) {\n', '\t\tuint adder = 0;\n', '\t\tuint256 arrayLen = votes[_id].voters.length;\n', '\t\tfor (uint256 i = 0; i < arrayLen; i++) {\n', '\t\t\tif (votes[_id].voters[i].vote == true) {\n', '\t\t\t\tadder += balanceOf(votes[_id].voters[i].id);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn adder;\n', '\t}\n', '\n', '\tfunction getCurrentNegatives(uint256 _id) public view returns (uint256) {\n', '\t\tuint adder = 0;\n', '\t\tuint256 arrayLen = votes[_id].voters.length;\n', '\t\tfor (uint256 i = 0; i < arrayLen; i++) {\n', '\t\t\tif (votes[_id].voters[i].vote == false) {\n', '\t\t\t\tadder += balanceOf(votes[_id].voters[i].id);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn adder;\n', '\t}\n', '}']