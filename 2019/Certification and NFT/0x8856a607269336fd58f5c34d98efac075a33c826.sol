['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-05\n', '*/\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '/* Interface for ERC20 Tokens */\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '/* Interface for the DMEX base contract */\n', 'contract EtherMium {\n', '    function getReserve(address token, address user) returns (uint256);\n', '    function setReserve(address token, address user, uint256 amount) returns (bool);\n', '\n', '    function availableBalanceOf(address token, address user) returns (uint256);\n', '    function balanceOf(address token, address user) returns (uint256);\n', '\n', '\n', '    function setBalance(address token, address user, uint256 amount) returns (bool);\n', '    function getAffiliate(address user) returns (address);\n', '    function getInactivityReleasePeriod() returns (uint256);\n', '    function getMakerTakerBalances(address token, address maker, address taker) returns (uint256[4]);\n', '\n', '    function getEtmTokenAddress() returns (address);\n', '\n', '    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) returns (bool);\n', '    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) returns (bool);\n', '    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) returns (bool);\n', '\n', '}\n', '\n', '\n', '\n', '// The DMEX Futures Contract\n', 'contract Exchange {\n', '    function assert(bool assertion) pure {\n', '        \n', '        if (!assertion) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    // Safe Multiply Function - prevents integer overflow \n', '    function safeMul(uint a, uint b) pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    // Safe Subtraction Function - prevents integer overflow \n', '    function safeSub(uint a, uint b) pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // Safe Addition Function - prevents integer overflow \n', '    function safeAdd(uint a, uint b) pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    address public owner; // holds the address of the contract owner\n', '\n', '    // Event fired when the owner of the contract is changed\n', '    event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOracle {\n', '        assert(msg.sender == DmexOracleContract);\n', '        _;\n', '    }\n', '\n', '    // Changes the owner of the contract\n', '    function setOwner(address newOwner) onlyOwner {\n', '        emit SetOwner(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    // Owner getter function\n', '    function getOwner() view returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    mapping (address => bool) public admins;                    // mapping of admin addresses\n', '    mapping (address => uint256) public lastActiveTransaction;  // mapping of user addresses to last transaction block\n', '    mapping (bytes32 => uint256) public orderFills;             // mapping of orders to filled qunatity\n', '    \n', '    address public feeAccount;          // the account that receives the trading fees\n', '    address public exchangeContract;    // the address of the main EtherMium contract\n', '    address public DmexOracleContract;    // the address of the DMEX math contract used for some calculations\n', '\n', '    uint256 public makerFee;            // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '    uint256 public takerFee;            // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '    \n', '    struct FuturesAsset {\n', '        string name;                    // the name of the traded asset (ex. ETHUSD)\n', '        address baseToken;              // the token for collateral\n', '        string priceUrl;                // the url where the price of the asset will be taken for settlement\n', '        string pricePath;               // price path in the returned JSON from the priceUrl (ex. path "last" will return tha value last from the json: {"high": "156.49", "last": "154.31", "timestamp": "1556522201", "bid": "154.22", "vwap": "154.65", "volume": "25578.79138868", "low": "152.33", "ask": "154.26", "open": "152.99"})\n', '        bool inversed;                  // if true, the price from the priceUrl will be inversed (i.e price = 1/priceUrl)\n', '        bool disabled;                  // if true, the asset cannot be used in contract creation (when price url no longer valid)\n', '    }\n', '\n', '    function createFuturesAsset(string name, address baseToken, string priceUrl, string pricePath, bool inversed) onlyAdmin returns (bytes32)\n', '    {    \n', '        bytes32 futuresAsset = keccak256(this, name, baseToken, priceUrl, pricePath, inversed);\n', '        if (futuresAssets[futuresAsset].disabled) throw; // asset already exists and is disabled\n', '\n', '        futuresAssets[futuresAsset] = FuturesAsset({\n', '            name                : name,\n', '            baseToken           : baseToken,\n', '            priceUrl            : priceUrl,\n', '            pricePath           : pricePath,\n', '            inversed            : inversed,\n', '            disabled            : false\n', '        });\n', '\n', '        emit FuturesAssetCreated(futuresAsset, name, baseToken, priceUrl, pricePath, inversed);\n', '        return futuresAsset;\n', '    }\n', '    \n', '    struct FuturesContract {\n', '        bytes32 asset;                  // the hash of the underlying asset object\n', '        uint256 expirationBlock;        // futures contract expiration block\n', '        uint256 closingPrice;           // the closing price for the futures contract\n', '        bool closed;                    // is the futures contract closed (0 - false, 1 - true)\n', '        bool broken;                    // if someone has forced release of funds the contract is marked as broken and can no longer close positions (0-false, 1-true)\n', '        uint256 floorPrice;             // the minimum price that can be traded on the contract, once price is reached the contract expires and enters settlement state \n', '        uint256 capPrice;               // the maximum price that can be traded on the contract, once price is reached the contract expires and enters settlement state\n', '        uint256 multiplier;             // the multiplier price, used when teh trading pair doesn&#39;t have the base token in it (eg. BTCUSD with ETH as base token, multiplier will be the ETHBTC price)\n', '    }\n', '\n', '    function createFuturesContract(bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier) onlyAdmin returns (bytes32)\n', '    {    \n', '        bytes32 futuresContract = keccak256(this, asset, expirationBlock, floorPrice, capPrice, multiplier);\n', '        if (futuresContracts[futuresContract].expirationBlock > 0) return futuresContract; // contract already exists\n', '\n', '        futuresContracts[futuresContract] = FuturesContract({\n', '            asset           : asset,\n', '            expirationBlock : expirationBlock,\n', '            closingPrice    : 0,\n', '            closed          : false,\n', '            broken          : false,\n', '            floorPrice      : floorPrice,\n', '            capPrice        : capPrice,\n', '            multiplier      : multiplier\n', '        });\n', '\n', '        emit FuturesContractCreated(futuresContract, asset, expirationBlock, floorPrice, capPrice, multiplier);\n', '\n', '        return futuresContract;\n', '    }\n', '\n', '    function getContractExpiration (bytes32 futuresContractHash) view returns (uint256)\n', '    {\n', '        return futuresContracts[futuresContractHash].expirationBlock;\n', '    }\n', '\n', '    function getContractClosed (bytes32 futuresContractHash) returns (bool)\n', '    {\n', '        return futuresContracts[futuresContractHash].closed;\n', '    }\n', '\n', '    function getContractPriceUrl (bytes32 futuresContractHash) returns (string)\n', '    {\n', '        return futuresAssets[futuresContracts[futuresContractHash].asset].priceUrl;\n', '    }\n', '\n', '    function getContractPricePath (bytes32 futuresContractHash) returns (string)\n', '    {\n', '        return futuresAssets[futuresContracts[futuresContractHash].asset].pricePath;\n', '    }\n', '\n', '    mapping (bytes32 => FuturesAsset)       public futuresAssets;      // mapping of futuresAsset hash to FuturesAsset structs\n', '    mapping (bytes32 => FuturesContract)    public futuresContracts;   // mapping of futuresContract hash to FuturesContract structs\n', '    mapping (bytes32 => uint256)            public positions;          // mapping of user addresses to position hashes to position\n', '\n', '\n', '    enum Errors {\n', '        INVALID_PRICE,                  // Order prices don&#39;t match\n', '        INVALID_SIGNATURE,              // Signature is invalid\n', '        ORDER_ALREADY_FILLED,           // Order was already filled\n', '        GAS_TOO_HIGH,                   // Too high gas fee\n', '        OUT_OF_BALANCE,                 // User doesn&#39;t have enough balance for the operation\n', '        FUTURES_CONTRACT_EXPIRED,       // Futures contract already expired\n', '        FLOOR_OR_CAP_PRICE_REACHED,     // The floor price or the cap price for the futures contract was reached\n', '        POSITION_ALREADY_EXISTS,        // User has an open position already \n', '        UINT48_VALIDATION,              // Size or price bigger than an Uint48\n', '        FAILED_ASSERTION                // Assertion failed\n', '    }\n', '\n', '    event FuturesTrade(bool side, uint256 size, uint256 price, bytes32 indexed futuresContract, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event FuturesPositionClosed(bytes32 indexed positionHash);\n', '    event FuturesContractClosed(bytes32 indexed futuresContract, uint256 closingPrice);\n', '    event FuturesForcedRelease(bytes32 indexed futuresContract, bool side, address user);\n', '    event FuturesAssetCreated(bytes32 indexed futuresAsset, string name, address baseToken, string priceUrl, string pricePath, bool inversed);\n', '    event FuturesContractCreated(bytes32 indexed futuresContract, bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier);\n', ' \n', '    // Fee change event\n', '    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\n', '\n', '    // Log event, logs errors in contract execution (for internal use)\n', '    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event LogErrorLight(uint8 indexed errorId);\n', '    event LogUint(uint8 id, uint256 value);\n', '    event LogBool(uint8 id, bool value);\n', '    event LogAddress(uint8 id, address value);\n', '\n', '\n', '    // Constructor function, initializes the contract and sets the core variables\n', '    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_, address DmexOracleContract_) {\n', '        owner               = msg.sender;\n', '        feeAccount          = feeAccount_;\n', '        makerFee            = makerFee_;\n', '        takerFee            = takerFee_;\n', '\n', '        exchangeContract    = exchangeContract_;\n', '        DmexOracleContract    = DmexOracleContract_;\n', '    }\n', '\n', '    // Changes the fees\n', '    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\n', '        require(makerFee_       < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\n', '        makerFee                = makerFee_;\n', '        takerFee                = takerFee_;\n', '\n', '        emit FeeChange(makerFee, takerFee);\n', '    }\n', '\n', '    // Adds or disables an admin account\n', '    function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '    // Allows for admins only to call the function\n', '    modifier onlyAdmin {\n', '        if (msg.sender != owner && !admins[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    function() external {\n', '        throw;\n', '    }   \n', '\n', '\n', '    function validateUint48(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint48(val)) return false;\n', '        return true;\n', '    }\n', '\n', '    function validateUint64(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint64(val)) return false;\n', '        return true;\n', '    }\n', '\n', '    function validateUint128(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint128(val)) return false;\n', '        return true;\n', '    }\n', '\n', '\n', '    // Structure that holds order values, used inside the trade() function\n', '    struct FuturesOrderPair {\n', '        uint256 makerNonce;                 // maker order nonce, makes the order unique\n', '        uint256 takerNonce;                 // taker order nonce\n', '        uint256 takerGasFee;                // taker gas fee, taker pays the gas\n', '        uint256 takerIsBuying;              // true/false taker is the buyer\n', '\n', '        address maker;                      // address of the maker\n', '        address taker;                      // address of the taker\n', '\n', '        bytes32 makerOrderHash;             // hash of the maker order\n', '        bytes32 takerOrderHash;             // has of the taker order\n', '\n', '        uint256 makerAmount;                // trade amount for maker\n', '        uint256 takerAmount;                // trade amount for taker\n', '\n', '        uint256 makerPrice;                 // maker order price in wei (18 decimal precision)\n', '        uint256 takerPrice;                 // taker order price in wei (18 decimal precision)\n', '\n', '        bytes32 futuresContract;            // the futures contract being traded\n', '\n', '        address baseToken;                  // the address of the base token for futures contract\n', '        uint256 floorPrice;                 // floor price of futures contract\n', '        uint256 capPrice;                   // cap price of futures contract\n', '\n', '        bytes32 makerPositionHash;          // hash for maker position\n', '        bytes32 makerInversePositionHash;   // hash for inverse maker position \n', '\n', '        bytes32 takerPositionHash;          // hash for taker position\n', '        bytes32 takerInversePositionHash;   // hash for inverse taker position\n', '    }\n', '\n', '    // Structure that holds trade values, used inside the trade() function\n', '    struct FuturesTradeValues {\n', '        uint256 qty;                // amount to be trade\n', '        uint256 makerProfit;        // holds maker profit value\n', '        uint256 makerLoss;          // holds maker loss value\n', '        uint256 takerProfit;        // holds taker profit value\n', '        uint256 takerLoss;          // holds taker loss value\n', '        uint256 makerBalance;       // holds maker balance value\n', '        uint256 takerBalance;       // holds taker balance value\n', '        uint256 makerReserve;       // holds taker reserved value\n', '        uint256 takerReserve;       // holds taker reserved value\n', '    }\n', '\n', '    // Opens/closes futures positions\n', '    function futuresTrade(\n', '        uint8[2] v,\n', '        bytes32[4] rs,\n', '        uint256[8] tradeValues,\n', '        address[2] tradeAddresses,\n', '        bool takerIsBuying,\n', '        bytes32 futuresContractHash\n', '    ) onlyAdmin returns (uint filledTakerTokenAmount)\n', '    {\n', '        /* tradeValues\n', '          [0] makerNonce\n', '          [1] takerNonce\n', '          [2] takerGasFee\n', '          [3] takerIsBuying\n', '          [4] makerAmount\n', '          [5] takerAmount\n', '          [6] makerPrice\n', '          [7] takerPrice\n', '\n', '          tradeAddresses\n', '          [0] maker\n', '          [1] taker\n', '        */\n', '\n', '        FuturesOrderPair memory t  = FuturesOrderPair({\n', '            makerNonce      : tradeValues[0],\n', '            takerNonce      : tradeValues[1],\n', '            takerGasFee     : tradeValues[2],\n', '            takerIsBuying   : tradeValues[3],\n', '            makerAmount     : tradeValues[4],      \n', '            takerAmount     : tradeValues[5],   \n', '            makerPrice      : tradeValues[6],         \n', '            takerPrice      : tradeValues[7],\n', '\n', '            maker           : tradeAddresses[0],\n', '            taker           : tradeAddresses[1],\n', '\n', '            //                                futuresContract      user               amount          price           side             nonce\n', '            makerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[0], tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0]),\n', '            takerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[1], tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1]),            \n', '\n', '            futuresContract : futuresContractHash,\n', '\n', '            baseToken       : futuresAssets[futuresContracts[futuresContractHash].asset].baseToken,\n', '            floorPrice      : futuresContracts[futuresContractHash].floorPrice,\n', '            capPrice        : futuresContracts[futuresContractHash].capPrice,\n', '\n', '            //                                            user               futuresContractHash   side\n', '            makerPositionHash           : keccak256(this, tradeAddresses[0], futuresContractHash, !takerIsBuying),\n', '            makerInversePositionHash    : keccak256(this, tradeAddresses[0], futuresContractHash, takerIsBuying),\n', '\n', '            takerPositionHash           : keccak256(this, tradeAddresses[1], futuresContractHash, takerIsBuying),\n', '            takerInversePositionHash    : keccak256(this, tradeAddresses[1], futuresContractHash, !takerIsBuying)\n', '\n', '        });\n', '\n', '//--> 44 000\n', '    \n', '        // Valifate size and price values\n', '        if (!validateUint128(t.makerAmount) || !validateUint128(t.takerAmount) || !validateUint64(t.makerPrice) || !validateUint64(t.takerPrice))\n', '        {            \n', '            emit LogError(uint8(Errors.UINT48_VALIDATION), t.makerOrderHash, t.takerOrderHash);\n', '            return 0; \n', '        }\n', '\n', '\n', '        // Check if futures contract has expired already\n', '        if (block.number > futuresContracts[t.futuresContract].expirationBlock || futuresContracts[t.futuresContract].closed == true || futuresContracts[t.futuresContract].broken == true)\n', '        {\n', '            emit LogError(uint8(Errors.FUTURES_CONTRACT_EXPIRED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0; // futures contract is expired\n', '        }\n', '\n', '        // Checks the signature for the maker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '       \n', '        // Checks the signature for the taker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '\n', '\n', '        // check prices\n', '        if ((!takerIsBuying && t.makerPrice < t.takerPrice) || (takerIsBuying && t.takerPrice < t.makerPrice))\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_PRICE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0; // prices don&#39;t match\n', '        }      \n', '\n', '//--> 54 000\n', '\n', '         \n', '        \n', '\n', '        uint256[4] memory balances = EtherMium(exchangeContract).getMakerTakerBalances(t.baseToken, t.maker, t.taker);\n', '\n', '        // Initializing trade values structure \n', '        FuturesTradeValues memory tv = FuturesTradeValues({\n', '            qty                 : 0,\n', '            makerProfit         : 0,\n', '            makerLoss           : 0,\n', '            takerProfit         : 0,\n', '            takerLoss           : 0,\n', '            makerBalance        : balances[0], //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            takerBalance        : balances[1],  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            makerReserve        : balances[2],  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            takerReserve        : balances[3]  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '        });\n', '\n', '//--> 60 000\n', '\n', '\n', '         \n', '\n', '        // check if floor price or cap price was reached\n', '        if (futuresContracts[t.futuresContract].floorPrice >= t.makerPrice || futuresContracts[t.futuresContract].capPrice <= t.makerPrice)\n', '        {\n', '            // attepting price outside range\n', '            emit LogError(uint8(Errors.FLOOR_OR_CAP_PRICE_REACHED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '        // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\n', '        // and open inverse positions\n', '        tv.qty = min(safeSub(t.makerAmount, orderFills[t.makerOrderHash]), safeSub(t.takerAmount, orderFills[t.takerOrderHash]));\n', '        \n', '        if (positionExists(t.makerInversePositionHash) && positionExists(t.takerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, min(retrievePosition(t.makerInversePositionHash)[0], retrievePosition(t.takerInversePositionHash)[0]));\n', '        }\n', '        else if (positionExists(t.makerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, retrievePosition(t.makerInversePositionHash)[0]);\n', '        }\n', '        else if (positionExists(t.takerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, retrievePosition(t.takerInversePositionHash)[0]);\n', '        }\n', '\n', '       \n', '\n', '\n', '\n', '//--> 64 000       \n', '        \n', '        if (tv.qty == 0)\n', '        {\n', '            // no qty left on orders\n', '            emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '        // Cheks that gas fee is not higher than 10%\n', '        if (safeMul(t.takerGasFee, 20) > calculateTradeValue(tv.qty, t.makerPrice, t.futuresContract))\n', '        {\n', '            emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        } // takerGasFee too high\n', '\n', '\n', '        // check if users have open positions already\n', '        // if (positionExists(t.makerPositionHash) || positionExists(t.takerPositionHash))\n', '        // {\n', '        //     // maker already has the position open, first must close existing position before opening a new one\n', '        //     emit LogError(uint8(Errors.POSITION_ALREADY_EXISTS), t.makerOrderHash, t.takerOrderHash);\n', '        //     return 0; \n', '        // }\n', '\n', '//--> 66 000\n', '        \n', '\n', '       \n', '\n', '        /*------------- Maker long, Taker short -------------*/\n', '        if (!takerIsBuying)\n', '        {     \n', '            \n', '      \n', '            // position actions for maker\n', '            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\n', '            {\n', '\n', '\n', '                // check if maker has enough balance   \n', '                \n', '                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                \n', '                \n', '                // create new position\n', '                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 1, block.number);\n', '\n', '\n', '\n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken, // base token\n', '                        t.maker // make address\n', '                    ], \n', '                    t.makerPositionHash,  // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice,  // price\n', '                        makerFee, // fee\n', '                        0, // profit\n', '                        0, // loss\n', '                        tv.makerBalance, // balance\n', '                        0, // gasFee\n', '                        tv.makerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        true, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {               \n', '                \n', '                if (positionExists(t.makerPositionHash))\n', '                {\n', '                    // check if maker has enough balance            \n', '                    // if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, \n', '                    //     safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);\n', '                    \n', '                    \n', '\n', '                    if (t.makerPrice < retrievePosition(t.makerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.makerProfit                    = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\n', '                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.makerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;    \n', '                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                        \n', '                    }\n', '\n', '\n', '\n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            tv.makerProfit,  // profit\n', '                            tv.makerLoss,  // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }                \n', '            }\n', '\n', '           \n', '\n', '\n', '            // position actions for taker\n', '            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\n', '            {\n', '                \n', '                // check if taker has enough balance\n', '                // if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\n', '                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '                \n', '                // create new position\n', '                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 0, block.number);\n', '                \n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken, // base token\n', '                        t.taker // make address\n', '                    ], \n', '                    t.takerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice,  // price\n', '                        takerFee, // fee\n', '                        0, // profit\n', '                        0,  // loss\n', '                        tv.takerBalance,  // balance\n', '                        t.takerGasFee, // gasFee\n', '                        tv.takerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        false, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.takerPositionHash))\n', '                {\n', '                    // check if taker has enough balance\n', '                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\n', '                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.taker // make address\n', '                        ], \n', '                        t.takerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {   \n', '\n', '\n', '                     \n', '                   \n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\n', '                    \n', '\n', '\n', '                    if (t.makerPrice > retrievePosition(t.takerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.takerProfit                    = safeMul(safeSub(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1]), tv.qty) / t.makerPrice;\n', '                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.takerLoss                      = safeMul(safeSub(retrievePosition(t.takerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;                                  \n', '                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false); \n', '                    }\n', '\n', '                  \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.taker // make address\n', '                        ], \n', '                        t.takerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            tv.takerProfit, // profit\n', '                            tv.takerLoss, // loss\n', '                            tv.takerBalance,  // balance\n', '                            t.takerGasFee,  // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }\n', '        }\n', '\n', '\n', '        /*------------- Maker short, Taker long -------------*/\n', '\n', '        else\n', '        {      \n', '            //LogUint(1, safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty)); return;\n', '\n', '            // position actions for maker\n', '            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\n', '            {\n', '                // check if maker has enough balance\n', '                //if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                // create new position\n', '                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 0, block.number);\n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken,   // base token\n', '                        t.maker // make address\n', '                    ], \n', '                    t.makerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice, // price\n', '                        makerFee, // fee\n', '                        0, // profit\n', '                        0, // loss\n', '                        tv.makerBalance, // balance\n', '                        0, // gasFee\n', '                        tv.makerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        false, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.makerPositionHash))\n', '                {\n', '                    // check if maker has enough balance\n', '                    //if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);       \n', '                    \n', '\n', '\n', '                    if (t.makerPrice > retrievePosition(t.makerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.makerProfit                    = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;\n', '                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.makerLoss                      = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice; \n', '                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);                               \n', '                    }\n', '\n', '                   \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.maker // user address\n', '                        ], \n', '                        t.makerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            tv.makerProfit,  // profit\n', '                            tv.makerLoss, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }\n', '\n', '            // position actions for taker\n', '            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\n', '            {\n', '                // check if taker has enough balance\n', '                // if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether)), t.takerGasFee / 1e10) * 1e10 > safeSub(balances[1],tv.takerReserve))\n', '                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                // create new position\n', '                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 1, block.number);\n', '           \n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken,  // base token\n', '                        t.taker // user address\n', '                    ], \n', '                    t.takerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice, // price\n', '                        takerFee, // fee\n', '                        0,  // profit\n', '                        0,  // loss\n', '                        tv.takerBalance, // balance\n', '                        t.takerGasFee, // gasFee\n', '                        tv.takerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        true, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.takerPositionHash))\n', '                {\n', '                    // check if taker has enough balance\n', '                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether)), t.takerGasFee / 1e10) * 1e10 > safeSub(balances[1],tv.takerReserve))\n', '                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '                    \n', '                    // increase position size\n', '                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.taker // user address\n', '                        ], \n', '                        t.takerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\n', '                                     \n', '                    if (t.makerPrice < retrievePosition(t.takerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.takerProfit                    = safeMul(safeSub(retrievePosition(t.takerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\n', '                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.takerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1]), tv.qty) / t.makerPrice; \n', '                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                  \n', '                    }\n', '\n', '                    \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,   // base toke\n', '                            t.taker // user address\n', '                        ], \n', '                        t.takerInversePositionHash,  // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            tv.takerProfit, // profit\n', '                            tv.takerLoss, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long) \n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }           \n', '        }\n', '\n', '//--> 220 000\n', '        orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty); // increase the maker order filled amount\n', '        orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); // increase the taker order filled amount\n', '\n', '//--> 264 000\n', '        emit FuturesTrade(takerIsBuying, tv.qty, t.makerPrice, t.futuresContract, t.makerOrderHash, t.takerOrderHash);\n', '\n', '        return tv.qty;\n', '    }\n', '\n', '\n', '    function calculateProfit(uint256 closingPrice, uint256 entryPrice, uint256 qty, bytes32 futuresContractHash, bool side) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(entryPrice, closingPrice), qty) / closingPrice;  \n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier)  / 1e8 / 1e18;\n', '            }\n', '            \n', '        }\n', '        else\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(closingPrice, entryPrice), qty) / closingPrice; \n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier)  / 1e8 / 1e18; \n', '            }\n', '        }       \n', '    }\n', '\n', '    function calculateTradeValue(uint256 qty, uint256 price, bytes32 futuresContractHash) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '        if (inversed)\n', '        {\n', '            return qty * 1e10;\n', '        }\n', '        else\n', '        {\n', '            return safeMul(safeMul(safeMul(qty, price), 1e2), multiplier) / 1e18 ;\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function calculateLoss(uint256 closingPrice, uint256 entryPrice, uint256 qty,  bytes32 futuresContractHash, bool side) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(closingPrice, entryPrice), qty) / closingPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(entryPrice, closingPrice), qty) / closingPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier) / 1e8 / 1e18;\n', '            } \n', '        }\n', '        \n', '    }\n', '\n', '    function calculateCollateral (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, bytes32 futuresContractHash) view returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            // long\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(tradePrice, limitPrice), qty) / limitPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(tradePrice, limitPrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            // short\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(limitPrice, tradePrice), qty)  / limitPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(limitPrice, tradePrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }         \n', '    }\n', '\n', '    function calculateFee (uint256 qty, uint256 tradePrice, uint256 fee, bytes32 futuresContractHash) returns (uint256)\n', '    {\n', '        return safeMul(calculateTradeValue(qty, tradePrice, futuresContractHash), fee) / 1e18 / 1e10;\n', '    }\n', '\n', '\n', '    function checkEnoughBalance (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, uint256 fee, uint256 gasFee, bytes32 futuresContractHash, uint256 availableBalance) view returns (bool)\n', '    {\n', '        \n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            // long\n', '            if (safeAdd(\n', '                    safeAdd(\n', '                        calculateCollateral(limitPrice, tradePrice, qty, side, futuresContractHash), \n', '                        //safeMul(qty, fee) / (1 ether)\n', '                        calculateFee(qty, tradePrice, fee, futuresContractHash)\n', '                    ) * 1e10,\n', '                    gasFee \n', '                ) > availableBalance)\n', '            {\n', '                return false; \n', '            }\n', '        }\n', '        else\n', '        {\n', '            // short\n', '            if (safeAdd(\n', '                    safeAdd(\n', '                        calculateCollateral(limitPrice, tradePrice, qty, side, futuresContractHash), \n', '                        //safeMul(qty, fee) / (1 ether)\n', '                        calculateFee(qty, tradePrice, fee, futuresContractHash)\n', '                    ) * 1e10, \n', '                    gasFee \n', '                ) > availableBalance)\n', '            {\n', '                return false;\n', '            }\n', '\n', '        }\n', '\n', '        return true;\n', '       \n', '    }  \n', '\n', '      \n', '\n', '    // Executes multiple trades in one transaction, saves gas fees\n', '    function batchFuturesTrade(\n', '        uint8[2][] v,\n', '        bytes32[4][] rs,\n', '        uint256[8][] tradeValues,\n', '        address[2][] tradeAddresses,\n', '        bool[] takerIsBuying,\n', '        bytes32[] assetHash,\n', '        uint256[4][] contractValues\n', '    ) onlyAdmin\n', '    {\n', '        // perform trades\n', '        for (uint i = 0; i < tradeAddresses.length; i++) {\n', '            futuresTrade(\n', '                v[i],\n', '                rs[i],\n', '                tradeValues[i],\n', '                tradeAddresses[i],\n', '                takerIsBuying[i],\n', '                createFuturesContract(assetHash[i], contractValues[i][0], contractValues[i][1], contractValues[i][2], contractValues[i][3])\n', '            );\n', '        }\n', '    }\n', '\n', '    \n', '\n', '\n', '    // Update user balance\n', '    function updateBalances (bytes32 futuresContract, address[2] addressValues, bytes32 positionHash, uint256[8] uintValues, bool[3] boolValues) private\n', '    {\n', '        /*\n', '            addressValues\n', '            [0] baseToken\n', '            [1] user\n', '\n', '            uintValues\n', '            [0] qty\n', '            [1] price\n', '            [2] fee\n', '            [3] profit\n', '            [4] loss\n', '            [5] balance\n', '            [6] gasFee\n', '            [7] reserve\n', '\n', '            boolValues\n', '            [0] newPostion\n', '            [1] side\n', '            [2] increase position\n', '\n', '        */\n', '\n', '        //                          qty * price * fee\n', '        // uint256 pam[0] = safeMul(safeMul(uintValues[0], uintValues[1]), uintValues[2]) / (1 ether);\n', '        // uint256 collateral;  \n', '\n', '\n', '        // pam = [fee value, collateral]                        \n', '        uint256[2] memory pam = [safeAdd(calculateFee(uintValues[0], uintValues[1], uintValues[2], futuresContract) * 1e10, uintValues[6]), 0];\n', '        \n', '        // LogUint(100, uintValues[3]);\n', '        // LogUint(9, uintValues[2]);\n', '        // LogUint(7, safeMul(uintValues[0], uintValues[2])  / (1 ether));\n', '        // return;\n', '\n', '        \n', '\n', '        // Position is new or position is increased\n', '        if (boolValues[0] || boolValues[2])  \n', '        {\n', '\n', '            if (boolValues[1])\n', '            {\n', '\n', '                //addReserve(addressValues[0], addressValues[1], uintValues[ 7], safeMul(safeSub(uintValues[1], futuresContracts[futuresContract].floorPrice), uintValues[0])); // reserve collateral on user\n', '                //pam[1] = safeMul(safeSub(uintValues[1], futuresContracts[futuresContract].floorPrice), uintValues[0]) / futuresContracts[futuresContract].floorPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, uintValues[1], uintValues[0], true, futuresContract);\n', '\n', '            }\n', '            else\n', '            {\n', '                //addReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(safeSub(futuresContracts[futuresContract].capPrice, uintValues[1]), uintValues[0])); // reserve collateral on user\n', '                //pam[1] = safeMul(safeSub(futuresContracts[futuresContract].capPrice, uintValues[1]), uintValues[0]) / futuresContracts[futuresContract].capPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, uintValues[1], uintValues[0], false, futuresContract);\n', '            }\n', '\n', '            subBalanceAddReserve(addressValues[0], addressValues[1], pam[0], safeAdd(pam[1],1));         \n', '\n', '            // if (uintValues[6] > 0)\n', '            // {   \n', '            //     subBalanceAddReserve(addressValues[0], addressValues[1], safeAdd(uintValues[6], pam[0]), pam[1]);                  \n', '                              \n', '            // }\n', '            // else\n', '            // {\n', '\n', '            //    subBalanceAddReserve(addressValues[0], addressValues[1], safeAdd(uintValues[6], pam[0]), pam[1]);                 \n', '            // }\n', '\n', '\n', '            //subBalance(addressValues[0], addressValues[1], uintValues[5], feeVal); // deduct user maker/taker fee \n', '\n', '            \n', '        // Position exists\n', '        } \n', '        else \n', '        {\n', '            if (retrievePosition(positionHash)[2] == 0)\n', '            {\n', '                // original position was short\n', '                //subReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(uintValues[0], safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]))); // remove freed collateral from reserver\n', '                //pam[1] = safeMul(uintValues[0], safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1])) / futuresContracts[futuresContract].capPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1], uintValues[0], false, futuresContract);\n', '\n', '                // LogUint(120, uintValues[0]);\n', '                // LogUint(121, futuresContracts[futuresContract].capPrice);\n', '                // LogUint(122, retrievePosition(positionHash)[1]);\n', '                // LogUint(123, uintValues[3]); // profit\n', '                // LogUint(124, uintValues[4]); // loss\n', '                // LogUint(125, safeAdd(uintValues[4], pam[0]));\n', '                // LogUint(12, pam[1] );\n', '                //return;\n', '            }\n', '            else\n', '            {       \n', '                       \n', '                // original position was long\n', '                //subReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(uintValues[0], safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice)));\n', '                //pam[1] = safeMul(uintValues[0], safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice)) / futuresContracts[futuresContract].floorPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, retrievePosition(positionHash)[1], uintValues[0], true, futuresContract);\n', '\n', '            }\n', '\n', '\n', '                // LogUint(41, uintValues[3]);\n', '                // LogUint(42, uintValues[4]);\n', '                // LogUint(43, pam[0]);\n', '                // return;  \n', '            if (uintValues[3] > 0) \n', '            {\n', '                // profi > 0\n', '\n', '                if (pam[0] <= uintValues[3]*1e10)\n', '                {\n', '                    //addBalance(addressValues[0], addressValues[1], uintValues[5], safeSub(uintValues[3], pam[0])); // add profit to user balance\n', '                    addBalanceSubReserve(addressValues[0], addressValues[1], safeSub(uintValues[3]*1e10, pam[0]), pam[1]);\n', '                }\n', '                else\n', '                {\n', '                    subBalanceSubReserve(addressValues[0], addressValues[1], safeSub(pam[0], uintValues[3]*1e10), pam[1]);\n', '                }\n', '                \n', '            } \n', '            else \n', '            {   \n', '                \n', '\n', '                // loss >= 0\n', '                //subBalance(addressValues[0], addressValues[1], uintValues[5], safeAdd(uintValues[4], pam[0])); // deduct loss from user balance \n', '                subBalanceSubReserve(addressValues[0], addressValues[1], safeAdd(uintValues[4]*1e10, pam[0]), pam[1]); // deduct loss from user balance\n', '           \n', '            } \n', '            //}            \n', '        }          \n', '        \n', '        addBalance(addressValues[0], feeAccount, EtherMium(exchangeContract).balanceOf(addressValues[0], feeAccount), pam[0]); // send fee to feeAccount\n', '    }\n', '\n', '    function recordNewPosition (bytes32 positionHash, uint256 size, uint256 price, uint256 side, uint256 block) private\n', '    {\n', '        if (!validateUint128(size) || !validateUint64(price)) \n', '        {\n', '            throw;\n', '        }\n', '\n', '        uint256 character = uint128(size);\n', '        character |= price<<128;\n', '        character |= side<<192;\n', '        character |= block<<208;\n', '\n', '        positions[positionHash] = character;\n', '    }\n', '\n', '    function retrievePosition (bytes32 positionHash) public view returns (uint256[4])\n', '    {\n', '        uint256 character = positions[positionHash];\n', '        uint256 size = uint256(uint128(character));\n', '        uint256 price = uint256(uint64(character>>128));\n', '        uint256 side = uint256(uint16(character>>192));\n', '        uint256 entryBlock = uint256(uint48(character>>208));\n', '\n', '        return [size, price, side, entryBlock];\n', '    }\n', '\n', '    function updatePositionSize(bytes32 positionHash, uint256 size, uint256 price) private\n', '    {\n', '        uint256[4] memory pos = retrievePosition(positionHash);\n', '\n', '        if (size > pos[0])\n', '        {\n', '            // position is increasing in size\n', '            recordNewPosition(positionHash, size, safeAdd(safeMul(pos[0], pos[1]), safeMul(price, safeSub(size, pos[0]))) / size, pos[2], pos[3]);\n', '        }\n', '        else\n', '        {\n', '            // position is decreasing in size\n', '            recordNewPosition(positionHash, size, pos[1], pos[2], pos[3]);\n', '        }        \n', '    }\n', '\n', '    function positionExists (bytes32 positionHash) internal view returns (bool)\n', '    {\n', '        //LogUint(3,retrievePosition(positionHash)[0]);\n', '        if (retrievePosition(positionHash)[0] == 0)\n', '        {\n', '            return false;\n', '        }\n', '        else\n', '        {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // This function allows the user to manually release collateral in case the oracle service does not provide the price during the inactivityReleasePeriod\n', '    function forceReleaseReserve (bytes32 futuresContract, bool side) public\n', '    {   \n', '        if (futuresContracts[futuresContract].expirationBlock == 0) throw;       \n', '        if (futuresContracts[futuresContract].expirationBlock > block.number) throw;\n', '        if (safeAdd(futuresContracts[futuresContract].expirationBlock, EtherMium(exchangeContract).getInactivityReleasePeriod()) > block.number) throw;  \n', '\n', '        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);\n', '        if (retrievePosition(positionHash)[1] == 0) throw;    \n', '  \n', '\n', '        futuresContracts[futuresContract].broken = true;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        if (side)\n', '        {\n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                EtherMium(exchangeContract).getReserve(baseToken, msg.sender), \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice\n', '                calculateCollateral(futuresContracts[futuresContract].floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, futuresContract)\n', '            ); \n', '        }\n', '        else\n', '        {            \n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                EtherMium(exchangeContract).getReserve(baseToken, msg.sender), \n', '                //safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice\n', '                calculateCollateral(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, futuresContract)\n', '            ); \n', '        }\n', '\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), );\n', '        //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], positions[msg.sender][positionHash].collateral);\n', '\n', '        emit FuturesForcedRelease(futuresContract, side, msg.sender);\n', '\n', '    }\n', '\n', '    function addBalance(address token, address user, uint256 balance, uint256 amount) private\n', '    {\n', '        EtherMium(exchangeContract).setBalance(token, user, safeAdd(balance, amount));\n', '    }\n', '\n', '    function subBalance(address token, address user, uint256 balance, uint256 amount) private\n', '    {\n', '        EtherMium(exchangeContract).setBalance(token, user, safeSub(balance, amount));\n', '    }\n', '\n', '    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) private\n', '    {\n', '        EtherMium(exchangeContract).subBalanceAddReserve(token, user, subBalance, addReserve * 1e10);\n', '    }\n', '\n', '    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) private\n', '    {\n', '\n', '        EtherMium(exchangeContract).addBalanceSubReserve(token, user, addBalance, subReserve * 1e10);\n', '    }\n', '\n', '    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) private\n', '    {\n', '        // LogUint(31, subBalance);\n', '        // LogUint(32, subReserve);\n', '        // return;\n', '\n', '        EtherMium(exchangeContract).subBalanceSubReserve(token, user, subBalance, subReserve * 1e10);\n', '    }\n', '\n', '    function addReserve(address token, address user, uint256 reserve, uint256 amount) private\n', '    {\n', '        //reserve[token][user] = safeAdd(reserve[token][user], amount);\n', '        EtherMium(exchangeContract).setReserve(token, user, safeAdd(reserve, amount * 1e10));\n', '    }\n', '\n', '    function subReserve(address token, address user, uint256 reserve, uint256 amount) private \n', '    {\n', '        //reserve[token][user] = safeSub(reserve[token][user], amount);\n', '        EtherMium(exchangeContract).setReserve(token, user, safeSub(reserve, amount * 1e10));\n', '    }\n', '\n', '\n', '    function getMakerTakerBalances(address maker, address taker, address token) public view returns (uint256[4])\n', '    {\n', '        return [\n', '            EtherMium(exchangeContract).balanceOf(token, maker),\n', '            EtherMium(exchangeContract).getReserve(token, maker),\n', '            EtherMium(exchangeContract).balanceOf(token, taker),\n', '            EtherMium(exchangeContract).getReserve(token, taker)\n', '        ];\n', '    }\n', '\n', '    function getMakerTakerPositions(bytes32 makerPositionHash, bytes32 makerInversePositionHash, bytes32 takerPosition, bytes32 takerInversePosition) public view returns (uint256[4][4])\n', '    {\n', '        return [\n', '            retrievePosition(makerPositionHash),\n', '            retrievePosition(makerInversePositionHash),\n', '            retrievePosition(takerPosition),\n', '            retrievePosition(takerInversePosition)\n', '        ];\n', '    }\n', '\n', '\n', '    struct FuturesClosePositionValues {\n', '        uint256 reserve;                // amount to be trade\n', '        uint256 balance;        // holds maker profit value\n', '        uint256 floorPrice;          // holds maker loss value\n', '        uint256 capPrice;        // holds taker profit value\n', '        uint256 closingPrice;          // holds taker loss value\n', '        bytes32 futuresContract; // the futures contract hash\n', '    }\n', '\n', '\n', '    function closeFuturesPosition (bytes32 futuresContract, bool side)\n', '    {\n', '        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);\n', '\n', '        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\n', '        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\n', '        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\n', '\n', '        uint256 profit;\n', '        uint256 loss;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        FuturesClosePositionValues memory v = FuturesClosePositionValues({\n', '            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),\n', '            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),\n', '            floorPrice      : futuresContracts[futuresContract].floorPrice,\n', '            capPrice        : futuresContracts[futuresContract].capPrice,\n', '            closingPrice    : futuresContracts[futuresContract].closingPrice,\n', '            futuresContract : futuresContract\n', '        });\n', '\n', '        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);\n', '        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);\n', '        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;\n', '        // uint256 capPrice = futuresContracts[futuresContract].capPrice;\n', '        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;\n', '\n', '\n', '        \n', '        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);\n', '        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);\n', '\n', '\n', '\n', '        // close long position\n', '        if (side == true)\n', '        {            \n', '\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);\n', '            // return;\n', '            // reserve = reserve - (entryPrice - floorPrice) * size;\n', '            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));\n', '            \n', '            \n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                v.reserve, \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice\n', '                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice > retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);\n', '                \n', '\n', '\n', '                // LogUint(15, profit);\n', '                // LogUint(16, fee);\n', '                // LogUint(17, safeSub(profit * 1e10, fee));\n', '                // return;\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  \n', '\n', '\n', '                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }   \n', '        // close short position \n', '        else\n', '        {\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);\n', '            // return;\n', '\n', '            // reserve = reserve - (capPrice - entryPrice) * size;\n', '            subReserve(\n', '                baseToken, \n', '                msg.sender,  \n', '                v.reserve, \n', '                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice\n', '                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice < retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                // profit = (entryPrice - closingPrice) * size\n', '                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);\n', '\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                // profit = (closingPrice - entryPrice) * size\n', '                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  \n', '\n', '                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }  \n', '\n', '        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        emit FuturesPositionClosed(positionHash);\n', '    }\n', '\n', '    function closeFuturesContract (bytes32 futuresContract, uint256 price) onlyOracle returns (bool)\n', '    {\n', '        if (futuresContracts[futuresContract].expirationBlock == 0)  return false; // contract not found\n', '        if (futuresContracts[futuresContract].closed == true)  return false; // contract already closed\n', '\n', '        if (futuresContracts[futuresContract].expirationBlock > block.number\n', '            && price > futuresContracts[futuresContract].floorPrice\n', '            && price < futuresContracts[futuresContract].capPrice) return false; // contract not yet expired and the price did not leave the range\n', '                \n', '\n', '        if (price <= futuresContracts[futuresContract].floorPrice)  \n', '        {\n', '            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].floorPrice; \n', '        }  \n', '        else if (price >= futuresContracts[futuresContract].capPrice)\n', '        {\n', '            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].capPrice;\n', '        }   \n', '        else\n', '        {\n', '            futuresContracts[futuresContract].closingPrice = price;\n', '        }         \n', '        \n', '\n', '        futuresContracts[futuresContract].closed = true;\n', '\n', '        emit FuturesContractClosed(futuresContract, price);\n', '    }  \n', '\n', '    // closes position for user\n', '    function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin\n', '    {\n', '        bytes32 positionHash = keccak256(this, user, futuresContract, side);\n', '\n', '        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\n', '        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\n', '        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\n', '\n', '        // failsafe, gas fee cannot be greater than 5% of position value\n', '        if (safeMul(gasFee * 1e10, 20) > calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))\n', '        {\n', '            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);\n', '            return;\n', '        }\n', '\n', '\n', '        uint256 profit;\n', '        uint256 loss;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        FuturesClosePositionValues memory v = FuturesClosePositionValues({\n', '            reserve         : EtherMium(exchangeContract).getReserve(baseToken, user),\n', '            balance         : EtherMium(exchangeContract).balanceOf(baseToken, user),\n', '            floorPrice      : futuresContracts[futuresContract].floorPrice,\n', '            capPrice        : futuresContracts[futuresContract].capPrice,\n', '            closingPrice    : futuresContracts[futuresContract].closingPrice,\n', '            futuresContract : futuresContract\n', '        });\n', '\n', '        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);\n', '        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);\n', '        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;\n', '        // uint256 capPrice = futuresContracts[futuresContract].capPrice;\n', '        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;\n', '\n', '\n', '        \n', '        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);\n', '        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);\n', '\n', '        // close long position\n', '        if (side == true)\n', '        {            \n', '\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);\n', '            // return;\n', '            // reserve = reserve - (entryPrice - floorPrice) * size;\n', '            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));\n', '            \n', '            \n', '            subReserve(\n', '                baseToken, \n', '                user, \n', '                v.reserve, \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice\n', '                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice > retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);\n', '                \n', '\n', '\n', '                // LogUint(15, profit);\n', '                // LogUint(16, fee);\n', '                // LogUint(17, safeSub(profit * 1e10, fee));\n', '                // return;\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  \n', '\n', '\n', '                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }   \n', '        // close short position \n', '        else\n', '        {\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);\n', '            // return;\n', '\n', '            // reserve = reserve - (capPrice - entryPrice) * size;\n', '            subReserve(\n', '                baseToken, \n', '                user,  \n', '                v.reserve, \n', '                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice\n', '                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice < retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                // profit = (entryPrice - closingPrice) * size\n', '                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);\n', '\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                \n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                // profit = (closingPrice - entryPrice) * size\n', '                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  \n', '\n', '                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }  \n', '\n', '        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        emit FuturesPositionClosed(positionHash);\n', '    }\n', '\n', '    // Settle positions for closed contracts\n', '    function batchSettlePositions (\n', '        bytes32[] futuresContracts,\n', '        bool[] sides,\n', '        address[] users,\n', '        uint256 gasFeePerClose // baseToken with 8 decimals\n', '    ) onlyAdmin {\n', '        \n', '        for (uint i = 0; i < futuresContracts.length; i++) \n', '        {\n', '            closeFuturesPositionForUser(futuresContracts[i], sides[i], users[i], gasFeePerClose);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    \n', '    \n', '\n', '    // Returns the smaller of two values\n', '    function min(uint a, uint b) private pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '/* Interface for ERC20 Tokens */\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '/* Interface for the DMEX base contract */\n', 'contract EtherMium {\n', '    function getReserve(address token, address user) returns (uint256);\n', '    function setReserve(address token, address user, uint256 amount) returns (bool);\n', '\n', '    function availableBalanceOf(address token, address user) returns (uint256);\n', '    function balanceOf(address token, address user) returns (uint256);\n', '\n', '\n', '    function setBalance(address token, address user, uint256 amount) returns (bool);\n', '    function getAffiliate(address user) returns (address);\n', '    function getInactivityReleasePeriod() returns (uint256);\n', '    function getMakerTakerBalances(address token, address maker, address taker) returns (uint256[4]);\n', '\n', '    function getEtmTokenAddress() returns (address);\n', '\n', '    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) returns (bool);\n', '    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) returns (bool);\n', '    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) returns (bool);\n', '\n', '}\n', '\n', '\n', '\n', '// The DMEX Futures Contract\n', 'contract Exchange {\n', '    function assert(bool assertion) pure {\n', '        \n', '        if (!assertion) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    // Safe Multiply Function - prevents integer overflow \n', '    function safeMul(uint a, uint b) pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    // Safe Subtraction Function - prevents integer overflow \n', '    function safeSub(uint a, uint b) pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // Safe Addition Function - prevents integer overflow \n', '    function safeAdd(uint a, uint b) pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    address public owner; // holds the address of the contract owner\n', '\n', '    // Event fired when the owner of the contract is changed\n', '    event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOracle {\n', '        assert(msg.sender == DmexOracleContract);\n', '        _;\n', '    }\n', '\n', '    // Changes the owner of the contract\n', '    function setOwner(address newOwner) onlyOwner {\n', '        emit SetOwner(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    // Owner getter function\n', '    function getOwner() view returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    mapping (address => bool) public admins;                    // mapping of admin addresses\n', '    mapping (address => uint256) public lastActiveTransaction;  // mapping of user addresses to last transaction block\n', '    mapping (bytes32 => uint256) public orderFills;             // mapping of orders to filled qunatity\n', '    \n', '    address public feeAccount;          // the account that receives the trading fees\n', '    address public exchangeContract;    // the address of the main EtherMium contract\n', '    address public DmexOracleContract;    // the address of the DMEX math contract used for some calculations\n', '\n', '    uint256 public makerFee;            // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '    uint256 public takerFee;            // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '    \n', '    struct FuturesAsset {\n', '        string name;                    // the name of the traded asset (ex. ETHUSD)\n', '        address baseToken;              // the token for collateral\n', '        string priceUrl;                // the url where the price of the asset will be taken for settlement\n', '        string pricePath;               // price path in the returned JSON from the priceUrl (ex. path "last" will return tha value last from the json: {"high": "156.49", "last": "154.31", "timestamp": "1556522201", "bid": "154.22", "vwap": "154.65", "volume": "25578.79138868", "low": "152.33", "ask": "154.26", "open": "152.99"})\n', '        bool inversed;                  // if true, the price from the priceUrl will be inversed (i.e price = 1/priceUrl)\n', '        bool disabled;                  // if true, the asset cannot be used in contract creation (when price url no longer valid)\n', '    }\n', '\n', '    function createFuturesAsset(string name, address baseToken, string priceUrl, string pricePath, bool inversed) onlyAdmin returns (bytes32)\n', '    {    \n', '        bytes32 futuresAsset = keccak256(this, name, baseToken, priceUrl, pricePath, inversed);\n', '        if (futuresAssets[futuresAsset].disabled) throw; // asset already exists and is disabled\n', '\n', '        futuresAssets[futuresAsset] = FuturesAsset({\n', '            name                : name,\n', '            baseToken           : baseToken,\n', '            priceUrl            : priceUrl,\n', '            pricePath           : pricePath,\n', '            inversed            : inversed,\n', '            disabled            : false\n', '        });\n', '\n', '        emit FuturesAssetCreated(futuresAsset, name, baseToken, priceUrl, pricePath, inversed);\n', '        return futuresAsset;\n', '    }\n', '    \n', '    struct FuturesContract {\n', '        bytes32 asset;                  // the hash of the underlying asset object\n', '        uint256 expirationBlock;        // futures contract expiration block\n', '        uint256 closingPrice;           // the closing price for the futures contract\n', '        bool closed;                    // is the futures contract closed (0 - false, 1 - true)\n', '        bool broken;                    // if someone has forced release of funds the contract is marked as broken and can no longer close positions (0-false, 1-true)\n', '        uint256 floorPrice;             // the minimum price that can be traded on the contract, once price is reached the contract expires and enters settlement state \n', '        uint256 capPrice;               // the maximum price that can be traded on the contract, once price is reached the contract expires and enters settlement state\n', "        uint256 multiplier;             // the multiplier price, used when teh trading pair doesn't have the base token in it (eg. BTCUSD with ETH as base token, multiplier will be the ETHBTC price)\n", '    }\n', '\n', '    function createFuturesContract(bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier) onlyAdmin returns (bytes32)\n', '    {    \n', '        bytes32 futuresContract = keccak256(this, asset, expirationBlock, floorPrice, capPrice, multiplier);\n', '        if (futuresContracts[futuresContract].expirationBlock > 0) return futuresContract; // contract already exists\n', '\n', '        futuresContracts[futuresContract] = FuturesContract({\n', '            asset           : asset,\n', '            expirationBlock : expirationBlock,\n', '            closingPrice    : 0,\n', '            closed          : false,\n', '            broken          : false,\n', '            floorPrice      : floorPrice,\n', '            capPrice        : capPrice,\n', '            multiplier      : multiplier\n', '        });\n', '\n', '        emit FuturesContractCreated(futuresContract, asset, expirationBlock, floorPrice, capPrice, multiplier);\n', '\n', '        return futuresContract;\n', '    }\n', '\n', '    function getContractExpiration (bytes32 futuresContractHash) view returns (uint256)\n', '    {\n', '        return futuresContracts[futuresContractHash].expirationBlock;\n', '    }\n', '\n', '    function getContractClosed (bytes32 futuresContractHash) returns (bool)\n', '    {\n', '        return futuresContracts[futuresContractHash].closed;\n', '    }\n', '\n', '    function getContractPriceUrl (bytes32 futuresContractHash) returns (string)\n', '    {\n', '        return futuresAssets[futuresContracts[futuresContractHash].asset].priceUrl;\n', '    }\n', '\n', '    function getContractPricePath (bytes32 futuresContractHash) returns (string)\n', '    {\n', '        return futuresAssets[futuresContracts[futuresContractHash].asset].pricePath;\n', '    }\n', '\n', '    mapping (bytes32 => FuturesAsset)       public futuresAssets;      // mapping of futuresAsset hash to FuturesAsset structs\n', '    mapping (bytes32 => FuturesContract)    public futuresContracts;   // mapping of futuresContract hash to FuturesContract structs\n', '    mapping (bytes32 => uint256)            public positions;          // mapping of user addresses to position hashes to position\n', '\n', '\n', '    enum Errors {\n', "        INVALID_PRICE,                  // Order prices don't match\n", '        INVALID_SIGNATURE,              // Signature is invalid\n', '        ORDER_ALREADY_FILLED,           // Order was already filled\n', '        GAS_TOO_HIGH,                   // Too high gas fee\n', "        OUT_OF_BALANCE,                 // User doesn't have enough balance for the operation\n", '        FUTURES_CONTRACT_EXPIRED,       // Futures contract already expired\n', '        FLOOR_OR_CAP_PRICE_REACHED,     // The floor price or the cap price for the futures contract was reached\n', '        POSITION_ALREADY_EXISTS,        // User has an open position already \n', '        UINT48_VALIDATION,              // Size or price bigger than an Uint48\n', '        FAILED_ASSERTION                // Assertion failed\n', '    }\n', '\n', '    event FuturesTrade(bool side, uint256 size, uint256 price, bytes32 indexed futuresContract, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event FuturesPositionClosed(bytes32 indexed positionHash);\n', '    event FuturesContractClosed(bytes32 indexed futuresContract, uint256 closingPrice);\n', '    event FuturesForcedRelease(bytes32 indexed futuresContract, bool side, address user);\n', '    event FuturesAssetCreated(bytes32 indexed futuresAsset, string name, address baseToken, string priceUrl, string pricePath, bool inversed);\n', '    event FuturesContractCreated(bytes32 indexed futuresContract, bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier);\n', ' \n', '    // Fee change event\n', '    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\n', '\n', '    // Log event, logs errors in contract execution (for internal use)\n', '    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event LogErrorLight(uint8 indexed errorId);\n', '    event LogUint(uint8 id, uint256 value);\n', '    event LogBool(uint8 id, bool value);\n', '    event LogAddress(uint8 id, address value);\n', '\n', '\n', '    // Constructor function, initializes the contract and sets the core variables\n', '    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_, address DmexOracleContract_) {\n', '        owner               = msg.sender;\n', '        feeAccount          = feeAccount_;\n', '        makerFee            = makerFee_;\n', '        takerFee            = takerFee_;\n', '\n', '        exchangeContract    = exchangeContract_;\n', '        DmexOracleContract    = DmexOracleContract_;\n', '    }\n', '\n', '    // Changes the fees\n', '    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\n', '        require(makerFee_       < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\n', '        makerFee                = makerFee_;\n', '        takerFee                = takerFee_;\n', '\n', '        emit FeeChange(makerFee, takerFee);\n', '    }\n', '\n', '    // Adds or disables an admin account\n', '    function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '    // Allows for admins only to call the function\n', '    modifier onlyAdmin {\n', '        if (msg.sender != owner && !admins[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    function() external {\n', '        throw;\n', '    }   \n', '\n', '\n', '    function validateUint48(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint48(val)) return false;\n', '        return true;\n', '    }\n', '\n', '    function validateUint64(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint64(val)) return false;\n', '        return true;\n', '    }\n', '\n', '    function validateUint128(uint256 val) returns (bool)\n', '    {\n', '        if (val != uint128(val)) return false;\n', '        return true;\n', '    }\n', '\n', '\n', '    // Structure that holds order values, used inside the trade() function\n', '    struct FuturesOrderPair {\n', '        uint256 makerNonce;                 // maker order nonce, makes the order unique\n', '        uint256 takerNonce;                 // taker order nonce\n', '        uint256 takerGasFee;                // taker gas fee, taker pays the gas\n', '        uint256 takerIsBuying;              // true/false taker is the buyer\n', '\n', '        address maker;                      // address of the maker\n', '        address taker;                      // address of the taker\n', '\n', '        bytes32 makerOrderHash;             // hash of the maker order\n', '        bytes32 takerOrderHash;             // has of the taker order\n', '\n', '        uint256 makerAmount;                // trade amount for maker\n', '        uint256 takerAmount;                // trade amount for taker\n', '\n', '        uint256 makerPrice;                 // maker order price in wei (18 decimal precision)\n', '        uint256 takerPrice;                 // taker order price in wei (18 decimal precision)\n', '\n', '        bytes32 futuresContract;            // the futures contract being traded\n', '\n', '        address baseToken;                  // the address of the base token for futures contract\n', '        uint256 floorPrice;                 // floor price of futures contract\n', '        uint256 capPrice;                   // cap price of futures contract\n', '\n', '        bytes32 makerPositionHash;          // hash for maker position\n', '        bytes32 makerInversePositionHash;   // hash for inverse maker position \n', '\n', '        bytes32 takerPositionHash;          // hash for taker position\n', '        bytes32 takerInversePositionHash;   // hash for inverse taker position\n', '    }\n', '\n', '    // Structure that holds trade values, used inside the trade() function\n', '    struct FuturesTradeValues {\n', '        uint256 qty;                // amount to be trade\n', '        uint256 makerProfit;        // holds maker profit value\n', '        uint256 makerLoss;          // holds maker loss value\n', '        uint256 takerProfit;        // holds taker profit value\n', '        uint256 takerLoss;          // holds taker loss value\n', '        uint256 makerBalance;       // holds maker balance value\n', '        uint256 takerBalance;       // holds taker balance value\n', '        uint256 makerReserve;       // holds taker reserved value\n', '        uint256 takerReserve;       // holds taker reserved value\n', '    }\n', '\n', '    // Opens/closes futures positions\n', '    function futuresTrade(\n', '        uint8[2] v,\n', '        bytes32[4] rs,\n', '        uint256[8] tradeValues,\n', '        address[2] tradeAddresses,\n', '        bool takerIsBuying,\n', '        bytes32 futuresContractHash\n', '    ) onlyAdmin returns (uint filledTakerTokenAmount)\n', '    {\n', '        /* tradeValues\n', '          [0] makerNonce\n', '          [1] takerNonce\n', '          [2] takerGasFee\n', '          [3] takerIsBuying\n', '          [4] makerAmount\n', '          [5] takerAmount\n', '          [6] makerPrice\n', '          [7] takerPrice\n', '\n', '          tradeAddresses\n', '          [0] maker\n', '          [1] taker\n', '        */\n', '\n', '        FuturesOrderPair memory t  = FuturesOrderPair({\n', '            makerNonce      : tradeValues[0],\n', '            takerNonce      : tradeValues[1],\n', '            takerGasFee     : tradeValues[2],\n', '            takerIsBuying   : tradeValues[3],\n', '            makerAmount     : tradeValues[4],      \n', '            takerAmount     : tradeValues[5],   \n', '            makerPrice      : tradeValues[6],         \n', '            takerPrice      : tradeValues[7],\n', '\n', '            maker           : tradeAddresses[0],\n', '            taker           : tradeAddresses[1],\n', '\n', '            //                                futuresContract      user               amount          price           side             nonce\n', '            makerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[0], tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0]),\n', '            takerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[1], tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1]),            \n', '\n', '            futuresContract : futuresContractHash,\n', '\n', '            baseToken       : futuresAssets[futuresContracts[futuresContractHash].asset].baseToken,\n', '            floorPrice      : futuresContracts[futuresContractHash].floorPrice,\n', '            capPrice        : futuresContracts[futuresContractHash].capPrice,\n', '\n', '            //                                            user               futuresContractHash   side\n', '            makerPositionHash           : keccak256(this, tradeAddresses[0], futuresContractHash, !takerIsBuying),\n', '            makerInversePositionHash    : keccak256(this, tradeAddresses[0], futuresContractHash, takerIsBuying),\n', '\n', '            takerPositionHash           : keccak256(this, tradeAddresses[1], futuresContractHash, takerIsBuying),\n', '            takerInversePositionHash    : keccak256(this, tradeAddresses[1], futuresContractHash, !takerIsBuying)\n', '\n', '        });\n', '\n', '//--> 44 000\n', '    \n', '        // Valifate size and price values\n', '        if (!validateUint128(t.makerAmount) || !validateUint128(t.takerAmount) || !validateUint64(t.makerPrice) || !validateUint64(t.takerPrice))\n', '        {            \n', '            emit LogError(uint8(Errors.UINT48_VALIDATION), t.makerOrderHash, t.takerOrderHash);\n', '            return 0; \n', '        }\n', '\n', '\n', '        // Check if futures contract has expired already\n', '        if (block.number > futuresContracts[t.futuresContract].expirationBlock || futuresContracts[t.futuresContract].closed == true || futuresContracts[t.futuresContract].broken == true)\n', '        {\n', '            emit LogError(uint8(Errors.FUTURES_CONTRACT_EXPIRED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0; // futures contract is expired\n', '        }\n', '\n', '        // Checks the signature for the maker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '       \n', '        // Checks the signature for the taker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '\n', '\n', '        // check prices\n', '        if ((!takerIsBuying && t.makerPrice < t.takerPrice) || (takerIsBuying && t.takerPrice < t.makerPrice))\n', '        {\n', '            emit LogError(uint8(Errors.INVALID_PRICE), t.makerOrderHash, t.takerOrderHash);\n', "            return 0; // prices don't match\n", '        }      \n', '\n', '//--> 54 000\n', '\n', '         \n', '        \n', '\n', '        uint256[4] memory balances = EtherMium(exchangeContract).getMakerTakerBalances(t.baseToken, t.maker, t.taker);\n', '\n', '        // Initializing trade values structure \n', '        FuturesTradeValues memory tv = FuturesTradeValues({\n', '            qty                 : 0,\n', '            makerProfit         : 0,\n', '            makerLoss           : 0,\n', '            takerProfit         : 0,\n', '            takerLoss           : 0,\n', '            makerBalance        : balances[0], //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            takerBalance        : balances[1],  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            makerReserve        : balances[2],  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '            takerReserve        : balances[3]  //EtherMium(exchangeContract).balanceOf(t.baseToken, t.maker),\n', '        });\n', '\n', '//--> 60 000\n', '\n', '\n', '         \n', '\n', '        // check if floor price or cap price was reached\n', '        if (futuresContracts[t.futuresContract].floorPrice >= t.makerPrice || futuresContracts[t.futuresContract].capPrice <= t.makerPrice)\n', '        {\n', '            // attepting price outside range\n', '            emit LogError(uint8(Errors.FLOOR_OR_CAP_PRICE_REACHED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '        // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\n', '        // and open inverse positions\n', '        tv.qty = min(safeSub(t.makerAmount, orderFills[t.makerOrderHash]), safeSub(t.takerAmount, orderFills[t.takerOrderHash]));\n', '        \n', '        if (positionExists(t.makerInversePositionHash) && positionExists(t.takerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, min(retrievePosition(t.makerInversePositionHash)[0], retrievePosition(t.takerInversePositionHash)[0]));\n', '        }\n', '        else if (positionExists(t.makerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, retrievePosition(t.makerInversePositionHash)[0]);\n', '        }\n', '        else if (positionExists(t.takerInversePositionHash))\n', '        {\n', '            tv.qty = min(tv.qty, retrievePosition(t.takerInversePositionHash)[0]);\n', '        }\n', '\n', '       \n', '\n', '\n', '\n', '//--> 64 000       \n', '        \n', '        if (tv.qty == 0)\n', '        {\n', '            // no qty left on orders\n', '            emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '        // Cheks that gas fee is not higher than 10%\n', '        if (safeMul(t.takerGasFee, 20) > calculateTradeValue(tv.qty, t.makerPrice, t.futuresContract))\n', '        {\n', '            emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        } // takerGasFee too high\n', '\n', '\n', '        // check if users have open positions already\n', '        // if (positionExists(t.makerPositionHash) || positionExists(t.takerPositionHash))\n', '        // {\n', '        //     // maker already has the position open, first must close existing position before opening a new one\n', '        //     emit LogError(uint8(Errors.POSITION_ALREADY_EXISTS), t.makerOrderHash, t.takerOrderHash);\n', '        //     return 0; \n', '        // }\n', '\n', '//--> 66 000\n', '        \n', '\n', '       \n', '\n', '        /*------------- Maker long, Taker short -------------*/\n', '        if (!takerIsBuying)\n', '        {     \n', '            \n', '      \n', '            // position actions for maker\n', '            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\n', '            {\n', '\n', '\n', '                // check if maker has enough balance   \n', '                \n', '                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                \n', '                \n', '                // create new position\n', '                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 1, block.number);\n', '\n', '\n', '\n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken, // base token\n', '                        t.maker // make address\n', '                    ], \n', '                    t.makerPositionHash,  // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice,  // price\n', '                        makerFee, // fee\n', '                        0, // profit\n', '                        0, // loss\n', '                        tv.makerBalance, // balance\n', '                        0, // gasFee\n', '                        tv.makerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        true, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {               \n', '                \n', '                if (positionExists(t.makerPositionHash))\n', '                {\n', '                    // check if maker has enough balance            \n', '                    // if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, \n', '                    //     safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);\n', '                    \n', '                    \n', '\n', '                    if (t.makerPrice < retrievePosition(t.makerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.makerProfit                    = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\n', '                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.makerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;    \n', '                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                        \n', '                    }\n', '\n', '\n', '\n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            tv.makerProfit,  // profit\n', '                            tv.makerLoss,  // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }                \n', '            }\n', '\n', '           \n', '\n', '\n', '            // position actions for taker\n', '            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\n', '            {\n', '                \n', '                // check if taker has enough balance\n', '                // if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\n', '                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '                \n', '                // create new position\n', '                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 0, block.number);\n', '                \n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken, // base token\n', '                        t.taker // make address\n', '                    ], \n', '                    t.takerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice,  // price\n', '                        takerFee, // fee\n', '                        0, // profit\n', '                        0,  // loss\n', '                        tv.takerBalance,  // balance\n', '                        t.takerGasFee, // gasFee\n', '                        tv.takerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        false, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.takerPositionHash))\n', '                {\n', '                    // check if taker has enough balance\n', '                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\n', '                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.taker // make address\n', '                        ], \n', '                        t.takerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {   \n', '\n', '\n', '                     \n', '                   \n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\n', '                    \n', '\n', '\n', '                    if (t.makerPrice > retrievePosition(t.takerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.takerProfit                    = safeMul(safeSub(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1]), tv.qty) / t.makerPrice;\n', '                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.takerLoss                      = safeMul(safeSub(retrievePosition(t.takerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;                                  \n', '                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false); \n', '                    }\n', '\n', '                  \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.taker // make address\n', '                        ], \n', '                        t.takerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            tv.takerProfit, // profit\n', '                            tv.takerLoss, // loss\n', '                            tv.takerBalance,  // balance\n', '                            t.takerGasFee,  // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }\n', '        }\n', '\n', '\n', '        /*------------- Maker short, Taker long -------------*/\n', '\n', '        else\n', '        {      \n', '            //LogUint(1, safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty)); return;\n', '\n', '            // position actions for maker\n', '            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\n', '            {\n', '                // check if maker has enough balance\n', '                //if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                // create new position\n', '                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 0, block.number);\n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken,   // base token\n', '                        t.maker // make address\n', '                    ], \n', '                    t.makerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice, // price\n', '                        makerFee, // fee\n', '                        0, // profit\n', '                        0, // loss\n', '                        tv.makerBalance, // balance\n', '                        0, // gasFee\n', '                        tv.makerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        false, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.makerPositionHash))\n', '                {\n', '                    // check if maker has enough balance\n', '                    //if (safeAdd(safeMul(safeSub(t.makerPrice, t.floorPrice), tv.qty) / t.floorPrice, safeMul(tv.qty, makerFee) / (1 ether)) * 1e10 > safeSub(balances[0],tv.makerReserve))\n', '                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '\n', '                    // increase position size\n', '                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.maker // make address\n', '                        ], \n', '                        t.makerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);       \n', '                    \n', '\n', '\n', '                    if (t.makerPrice > retrievePosition(t.makerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.makerProfit                    = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;\n', '                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.makerLoss                      = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice; \n', '                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);                               \n', '                    }\n', '\n', '                   \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken, // base token\n', '                            t.maker // user address\n', '                        ], \n', '                        t.makerInversePositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            makerFee, // fee\n', '                            tv.makerProfit,  // profit\n', '                            tv.makerLoss, // loss\n', '                            tv.makerBalance, // balance\n', '                            0, // gasFee\n', '                            tv.makerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            false, // side (if true - long)\n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }\n', '\n', '            // position actions for taker\n', '            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\n', '            {\n', '                // check if taker has enough balance\n', '                // if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether)), t.takerGasFee / 1e10) * 1e10 > safeSub(balances[1],tv.takerReserve))\n', '                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                {\n', '                    // maker out of balance\n', '                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                    return 0; \n', '                }\n', '\n', '                // create new position\n', '                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 1, block.number);\n', '           \n', '                updateBalances(\n', '                    t.futuresContract, \n', '                    [\n', '                        t.baseToken,  // base token\n', '                        t.taker // user address\n', '                    ], \n', '                    t.takerPositionHash, // position hash\n', '                    [\n', '                        tv.qty, // qty\n', '                        t.makerPrice, // price\n', '                        takerFee, // fee\n', '                        0,  // profit\n', '                        0,  // loss\n', '                        tv.takerBalance, // balance\n', '                        t.takerGasFee, // gasFee\n', '                        tv.takerReserve // reserve\n', '                    ], \n', '                    [\n', '                        true, // newPostion (if true position is new)\n', '                        true, // side (if true - long)\n', '                        false // increase position (if true)\n', '                    ]\n', '                );\n', '\n', '            } else {\n', '                if (positionExists(t.takerPositionHash))\n', '                {\n', '                    // check if taker has enough balance\n', '                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether)), t.takerGasFee / 1e10) * 1e10 > safeSub(balances[1],tv.takerReserve))\n', '                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\n', '                    {\n', '                        // maker out of balance\n', '                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\n', '                        return 0; \n', '                    }\n', '                    \n', '                    // increase position size\n', '                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\n', '                \n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,  // base token\n', '                            t.taker // user address\n', '                        ], \n', '                        t.takerPositionHash, // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            0, // profit\n', '                            0, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long)\n', '                            true // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '                else\n', '                {\n', '\n', '                    // close/partially close existing position\n', '                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\n', '                                     \n', '                    if (t.makerPrice < retrievePosition(t.takerInversePositionHash)[1])\n', '                    {\n', '                        // user has made a profit\n', '                        //tv.takerProfit                    = safeMul(safeSub(retrievePosition(t.takerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\n', '                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);\n', '                    }\n', '                    else\n', '                    {\n', '                        // user has made a loss\n', '                        //tv.takerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1]), tv.qty) / t.makerPrice; \n', '                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                  \n', '                    }\n', '\n', '                    \n', '\n', '                    updateBalances(\n', '                        t.futuresContract, \n', '                        [\n', '                            t.baseToken,   // base toke\n', '                            t.taker // user address\n', '                        ], \n', '                        t.takerInversePositionHash,  // position hash\n', '                        [\n', '                            tv.qty, // qty\n', '                            t.makerPrice, // price\n', '                            takerFee, // fee\n', '                            tv.takerProfit, // profit\n', '                            tv.takerLoss, // loss\n', '                            tv.takerBalance, // balance\n', '                            t.takerGasFee, // gasFee\n', '                            tv.takerReserve // reserve\n', '                        ], \n', '                        [\n', '                            false, // newPostion (if true position is new)\n', '                            true, // side (if true - long) \n', '                            false // increase position (if true)\n', '                        ]\n', '                    );\n', '                }\n', '            }           \n', '        }\n', '\n', '//--> 220 000\n', '        orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty); // increase the maker order filled amount\n', '        orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); // increase the taker order filled amount\n', '\n', '//--> 264 000\n', '        emit FuturesTrade(takerIsBuying, tv.qty, t.makerPrice, t.futuresContract, t.makerOrderHash, t.takerOrderHash);\n', '\n', '        return tv.qty;\n', '    }\n', '\n', '\n', '    function calculateProfit(uint256 closingPrice, uint256 entryPrice, uint256 qty, bytes32 futuresContractHash, bool side) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(entryPrice, closingPrice), qty) / closingPrice;  \n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier)  / 1e8 / 1e18;\n', '            }\n', '            \n', '        }\n', '        else\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(closingPrice, entryPrice), qty) / closingPrice; \n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier)  / 1e8 / 1e18; \n', '            }\n', '        }       \n', '    }\n', '\n', '    function calculateTradeValue(uint256 qty, uint256 price, bytes32 futuresContractHash) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '        if (inversed)\n', '        {\n', '            return qty * 1e10;\n', '        }\n', '        else\n', '        {\n', '            return safeMul(safeMul(safeMul(qty, price), 1e2), multiplier) / 1e18 ;\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function calculateLoss(uint256 closingPrice, uint256 entryPrice, uint256 qty,  bytes32 futuresContractHash, bool side) returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(closingPrice, entryPrice), qty) / closingPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(entryPrice, closingPrice), qty) / closingPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier) / 1e8 / 1e18;\n', '            } \n', '        }\n', '        \n', '    }\n', '\n', '    function calculateCollateral (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, bytes32 futuresContractHash) view returns (uint256)\n', '    {\n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            // long\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(tradePrice, limitPrice), qty) / limitPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(tradePrice, limitPrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            // short\n', '            if (inversed)\n', '            {\n', '                return safeMul(safeSub(limitPrice, tradePrice), qty)  / limitPrice;\n', '            }\n', '            else\n', '            {\n', '                return safeMul(safeMul(safeSub(limitPrice, tradePrice), qty), multiplier) / 1e8 / 1e18;\n', '            }\n', '        }         \n', '    }\n', '\n', '    function calculateFee (uint256 qty, uint256 tradePrice, uint256 fee, bytes32 futuresContractHash) returns (uint256)\n', '    {\n', '        return safeMul(calculateTradeValue(qty, tradePrice, futuresContractHash), fee) / 1e18 / 1e10;\n', '    }\n', '\n', '\n', '    function checkEnoughBalance (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, uint256 fee, uint256 gasFee, bytes32 futuresContractHash, uint256 availableBalance) view returns (bool)\n', '    {\n', '        \n', '        bool inversed = futuresAssets[futuresContracts[futuresContractHash].asset].inversed;\n', '        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\n', '\n', '        if (side)\n', '        {\n', '            // long\n', '            if (safeAdd(\n', '                    safeAdd(\n', '                        calculateCollateral(limitPrice, tradePrice, qty, side, futuresContractHash), \n', '                        //safeMul(qty, fee) / (1 ether)\n', '                        calculateFee(qty, tradePrice, fee, futuresContractHash)\n', '                    ) * 1e10,\n', '                    gasFee \n', '                ) > availableBalance)\n', '            {\n', '                return false; \n', '            }\n', '        }\n', '        else\n', '        {\n', '            // short\n', '            if (safeAdd(\n', '                    safeAdd(\n', '                        calculateCollateral(limitPrice, tradePrice, qty, side, futuresContractHash), \n', '                        //safeMul(qty, fee) / (1 ether)\n', '                        calculateFee(qty, tradePrice, fee, futuresContractHash)\n', '                    ) * 1e10, \n', '                    gasFee \n', '                ) > availableBalance)\n', '            {\n', '                return false;\n', '            }\n', '\n', '        }\n', '\n', '        return true;\n', '       \n', '    }  \n', '\n', '      \n', '\n', '    // Executes multiple trades in one transaction, saves gas fees\n', '    function batchFuturesTrade(\n', '        uint8[2][] v,\n', '        bytes32[4][] rs,\n', '        uint256[8][] tradeValues,\n', '        address[2][] tradeAddresses,\n', '        bool[] takerIsBuying,\n', '        bytes32[] assetHash,\n', '        uint256[4][] contractValues\n', '    ) onlyAdmin\n', '    {\n', '        // perform trades\n', '        for (uint i = 0; i < tradeAddresses.length; i++) {\n', '            futuresTrade(\n', '                v[i],\n', '                rs[i],\n', '                tradeValues[i],\n', '                tradeAddresses[i],\n', '                takerIsBuying[i],\n', '                createFuturesContract(assetHash[i], contractValues[i][0], contractValues[i][1], contractValues[i][2], contractValues[i][3])\n', '            );\n', '        }\n', '    }\n', '\n', '    \n', '\n', '\n', '    // Update user balance\n', '    function updateBalances (bytes32 futuresContract, address[2] addressValues, bytes32 positionHash, uint256[8] uintValues, bool[3] boolValues) private\n', '    {\n', '        /*\n', '            addressValues\n', '            [0] baseToken\n', '            [1] user\n', '\n', '            uintValues\n', '            [0] qty\n', '            [1] price\n', '            [2] fee\n', '            [3] profit\n', '            [4] loss\n', '            [5] balance\n', '            [6] gasFee\n', '            [7] reserve\n', '\n', '            boolValues\n', '            [0] newPostion\n', '            [1] side\n', '            [2] increase position\n', '\n', '        */\n', '\n', '        //                          qty * price * fee\n', '        // uint256 pam[0] = safeMul(safeMul(uintValues[0], uintValues[1]), uintValues[2]) / (1 ether);\n', '        // uint256 collateral;  \n', '\n', '\n', '        // pam = [fee value, collateral]                        \n', '        uint256[2] memory pam = [safeAdd(calculateFee(uintValues[0], uintValues[1], uintValues[2], futuresContract) * 1e10, uintValues[6]), 0];\n', '        \n', '        // LogUint(100, uintValues[3]);\n', '        // LogUint(9, uintValues[2]);\n', '        // LogUint(7, safeMul(uintValues[0], uintValues[2])  / (1 ether));\n', '        // return;\n', '\n', '        \n', '\n', '        // Position is new or position is increased\n', '        if (boolValues[0] || boolValues[2])  \n', '        {\n', '\n', '            if (boolValues[1])\n', '            {\n', '\n', '                //addReserve(addressValues[0], addressValues[1], uintValues[ 7], safeMul(safeSub(uintValues[1], futuresContracts[futuresContract].floorPrice), uintValues[0])); // reserve collateral on user\n', '                //pam[1] = safeMul(safeSub(uintValues[1], futuresContracts[futuresContract].floorPrice), uintValues[0]) / futuresContracts[futuresContract].floorPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, uintValues[1], uintValues[0], true, futuresContract);\n', '\n', '            }\n', '            else\n', '            {\n', '                //addReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(safeSub(futuresContracts[futuresContract].capPrice, uintValues[1]), uintValues[0])); // reserve collateral on user\n', '                //pam[1] = safeMul(safeSub(futuresContracts[futuresContract].capPrice, uintValues[1]), uintValues[0]) / futuresContracts[futuresContract].capPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, uintValues[1], uintValues[0], false, futuresContract);\n', '            }\n', '\n', '            subBalanceAddReserve(addressValues[0], addressValues[1], pam[0], safeAdd(pam[1],1));         \n', '\n', '            // if (uintValues[6] > 0)\n', '            // {   \n', '            //     subBalanceAddReserve(addressValues[0], addressValues[1], safeAdd(uintValues[6], pam[0]), pam[1]);                  \n', '                              \n', '            // }\n', '            // else\n', '            // {\n', '\n', '            //    subBalanceAddReserve(addressValues[0], addressValues[1], safeAdd(uintValues[6], pam[0]), pam[1]);                 \n', '            // }\n', '\n', '\n', '            //subBalance(addressValues[0], addressValues[1], uintValues[5], feeVal); // deduct user maker/taker fee \n', '\n', '            \n', '        // Position exists\n', '        } \n', '        else \n', '        {\n', '            if (retrievePosition(positionHash)[2] == 0)\n', '            {\n', '                // original position was short\n', '                //subReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(uintValues[0], safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]))); // remove freed collateral from reserver\n', '                //pam[1] = safeMul(uintValues[0], safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1])) / futuresContracts[futuresContract].capPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1], uintValues[0], false, futuresContract);\n', '\n', '                // LogUint(120, uintValues[0]);\n', '                // LogUint(121, futuresContracts[futuresContract].capPrice);\n', '                // LogUint(122, retrievePosition(positionHash)[1]);\n', '                // LogUint(123, uintValues[3]); // profit\n', '                // LogUint(124, uintValues[4]); // loss\n', '                // LogUint(125, safeAdd(uintValues[4], pam[0]));\n', '                // LogUint(12, pam[1] );\n', '                //return;\n', '            }\n', '            else\n', '            {       \n', '                       \n', '                // original position was long\n', '                //subReserve(addressValues[0], addressValues[1], uintValues[7], safeMul(uintValues[0], safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice)));\n', '                //pam[1] = safeMul(uintValues[0], safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice)) / futuresContracts[futuresContract].floorPrice;\n', '                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, retrievePosition(positionHash)[1], uintValues[0], true, futuresContract);\n', '\n', '            }\n', '\n', '\n', '                // LogUint(41, uintValues[3]);\n', '                // LogUint(42, uintValues[4]);\n', '                // LogUint(43, pam[0]);\n', '                // return;  \n', '            if (uintValues[3] > 0) \n', '            {\n', '                // profi > 0\n', '\n', '                if (pam[0] <= uintValues[3]*1e10)\n', '                {\n', '                    //addBalance(addressValues[0], addressValues[1], uintValues[5], safeSub(uintValues[3], pam[0])); // add profit to user balance\n', '                    addBalanceSubReserve(addressValues[0], addressValues[1], safeSub(uintValues[3]*1e10, pam[0]), pam[1]);\n', '                }\n', '                else\n', '                {\n', '                    subBalanceSubReserve(addressValues[0], addressValues[1], safeSub(pam[0], uintValues[3]*1e10), pam[1]);\n', '                }\n', '                \n', '            } \n', '            else \n', '            {   \n', '                \n', '\n', '                // loss >= 0\n', '                //subBalance(addressValues[0], addressValues[1], uintValues[5], safeAdd(uintValues[4], pam[0])); // deduct loss from user balance \n', '                subBalanceSubReserve(addressValues[0], addressValues[1], safeAdd(uintValues[4]*1e10, pam[0]), pam[1]); // deduct loss from user balance\n', '           \n', '            } \n', '            //}            \n', '        }          \n', '        \n', '        addBalance(addressValues[0], feeAccount, EtherMium(exchangeContract).balanceOf(addressValues[0], feeAccount), pam[0]); // send fee to feeAccount\n', '    }\n', '\n', '    function recordNewPosition (bytes32 positionHash, uint256 size, uint256 price, uint256 side, uint256 block) private\n', '    {\n', '        if (!validateUint128(size) || !validateUint64(price)) \n', '        {\n', '            throw;\n', '        }\n', '\n', '        uint256 character = uint128(size);\n', '        character |= price<<128;\n', '        character |= side<<192;\n', '        character |= block<<208;\n', '\n', '        positions[positionHash] = character;\n', '    }\n', '\n', '    function retrievePosition (bytes32 positionHash) public view returns (uint256[4])\n', '    {\n', '        uint256 character = positions[positionHash];\n', '        uint256 size = uint256(uint128(character));\n', '        uint256 price = uint256(uint64(character>>128));\n', '        uint256 side = uint256(uint16(character>>192));\n', '        uint256 entryBlock = uint256(uint48(character>>208));\n', '\n', '        return [size, price, side, entryBlock];\n', '    }\n', '\n', '    function updatePositionSize(bytes32 positionHash, uint256 size, uint256 price) private\n', '    {\n', '        uint256[4] memory pos = retrievePosition(positionHash);\n', '\n', '        if (size > pos[0])\n', '        {\n', '            // position is increasing in size\n', '            recordNewPosition(positionHash, size, safeAdd(safeMul(pos[0], pos[1]), safeMul(price, safeSub(size, pos[0]))) / size, pos[2], pos[3]);\n', '        }\n', '        else\n', '        {\n', '            // position is decreasing in size\n', '            recordNewPosition(positionHash, size, pos[1], pos[2], pos[3]);\n', '        }        \n', '    }\n', '\n', '    function positionExists (bytes32 positionHash) internal view returns (bool)\n', '    {\n', '        //LogUint(3,retrievePosition(positionHash)[0]);\n', '        if (retrievePosition(positionHash)[0] == 0)\n', '        {\n', '            return false;\n', '        }\n', '        else\n', '        {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // This function allows the user to manually release collateral in case the oracle service does not provide the price during the inactivityReleasePeriod\n', '    function forceReleaseReserve (bytes32 futuresContract, bool side) public\n', '    {   \n', '        if (futuresContracts[futuresContract].expirationBlock == 0) throw;       \n', '        if (futuresContracts[futuresContract].expirationBlock > block.number) throw;\n', '        if (safeAdd(futuresContracts[futuresContract].expirationBlock, EtherMium(exchangeContract).getInactivityReleasePeriod()) > block.number) throw;  \n', '\n', '        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);\n', '        if (retrievePosition(positionHash)[1] == 0) throw;    \n', '  \n', '\n', '        futuresContracts[futuresContract].broken = true;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        if (side)\n', '        {\n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                EtherMium(exchangeContract).getReserve(baseToken, msg.sender), \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice\n', '                calculateCollateral(futuresContracts[futuresContract].floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, futuresContract)\n', '            ); \n', '        }\n', '        else\n', '        {            \n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                EtherMium(exchangeContract).getReserve(baseToken, msg.sender), \n', '                //safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice\n', '                calculateCollateral(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, futuresContract)\n', '            ); \n', '        }\n', '\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), );\n', '        //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], positions[msg.sender][positionHash].collateral);\n', '\n', '        emit FuturesForcedRelease(futuresContract, side, msg.sender);\n', '\n', '    }\n', '\n', '    function addBalance(address token, address user, uint256 balance, uint256 amount) private\n', '    {\n', '        EtherMium(exchangeContract).setBalance(token, user, safeAdd(balance, amount));\n', '    }\n', '\n', '    function subBalance(address token, address user, uint256 balance, uint256 amount) private\n', '    {\n', '        EtherMium(exchangeContract).setBalance(token, user, safeSub(balance, amount));\n', '    }\n', '\n', '    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) private\n', '    {\n', '        EtherMium(exchangeContract).subBalanceAddReserve(token, user, subBalance, addReserve * 1e10);\n', '    }\n', '\n', '    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) private\n', '    {\n', '\n', '        EtherMium(exchangeContract).addBalanceSubReserve(token, user, addBalance, subReserve * 1e10);\n', '    }\n', '\n', '    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) private\n', '    {\n', '        // LogUint(31, subBalance);\n', '        // LogUint(32, subReserve);\n', '        // return;\n', '\n', '        EtherMium(exchangeContract).subBalanceSubReserve(token, user, subBalance, subReserve * 1e10);\n', '    }\n', '\n', '    function addReserve(address token, address user, uint256 reserve, uint256 amount) private\n', '    {\n', '        //reserve[token][user] = safeAdd(reserve[token][user], amount);\n', '        EtherMium(exchangeContract).setReserve(token, user, safeAdd(reserve, amount * 1e10));\n', '    }\n', '\n', '    function subReserve(address token, address user, uint256 reserve, uint256 amount) private \n', '    {\n', '        //reserve[token][user] = safeSub(reserve[token][user], amount);\n', '        EtherMium(exchangeContract).setReserve(token, user, safeSub(reserve, amount * 1e10));\n', '    }\n', '\n', '\n', '    function getMakerTakerBalances(address maker, address taker, address token) public view returns (uint256[4])\n', '    {\n', '        return [\n', '            EtherMium(exchangeContract).balanceOf(token, maker),\n', '            EtherMium(exchangeContract).getReserve(token, maker),\n', '            EtherMium(exchangeContract).balanceOf(token, taker),\n', '            EtherMium(exchangeContract).getReserve(token, taker)\n', '        ];\n', '    }\n', '\n', '    function getMakerTakerPositions(bytes32 makerPositionHash, bytes32 makerInversePositionHash, bytes32 takerPosition, bytes32 takerInversePosition) public view returns (uint256[4][4])\n', '    {\n', '        return [\n', '            retrievePosition(makerPositionHash),\n', '            retrievePosition(makerInversePositionHash),\n', '            retrievePosition(takerPosition),\n', '            retrievePosition(takerInversePosition)\n', '        ];\n', '    }\n', '\n', '\n', '    struct FuturesClosePositionValues {\n', '        uint256 reserve;                // amount to be trade\n', '        uint256 balance;        // holds maker profit value\n', '        uint256 floorPrice;          // holds maker loss value\n', '        uint256 capPrice;        // holds taker profit value\n', '        uint256 closingPrice;          // holds taker loss value\n', '        bytes32 futuresContract; // the futures contract hash\n', '    }\n', '\n', '\n', '    function closeFuturesPosition (bytes32 futuresContract, bool side)\n', '    {\n', '        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);\n', '\n', '        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\n', '        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\n', '        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\n', '\n', '        uint256 profit;\n', '        uint256 loss;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        FuturesClosePositionValues memory v = FuturesClosePositionValues({\n', '            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),\n', '            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),\n', '            floorPrice      : futuresContracts[futuresContract].floorPrice,\n', '            capPrice        : futuresContracts[futuresContract].capPrice,\n', '            closingPrice    : futuresContracts[futuresContract].closingPrice,\n', '            futuresContract : futuresContract\n', '        });\n', '\n', '        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);\n', '        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);\n', '        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;\n', '        // uint256 capPrice = futuresContracts[futuresContract].capPrice;\n', '        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;\n', '\n', '\n', '        \n', '        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);\n', '        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);\n', '\n', '\n', '\n', '        // close long position\n', '        if (side == true)\n', '        {            \n', '\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);\n', '            // return;\n', '            // reserve = reserve - (entryPrice - floorPrice) * size;\n', '            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));\n', '            \n', '            \n', '            subReserve(\n', '                baseToken, \n', '                msg.sender, \n', '                v.reserve, \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice\n', '                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice > retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);\n', '                \n', '\n', '\n', '                // LogUint(15, profit);\n', '                // LogUint(16, fee);\n', '                // LogUint(17, safeSub(profit * 1e10, fee));\n', '                // return;\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  \n', '\n', '\n', '                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }   \n', '        // close short position \n', '        else\n', '        {\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);\n', '            // return;\n', '\n', '            // reserve = reserve - (capPrice - entryPrice) * size;\n', '            subReserve(\n', '                baseToken, \n', '                msg.sender,  \n', '                v.reserve, \n', '                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice\n', '                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice < retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                // profit = (entryPrice - closingPrice) * size\n', '                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);\n', '\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                // profit = (closingPrice - entryPrice) * size\n', '                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  \n', '\n', '                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }  \n', '\n', '        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        emit FuturesPositionClosed(positionHash);\n', '    }\n', '\n', '    function closeFuturesContract (bytes32 futuresContract, uint256 price) onlyOracle returns (bool)\n', '    {\n', '        if (futuresContracts[futuresContract].expirationBlock == 0)  return false; // contract not found\n', '        if (futuresContracts[futuresContract].closed == true)  return false; // contract already closed\n', '\n', '        if (futuresContracts[futuresContract].expirationBlock > block.number\n', '            && price > futuresContracts[futuresContract].floorPrice\n', '            && price < futuresContracts[futuresContract].capPrice) return false; // contract not yet expired and the price did not leave the range\n', '                \n', '\n', '        if (price <= futuresContracts[futuresContract].floorPrice)  \n', '        {\n', '            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].floorPrice; \n', '        }  \n', '        else if (price >= futuresContracts[futuresContract].capPrice)\n', '        {\n', '            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].capPrice;\n', '        }   \n', '        else\n', '        {\n', '            futuresContracts[futuresContract].closingPrice = price;\n', '        }         \n', '        \n', '\n', '        futuresContracts[futuresContract].closed = true;\n', '\n', '        emit FuturesContractClosed(futuresContract, price);\n', '    }  \n', '\n', '    // closes position for user\n', '    function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin\n', '    {\n', '        bytes32 positionHash = keccak256(this, user, futuresContract, side);\n', '\n', '        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\n', '        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\n', '        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\n', '\n', '        // failsafe, gas fee cannot be greater than 5% of position value\n', '        if (safeMul(gasFee * 1e10, 20) > calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))\n', '        {\n', '            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);\n', '            return;\n', '        }\n', '\n', '\n', '        uint256 profit;\n', '        uint256 loss;\n', '\n', '        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\n', '\n', '        FuturesClosePositionValues memory v = FuturesClosePositionValues({\n', '            reserve         : EtherMium(exchangeContract).getReserve(baseToken, user),\n', '            balance         : EtherMium(exchangeContract).balanceOf(baseToken, user),\n', '            floorPrice      : futuresContracts[futuresContract].floorPrice,\n', '            capPrice        : futuresContracts[futuresContract].capPrice,\n', '            closingPrice    : futuresContracts[futuresContract].closingPrice,\n', '            futuresContract : futuresContract\n', '        });\n', '\n', '        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);\n', '        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);\n', '        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;\n', '        // uint256 capPrice = futuresContracts[futuresContract].capPrice;\n', '        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;\n', '\n', '\n', '        \n', '        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);\n', '        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);\n', '\n', '        // close long position\n', '        if (side == true)\n', '        {            \n', '\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);\n', '            // return;\n', '            // reserve = reserve - (entryPrice - floorPrice) * size;\n', '            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));\n', '            \n', '            \n', '            subReserve(\n', '                baseToken, \n', '                user, \n', '                v.reserve, \n', '                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice\n', '                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice > retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);\n', '                \n', '\n', '\n', '                // LogUint(15, profit);\n', '                // LogUint(16, fee);\n', '                // LogUint(17, safeSub(profit * 1e10, fee));\n', '                // return;\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  \n', '\n', '\n', '                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }   \n', '        // close short position \n', '        else\n', '        {\n', '            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));\n', '            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);\n', '            // return;\n', '\n', '            // reserve = reserve - (capPrice - entryPrice) * size;\n', '            subReserve(\n', '                baseToken, \n', '                user,  \n', '                v.reserve, \n', '                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice\n', '                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)\n', '            );\n', '            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));\n', '            \n', '            \n', '\n', '            if (v.closingPrice < retrievePosition(positionHash)[1])\n', '            {\n', '                // user made a profit\n', '                // profit = (entryPrice - closingPrice) * size\n', '                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);\n', '\n', '                if (profit > fee)\n', '                {\n', '                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); \n', '                }\n', '                else\n', '                {\n', '                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); \n', '                }\n', '                \n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);\n', '            }\n', '            else\n', '            {\n', '                // user made a loss\n', '                // profit = (closingPrice - entryPrice) * size\n', '                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;\n', '                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  \n', '\n', '                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));\n', '\n', '                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);\n', '            }\n', '        }  \n', '\n', '        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount\n', '        updatePositionSize(positionHash, 0, 0);\n', '\n', '        emit FuturesPositionClosed(positionHash);\n', '    }\n', '\n', '    // Settle positions for closed contracts\n', '    function batchSettlePositions (\n', '        bytes32[] futuresContracts,\n', '        bool[] sides,\n', '        address[] users,\n', '        uint256 gasFeePerClose // baseToken with 8 decimals\n', '    ) onlyAdmin {\n', '        \n', '        for (uint i = 0; i < futuresContracts.length; i++) \n', '        {\n', '            closeFuturesPositionForUser(futuresContracts[i], sides[i], users[i], gasFeePerClose);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    \n', '    \n', '\n', '    // Returns the smaller of two values\n', '    function min(uint a, uint b) private pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}']
