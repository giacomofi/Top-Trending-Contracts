['pragma solidity ^0.5.7;\n', '\n', '\n', '\n', 'library SafeMath256 {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return a / b;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '    address payable internal _receiver;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n', '\n', '\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        _receiver = msg.sender;\n', '    }\n', '\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _owner);\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0));\n', '        address __previousOwner = _owner;\n', '        _owner = newOwner;\n', '        emit OwnershipTransferred(__previousOwner, newOwner);\n', '    }\n', '\n', '\n', '    function changeReceiver(address payable newReceiver) external onlyOwner {\n', '        require(newReceiver != address(0));\n', '        address __previousReceiver = _receiver;\n', '        _receiver = newReceiver;\n', '        emit ReceiverChanged(__previousReceiver, newReceiver);\n', '    }\n', '\n', '\n', '    function rescueTokens(address tokenAddress, address receiver, uint256 amount) external onlyOwner {\n', '        IERC20 _token = IERC20(tokenAddress);\n', '        require(receiver != address(0));\n', '        uint256 balance = _token.balanceOf(address(this));\n', '        require(balance >= amount);\n', '\n', '        assert(_token.transfer(receiver, amount));\n', '    }\n', '\n', '\n', '    function withdrawEther(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0));\n', '        uint256 balance = address(this).balance;\n', '        require(balance >= amount);\n', '\n', '        to.transfer(amount);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Pausable is Ownable {\n', '    bool private _paused;\n', '\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Paused.");\n', '        _;\n', '    }\n', '\n', '\n', '    function setPaused(bool state) external onlyOwner {\n', '        if (_paused && !state) {\n', '            _paused = false;\n', '            emit Unpaused(msg.sender);\n', '        } else if (!_paused && state) {\n', '            _paused = true;\n', '            emit Paused(msg.sender);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '}\n', '\n', '\n', '\n', 'interface IToken {\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function inWhitelist(address account) external view returns (bool);\n', '}\n', '\n', '\n', '\n', 'interface ITokenPublicSale {\n', '    function status() external view returns (uint256 auditEtherPrice,\n', '        uint16 stage,\n', '        uint16 season,\n', '        uint256 tokenUsdPrice,\n', '        uint256 currentTopSalesRatio,\n', '        uint256 txs,\n', '        uint256 tokenTxs,\n', '        uint256 tokenBonusTxs,\n', '        uint256 tokenWhitelistTxs,\n', '        uint256 tokenIssued,\n', '        uint256 tokenBonus,\n', '        uint256 tokenWhitelist);\n', '}\n', '\n', '\n', 'contract Get102Token is Ownable, Pausable {\n', '    using SafeMath256 for uint256;\n', '\n', '    IToken           public TOKEN             = IToken(0x4b9EcF8a0A67c16Ad5850C9ab3afc692F65e8815);\n', '    ITokenPublicSale public TOKEN_PUBLIC_SALE = ITokenPublicSale(0x26b7677a22597ac64Fc9d3961037f95af77db347);\n', '\n', '    uint256 private WEI_MIN = 1 ether;\n', '    uint256 private TOKEN_PER_TXN = 102000000; // 102.000000 Token\n', '\n', '    uint256 private _txs;\n', '\n', '    mapping (address => bool) _alreadyGot;\n', '\n', '    event Tx(uint256 etherPrice, uint256 vokdnUsdPrice, uint256 weiUsed);\n', '\n', '\n', '    function txs() public view returns (uint256) {\n', '        return _txs;\n', '    }\n', '\n', '\n', '    function () external payable whenNotPaused {\n', '        require(msg.value >= WEI_MIN);\n', '        require(TOKEN.balanceOf(address(this)) >= TOKEN_PER_TXN);\n', '        require(TOKEN.balanceOf(msg.sender) == 0);\n', '        require(!TOKEN.inWhitelist(msg.sender));\n', '        require(!_alreadyGot[msg.sender]);\n', '\n', '        uint256 __etherPrice;\n', '        uint256 __tokenUsdPrice;\n', '        (__etherPrice, , , __tokenUsdPrice, , , , , , , ,) = TOKEN_PUBLIC_SALE.status();\n', '\n', '        require(__etherPrice > 0);\n', '\n', '        uint256 __usd = TOKEN_PER_TXN.mul(__tokenUsdPrice).div(1000000);\n', '        uint256 __wei = __usd.mul(1 ether).div(__etherPrice);\n', '\n', '        require(msg.value >= __wei);\n', '\n', '        if (msg.value > __wei) {\n', '            msg.sender.transfer(msg.value.sub(__wei));\n', '            _receiver.transfer(__wei);\n', '        }\n', '\n', '        _txs = _txs.add(1);\n', '        _alreadyGot[msg.sender] = true;\n', '        emit Tx(__etherPrice, __tokenUsdPrice, __wei);\n', '\n', '        assert(TOKEN.transfer(msg.sender, TOKEN_PER_TXN));\n', '    }\n', '}']