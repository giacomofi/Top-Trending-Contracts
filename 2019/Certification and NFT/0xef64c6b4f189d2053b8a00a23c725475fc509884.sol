['pragma solidity ^0.5.0;\n', '\n', '/// https://eips.ethereum.org/EIPS/eip-165\n', 'interface ERC165 {\n', '  /// @notice Query if a contract implements an interface\n', '  /// @param interfaceID The interface identifier, as specified in ERC-165\n', '  /// @dev Interface identification is specified in ERC-165. This function\n', '  ///  uses less than 30,000 gas.\n', '  /// @return `true` if the contract implements `interfaceID` and\n', '  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// https://eips.ethereum.org/EIPS/eip-900\n', '/// @notice Interface with external methods\n', 'interface ISimpleStaking {\n', '\n', '  event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '  event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n', '\n', '  function stake(uint256 amount, bytes calldata data) external;\n', '  function stakeFor(address user, uint256 amount, bytes calldata data) external;\n', '  function unstake(uint256 amount, bytes calldata data) external;\n', '  function totalStakedFor(address addr) external view returns (uint256);\n', '  function totalStaked() external view returns (uint256);\n', '  function token() external view returns (address);\n', '  function supportsHistory() external pure returns (bool);\n', '\n', '  // optional. Commented out until we have valid reason to implement these methods\n', '  // function lastStakedFor(address addr) public view returns (uint256);\n', '  // function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256);\n', '  // function totalStakedAt(uint256 blockNumber) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * Courtesy of https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9be0f100c48e4726bee73829fbb10f7d85b6ef54/contracts/math/SafeMath.sol\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '\n', '  /// @return The total amount of tokens\n', '  function totalSupply() public view returns (uint256 supply);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', '* Smart contract to stake ERC20 and optionally lock it in for a period of time.\n', '* Users can add stake any time as long as the emergency status is false\n', '* Maximum locked-in time is 365 days from now.\n', '*\n', '* It also keeps track of the effective start time which is recorded on the very\n', '* first stake. Think of it as the "member since" attribute.\n', '* If user unstakes (full or partial) at any point, the effective start time is reset.\n', '*\n', '*/\n', 'contract TimeLockedStaking is ERC165, ISimpleStaking {\n', '  using SafeMath for uint256;\n', '\n', '  struct StakeRecord {\n', '    uint256 amount;\n', '    uint256 unlockedAt;\n', '  }\n', '\n', '  struct StakeInfo {\n', '    /// total tokens this user stakes.\n', '    uint256 totalAmount;\n', '    /// "member since" in unix timestamp. Reset when user unstakes.\n', '    uint256 effectiveAt;\n', '    /// storing staking data for unstaking later.\n', "    /// recordId i.e. key of mapping is the keccak256 of the 'data' parameter in the stake method.\n", '    mapping (bytes32 => StakeRecord) stakeRecords;\n', '  }\n', '\n', '  /// @dev When emergency is true,\n', '  /// block staking action and\n', '  /// allow to unstake without verifying the record.unlockedAt\n', '  bool public emergency;\n', '\n', '  /// @dev Owner of this contract, who can activate the emergency.\n', '  address public owner;\n', '\n', '  /// @dev Address of the ERC20 token contract used for staking.\n', '  ERC20 internal erc20Token;\n', '\n', '  /// @dev https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#avoiding-naming-collisions\n', '  uint256 internal totalStaked_ = 0;\n', '\n', '  /// Keep track of all stakers\n', '  mapping (address => StakeInfo) public stakers;\n', '\n', '  modifier greaterThanZero(uint256 num) {\n', '    require(num > 0, "Must be greater than 0.");\n', '    _;\n', '  }\n', '\n', '  /// @dev Better to manually validate these params after deployment.\n', "  /// @param token_ ERC0 token's address. Required.\n", '  /// @param owner_ Who can set emergency status. Default: msg.sender.\n', '  constructor(address token_, address owner_) public {\n', '    erc20Token = ERC20(token_);\n', '    owner = owner_;\n', '    emergency = false;\n', '  }\n', '\n', '  /// @dev Implement ERC165\n', '  /// With three or more supported interfaces (including ERC165 itself as a required supported interface),\n', '  /// the mapping approach (in every case) costs less gas than the pure approach (at worst case).\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '    return\n', '      interfaceID == this.supportsInterface.selector ||\n', '      interfaceID == this.stake.selector ^ this.stakeFor.selector ^ this.unstake.selector ^ this.totalStakedFor.selector ^ this.totalStaked.selector ^ this.token.selector ^ this.supportsHistory.selector;\n', '  }\n', '\n', '  /// @dev msg.sender stakes for him/her self.\n', '  /// @param amount Number of ERC20 to be staked. Amount must be > 0.\n', '  /// @param data Used for signaling the unlocked time.\n', '  function stake(uint256 amount, bytes calldata data) external {\n', '    registerStake(msg.sender, amount, data);\n', '  }\n', '\n', '  /// @dev msg.sender stakes for someone else.\n', '  /// @param amount Number of ERC20 to be staked. Must be > 0.\n', '  /// @param data Used for signaling the unlocked time.\n', '  function stakeFor(address user, uint256 amount, bytes calldata data) external {\n', '    registerStake(user, amount, data);\n', '  }\n', '\n', '  /// @dev msg.sender can unstake full amount or partial if unlockedAt =< now\n', '  /// @notice as a result, the "member since" attribute is reset.\n', '  /// @param amount Number of ERC20 to be unstaked. Must be > 0 and =< staked amount.\n', '  /// @param data The payload that was used when staking.\n', '  function unstake(uint256 amount, bytes calldata data)\n', '    external\n', '    greaterThanZero(stakers[msg.sender].effectiveAt) // must be a member\n', '    greaterThanZero(amount)\n', '  {\n', '    address user = msg.sender;\n', '\n', '    bytes32 recordId = keccak256(data);\n', '\n', '    StakeRecord storage record = stakers[user].stakeRecords[recordId];\n', '\n', '    require(amount <= record.amount, "Amount must be equal or smaller than the record.");\n', '\n', "    // Validate unlockedAt if there's no emergency.\n", '    // Otherwise, ignore the lockdown period.\n', '    if (!emergency) {\n', '      require(block.timestamp >= record.unlockedAt, "This stake is still locked.");\n', '    }\n', '\n', '    record.amount = record.amount.sub(amount);\n', '\n', '    stakers[user].totalAmount = stakers[user].totalAmount.sub(amount);\n', '    stakers[user].effectiveAt = block.timestamp;\n', '\n', '    totalStaked_ = totalStaked_.sub(amount);\n', '\n', '    require(erc20Token.transfer(user, amount), "Transfer failed.");\n', '    emit Unstaked(user, amount, stakers[user].totalAmount, data);\n', '  }\n', '\n', '  /// @return The staked amount of an address.\n', '  function totalStakedFor(address addr) external view returns (uint256) {\n', '    return stakers[addr].totalAmount;\n', '  }\n', '\n', '  /// @return Total number of tokens this smart contract hold.\n', '  function totalStaked() external view returns (uint256) {\n', '    return totalStaked_;\n', '  }\n', '\n', '  /// @return Address of the ERC20 used for staking.\n', '  function token() external view returns (address) {\n', '    return address(erc20Token);\n', '  }\n', '\n', '  /// @dev This smart contract does not store staking activities on chain.\n', '  /// @return false History is processed off-chain via event logs.\n', '  function supportsHistory() external pure returns (bool) {\n', '    return false;\n', '  }\n', '\n', '\n', '  /// Escape hatch\n', '  function setEmergency(bool status) external {\n', '    require(msg.sender == owner, "msg.sender must be owner.");\n', '    emergency = status;\n', '  }\n', '\n', '  /// Helpers\n', '  ///\n', '\n', '  function max(uint256 a, uint256 b) public pure returns (uint256) {\n', '    return a > b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) public pure returns (uint256) {\n', '    return a > b ? b : a;\n', '  }\n', '\n', '  function getStakeRecordUnlockedAt(address user, bytes memory data) public view returns (uint256) {\n', '    return stakers[user].stakeRecords[keccak256(data)].unlockedAt;\n', '  }\n', '\n', '  function getStakeRecordAmount(address user, bytes memory data) public view returns (uint256) {\n', '    return stakers[user].stakeRecords[keccak256(data)].amount;\n', '  }\n', '\n', '  /// @dev Get the unlockedAt in the data field.\n', '  /// Maximum of 365 days from now.\n', '  /// Minimum of 1. Default value if data.length < 32.\n', '  /// @param data The left-most 256 bits are unix timestamp in seconds.\n', '  /// @return The unlockedAt in the data. Range [1, 365 days from now].\n', '  function getUnlockedAtSignal(bytes memory data) public view returns (uint256) {\n', '    uint256 unlockedAt;\n', '\n', '    if (data.length >= 32) {\n', '      assembly {\n', '        let d := add(data, 32) // first 32 bytes are the padded length of data\n', '        unlockedAt := mload(d)\n', '      }\n', '    }\n', '\n', '    // Maximum 365 days from now\n', '    uint256 oneYearFromNow = block.timestamp + 365 days;\n', '    uint256 capped = min(unlockedAt, oneYearFromNow);\n', '\n', '    return max(1, capped);\n', '  }\n', '\n', '  /// @dev Register a stake by updating the StakeInfo struct\n', '  function registerStake(address user, uint256 amount, bytes memory data) private greaterThanZero(amount) {\n', '    require(!emergency, "Cannot stake due to emergency.");\n', '    require(erc20Token.transferFrom(msg.sender, address(this), amount), "Transfer failed.");\n', '\n', '    StakeInfo storage info = stakers[user];\n', '\n', '    // Update effective at\n', '    info.effectiveAt = info.effectiveAt == 0 ? block.timestamp : info.effectiveAt;\n', '\n', '    // Update stake record\n', '    bytes32 recordId = keccak256(data);\n', '    StakeRecord storage record = info.stakeRecords[recordId];\n', '    record.amount = amount.add(record.amount);\n', '    record.unlockedAt = record.unlockedAt == 0 ? getUnlockedAtSignal(data) : record.unlockedAt;\n', '\n', '    // Update total amounts\n', '    info.totalAmount = amount.add(info.totalAmount);\n', '    totalStaked_ = totalStaked_.add(amount);\n', '\n', '    emit Staked(user, amount, stakers[user].totalAmount, data);\n', '  }\n', '}']