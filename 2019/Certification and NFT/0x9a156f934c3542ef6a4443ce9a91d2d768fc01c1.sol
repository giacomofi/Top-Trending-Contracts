['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow.\n', '    */\n', '    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        assert(y <= x);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x + y;\n', '        assert(z >= x);\n', '        return z;\n', '    }\n', '\t\n', '\t/**\n', '    * @dev Integer division of two numbers, reverts on division by zero.\n', '    */\n', '    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\t\n', '    function safeMul(uint256 x, uint256 y) internal pure returns (uint256) {    \n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '    \n', '        uint256 z = x * y;\n', '        assert(z / x == y);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the integer percentage of the number.\n', '    */\n', '    function safePerc(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        uint256 z = x * y;\n', '        assert(z / x == y);    \n', '        z = z / 10000; // percent to hundredths\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the minimum value of two numbers.\n', '    */\t\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x <= y ? x : y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the maximum value of two numbers.\n', '    */\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x >= y ? x : y;\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title DAppDEXI - Interface \n', ' */\n', 'interface DAppDEXI {\n', '\n', '    function updateAgent(address _agent, bool _status) external;\n', '\n', '    function setAccountType(address user_, uint256 type_) external;\n', '    function getAccountType(address user_) external view returns(uint256);\n', '    function setFeeType(uint256 type_ , uint256 feeMake_, uint256 feeTake_) external;\n', '    function getFeeMake(uint256 type_ ) external view returns(uint256);\n', '    function getFeeTake(uint256 type_ ) external view returns(uint256);\n', '    function changeFeeAccount(address feeAccount_) external;\n', '    \n', '    function setWhitelistTokens(address token) external;\n', '    function setWhitelistTokens(address token, bool active, uint256 timestamp, bytes32 typeERC) external;\n', '    function depositToken(address token, uint amount) external;\n', '    function tokenFallback(address owner, uint256 amount, bytes data) external returns (bool success);\n', '\n', '    function withdraw(uint amount) external;\n', '    function withdrawToken(address token, uint amount) external;\n', '\n', '    function balanceOf(address token, address user) external view returns (uint);\n', '\n', '    function order(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce) external;\n', '    function trade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) external;    \n', '    function cancelOrder(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) external;\n', '    function testTrade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) external view returns(bool);\n', '    function availableVolume(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) external view returns(uint);\n', '    function amountFilled(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user) external view returns(uint);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20I {\n', '\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '  function transfer(address _to, uint256 _value) external returns (bool success);\n', '  \n', '  function allowance(address _owner, address _spender) external view returns (uint256);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '  function approve(address _spender, uint256 _value) external returns (bool success);\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable contract - base contract with an owner\n', ' */\n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    assert(_newOwner != address(0));      \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Accept transferOwnership.\n', '   */\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      emit OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SDADI - Interface\n', ' */\n', 'interface SDADI  {\t\n', '  function AddToken(address token) external;\n', '  function DelToken(address token) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token + balance on date\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20 \n', ' */\n', 'contract ERC20Base is ERC20I, SafeMath {\n', '\t\n', '  uint256 totalSupply_;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  uint256 public start = 0;               // Must be equal to the date of issue tokens\n', '  uint256 public period = 30 days;        // By default, the dividend accrual period is 30 days\n', '  mapping (address => mapping (uint256 => int256)) public ChangeOverPeriod;\n', '\n', '  address[] public owners;\n', '  mapping (address => bool) public ownersIndex;\n', '\n', '  struct _Prop {\n', '    uint propID;          // proposal ID in DAO    \n', '    uint endTime;         // end time of voting\n', '  }\n', '  \n', '  _Prop[] public ActiveProposals;  // contains active proposals\n', '\n', '  // contains voted Tokens on proposals\n', '  mapping (uint => mapping (address => uint)) public voted;\n', '\n', '  /** \n', '   * @dev Total Supply\n', '   * @return totalSupply_ \n', '   */  \n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '  \n', '  /** \n', '   * @dev Tokens balance\n', '   * @param _owner holder address\n', '   * @return balance amount \n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /** \n', '   * @dev Balance of tokens on date\n', '   * @param _owner holder address\n', '   * @return balance amount \n', '   */\n', '  function balanceOf(address _owner, uint _date) public view returns (uint256) {\n', '    require(_date >= start);\n', '    uint256 N1 = (_date - start) / period + 1;    \n', '\n', '    uint256 N2 = 1;\n', '    if (block.timestamp > start) {\n', '      N2 = (block.timestamp - start) / period + 1;\n', '    }\n', '\n', '    require(N2 >= N1);\n', '\n', '    int256 B = int256(balances[_owner]);\n', '\n', '    while (N2 > N1) {\n', '      B = B - ChangeOverPeriod[_owner][N2];\n', '      N2--;\n', '    }\n', '\n', '    require(B >= 0);\n', '    return uint256(B);\n', '  }\n', '\n', '  /** \n', '   * @dev Tranfer tokens to address\n', '   * @param _to dest address\n', '   * @param _value tokens amount\n', '   * @return transfer result\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    require(_to != address(0));\n', '\n', '    uint lock = 0;\n', '    for (uint k = 0; k < ActiveProposals.length; k++) {\n', '      if (ActiveProposals[k].endTime > now) {\n', '        if (lock < voted[ActiveProposals[k].propID][msg.sender]) {\n', '          lock = voted[ActiveProposals[k].propID][msg.sender];\n', '        }\n', '      }\n', '    }\n', '\n', '    require(safeSub(balances[msg.sender], lock) >= _value);\n', '\n', '    if (ownersIndex[_to] == false && _value > 0) {\n', '      ownersIndex[_to] = true;\n', '      owners.push(_to);\n', '    }\n', '    \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '\n', '    uint256 N = 1;\n', '    if (block.timestamp > start) {\n', '      N = (block.timestamp - start) / period + 1;\n', '    }\n', '\n', '    ChangeOverPeriod[msg.sender][N] = ChangeOverPeriod[msg.sender][N] - int256(_value);\n', '    ChangeOverPeriod[_to][N] = ChangeOverPeriod[_to][N] + int256(_value);\n', '   \n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /** \n', '   * @dev Token allowance\n', '   * @param _owner holder address\n', '   * @param _spender spender address\n', '   * @return remain amount\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**    \n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from source address\n', '   * @param _to dest address\n', '   * @param _value tokens amount\n', '   * @return transfer result\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    require(_to != address(0));\n', '\n', '    uint lock = 0;\n', '    for (uint k = 0; k < ActiveProposals.length; k++) {\n', '      if (ActiveProposals[k].endTime > now) {\n', '        if (lock < voted[ActiveProposals[k].propID][_from]) {\n', '          lock = voted[ActiveProposals[k].propID][_from];\n', '        }\n', '      }\n', '    }\n', '    \n', '    require(safeSub(balances[_from], lock) >= _value);\n', '    \n', '    require(allowed[_from][msg.sender] >= _value);\n', '\n', '    if (ownersIndex[_to] == false && _value > 0) {\n', '      ownersIndex[_to] = true;\n', '      owners.push(_to);\n', '    }\n', '    \n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '    \n', '    uint256 N = 1;\n', '    if (block.timestamp > start) {\n', '      N = (block.timestamp - start) / period + 1;\n', '    }\n', '\n', '    ChangeOverPeriod[_from][N] = ChangeOverPeriod[_from][N] - int256(_value);\n', '    ChangeOverPeriod[_to][N] = ChangeOverPeriod[_to][N] + int256(_value);\n', '\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  /** \n', '   * @dev Approve transfer\n', '   * @param _spender holder address\n', '   * @param _value tokens amount\n', '   * @return result  \n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    \n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /** \n', '   * @dev Trim owners with zero balance\n', '   */\n', '  function trim(uint offset, uint limit) external returns (bool) { \n', '    uint k = offset;\n', '    uint ln = limit;\n', '    while (k < ln) {\n', '      if (balances[owners[k]] == 0) {\n', '        ownersIndex[owners[k]] =  false;\n', '        owners[k] = owners[owners.length-1];\n', '        owners.length = owners.length-1;\n', '        ln--;\n', '      } else {\n', '        k++;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  // current number of shareholders (owners)\n', '  function getOwnersCount() external view returns (uint256 count) {\n', '    return owners.length;\n', '  }\n', '\n', '  // current period\n', '  function getCurrentPeriod() external view returns (uint256 N) {\n', '    if (block.timestamp > start) {\n', '      return (block.timestamp - start) / period;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function addProposal(uint _propID, uint _endTime) internal {\n', '    ActiveProposals.push(_Prop({\n', '      propID: _propID,\n', '      endTime: _endTime\n', '    }));\n', '  }\n', '\n', '  function delProposal(uint _propID) internal {\n', '    uint k = 0;\n', '    while (k < ActiveProposals.length){\n', '      if (ActiveProposals[k].propID == _propID) {\n', '        require(ActiveProposals[k].endTime < now);\n', '        ActiveProposals[k] = ActiveProposals[ActiveProposals.length-1];\n', '        ActiveProposals.length = ActiveProposals.length-1;   \n', '      } else {\n', '        k++;\n', '      }\n', '    }    \n', '  }\n', '\n', '  function getVoted(uint _propID, address _voter) external view returns (uint) {\n', '    return voted[_propID][_voter];\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Dividend Distribution Contract for DAO\n', ' */\n', 'contract Dividends is ERC20Base, Ownable {\n', '\n', '  DAppDEXI public DEX;\n', '\n', '  address[] public tokens;\n', '  mapping (address => uint) public tokensIndex;\n', '  \n', '  mapping (uint => mapping (address => uint)) public dividends;\n', '  mapping (address => mapping (address => uint)) public ownersbal;  \n', '  mapping (uint => mapping (address => mapping (address => bool))) public AlreadyReceived;\n', '\n', '  uint public multiplier = 100000; // precision to ten thousandth percent (0.001%)\n', '\n', '  event Payment(address indexed sender, uint amount);\n', '  event setDEXContractEvent(address dex);\n', '   \n', '  function AddToken(address token) public {\n', '    require(msg.sender == address(DEX));\n', '    tokens.push(token);\n', '    tokensIndex[token] = tokens.length-1;\n', '  }\n', '\n', '  function DelToken(address token) public {\n', '    require(msg.sender == address(DEX));\n', '    require(tokens[tokensIndex[token]] != 0);    \n', '    tokens[tokensIndex[token]] = tokens[tokens.length-1];\n', '    tokens.length = tokens.length-1;\n', '  }\n', '\n', '  // Take profit for dividends from DEX contract\n', '  function TakeProfit(uint offset, uint limit) external {\n', '    require (limit <= tokens.length);\n', '    require (offset < limit);\n', '\n', '    uint N = (block.timestamp - start) / period;\n', '    \n', '    require (N > 0);\n', '    \n', '    for (uint k = offset; k < limit; k++) {\n', '      if(dividends[N][tokens[k]] == 0 ) {\n', '          uint amount = DEX.balanceOf(tokens[k], address(this));\n', '          if (k == 0) {\n', '            DEX.withdraw(amount);\n', '            dividends[N][tokens[k]] = amount;\n', '          } else {\n', '            DEX.withdrawToken(tokens[k], amount);\n', '            dividends[N][tokens[k]] = amount;\n', '          }\n', '      }\n', '    }\n', '  }\n', '\n', '  function () public payable {\n', '      emit Payment(msg.sender, msg.value);\n', '  }\n', '  \n', '  // PayDividends to owners\n', '  function PayDividends(address token, uint offset, uint limit) external {\n', '    //require (address(this).balance > 0);\n', '    require (limit <= owners.length);\n', '    require (offset < limit);\n', '\n', '    uint N = (block.timestamp - start) / period; // current - 1\n', '    uint date = start + N * period - 1;\n', '    \n', '    require(dividends[N][token] > 0);\n', '\n', '    uint share = 0;\n', '    uint k = 0;\n', '    for (k = offset; k < limit; k++) {\n', '      if (!AlreadyReceived[N][token][owners[k]]) {\n', '        share = safeMul(balanceOf(owners[k], date), multiplier);\n', '        share = safeDiv(safeMul(share, 100), totalSupply_); // calc the percentage of the totalSupply_ (from 100%)\n', '\n', '        share = safePerc(dividends[N][token], share);\n', '        share = safeDiv(share, safeDiv(multiplier, 100));  // safeDiv(multiplier, 100) - convert to hundredths\n', '        \n', '        ownersbal[owners[k]][token] = safeAdd(ownersbal[owners[k]][token], share);\n', '        AlreadyReceived[N][token][owners[k]] = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  // PayDividends individuals to msg.sender\n', '  function PayDividends(address token) external {\n', '    //require (address(this).balance > 0);\n', '\n', '    uint N = (block.timestamp - start) / period; // current - 1\n', '    uint date = start + N * period - 1;\n', '\n', '    require(dividends[N][token] > 0);\n', '    \n', '    if (!AlreadyReceived[N][token][msg.sender]) {      \n', '      uint share = safeMul(balanceOf(msg.sender, date), multiplier);\n', '      share = safeDiv(safeMul(share, 100), totalSupply_); // calc the percentage of the totalSupply_ (from 100%)\n', '\n', '      share = safePerc(dividends[N][token], share);\n', '      share = safeDiv(share, safeDiv(multiplier, 100));  // safeDiv(multiplier, 100) - convert to hundredths\n', '        \n', '      ownersbal[msg.sender][token] = safeAdd(ownersbal[msg.sender][token], share);\n', '      AlreadyReceived[N][token][msg.sender] = true;\n', '    }\n', '  }\n', '\n', '  // withdraw dividends\n', '  function withdraw(address token, uint _value) external {    \n', '    require(ownersbal[msg.sender][token] >= _value);\n', '    ownersbal[msg.sender][token] = safeSub(ownersbal[msg.sender][token], _value);\n', '    if (token == address(0)) {\n', '      msg.sender.transfer(_value);\n', '    } else {\n', '      ERC20I(token).transfer(msg.sender, _value);\n', '    }\n', '  }\n', '  \n', '  // withdraw dividends to address\n', '  function withdraw(address token, uint _value, address _receiver) external {    \n', '    require(ownersbal[msg.sender][token] >= _value);\n', '    ownersbal[msg.sender][token] = safeSub(ownersbal[msg.sender][token], _value);\n', '    if (token == address(0)) {\n', '      _receiver.transfer(_value);\n', '    } else {\n', '      ERC20I(token).transfer(_receiver, _value);\n', '    }    \n', '  }\n', '\n', '  function setMultiplier(uint _value) external onlyOwner {\n', '    require(_value > 0);\n', '    multiplier = _value;\n', '  }\n', '  \n', '  function getMultiplier() external view returns (uint ) {\n', '    return multiplier;\n', '  }  \n', '\n', '  // link to DEX contract\n', '  function setDEXContract(address _contract) external onlyOwner {\n', '    DEX = DAppDEXI(_contract);\n', '    emit setDEXContractEvent(_contract);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title External interface for DAO\n', ' */\n', 'interface CommonI {\n', '    function transferOwnership(address _newOwner) external;\n', '    function acceptOwnership() external;\n', '    function updateAgent(address _agent, bool _state) external;    \n', '}\n', '\n', '\n', '/**\n', ' * @title Decentralized Autonomous Organization\n', ' */\n', 'contract DAO is Dividends {\n', '\n', '    //minimum balance for adding proposal - default 10000 tokens\n', '    uint minBalance = 1000000000000; \n', '    // minimum quorum - number of votes must be more than minimum quorum\n', '    uint public minimumQuorum;\n', '    // debating period duration\n', '    uint public debatingPeriodDuration;\n', '    // requisite majority of votes (by the system a simple majority)\n', '    uint public requisiteMajority;\n', '\n', '    struct _Proposal {\n', '        // proposal may execute only after voting ended\n', '        uint endTimeOfVoting;\n', '        // if executed = true\n', '        bool executed;\n', '        // if passed = true\n', '        bool proposalPassed;\n', '        // number of votes already voted\n', '        uint numberOfVotes;\n', '        // in support of votes\n', '        uint votesSupport;\n', '        // against votes\n', '        uint votesAgainst;\n', '        \n', '        // the address where the `amount` will go to if the proposal is accepted\n', '        address recipient;\n', '        // the amount to transfer to `recipient` if the proposal is accepted.\n', '        uint amount;\n', '        // keccak256(abi.encodePacked(recipient, amount, transactionByteCode));\n', '        bytes32 transactionHash;\n', '\n', '        // a plain text description of the proposal\n', '        string desc;\n', '        // a hash of full description data of the proposal (optional)\n', '        string fullDescHash;\n', '    }\n', '\n', '    _Proposal[] public Proposals;\n', '\n', '    event ProposalAdded(uint proposalID, address recipient, uint amount, string description, string fullDescHash);\n', '    event Voted(uint proposalID, bool position, address voter, string justification);\n', '    event ProposalTallied(uint proposalID, uint votesSupport, uint votesAgainst, uint quorum, bool active);    \n', '    event ChangeOfRules(uint newMinimumQuorum, uint newdebatingPeriodDuration, uint newRequisiteMajority);\n', '    event Payment(address indexed sender, uint amount);\n', '\n', '    // Modifier that allows only owners of tokens to vote and create new proposals\n', '    modifier onlyMembers {\n', '        require(balances[msg.sender] > 0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Change voting rules\n', '     *\n', '     * Make so that Proposals need to be discussed for at least `_debatingPeriodDuration/60` hours,\n', '     * have at least `_minimumQuorum` votes, and have 50% + `_requisiteMajority` votes to be executed\n', '     *\n', '     * @param _minimumQuorum how many members must vote on a proposal for it to be executed\n', '     * @param _debatingPeriodDuration the minimum amount of delay between when a proposal is made and when it can be executed\n', '     * @param _requisiteMajority the proposal needs to have 50% plus this number\n', '     */\n', '    function changeVotingRules(\n', '        uint _minimumQuorum,\n', '        uint _debatingPeriodDuration,\n', '        uint _requisiteMajority\n', '    ) onlyOwner public {\n', '        minimumQuorum = _minimumQuorum;\n', '        debatingPeriodDuration = _debatingPeriodDuration;\n', '        requisiteMajority = _requisiteMajority;\n', '\n', '        emit ChangeOfRules(minimumQuorum, debatingPeriodDuration, requisiteMajority);\n', '    }\n', '\n', '    /**\n', '     * Add Proposal\n', '     *\n', '     * Propose to send `_amount / 1e18` ether to `_recipient` for `_desc`. `_transactionByteCode ? Contains : Does not contain` code.\n', '     *\n', '     * @param _recipient who to send the ether to\n', '     * @param _amount amount of ether to send, in wei\n', '     * @param _desc Description of job\n', '     * @param _fullDescHash Hash of full description of job\n', '     * @param _transactionByteCode bytecode of transaction\n', '     */\n', '    function addProposal(address _recipient, uint _amount, string _desc, string _fullDescHash, bytes _transactionByteCode, uint _debatingPeriodDuration) onlyMembers public returns (uint) {\n', '        require(balances[msg.sender] > minBalance);\n', '\n', '        if (_debatingPeriodDuration == 0) {\n', '            _debatingPeriodDuration = debatingPeriodDuration;\n', '        }\n', '\n', '        Proposals.push(_Proposal({      \n', '            endTimeOfVoting: now + _debatingPeriodDuration * 1 minutes,\n', '            executed: false,\n', '            proposalPassed: false,\n', '            numberOfVotes: 0,\n', '            votesSupport: 0,\n', '            votesAgainst: 0,\n', '            recipient: _recipient,\n', '            amount: _amount,\n', '            transactionHash: keccak256(abi.encodePacked(_recipient, _amount, _transactionByteCode)),\n', '            desc: _desc,\n', '            fullDescHash: _fullDescHash\n', '        }));\n', '        \n', '        // add proposal in ERC20 base contract for block transfer\n', '        super.addProposal(Proposals.length-1, Proposals[Proposals.length-1].endTimeOfVoting);\n', '\n', '        emit ProposalAdded(Proposals.length-1, _recipient, _amount, _desc, _fullDescHash);\n', '\n', '        return Proposals.length-1;\n', '    }\n', '\n', '    /**\n', '     * Check if a proposal code matches\n', '     *\n', '     * @param _proposalID number of the proposal to query\n', '     * @param _recipient who to send the ether to\n', '     * @param _amount amount of ether to send\n', '     * @param _transactionByteCode bytecode of transaction\n', '     */\n', '    function checkProposalCode(uint _proposalID, address _recipient, uint _amount, bytes _transactionByteCode) view public returns (bool) {\n', '        require(Proposals[_proposalID].recipient == _recipient);\n', '        require(Proposals[_proposalID].amount == _amount);\n', '        // compare ByteCode        \n', '        return Proposals[_proposalID].transactionHash == keccak256(abi.encodePacked(_recipient, _amount, _transactionByteCode));\n', '    }\n', '\n', '    /**\n', '     * Log a vote for a proposal\n', '     *\n', '     * Vote `supportsProposal? in support of : against` proposal #`proposalID`\n', '     *\n', '     * @param _proposalID number of proposal\n', '     * @param _supportsProposal either in favor or against it\n', '     * @param _justificationText optional justification text\n', '     */\n', '    function vote(uint _proposalID, bool _supportsProposal, string _justificationText) onlyMembers public returns (uint) {\n', '        // Get the proposal\n', '        _Proposal storage p = Proposals[_proposalID]; \n', '        require(now <= p.endTimeOfVoting);\n', '\n', '        // get numbers of votes for msg.sender\n', '        uint votes = safeSub(balances[msg.sender], voted[_proposalID][msg.sender]);\n', '        require(votes > 0);\n', '\n', '        voted[_proposalID][msg.sender] = safeAdd(voted[_proposalID][msg.sender], votes);\n', '\n', '        // Increase the number of votes\n', '        p.numberOfVotes = p.numberOfVotes + votes;\n', '        \n', '        if (_supportsProposal) {\n', '            p.votesSupport = p.votesSupport + votes;\n', '        } else {\n', '            p.votesAgainst = p.votesAgainst + votes;\n', '        }\n', '        \n', '        emit Voted(_proposalID, _supportsProposal, msg.sender, _justificationText);\n', '        return p.numberOfVotes;\n', '    }\n', '\n', '    /**\n', '     * Finish vote\n', '     *\n', '     * Count the votes proposal #`_proposalID` and execute it if approved\n', '     *\n', '     * @param _proposalID proposal number\n', '     * @param _transactionByteCode optional: if the transaction contained a bytecode, you need to send it\n', '     */\n', '    function executeProposal(uint _proposalID, bytes _transactionByteCode) public {\n', '        // Get the proposal\n', '        _Proposal storage p = Proposals[_proposalID];\n', '\n', '        require(now > p.endTimeOfVoting                                                                       // If it is past the voting deadline\n', '            && !p.executed                                                                                    // and it has not already been executed\n', '            && p.transactionHash == keccak256(abi.encodePacked(p.recipient, p.amount, _transactionByteCode))  // and the supplied code matches the proposal\n', '            && p.numberOfVotes >= minimumQuorum);                                                             // and a minimum quorum has been reached\n', '        // then execute result\n', '        if (p.votesSupport > requisiteMajority) {\n', '            // Proposal passed; execute the transaction\n', '            require(p.recipient.call.value(p.amount)(_transactionByteCode));\n', '            p.proposalPassed = true;\n', '        } else {\n', '            // Proposal failed\n', '            p.proposalPassed = false;\n', '        }\n', '        p.executed = true;\n', '\n', '        // delete proposal from active list\n', '        super.delProposal(_proposalID);\n', '       \n', '        // Fire Events\n', '        emit ProposalTallied(_proposalID, p.votesSupport, p.votesAgainst, p.numberOfVotes, p.proposalPassed);\n', '    }\n', '\n', '    // function is needed if execution transactionByteCode in Proposal failed\n', '    function delActiveProposal(uint _proposalID) public onlyOwner {\n', '        // delete proposal from active list\n', '        super.delProposal(_proposalID);   \n', '    }\n', '\n', '    /**\n', '    * @dev Allows the DAO to transfer control of the _contract to a _newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _contract, address _newOwner) public onlyOwner {\n', '        CommonI(_contract).transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Accept transferOwnership on a this (DAO) contract\n', '     */\n', '    function acceptOwnership(address _contract) public onlyOwner {\n', '        CommonI(_contract).acceptOwnership();        \n', '    }\n', '\n', '    function updateAgent(address _contract, address _agent, bool _state) public onlyOwner {\n', '        CommonI(_contract).updateAgent(_agent, _state);        \n', '    }\n', '\n', '    /**\n', '     * Set minimum balance for adding proposal\n', '     */\n', '    function setMinBalance(uint _minBalance) public onlyOwner {\n', '        assert(_minBalance > 0);\n', '        minBalance = _minBalance;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Agent contract - base contract with an agent\n', ' */\n', 'contract Agent is Ownable {\n', '\n', '  address public defAgent;\n', '\n', '  mapping(address => bool) public Agents;\n', '  \n', '  constructor() public {    \n', '    Agents[msg.sender] = true;\n', '  }\n', '  \n', '  modifier onlyAgent() {\n', '    assert(Agents[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  function updateAgent(address _agent, bool _status) public onlyOwner {\n', '    assert(_agent != address(0));\n', '    Agents[_agent] = _status;\n', '  }  \n', '}\n', '\n', '\n', '/**\n', ' * @title SDAD - ERC20 Token based on ERC20Base, DAO, Dividends smart contracts\n', ' */\n', 'contract SDAD is SDADI, DAO {\n', '\t\n', '  uint public initialSupply = 10 * 10**6; // 10 million tokens\n', '  uint public decimals = 8;\n', '\n', '  string public name;\n', '  string public symbol;\n', '\n', '  /** Name and symbol were updated. */\n', '  event UpdatedTokenInformation(string _name, string _symbol);\n', '\n', '  /** Period were updated. */\n', '  event UpdatedPeriod(uint _period);\n', '\n', '  constructor(string _name, string _symbol, uint _start, uint _period, address _dexowner) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    start = _start;\n', '    period = _period;\n', '\n', '    totalSupply_ = initialSupply*10**decimals;\n', '\n', '    // creating initial tokens\n', '    balances[_dexowner] = totalSupply_;    \n', '    emit Transfer(0x0, _dexowner, balances[_dexowner]);\n', '\n', '    ownersIndex[_dexowner] = true;\n', '    owners.push(_dexowner);\n', '\n', '    ChangeOverPeriod[_dexowner][1] = int256(balances[_dexowner]);\n', '\n', '    // set voting rules\n', '    // _minimumQuorum = 50%\n', '    // _requisiteMajority = 25%\n', '    // _debatingPeriodDuration = 1 day\n', '    changeVotingRules(safePerc(totalSupply_, 5000), 1440, safePerc(totalSupply_, 2500));\n', '\n', '    // add ETH\n', '    tokens.push(address(0));\n', '    tokensIndex[address(0)] = tokens.length-1;\n', '  } \n', '\n', '  /**\n', '  * Owner can update token information here.\n', '  *\n', '  * It is often useful to conceal the actual token association, until\n', '  * the token operations, like central issuance or reissuance have been completed.\n', '  *\n', '  * This function allows the token owner to rename the token after the operations\n', '  * have been completed and then point the audience to use the token contract.\n', '  */\n', '  function setTokenInformation(string _name, string _symbol) public onlyOwner {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    emit UpdatedTokenInformation(_name, _symbol);\n', '  }\n', '\n', '  /**\n', '  * Owner can change period\n', '  *\n', '  */\n', '  function setPeriod(uint _period) public onlyOwner {\n', '    period = _period;\n', '    emit UpdatedPeriod(_period);    \n', '  }\n', '\n', '  /**\n', '  * set owner to self\n', '  *\n', '  */\n', '  function setOwnerToSelf() public onlyOwner {\n', '    owner = address(this);\n', '    emit OwnershipTransferred(msg.sender, address(this));\n', '  }\n', '}']