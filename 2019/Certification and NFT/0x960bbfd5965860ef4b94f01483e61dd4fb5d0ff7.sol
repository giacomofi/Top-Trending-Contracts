['pragma solidity ^0.5.0;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/Certification.sol\n', '\n', 'contract ICertification {\n', '  event Certificate(bytes32 indexed certHash, bytes32 innerHash, address indexed certifier);\n', '  event Revocation(bytes32 indexed certHash, bool invalid);  \n', '  address public newAddress;\n', '  uint public genesis;\n', '}\n', '\n', 'contract Certification is ICertification, Ownable {\n', '\n', '  struct Certifier {\n', '    bool valid;\n', '    string id;\n', '  }\n', '\n', '  mapping (address => Certifier) public certifiers;  \n', '  mapping (bytes32 => bool) public revoked;  \n', '\n', '  constructor() public {\n', '    genesis = block.number;\n', '  }\n', '\n', '  function setCertifierStatus(address certifier, bool valid)\n', '  onlyOwner public {\n', '    certifiers[certifier].valid = valid;\n', '  }\n', '\n', '  function setCertifierId(address certifier, string memory id)\n', '  onlyOwner public {\n', '    certifiers[certifier].id = id;\n', '  }\n', '\n', '  function computeCertHash(address certifier, bytes32 innerHash)\n', '  pure public returns (bytes32) {\n', '    return keccak256(abi.encodePacked(certifier, innerHash));\n', '  }\n', '\n', '  function _certify(bytes32 innerHash) internal {\n', '    emit Certificate(\n', '      computeCertHash(msg.sender, innerHash),\n', '      innerHash, msg.sender\n', '    );\n', '  }\n', '\n', '  function certifyMany(bytes32[] memory innerHashes) public {\n', '    require(certifiers[msg.sender].valid);\n', '    for(uint i = 0; i < innerHashes.length; i++) {\n', '      _certify(innerHashes[i]);\n', '    }\n', '  }\n', '\n', '  function revoke(bytes32 innerHash, address certifier, bool invalid) public {\n', '    require(isOwner() || (certifiers[msg.sender].valid && msg.sender == certifier && invalid));\n', '    bytes32 certHash = computeCertHash(certifier, innerHash);\n', '    emit Revocation(certHash, invalid);\n', '    revoked[certHash] = invalid;\n', '  }\n', '\n', '  function deprecate(address _newAddress) public onlyOwner {\n', '    newAddress = _newAddress;\n', '  }\n', '\n', '}']