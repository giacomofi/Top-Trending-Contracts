['pragma solidity ^0.5.10;\n', '\n', '\n', 'contract Custodian {\n', '\n', '  \n', '    struct Request {\n', '        bytes32 lockId;\n', '        bytes4 callbackSelector;\n', '        address callbackAddress;\n', '        uint256 idx;\n', '        uint256 timestamp;\n', '        bool extended;\n', '    }\n', '\n', '  \n', '    event Requested(\n', '        bytes32 _lockId,\n', '        address _callbackAddress,\n', '        bytes4 _callbackSelector,\n', '        uint256 _nonce,\n', '        address _whitelistedAddress,\n', '        bytes32 _requestMsgHash,\n', '        uint256 _timeLockExpiry\n', '    );\n', '\n', '  \n', '    event TimeLocked(\n', '        uint256 _timeLockExpiry,\n', '        bytes32 _requestMsgHash\n', '    );\n', '\n', '    \n', '    event Completed(\n', '        bytes32 _lockId,\n', '        bytes32 _requestMsgHash,\n', '        address _signer1,\n', '        address _signer2\n', '    );\n', '\n', '  \n', '    event Failed(\n', '        bytes32 _lockId,\n', '        bytes32 _requestMsgHash,\n', '        address _signer1,\n', '        address _signer2\n', '    );\n', '\n', '   \n', '    event TimeLockExtended(\n', '        uint256 _timeLockExpiry,\n', '        bytes32 _requestMsgHash\n', '    );\n', '\n', '  \n', '    uint256 public requestCount;\n', '\n', '   \n', '    mapping (address => bool) public signerSet;\n', '\n', '    \n', '    mapping (bytes32 => Request) public requestMap;\n', '\n', '   \n', '    mapping (address => mapping (bytes4 => uint256)) public lastCompletedIdxs;\n', '\n', '   \n', '    uint256 public defaultTimeLock;\n', '\n', '   \n', '    uint256 public extendedTimeLock;\n', '\n', '   \n', '    address public primary;\n', '\n', '  \n', '    constructor(\n', '        address[] memory _signers,\n', '        uint256 _defaultTimeLock,\n', '        uint256 _extendedTimeLock,\n', '        address _primary\n', '    )\n', '        public\n', '    {\n', '        \n', '        require(_signers.length >= 2);\n', '\n', '      \n', '        require(_defaultTimeLock <= _extendedTimeLock);\n', '        defaultTimeLock = _defaultTimeLock;\n', '        extendedTimeLock = _extendedTimeLock;\n', '\n', '        primary = _primary;\n', '\n', '        \n', '        requestCount = 0;\n', '        \n', '        for (uint i = 0; i < _signers.length; i++) {\n', '            \n', '            require(_signers[i] != address(0) && !signerSet[_signers[i]]);\n', '            signerSet[_signers[i]] = true;\n', '        }\n', '    }\n', '\n', '   \n', '    modifier onlyPrimary {\n', '        require(msg.sender == primary);\n', '        _;\n', '    }\n', '\n', '  \n', '    function requestUnlock(\n', '        bytes32 _lockId,\n', '        address _callbackAddress,\n', '        bytes4 _callbackSelector,\n', '        address _whitelistedAddress\n', '    )\n', '        public\n', '        payable\n', '        returns (bytes32 requestMsgHash)\n', '    {\n', '        require(msg.sender == primary || msg.value >= 1 ether);\n', '\n', '       \n', '        require(_callbackAddress != address(0));\n', '\n', '        uint256 requestIdx = ++requestCount;\n', '      \n', '        uint256 nonce = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), requestIdx)));\n', '\n', '        requestMsgHash = keccak256(abi.encodePacked(nonce, _whitelistedAddress, uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n', '        requestMap[requestMsgHash] = Request({\n', '            lockId: _lockId,\n', '            callbackSelector: _callbackSelector,\n', '            callbackAddress: _callbackAddress,\n', '            idx: requestIdx,\n', '            timestamp: block.timestamp,\n', '            extended: false\n', '        });\n', '\n', '      \n', '        uint256 timeLockExpiry = block.timestamp;\n', '        if (msg.sender == primary) {\n', '            timeLockExpiry += defaultTimeLock;\n', '        } else {\n', '            timeLockExpiry += extendedTimeLock;\n', '\n', '          \n', '            requestMap[requestMsgHash].extended = true;\n', '        }\n', '\n', '        emit Requested(_lockId, _callbackAddress, _callbackSelector, nonce, _whitelistedAddress, requestMsgHash, timeLockExpiry);\n', '    }\n', '\n', '    \n', '    function completeUnlock(\n', '        bytes32 _requestMsgHash,\n', '        uint8 _recoveryByte1, bytes32 _ecdsaR1, bytes32 _ecdsaS1,\n', '        uint8 _recoveryByte2, bytes32 _ecdsaR2, bytes32 _ecdsaS2\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        Request storage request = requestMap[_requestMsgHash];\n', '\n', '        bytes32 lockId = request.lockId;\n', '        address callbackAddress = request.callbackAddress;\n', '        bytes4 callbackSelector = request.callbackSelector;\n', '\n', '       \n', '        require(callbackAddress != address(0));\n', '\n', '      \n', '        require(request.idx > lastCompletedIdxs[callbackAddress][callbackSelector]);\n', '        \n', '        address signer1 =  ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _requestMsgHash)), _recoveryByte1,_ecdsaR1, _ecdsaS1);\n', '        require(signerSet[signer1]);\n', '\n', '        address signer2 =  ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _requestMsgHash)), _recoveryByte2, _ecdsaR2, _ecdsaS2);\n', '        require(signerSet[signer2]);\n', '        require(signer1 != signer2);\n', '\n', '        if (request.extended && ((block.timestamp - request.timestamp) < extendedTimeLock)) {\n', '            emit TimeLocked(request.timestamp + extendedTimeLock, _requestMsgHash);\n', '            return false;\n', '        } else if ((block.timestamp - request.timestamp) < defaultTimeLock) {\n', '            emit TimeLocked(request.timestamp + defaultTimeLock, _requestMsgHash);\n', '            return false;\n', '        } else {\n', '            if (address(this).balance > 0) {\n', '                \n', '                success = msg.sender.send(address(this).balance);\n', '            }\n', '\n', '         \n', '            lastCompletedIdxs[callbackAddress][callbackSelector] = request.idx;\n', '           \n', '            delete requestMap[_requestMsgHash];\n', '\n', '           \n', '            (success,) = callbackAddress.call(abi.encodeWithSelector(callbackSelector, lockId));\n', '\n', '            if (success) {\n', '                emit Completed(lockId, _requestMsgHash, signer1, signer2);\n', '            } else {\n', '                emit Failed(lockId, _requestMsgHash, signer1, signer2);\n', '            }\n', '        }\n', '    }\n', '\n', '    function deleteUncompletableRequest(bytes32 _requestMsgHash) public {\n', '        Request storage request = requestMap[_requestMsgHash];\n', '\n', '        uint256 idx = request.idx;\n', '\n', '        require(0 < idx && idx < lastCompletedIdxs[request.callbackAddress][request.callbackSelector]);\n', '\n', '        delete requestMap[_requestMsgHash];\n', '    }\n', '\n', '  \n', '    function extendRequestTimeLock(bytes32 _requestMsgHash) public onlyPrimary {\n', '        Request storage request = requestMap[_requestMsgHash];\n', '\n', '     \n', '        require(request.callbackAddress != address(0));\n', '\n', '       \n', '        require(request.extended != true);\n', '\n', '        \n', '        request.extended = true;\n', '\n', '        emit TimeLockExtended(request.timestamp + extendedTimeLock, _requestMsgHash);\n', '    }\n', '}\n', '\n', 'contract LockRequestable {\n', '\n', '   \n', '    uint256 public lockRequestCount;\n', '\n', '    \n', '    constructor() public {\n', '        lockRequestCount = 0;\n', '    }\n', '\n', '    function generateLockId() internal returns (bytes32 lockId) {\n', '        return keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount));\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', ' \n', '  function totalSupply() public view returns (uint256);\n', '\n', ' \n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  \n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', ' \n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '  \n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', ' \n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  \n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract CustodianUpgradeable is LockRequestable {\n', '\n', '    \n', '    struct CustodianChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '  \n', '    address public custodian;\n', '\n', '    \n', '    mapping (bytes32 => CustodianChangeRequest) public custodianChangeReqs;\n', '\n', '  \n', '    constructor(\n', '        address _custodian\n', '    )\n', '      LockRequestable()\n', '      public\n', '    {\n', '        custodian = _custodian;\n', '    }\n', '\n', '   \n', '    modifier onlyCustodian {\n', '        require(msg.sender == custodian);\n', '        _;\n', '    }\n', '\n', '    function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n', '        require(_proposedCustodian != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        custodianChangeReqs[lockId] = CustodianChangeRequest({\n', '            proposedNew: _proposedCustodian\n', '        });\n', '\n', '        emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n', '    }\n', '\n', '   \n', '    function confirmCustodianChange(bytes32 _lockId) public onlyCustodian {\n', '        custodian = getCustodianChangeReq(_lockId);\n', '\n', '        delete custodianChangeReqs[_lockId];\n', '\n', '        emit CustodianChangeConfirmed(_lockId, custodian);\n', '    }\n', '\n', '   \n', '    function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\n', '        CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\n', '\n', '       \n', '        require(changeRequest.proposedNew != address(0));\n', '\n', '        return changeRequest.proposedNew;\n', '    }\n', '   \n', '    event CustodianChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedCustodian\n', '    );\n', '\n', '    event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\n', '}\n', '\n', 'contract ERC20ImplUpgradeable is CustodianUpgradeable  {\n', '\n', '   \n', '    struct ImplChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '   \n', '    ERC20Impl public erc20Impl;\n', '\n', '   \n', '    mapping (bytes32 => ImplChangeRequest) public implChangeReqs;\n', '\n', '   \n', '    constructor(address _custodian) CustodianUpgradeable(_custodian) public {\n', '        erc20Impl = ERC20Impl(0x0);\n', '    }\n', '\n', '   \n', '    modifier onlyImpl {\n', '        require(msg.sender == address(erc20Impl));\n', '        _;\n', '    }\n', '\n', '    \n', '    function requestImplChange(address _proposedImpl) public returns (bytes32 lockId) {\n', '        require(_proposedImpl != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        implChangeReqs[lockId] = ImplChangeRequest({\n', '            proposedNew: _proposedImpl\n', '        });\n', '\n', '        emit ImplChangeRequested(lockId, msg.sender, _proposedImpl);\n', '    }\n', '\n', '   \n', '    function confirmImplChange(bytes32 _lockId) public onlyCustodian {\n', '        erc20Impl = getImplChangeReq(_lockId);\n', '\n', '        delete implChangeReqs[_lockId];\n', '\n', '        emit ImplChangeConfirmed(_lockId, address(erc20Impl));\n', '    }\n', '\n', '    \n', '    function getImplChangeReq(bytes32 _lockId) private view returns (ERC20Impl _proposedNew) {\n', '        ImplChangeRequest storage changeRequest = implChangeReqs[_lockId];\n', '\n', '     \n', '        require(changeRequest.proposedNew != address(0));\n', '\n', '        return ERC20Impl(changeRequest.proposedNew);\n', '    }\n', '\n', '  \n', '    event ImplChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedImpl\n', '    );\n', '\n', '    \n', '    event ImplChangeConfirmed(bytes32 _lockId, address _newImpl);\n', '}\n', '\n', 'contract ERC20Proxy is ERC20Interface, ERC20ImplUpgradeable {\n', '\n', '   \n', '    string public name;\n', '\n', '    \n', '    string public symbol;\n', '\n', '    \n', '    uint8 public decimals;\n', '\n', '    \n', '    constructor(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint8 _decimals,\n', '        address _custodian\n', '    )\n', '        ERC20ImplUpgradeable(_custodian)\n', '        public\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Impl.totalSupply();\n', '    }\n', '\n', '   \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Impl.balanceOf(_owner);\n', '    }\n', '\n', '    \n', '    function emitTransfer(address _from, address _to, uint256 _value) public onlyImpl {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferWithSender(msg.sender, _to, _value);\n', '    }\n', '\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);\n', '    }\n', '\n', '    function emitApproval(address _owner, address _spender, uint256 _value) public onlyImpl {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.approveWithSender(msg.sender, _spender, _value);\n', '    }\n', ' \n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n', '        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n', '        return erc20Impl.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Impl.allowance(_owner, _spender);\n', '    }\n', '}\n', '\n', 'contract ERC20Store is ERC20ImplUpgradeable {\n', '\n', '    uint256 public totalSupply;\n', '\n', '   \n', '    mapping (address => uint256) public balances;\n', '\n', '   \n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    \n', '    constructor(address _custodian) ERC20ImplUpgradeable(_custodian) public {\n', '        totalSupply = 0;\n', '    }\n', '\n', '    function setTotalSupply(\n', '        uint256 _newTotalSupply\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        totalSupply = _newTotalSupply;\n', '    }\n', '\n', '    function setAllowance(\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        allowed[_owner][_spender] = _value;\n', '    }\n', '\n', '    function setBalance(\n', '        address _owner,\n', '        uint256 _newBalance\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        balances[_owner] = _newBalance;\n', '    }\n', '\n', '    function addBalance(\n', '        address _owner,\n', '        uint256 _balanceIncrease\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        balances[_owner] = balances[_owner] + _balanceIncrease;\n', '    }\n', '}\n', '\n', 'contract ERC20Impl is CustodianUpgradeable {\n', '\n', '  \n', '    struct PendingPrint {\n', '        address receiver;\n', '        uint256 value;\n', '    }\n', '\n', '    ERC20Proxy public erc20Proxy;\n', '\n', '\n', '    ERC20Store public erc20Store;\n', '\n', '   \n', '    address public sweeper;\n', '\n', '    \n', '    bytes32 public sweepMsg;\n', '\n', '    \n', '    mapping (address => bool) public sweptSet;\n', '\n', '    \n', '    mapping (bytes32 => PendingPrint) public pendingPrintMap;\n', '\n', '   \n', '    constructor(\n', '          address _erc20Proxy,\n', '          address _erc20Store,\n', '          address _custodian,\n', '          address _sweeper\n', '    )\n', '        CustodianUpgradeable(_custodian)\n', '        public\n', '    {\n', '        require(_sweeper != address(0));\n', '        erc20Proxy = ERC20Proxy(_erc20Proxy);\n', '        erc20Store = ERC20Store(_erc20Store);\n', '\n', '        sweeper = _sweeper;\n', '        sweepMsg = keccak256(abi.encodePacked(address(this), "sweep"));\n', '    }\n', '\n', '   \n', '    modifier onlyProxy {\n', '        require(msg.sender == address(erc20Proxy));\n', '        _;\n', '    }\n', '    modifier onlySweeper {\n', '        require(msg.sender == sweeper);\n', '        _;\n', '    }\n', '\n', '\n', '   \n', '    function approveWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        erc20Store.setAllowance(_sender, _spender, _value);\n', '        erc20Proxy.emitApproval(_sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '   \n', '    function increaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0)); \n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance + _addedValue;\n', '\n', '        require(newAllowance >= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function decreaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0)); \n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance - _subtractedValue;\n', '\n', '        require(newAllowance <= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function requestPrint(address _receiver, uint256 _value) public returns (bytes32 lockId) {\n', '        require(_receiver != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        pendingPrintMap[lockId] = PendingPrint({\n', '            receiver: _receiver,\n', '            value: _value\n', '        });\n', '\n', '        emit PrintingLocked(lockId, _receiver, _value);\n', '    }\n', '\n', '   \n', '    function confirmPrint(bytes32 _lockId) public onlyCustodian {\n', '        PendingPrint storage print = pendingPrintMap[_lockId];\n', '\n', '     \n', '        address receiver = print.receiver;\n', '        require (receiver != address(0));\n', '        uint256 value = print.value;\n', '\n', '        delete pendingPrintMap[_lockId];\n', '\n', '        uint256 supply = erc20Store.totalSupply();\n', '        uint256 newSupply = supply + value;\n', '        if (newSupply >= supply) {\n', '          erc20Store.setTotalSupply(newSupply);\n', '          erc20Store.addBalance(receiver, value);\n', '\n', '          emit PrintingConfirmed(_lockId, receiver, value);\n', '          erc20Proxy.emitTransfer(address(0), receiver, value);\n', '        }\n', '    }\n', '\n', ' \n', '    function burn(uint256 _value) public returns (bool success) {\n', '        uint256 balanceOfSender = erc20Store.balances(msg.sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        erc20Store.setBalance(msg.sender, balanceOfSender - _value);\n', '        erc20Store.setTotalSupply(erc20Store.totalSupply() - _value);\n', '\n', '        erc20Proxy.emitTransfer(msg.sender, address(0), _value);\n', '\n', '        return true;\n', '    }\n', '\n', '  \n', '    function batchTransfer(address[] memory _tos, uint256[] memory _values) public returns (bool success) {\n', '        require(_tos.length == _values.length);\n', '\n', '        uint256 numTransfers = _tos.length;\n', '        uint256 senderBalance = erc20Store.balances(msg.sender);\n', '\n', '        for (uint256 i = 0; i < numTransfers; i++) {\n', '          address to = _tos[i];\n', '          require(to != address(0));\n', '          uint256 v = _values[i];\n', '          require(senderBalance >= v);\n', '\n', '          if (msg.sender != to) {\n', '            senderBalance -= v;\n', '            erc20Store.addBalance(to, v);\n', '          }\n', '          erc20Proxy.emitTransfer(msg.sender, to, v);\n', '        }\n', '\n', '        erc20Store.setBalance(msg.sender, senderBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    \n', '    function enableSweep(uint8[] memory _vs, bytes32[] memory _rs, bytes32[] memory _ss, address _to) public onlySweeper {\n', '        require(_to != address(0));\n', '        require((_vs.length == _rs.length) && (_vs.length == _ss.length));\n', '\n', '        uint256 numSignatures = _vs.length;\n', '        uint256 sweptBalance = 0;\n', '\n', '        for (uint256 i=0; i<numSignatures; ++i) {\n', '          address from = ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32",sweepMsg)), _vs[i], _rs[i], _ss[i]);\n', '\n', '      \n', '          if (from != address(0)) {\n', '            sweptSet[from] = true;\n', '\n', '            uint256 fromBalance = erc20Store.balances(from);\n', '\n', '            if (fromBalance > 0) {\n', '              sweptBalance += fromBalance;\n', '\n', '              erc20Store.setBalance(from, 0);\n', '\n', '              erc20Proxy.emitTransfer(from, _to, fromBalance);\n', '            }\n', '          }\n', '        }\n', '\n', '        if (sweptBalance > 0) {\n', '          erc20Store.addBalance(_to, sweptBalance);\n', '        }\n', '    }\n', '\n', '    \n', '    function replaySweep(address[] memory _froms, address _to) public onlySweeper {\n', '        require(_to != address(0));\n', '        uint256 lenFroms = _froms.length;\n', '        uint256 sweptBalance = 0;\n', '\n', '        for (uint256 i=0; i<lenFroms; ++i) {\n', '            address from = _froms[i];\n', '\n', '            if (sweptSet[from]) {\n', '                uint256 fromBalance = erc20Store.balances(from);\n', '\n', '                if (fromBalance > 0) {\n', '                    sweptBalance += fromBalance;\n', '\n', '                    erc20Store.setBalance(from, 0);\n', '\n', '                    erc20Proxy.emitTransfer(from, _to, fromBalance);\n', '                }\n', '            }\n', '        }\n', '\n', '        if (sweptBalance > 0) {\n', '            erc20Store.addBalance(_to, sweptBalance);\n', '        }\n', '    }\n', '\n', '   \n', '    function transferFromWithSender(\n', '        address _sender,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_to != address(0)); \n', '\n', '        uint256 balanceOfFrom = erc20Store.balances(_from);\n', '        require(_value <= balanceOfFrom);\n', '\n', '        uint256 senderAllowance = erc20Store.allowed(_from, _sender);\n', '        require(_value <= senderAllowance);\n', '\n', '        erc20Store.setBalance(_from, balanceOfFrom - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Store.setAllowance(_from, _sender, senderAllowance - _value);\n', '\n', '        erc20Proxy.emitTransfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferWithSender(\n', '        address _sender,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_to != address(0)); \n', '        uint256 balanceOfSender = erc20Store.balances(_sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        erc20Store.setBalance(_sender, balanceOfSender - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Proxy.emitTransfer(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Store.totalSupply();\n', '    }\n', '\n', '   \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Store.balances(_owner);\n', '    }\n', '\n', '   \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Store.allowed(_owner, _spender);\n', '    }\n', '\n', '   \n', '    event PrintingLocked(bytes32 _lockId, address _receiver, uint256 _value);\n', '  \n', '    event PrintingConfirmed(bytes32 _lockId, address _receiver, uint256 _value);\n', '}\n', '\n', 'contract PrintLimiter is LockRequestable {\n', '\n', '   \n', '    struct PendingCeilingRaise {\n', '        uint256 raiseBy;\n', '    }\n', '\n', '  \n', '    ERC20Impl public erc20Impl;\n', '\n', '   \n', '    address public custodian;\n', '\n', '    address public limitedPrinter;\n', '\n', '    uint256 public totalSupplyCeiling;\n', '\n', '    mapping (bytes32 => PendingCeilingRaise) public pendingRaiseMap;\n', '\n', '    constructor(\n', '        address _erc20Impl,\n', '        address _custodian,\n', '        address _limitedPrinter,\n', '        uint256 _initialCeiling\n', '    )\n', '        public\n', '    {\n', '        erc20Impl = ERC20Impl(_erc20Impl);\n', '        custodian = _custodian;\n', '        limitedPrinter = _limitedPrinter;\n', '        totalSupplyCeiling = _initialCeiling;\n', '    }\n', '\n', '   \n', '    modifier onlyCustodian {\n', '        require(msg.sender == custodian);\n', '        _;\n', '    }\n', '    modifier onlyLimitedPrinter {\n', '        require(msg.sender == limitedPrinter);\n', '        _;\n', '    }\n', '\n', '    function limitedPrint(address _receiver, uint256 _value) public onlyLimitedPrinter {\n', '        uint256 totalSupply = erc20Impl.totalSupply();\n', '        uint256 newTotalSupply = totalSupply + _value;\n', '\n', '        require(newTotalSupply >= totalSupply);\n', '        require(newTotalSupply <= totalSupplyCeiling);\n', '        erc20Impl.confirmPrint(erc20Impl.requestPrint(_receiver, _value));\n', '    }\n', '\n', '    function requestCeilingRaise(uint256 _raiseBy) public returns (bytes32 lockId) {\n', '        require(_raiseBy != 0);\n', '\n', '        lockId = generateLockId();\n', '\n', '        pendingRaiseMap[lockId] = PendingCeilingRaise({\n', '            raiseBy: _raiseBy\n', '        });\n', '\n', '        emit CeilingRaiseLocked(lockId, _raiseBy);\n', '    }\n', '\n', '    function confirmCeilingRaise(bytes32 _lockId) public onlyCustodian {\n', '        PendingCeilingRaise storage pendingRaise = pendingRaiseMap[_lockId];\n', '\n', '      \n', '        uint256 raiseBy = pendingRaise.raiseBy;\n', '\n', '        require(raiseBy != 0);\n', '\n', '        delete pendingRaiseMap[_lockId];\n', '\n', '        uint256 newCeiling = totalSupplyCeiling + raiseBy;\n', '        if (newCeiling >= totalSupplyCeiling) {\n', '            totalSupplyCeiling = newCeiling;\n', '\n', '            emit CeilingRaiseConfirmed(_lockId, raiseBy, newCeiling);\n', '        }\n', '    }\n', '\n', '  \n', '    function lowerCeiling(uint256 _lowerBy) public onlyLimitedPrinter {\n', '        uint256 newCeiling = totalSupplyCeiling - _lowerBy;\n', '        // overflow check\n', '        require(newCeiling <= totalSupplyCeiling);\n', '        totalSupplyCeiling = newCeiling;\n', '\n', '        emit CeilingLowered(_lowerBy, newCeiling);\n', '    }\n', '\n', '   \n', '    function confirmPrintProxy(bytes32 _lockId) public onlyCustodian {\n', '        erc20Impl.confirmPrint(_lockId);\n', '    }\n', '\n', '   \n', '    function confirmCustodianChangeProxy(bytes32 _lockId) public onlyCustodian {\n', '        erc20Impl.confirmCustodianChange(_lockId);\n', '    }\n', '\n', '   \n', '    event CeilingRaiseLocked(bytes32 _lockId, uint256 _raiseBy);\n', '  \n', '    event CeilingRaiseConfirmed(bytes32 _lockId, uint256 _raiseBy, uint256 _newCeiling);\n', '\n', '   \n', '    event CeilingLowered(uint256 _lowerBy, uint256 _newCeiling);\n', '}']