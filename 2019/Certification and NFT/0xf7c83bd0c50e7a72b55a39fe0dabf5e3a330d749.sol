['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-06\n', '*/\n', '\n', '// File: @ensdomains/ens/contracts/ENS.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface ENS {\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Deed.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface Deed {\n', '\n', '    function setOwner(address payable newOwner) external;\n', '    function setRegistrar(address newRegistrar) external;\n', '    function setBalance(uint newValue, bool throwOnFailure) external;\n', '    function closeDeed(uint refundRatio) external;\n', '    function destroyDeed() external;\n', '\n', '    function owner() external view returns (address);\n', '    function previousOwner() external view returns (address);\n', '    function value() external view returns (uint);\n', '    function creationDate() external view returns (uint);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Registrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', 'interface Registrar {\n', '\n', '    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\n', '\n', '    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n', '    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n', '    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n', '    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n', '    event HashReleased(bytes32 indexed hash, uint value);\n', '    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\n', '\n', '    function state(bytes32 _hash) external view returns (Mode);\n', '    function startAuction(bytes32 _hash) external;\n', '    function startAuctions(bytes32[] calldata _hashes) external;\n', '    function newBid(bytes32 sealedBid) external payable;\n', '    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\n', '    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\n', '    function cancelBid(address bidder, bytes32 seal) external;\n', '    function finalizeAuction(bytes32 _hash) external;\n', '    function transfer(bytes32 _hash, address payable newOwner) external;\n', '    function releaseDeed(bytes32 _hash) external;\n', '    function invalidateName(string calldata unhashedName) external;\n', '    function eraseNode(bytes32[] calldata labels) external;\n', '    function transferRegistrars(bytes32 _hash) external;\n', '    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\n', '    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/BaseRegistrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract BaseRegistrar is IERC721, Ownable {\n', '    uint constant public GRACE_PERIOD = 90 days;\n', '\n', '    event ControllerAdded(address indexed controller);\n', '    event ControllerRemoved(address indexed controller);\n', '    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRenewed(uint256 indexed id, uint expires);\n', '\n', '    // Expiration timestamp for migrated domains.\n', '    uint public transferPeriodEnds;\n', '\n', '    // The ENS registry\n', '    ENS public ens;\n', '\n', '    // The namehash of the TLD this registrar owns (eg, .eth)\n', '    bytes32 public baseNode;\n', '\n', '    // The interim registrar\n', '    Registrar public previousRegistrar;\n', '\n', '    // A map of addresses that are authorised to register and renew names.\n', '    mapping(address=>bool) public controllers;\n', '\n', '    // Authorises a controller, who can register and renew domains.\n', '    function addController(address controller) external;\n', '\n', '    // Revoke controller permission for an address.\n', '    function removeController(address controller) external;\n', '\n', '    // Set the resolver for the TLD this registrar manages.\n', '    function setResolver(address resolver) external;\n', '\n', '    // Returns the expiration timestamp of the specified label hash.\n', '    function nameExpires(uint256 id) external view returns(uint);\n', '\n', '    // Returns true iff the specified name is available for registration.\n', '    function available(uint256 id) public view returns(bool);\n', '\n', '    /**\n', '     * @dev Register a name.\n', '     */\n', '    function register(uint256 id, address owner, uint duration) external returns(uint);\n', '\n', '    function renew(uint256 id, uint duration) external returns(uint);\n', '\n', '    /**\n', '     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n', '     */\n', '    function reclaim(uint256 id, address owner) external;\n', '\n', '    /**\n', '     * @dev Transfers a registration from the initial registrar.\n', '     * This function is called by the initial registrar when a user calls `transferRegistrars`.\n', '     */\n', '    function acceptRegistrarTransfer(bytes32 label, Deed deed, uint) external;\n', '}\n', '\n', '// File: contracts/StringUtils.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'library StringUtils {\n', '    /**\n', '     * @dev Returns the length of a given string\n', '     *\n', '     * @param s The string to measure the length of\n', '     * @return The length of the input string\n', '     */\n', '    function strlen(string memory s) internal pure returns (uint) {\n', '        uint len;\n', '        uint i = 0;\n', '        uint bytelength = bytes(s).length;\n', '        for(len = 0; i < bytelength; len++) {\n', '            byte b = bytes(s)[i];\n', '            if(b < 0x80) {\n', '                i += 1;\n', '            } else if (b < 0xE0) {\n', '                i += 2;\n', '            } else if (b < 0xF0) {\n', '                i += 3;\n', '            } else if (b < 0xF8) {\n', '                i += 4;\n', '            } else if (b < 0xFC) {\n', '                i += 5;\n', '            } else {\n', '                i += 6;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '}\n', '\n', '// File: contracts/PriceOracle.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface PriceOracle {\n', '    /**\n', '     * @dev Returns the price to register or renew a name.\n', '     * @param name The name being registered or renewed.\n', '     * @param expires When the name presently expires (0 if this is a new registration).\n', '     * @param duration How long the name is being registered or extended for, in seconds.\n', '     * @return The price of this renewal or registration, in wei.\n', '     */\n', '    function price(string calldata name, uint expires, uint duration) external view returns(uint);\n', '}\n', '\n', '// File: @ensdomains/buffer/contracts/Buffer.sol\n', '\n', 'pragma solidity >0.4.18;\n', '\n', '/**\n', '* @dev A library for working with mutable byte buffers in Solidity.\n', '*\n', '* Byte buffers are mutable and expandable, and provide a variety of primitives\n', '* for writing to them. At any time you can fetch a bytes object containing the\n', '* current contents of the buffer. The bytes object should not be stored between\n', '* operations, as it may change due to resizing of the buffer.\n', '*/\n', 'library Buffer {\n', '    /**\n', '    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n', '    *      a capacity. The capacity may be longer than the current value, in\n', '    *      which case it can be extended without the need to allocate more memory.\n', '    */\n', '    struct buffer {\n', '        bytes buf;\n', '        uint capacity;\n', '    }\n', '\n', '    /**\n', '    * @dev Initializes a buffer with an initial capacity.\n', '    * @param buf The buffer to initialize.\n', '    * @param capacity The number of bytes of space to allocate the buffer.\n', '    * @return The buffer, for chaining.\n', '    */\n', '    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n', '        if (capacity % 32 != 0) {\n', '            capacity += 32 - (capacity % 32);\n', '        }\n', '        // Allocate space for the buffer data\n', '        buf.capacity = capacity;\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(buf, ptr)\n', '            mstore(ptr, 0)\n', '            mstore(0x40, add(32, add(ptr, capacity)))\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Initializes a new buffer from an existing bytes object.\n', '    *      Changes to the buffer may mutate the original value.\n', '    * @param b The bytes object to initialize the buffer with.\n', '    * @return A new buffer.\n', '    */\n', '    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n', '        buffer memory buf;\n', '        buf.buf = b;\n', '        buf.capacity = b.length;\n', '        return buf;\n', '    }\n', '\n', '    function resize(buffer memory buf, uint capacity) private pure {\n', '        bytes memory oldbuf = buf.buf;\n', '        init(buf, capacity);\n', '        append(buf, oldbuf);\n', '    }\n', '\n', '    function max(uint a, uint b) private pure returns(uint) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '\n', '    /**\n', '    * @dev Sets buffer length to 0.\n', '    * @param buf The buffer to truncate.\n', '    * @return The original buffer, for chaining..\n', '    */\n', '    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n', '        assembly {\n', '            let bufptr := mload(buf)\n', '            mstore(bufptr, 0)\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The start offset to write to.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to copy.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n', '        require(len <= data.length);\n', '\n', '        if (off + len > buf.capacity) {\n', '            resize(buf, max(buf.capacity, len + off) * 2);\n', '        }\n', '\n', '        uint dest;\n', '        uint src;\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Length of existing buffer data\n', '            let buflen := mload(bufptr)\n', '            // Start address = buffer address + offset + sizeof(buffer length)\n', '            dest := add(add(bufptr, 32), off)\n', '            // Update buffer length if we&#39;re extending it\n', '            if gt(add(len, off), buflen) {\n', '                mstore(bufptr, add(len, off))\n', '            }\n', '            src := add(data, 32)\n', '        }\n', '\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to copy.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, len);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, data.length);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write the byte at.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n', '        if (off >= buf.capacity) {\n', '            resize(buf, buf.capacity * 2);\n', '        }\n', '\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Length of existing buffer data\n', '            let buflen := mload(bufptr)\n', '            // Address = buffer address + sizeof(buffer length) + off\n', '            let dest := add(add(bufptr, off), 32)\n', '            mstore8(dest, data)\n', '            // Update buffer length if we extended it\n', '            if eq(off, buflen) {\n', '                mstore(bufptr, add(buflen, 1))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n', '        return writeUint8(buf, buf.buf.length, data);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n', '    *      exceed the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to write (left-aligned).\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n', '        if (len + off > buf.capacity) {\n', '            resize(buf, (len + off) * 2);\n', '        }\n', '\n', '        uint mask = 256 ** len - 1;\n', '        // Right-align data\n', '        data = data >> (8 * (32 - len));\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Address = buffer address + sizeof(buffer length) + off + len\n', '            let dest := add(add(bufptr, off), len)\n', '            mstore(dest, or(and(mload(dest), not(mask)), data))\n', '            // Update buffer length if we extended it\n', '            if gt(add(off, len), mload(bufptr)) {\n', '                mstore(bufptr, add(off, len))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n', '        return write(buf, off, bytes32(data), 20);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chhaining.\n', '    */\n', '    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, bytes32(data), 20);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, 32);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to write (right-aligned).\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n', '        if (len + off > buf.capacity) {\n', '            resize(buf, (len + off) * 2);\n', '        }\n', '\n', '        uint mask = 256 ** len - 1;\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Address = buffer address + off + sizeof(buffer length) + len\n', '            let dest := add(add(bufptr, off), len)\n', '            mstore(dest, or(and(mload(dest), not(mask)), data))\n', '            // Update buffer length if we extended it\n', '            if gt(add(off, len), mload(bufptr)) {\n', '                mstore(bufptr, add(off, len))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n', '     * exceed the capacity of the buffer.\n', '     * @param buf The buffer to append to.\n', '     * @param data The data to append.\n', '     * @return The original buffer.\n', '     */\n', '    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n', '        return writeInt(buf, buf.buf.length, data, len);\n', '    }\n', '}\n', '\n', '// File: @ensdomains/dnssec-oracle/contracts/BytesUtils.sol\n', '\n', 'pragma solidity >0.4.23;\n', '\n', 'library BytesUtils {\n', '    /*\n', '    * @dev Returns the keccak-256 hash of a byte range.\n', '    * @param self The byte string to hash.\n', '    * @param offset The position to start hashing at.\n', '    * @param len The number of bytes to hash.\n', '    * @return The hash of the byte range.\n', '    */\n', '    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\n', '        require(offset + len <= self.length);\n', '        assembly {\n', '            ret := keccak256(add(add(self, 32), offset), len)\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '    * @dev Returns a positive number if `other` comes lexicographically after\n', '    *      `self`, a negative number if it comes before, or zero if the\n', '    *      contents of the two bytes are equal.\n', '    * @param self The first bytes to compare.\n', '    * @param other The second bytes to compare.\n', '    * @return The result of the comparison.\n', '    */\n', '    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\n', '        return compare(self, 0, self.length, other, 0, other.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns a positive number if `other` comes lexicographically after\n', '    *      `self`, a negative number if it comes before, or zero if the\n', '    *      contents of the two bytes are equal. Comparison is done per-rune,\n', '    *      on unicode codepoints.\n', '    * @param self The first bytes to compare.\n', '    * @param offset The offset of self.\n', '    * @param len    The length of self.\n', '    * @param other The second bytes to compare.\n', '    * @param otheroffset The offset of the other string.\n', '    * @param otherlen    The length of the other string.\n', '    * @return The result of the comparison.\n', '    */\n', '    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n', '        uint shortest = len;\n', '        if (otherlen < len)\n', '        shortest = otherlen;\n', '\n', '        uint selfptr;\n', '        uint otherptr;\n', '\n', '        assembly {\n', '            selfptr := add(self, add(offset, 32))\n', '            otherptr := add(other, add(otheroffset, 32))\n', '        }\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint mask;\n', '                if (shortest > 32) {\n', '                    mask = uint256(- 1); // aka 0xffffff....\n', '                } else {\n', '                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '\n', '        return int(len) - int(otherlen);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @param otherOffset The offset into the second byte range.\n', '    * @param len The number of bytes to compare\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\n', '        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal with offsets.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @param otherOffset The offset into the second byte range.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\n', '        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n', '    }\n', '\n', '    /*\n', '    * @dev Compares a range of &#39;self&#39; to all of &#39;other&#39; and returns True iff\n', '    *      they are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n', '        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param other The second byte range to compare.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\n', '        return self.length == other.length && equals(self, 0, other, 0, self.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 8-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 8 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\n', '        return uint8(self[idx]);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 16-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 16 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\n', '        require(idx + 2 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\n', '        require(idx + 4 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32 byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\n', '        require(idx + 32 <= self.length);\n', '        assembly {\n', '            ret := mload(add(add(self, 32), idx))\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32 byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\n', '        require(idx + 20 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the n byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes.\n', '    * @param len The number of bytes.\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\n', '        require(len <= 32);\n', '        require(idx + len <= self.length);\n', '        assembly {\n', '            let mask := not(sub(exp(256, sub(32, len)), 1))\n', '            ret := and(mload(add(add(self, 32), idx)),  mask)\n', '        }\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Copies a substring into a new byte string.\n', '    * @param self The byte string to copy from.\n', '    * @param offset The offset to start copying at.\n', '    * @param len The number of bytes to copy.\n', '    */\n', '    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\n', '        require(offset + len <= self.length);\n', '\n', '        bytes memory ret = new bytes(len);\n', '        uint dest;\n', '        uint src;\n', '\n', '        assembly {\n', '            dest := add(ret, 32)\n', '            src := add(add(self, 32), offset)\n', '        }\n', '        memcpy(dest, src, len);\n', '\n', '        return ret;\n', '    }\n', '\n', '    // Maps characters from 0x30 to 0x7A to their base32 values.\n', '    // 0xFF represents invalid characters in that range.\n', '    bytes constant base32HexTable = hex&#39;00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F&#39;;\n', '\n', '    /**\n', '     * @dev Decodes unpadded base32 data of up to one word in length.\n', '     * @param self The data to decode.\n', '     * @param off Offset into the string to start at.\n', '     * @param len Number of characters to decode.\n', '     * @return The decoded data, left aligned.\n', '     */\n', '    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\n', '        require(len <= 52);\n', '\n', '        uint ret = 0;\n', '        uint8 decoded;\n', '        for(uint i = 0; i < len; i++) {\n', '            bytes1 char = self[off + i];\n', '            require(char >= 0x30 && char <= 0x7A);\n', '            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\n', '            require(decoded <= 0x20);\n', '            if(i == len - 1) {\n', '                break;\n', '            }\n', '            ret = (ret << 5) | decoded;\n', '        }\n', '\n', '        uint bitlen = len * 5;\n', '        if(len % 8 == 0) {\n', '            // Multiple of 8 characters, no padding\n', '            ret = (ret << 5) | decoded;\n', '        } else if(len % 8 == 2) {\n', '            // Two extra characters - 1 byte\n', '            ret = (ret << 3) | (decoded >> 2);\n', '            bitlen -= 2;\n', '        } else if(len % 8 == 4) {\n', '            // Four extra characters - 2 bytes\n', '            ret = (ret << 1) | (decoded >> 4);\n', '            bitlen -= 4;\n', '        } else if(len % 8 == 5) {\n', '            // Five extra characters - 3 bytes\n', '            ret = (ret << 4) | (decoded >> 1);\n', '            bitlen -= 1;\n', '        } else if(len % 8 == 7) {\n', '            // Seven extra characters - 4 bytes\n', '            ret = (ret << 2) | (decoded >> 3);\n', '            bitlen -= 3;\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        return bytes32(ret << (256 - bitlen));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove an account&#39;s access to this role\n', '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/ShortNameClaims.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev ShortNameClaims is a contract that permits people to register claims\n', ' *      for short (3-6 character) ENS names ahead of the auction process.\n', ' *\n', ' *      Anyone with a DNS name registered before January 1, 2019, may use this\n', ' *      name to support a claim for a matching ENS name. In the event that\n', ' *      multiple claimants request the same name, the name will be assigned to\n', ' *      the oldest registered DNS name.\n', ' *\n', ' *      Claims may be submitted by calling `submitExactClaim`,\n', ' *      `submitCombinedClaim` or `submitPrefixClaim` as appropriate.\n', ' *\n', ' *      Claims require lodging a deposit equivalent to 365 days&#39; registration of\n', ' *      the name. If the claim is approved, this deposit is spent, and the name\n', ' *      is registered for the claimant for 365 days. If the claim is declined,\n', ' *      the deposit will be returned.\n', ' */\n', 'contract ShortNameClaims {\n', '    using Roles for Roles.Role;\n', '\n', '    uint constant public REGISTRATION_PERIOD = 31536000;\n', '\n', '    using Buffer for Buffer.buffer;\n', '    using BytesUtils for bytes;\n', '    using StringUtils for string;\n', '\n', '    enum Phase {\n', '        OPEN,\n', '        REVIEW,\n', '        FINAL\n', '    }\n', '\n', '    enum Status {\n', '        PENDING,\n', '        APPROVED,\n', '        DECLINED,\n', '        WITHDRAWN\n', '    }\n', '\n', '    struct Claim {\n', '        bytes32 labelHash;\n', '        address claimant;\n', '        uint paid;\n', '        Status status;\n', '    }\n', '\n', '    Roles.Role owners;\n', '    Roles.Role ratifiers;\n', '\n', '    PriceOracle public priceOracle;\n', '    BaseRegistrar public registrar;\n', '    mapping(bytes32=>Claim) public claims;\n', '    mapping(bytes32=>bool) approvedNames;\n', '    uint public pendingClaims;\n', '    uint public unresolvedClaims;\n', '    Phase public phase;\n', '\n', '    event ClaimSubmitted(string claimed, bytes dnsname, uint paid, address claimant, string email);\n', '    event ClaimStatusChanged(bytes32 indexed claimId, Status status);\n', '\n', '    constructor(PriceOracle _priceOracle, BaseRegistrar _registrar, address _ratifier) public {\n', '        priceOracle = _priceOracle;\n', '        registrar = _registrar;\n', '        phase = Phase.OPEN;\n', '\n', '        owners.add(msg.sender);\n', '        ratifiers.add(_ratifier);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(owners.has(msg.sender), "Caller must be an owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyRatifier() {\n', '        require(ratifiers.has(msg.sender), "Caller must be a ratifier");\n', '        _;\n', '    }\n', '\n', '    modifier inPhase(Phase p) {\n', '        require(phase == p, "Not in required phase");\n', '        _;\n', '    }\n', '\n', '    function addOwner(address owner) external onlyOwner {\n', '        owners.add(owner);\n', '    }\n', '\n', '    function removeOwner(address owner) external onlyOwner {\n', '        owners.remove(owner);\n', '    }\n', '\n', '    function addRatifier(address ratifier) external onlyRatifier {\n', '        ratifiers.add(ratifier);\n', '    }\n', '\n', '    function removeRatifier(address ratifier) external onlyRatifier {\n', '        ratifiers.remove(ratifier);\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the claim ID for a submitted claim, so it can be looked up\n', '     *      using `claims`.\n', '     * @param claimed The name being claimed (eg, &#39;foo&#39;)\n', '     * @param dnsname The DNS-encoded name supporting the claim (eg, &#39;foo.test&#39;)\n', '     * @param claimant The address making the claim.\n', '     * @return The claim ID.\n', '     */\n', '    function computeClaimId(string memory claimed, bytes memory dnsname, address claimant, string memory email) public pure returns(bytes32) {\n', '        return keccak256(abi.encodePacked(keccak256(bytes(claimed)), keccak256(dnsname), claimant, keccak256(bytes(email))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the cost associated with placing a claim.\n', '     * @param claimed The name being claimed.\n', '     * @return The cost in wei for this claim.\n', '     */\n', '    function getClaimCost(string memory claimed) public view returns(uint) {\n', '        return priceOracle.price(claimed, 0, REGISTRATION_PERIOD);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for an exact match (eg, foo.test -> foo.eth).\n', '     *      Claimants must provide an amount of ether equal to 365 days&#39;\n', '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitExactClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        string memory claimed = getLabel(name, 0);\n', '        handleClaim(claimed, name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for match on name+tld (eg, foo.tv -> footv).\n', '     *      Claimants must provide an amount of ether equal to 365 days&#39;\n', '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitCombinedClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        bytes memory firstLabel = bytes(getLabel(name, 0));\n', '        bytes memory secondLabel = bytes(getLabel(name, 1));\n', '        Buffer.buffer memory buf;\n', '        buf.init(firstLabel.length + secondLabel.length);\n', '        buf.append(firstLabel);\n', '        buf.append(secondLabel);\n', '\n', '        handleClaim(string(buf.buf), name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for prefix match (eg, fooeth.test -> foo.eth).\n', '     *      Claimants must provide an amount of ether equal to 365 days&#39;\n', '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitPrefixClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        bytes memory firstLabel = bytes(getLabel(name, 0));\n', '        require(firstLabel.equals(firstLabel.length - 3, bytes("eth")));\n', '        handleClaim(string(firstLabel.substring(0, firstLabel.length - 3)), name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Closes the claim submission period.\n', '     *      Callable only by the owner.\n', '     */\n', '    function closeClaims() external onlyOwner inPhase(Phase.OPEN) {\n', '        phase = Phase.REVIEW;\n', '    }\n', '\n', '    /**\n', '     * @dev Ratifies the current set of claims.\n', '     *      Ratification freezes the claims and their resolutions, and permits\n', '     *      them to be acted on.\n', '     */\n', '    function ratifyClaims() external onlyRatifier inPhase(Phase.REVIEW) {\n', '        // Can&#39;t ratify until all claims have a resolution.\n', '        require(pendingClaims == 0);\n', '        phase = Phase.FINAL;\n', '    }\n', '\n', '    /**\n', '     * @dev Cleans up the contract, after all claims are resolved.\n', '     *      Callable only by the owner, and only in final state.\n', '     */\n', '    function destroy() external onlyOwner inPhase(Phase.FINAL) {\n', '        require(unresolvedClaims == 0);\n', '        selfdestruct(toPayable(msg.sender));\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the status of a claim to either APPROVED or DECLINED.\n', '     *      Callable only during the review phase, and only by the owner or\n', '     *      ratifier.\n', '     * @param claimId The claim to set the status of.\n', '     * @param approved True if the claim is approved, false if it is declined.\n', '     */\n', '    function setClaimStatus(bytes32 claimId, bool approved) public inPhase(Phase.REVIEW) {\n', '        // Only callable by owner or ratifier\n', '        require(owners.has(msg.sender) || ratifiers.has(msg.sender));\n', '\n', '        Claim memory claim = claims[claimId];\n', '        require(claim.paid > 0, "Claim not found");\n', '\n', '        if(claim.status == Status.PENDING) {\n', '          // Claim went from pending -> approved/declined; update counters\n', '          pendingClaims--;\n', '          unresolvedClaims++;\n', '        } else if(claim.status == Status.APPROVED) {\n', '          // Claim was previously approved; remove from approved map\n', '          approvedNames[claim.labelHash] = false;\n', '        }\n', '\n', '        // Claim was just approved; check the name was not already used, and add\n', '        // to approved map\n', '        if(approved) {\n', '          require(!approvedNames[claim.labelHash]);\n', '          approvedNames[claim.labelHash] = true;\n', '        }\n', '\n', '        Status status = approved?Status.APPROVED:Status.DECLINED;\n', '        claims[claimId].status = status;\n', '        emit ClaimStatusChanged(claimId, status);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the status of multiple claims. Callable only during the review\n', '     *      phase, and only by the owner or ratifier.\n', '     * @param approved A list of approved claim IDs.\n', '     * @param declined A list of declined claim IDs.\n', '     */\n', '    function setClaimStatuses(bytes32[] calldata approved, bytes32[] calldata declined) external {\n', '        for(uint i = 0; i < approved.length; i++) {\n', '            setClaimStatus(approved[i], true);\n', '        }\n', '        for(uint i = 0; i < declined.length; i++) {\n', '            setClaimStatus(declined[i], false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Resolves a claim. Callable by anyone, only in the final phase.\n', '     *      Resolving a claim either registers the name or refunds the claimant.\n', '     * @param claimId The claim ID to resolve.\n', '     */\n', '    function resolveClaim(bytes32 claimId) public inPhase(Phase.FINAL) {\n', '        Claim memory claim = claims[claimId];\n', '        require(claim.paid > 0, "Claim not found");\n', '\n', '        if(claim.status == Status.APPROVED) {\n', '            registrar.register(uint256(claim.labelHash), claim.claimant, REGISTRATION_PERIOD);\n', '            toPayable(registrar.owner()).transfer(claim.paid);\n', '        } else if(claim.status == Status.DECLINED) {\n', '            toPayable(claim.claimant).transfer(claim.paid);\n', '        } else {\n', '            // It should not be possible to get to FINAL with claim IDs that are\n', '            // not either APPROVED or DECLINED.\n', '            assert(false);\n', '        }\n', '\n', '        unresolvedClaims--;\n', '        delete claims[claimId];\n', '    }\n', '\n', '    /**\n', '     * @dev Resolves multiple claims. Callable by anyone, only in the final phase.\n', '     * @param claimIds A list of claim IDs to resolve.\n', '     */\n', '    function resolveClaims(bytes32[] calldata claimIds) external {\n', '        for(uint i = 0; i < claimIds.length; i++) {\n', '            resolveClaim(claimIds[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws a claim and refunds the claimant.\n', '     *      Callable only by the claimant, at any time.\n', '     * @param claimId The ID of the claim to withdraw.\n', '     */\n', '    function withdrawClaim(bytes32 claimId) external {\n', '        Claim memory claim = claims[claimId];\n', '\n', '        // Only callable by claimant\n', '        require(msg.sender == claim.claimant);\n', '\n', '        if(claim.status == Status.PENDING) {\n', '            pendingClaims--;\n', '        } else {\n', '            unresolvedClaims--;\n', '        }\n', '\n', '        toPayable(claim.claimant).transfer(claim.paid);\n', '        emit ClaimStatusChanged(claimId, Status.WITHDRAWN);\n', '        delete claims[claimId];\n', '    }\n', '\n', '    function handleClaim(string memory claimed, bytes memory name, address claimant, string memory email) internal inPhase(Phase.OPEN) {\n', '        uint len = claimed.strlen();\n', '        require(len >= 3 && len <= 6);\n', '\n', '        bytes32 claimId = computeClaimId(claimed, name, claimant, email);\n', '        require(claims[claimId].paid == 0, "Claim already submitted");\n', '\n', '        // Require that there are at most two labels (name.tld)\n', '        require(bytes(getLabel(name, 2)).length == 0, "Name must be a 2LD");\n', '\n', '        uint price = getClaimCost(claimed);\n', '        require(msg.value >= price, "Insufficient funds for reservation");\n', '        if(msg.value > price) {\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '\n', '        claims[claimId] = Claim(keccak256(bytes(claimed)), claimant, price, Status.PENDING);\n', '        pendingClaims++;\n', '        emit ClaimSubmitted(claimed, name, price, claimant, email);\n', '    }\n', '\n', '    function getLabel(bytes memory name, uint idx) internal pure returns(string memory) {\n', '        // Skip the first `idx` labels\n', '        uint offset = 0;\n', '        for(uint i = 0; i < idx; i++) {\n', '            if(offset >= name.length) return "";\n', '            offset += name.readUint8(offset) + 1;\n', '        }\n', '\n', '        // Read the label we care about\n', '        if(offset >= name.length) return &#39;&#39;;\n', '        uint len = name.readUint8(offset);\n', '        return string(name.substring(offset + 1, len));\n', '    }\n', '\n', '    function toPayable(address addr) internal pure returns(address payable) {\n', '        return address(uint160(addr));\n', '    }\n', '}']
['// File: @ensdomains/ens/contracts/ENS.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface ENS {\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Deed.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface Deed {\n', '\n', '    function setOwner(address payable newOwner) external;\n', '    function setRegistrar(address newRegistrar) external;\n', '    function setBalance(uint newValue, bool throwOnFailure) external;\n', '    function closeDeed(uint refundRatio) external;\n', '    function destroyDeed() external;\n', '\n', '    function owner() external view returns (address);\n', '    function previousOwner() external view returns (address);\n', '    function value() external view returns (uint);\n', '    function creationDate() external view returns (uint);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Registrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', 'interface Registrar {\n', '\n', '    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\n', '\n', '    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n', '    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n', '    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n', '    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n', '    event HashReleased(bytes32 indexed hash, uint value);\n', '    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\n', '\n', '    function state(bytes32 _hash) external view returns (Mode);\n', '    function startAuction(bytes32 _hash) external;\n', '    function startAuctions(bytes32[] calldata _hashes) external;\n', '    function newBid(bytes32 sealedBid) external payable;\n', '    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\n', '    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\n', '    function cancelBid(address bidder, bytes32 seal) external;\n', '    function finalizeAuction(bytes32 _hash) external;\n', '    function transfer(bytes32 _hash, address payable newOwner) external;\n', '    function releaseDeed(bytes32 _hash) external;\n', '    function invalidateName(string calldata unhashedName) external;\n', '    function eraseNode(bytes32[] calldata labels) external;\n', '    function transferRegistrars(bytes32 _hash) external;\n', '    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\n', '    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/BaseRegistrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract BaseRegistrar is IERC721, Ownable {\n', '    uint constant public GRACE_PERIOD = 90 days;\n', '\n', '    event ControllerAdded(address indexed controller);\n', '    event ControllerRemoved(address indexed controller);\n', '    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRenewed(uint256 indexed id, uint expires);\n', '\n', '    // Expiration timestamp for migrated domains.\n', '    uint public transferPeriodEnds;\n', '\n', '    // The ENS registry\n', '    ENS public ens;\n', '\n', '    // The namehash of the TLD this registrar owns (eg, .eth)\n', '    bytes32 public baseNode;\n', '\n', '    // The interim registrar\n', '    Registrar public previousRegistrar;\n', '\n', '    // A map of addresses that are authorised to register and renew names.\n', '    mapping(address=>bool) public controllers;\n', '\n', '    // Authorises a controller, who can register and renew domains.\n', '    function addController(address controller) external;\n', '\n', '    // Revoke controller permission for an address.\n', '    function removeController(address controller) external;\n', '\n', '    // Set the resolver for the TLD this registrar manages.\n', '    function setResolver(address resolver) external;\n', '\n', '    // Returns the expiration timestamp of the specified label hash.\n', '    function nameExpires(uint256 id) external view returns(uint);\n', '\n', '    // Returns true iff the specified name is available for registration.\n', '    function available(uint256 id) public view returns(bool);\n', '\n', '    /**\n', '     * @dev Register a name.\n', '     */\n', '    function register(uint256 id, address owner, uint duration) external returns(uint);\n', '\n', '    function renew(uint256 id, uint duration) external returns(uint);\n', '\n', '    /**\n', '     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n', '     */\n', '    function reclaim(uint256 id, address owner) external;\n', '\n', '    /**\n', '     * @dev Transfers a registration from the initial registrar.\n', '     * This function is called by the initial registrar when a user calls `transferRegistrars`.\n', '     */\n', '    function acceptRegistrarTransfer(bytes32 label, Deed deed, uint) external;\n', '}\n', '\n', '// File: contracts/StringUtils.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'library StringUtils {\n', '    /**\n', '     * @dev Returns the length of a given string\n', '     *\n', '     * @param s The string to measure the length of\n', '     * @return The length of the input string\n', '     */\n', '    function strlen(string memory s) internal pure returns (uint) {\n', '        uint len;\n', '        uint i = 0;\n', '        uint bytelength = bytes(s).length;\n', '        for(len = 0; i < bytelength; len++) {\n', '            byte b = bytes(s)[i];\n', '            if(b < 0x80) {\n', '                i += 1;\n', '            } else if (b < 0xE0) {\n', '                i += 2;\n', '            } else if (b < 0xF0) {\n', '                i += 3;\n', '            } else if (b < 0xF8) {\n', '                i += 4;\n', '            } else if (b < 0xFC) {\n', '                i += 5;\n', '            } else {\n', '                i += 6;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '}\n', '\n', '// File: contracts/PriceOracle.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface PriceOracle {\n', '    /**\n', '     * @dev Returns the price to register or renew a name.\n', '     * @param name The name being registered or renewed.\n', '     * @param expires When the name presently expires (0 if this is a new registration).\n', '     * @param duration How long the name is being registered or extended for, in seconds.\n', '     * @return The price of this renewal or registration, in wei.\n', '     */\n', '    function price(string calldata name, uint expires, uint duration) external view returns(uint);\n', '}\n', '\n', '// File: @ensdomains/buffer/contracts/Buffer.sol\n', '\n', 'pragma solidity >0.4.18;\n', '\n', '/**\n', '* @dev A library for working with mutable byte buffers in Solidity.\n', '*\n', '* Byte buffers are mutable and expandable, and provide a variety of primitives\n', '* for writing to them. At any time you can fetch a bytes object containing the\n', '* current contents of the buffer. The bytes object should not be stored between\n', '* operations, as it may change due to resizing of the buffer.\n', '*/\n', 'library Buffer {\n', '    /**\n', '    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n', '    *      a capacity. The capacity may be longer than the current value, in\n', '    *      which case it can be extended without the need to allocate more memory.\n', '    */\n', '    struct buffer {\n', '        bytes buf;\n', '        uint capacity;\n', '    }\n', '\n', '    /**\n', '    * @dev Initializes a buffer with an initial capacity.\n', '    * @param buf The buffer to initialize.\n', '    * @param capacity The number of bytes of space to allocate the buffer.\n', '    * @return The buffer, for chaining.\n', '    */\n', '    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n', '        if (capacity % 32 != 0) {\n', '            capacity += 32 - (capacity % 32);\n', '        }\n', '        // Allocate space for the buffer data\n', '        buf.capacity = capacity;\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(buf, ptr)\n', '            mstore(ptr, 0)\n', '            mstore(0x40, add(32, add(ptr, capacity)))\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Initializes a new buffer from an existing bytes object.\n', '    *      Changes to the buffer may mutate the original value.\n', '    * @param b The bytes object to initialize the buffer with.\n', '    * @return A new buffer.\n', '    */\n', '    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n', '        buffer memory buf;\n', '        buf.buf = b;\n', '        buf.capacity = b.length;\n', '        return buf;\n', '    }\n', '\n', '    function resize(buffer memory buf, uint capacity) private pure {\n', '        bytes memory oldbuf = buf.buf;\n', '        init(buf, capacity);\n', '        append(buf, oldbuf);\n', '    }\n', '\n', '    function max(uint a, uint b) private pure returns(uint) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '\n', '    /**\n', '    * @dev Sets buffer length to 0.\n', '    * @param buf The buffer to truncate.\n', '    * @return The original buffer, for chaining..\n', '    */\n', '    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n', '        assembly {\n', '            let bufptr := mload(buf)\n', '            mstore(bufptr, 0)\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The start offset to write to.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to copy.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n', '        require(len <= data.length);\n', '\n', '        if (off + len > buf.capacity) {\n', '            resize(buf, max(buf.capacity, len + off) * 2);\n', '        }\n', '\n', '        uint dest;\n', '        uint src;\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Length of existing buffer data\n', '            let buflen := mload(bufptr)\n', '            // Start address = buffer address + offset + sizeof(buffer length)\n', '            dest := add(add(bufptr, 32), off)\n', "            // Update buffer length if we're extending it\n", '            if gt(add(len, off), buflen) {\n', '                mstore(bufptr, add(len, off))\n', '            }\n', '            src := add(data, 32)\n', '        }\n', '\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to copy.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, len);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, data.length);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write the byte at.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n', '        if (off >= buf.capacity) {\n', '            resize(buf, buf.capacity * 2);\n', '        }\n', '\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Length of existing buffer data\n', '            let buflen := mload(bufptr)\n', '            // Address = buffer address + sizeof(buffer length) + off\n', '            let dest := add(add(bufptr, off), 32)\n', '            mstore8(dest, data)\n', '            // Update buffer length if we extended it\n', '            if eq(off, buflen) {\n', '                mstore(bufptr, add(buflen, 1))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n', '        return writeUint8(buf, buf.buf.length, data);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n', '    *      exceed the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to write (left-aligned).\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n', '        if (len + off > buf.capacity) {\n', '            resize(buf, (len + off) * 2);\n', '        }\n', '\n', '        uint mask = 256 ** len - 1;\n', '        // Right-align data\n', '        data = data >> (8 * (32 - len));\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Address = buffer address + sizeof(buffer length) + off + len\n', '            let dest := add(add(bufptr, off), len)\n', '            mstore(dest, or(and(mload(dest), not(mask)), data))\n', '            // Update buffer length if we extended it\n', '            if gt(add(off, len), mload(bufptr)) {\n', '                mstore(bufptr, add(off, len))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n', '    *      capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n', '        return write(buf, off, bytes32(data), 20);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chhaining.\n', '    */\n', '    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, bytes32(data), 20);\n', '    }\n', '\n', '    /**\n', '    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param data The data to append.\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n', '        return write(buf, buf.buf.length, data, 32);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n', '    *      the capacity of the buffer.\n', '    * @param buf The buffer to append to.\n', '    * @param off The offset to write at.\n', '    * @param data The data to append.\n', '    * @param len The number of bytes to write (right-aligned).\n', '    * @return The original buffer, for chaining.\n', '    */\n', '    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n', '        if (len + off > buf.capacity) {\n', '            resize(buf, (len + off) * 2);\n', '        }\n', '\n', '        uint mask = 256 ** len - 1;\n', '        assembly {\n', '            // Memory address of the buffer data\n', '            let bufptr := mload(buf)\n', '            // Address = buffer address + off + sizeof(buffer length) + len\n', '            let dest := add(add(bufptr, off), len)\n', '            mstore(dest, or(and(mload(dest), not(mask)), data))\n', '            // Update buffer length if we extended it\n', '            if gt(add(off, len), mload(bufptr)) {\n', '                mstore(bufptr, add(off, len))\n', '            }\n', '        }\n', '        return buf;\n', '    }\n', '\n', '    /**\n', '     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n', '     * exceed the capacity of the buffer.\n', '     * @param buf The buffer to append to.\n', '     * @param data The data to append.\n', '     * @return The original buffer.\n', '     */\n', '    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n', '        return writeInt(buf, buf.buf.length, data, len);\n', '    }\n', '}\n', '\n', '// File: @ensdomains/dnssec-oracle/contracts/BytesUtils.sol\n', '\n', 'pragma solidity >0.4.23;\n', '\n', 'library BytesUtils {\n', '    /*\n', '    * @dev Returns the keccak-256 hash of a byte range.\n', '    * @param self The byte string to hash.\n', '    * @param offset The position to start hashing at.\n', '    * @param len The number of bytes to hash.\n', '    * @return The hash of the byte range.\n', '    */\n', '    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\n', '        require(offset + len <= self.length);\n', '        assembly {\n', '            ret := keccak256(add(add(self, 32), offset), len)\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '    * @dev Returns a positive number if `other` comes lexicographically after\n', '    *      `self`, a negative number if it comes before, or zero if the\n', '    *      contents of the two bytes are equal.\n', '    * @param self The first bytes to compare.\n', '    * @param other The second bytes to compare.\n', '    * @return The result of the comparison.\n', '    */\n', '    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\n', '        return compare(self, 0, self.length, other, 0, other.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns a positive number if `other` comes lexicographically after\n', '    *      `self`, a negative number if it comes before, or zero if the\n', '    *      contents of the two bytes are equal. Comparison is done per-rune,\n', '    *      on unicode codepoints.\n', '    * @param self The first bytes to compare.\n', '    * @param offset The offset of self.\n', '    * @param len    The length of self.\n', '    * @param other The second bytes to compare.\n', '    * @param otheroffset The offset of the other string.\n', '    * @param otherlen    The length of the other string.\n', '    * @return The result of the comparison.\n', '    */\n', '    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n', '        uint shortest = len;\n', '        if (otherlen < len)\n', '        shortest = otherlen;\n', '\n', '        uint selfptr;\n', '        uint otherptr;\n', '\n', '        assembly {\n', '            selfptr := add(self, add(offset, 32))\n', '            otherptr := add(other, add(otheroffset, 32))\n', '        }\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint mask;\n', '                if (shortest > 32) {\n', '                    mask = uint256(- 1); // aka 0xffffff....\n', '                } else {\n', '                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '\n', '        return int(len) - int(otherlen);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @param otherOffset The offset into the second byte range.\n', '    * @param len The number of bytes to compare\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\n', '        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal with offsets.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @param otherOffset The offset into the second byte range.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\n', '        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n', '    }\n', '\n', '    /*\n', "    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n", '    *      they are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param offset The offset into the first byte range.\n', '    * @param other The second byte range to compare.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n', '        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the two byte ranges are equal.\n', '    * @param self The first byte range to compare.\n', '    * @param other The second byte range to compare.\n', '    * @return True if the byte ranges are equal, false otherwise.\n', '    */\n', '    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\n', '        return self.length == other.length && equals(self, 0, other, 0, self.length);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 8-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 8 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\n', '        return uint8(self[idx]);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 16-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 16 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\n', '        require(idx + 2 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32-bit number at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bits of the string, interpreted as an integer.\n', '    */\n', '    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\n', '        require(idx + 4 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32 byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\n', '        require(idx + 32 <= self.length);\n', '        assembly {\n', '            ret := mload(add(add(self, 32), idx))\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the 32 byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\n', '        require(idx + 20 <= self.length);\n', '        assembly {\n', '            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the n byte value at the specified index of self.\n', '    * @param self The byte string.\n', '    * @param idx The index into the bytes.\n', '    * @param len The number of bytes.\n', '    * @return The specified 32 bytes of the string.\n', '    */\n', '    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\n', '        require(len <= 32);\n', '        require(idx + len <= self.length);\n', '        assembly {\n', '            let mask := not(sub(exp(256, sub(32, len)), 1))\n', '            ret := and(mload(add(add(self, 32), idx)),  mask)\n', '        }\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Copies a substring into a new byte string.\n', '    * @param self The byte string to copy from.\n', '    * @param offset The offset to start copying at.\n', '    * @param len The number of bytes to copy.\n', '    */\n', '    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\n', '        require(offset + len <= self.length);\n', '\n', '        bytes memory ret = new bytes(len);\n', '        uint dest;\n', '        uint src;\n', '\n', '        assembly {\n', '            dest := add(ret, 32)\n', '            src := add(add(self, 32), offset)\n', '        }\n', '        memcpy(dest, src, len);\n', '\n', '        return ret;\n', '    }\n', '\n', '    // Maps characters from 0x30 to 0x7A to their base32 values.\n', '    // 0xFF represents invalid characters in that range.\n', "    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\n", '\n', '    /**\n', '     * @dev Decodes unpadded base32 data of up to one word in length.\n', '     * @param self The data to decode.\n', '     * @param off Offset into the string to start at.\n', '     * @param len Number of characters to decode.\n', '     * @return The decoded data, left aligned.\n', '     */\n', '    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\n', '        require(len <= 52);\n', '\n', '        uint ret = 0;\n', '        uint8 decoded;\n', '        for(uint i = 0; i < len; i++) {\n', '            bytes1 char = self[off + i];\n', '            require(char >= 0x30 && char <= 0x7A);\n', '            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\n', '            require(decoded <= 0x20);\n', '            if(i == len - 1) {\n', '                break;\n', '            }\n', '            ret = (ret << 5) | decoded;\n', '        }\n', '\n', '        uint bitlen = len * 5;\n', '        if(len % 8 == 0) {\n', '            // Multiple of 8 characters, no padding\n', '            ret = (ret << 5) | decoded;\n', '        } else if(len % 8 == 2) {\n', '            // Two extra characters - 1 byte\n', '            ret = (ret << 3) | (decoded >> 2);\n', '            bitlen -= 2;\n', '        } else if(len % 8 == 4) {\n', '            // Four extra characters - 2 bytes\n', '            ret = (ret << 1) | (decoded >> 4);\n', '            bitlen -= 4;\n', '        } else if(len % 8 == 5) {\n', '            // Five extra characters - 3 bytes\n', '            ret = (ret << 4) | (decoded >> 1);\n', '            bitlen -= 1;\n', '        } else if(len % 8 == 7) {\n', '            // Seven extra characters - 4 bytes\n', '            ret = (ret << 2) | (decoded >> 3);\n', '            bitlen -= 3;\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        return bytes32(ret << (256 - bitlen));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/ShortNameClaims.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev ShortNameClaims is a contract that permits people to register claims\n', ' *      for short (3-6 character) ENS names ahead of the auction process.\n', ' *\n', ' *      Anyone with a DNS name registered before January 1, 2019, may use this\n', ' *      name to support a claim for a matching ENS name. In the event that\n', ' *      multiple claimants request the same name, the name will be assigned to\n', ' *      the oldest registered DNS name.\n', ' *\n', ' *      Claims may be submitted by calling `submitExactClaim`,\n', ' *      `submitCombinedClaim` or `submitPrefixClaim` as appropriate.\n', ' *\n', " *      Claims require lodging a deposit equivalent to 365 days' registration of\n", ' *      the name. If the claim is approved, this deposit is spent, and the name\n', ' *      is registered for the claimant for 365 days. If the claim is declined,\n', ' *      the deposit will be returned.\n', ' */\n', 'contract ShortNameClaims {\n', '    using Roles for Roles.Role;\n', '\n', '    uint constant public REGISTRATION_PERIOD = 31536000;\n', '\n', '    using Buffer for Buffer.buffer;\n', '    using BytesUtils for bytes;\n', '    using StringUtils for string;\n', '\n', '    enum Phase {\n', '        OPEN,\n', '        REVIEW,\n', '        FINAL\n', '    }\n', '\n', '    enum Status {\n', '        PENDING,\n', '        APPROVED,\n', '        DECLINED,\n', '        WITHDRAWN\n', '    }\n', '\n', '    struct Claim {\n', '        bytes32 labelHash;\n', '        address claimant;\n', '        uint paid;\n', '        Status status;\n', '    }\n', '\n', '    Roles.Role owners;\n', '    Roles.Role ratifiers;\n', '\n', '    PriceOracle public priceOracle;\n', '    BaseRegistrar public registrar;\n', '    mapping(bytes32=>Claim) public claims;\n', '    mapping(bytes32=>bool) approvedNames;\n', '    uint public pendingClaims;\n', '    uint public unresolvedClaims;\n', '    Phase public phase;\n', '\n', '    event ClaimSubmitted(string claimed, bytes dnsname, uint paid, address claimant, string email);\n', '    event ClaimStatusChanged(bytes32 indexed claimId, Status status);\n', '\n', '    constructor(PriceOracle _priceOracle, BaseRegistrar _registrar, address _ratifier) public {\n', '        priceOracle = _priceOracle;\n', '        registrar = _registrar;\n', '        phase = Phase.OPEN;\n', '\n', '        owners.add(msg.sender);\n', '        ratifiers.add(_ratifier);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(owners.has(msg.sender), "Caller must be an owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyRatifier() {\n', '        require(ratifiers.has(msg.sender), "Caller must be a ratifier");\n', '        _;\n', '    }\n', '\n', '    modifier inPhase(Phase p) {\n', '        require(phase == p, "Not in required phase");\n', '        _;\n', '    }\n', '\n', '    function addOwner(address owner) external onlyOwner {\n', '        owners.add(owner);\n', '    }\n', '\n', '    function removeOwner(address owner) external onlyOwner {\n', '        owners.remove(owner);\n', '    }\n', '\n', '    function addRatifier(address ratifier) external onlyRatifier {\n', '        ratifiers.add(ratifier);\n', '    }\n', '\n', '    function removeRatifier(address ratifier) external onlyRatifier {\n', '        ratifiers.remove(ratifier);\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the claim ID for a submitted claim, so it can be looked up\n', '     *      using `claims`.\n', "     * @param claimed The name being claimed (eg, 'foo')\n", "     * @param dnsname The DNS-encoded name supporting the claim (eg, 'foo.test')\n", '     * @param claimant The address making the claim.\n', '     * @return The claim ID.\n', '     */\n', '    function computeClaimId(string memory claimed, bytes memory dnsname, address claimant, string memory email) public pure returns(bytes32) {\n', '        return keccak256(abi.encodePacked(keccak256(bytes(claimed)), keccak256(dnsname), claimant, keccak256(bytes(email))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the cost associated with placing a claim.\n', '     * @param claimed The name being claimed.\n', '     * @return The cost in wei for this claim.\n', '     */\n', '    function getClaimCost(string memory claimed) public view returns(uint) {\n', '        return priceOracle.price(claimed, 0, REGISTRATION_PERIOD);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for an exact match (eg, foo.test -> foo.eth).\n', "     *      Claimants must provide an amount of ether equal to 365 days'\n", '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitExactClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        string memory claimed = getLabel(name, 0);\n', '        handleClaim(claimed, name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for match on name+tld (eg, foo.tv -> footv).\n', "     *      Claimants must provide an amount of ether equal to 365 days'\n", '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitCombinedClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        bytes memory firstLabel = bytes(getLabel(name, 0));\n', '        bytes memory secondLabel = bytes(getLabel(name, 1));\n', '        Buffer.buffer memory buf;\n', '        buf.init(firstLabel.length + secondLabel.length);\n', '        buf.append(firstLabel);\n', '        buf.append(secondLabel);\n', '\n', '        handleClaim(string(buf.buf), name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a claim for prefix match (eg, fooeth.test -> foo.eth).\n', "     *      Claimants must provide an amount of ether equal to 365 days'\n", '     *      registration cost; call `getClaimCost` to determine this amount.\n', '     *      Claimants should supply a little extra in case of variation in price;\n', '     *      any excess will be returned to the sender.\n', '     * @param name The DNS-encoded name of the domain being used to support the\n', '     *             claim.\n', '     * @param claimant The address of the claimant.\n', '     * @param email An email address for correspondence regarding the claim.\n', '     */\n', '    function submitPrefixClaim(bytes memory name, address claimant, string memory email) public payable {\n', '        bytes memory firstLabel = bytes(getLabel(name, 0));\n', '        require(firstLabel.equals(firstLabel.length - 3, bytes("eth")));\n', '        handleClaim(string(firstLabel.substring(0, firstLabel.length - 3)), name, claimant, email);\n', '    }\n', '\n', '    /**\n', '     * @dev Closes the claim submission period.\n', '     *      Callable only by the owner.\n', '     */\n', '    function closeClaims() external onlyOwner inPhase(Phase.OPEN) {\n', '        phase = Phase.REVIEW;\n', '    }\n', '\n', '    /**\n', '     * @dev Ratifies the current set of claims.\n', '     *      Ratification freezes the claims and their resolutions, and permits\n', '     *      them to be acted on.\n', '     */\n', '    function ratifyClaims() external onlyRatifier inPhase(Phase.REVIEW) {\n', "        // Can't ratify until all claims have a resolution.\n", '        require(pendingClaims == 0);\n', '        phase = Phase.FINAL;\n', '    }\n', '\n', '    /**\n', '     * @dev Cleans up the contract, after all claims are resolved.\n', '     *      Callable only by the owner, and only in final state.\n', '     */\n', '    function destroy() external onlyOwner inPhase(Phase.FINAL) {\n', '        require(unresolvedClaims == 0);\n', '        selfdestruct(toPayable(msg.sender));\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the status of a claim to either APPROVED or DECLINED.\n', '     *      Callable only during the review phase, and only by the owner or\n', '     *      ratifier.\n', '     * @param claimId The claim to set the status of.\n', '     * @param approved True if the claim is approved, false if it is declined.\n', '     */\n', '    function setClaimStatus(bytes32 claimId, bool approved) public inPhase(Phase.REVIEW) {\n', '        // Only callable by owner or ratifier\n', '        require(owners.has(msg.sender) || ratifiers.has(msg.sender));\n', '\n', '        Claim memory claim = claims[claimId];\n', '        require(claim.paid > 0, "Claim not found");\n', '\n', '        if(claim.status == Status.PENDING) {\n', '          // Claim went from pending -> approved/declined; update counters\n', '          pendingClaims--;\n', '          unresolvedClaims++;\n', '        } else if(claim.status == Status.APPROVED) {\n', '          // Claim was previously approved; remove from approved map\n', '          approvedNames[claim.labelHash] = false;\n', '        }\n', '\n', '        // Claim was just approved; check the name was not already used, and add\n', '        // to approved map\n', '        if(approved) {\n', '          require(!approvedNames[claim.labelHash]);\n', '          approvedNames[claim.labelHash] = true;\n', '        }\n', '\n', '        Status status = approved?Status.APPROVED:Status.DECLINED;\n', '        claims[claimId].status = status;\n', '        emit ClaimStatusChanged(claimId, status);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the status of multiple claims. Callable only during the review\n', '     *      phase, and only by the owner or ratifier.\n', '     * @param approved A list of approved claim IDs.\n', '     * @param declined A list of declined claim IDs.\n', '     */\n', '    function setClaimStatuses(bytes32[] calldata approved, bytes32[] calldata declined) external {\n', '        for(uint i = 0; i < approved.length; i++) {\n', '            setClaimStatus(approved[i], true);\n', '        }\n', '        for(uint i = 0; i < declined.length; i++) {\n', '            setClaimStatus(declined[i], false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Resolves a claim. Callable by anyone, only in the final phase.\n', '     *      Resolving a claim either registers the name or refunds the claimant.\n', '     * @param claimId The claim ID to resolve.\n', '     */\n', '    function resolveClaim(bytes32 claimId) public inPhase(Phase.FINAL) {\n', '        Claim memory claim = claims[claimId];\n', '        require(claim.paid > 0, "Claim not found");\n', '\n', '        if(claim.status == Status.APPROVED) {\n', '            registrar.register(uint256(claim.labelHash), claim.claimant, REGISTRATION_PERIOD);\n', '            toPayable(registrar.owner()).transfer(claim.paid);\n', '        } else if(claim.status == Status.DECLINED) {\n', '            toPayable(claim.claimant).transfer(claim.paid);\n', '        } else {\n', '            // It should not be possible to get to FINAL with claim IDs that are\n', '            // not either APPROVED or DECLINED.\n', '            assert(false);\n', '        }\n', '\n', '        unresolvedClaims--;\n', '        delete claims[claimId];\n', '    }\n', '\n', '    /**\n', '     * @dev Resolves multiple claims. Callable by anyone, only in the final phase.\n', '     * @param claimIds A list of claim IDs to resolve.\n', '     */\n', '    function resolveClaims(bytes32[] calldata claimIds) external {\n', '        for(uint i = 0; i < claimIds.length; i++) {\n', '            resolveClaim(claimIds[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws a claim and refunds the claimant.\n', '     *      Callable only by the claimant, at any time.\n', '     * @param claimId The ID of the claim to withdraw.\n', '     */\n', '    function withdrawClaim(bytes32 claimId) external {\n', '        Claim memory claim = claims[claimId];\n', '\n', '        // Only callable by claimant\n', '        require(msg.sender == claim.claimant);\n', '\n', '        if(claim.status == Status.PENDING) {\n', '            pendingClaims--;\n', '        } else {\n', '            unresolvedClaims--;\n', '        }\n', '\n', '        toPayable(claim.claimant).transfer(claim.paid);\n', '        emit ClaimStatusChanged(claimId, Status.WITHDRAWN);\n', '        delete claims[claimId];\n', '    }\n', '\n', '    function handleClaim(string memory claimed, bytes memory name, address claimant, string memory email) internal inPhase(Phase.OPEN) {\n', '        uint len = claimed.strlen();\n', '        require(len >= 3 && len <= 6);\n', '\n', '        bytes32 claimId = computeClaimId(claimed, name, claimant, email);\n', '        require(claims[claimId].paid == 0, "Claim already submitted");\n', '\n', '        // Require that there are at most two labels (name.tld)\n', '        require(bytes(getLabel(name, 2)).length == 0, "Name must be a 2LD");\n', '\n', '        uint price = getClaimCost(claimed);\n', '        require(msg.value >= price, "Insufficient funds for reservation");\n', '        if(msg.value > price) {\n', '            msg.sender.transfer(msg.value - price);\n', '        }\n', '\n', '        claims[claimId] = Claim(keccak256(bytes(claimed)), claimant, price, Status.PENDING);\n', '        pendingClaims++;\n', '        emit ClaimSubmitted(claimed, name, price, claimant, email);\n', '    }\n', '\n', '    function getLabel(bytes memory name, uint idx) internal pure returns(string memory) {\n', '        // Skip the first `idx` labels\n', '        uint offset = 0;\n', '        for(uint i = 0; i < idx; i++) {\n', '            if(offset >= name.length) return "";\n', '            offset += name.readUint8(offset) + 1;\n', '        }\n', '\n', '        // Read the label we care about\n', "        if(offset >= name.length) return '';\n", '        uint len = name.readUint8(offset);\n', '        return string(name.substring(offset + 1, len));\n', '    }\n', '\n', '    function toPayable(address addr) internal pure returns(address payable) {\n', '        return address(uint160(addr));\n', '    }\n', '}']
