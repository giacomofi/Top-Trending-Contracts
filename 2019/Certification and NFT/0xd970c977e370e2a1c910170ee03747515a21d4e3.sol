['// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IWhitelistable.sol\n', '\n', 'pragma solidity 0.5.4;\n', '\n', '\n', 'interface IWhitelistable {\n', '    event Whitelisted(address account);\n', '    event Unwhitelisted(address account);\n', '\n', '    function isWhitelisted(address account) external returns (bool);\n', '    function whitelist(address account) external;\n', '    function unwhitelist(address account) external;\n', '    function isModerator(address account) external view returns (bool);\n', '    function renounceModerator() external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/roles/ModeratorRole.sol\n', '\n', 'pragma solidity 0.5.4;\n', '\n', '\n', '\n', '// @notice Moderators are able to modify whitelists and transfer permissions in Moderator contracts.\n', 'contract ModeratorRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event ModeratorAdded(address indexed account);\n', '    event ModeratorRemoved(address indexed account);\n', '\n', '    Roles.Role internal _moderators;\n', '\n', '    modifier onlyModerator() {\n', '        require(isModerator(msg.sender), "Only Moderators can execute this function.");\n', '        _;\n', '    }\n', '\n', '    constructor() internal {\n', '        _addModerator(msg.sender);\n', '    }\n', '\n', '    function isModerator(address account) public view returns (bool) {\n', '        return _moderators.has(account);\n', '    }\n', '\n', '    function addModerator(address account) public onlyModerator {\n', '        _addModerator(account);\n', '    }\n', '\n', '    function renounceModerator() public {\n', '        _removeModerator(msg.sender);\n', '    }    \n', '\n', '    function _addModerator(address account) internal {\n', '        _moderators.add(account);\n', '        emit ModeratorAdded(account);\n', '    }    \n', '\n', '    function _removeModerator(address account) internal {\n', '        _moderators.remove(account);\n', '        emit ModeratorRemoved(account);\n', '    }\n', '}\n', '\n', '// File: contracts/rewards/BatchWhitelister.sol\n', '\n', 'pragma solidity 0.5.4;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @notice Enables batching transactions for Rewards whitelisting\n', ' */\n', 'contract BatchWhitelister is ModeratorRole, Ownable {\n', '  event BatchWhitelisted(address indexed from, uint accounts);\n', '  event BatchUnwhitelisted(address indexed from, uint accounts);\n', '\n', '  IWhitelistable public rewards; // The contract which implements IWhitelistable\n', '\n', '  constructor(IWhitelistable _contract) public {\n', '      rewards = _contract;\n', '  }\n', '\n', '  function batchWhitelist(address[] memory accounts) public onlyModerator {\n', '    bool isModerator = rewards.isModerator(address(this));\n', "    require(isModerator, 'This contract is not a moderator.');\n", '\n', '    emit BatchWhitelisted(msg.sender, accounts.length);\n', '    for (uint i = 0; i < accounts.length; i++) {\n', '      rewards.whitelist(accounts[i]);\n', '    }\n', '  }\n', '\n', '  function batchUnwhitelist(address[] memory accounts) public onlyModerator {\n', '    bool isModerator = rewards.isModerator(address(this));\n', "    require(isModerator, 'This contract is not a moderator.');\n", '\n', '    emit BatchUnwhitelisted(msg.sender, accounts.length);\n', '    for (uint i = 0; i < accounts.length; i++) {\n', '      rewards.unwhitelist(accounts[i]);\n', '    }\n', '  }\n', '\n', '  function disconnect() public onlyOwner {\n', '    rewards.renounceModerator();\n', '  }\n', '}']