['// This is the Alethena Share Dispenser. \n', '// To learn more, visit https://dispenser.alethena.com\n', '// Or contact us at contact@alethena.com\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'contract PauserRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    constructor () internal {\n', '        _addPauser(msg.sender);\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(msg.sender);\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @return true if the contract is paused, false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/ShareDispenser.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Alethena Share Dispenser\n', ' * @author Benjamin Rickenbacher, benjamin@alethena.com\n', ' * @dev This contract uses the open-zeppelin library.\n', ' *\n', ' * This smart contract is intended to serve as a tool that companies can use to provide liquidity in the context of \n', ' * shares not traded on an exchange. This concrete instance is used to by Alethena for the tokenised shares of the \n', ' * underlying Equility AG (https://etherscan.io/token/0xf40c5e190a608b6f8c0bf2b38c9506b327941402).\n', ' *\n', ' * The currency used for payment is the Crypto Franc XCHF (https://www.swisscryptotokens.ch/) which makes it possible\n', ' * to quote share prices directly in Swiss Francs.\n', ' *\n', ' * A company can allocate a certain number of shares (and optionally also some XCHF) to the share dispenser \n', ' * and defines a linear price dependency.\n', ' **/\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool success);\n', '    function totalShares() external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '}\n', '\n', 'contract ShareDispenser is Ownable, Pausable {\n', '    constructor(\n', '        address initialXCHFContractAddress, \n', '        address initialALEQContractAddress, \n', '        address initialusageFeeAddress\n', '        ) public {\n', '            \n', '        require(initialXCHFContractAddress != address(0), "XCHF does not reside at address 0!");\n', '        require(initialALEQContractAddress != address(0), "ALEQ does not reside at address 0!");\n', '        require(initialusageFeeAddress != address(0), "Usage fee address cannot be 0!");\n', '\n', '        XCHFContractAddress = initialXCHFContractAddress;\n', '        ALEQContractAddress = initialALEQContractAddress;\n', '        usageFeeAddress = initialusageFeeAddress;\n', '    }\n', '\n', '    /* \n', '     * Fallback function to prevent accidentally sending Ether to the contract\n', '     * It is still possible to force Ether into the contract as this cannot be prevented fully.\n', '     * Sending Ether to this contract does not create any problems for the contract, but the Ether will be lost.\n', '    */ \n', '\n', '    function () external payable {\n', '        revert("This contract does not accept Ether."); \n', '    }   \n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Variables\n', '\n', '    address public XCHFContractAddress;     // Address where XCHF is deployed\n', '    address public ALEQContractAddress;     // Address where ALEQ is deployed\n', '    address public usageFeeAddress;         // Address where usage fee is collected\n', '\n', '    // Buy and sell always refer to the end-user view.\n', '    // 10000 basis points = 100%\n', '\n', '    uint256 public usageFeeBSP  = 0;       // In basis points. 0 = no usage fee\n', '    uint256 public minVolume = 20;          // Minimum number of shares to buy/sell\n', '\n', '    uint256 public minPriceInXCHF = 6*10**18;\n', '    uint256 public maxPriceInXCHF = 65*10**17;\n', '    uint256 public initialNumberOfShares = 2000;\n', '\n', '    bool public buyEnabled = true;\n', '    bool public sellEnabled = false;\n', '\n', '    // Events \n', '\n', '    event XCHFContractAddressSet(address newXCHFContractAddress);\n', '    event ALEQContractAddressSet(address newALEQContractAddress);\n', '    event UsageFeeAddressSet(address newUsageFeeAddress);\n', '\n', '    event SharesPurchased(address indexed buyer, uint256 amount, uint256 totalPrice, uint256 nextPrice);\n', '    event SharesSold(address indexed seller, uint256 amount, uint256 buyBackPrice, uint256 nextPrice);\n', '    \n', '    event TokensRetrieved(address contractAddress, address indexed to, uint256 amount);\n', '\n', '    event UsageFeeSet(uint256 usageFee);\n', '    event MinVolumeSet(uint256 minVolume);\n', '    event MinPriceSet(uint256 minPrice);\n', '    event MaxPriceSet(uint256 maxPrice);\n', '    event InitialNumberOfSharesSet(uint256 initialNumberOfShares);\n', '\n', '    event BuyStatusChanged(bool newStatus);\n', '    event SellStatusChanged(bool newStatus);\n', '    \n', '\n', '    // Function for buying shares\n', '\n', '    function buyShares(uint256 numberOfSharesToBuy) public whenNotPaused() returns (bool) {\n', '\n', '        // Check that buying is enabled\n', '        require(buyEnabled, "Buying is currenty disabled");\n', '        require(numberOfSharesToBuy >= minVolume, "Volume too low");\n', '\n', '        // Fetch the total price\n', '        address buyer = msg.sender;\n', '        uint256 sharesAvailable = getERC20Balance(ALEQContractAddress);\n', '        uint256 totalPrice = getCumulatedPrice(numberOfSharesToBuy, sharesAvailable);\n', '\n', '        // Check that there are enough shares\n', '        require(sharesAvailable >= numberOfSharesToBuy, "Not enough shares available");\n', '\n', '        //Check that XCHF balance is sufficient and allowance is set\n', '        require(getERC20Available(XCHFContractAddress, buyer) >= totalPrice, "Payment not authorized or funds insufficient");\n', '\n', '        // Compute usage fee and final payment amount\n', '        uint256 usageFee = totalPrice.mul(usageFeeBSP).div(10000);\n', '        uint256 paymentAmount = totalPrice.sub(usageFee);\n', '\n', '        // Instantiate contracts\n', '        ERC20 ALEQ = ERC20(ALEQContractAddress);\n', '        ERC20 XCHF = ERC20(XCHFContractAddress);\n', '\n', '        // Transfer usage fee and payment amount\n', '        require(XCHF.transferFrom(buyer, usageFeeAddress, usageFee), "Usage fee transfer failed");\n', '        require(XCHF.transferFrom(buyer, address(this), paymentAmount), "XCHF payment failed");\n', '\n', '        // Transfer the shares\n', '        require(ALEQ.transfer(buyer, numberOfSharesToBuy), "Share transfer failed");\n', '        uint256 nextPrice = getCumulatedPrice(1, sharesAvailable.sub(numberOfSharesToBuy));\n', '        emit SharesPurchased(buyer, numberOfSharesToBuy, totalPrice, nextPrice);\n', '        return true;\n', '    }\n', '\n', '    // Function for selling shares\n', '\n', '    function sellShares(uint256 numberOfSharesToSell, uint256 limitInXCHF) public whenNotPaused() returns (bool) {\n', '\n', '        // Check that selling is enabled\n', '        require(sellEnabled, "Selling is currenty disabled");\n', '        require(numberOfSharesToSell >= minVolume, "Volume too low");\n', '\n', '        // Fetch buyback price\n', '        address seller = msg.sender;\n', '        uint256 XCHFAvailable = getERC20Balance(XCHFContractAddress);\n', '        uint256 sharesAvailable = getERC20Balance(ALEQContractAddress);\n', '\n', '        uint256 buyBackPrice = getCumulatedBuyBackPrice(numberOfSharesToSell, sharesAvailable);\n', '        require(limitInXCHF <= buyBackPrice, "Price too low");\n', '\n', '        // Check that XCHF reserve is sufficient\n', '        require(XCHFAvailable >= buyBackPrice, "Reserves to small to buy back this amount of shares");\n', '\n', '        // Check that seller has sufficient shares and allowance is set\n', '        require(getERC20Available(ALEQContractAddress, seller) >= numberOfSharesToSell, "Seller doesn\'t have enough shares");\n', '\n', '        // Compute usage fee and final payment amount\n', '        uint256 usageFee = buyBackPrice.mul(usageFeeBSP).div(10000);\n', '        uint256 paymentAmount = buyBackPrice.sub(usageFee);\n', '\n', '        // Instantiate contracts\n', '        ERC20 ALEQ = ERC20(ALEQContractAddress);\n', '        ERC20 XCHF = ERC20(XCHFContractAddress);\n', '\n', '        // Transfer the shares\n', '        require(ALEQ.transferFrom(seller, address(this), numberOfSharesToSell), "Share transfer failed");\n', '\n', '        // Transfer usage fee and payment amount\n', '        require(XCHF.transfer(usageFeeAddress, usageFee), "Usage fee transfer failed");\n', '        require(XCHF.transfer(seller, paymentAmount), "XCHF payment failed");\n', '        uint256 nextPrice = getCumulatedBuyBackPrice(1, sharesAvailable.add(numberOfSharesToSell));\n', '        emit SharesSold(seller, numberOfSharesToSell, buyBackPrice, nextPrice);\n', '        return true;\n', '    }\n', '\n', '    // Getters for ERC20 balances (for convenience)\n', '\n', '    function getERC20Balance(address contractAddress) public view returns (uint256) {\n', '        ERC20 contractInstance = ERC20(contractAddress);\n', '        return contractInstance.balanceOf(address(this));\n', '    }\n', '\n', '    function getERC20Available(address contractAddress, address owner) public view returns (uint256) {\n', '        ERC20 contractInstance = ERC20(contractAddress);\n', '        uint256 allowed = contractInstance.allowance(owner, address(this));\n', '        uint256 bal = contractInstance.balanceOf(owner);\n', '        return (allowed <= bal) ? allowed : bal;\n', '    }\n', '\n', '    // Price getters\n', '\n', '    function getCumulatedPrice(uint256 amount, uint256 supply) public view returns (uint256){\n', '        uint256 cumulatedPrice = 0;\n', '        if (supply <= initialNumberOfShares) {\n', '            uint256 first = initialNumberOfShares.add(1).sub(supply);\n', '            uint256 last = first.add(amount).sub(1);\n', '            cumulatedPrice = helper(first, last);\n', '        }\n', '\n', '        else if (supply.sub(amount) >= initialNumberOfShares) {\n', '            cumulatedPrice = minPriceInXCHF.mul(amount);\n', '        }\n', '\n', '        else {\n', '            cumulatedPrice = supply.sub(initialNumberOfShares).mul(minPriceInXCHF);\n', '            uint256 first = 1;\n', '            uint256 last = amount.sub(supply.sub(initialNumberOfShares));\n', '            cumulatedPrice = cumulatedPrice.add(helper(first,last));\n', '        }\n', '        \n', '        return cumulatedPrice;\n', '    }\n', '\n', '    function getCumulatedBuyBackPrice(uint256 amount, uint256 supply) public view returns (uint256){\n', '        return getCumulatedPrice(amount, supply.add(amount)); // For symmetry reasons\n', '    }\n', '\n', '    // Function to retrieve ALEQ or XCHF from contract\n', '    // This can also be used to retrieve any other ERC-20 token sent to the smart contract by accident\n', '\n', '    function retrieveERC20(address contractAddress, address to, uint256 amount) public onlyOwner() returns(bool) {\n', '        ERC20 contractInstance = ERC20(contractAddress);\n', '        require(contractInstance.transfer(to, amount), "Transfer failed");\n', '        emit TokensRetrieved(contractAddress, to, amount);\n', '        return true;\n', '    }\n', '\n', '    // Setters for addresses\n', '\n', '    function setXCHFContractAddress(address newXCHFContractAddress) public onlyOwner() {\n', '        require(newXCHFContractAddress != address(0), "XCHF does not reside at address 0");\n', '        XCHFContractAddress = newXCHFContractAddress;\n', '        emit XCHFContractAddressSet(XCHFContractAddress);\n', '    }\n', '\n', '    function setALEQContractAddress(address newALEQContractAddress) public onlyOwner() {\n', '        require(newALEQContractAddress != address(0), "ALEQ does not reside at address 0");\n', '        ALEQContractAddress = newALEQContractAddress;\n', '        emit ALEQContractAddressSet(ALEQContractAddress);\n', '    }\n', '\n', '    function setUsageFeeAddress(address newUsageFeeAddress) public onlyOwner() {\n', '        require(newUsageFeeAddress != address(0), "ALEQ does not reside at address 0");\n', '        usageFeeAddress = newUsageFeeAddress;\n', '        emit UsageFeeAddressSet(usageFeeAddress);\n', '    }\n', '\n', '    // Setters for constants\n', '    \n', '    function setUsageFee(uint256 newUsageFeeInBSP) public onlyOwner() {\n', '        require(newUsageFeeInBSP <= 10000, "Usage fee must be given in basis points");\n', '        usageFeeBSP = newUsageFeeInBSP;\n', '        emit UsageFeeSet(usageFeeBSP);\n', '    }\n', '\n', '    function setMinVolume(uint256 newMinVolume) public onlyOwner() {\n', '        require(newMinVolume > 0, "Minimum volume can\'t be zero");\n', '        minVolume = newMinVolume;\n', '        emit MinVolumeSet(minVolume);\n', '    }\n', '\n', '    function setminPriceInXCHF(uint256 newMinPriceInRappen) public onlyOwner() {\n', '        require(newMinPriceInRappen > 0, "Price must be positive number");\n', '        minPriceInXCHF = newMinPriceInRappen.mul(10**16);\n', '        require(minPriceInXCHF <= maxPriceInXCHF, "Minimum price cannot exceed maximum price");\n', '        emit MinPriceSet(minPriceInXCHF);\n', '    }\n', '\n', '    function setmaxPriceInXCHF(uint256 newMaxPriceInRappen) public onlyOwner() {\n', '        require(newMaxPriceInRappen > 0, "Price must be positive number");\n', '        maxPriceInXCHF = newMaxPriceInRappen.mul(10**16);\n', '        require(minPriceInXCHF <= maxPriceInXCHF, "Minimum price cannot exceed maximum price");\n', '        emit MaxPriceSet(maxPriceInXCHF);\n', '    }\n', '\n', '    function setInitialNumberOfShares(uint256 newInitialNumberOfShares) public onlyOwner() {\n', '        require(newInitialNumberOfShares > 0, "Initial number of shares must be positive");\n', '        initialNumberOfShares = newInitialNumberOfShares;\n', '        emit InitialNumberOfSharesSet(initialNumberOfShares);\n', '    }\n', '\n', '    // Enable buy and sell separately\n', '\n', '    function buyStatus(bool newStatus) public onlyOwner() {\n', '        buyEnabled = newStatus;\n', '        emit BuyStatusChanged(newStatus);\n', '    }\n', '\n', '    function sellStatus(bool newStatus) public onlyOwner() {\n', '        sellEnabled = newStatus;\n', '        emit SellStatusChanged(newStatus);\n', '    }\n', '\n', '    // Helper functions\n', '\n', '    function helper(uint256 first, uint256 last) internal view returns (uint256) {\n', '        uint256 tempa = last.sub(first).add(1).mul(minPriceInXCHF);                                   // (l-m+1)*p_min\n', '        uint256 tempb = maxPriceInXCHF.sub(minPriceInXCHF).div(initialNumberOfShares.sub(1)).div(2);  // (p_max-p_min)/(2(N-1))\n', '        uint256 tempc = last.mul(last).add(first.mul(3)).sub(last).sub(first.mul(first)).sub(2);      // l*l+3*m-l-m*m-2)\n', '        return tempb.mul(tempc).add(tempa);\n', '    }\n', '\n', '}']