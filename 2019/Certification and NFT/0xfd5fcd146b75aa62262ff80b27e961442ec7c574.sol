['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '// Safe math\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '    \n', '     //not a SafeMath function\n', '    function max(uint a, uint b) private pure returns (uint) {\n', '        return a > b ? a : b;\n', '    }\n', '    \n', '}\n', '\n', '\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// Owned contract\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/// @title  Version 0.1 of the InchWorm Contract, which allows INCH tokens to be traded for Dai and Ether at an adjustable peg. \n', '/// @author Fakuterin\n', '/// @notice In order to use, permission must be given to the Dai token contract and the InchWorm token contract.\n', '///         Call the "allow" function on each, passing this address and the number of tokens to allow as parameters.\n', '///         Use the 4 withdrawel and deposit functions in your this contract to buy and sell INCH for Ether and Dai\n', '///         Because there is no UI for this contract, KEEP IN MIND THAT ALL VALUES ARE IN MINIMUM DENOMINATIONS\n', '///         IN OTHER WORDS ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AND INPUT AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '///         Other warnings: This is a test contract. Do not risk any significant value. You are not guaranteed a \n', '///         refund, even if it&#39;s my fault. Do not send any tokens or assets directly to the contract. \n', '///         DO NOT SEND ANY TOKENS OR ASSETS DIRECTLY TO THE CONTRACT. Use only the withdrawel and deposit functions\n', '/// @dev    Addresses and &#39;deployership&#39; should be initialized before use. INCH must be deposited in contract\n', '///         Ownership should be set to 0x0 after initialization\n', 'contract InchWormVaultLiveTest is Owned {\n', '    using SafeMath for uint;\n', '\n', '\n', '    event SellInchForWei(uint inch, uint _wei);\n', '    event SellInchForDai(uint inch, uint dai);\n', '    event BuyInchWithWei(uint inch, uint _wei);\n', '    event BuyInchWithDai(uint inch, uint dai);\n', '    event PremiumIncreased(uint inchSold, uint premiumIncrease);\n', '\n', '    // The premium controls both the INCH/Dai price and the INCH/ETH price. It increases as fees are paid. If 1 dai \n', '    // worth of fees are paid  and there are 10 circulating tokens, the premium will increase by 100,000,\n', '    // or 10% of the base premium. The premium may decrease as the peg changes over time\n', '    uint public premium = 1000000; \n', '    \n', '    // Used for internal calculations. Represents the initial value of premium\n', '    uint internal constant premiumDigits = 1000000;\n', '    \n', '    // The etherPeg controls the Dai/ETH price. There is no way to exchange Dai and ETH directly, so the peg actually changes the rate of \n', '    // INCH/Dai and INCH/ETH simultaneously. The peg can be increased or decreased by increments of 2%, given certain global conditions\n', '    uint public etherPeg = 300;\n', '    \n', '    // Used for internal mathematics, represents fee rate. Fees = (10,000 - conserveRate)/100\n', '    uint internal constant conserveRate = 9700; //out of 10,000\n', '    uint internal constant conserveRateDigits = 10000;\n', '    \n', '    // Defines the minimum time to wait in between Dai/Ether peg adjustments\n', '    uint public pegMoveCooldown = 12 hours; \n', '    // Represents the next unix time that a call can be made to the increase and decrease peg functions\n', '    uint public pegMoveReadyTime;\n', '    \n', '    ERC20Interface inchWormContract; // must be initialized to the ERC20 InchWorm Contract\n', '    ERC20Interface daiContract; // must be initialized to the ERC20 Dai Contract (check on compatitbility with MCD)\n', '    \n', '    // Retains ability to transfer mistaken ERC20s after ownership is revoked. Recieves portion of fees. In future versions\n', '    // these fees will be distributed to holders of the "Ownership Token", and not to the deployer.\n', '    address payable deployer; \n', '    \n', '    \n', '    // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '    \n', '    /// @param  _inchFeesPaid: the amount of INCH sent to this contract, which adjusts the premium using the same logic as used in withdrawal \n', '    ///         methods below.\n', '    /// @notice This method allows other contracts to buy into the InchWorm System. They can pay INCH in order to adjust the \n', '    ///         premium, allowing them to create vaults which can hold ERC20 assets instead of Ether.\n', '    function increasePremium(uint _inchFeesPaid) external {\n', '        //need to get permissions for this. AddOnVault needs to approve vault address for payments\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchFeesPaid);\n', '        \n', '        uint _premiumIncrease = _inchFeesPaid.mul(premium).div((inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this)))));\n', '        premium = premium.add(_premiumIncrease);\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*______________________________Inititialization Functions____________________________*/\n', '    \n', '    /// @param  _inchwormAddress: deployment address of the InchWorm contract\n', '    /// @param  _daiAddress: deployment address of the ERC20 Dai token contract\n', '    /// @param  _deployer: address of initial deployer. Receives fees and can transfer unrelated ERC20s\n', '    /// @notice Sets the address for the INCH and Dai tokens, as well as the deployer\n', '    ///         Sets the pegMoveReadyTime to now, allowing the peg to be moved immediately (if balances are correct)\n', '    function initialize(address _inchwormAddress, address _daiAddress, address payable _deployer) external onlyOwner {\n', '        inchWormContract = ERC20Interface(_inchwormAddress);\n', '        daiContract = ERC20Interface(_daiAddress);\n', '        deployer = _deployer;\n', '        pegMoveReadyTime = now;\n', '    }\n', '    \n', '\n', '    /*^__^__^__^__^__^__^__^__^__^__Inititialization Functions__^__^__^__^__^__^__^__^__^ */\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*_________________________________Peg Functions______________________________________*/\n', '    \n', '    /// @notice A public call to increase the peg by 4%. Can only be called once every 12 hours, and only if\n', '    ///         there is there is <= 2% as much Ether value in the contract as there is Dai value.\n', '    ///         Example: with a peg of 100, and 10000 total Dai in the vault, the ether balance of the\n', '    ///         vault must be less than or equal to 2 to execute this function.\n', '    function increasePeg() external {\n', '        // check that the total value of eth in contract is <= 2% the total value of dai in the contract\n', '        require (address(this).balance.mul(etherPeg) <= daiContract.balanceOf(address(this)).div(50)); \n', '        // check that peg hasn&#39;t been changed in last 12 hours\n', '        require (now > pegMoveReadyTime);\n', '        // increase peg\n', '        etherPeg = etherPeg.mul(104).div(100);\n', '        // reset cooldown\n', '        pegMoveReadyTime = now+pegMoveCooldown;\n', '    }\n', '    \n', '    /// @notice A public call to decrease the peg by 4%. Can only be called once every 12 hours, and only if\n', '    ///         there is there is < 2% as much Dai value in the contract as there is Ether value.\n', '    ///         Example: with a peg of 100, and 100 total Ether in the vault, the dai balance of the\n', '    ///         vault must be less than or equal to 200 to execute this function. \n', '    function decreasePeg() external {\n', '         // check that the total value of eth in contract is <= 2% the total value of dai in the contract\n', '        require (daiContract.balanceOf(address(this)) <= address(this).balance.mul(etherPeg).div(50));\n', '        // check that peg hasn&#39;t been changed in last 12 hours\n', '        require (now > pegMoveReadyTime);\n', '        // increase peg\n', '        etherPeg = etherPeg.mul(96).div(100);\n', '        // reset cooldown\n', '        pegMoveReadyTime = now+pegMoveCooldown;\n', '        \n', '        premium = premium.mul(96).div(100);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__^__^__^__^__Peg Functions__^__^__^__^__^__^__^__^__^__^__^ */\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*__________________________Deposit and Withdrawel Functions_________________________ */\n', '    // All functions begin with __ in order to help with organization. Will be changed after UI is developed\n', '\n', '    /// @notice All units are minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable function to buy INCH from the contract with Wei. Rates are based on premium\n', '    ///         and etherPeg. For every Wei deposited, msg.sender recieves etherPeg/(0.000001*premium) INCH.\n', '    ///         Example: If the peg is 100, and the premium is 2000000, msg.sender will recieve 50 INCH.\n', '    /// @dev    Transaction reverts if payment results in 0 INCH returned\n', '    function __buyInchWithWei() external payable {\n', '        // Calculate the amount of inch give to msg.sender\n', '        uint _inchToBuy = msg.value.mul(etherPeg).mul(premiumDigits).div(premium);\n', '        // Require that INCH returned is not 0\n', '        require(_inchToBuy > 0);\n', '        // Transfer INCH to Purchaser\n', '        inchWormContract.transfer(msg.sender, _inchToBuy);\n', '        \n', '        emit BuyInchWithWei(_inchToBuy, msg.value);\n', '    }\n', '    \n', '    /// @param  _inchToBuy: amount of INCH (in mininum denomination) msg.sender wishes to purchase\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to buy INCH from the contract using Dai. Rates are based on premium.\n', '    ///         For every Dai deposited, msg.sender recieves 1/(0.000001*premium) INCH.\n', '    ///         Example: If the premium is 5000000, calling the function with input 1 will result in \n', '    ///         msg.sender paying 5 DaiSats. \n', '    function __buyInchWithDai(uint _inchToBuy) external {\n', '        // Calculate the amount of Dai to extract from the purchaser&#39;s wallet based on the premium\n', '        uint _daiOwed = _inchToBuy.mul(premium).div(premiumDigits);\n', '        // Take Dai from the purchaser and transfer to vault contract\n', '        daiContract.transferFrom(msg.sender, address(this), _daiOwed);\n', '        // Send INCH to purchaser\n', '        inchWormContract.transfer(msg.sender, _inchToBuy);\n', '        \n', '        emit BuyInchWithDai(_inchToBuy, _daiOwed);\n', '    }\n', '    \n', '    \n', '    /// @param  _inchToSell: amount of INCH (in mininum denomination) msg.sender wishes to sell to the vault contract\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to sell INCH to the contract and withdraw Wei. Rates are based on premium and etherPeg.\n', '    ///         Fees are paid automatically and increase the premium for remaining tokens. Fee is currently 3%\n', '    ///         For every Inch sold, msg.sender recieves (0.97 * 0.000001*premium) / (etherPeg)   Ether.\n', '    ///         Example: If the peg is 100, and the premium is 2000000, each unit of INCHSat sold will return 0.0194 Wei. \n', '    ///         Because fractions of a Wei are not possible, no value will be returned for miniscule sales of INCH\n', '    ///         With a peg of 100, values of less than 104 will return 0\n', '    /// @dev    Future versions may add a require (_etherToReturn >0). This should be an edge case. However, rounding \n', '    ///         will still result in negligible losses for user. This could be fixed by rounding user input down to the nearest\n', '    ///         viable withdrawal amount. \n', '    ///         Premium increases are functionally the same as distributing fees to all remaining INCH tokens\n', '    function __sellInchForEth(uint _inchToSell) external {\n', '        // Deduct fee (currenly 3%)\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        // Calculate Ether to send to user based on premium and peg\n', '        uint _etherToReturn = _trueInchToSell.mul(premium).div(premiumDigits.mul(etherPeg));\n', '       \n', '        // Send Ether to user\n', '        msg.sender.transfer(_etherToReturn);\n', '        // Deposit INCH from user into vault\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchToSell);\n', '        // Transfer 1% to deployer. In the future, this will go to holders of the "ownership Token"\n', '        uint _deployerPayment = _inchToSell.mul(100).div(10000).mul(premium).div(premiumDigits.mul(etherPeg));\n', '        deployer.transfer(_deployerPayment);\n', '        \n', '        // Increase the premium. Premium increases are based on fees. It is functionally equivalent to distributing the fee to \n', '        // remaining INCH tokens in the form of a redeemable dividend. Example: Given 1 Ether worth of fees paid and a peg of 100.\n', '        // Convert to dai value, so fees = 100 Dai. If 1000 tokens remain after the transaction, the premium must increase by an amount\n', '        // such that each INCH is worth 0.1 more Dai. If the premium was previously 1500000, then the new premium should be 1600000.\n', '        // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '        uint _premiumIncrease = _inchToSell.sub(_trueInchToSell).mul(premium).div(inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this))));\n', '        premium = premium.add(_premiumIncrease);\n', '        \n', '        emit PremiumIncreased(_inchToSell, _premiumIncrease);\n', '        emit SellInchForWei(_inchToSell, _etherToReturn);\n', '    }\n', '    \n', '    \n', '    \n', '    /// @param  _inchToSell: amount of INCH (in mininum denomination) msg.sender wishes to sell to the vault contract\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to sell INCH to the contract and withdraw Dai. Rates are based on premium.\n', '    ///         Fees are paid automatically and increase the premium for remaining tokens. Fee is currently 3%\n', '    ///         For every Inch sold, msg.sender recieves (0.97 * 0.000001*premium) Dai.\n', '    ///         Example: If the premium is 5000000, each unit of INCHSat sold will return 4.85 DaiSat. \n', '    ///         Because fee functions round down, this does not work for low values of INCHSat. For instance, a single \n', '    ///         INCHSat will return 0 DaiSats and 101 INCHSats will return 485, instead of 489.85 INCHSats\n', '    /// @dev    Rounding down for minimum denomination units will result in negligible losses for user. \n', '    ///         Premium increases are functionally the same as distributing fees to all remaining INCH tokens\n', '    function __sellInchForDai(uint _inchToSell) external {\n', '        // Deduct fee (currenly 3%). Rounds down to nearest INCH. Input of 1 will return 0. Input of 3 will return 2\n', '        // Input of 101 will return 97\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        // Calculate Dai to send to user based on premium\n', '        uint _daiToReturn = _trueInchToSell.mul(premium).div(premiumDigits);\n', '        \n', '        // Send Dai to user\n', '        daiContract.transfer(msg.sender, _daiToReturn);\n', '        // Deposit INCH from user into vault\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchToSell);\n', '        // Transfer 1% to deployer. In the future, this will go to holders of the "ownership Token"\n', '        uint _deployerPayment = _inchToSell.mul(100).div(10000).mul(premium).div(premiumDigits);\n', '        daiContract.transfer(deployer, _deployerPayment);\n', '        \n', '        // Increase the premium. Premium increases are based on fees. It is functionally equivalent to distributing the fee to \n', '        // remaining INCH tokens in the form of a redeemable dividend. Example: Given 100 Dai worth of fees paid  and 5000 tokens\n', '        // remaining after the transaction, the premium must increase by an amount such that each INCH is worth 0.02 more Dai.\n', '        // If the premium was previously 2000000, then the new premium should be 2020000.\n', '        // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '        uint _premiumIncrease = _inchToSell.sub(_trueInchToSell).mul(premium).div(inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this))));\n', '        premium = premium.add(_premiumIncrease);\n', '        \n', '        emit PremiumIncreased(_inchToSell, _premiumIncrease);\n', '        emit SellInchForDai(_inchToSell, _daiToReturn);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__Deposit and Withdrawel Functions__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*___________________________________View Functions___________________________________*/\n', '    \n', '\n', '    /// @return The current premium, which is initially 1,000,000\n', '    /// @notice The premium changes the rate at which INCH is exchanged for Dai and Ether\n', '    function getPremium() external view returns(uint){\n', '        return premium;\n', '    } \n', '    \n', '    /// @return The percentage fee that is paid when withdrawing Ether or Dai\n', '    function getFeePercent() external pure returns(uint) {\n', '        return (conserveRateDigits - conserveRate)/100;    \n', '    }\n', '    \n', '    function canPegBeIncreased() external view returns(bool) {\n', '        return (address(this).balance.mul(etherPeg) <= daiContract.balanceOf(address(this)).div(50) && (now > pegMoveReadyTime)); \n', '    }\n', '    \n', '    /// @return true if a call can be made to decrease peg\n', '    function canPegBeDecreased() external view returns(bool) {\n', '        return (daiContract.balanceOf(address(this)) <= address(this).balance.mul(etherPeg).div(50) && (now > pegMoveReadyTime));\n', '    }\n', '    \n', '    /// @return true if a call can be made to increase peg\n', '    function vzgetCirculatingSupply() public view returns(uint) {\n', '        return inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this)));\n', '    }\n', '    \n', '    \n', '    /// @return The amount of ETH you will get after selling X INCH\n', '    function afterFeeEthReturns(uint _inchToSell) public view returns(uint) {\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        return _trueInchToSell.mul(premium).div(premiumDigits.mul(etherPeg));\n', '    }\n', '    \n', '    /// @return The amount of ETH you will get after selling X INCH\n', '    function afterFeeDaiReturns(uint _inchToSell) public view returns(uint) {\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        return _trueInchToSell.mul(premium).div(premiumDigits);\n', '    }\n', '    \n', '    /// @return The Wei balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getEthBalance() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /// @return The INCH balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getInchBalance() public view returns(uint) {\n', '        return inchWormContract.balanceOf(address(this));\n', '    }\n', '    \n', '    /// @return The Dai balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getDaiBalance() public view returns(uint) {\n', '        return daiContract.balanceOf(address(this));\n', '    }\n', '    \n', '    /// @param _a: the address to check balance of\n', '    /// @return INCH balance of target address\n', '    /// @notice This is just the balanceOf function from inchWormContract. Put here for ease of access\n', '    function getOwnerInch(address _a) public view returns(uint) {\n', '        return inchWormContract.balanceOf(_a);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__^__^__^__View Functions__^__^__^__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '\n', '\n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*__________________________Emergency and Fallback Functions__________________________*/\n', '    \n', '    /// @notice Original deployer can transfer out tokens other than Dai and INCH\n', '    /// @dev    This function can be used to steal funds if there is any way to alter the inchWormContract address or daiContract address\n', '    function transferAccidentalERC20Tokens(address tokenAddress, uint tokens) external returns (bool success) {\n', '        require(msg.sender == deployer);\n', '        require(tokenAddress != address(inchWormContract));\n', '        require(tokenAddress != address(daiContract));\n', '        \n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    // fallback function\n', '    function () external payable {\n', '        revert();\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__emergency and fallback functions__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '    \n', '}']
['pragma solidity ^0.5.0;\n', '\n', '\n', '// Safe math\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '    \n', '     //not a SafeMath function\n', '    function max(uint a, uint b) private pure returns (uint) {\n', '        return a > b ? a : b;\n', '    }\n', '    \n', '}\n', '\n', '\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// Owned contract\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/// @title  Version 0.1 of the InchWorm Contract, which allows INCH tokens to be traded for Dai and Ether at an adjustable peg. \n', '/// @author Fakuterin\n', '/// @notice In order to use, permission must be given to the Dai token contract and the InchWorm token contract.\n', '///         Call the "allow" function on each, passing this address and the number of tokens to allow as parameters.\n', '///         Use the 4 withdrawel and deposit functions in your this contract to buy and sell INCH for Ether and Dai\n', '///         Because there is no UI for this contract, KEEP IN MIND THAT ALL VALUES ARE IN MINIMUM DENOMINATIONS\n', '///         IN OTHER WORDS ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AND INPUT AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '///         Other warnings: This is a test contract. Do not risk any significant value. You are not guaranteed a \n', "///         refund, even if it's my fault. Do not send any tokens or assets directly to the contract. \n", '///         DO NOT SEND ANY TOKENS OR ASSETS DIRECTLY TO THE CONTRACT. Use only the withdrawel and deposit functions\n', "/// @dev    Addresses and 'deployership' should be initialized before use. INCH must be deposited in contract\n", '///         Ownership should be set to 0x0 after initialization\n', 'contract InchWormVaultLiveTest is Owned {\n', '    using SafeMath for uint;\n', '\n', '\n', '    event SellInchForWei(uint inch, uint _wei);\n', '    event SellInchForDai(uint inch, uint dai);\n', '    event BuyInchWithWei(uint inch, uint _wei);\n', '    event BuyInchWithDai(uint inch, uint dai);\n', '    event PremiumIncreased(uint inchSold, uint premiumIncrease);\n', '\n', '    // The premium controls both the INCH/Dai price and the INCH/ETH price. It increases as fees are paid. If 1 dai \n', '    // worth of fees are paid  and there are 10 circulating tokens, the premium will increase by 100,000,\n', '    // or 10% of the base premium. The premium may decrease as the peg changes over time\n', '    uint public premium = 1000000; \n', '    \n', '    // Used for internal calculations. Represents the initial value of premium\n', '    uint internal constant premiumDigits = 1000000;\n', '    \n', '    // The etherPeg controls the Dai/ETH price. There is no way to exchange Dai and ETH directly, so the peg actually changes the rate of \n', '    // INCH/Dai and INCH/ETH simultaneously. The peg can be increased or decreased by increments of 2%, given certain global conditions\n', '    uint public etherPeg = 300;\n', '    \n', '    // Used for internal mathematics, represents fee rate. Fees = (10,000 - conserveRate)/100\n', '    uint internal constant conserveRate = 9700; //out of 10,000\n', '    uint internal constant conserveRateDigits = 10000;\n', '    \n', '    // Defines the minimum time to wait in between Dai/Ether peg adjustments\n', '    uint public pegMoveCooldown = 12 hours; \n', '    // Represents the next unix time that a call can be made to the increase and decrease peg functions\n', '    uint public pegMoveReadyTime;\n', '    \n', '    ERC20Interface inchWormContract; // must be initialized to the ERC20 InchWorm Contract\n', '    ERC20Interface daiContract; // must be initialized to the ERC20 Dai Contract (check on compatitbility with MCD)\n', '    \n', '    // Retains ability to transfer mistaken ERC20s after ownership is revoked. Recieves portion of fees. In future versions\n', '    // these fees will be distributed to holders of the "Ownership Token", and not to the deployer.\n', '    address payable deployer; \n', '    \n', '    \n', '    // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '    \n', '    /// @param  _inchFeesPaid: the amount of INCH sent to this contract, which adjusts the premium using the same logic as used in withdrawal \n', '    ///         methods below.\n', '    /// @notice This method allows other contracts to buy into the InchWorm System. They can pay INCH in order to adjust the \n', '    ///         premium, allowing them to create vaults which can hold ERC20 assets instead of Ether.\n', '    function increasePremium(uint _inchFeesPaid) external {\n', '        //need to get permissions for this. AddOnVault needs to approve vault address for payments\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchFeesPaid);\n', '        \n', '        uint _premiumIncrease = _inchFeesPaid.mul(premium).div((inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this)))));\n', '        premium = premium.add(_premiumIncrease);\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*______________________________Inititialization Functions____________________________*/\n', '    \n', '    /// @param  _inchwormAddress: deployment address of the InchWorm contract\n', '    /// @param  _daiAddress: deployment address of the ERC20 Dai token contract\n', '    /// @param  _deployer: address of initial deployer. Receives fees and can transfer unrelated ERC20s\n', '    /// @notice Sets the address for the INCH and Dai tokens, as well as the deployer\n', '    ///         Sets the pegMoveReadyTime to now, allowing the peg to be moved immediately (if balances are correct)\n', '    function initialize(address _inchwormAddress, address _daiAddress, address payable _deployer) external onlyOwner {\n', '        inchWormContract = ERC20Interface(_inchwormAddress);\n', '        daiContract = ERC20Interface(_daiAddress);\n', '        deployer = _deployer;\n', '        pegMoveReadyTime = now;\n', '    }\n', '    \n', '\n', '    /*^__^__^__^__^__^__^__^__^__^__Inititialization Functions__^__^__^__^__^__^__^__^__^ */\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*_________________________________Peg Functions______________________________________*/\n', '    \n', '    /// @notice A public call to increase the peg by 4%. Can only be called once every 12 hours, and only if\n', '    ///         there is there is <= 2% as much Ether value in the contract as there is Dai value.\n', '    ///         Example: with a peg of 100, and 10000 total Dai in the vault, the ether balance of the\n', '    ///         vault must be less than or equal to 2 to execute this function.\n', '    function increasePeg() external {\n', '        // check that the total value of eth in contract is <= 2% the total value of dai in the contract\n', '        require (address(this).balance.mul(etherPeg) <= daiContract.balanceOf(address(this)).div(50)); \n', "        // check that peg hasn't been changed in last 12 hours\n", '        require (now > pegMoveReadyTime);\n', '        // increase peg\n', '        etherPeg = etherPeg.mul(104).div(100);\n', '        // reset cooldown\n', '        pegMoveReadyTime = now+pegMoveCooldown;\n', '    }\n', '    \n', '    /// @notice A public call to decrease the peg by 4%. Can only be called once every 12 hours, and only if\n', '    ///         there is there is < 2% as much Dai value in the contract as there is Ether value.\n', '    ///         Example: with a peg of 100, and 100 total Ether in the vault, the dai balance of the\n', '    ///         vault must be less than or equal to 200 to execute this function. \n', '    function decreasePeg() external {\n', '         // check that the total value of eth in contract is <= 2% the total value of dai in the contract\n', '        require (daiContract.balanceOf(address(this)) <= address(this).balance.mul(etherPeg).div(50));\n', "        // check that peg hasn't been changed in last 12 hours\n", '        require (now > pegMoveReadyTime);\n', '        // increase peg\n', '        etherPeg = etherPeg.mul(96).div(100);\n', '        // reset cooldown\n', '        pegMoveReadyTime = now+pegMoveCooldown;\n', '        \n', '        premium = premium.mul(96).div(100);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__^__^__^__^__Peg Functions__^__^__^__^__^__^__^__^__^__^__^ */\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*__________________________Deposit and Withdrawel Functions_________________________ */\n', '    // All functions begin with __ in order to help with organization. Will be changed after UI is developed\n', '\n', '    /// @notice All units are minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable function to buy INCH from the contract with Wei. Rates are based on premium\n', '    ///         and etherPeg. For every Wei deposited, msg.sender recieves etherPeg/(0.000001*premium) INCH.\n', '    ///         Example: If the peg is 100, and the premium is 2000000, msg.sender will recieve 50 INCH.\n', '    /// @dev    Transaction reverts if payment results in 0 INCH returned\n', '    function __buyInchWithWei() external payable {\n', '        // Calculate the amount of inch give to msg.sender\n', '        uint _inchToBuy = msg.value.mul(etherPeg).mul(premiumDigits).div(premium);\n', '        // Require that INCH returned is not 0\n', '        require(_inchToBuy > 0);\n', '        // Transfer INCH to Purchaser\n', '        inchWormContract.transfer(msg.sender, _inchToBuy);\n', '        \n', '        emit BuyInchWithWei(_inchToBuy, msg.value);\n', '    }\n', '    \n', '    /// @param  _inchToBuy: amount of INCH (in mininum denomination) msg.sender wishes to purchase\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to buy INCH from the contract using Dai. Rates are based on premium.\n', '    ///         For every Dai deposited, msg.sender recieves 1/(0.000001*premium) INCH.\n', '    ///         Example: If the premium is 5000000, calling the function with input 1 will result in \n', '    ///         msg.sender paying 5 DaiSats. \n', '    function __buyInchWithDai(uint _inchToBuy) external {\n', "        // Calculate the amount of Dai to extract from the purchaser's wallet based on the premium\n", '        uint _daiOwed = _inchToBuy.mul(premium).div(premiumDigits);\n', '        // Take Dai from the purchaser and transfer to vault contract\n', '        daiContract.transferFrom(msg.sender, address(this), _daiOwed);\n', '        // Send INCH to purchaser\n', '        inchWormContract.transfer(msg.sender, _inchToBuy);\n', '        \n', '        emit BuyInchWithDai(_inchToBuy, _daiOwed);\n', '    }\n', '    \n', '    \n', '    /// @param  _inchToSell: amount of INCH (in mininum denomination) msg.sender wishes to sell to the vault contract\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to sell INCH to the contract and withdraw Wei. Rates are based on premium and etherPeg.\n', '    ///         Fees are paid automatically and increase the premium for remaining tokens. Fee is currently 3%\n', '    ///         For every Inch sold, msg.sender recieves (0.97 * 0.000001*premium) / (etherPeg)   Ether.\n', '    ///         Example: If the peg is 100, and the premium is 2000000, each unit of INCHSat sold will return 0.0194 Wei. \n', '    ///         Because fractions of a Wei are not possible, no value will be returned for miniscule sales of INCH\n', '    ///         With a peg of 100, values of less than 104 will return 0\n', '    /// @dev    Future versions may add a require (_etherToReturn >0). This should be an edge case. However, rounding \n', '    ///         will still result in negligible losses for user. This could be fixed by rounding user input down to the nearest\n', '    ///         viable withdrawal amount. \n', '    ///         Premium increases are functionally the same as distributing fees to all remaining INCH tokens\n', '    function __sellInchForEth(uint _inchToSell) external {\n', '        // Deduct fee (currenly 3%)\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        // Calculate Ether to send to user based on premium and peg\n', '        uint _etherToReturn = _trueInchToSell.mul(premium).div(premiumDigits.mul(etherPeg));\n', '       \n', '        // Send Ether to user\n', '        msg.sender.transfer(_etherToReturn);\n', '        // Deposit INCH from user into vault\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchToSell);\n', '        // Transfer 1% to deployer. In the future, this will go to holders of the "ownership Token"\n', '        uint _deployerPayment = _inchToSell.mul(100).div(10000).mul(premium).div(premiumDigits.mul(etherPeg));\n', '        deployer.transfer(_deployerPayment);\n', '        \n', '        // Increase the premium. Premium increases are based on fees. It is functionally equivalent to distributing the fee to \n', '        // remaining INCH tokens in the form of a redeemable dividend. Example: Given 1 Ether worth of fees paid and a peg of 100.\n', '        // Convert to dai value, so fees = 100 Dai. If 1000 tokens remain after the transaction, the premium must increase by an amount\n', '        // such that each INCH is worth 0.1 more Dai. If the premium was previously 1500000, then the new premium should be 1600000.\n', '        // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '        uint _premiumIncrease = _inchToSell.sub(_trueInchToSell).mul(premium).div(inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this))));\n', '        premium = premium.add(_premiumIncrease);\n', '        \n', '        emit PremiumIncreased(_inchToSell, _premiumIncrease);\n', '        emit SellInchForWei(_inchToSell, _etherToReturn);\n', '    }\n', '    \n', '    \n', '    \n', '    /// @param  _inchToSell: amount of INCH (in mininum denomination) msg.sender wishes to sell to the vault contract\n', '    /// @notice All units are in minimum denomination, ie base unit *10**-18\n', '    ///         Use this payable to sell INCH to the contract and withdraw Dai. Rates are based on premium.\n', '    ///         Fees are paid automatically and increase the premium for remaining tokens. Fee is currently 3%\n', '    ///         For every Inch sold, msg.sender recieves (0.97 * 0.000001*premium) Dai.\n', '    ///         Example: If the premium is 5000000, each unit of INCHSat sold will return 4.85 DaiSat. \n', '    ///         Because fee functions round down, this does not work for low values of INCHSat. For instance, a single \n', '    ///         INCHSat will return 0 DaiSats and 101 INCHSats will return 485, instead of 489.85 INCHSats\n', '    /// @dev    Rounding down for minimum denomination units will result in negligible losses for user. \n', '    ///         Premium increases are functionally the same as distributing fees to all remaining INCH tokens\n', '    function __sellInchForDai(uint _inchToSell) external {\n', '        // Deduct fee (currenly 3%). Rounds down to nearest INCH. Input of 1 will return 0. Input of 3 will return 2\n', '        // Input of 101 will return 97\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        // Calculate Dai to send to user based on premium\n', '        uint _daiToReturn = _trueInchToSell.mul(premium).div(premiumDigits);\n', '        \n', '        // Send Dai to user\n', '        daiContract.transfer(msg.sender, _daiToReturn);\n', '        // Deposit INCH from user into vault\n', '        inchWormContract.transferFrom(msg.sender, address(this), _inchToSell);\n', '        // Transfer 1% to deployer. In the future, this will go to holders of the "ownership Token"\n', '        uint _deployerPayment = _inchToSell.mul(100).div(10000).mul(premium).div(premiumDigits);\n', '        daiContract.transfer(deployer, _deployerPayment);\n', '        \n', '        // Increase the premium. Premium increases are based on fees. It is functionally equivalent to distributing the fee to \n', '        // remaining INCH tokens in the form of a redeemable dividend. Example: Given 100 Dai worth of fees paid  and 5000 tokens\n', '        // remaining after the transaction, the premium must increase by an amount such that each INCH is worth 0.02 more Dai.\n', '        // If the premium was previously 2000000, then the new premium should be 2020000.\n', '        // Formula: premium += (FeeAmountInDai *1000000) / CirculatingSupplyAfterTransaction\n', '        uint _premiumIncrease = _inchToSell.sub(_trueInchToSell).mul(premium).div(inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this))));\n', '        premium = premium.add(_premiumIncrease);\n', '        \n', '        emit PremiumIncreased(_inchToSell, _premiumIncrease);\n', '        emit SellInchForDai(_inchToSell, _daiToReturn);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__Deposit and Withdrawel Functions__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '    \n', '    \n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*___________________________________View Functions___________________________________*/\n', '    \n', '\n', '    /// @return The current premium, which is initially 1,000,000\n', '    /// @notice The premium changes the rate at which INCH is exchanged for Dai and Ether\n', '    function getPremium() external view returns(uint){\n', '        return premium;\n', '    } \n', '    \n', '    /// @return The percentage fee that is paid when withdrawing Ether or Dai\n', '    function getFeePercent() external pure returns(uint) {\n', '        return (conserveRateDigits - conserveRate)/100;    \n', '    }\n', '    \n', '    function canPegBeIncreased() external view returns(bool) {\n', '        return (address(this).balance.mul(etherPeg) <= daiContract.balanceOf(address(this)).div(50) && (now > pegMoveReadyTime)); \n', '    }\n', '    \n', '    /// @return true if a call can be made to decrease peg\n', '    function canPegBeDecreased() external view returns(bool) {\n', '        return (daiContract.balanceOf(address(this)) <= address(this).balance.mul(etherPeg).div(50) && (now > pegMoveReadyTime));\n', '    }\n', '    \n', '    /// @return true if a call can be made to increase peg\n', '    function vzgetCirculatingSupply() public view returns(uint) {\n', '        return inchWormContract.totalSupply().sub(inchWormContract.balanceOf(address(this)));\n', '    }\n', '    \n', '    \n', '    /// @return The amount of ETH you will get after selling X INCH\n', '    function afterFeeEthReturns(uint _inchToSell) public view returns(uint) {\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        return _trueInchToSell.mul(premium).div(premiumDigits.mul(etherPeg));\n', '    }\n', '    \n', '    /// @return The amount of ETH you will get after selling X INCH\n', '    function afterFeeDaiReturns(uint _inchToSell) public view returns(uint) {\n', '        uint _trueInchToSell = _inchToSell.mul(conserveRate).div(conserveRateDigits);\n', '        return _trueInchToSell.mul(premium).div(premiumDigits);\n', '    }\n', '    \n', '    /// @return The Wei balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getEthBalance() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /// @return The INCH balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getInchBalance() public view returns(uint) {\n', '        return inchWormContract.balanceOf(address(this));\n', '    }\n', '    \n', '    /// @return The Dai balance of the vault contract\n', '    ///         ALL TOKENS UNCLUDING ETHER ARE DISPLAYED AS 10^-18 * THE BASE UNIT OF CURRENCY\n', '    function getDaiBalance() public view returns(uint) {\n', '        return daiContract.balanceOf(address(this));\n', '    }\n', '    \n', '    /// @param _a: the address to check balance of\n', '    /// @return INCH balance of target address\n', '    /// @notice This is just the balanceOf function from inchWormContract. Put here for ease of access\n', '    function getOwnerInch(address _a) public view returns(uint) {\n', '        return inchWormContract.balanceOf(_a);\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__^__^__^__View Functions__^__^__^__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '\n', '\n', '    \n', '    \n', '    /*____________________________________________________________________________________*/\n', '    /*__________________________Emergency and Fallback Functions__________________________*/\n', '    \n', '    /// @notice Original deployer can transfer out tokens other than Dai and INCH\n', '    /// @dev    This function can be used to steal funds if there is any way to alter the inchWormContract address or daiContract address\n', '    function transferAccidentalERC20Tokens(address tokenAddress, uint tokens) external returns (bool success) {\n', '        require(msg.sender == deployer);\n', '        require(tokenAddress != address(inchWormContract));\n', '        require(tokenAddress != address(daiContract));\n', '        \n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    // fallback function\n', '    function () external payable {\n', '        revert();\n', '    }\n', '    \n', '    /* ^__^__^__^__^__^__^__^__emergency and fallback functions__^__^__^__^__^__^__^__^__^*/\n', '    /*____________________________________________________________________________________*/\n', '    \n', '}']
