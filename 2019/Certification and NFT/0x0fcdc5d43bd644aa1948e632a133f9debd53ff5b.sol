['//                                               __                __                                                            \n', '//                                              |  \\              |  \\                                                           \n', '//   _______  __   __   __   ______    ______  _| $$_     ______  | $$   __   ______   _______       ______    ______    ______  \n', '//  /       \\|  \\ |  \\ |  \\ |      \\  /      \\|   $$ \\   /      \\ | $$  /  \\ /      \\ |       \\     |      \\  /      \\  /      \\ \n', '// |  $$$$$$$| $$ | $$ | $$  \\$$$$$$\\|  $$$$$$\\\\$$$$$$  |  $$$$$$\\| $$_/  $$|  $$$$$$\\| $$$$$$$\\     \\$$$$$$\\|  $$$$$$\\|  $$$$$$\\\n', '//  \\$$    \\ | $$ | $$ | $$ /      $$| $$  | $$ | $$ __ | $$  | $$| $$   $$ | $$    $$| $$  | $$    /      $$| $$  | $$| $$  | $$\n', '//  _\\$$$$$$\\| $$_/ $$_/ $$|  $$$$$$$| $$__/ $$ | $$|  \\| $$__/ $$| $$$$$$\\ | $$$$$$$$| $$  | $$ __|  $$$$$$$| $$__/ $$| $$__/ $$\n', '// |       $$ \\$$   $$   $$ \\$$    $$| $$    $$  \\$$  $$ \\$$    $$| $$  \\$$\\ \\$$     \\| $$  | $$|  \\\\$$    $$| $$    $$| $$    $$\n', '//  \\$$$$$$$   \\$$$$$\\$$$$   \\$$$$$$$| $$$$$$$    \\$$$$   \\$$$$$$  \\$$   \\$$  \\$$$$$$$ \\$$   \\$$ \\$$ \\$$$$$$$| $$$$$$$ | $$$$$$$ \n', '//                                   | $$                                                                    | $$      | $$      \n', '//                                   | $$                                                                    | $$      | $$      \n', '//                                    \\$$                                                                     \\$$       \\$$      \n', '// https://swaptoken.app\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/HashedTimelock.sol\n', '\n', 'pragma solidity 0.5.3;\n', '\n', '\n', '\n', '/**\n', ' * @title Hashed Timelock Contracts (HTLCs) on Ethereum ETH.\n', ' *\n', ' * This contract provides a way to create and keep HTLCs for ETH.\n', ' *\n', ' *\n', ' * Protocol:\n', ' *\n', ' *  1) newContract(receiver, hashlock, timelock) - a sender calls this to create\n', ' *      a new HTLC and gets back a 32 byte contract id\n', ' *  2) withdraw(contractId, preimage) - once the receiver knows the preimage of\n', ' *      the hashlock hash they can claim the ETH with this function\n', ' *  3) refund() - after timelock has expired and if the receiver did not \n', ' *      withdraw funds the sender / creater of the HTLC can get their ETH \n', ' *      back with this function.\n', ' */\n', 'contract HashedTimelock {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event LogHTLCNew(\n', '        bytes32 indexed contractId,\n', '        address indexed sender,\n', '        address indexed receiver,\n', '        uint amount,\n', '        uint timelock\n', '    );\n', '    event LogHTLCWithdraw(bytes32 indexed contractId, bytes32 preimage);\n', '    event LogHTLCRefund(bytes32 indexed contractId);\n', '\n', '    struct LockContract {\n', '        address payable sender;\n', '        address payable receiver;\n', '        uint amount;\n', '        uint timelock; // UNIX timestamp seconds - locked UNTIL this time\n', '        bool withdrawn;\n', '        bool refunded;\n', '        bytes32 preimage;\n', '    }\n', '\n', '    modifier fundsSent() {\n', '        require(msg.value > 0, "msg.value must be > 0");\n', '        _;\n', '    }\n', '    modifier futureTimelock(uint _time) {\n', '        // only requirement is the timelock time is after the last blocktime (now).\n', '        // probably want something a bit further in the future then this.\n', '        // but this is still a useful sanity check:\n', '        require(_time > now + 1 hours, "timelock time must be in the future");\n', '        _;\n', '    }\n', '    modifier contractExists(bytes32 _contractId) {\n', '        require(haveContract(_contractId), "contractId does not exist");\n', '        _;\n', '    }\n', '    modifier hashlockMatches(bytes32 _contractId, bytes32 _x) {\n', '        require(\n', '            _contractId == keccak256(abi.encodePacked(_x)),\n', '            "hashlock hash does not match"\n', '        );\n', '        _;\n', '    }\n', '    modifier withdrawable(bytes32 _contractId) {\n', '        require(contracts[_contractId].receiver == msg.sender, "withdrawable: not receiver");\n', '        require(contracts[_contractId].withdrawn == false, "withdrawable: already withdrawn");\n', '        _;\n', '    }\n', '    modifier refundable(bytes32 _contractId) {\n', '        require(contracts[_contractId].sender == msg.sender, "refundable: not sender");\n', '        require(contracts[_contractId].refunded == false, "refundable: already refunded");\n', '        require(contracts[_contractId].withdrawn == false, "refundable: already withdrawn");\n', '        require(contracts[_contractId].timelock <= now, "refundable: timelock not yet passed");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "you are not an owner");\n', '        _;\n', '    }\n', '\n', '    mapping (bytes32 => LockContract) contracts;\n', '    uint256 public feePercent; // 5 == 0.05 %\n', '    uint oneHundredPercent = 10000; // 100 %\n', '    address payable public owner;\n', '    uint feeToWithdraw;\n', '\n', '    constructor(address payable _owner, uint256 _feePercent) public {\n', '        feePercent = _feePercent;\n', '        owner = _owner;\n', '    }\n', '\n', '    function setFeePercent(uint256 _feePercent) external onlyOwner {\n', '        require(_feePercent < oneHundredPercent.div(2), "should be less than 50%");\n', '        feePercent = _feePercent;\n', '    }\n', '    /**\n', '     * @dev Sender sets up a new hash time lock contract depositing the ETH and \n', '     * providing the reciever lock terms.\n', '     *\n', '     * @param _receiver Receiver of the ETH.\n', '     * @param _hashlock A keccak256 hash hashlock.\n', '     * @param _timelock UNIX epoch seconds time that the lock expires at. \n', '     *                  Refunds can be made after this time.\n', '     */\n', '    function newContract(address payable _receiver, bytes32 _hashlock, uint _timelock)\n', '        external\n', '        payable\n', '        fundsSent\n', '        futureTimelock(_timelock)\n', '    {\n', '        uint256 swapValue = msg.value.mul(oneHundredPercent).div(oneHundredPercent.add(feePercent));\n', '        uint feeValue = msg.value.sub(swapValue);\n', '        feeToWithdraw = feeValue.add(feeToWithdraw);\n', '\n', '        // Reject if a contract already exists with the same parameters. The\n', '        // sender must change one of these parameters to create a new distinct \n', '        // contract.\n', '        if (haveContract(_hashlock)) {\n', '            revert("contract exist");\n', '        }\n', '\n', '        contracts[_hashlock] = LockContract(\n', '            msg.sender,\n', '            _receiver,\n', '            swapValue,\n', '            _timelock,\n', '            false,\n', '            false,\n', '            0x0\n', '        );\n', '\n', '        emit LogHTLCNew(\n', '            _hashlock,\n', '            msg.sender,\n', '            _receiver,\n', '            swapValue,\n', '            _timelock\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the receiver once they know the preimage of the hashlock.\n', '     * This will transfer the locked funds to their address.\n', '     *\n', '     * @param _contractId Id of the HTLC.\n', '     * @param _preimage keccak256(_preimage) should equal the contract hashlock.\n', '     * @return bool true on success\n', '     */\n', '    function withdraw(bytes32 _contractId, bytes32 _preimage)\n', '        external\n', '        contractExists(_contractId)\n', '        hashlockMatches(_contractId, _preimage)\n', '        withdrawable(_contractId)\n', '        returns (bool)\n', '    {\n', '        LockContract storage c = contracts[_contractId];\n', '        c.preimage = _preimage;\n', '        c.withdrawn = true;\n', '        c.receiver.transfer(c.amount);\n', '        emit LogHTLCWithdraw(_contractId, _preimage);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the sender if there was no withdraw AND the time lock has\n', '     * expired. This will refund the contract amount.\n', '     *\n', '     * @param _contractId Id of HTLC to refund from.\n', '     * @return bool true on success\n', '     */\n', '    function refund(bytes32 _contractId)\n', '        external\n', '        contractExists(_contractId)\n', '        refundable(_contractId)\n', '        returns (bool)\n', '    {\n', '        LockContract storage c = contracts[_contractId];\n', '        c.refunded = true;\n', '        c.sender.transfer(c.amount);\n', '        emit LogHTLCRefund(_contractId);\n', '        return true;\n', '    }\n', '\n', '    function claimTokens(address _token) external onlyOwner {\n', '        if (_token == address(0)) {\n', '            owner.transfer(feeToWithdraw);\n', '            return;\n', '        }\n', '        IERC20 erc20token = IERC20(_token);\n', '        uint256 balance = erc20token.balanceOf(address(this));\n', '        erc20token.transfer(owner, balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Get contract details.\n', '     * @param _contractId HTLC contract id\n', '     * @return All parameters in struct LockContract for _contractId HTLC\n', '     */\n', '    function getContract(bytes32 _contractId)\n', '        public\n', '        view\n', '        returns (\n', '            address sender,\n', '            address receiver,\n', '            uint amount,\n', '            uint timelock,\n', '            bool withdrawn,\n', '            bool refunded,\n', '            bytes32 preimage\n', '        )\n', '    {\n', '        if (haveContract(_contractId) == false)\n', '            return (address(0), address(0), 0, 0, false, false, 0);\n', '        LockContract storage c = contracts[_contractId];\n', '        return (c.sender, c.receiver, c.amount, c.timelock,\n', '            c.withdrawn, c.refunded, c.preimage);\n', '    }\n', '\n', '    /**\n', '     * @dev Is there a contract with id _contractId.\n', '     * @param _contractId Id into contracts mapping.\n', '     */\n', '    function haveContract(bytes32 _contractId)\n', '        public\n', '        view\n', '        returns (bool exists)\n', '    {\n', '        exists = (contracts[_contractId].sender != address(0));\n', '    }\n', '\n', '}']