['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-09\n', '*/\n', '\n', '/**\n', ' * Copyright 2017-2019, bZeroX, LLC. All Rights Reserved.\n', ' * Licensed under the Apache License, Version 2.0.\n', ' */\n', ' \n', 'pragma solidity 0.5.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title EIP20/ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract EIP20 is ERC20 {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '}\n', '\n', 'contract WETHInterface is EIP20 {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 wad) external;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, rounding up and truncating the quotient\n', '  */\n', '  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    return ((_a - 1) / _b) + 1;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0d7f68606e624d3f">[email&#160;protected]</a>Ï€.com>, Eenae <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b0d1dcd5c8d5c9f0ddd9c8d2c9c4d5c39ed9df">[email&#160;protected]</a>>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\n', '  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\n', '  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\n', '\n', '  /// @dev Constant for locked guard state\n', '  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one `nonReentrant` function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and an `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(reentrancyLock == REENTRANCY_GUARD_FREE, "nonReentrant");\n', '    reentrancyLock = REENTRANCY_GUARD_LOCKED;\n', '    _;\n', '    reentrancyLock = REENTRANCY_GUARD_FREE;\n', '  }\n', '\n', '}\n', '\n', 'contract LoanTokenization is ReentrancyGuard, Ownable {\n', '\n', '    uint256 internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    address public bZxContract;\n', '    address public bZxVault;\n', '    address public bZxOracle;\n', '    address public wethContract;\n', '\n', '    address public loanTokenAddress;\n', '\n', '    // price of token at last user checkpoint\n', '    mapping (address => uint256) internal checkpointPrices_;\n', '}\n', '\n', 'contract PositionTokenStorage is LoanTokenization {\n', '\n', '    bool internal isInitialized_ = false;\n', '\n', '    address public loanTokenLender;\n', '    address public tradeTokenAddress;\n', '\n', '    uint256 public leverageAmount;\n', '    bytes32 public loanOrderHash;\n', '\n', '    uint256 public initialPrice;\n', '}\n', '\n', 'contract SplittableTokenStorage is PositionTokenStorage {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Mint(\n', '        address indexed minter,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '    event Burn(\n', '        address indexed burner,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 internal totalSupply_;\n', '\n', '    uint256 public splitFactor = 10**18;\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return denormalize(totalSupply_);\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return denormalize(balances[_owner]);\n', '    }\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return denormalize(allowed[_owner][_spender]);\n', '    }\n', '\n', '    function normalize(\n', '        uint256 _value)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _value\n', '            .mul(splitFactor)\n', '            .div(10**18);\n', '    }\n', '\n', '    function denormalize(\n', '        uint256 _value)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _value\n', '            .mul(10**18)\n', '            .div(splitFactor);\n', '    }\n', '}\n', '\n', 'contract SplittableToken is SplittableTokenStorage {\n', '    using SafeMath for uint256;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 allowanceAmount = denormalize(allowed[_from][msg.sender]);\n', '        uint256 fromBalance = denormalize(balances[_from]);\n', '        require(_value <= fromBalance, "insufficient balance");\n', '        require(_value <= allowanceAmount, "insufficient allowance");\n', '        require(_to != address(0), "invalid address");\n', '\n', '        balances[_from] = normalize(fromBalance.sub(_value));\n', '        if (balanceOf(_from) == 0) {\n', '            balances[_from] = 0;\n', '        }\n', '\n', '        balances[_to] = normalize(denormalize(balances[_to]).add(_value));\n', '        if (allowanceAmount < MAX_UINT) {\n', '            allowed[_from][msg.sender] = normalize(allowanceAmount.sub(_value));\n', '            if (allowance(_from, msg.sender) == 0) {\n', '                allowed[_from][msg.sender] = 0;\n', '            }\n', '        }\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 fromBalance = denormalize(balances[msg.sender]);\n', '        require(_value <= fromBalance, "insufficient balance");\n', '        require(_to != address(0), "invalid address");\n', '\n', '        balances[msg.sender] = normalize(fromBalance.sub(_value));\n', '        if (balanceOf(msg.sender) == 0) {\n', '            balances[msg.sender] = 0;\n', '        }\n', '\n', '        balances[_to] = normalize(denormalize(balances[_to]).add(_value));\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        if (allowance(msg.sender, _spender) == 0) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        }\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = normalize(denormalize(allowed[msg.sender][_spender]).add(_addedValue));\n', '        emit Approval(msg.sender, _spender, denormalize(allowed[msg.sender][_spender]));\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 oldValue = denormalize(allowed[msg.sender][_spender]);\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = normalize(oldValue.sub(_subtractedValue));\n', '            if (allowance(msg.sender, _spender) == 0) {\n', '                allowed[msg.sender][_spender] = 0;\n', '            }\n', '        }\n', '        emit Approval(msg.sender, _spender, denormalize(allowed[msg.sender][_spender]));\n', '        return true;\n', '    }\n', '\n', '    function _mint(\n', '        address _to,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '    {\n', '        require(_to != address(0), "invalid address");\n', '        totalSupply_ = normalize(denormalize(totalSupply_).add(_tokenAmount));\n', '        balances[_to] = normalize(denormalize(balances[_to]).add(_tokenAmount));\n', '\n', '        emit Mint(_to, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(address(0), _to, _tokenAmount);\n', '    }\n', '\n', '    function _burn(\n', '        address _who,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '    {\n', '        uint256 whoBalance = denormalize(balances[_who]);\n', '        require(_tokenAmount <= whoBalance, "burn value exceeds balance");\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        uint256 offsetAmount;\n', '        balances[_who] = normalize(whoBalance.sub(_tokenAmount));\n', '        if (balances[_who] <= 10 || balanceOf(_who) <= 10) { // we can&#39;t leave such small balance quantities\n', '            offsetAmount = balances[_who];\n', '            balances[_who] = 0;\n', '        }\n', '\n', '        uint256 normSupply = denormalize(totalSupply_);\n', '        if (normSupply > _tokenAmount) {\n', '            totalSupply_ = normalize(normSupply.sub(_tokenAmount));\n', '\n', '            if (totalSupply() == 0) {\n', '                totalSupply_ = 0;\n', '                balances[_who] = 0;\n', '            }\n', '        } else {\n', '            balances[_who] = 0;\n', '            totalSupply_ = 0;\n', '        }\n', '\n', '        if (offsetAmount > 0) {\n', '            _tokenAmount = _tokenAmount.add(denormalize(offsetAmount));\n', '            if (totalSupply_ > offsetAmount)\n', '                totalSupply_ = totalSupply_.sub(offsetAmount);\n', '            else {\n', '                totalSupply_ = 0;\n', '            }\n', '        }\n', '\n', '        emit Burn(_who, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(_who, address(0), _tokenAmount);\n', '    }\n', '}\n', '\n', 'interface IBZx {\n', '    function closeLoanPartiallyIfHealthy(\n', '        bytes32 loanOrderHash,\n', '        uint256 closeAmount)\n', '        external\n', '        returns (uint256 actualCloseAmount);\n', '\n', '    function withdrawCollateral(\n', '        bytes32 loanOrderHash,\n', '        uint256 withdrawAmount)\n', '        external\n', '        returns (uint256 amountWithdrawn);\n', '\n', '    function depositCollateral(\n', '        bytes32 loanOrderHash,\n', '        address depositTokenAddress,\n', '        uint256 depositAmount)\n', '        external\n', '        returns (bool);\n', '\n', '    function depositPosition(\n', '        bytes32 loanOrderHash,\n', '        address depositTokenAddress,\n', '        uint256 depositAmount)\n', '        external\n', '        returns (bool);\n', '\n', '    function getMarginLevels(\n', '        bytes32 loanOrderHash,\n', '        address trader)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 initialMarginAmount,\n', '            uint256 maintenanceMarginAmount,\n', '            uint256 currentMarginAmount);\n', '\n', '    function getTotalEscrow(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        bool actualized)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 netCollateralAmount,\n', '            uint256 interestDepositRemaining,\n', '            uint256 loanTokenAmountBorrowed);\n', '\n', '    function oracleAddresses(\n', '        address oracleAddress)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'interface IBZxOracle {\n', '    function tradeUserAsset(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        address receiverAddress,\n', '        address returnToSenderAddress,\n', '        uint256 sourceTokenAmount,\n', '        uint256 maxDestTokenAmount,\n', '        uint256 minConversionRate)\n', '        external\n', '        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed);\n', '}\n', '\n', 'interface ILoanToken {\n', '    function getMaxEscrowAmount(\n', '        uint256 leverageAmount)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'contract PositionTokenLogic_WBTCShort is SplittableToken {\n', '    using SafeMath for uint256;\n', '\n', '\n', '    function()\n', '        external\n', '        payable\n', '    {}\n', '\n', '\n', '    /* Public functions */\n', '\n', '    // returns the amount of token minted\n', '    // maxPriceAllowed of 0 will be ignored\n', '    function mintWithEther(\n', '        address receiver,\n', '        uint256 maxPriceAllowed)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        require (msg.value > 0, "msg.value == 0");\n', '\n', '        uint256 netCollateralAmount;\n', '        uint256 interestDepositRemaining;\n', '        if (totalSupply() > 0) {\n', '            (netCollateralAmount, interestDepositRemaining,) = IBZx(bZxContract).getTotalEscrow(\n', '                loanOrderHash,\n', '                address(this),\n', '                false // actualized\n', '            );\n', '        }\n', '        uint256 currentPrice = _tokenPrice(netCollateralAmount, interestDepositRemaining);\n', '\n', '        if (maxPriceAllowed != 0) {\n', '            require(\n', '                currentPrice <= maxPriceAllowed,\n', '                "price too high"\n', '            );\n', '        }\n', '\n', '        WETHInterface(wethContract).deposit.value(msg.value)();\n', '\n', '        return _mintWithToken(\n', '            receiver,\n', '            wethContract,\n', '            msg.value,\n', '            currentPrice\n', '        );\n', '    }\n', '\n', '    // returns the amount of token minted\n', '    // maxPriceAllowed of 0 is ignored\n', '    function mintWithToken(\n', '        address receiver,\n', '        address depositTokenAddress,\n', '        uint256 depositAmount,\n', '        uint256 maxPriceAllowed)\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        require (depositAmount > 0, "depositAmount == 0");\n', '\n', '        uint256 netCollateralAmount;\n', '        uint256 interestDepositRemaining;\n', '        if (totalSupply() > 0) {\n', '            (netCollateralAmount, interestDepositRemaining,) = IBZx(bZxContract).getTotalEscrow(\n', '                loanOrderHash,\n', '                address(this),\n', '                false // actualized\n', '            );\n', '        }\n', '        uint256 currentPrice = _tokenPrice(netCollateralAmount, interestDepositRemaining);\n', '\n', '        if (maxPriceAllowed != 0) {\n', '            require(\n', '                currentPrice <= maxPriceAllowed,\n', '                "price too high"\n', '            );\n', '        }\n', '\n', '        require(ERC20(depositTokenAddress).transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            depositAmount\n', '        ), "transfer of token failed");\n', '\n', '        return _mintWithToken(\n', '            receiver,\n', '            depositTokenAddress,\n', '            depositAmount,\n', '            currentPrice\n', '        );\n', '    }\n', '\n', '    function burnToEther(\n', '        address payable receiver,\n', '        uint256 burnAmount,\n', '        uint256 minPriceAllowed)\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        uint256 loanAmountOwed = _burnToken(burnAmount, minPriceAllowed);\n', '        if (loanAmountOwed > 0) {\n', '            if (wethContract != loanTokenAddress) {\n', '                address oracle = IBZx(bZxContract).oracleAddresses(bZxOracle);\n', '                uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), oracle);\n', '                if (tempAllowance < loanAmountOwed) {\n', '                    if (tempAllowance > 0) {\n', '                        // reset approval to 0\n', '                        require(ERC20(loanTokenAddress).approve(oracle, 0), "token approval reset failed");\n', '                    }\n', '\n', '                    require(ERC20(loanTokenAddress).approve(oracle, MAX_UINT), "token approval failed");\n', '                }\n', '\n', '                (uint256 destTokenAmountReceived,) = IBZxOracle(oracle).tradeUserAsset(\n', '                    loanTokenAddress,\n', '                    address(0), // Ether\n', '                    receiver, // receiverAddress\n', '                    receiver, // returnToSenderAddress\n', '                    loanAmountOwed,\n', '                    MAX_UINT,\n', '                    0 // minConversionRate\n', '                );\n', '\n', '                loanAmountOwed = destTokenAmountReceived;\n', '            } else {\n', '                WETHInterface(wethContract).withdraw(loanAmountOwed);\n', '                require(receiver.send(loanAmountOwed), "transfer of ETH failed");\n', '            }\n', '        }\n', '\n', '        return loanAmountOwed;\n', '    }\n', '\n', '    function burnToToken(\n', '        address receiver,\n', '        address burnTokenAddress,\n', '        uint256 burnAmount,\n', '        uint256 minPriceAllowed)\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        uint256 loanAmountOwed = _burnToken(burnAmount, minPriceAllowed);\n', '        if (loanAmountOwed > 0) {\n', '            if (burnTokenAddress != loanTokenAddress) {\n', '                address oracle = IBZx(bZxContract).oracleAddresses(bZxOracle);\n', '                uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), oracle);\n', '                if (tempAllowance < loanAmountOwed) {\n', '                    if (tempAllowance > 0) {\n', '                        // reset approval to 0\n', '                        require(ERC20(loanTokenAddress).approve(oracle, 0), "token approval reset failed");\n', '                    }\n', '\n', '                    require(ERC20(loanTokenAddress).approve(oracle, MAX_UINT), "token approval failed");\n', '                }\n', '\n', '                (uint256 destTokenAmountReceived,) = IBZxOracle(oracle).tradeUserAsset(\n', '                    loanTokenAddress,\n', '                    burnTokenAddress,\n', '                    receiver, // receiverAddress\n', '                    receiver, // returnToSenderAddress\n', '                    loanAmountOwed,\n', '                    MAX_UINT,\n', '                    0 // minConversionRate\n', '                );\n', '\n', '                loanAmountOwed = destTokenAmountReceived;\n', '            } else {\n', '                require(ERC20(loanTokenAddress).transfer(\n', '                    receiver,\n', '                    loanAmountOwed\n', '                ), "transfer of loanToken failed");\n', '            }\n', '        }\n', '\n', '        return loanAmountOwed;\n', '    }\n', '\n', '    function wrapEther()\n', '        external\n', '        nonReentrant\n', '    {\n', '        if (address(this).balance > 0) {\n', '            WETHInterface(wethContract).deposit.value(address(this).balance)();\n', '        }\n', '    }\n', '\n', '    // Sends non-LoanToken assets to the Oracle fund\n', '    // These are assets that would otherwise be "stuck" due to a user accidently sending them to the contract\n', '    function donateAsset(\n', '        address tokenAddress)\n', '        external\n', '        nonReentrant\n', '        returns (bool)\n', '    {\n', '        if (tokenAddress == loanTokenAddress)\n', '            return false;\n', '\n', '        uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\n', '        if (balance == 0)\n', '            return false;\n', '\n', '        require(ERC20(tokenAddress).transfer(\n', '            IBZx(bZxContract).oracleAddresses(bZxOracle),\n', '            balance\n', '        ), "transfer of token balance failed");\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        super.transferFrom(\n', '            _from,\n', '            _to,\n', '            _value\n', '        );\n', '\n', '        // handle checkpoint update\n', '        uint256 currentPrice = denormalize(tokenPrice());\n', '        if (balanceOf(_from) > 0) {\n', '            checkpointPrices_[_from] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_from] = 0;\n', '        }\n', '        if (balanceOf(_to) > 0) {\n', '            checkpointPrices_[_to] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_to] = 0;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        super.transfer(\n', '            _to,\n', '            _value\n', '        );\n', '\n', '        // handle checkpoint update\n', '        uint256 currentPrice = denormalize(tokenPrice());\n', '        if (balanceOf(msg.sender) > 0) {\n', '            checkpointPrices_[msg.sender] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[msg.sender] = 0;\n', '        }\n', '        if (balanceOf(_to) > 0) {\n', '            checkpointPrices_[_to] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_to] = 0;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Public View functions */\n', '\n', '    function tokenPrice()\n', '        public\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        uint256 netCollateralAmount;\n', '        uint256 interestDepositRemaining;\n', '        if (totalSupply() > 0) {\n', '            (netCollateralAmount, interestDepositRemaining,) = IBZx(bZxContract).getTotalEscrow(\n', '                loanOrderHash,\n', '                address(this),\n', '                false // actualized\n', '            );\n', '        }\n', '\n', '        return _tokenPrice(netCollateralAmount, interestDepositRemaining);\n', '    }\n', '\n', '    function liquidationPrice()\n', '        public\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        (,uint256 maintenanceMarginAmount,uint256 currentMarginAmount) = IBZx(bZxContract).getMarginLevels(\n', '            loanOrderHash,\n', '            address(this));\n', '\n', '        if (maintenanceMarginAmount == 0)\n', '            return 0;\n', '        else if (currentMarginAmount <= maintenanceMarginAmount)\n', '            return tokenPrice();\n', '\n', '        return tokenPrice()\n', '            .mul(maintenanceMarginAmount)\n', '            .div(currentMarginAmount);\n', '    }\n', '\n', '    function checkpointPrice(\n', '        address _user)\n', '        public\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        return normalize(checkpointPrices_[_user]);\n', '    }\n', '\n', '    function currentLeverage()\n', '        public\n', '        view\n', '        returns (uint256 leverage)\n', '    {\n', '        (,,uint256 currentMarginAmount) = IBZx(bZxContract).getMarginLevels(\n', '            loanOrderHash,\n', '            address(this));\n', '\n', '        if (currentMarginAmount == 0)\n', '            return 0;\n', '\n', '        return SafeMath.div(10**38, currentMarginAmount);\n', '    }\n', '\n', '    function marketLiquidityForAsset()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return ILoanToken(loanTokenLender).getMaxEscrowAmount(leverageAmount);\n', '    }\n', '\n', '    function marketLiquidityForToken()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return ILoanToken(loanTokenLender).getMaxEscrowAmount(leverageAmount)\n', '            .mul(10**28) // 10**18 * 10**(18-8) - WBTC adjust\n', '            .div(tokenPrice());\n', '    }\n', '\n', '    // returns the user&#39;s balance of underlying token\n', '    function assetBalanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balanceOf(_owner)\n', '            .mul(tokenPrice())\n', '            .div(10**28); // 10**18 * 10**(18-8) - WBTC adjust\n', '    }\n', '\n', '\n', '    /* Internal functions */\n', '\n', '    // returns the amount of token minted\n', '    function _mintWithToken(\n', '        address receiver,\n', '        address depositTokenAddress,\n', '        uint256 depositAmount,\n', '        uint256 currentPrice)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 liquidityAmount = marketLiquidityForAsset();\n', '        require(liquidityAmount > 0, "marketLiquidity == 0");\n', '\n', '        uint256 refundAmount;\n', '        if (depositTokenAddress != loanTokenAddress) {\n', '            address oracle = IBZx(bZxContract).oracleAddresses(bZxOracle);\n', '            uint256 tempAllowance = ERC20(depositTokenAddress).allowance(address(this), oracle);\n', '            if (tempAllowance < depositAmount) {\n', '                if (tempAllowance > 0) {\n', '                    // reset approval to 0\n', '                    require(ERC20(depositTokenAddress).approve(oracle, 0), "token approval reset failed");\n', '                }\n', '\n', '                require(ERC20(depositTokenAddress).approve(oracle, MAX_UINT), "token approval failed");\n', '            }\n', '\n', '            (uint256 destTokenAmountReceived, uint256 depositAmountUsed) = IBZxOracle(oracle).tradeUserAsset(\n', '                depositTokenAddress,\n', '                loanTokenAddress,\n', '                address(this), // receiverAddress\n', '                address(this), // returnToSenderAddress\n', '                depositAmount,\n', '                MAX_UINT,\n', '                0 // minConversionRate\n', '            );\n', '\n', '            require(destTokenAmountReceived <= liquidityAmount, "market liquidity insufficient");\n', '\n', '            if (depositAmount > depositAmountUsed) {\n', '                refundAmount = depositAmount-depositAmountUsed;\n', '                if (msg.value == 0) {\n', '                    require(ERC20(depositTokenAddress).transfer(\n', '                        msg.sender,\n', '                        refundAmount\n', '                    ), "transfer of token failed");\n', '                } else {\n', '                    WETHInterface(wethContract).withdraw(refundAmount);\n', '                    require(msg.sender.send(refundAmount), "transfer of ETH failed");\n', '                }\n', '            }\n', '\n', '            depositAmount = destTokenAmountReceived;\n', '        } else if (depositAmount > liquidityAmount) {\n', '            refundAmount = depositAmount-liquidityAmount;\n', '            if (msg.value == 0) {\n', '                require(ERC20(loanTokenAddress).transfer(\n', '                    msg.sender,\n', '                    refundAmount\n', '                ), "transfer of token failed");\n', '            } else {\n', '                WETHInterface(wethContract).withdraw(refundAmount);\n', '                require(msg.sender.send(refundAmount), "transfer of ETH failed");\n', '            }\n', '            depositAmount = liquidityAmount;\n', '        }\n', '\n', '        // depositAmount must be >= 0.001 loanToken units\n', '        require(depositAmount >= (10**15 *\n', '            10**uint256(decimals) /\n', '            10**28 // 10**18 * 10**(18-8) - WBTC adjust\n', '        ), "depositAmount too low");\n', '\n', '        require(_triggerPosition(depositAmount), "triggerPosition failed");\n', '\n', '        // get post-entry supply\n', '        (uint256 netCollateralAmount, uint256 interestDepositRemaining,) = IBZx(bZxContract).getTotalEscrow(\n', '            loanOrderHash,\n', '            address(this),\n', '            false // actualized\n', '        );\n', '        uint256 postEntrySupply = ERC20(loanTokenAddress).balanceOf(address(this))\n', '            .add(netCollateralAmount)\n', '            .add(interestDepositRemaining)\n', '            .mul(10**28) // 10**18 * 10**(18-8) - WBTC adjust\n', '            .div(currentPrice);\n', '        require(postEntrySupply > totalSupply(), "supply not added");\n', '\n', '        uint256 mintAmount = postEntrySupply - totalSupply();\n', '        _mint(\n', '            receiver,\n', '            mintAmount,\n', '            depositAmount,\n', '            currentPrice\n', '        );\n', '\n', '        checkpointPrices_[receiver] = denormalize(currentPrice);\n', '\n', '        return mintAmount;\n', '    }\n', '\n', '    function _burnToken(\n', '        uint256 burnAmount,\n', '        uint256 minPriceAllowed)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        require(burnAmount > 0, "burnAmount == 0");\n', '\n', '        if (burnAmount > balanceOf(msg.sender)) {\n', '            burnAmount = balanceOf(msg.sender);\n', '        }\n', '\n', '        (uint256 netCollateralAmount, uint256 interestDepositRemaining, uint256 loanTokenAmountBorrowed) = IBZx(bZxContract).getTotalEscrow(\n', '            loanOrderHash,\n', '            address(this),\n', '            false // actualized\n', '        );\n', '        uint256 currentPrice = _tokenPrice(netCollateralAmount, interestDepositRemaining);\n', '\n', '        if (minPriceAllowed != 0) {\n', '            require(\n', '                currentPrice >= minPriceAllowed,\n', '                "price too low"\n', '            );\n', '        }\n', '\n', '        uint256 loanAmountOwed = burnAmount\n', '            .mul(currentPrice)\n', '            .div(10**28); // 10**18 * 10**(18-8) - WBTC adjust\n', '\n', '        uint256 loanAmountAvailableInContract = ERC20(loanTokenAddress).balanceOf(address(this));\n', '\n', '        uint256 preCloseEscrow = loanAmountAvailableInContract\n', '            .add(netCollateralAmount)\n', '            .add(interestDepositRemaining);\n', '\n', '        bool didCallWithdraw;\n', '        if (loanAmountAvailableInContract < loanAmountOwed) {\n', '            uint256 closeAmount;\n', '            if (burnAmount < totalSupply()) {\n', '                closeAmount = loanAmountOwed\n', '                    .sub(loanAmountAvailableInContract)\n', '                    .mul(loanTokenAmountBorrowed)\n', '                    .div(netCollateralAmount\n', '                        .add(interestDepositRemaining));\n', '            } else {\n', '                // close entire loan\n', '                closeAmount = MAX_UINT;\n', '            }\n', '\n', '            // will revert if the position needs to be liquidated\n', '            IBZx(bZxContract).closeLoanPartiallyIfHealthy(\n', '                loanOrderHash,\n', '                closeAmount\n', '            );\n', '\n', '            loanAmountAvailableInContract = ERC20(loanTokenAddress).balanceOf(address(this));\n', '            didCallWithdraw = true;\n', '        }\n', '\n', '        if (loanAmountAvailableInContract < loanAmountOwed) {\n', '            uint256 collateralWithdrawn = IBZx(bZxContract).withdrawCollateral(\n', '                loanOrderHash,\n', '                loanAmountOwed.sub(loanAmountAvailableInContract)\n', '            );\n', '            if (collateralWithdrawn > 0) {\n', '                loanAmountAvailableInContract = loanAmountAvailableInContract.add(collateralWithdrawn);\n', '                didCallWithdraw = true;\n', '            }\n', '        }\n', '\n', '        if (didCallWithdraw) {\n', '            (netCollateralAmount, interestDepositRemaining,) = IBZx(bZxContract).getTotalEscrow(\n', '                loanOrderHash,\n', '                address(this),\n', '                false // actualized\n', '            );\n', '            uint256 postCloseEscrow = loanAmountAvailableInContract\n', '                .add(netCollateralAmount)\n', '                .add(interestDepositRemaining);\n', '\n', '            if (postCloseEscrow < preCloseEscrow) {\n', '                uint256 slippageLoss = preCloseEscrow - postCloseEscrow;\n', '\n', '                require(loanAmountOwed > slippageLoss, "slippage too great");\n', '                loanAmountOwed = loanAmountOwed - slippageLoss;\n', '            } else {\n', '                loanAmountOwed = loanAmountOwed.add(postCloseEscrow - preCloseEscrow);\n', '            }\n', '\n', '            if (loanAmountOwed > loanAmountAvailableInContract) {\n', '                // allow at most 5% loss here\n', '                require(\n', '                    loanAmountOwed\n', '                    .sub(loanAmountAvailableInContract)\n', '                    .mul(10**20)\n', '                    .div(loanAmountOwed) <= (5 * 10**18),\n', '                    "contract value too low"\n', '                );\n', '                loanAmountOwed = loanAmountAvailableInContract;\n', '            }\n', '        }\n', '\n', '        // unless burning the full balance, loanAmountOwed must be >= 0.001 loanToken units\n', '        require(burnAmount == balanceOf(msg.sender) || loanAmountOwed >= (\n', '            10**15 *\n', '            10**uint256(decimals)\n', '            / 10**28 // 10**18 * 10**(18-8) - WBTC adjust\n', '        ), "burnAmount too low");\n', '\n', '        _burn(msg.sender, burnAmount, loanAmountOwed, currentPrice);\n', '\n', '        if (totalSupply() == 0 || tokenPrice() == 0) {\n', '            splitFactor = 10**18;\n', '            currentPrice = initialPrice;\n', '        }\n', '\n', '        if (balanceOf(msg.sender) > 0) {\n', '            checkpointPrices_[msg.sender] = denormalize(currentPrice);\n', '        } else {\n', '            checkpointPrices_[msg.sender] = 0;\n', '        }\n', '\n', '        return loanAmountOwed;\n', '    }\n', '\n', '    function _triggerPosition(\n', '        uint256 amount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        uint256 assetBalance = ERC20(loanTokenAddress).balanceOf(address(this));\n', '        if (assetBalance > 0) {\n', '            uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), bZxVault);\n', '            if (tempAllowance < assetBalance) {\n', '                if (tempAllowance > 0) {\n', '                    // reset approval to 0\n', '                    require(ERC20(loanTokenAddress).approve(bZxVault, 0), "token approval reset failed");\n', '                }\n', '\n', '                require(ERC20(loanTokenAddress).approve(bZxVault, MAX_UINT), "token approval failed");\n', '            }\n', '\n', '            (bool result,) = loanTokenLender.call.gas(gasleft())(\n', '                abi.encodeWithSignature(\n', '                    "borrowTokenFromEscrow(uint256,uint256,address,bool)",\n', '                    amount == 0 || amount > assetBalance ? assetBalance : amount,\n', '                    leverageAmount,\n', '                    tradeTokenAddress,\n', '                    false\n', '                )\n', '            );\n', '            return result;\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    /* Internal View functions */\n', '\n', '    function _tokenPrice(\n', '        uint256 netCollateralAmount,\n', '        uint256 interestDepositRemaining)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupply_ > 0 ?\n', '            normalize(\n', '                ERC20(loanTokenAddress).balanceOf(address(this))\n', '                .add(netCollateralAmount)\n', '                .add(interestDepositRemaining)\n', '                .mul(10**28) // 10**18 * 10**(18-8) - WBTC adjust\n', '                .div(totalSupply_)\n', '            ) : initialPrice;\n', '    }\n', '\n', '\n', '    /* Owner-Only functions */\n', '\n', '    function setLoanTokenLender(\n', '        address _lender)\n', '        public\n', '        onlyOwner\n', '    {\n', '        loanTokenLender = _lender;\n', '    }\n', '\n', '    function setBZxContract(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxContract = _addr;\n', '    }\n', '\n', '    function setBZxVault(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxVault = _addr;\n', '    }\n', '\n', '    function setBZxOracle(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxOracle = _addr;\n', '    }\n', '\n', '    function setWETHContract(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        wethContract = _addr;\n', '    }\n', '\n', '    function setLoanTokenAddress(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        loanTokenAddress = _addr;\n', '    }\n', '\n', '    function setTradeTokenAddress(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        tradeTokenAddress = _addr;\n', '    }\n', '\n', '    function setInitialPrice(\n', '        uint256 _value)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_value > 0, "value can&#39;t be 0");\n', '        initialPrice = _value;\n', '    }\n', '\n', '    function setSplitValue(\n', '        uint256 _value)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_value > 0, "value can&#39;t be 0");\n', '        splitFactor = _value;\n', '    }\n', '\n', '    function handleSplit()\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (totalSupply() > 0) {\n', '            splitFactor = splitFactor\n', '                .mul(initialPrice)\n', '                .div(\n', '                    tokenPrice()\n', '                );\n', '        } else {\n', '            splitFactor = 10**18;\n', '        }\n', '    }\n', '\n', '    function migratePrecision(\n', '        address[] memory _users)\n', '        public\n', '        onlyOwner\n', '    {\n', '        uint256 balanceSeen;\n', '        for (uint256 i = 0; i < _users.length; i++) {\n', '            balanceSeen += balances[_users[i]];\n', '            balances[_users[i]] *= 10**10;\n', '        }\n', '        require(balanceSeen == totalSupply_, "balance mismatch");\n', '\n', '        totalSupply_ *= 10**10;\n', '        decimals = 18;\n', '    }\n', '\n', '    function depositCollateralToLoanFromBalance(\n', '        uint256 amount)\n', '        external\n', '        nonReentrant\n', '    {\n', '        uint256 assetBalance = ERC20(loanTokenAddress).balanceOf(address(this));\n', '        uint256 depositAmount = amount == 0 || amount > assetBalance ?\n', '            assetBalance :\n', '            amount;\n', '\n', '        uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), bZxVault);\n', '        if (tempAllowance < depositAmount) {\n', '            if (tempAllowance > 0) {\n', '                // reset approval to 0\n', '                require(ERC20(loanTokenAddress).approve(bZxVault, 0), "token approval reset failed");\n', '            }\n', '\n', '            require(ERC20(loanTokenAddress).approve(bZxVault, MAX_UINT), "token approval failed");\n', '        }\n', '\n', '        require(IBZx(bZxContract).depositCollateral(\n', '            loanOrderHash,\n', '            loanTokenAddress,\n', '            depositAmount\n', '        ), "deposit failed");\n', '    }\n', '\n', '    // depositTokenAddress is swapped to loanTokenAddress if needed in the protocol\n', '    // this is callable by anyone that wants to top up the collateral\n', '    function depositCollateralToLoan(\n', '        address depositTokenAddress,\n', '        uint256 depositAmount)\n', '        external\n', '        nonReentrant\n', '    {\n', '        require(ERC20(depositTokenAddress).transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            depositAmount\n', '        ), "transfer of token failed");\n', '\n', '        uint256 tempAllowance = ERC20(depositTokenAddress).allowance(address(this), bZxVault);\n', '        if (tempAllowance < depositAmount) {\n', '            if (tempAllowance > 0) {\n', '                // reset approval to 0\n', '                require(ERC20(depositTokenAddress).approve(bZxVault, 0), "token approval reset failed");\n', '            }\n', '\n', '            require(ERC20(depositTokenAddress).approve(bZxVault, MAX_UINT), "token approval failed");\n', '        }\n', '\n', '        require(IBZx(bZxContract).depositCollateral(\n', '            loanOrderHash,\n', '            depositTokenAddress,\n', '            depositAmount\n', '        ), "deposit failed");\n', '    }\n', '\n', '    // depositTokenAddress is swapped to tradeTokenAddress if needed in the protocol\n', '    // this is callable by anyone that wants to top up the position\n', '    function depositPositionToLoan(\n', '        address depositTokenAddress,\n', '        uint256 depositAmount)\n', '        external\n', '        nonReentrant\n', '    {\n', '        require(ERC20(depositTokenAddress).transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            depositAmount\n', '        ), "transfer of token failed");\n', '\n', '        uint256 tempAllowance = ERC20(depositTokenAddress).allowance(address(this), bZxVault);\n', '        if (tempAllowance < depositAmount) {\n', '            if (tempAllowance > 0) {\n', '                // reset approval to 0\n', '                require(ERC20(depositTokenAddress).approve(bZxVault, 0), "token approval reset failed");\n', '            }\n', '\n', '            require(ERC20(depositTokenAddress).approve(bZxVault, MAX_UINT), "token approval failed");\n', '        }\n', '\n', '        require(IBZx(bZxContract).depositPosition(\n', '            loanOrderHash,\n', '            depositTokenAddress,\n', '            depositAmount\n', '        ), "deposit failed");\n', '    }\n', '}']