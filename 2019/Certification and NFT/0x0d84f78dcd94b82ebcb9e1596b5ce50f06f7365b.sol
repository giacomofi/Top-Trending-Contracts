['pragma solidity 0.4.24;\n', '\n', '/// @title Ownable\n', '/// @dev Provide a modifier that permits only a single user to call the function\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @dev Set the original `owner` of the contract to the sender account.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Require that the modified function is only called by `owner`\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev Allow `owner` to transfer control of the contract to `newOwner`.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/// @title SafeMath\n', '/// @dev Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '    /// @dev Multiply two numbers, throw on overflow.\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /// @dev Substract two numbers, throw on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Add two numbers, throw on overflow.\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title Whitelist\n', '/// @dev Handle whitelisting, maximum purchase limits, and bonus calculation for PLGCrowdsale\n', 'contract Whitelist is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /// A participant in the crowdsale\n', '    struct Participant {\n', '        /// Percent of bonus tokens awarded to this participant\n', '        uint256 bonusPercent;\n', '        /// Maximum amount the participant can contribute in wei\n', '        uint256 maxPurchaseAmount;\n', '        /// Wei contributed to the crowdsale so far\n', '        uint256 weiContributed;\n', '    }\n', '\n', '    /// Crowdsale address, used to authorize purchase records\n', '    address public crowdsaleAddress;\n', '\n', '    /// Bonus/Vesting for specific accounts\n', '    /// If Participant.maxPurchaseAmount is zero, the address is not whitelisted\n', '    mapping(address => Participant) private participants;\n', '\n', '    /// @notice Set the crowdsale address. Only one crowdsale at a time may use this whitelist\n', '    /// @param crowdsale The address of the crowdsale\n', '    function setCrowdsale(address crowdsale) public onlyOwner {\n', '        require(crowdsale != address(0));\n', '        crowdsaleAddress = crowdsale;\n', '    }\n', '\n', '    /// @notice Get the bonus token percentage for `user`\n', '    /// @param user The address of a crowdsale participant\n', '    /// @return The percentage of bonus tokens `user` qualifies for\n', '    function getBonusPercent(address user) public view returns(uint256) {\n', '        return participants[user].bonusPercent;\n', '    }\n', '\n', '    /// @notice Check if an address is whitelisted\n', '    /// @param user Potential participant\n', '    /// @return Whether `user` may participate in the crowdsale\n', '    function isValidPurchase(address user, uint256 weiAmount) public view returns(bool) {\n', '        require(user != address(0));\n', '        Participant storage participant = participants[user];\n', '        if(participant.maxPurchaseAmount == 0) {\n', '            return false;\n', '        }\n', '        return participant.weiContributed.add(weiAmount) <= participant.maxPurchaseAmount;\n', '    }\n', '\n', '    /// @notice Whitelist a crowdsale participant\n', '    /// @notice Do not override weiContributed if the user has previously been whitelisted\n', '    /// @param user The participant to add\n', "    /// @param bonusPercent The user's bonus percentage\n", '    /// @param maxPurchaseAmount The maximum the participant is allowed to contribute in wei\n', '    ///     If zero, the user is de-whitelisted\n', '    function addParticipant(address user, uint256 bonusPercent, uint256 maxPurchaseAmount) external onlyOwner {\n', '        require(user != address(0));\n', '        participants[user].bonusPercent = bonusPercent;\n', '        participants[user].maxPurchaseAmount = maxPurchaseAmount;\n', '    }\n', '\n', '    /// @notice Whitelist multiple crowdsale participants at once with the same bonus/purchase amount\n', '    /// @param users The participants to add\n', '    /// @param bonusPercent The bonus percentage shared among users\n', '    /// @param maxPurchaseAmount The maximum each participant is allowed to contribute in wei\n', '    function addParticipants(address[] users, uint256 bonusPercent, uint256 maxPurchaseAmount) external onlyOwner {\n', '        \n', '        for(uint i=0; i<users.length; i+=1) {\n', '            require(users[i] != address(0));\n', '            participants[users[i]].bonusPercent = bonusPercent;\n', '            participants[users[i]].maxPurchaseAmount = maxPurchaseAmount;\n', '        }\n', '    }\n', '\n', '    /// @notice De-whitelist a crowdsale participant\n', '    /// @param user The participant to revoke\n', '    function revokeParticipant(address user) external onlyOwner {\n', '        require(user != address(0));\n', '        participants[user].maxPurchaseAmount = 0;\n', '    }\n', '\n', '    /// @notice De-whitelist multiple crowdsale participants at once\n', '    /// @param users The participants to revoke\n', '    function revokeParticipants(address[] users) external onlyOwner {\n', '        \n', '        for(uint i=0; i<users.length; i+=1) {\n', '            require(users[i] != address(0));\n', '            participants[users[i]].maxPurchaseAmount = 0;\n', '        }\n', '    }\n', '\n', '    function recordPurchase(address beneficiary, uint256 weiAmount) public {\n', '\n', '        require(msg.sender == crowdsaleAddress);\n', '\n', '        Participant storage participant = participants[beneficiary];\n', '        participant.weiContributed = participant.weiContributed.add(weiAmount);\n', '    }\n', '    \n', '}']