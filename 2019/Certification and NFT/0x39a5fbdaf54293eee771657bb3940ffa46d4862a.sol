['pragma solidity ^0.5.7;\n', '\n', 'contract ProxyStorage {\n', '    address public powner;\n', '    address public pimplementation;\n', '}\n', '\n', 'interface IERC165 {\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '// File: contracts/core/diaspore/interfaces/Model.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', '\n', '/**\n', '    The abstract contract Model defines the whole lifecycle of a debt on the DebtEngine.\n', '\n', '    Models can be used without previous approbation, this is meant\n', '    to avoid centralization on the development of RCN; this implies that not all models are secure.\n', '    Models can have back-doors, bugs and they have not guarantee of being autonomous.\n', '\n', '    The DebtEngine is meant to be the User of this model,\n', '    so all the methods with the ability to perform state changes should only be callable by the DebtEngine.\n', '\n', '    All models should implement the 0xaf498c35 interface.\n', '\n', '    @author Agustin Aguilar\n', '*/\n', 'contract Model is IERC165 {\n', '    // ///\n', '    // Events\n', '    // ///\n', '\n', '    /**\n', '        @dev This emits when create a new debt.\n', '    */\n', '    event Created(bytes32 indexed _id);\n', '\n', '    /**\n', '        @dev This emits when the status of debt change.\n', '\n', '        @param _timestamp Timestamp of the registry\n', '        @param _status New status of the registry\n', '    */\n', '    event ChangedStatus(bytes32 indexed _id, uint256 _timestamp, uint256 _status);\n', '\n', '    /**\n', '        @dev This emits when the obligation of debt change.\n', '\n', '        @param _timestamp Timestamp of the registry\n', '        @param _debt New debt of the registry\n', '    */\n', '    event ChangedObligation(bytes32 indexed _id, uint256 _timestamp, uint256 _debt);\n', '\n', '    /**\n', '        @dev This emits when the frequency of debt change.\n', '\n', '        @param _timestamp Timestamp of the registry\n', '        @param _frequency New frequency of each installment\n', '    */\n', '    event ChangedFrequency(bytes32 indexed _id, uint256 _timestamp, uint256 _frequency);\n', '\n', '    /**\n', '        @param _timestamp Timestamp of the registry\n', '    */\n', '    event ChangedDueTime(bytes32 indexed _id, uint256 _timestamp, uint256 _status);\n', '\n', '    /**\n', '        @param _timestamp Timestamp of the registry\n', '        @param _dueTime New dueTime of each installment\n', '    */\n', '    event ChangedFinalTime(bytes32 indexed _id, uint256 _timestamp, uint64 _dueTime);\n', '\n', '    /**\n', '        @dev This emits when the call addDebt function.\n', '\n', '        @param _amount New amount of the debt, old amount plus added\n', '    */\n', '    event AddedDebt(bytes32 indexed _id, uint256 _amount);\n', '\n', '    /**\n', '        @dev This emits when the call addPaid function.\n', '\n', '        If the registry is fully paid on the call and the amount parameter exceeds the required\n', '            payment amount, the event emits the real amount paid on the payment.\n', '\n', '        @param _paid Real amount paid\n', '    */\n', '    event AddedPaid(bytes32 indexed _id, uint256 _paid);\n', '\n', '    // Model interface selector\n', '    bytes4 internal constant MODEL_INTERFACE = 0xaf498c35;\n', '\n', '    uint256 public constant STATUS_ONGOING = 1;\n', '    uint256 public constant STATUS_PAID = 2;\n', '    uint256 public constant STATUS_ERROR = 4;\n', '\n', '    // ///\n', '    // Meta\n', '    // ///\n', '\n', '    /**\n', '        @return Identifier of the model\n', '    */\n', '    function modelId() external view returns (bytes32);\n', '\n', '    /**\n', '        Returns the address of the contract used as Descriptor of the model\n', '\n', '        @dev The descriptor contract should follow the ModelDescriptor.sol scheme\n', '\n', '        @return Address of the descriptor\n', '    */\n', '    function descriptor() external view returns (address);\n', '\n', '    /**\n', '        If called for any address with the ability to modify the state of the model registries,\n', '            this method should return True.\n', '\n', '        @dev Some contracts may check if the DebtEngine is\n', '            an operator to know if the model is operative or not.\n', '\n', '        @param operator Address of the target request operator\n', '\n', '        @return True if operator is able to modify the state of the model\n', '    */\n', '    function isOperator(address operator) external view returns (bool canOperate);\n', '\n', '    /**\n', '        Validates the data for the creation of a new registry, if returns True the\n', '            same data should be compatible with the create method.\n', '\n', '        @dev This method can revert the call or return false, and both meant an invalid data.\n', '\n', '        @param data Data to validate\n', '\n', '        @return True if the data can be used to create a new registry\n', '    */\n', '    function validate(bytes calldata data) external view returns (bool isValid);\n', '\n', '    // ///\n', '    // Getters\n', '    // ///\n', '\n', '    /**\n', '        Exposes the current status of the registry. The possible values are:\n', '\n', '        1: Ongoing - The debt is still ongoing and waiting to be paid\n', '        2: Paid - The debt is already paid and\n', '        4: Error - There was an Error with the registry\n', '\n', '        @dev This method should always be called by the DebtEngine\n', '\n', '        @param id Id of the registry\n', '\n', '        @return The current status value\n', '    */\n', '    function getStatus(bytes32 id) external view returns (uint256 status);\n', '\n', '    /**\n', '        Returns the total paid amount on the registry.\n', '\n', '        @dev it should equal to the sum of all real addPaid\n', '\n', '        @param id Id of the registry\n', '\n', '        @return Total paid amount\n', '    */\n', '    function getPaid(bytes32 id) external view returns (uint256 paid);\n', '\n', '    /**\n', '        If the returned amount does not depend on any interactions and only on the model logic,\n', '            the defined flag will be True; if the amount is an estimation of the future debt,\n', '            the flag will be set to False.\n', '\n', '        If timestamp equals the current moment, the defined flag should always be True.\n', '\n', '        @dev This can be a gas-intensive method to call, consider calling the run method before.\n', '\n', '        @param id Id of the registry\n', '        @param timestamp Timestamp of the obligation query\n', '\n', '        @return amount Amount pending to pay on the given timestamp\n', "        @return defined True If the amount returned is fixed and can't change\n", '    */\n', '    function getObligation(bytes32 id, uint64 timestamp) external view returns (uint256 amount, bool defined);\n', '\n', '    /**\n', '        The amount required to fully paid a registry.\n', '\n', '        All registries should be payable in a single time, even when it has multiple installments.\n', '\n', '        If the registry discounts interest for early payment, those discounts should be\n', '            taken into account in the returned amount.\n', '\n', '        @dev This can be a gas-intensive method to call, consider calling the run method before.\n', '\n', '        @param id Id of the registry\n', '\n', '        @return amount Amount required to fully paid the loan on the current timestamp\n', '    */\n', '    function getClosingObligation(bytes32 id) external view returns (uint256 amount);\n', '\n', '    /**\n', '        The timestamp of the next required payment.\n', '\n', '        After this moment, if the payment goal is not met the debt will be considered overdue.\n', '\n', '            The getObligation method can be used to know the required payment on the future timestamp.\n', '\n', '        @param id Id of the registry\n', '\n', '        @return timestamp The timestamp of the next due time\n', '    */\n', '    function getDueTime(bytes32 id) external view returns (uint256 timestamp);\n', '\n', '    // ///\n', '    // Metadata\n', '    // ///\n', '\n', '    /**\n', '        If the loan has multiple installments returns the duration of each installment in seconds,\n', '            if the loan has not installments it should return 1.\n', '\n', '        @param id Id of the registry\n', '\n', '        @return frequency Frequency of each installment\n', '    */\n', '    function getFrequency(bytes32 id) external view returns (uint256 frequency);\n', '\n', '    /**\n', '        If the loan has multiple installments returns the total of installments,\n', '            if the loan has not installments it should return 1.\n', '\n', '        @param id Id of the registry\n', '\n', '        @return installments Total of installments\n', '    */\n', '    function getInstallments(bytes32 id) external view returns (uint256 installments);\n', '\n', '    /**\n', '        The registry could be paid before or after the date, but the debt will always be\n', '            considered overdue if paid after this timestamp.\n', '\n', "        This is the estimated final payment date of the debt if it's always paid on each exact dueTime.\n", '\n', '        @param id Id of the registry\n', '\n', '        @return timestamp Timestamp of the final due time\n', '    */\n', '    function getFinalTime(bytes32 id) external view returns (uint256 timestamp);\n', '\n', '    /**\n', '        Similar to getFinalTime returns the expected payment remaining if paid always on the exact dueTime.\n', '\n', '        If the model has no interest discounts for early payments,\n', '            this method should return the same value as getClosingObligation.\n', '\n', '        @param id Id of the registry\n', '\n', '        @return amount Expected payment amount\n', '    */\n', '    function getEstimateObligation(bytes32 id) external view returns (uint256 amount);\n', '\n', '    // ///\n', '    // State interface\n', '    // ///\n', '\n', '    /**\n', '        Creates a new registry using the provided data and id, it should fail if the id already exists\n', '            or if calling validate(data) returns false or throws.\n', '\n', '        @dev This method should only be callable by an operator\n', '\n', '        @param id Id of the registry to create\n', '        @param data Data to construct the new registry\n', '\n', '        @return success True if the registry was created\n', '    */\n', '    function create(bytes32 id, bytes calldata data) external returns (bool success);\n', '\n', '    /**\n', '        If the registry is fully paid on the call and the amount parameter exceeds the required\n', '            payment amount, the method returns the real amount used on the payment.\n', '\n', '        The payment taken should always be the same as the requested unless the registry\n', '            is fully paid on the process.\n', '\n', '        @dev This method should only be callable by an operator\n', '\n', '        @param id If of the registry\n', '        @param amount Amount to pay\n', '\n', '        @return real Real amount paid\n', '    */\n', '    function addPaid(bytes32 id, uint256 amount) external returns (uint256 real);\n', '\n', '    /**\n', '        Adds a new amount to be paid on the debt model,\n', '            each model can handle the addition of more debt freely.\n', '\n', '        @dev This method should only be callable by an operator\n', '\n', '        @param id Id of the registry\n', '        @param amount Debt amount to add to the registry\n', '\n', '        @return added True if the debt was added\n', '    */\n', '    function addDebt(bytes32 id, uint256 amount) external returns (bool added);\n', '\n', '    // ///\n', '    // Utils\n', '    // ///\n', '\n', '    /**\n', '        Runs the internal clock of a registry, this is used to compute the last changes on the state.\n', '            It can make transactions cheaper by avoiding multiple calculations when calling views.\n', '\n', '        Not all models have internal clocks, a model without an internal clock should always return false.\n', '\n', '        Calls to this method should be possible from any address,\n', "            multiple calls to run shouldn't affect the internal calculations of the model.\n", '\n', '        @dev If the call had no effect the method would return False,\n', "            that is no sign of things going wrong, and the call shouldn't be wrapped on a require\n", '\n', '        @param id If of the registry\n', '\n', '        @return effect True if the run performed a change on the state\n', '    */\n', '    function run(bytes32 id) external returns (bool effect);\n', '}\n', '\n', '// File: contracts/core/diaspore/interfaces/ModelDescriptor.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', 'contract ModelDescriptor {\n', '    bytes4 internal constant MODEL_DESCRIPTOR_INTERFACE = 0x02735375;\n', '\n', '    function simFirstObligation(bytes calldata data) external view returns (uint256 amount, uint256 time);\n', '    function simTotalObligation(bytes calldata data) external view returns (uint256 amount);\n', '    function simDuration(bytes calldata data) external view returns (uint256 duration);\n', '    function simPunitiveInterestRate(bytes calldata data) external view returns (uint256 punitiveInterestRate);\n', '    function simFrequency(bytes calldata data) external view returns (uint256 frequency);\n', '    function simInstallments(bytes calldata data) external view returns (uint256 installments);\n', '}\n', '\n', '// File: contracts/interfaces/IERC173.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', '/// @title ERC-173 Contract Ownership Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n', '///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n', 'contract IERC173 {\n', '    /// @dev This emits when ownership of a contract changes.\n', '    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '    /// @notice Get the address of the owner\n', '    /// @return The address of the owner.\n', '    //// function owner() external view returns (address);\n', '\n', '    /// @notice Set the address of the new owner of the contract\n', '    /// @param _newOwner The address of the new owner of the contract\n', '    function transferOwnership2(address _newOwner) external;\n', '}\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', 'contract Initable {\n', '    bool public inited;\n', '    \n', '    modifier initer() {\n', '        require(inited == false, "Already inited");\n', '        _;\n', '        inited = true;\n', '    }\n', '    \n', '    function init() public initer { }\n', '}\n', '\n', '// File: contracts/commons/Ownable.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', '\n', 'contract Ownable is Initable, IERC173 {\n', '    address internal _owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _owner, "The owner should be the sender");\n', '        _;\n', '    }\n', '\n', '    function init() public initer {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0x0), msg.sender);\n', '        super.init();\n', '    }\n', '\n', '    function owner2() external view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _newOwner Address of the new owner\n', '    */\n', '    function transferOwnership2(address _newOwner) external onlyOwner {\n', '        require(_newOwner != address(0), "0x0 Is not a valid owner");\n', '        emit OwnershipTransferred(_owner, _newOwner);\n', '        _owner = _newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/commons/ERC165.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is Initable, IERC165 {\n', '    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n', '    /**\n', '    * 0x01ffc9a7 ===\n', "    *   bytes4(keccak256('supportsInterface(bytes4)'))\n", '    */\n', '\n', '    /**\n', "    * @dev a mapping of interface id to whether or not it's supported\n", '    */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '    * @dev A contract implementing SupportsInterfaceWithLookup\n', '    * implement ERC165 itself\n', '    */\n', '    function init() public initer {\n', '        _registerInterface(_InterfaceId_ERC165);\n', '        super.init();\n', '    }\n', '\n', '    /**\n', '    * @dev implement supportsInterface(bytes4) using a lookup table\n', '    */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '    * @dev internal method for registering an interface\n', '    */\n', '    function _registerInterface(bytes4 interfaceId)\n', '        internal\n', '    {\n', '        require(interfaceId != 0xffffffff, "Can\'t register 0xffffffff");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/utils/BytesUtils.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', 'contract BytesUtils {\n', '    function readBytes32(bytes memory data, uint256 index) internal pure returns (bytes32 o) {\n', '        require(data.length / 32 > index, "Reading bytes out of bounds");\n', '        assembly {\n', '            o := mload(add(data, add(32, mul(32, index))))\n', '        }\n', '    }\n', '\n', '    function read(bytes memory data, uint256 offset, uint256 length) internal pure returns (bytes32 o) {\n', '        require(data.length >= offset + length, "Reading bytes out of bounds");\n', '        assembly {\n', '            o := mload(add(data, add(32, offset)))\n', '            let lb := sub(32, length)\n', '            if lb { o := div(o, exp(2, mul(lb, 8))) }\n', '        }\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la\n', '    ) internal pure returns (bytes32 _a) {\n', '        require(_data.length >= _la, "Reading bytes out of bounds");\n', '        assembly {\n', '            _a := mload(add(_data, 32))\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '        }\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la,\n', '        uint256 _lb\n', '    ) internal pure returns (bytes32 _a, bytes32 _b) {\n', '        uint256 o;\n', '        assembly {\n', '            let s := add(_data, 32)\n', '            _a := mload(s)\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '            o := add(s, _la)\n', '            _b := mload(o)\n', '            l := sub(32, _lb)\n', '            if l { _b := div(_b, exp(2, mul(l, 8))) }\n', '            o := sub(o, s)\n', '        }\n', '        require(_data.length >= o, "Reading bytes out of bounds");\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la,\n', '        uint256 _lb,\n', '        uint256 _lc\n', '    ) internal pure returns (bytes32 _a, bytes32 _b, bytes32 _c) {\n', '        uint256 o;\n', '        assembly {\n', '            let s := add(_data, 32)\n', '            _a := mload(s)\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '            o := add(s, _la)\n', '            _b := mload(o)\n', '            l := sub(32, _lb)\n', '            if l { _b := div(_b, exp(2, mul(l, 8))) }\n', '            o := add(o, _lb)\n', '            _c := mload(o)\n', '            l := sub(32, _lc)\n', '            if l { _c := div(_c, exp(2, mul(l, 8))) }\n', '            o := sub(o, s)\n', '        }\n', '        require(_data.length >= o, "Reading bytes out of bounds");\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la,\n', '        uint256 _lb,\n', '        uint256 _lc,\n', '        uint256 _ld\n', '    ) internal pure returns (bytes32 _a, bytes32 _b, bytes32 _c, bytes32 _d) {\n', '        uint256 o;\n', '        assembly {\n', '            let s := add(_data, 32)\n', '            _a := mload(s)\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '            o := add(s, _la)\n', '            _b := mload(o)\n', '            l := sub(32, _lb)\n', '            if l { _b := div(_b, exp(2, mul(l, 8))) }\n', '            o := add(o, _lb)\n', '            _c := mload(o)\n', '            l := sub(32, _lc)\n', '            if l { _c := div(_c, exp(2, mul(l, 8))) }\n', '            o := add(o, _lc)\n', '            _d := mload(o)\n', '            l := sub(32, _ld)\n', '            if l { _d := div(_d, exp(2, mul(l, 8))) }\n', '            o := sub(o, s)\n', '        }\n', '        require(_data.length >= o, "Reading bytes out of bounds");\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la,\n', '        uint256 _lb,\n', '        uint256 _lc,\n', '        uint256 _ld,\n', '        uint256 _le\n', '    ) internal pure returns (bytes32 _a, bytes32 _b, bytes32 _c, bytes32 _d, bytes32 _e) {\n', '        uint256 o;\n', '        assembly {\n', '            let s := add(_data, 32)\n', '            _a := mload(s)\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '            o := add(s, _la)\n', '            _b := mload(o)\n', '            l := sub(32, _lb)\n', '            if l { _b := div(_b, exp(2, mul(l, 8))) }\n', '            o := add(o, _lb)\n', '            _c := mload(o)\n', '            l := sub(32, _lc)\n', '            if l { _c := div(_c, exp(2, mul(l, 8))) }\n', '            o := add(o, _lc)\n', '            _d := mload(o)\n', '            l := sub(32, _ld)\n', '            if l { _d := div(_d, exp(2, mul(l, 8))) }\n', '            o := add(o, _ld)\n', '            _e := mload(o)\n', '            l := sub(32, _le)\n', '            if l { _e := div(_e, exp(2, mul(l, 8))) }\n', '            o := sub(o, s)\n', '        }\n', '        require(_data.length >= o, "Reading bytes out of bounds");\n', '    }\n', '\n', '    function decode(\n', '        bytes memory _data,\n', '        uint256 _la,\n', '        uint256 _lb,\n', '        uint256 _lc,\n', '        uint256 _ld,\n', '        uint256 _le,\n', '        uint256 _lf\n', '    ) internal pure returns (\n', '        bytes32 _a,\n', '        bytes32 _b,\n', '        bytes32 _c,\n', '        bytes32 _d,\n', '        bytes32 _e,\n', '        bytes32 _f\n', '    ) {\n', '        uint256 o;\n', '        assembly {\n', '            let s := add(_data, 32)\n', '            _a := mload(s)\n', '            let l := sub(32, _la)\n', '            if l { _a := div(_a, exp(2, mul(l, 8))) }\n', '            o := add(s, _la)\n', '            _b := mload(o)\n', '            l := sub(32, _lb)\n', '            if l { _b := div(_b, exp(2, mul(l, 8))) }\n', '            o := add(o, _lb)\n', '            _c := mload(o)\n', '            l := sub(32, _lc)\n', '            if l { _c := div(_c, exp(2, mul(l, 8))) }\n', '            o := add(o, _lc)\n', '            _d := mload(o)\n', '            l := sub(32, _ld)\n', '            if l { _d := div(_d, exp(2, mul(l, 8))) }\n', '            o := add(o, _ld)\n', '            _e := mload(o)\n', '            l := sub(32, _le)\n', '            if l { _e := div(_e, exp(2, mul(l, 8))) }\n', '            o := add(o, _le)\n', '            _f := mload(o)\n', '            l := sub(32, _lf)\n', '            if l { _f := div(_f, exp(2, mul(l, 8))) }\n', '            o := sub(o, s)\n', '        }\n', '        require(_data.length >= o, "Reading bytes out of bounds");\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/core/diaspore/model/InstallmentsModel.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', 'contract InstallmentsModel is ProxyStorage, Initable, ERC165, BytesUtils, Ownable, Model, ModelDescriptor {\n', '    mapping(bytes4 => bool) private _supportedInterface;\n', '\n', '    function init() public initer {\n', '        _registerInterface(MODEL_INTERFACE);\n', '        _registerInterface(MODEL_DESCRIPTOR_INTERFACE);\n', '        super.init();\n', '    }\n', '\n', '    address public engine;\n', '    address private altDescriptor;\n', '\n', '    mapping(bytes32 => Config) public configs;\n', '    mapping(bytes32 => State) public states;\n', '\n', '    uint256 public constant L_DATA = 16 + 32 + 3 + 5 + 4;\n', '\n', '    uint256 private constant U_128_OVERFLOW = 2 ** 128;\n', '    uint256 private constant U_64_OVERFLOW = 2 ** 64;\n', '    uint256 private constant U_40_OVERFLOW = 2 ** 40;\n', '    uint256 private constant U_24_OVERFLOW = 2 ** 24;\n', '\n', '    event _setEngine(address _engine);\n', '    event _setDescriptor(address _descriptor);\n', '\n', '    event _setClock(bytes32 _id, uint64 _to);\n', '    event _setPaidBase(bytes32 _id, uint128 _paidBase);\n', '    event _setInterest(bytes32 _id, uint128 _interest);\n', '\n', '    struct Config {\n', '        uint24 installments;\n', '        uint32 timeUnit;\n', '        uint40 duration;\n', '        uint64 lentTime;\n', '        uint128 cuota;\n', '        uint256 interestRate;\n', '    }\n', '\n', '    struct State {\n', '        uint8 status;\n', '        uint64 clock;\n', '        uint64 lastPayment;\n', '        uint128 paid;\n', '        uint128 paidBase;\n', '        uint128 interest;\n', '    }\n', '\n', '    modifier onlyEngine {\n', '        require(msg.sender == engine, "Only engine allowed");\n', '        _;\n', '    }\n', '\n', '    function modelId() external view returns (bytes32) {\n', '        // InstallmentsModel A 0.0.2\n', '        return bytes32(0x00000000000000496e7374616c6c6d656e74734d6f64656c204120302e302e32);\n', '    }\n', '\n', '    function descriptor() external view returns (address) {\n', '        address _descriptor = altDescriptor;\n', '        return _descriptor == address(0) ? address(this) : _descriptor;\n', '    }\n', '\n', '    function setEngine(address _engine) external onlyOwner returns (bool) {\n', '        engine = _engine;\n', '        emit _setEngine(_engine);\n', '        return true;\n', '    }\n', '\n', '    function setDescriptor(address _descriptor) external onlyOwner returns (bool) {\n', '        altDescriptor = _descriptor;\n', '        emit _setDescriptor(_descriptor);\n', '        return true;\n', '    }\n', '\n', '    function encodeData(\n', '        uint128 _cuota,\n', '        uint256 _interestRate,\n', '        uint24 _installments,\n', '        uint40 _duration,\n', '        uint32 _timeUnit\n', '    ) external pure returns (bytes memory) {\n', '        return abi.encodePacked(_cuota, _interestRate, _installments, _duration, _timeUnit);\n', '    }\n', '\n', '    function create(bytes32 id, bytes calldata data) external onlyEngine returns (bool) {\n', '        require(configs[id].cuota == 0, "Entry already exist");\n', '\n', '        (uint128 cuota, uint256 interestRate, uint24 installments, uint40 duration, uint32 timeUnit) = _decodeData(data);\n', '        _validate(cuota, interestRate, installments, duration, timeUnit);\n', '\n', '        configs[id] = Config({\n', '            installments: installments,\n', '            duration: duration,\n', '            lentTime: uint64(now),\n', '            cuota: cuota,\n', '            interestRate: interestRate,\n', '            timeUnit: timeUnit\n', '        });\n', '\n', '        states[id].clock = duration;\n', '\n', '        emit Created(id);\n', '        emit _setClock(id, duration);\n', '\n', '        return true;\n', '    }\n', '\n', '    function addPaid(bytes32 id, uint256 amount) external onlyEngine returns (uint256 real) {\n', '        Config storage config = configs[id];\n', '        State storage state = states[id];\n', '\n', '        _advanceClock(id, uint64(now) - config.lentTime);\n', '\n', '        if (state.status != STATUS_PAID) {\n', '            // State & config memory load\n', '            uint256 paid = state.paid;\n', '            uint256 duration = config.duration;\n', '            uint256 interest = state.interest;\n', '\n', '            // Payment aux\n', '            uint256 available = amount;\n', '            require(available < U_128_OVERFLOW, "Amount overflow");\n', '\n', '            // Aux variables\n', '            uint256 unpaidInterest;\n', '            uint256 pending;\n', '            uint256 target;\n', '            uint256 baseDebt;\n', '            uint256 clock;\n', '\n', '            do {\n', '                clock = state.clock;\n', '\n', '                baseDebt = _baseDebt(clock, duration, config.installments, config.cuota);\n', '                pending = baseDebt + interest - paid;\n', '\n', '                // min(pending, available)\n', '                target = pending < available ? pending : available;\n', '\n', '                // Calc paid base\n', '                unpaidInterest = interest - (paid - state.paidBase);\n', '\n', '                // max(target - unpaidInterest, 0)\n', '                state.paidBase += uint128(target > unpaidInterest ? target - unpaidInterest : 0);\n', '                emit _setPaidBase(id, state.paidBase);\n', '\n', '                paid += target;\n', '                available -= target;\n', '\n', '                // Check fully paid\n', '                // All installments paid + interest\n', '                if (clock / duration >= config.installments && baseDebt + interest <= paid) {\n', '                    // Registry paid!\n', '                    state.status = uint8(STATUS_PAID);\n', '                    emit ChangedStatus(id, now, STATUS_PAID);\n', '                    break;\n', '                }\n', '\n', '                // If installment fully paid, advance to next one\n', '                if (pending == target) {\n', '                    _advanceClock(id, clock + duration - (clock % duration));\n', '                }\n', '            } while (available != 0);\n', '\n', '            require(paid < U_128_OVERFLOW, "Paid overflow");\n', '            state.paid = uint128(paid);\n', '            state.lastPayment = state.clock;\n', '\n', '            real = amount - available;\n', '            emit AddedPaid(id, real);\n', '        }\n', '    }\n', '\n', '    function addDebt(bytes32 id, uint256 amount) external onlyEngine returns (bool) {\n', '        revert("Not implemented!");\n', '    }\n', '\n', '    function fixClock(bytes32 id, uint64 target) external returns (bool) {\n', '        require(target <= now, "Forbidden advance clock into the future");\n', '        Config storage config = configs[id];\n', '        State storage state = states[id];\n', '        uint64 lentTime = config.lentTime;\n', '        require(lentTime < target, "Clock can\'t go negative");\n', '        uint64 targetClock = target - lentTime;\n', '        require(targetClock > state.clock, "Clock is ahead of target");\n', '        return _advanceClock(id, targetClock);\n', '    }\n', '\n', '    function isOperator(address _target) external view returns (bool) {\n', '        return engine == _target;\n', '    }\n', '\n', '    function getStatus(bytes32 id) external view returns (uint256) {\n', '        Config storage config = configs[id];\n', '        State storage state = states[id];\n', '        require(config.lentTime != 0, "The registry does not exist");\n', '        return state.status == STATUS_PAID ? STATUS_PAID : STATUS_ONGOING;\n', '    }\n', '\n', '    function getPaid(bytes32 id) external view returns (uint256) {\n', '        return states[id].paid;\n', '    }\n', '\n', '    function getObligation(bytes32 id, uint64 timestamp) external view returns (uint256, bool) {\n', '        State storage state = states[id];\n', '        Config storage config = configs[id];\n', '\n', "        // Can't be before creation\n", '        if (timestamp < config.lentTime) {\n', '            return (0, true);\n', '        }\n', '\n', '        // Static storage loads\n', '        uint256 currentClock = timestamp - config.lentTime;\n', '\n', '        uint256 base = _baseDebt(\n', '            currentClock,\n', '            config.duration,\n', '            config.installments,\n', '            config.cuota\n', '        );\n', '\n', '        uint256 interest;\n', '        uint256 prevInterest = state.interest;\n', '        uint256 clock = state.clock;\n', '        bool defined;\n', '\n', '        if (clock >= currentClock) {\n', '            interest = prevInterest;\n', '            defined = true;\n', '        } else {\n', '            // We need to calculate the new interest, on a view!\n', '            (interest, currentClock) = _simRunClock(\n', '                clock,\n', '                currentClock,\n', '                prevInterest,\n', '                config,\n', '                state\n', '            );\n', '\n', '            defined = prevInterest == interest;\n', '        }\n', '\n', '        uint256 debt = base + interest;\n', '        uint256 paid = state.paid;\n', '        return (debt > paid ? debt - paid : 0, defined);\n', '    }\n', '\n', '    function _simRunClock(\n', '        uint256 _clock,\n', '        uint256 _targetClock,\n', '        uint256 _prevInterest,\n', '        Config memory _config,\n', '        State memory _state\n', '    ) internal pure returns (uint256 interest, uint256 clock) {\n', '        (interest, clock) = _runAdvanceClock({\n', '            _clock: _clock,\n', '            _timeUnit: _config.timeUnit,\n', '            _interest: _prevInterest,\n', '            _duration: _config.duration,\n', '            _cuota: _config.cuota,\n', '            _installments: _config.installments,\n', '            _paidBase: _state.paidBase,\n', '            _interestRate: _config.interestRate,\n', '            _targetClock: _targetClock\n', '        });\n', '    }\n', '\n', '    function run(bytes32 id) external returns (bool) {\n', '        Config storage config = configs[id];\n', '        return _advanceClock(id, uint64(now) - config.lentTime);\n', '    }\n', '\n', '    function validate(bytes calldata data) external view returns (bool) {\n', '        (uint128 cuota, uint256 interestRate, uint24 installments, uint40 duration, uint32 timeUnit) = _decodeData(data);\n', '        _validate(cuota, interestRate, installments, duration, timeUnit);\n', '        return true;\n', '    }\n', '\n', '    function getClosingObligation(bytes32 id) external view returns (uint256) {\n', '        return _getClosingObligation(id);\n', '    }\n', '\n', '    function getDueTime(bytes32 id) external view returns (uint256) {\n', '        Config storage config = configs[id];\n', '        if (config.cuota == 0)\n', '            return 0;\n', '        uint256 last = states[id].lastPayment;\n', '        uint256 duration = config.duration;\n', '        last = last != 0 ? last : duration;\n', '        return last - (last % duration) + config.lentTime;\n', '    }\n', '\n', '    function getFinalTime(bytes32 id) external view returns (uint256) {\n', '        Config storage config = configs[id];\n', '        return config.lentTime + (uint256(config.duration) * (uint256(config.installments)));\n', '    }\n', '\n', '    function getFrequency(bytes32 id) external view returns (uint256) {\n', '        return configs[id].duration;\n', '    }\n', '\n', '    function getInstallments(bytes32 id) external view returns (uint256) {\n', '        return configs[id].installments;\n', '    }\n', '\n', '    function getEstimateObligation(bytes32 id) external view returns (uint256) {\n', '        return _getClosingObligation(id);\n', '    }\n', '\n', '    function simFirstObligation(bytes calldata _data) external view returns (uint256 amount, uint256 time) {\n', '        (amount,,, time,) = _decodeData(_data);\n', '    }\n', '\n', '    function simTotalObligation(bytes calldata _data) external view returns (uint256 amount) {\n', '        (uint256 cuota,, uint256 installments,,) = _decodeData(_data);\n', '        amount = cuota * installments;\n', '    }\n', '\n', '    function simDuration(bytes calldata _data) external view returns (uint256 duration) {\n', '        (,,uint256 installments, uint256 installmentDuration,) = _decodeData(_data);\n', '        duration = installmentDuration * installments;\n', '    }\n', '\n', '    function simPunitiveInterestRate(bytes calldata _data) external view returns (uint256 punitiveInterestRate) {\n', '        (,punitiveInterestRate,,,) = _decodeData(_data);\n', '    }\n', '\n', '    function simFrequency(bytes calldata _data) external view returns (uint256 frequency) {\n', '        (,,, frequency,) = _decodeData(_data);\n', '    }\n', '\n', '    function simInstallments(bytes calldata _data) external view returns (uint256 installments) {\n', '        (,, installments,,) = _decodeData(_data);\n', '    }\n', '\n', '    function _advanceClock(bytes32 id, uint256 _target) internal returns (bool) {\n', '        Config storage config = configs[id];\n', '        State storage state = states[id];\n', '\n', '        uint256 clock = state.clock;\n', '        if (clock < _target) {\n', '            (uint256 newInterest, uint256 newClock) = _runAdvanceClock({\n', '                _clock: state.clock,\n', '                _timeUnit: config.timeUnit,\n', '                _interest: state.interest,\n', '                _duration: config.duration,\n', '                _cuota: config.cuota,\n', '                _installments: config.installments,\n', '                _paidBase: state.paidBase,\n', '                _interestRate: config.interestRate,\n', '                _targetClock: _target\n', '            });\n', '\n', '            require(newClock < U_64_OVERFLOW, "Clock overflow");\n', '            require(newInterest < U_128_OVERFLOW, "Interest overflow");\n', '\n', '            emit _setClock(id, uint64(newClock));\n', '\n', '            if (newInterest != 0) {\n', '                emit _setInterest(id, uint128(newInterest));\n', '            }\n', '\n', '            state.clock = uint64(newClock);\n', '            state.interest = uint128(newInterest);\n', '\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function _getClosingObligation(bytes32 id) internal view returns (uint256) {\n', '        State storage state = states[id];\n', '        Config storage config = configs[id];\n', '\n', '        // Static storage loads\n', '        uint256 installments = config.installments;\n', '        uint256 cuota = config.cuota;\n', '        uint256 currentClock = uint64(now) - config.lentTime;\n', '\n', '        uint256 interest;\n', '        uint256 clock = state.clock;\n', '\n', '        if (clock >= currentClock) {\n', '            interest = state.interest;\n', '        } else {\n', '            (interest,) = _runAdvanceClock({\n', '                _clock: clock,\n', '                _timeUnit: config.timeUnit,\n', '                _interest: state.interest,\n', '                _duration: config.duration,\n', '                _cuota: cuota,\n', '                _installments: installments,\n', '                _paidBase: state.paidBase,\n', '                _interestRate: config.interestRate,\n', '                _targetClock: currentClock\n', '            });\n', '        }\n', '\n', '        uint256 debt = cuota * installments + interest;\n', '        uint256 paid = state.paid;\n', '        return debt > paid ? debt - paid : 0;\n', '    }\n', '\n', '    function _runAdvanceClock(\n', '        uint256 _clock,\n', '        uint256 _timeUnit,\n', '        uint256 _interest,\n', '        uint256 _duration,\n', '        uint256 _cuota,\n', '        uint256 _installments,\n', '        uint256 _paidBase,\n', '        uint256 _interestRate,\n', '        uint256 _targetClock\n', '    ) internal pure returns (uint256 interest, uint256 clock) {\n', '        // Advance clock to lentTime if never advanced before\n', '        clock = _clock;\n', '        interest = _interest;\n', '\n', '        // Aux variables\n', '        uint256 delta;\n', '        bool installmentCompleted;\n', '\n', '        do {\n', '            // Delta to next installment and absolute delta (no exceeding 1 installment)\n', '            (delta, installmentCompleted) = _calcDelta({\n', '                _targetDelta: _targetClock - clock,\n', '                _clock: clock,\n', '                _duration: _duration,\n', '                _installments: _installments\n', '            });\n', '\n', '            // Running debt\n', '            uint256 newInterest = _newInterest({\n', '                _clock: clock,\n', '                _timeUnit: _timeUnit,\n', '                _duration: _duration,\n', '                _installments: _installments,\n', '                _cuota: _cuota,\n', '                _paidBase: _paidBase,\n', '                _delta: delta,\n', '                _interestRate: _interestRate\n', '            });\n', '\n', "            // Don't change clock unless we have a change\n", '            if (installmentCompleted || newInterest > 0) {\n', '                clock += delta;\n', '                interest += newInterest;\n', '            } else {\n', '                break;\n', '            }\n', '        } while (clock < _targetClock);\n', '    }\n', '\n', '    function _calcDelta(\n', '        uint256 _targetDelta,\n', '        uint256 _clock,\n', '        uint256 _duration,\n', '        uint256 _installments\n', '    ) internal pure returns (uint256 delta, bool installmentCompleted) {\n', '        uint256 nextInstallmentDelta = _duration - _clock % _duration;\n', '        if (nextInstallmentDelta <= _targetDelta && _clock / _duration < _installments) {\n', '            delta = nextInstallmentDelta;\n', '            installmentCompleted = true;\n', '        } else {\n', '            delta = _targetDelta;\n', '            installmentCompleted = false;\n', '        }\n', '    }\n', '\n', '    function _newInterest(\n', '        uint256 _clock,\n', '        uint256 _timeUnit,\n', '        uint256 _duration,\n', '        uint256 _installments,\n', '        uint256 _cuota,\n', '        uint256 _paidBase,\n', '        uint256 _delta,\n', '        uint256 _interestRate\n', '    ) internal pure returns (uint256) {\n', '        uint256 runningDebt = _baseDebt(_clock, _duration, _installments, _cuota) - _paidBase;\n', '        uint256 newInterest = (100000 * (_delta / _timeUnit) * runningDebt) / (_interestRate / _timeUnit);\n', '        require(newInterest < U_128_OVERFLOW, "New interest overflow");\n', '        return newInterest;\n', '    }\n', '\n', '    function _baseDebt(\n', '        uint256 clock,\n', '        uint256 duration,\n', '        uint256 installments,\n', '        uint256 cuota\n', '    ) internal pure returns (uint256 base) {\n', '        uint256 installment = clock / duration;\n', '        return uint128(installment < installments ? installment * cuota : installments * cuota);\n', '    }\n', '\n', '    function _validate(\n', '        uint256 _cuota,\n', '        uint256 _interestRate,\n', '        uint256 _installments,\n', '        uint256 _installmentDuration,\n', '        uint256 _timeUnit\n', '    ) internal pure {\n', '        require(_cuota > 0, "Cuota can\'t be 0");\n', '        require(_interestRate > 0, "Interest rate can\'t be 0");\n', '        require(_installments > 0, "Installments can\'t be 0");\n', '        require(_installmentDuration > 0, "Installment duration can\'t be 0");\n', '        require(_timeUnit <= _installmentDuration, "Time unit can\'t be lower than installment duration");\n', '        require(_interestRate > _timeUnit, "Interest rate by time unit is too low");\n', '        require(_timeUnit > 0, "Time unit can\'be 0");\n', '    }\n', '\n', '    function _decodeData(\n', '        bytes memory _data\n', '    ) internal pure returns (uint128, uint256, uint24, uint40, uint32) {\n', '        require(_data.length == L_DATA, "Invalid data length");\n', '        (\n', '            bytes32 cuota,\n', '            bytes32 interestRate,\n', '            bytes32 installments,\n', '            bytes32 duration,\n', '            bytes32 timeUnit\n', '        ) = decode(_data, 16, 32, 3, 5, 4);\n', '        return (uint128(uint256(cuota)), uint256(interestRate), uint24(uint256(installments)), uint40(uint256(duration)), uint32(uint256(timeUnit)));\n', '    }\n', '}']