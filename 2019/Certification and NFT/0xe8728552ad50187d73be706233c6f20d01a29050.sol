['// File: contracts/lib/interface/ICelerWallet.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '/**\n', ' * @title CelerWallet interface\n', ' */\n', 'interface ICelerWallet {\n', '    function create(address[] calldata _owners, address _operator, bytes32 _nonce) external returns(bytes32);\n', '\n', '    function depositETH(bytes32 _walletId) external payable;\n', '\n', '    function depositERC20(bytes32 _walletId, address _tokenAddress, uint _amount) external;\n', '    \n', '    function withdraw(bytes32 _walletId, address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function transferToWallet(bytes32 _fromWalletId, bytes32 _toWalletId, address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function transferOperatorship(bytes32 _walletId, address _newOperator) external;\n', '\n', '    function proposeNewOperator(bytes32 _walletId, address _newOperator) external;\n', '\n', '    function drainToken(address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function getWalletOwners(bytes32 _walletId) external view returns(address[] memory);\n', '\n', '    function getOperator(bytes32 _walletId) external view returns(address);\n', '\n', '    function getBalance(bytes32 _walletId, address _tokenAddress) external view returns(uint);\n', '\n', '    function getProposedNewOperator(bytes32 _walletId) external view returns(address);\n', '\n', '    function getProposalVote(bytes32 _walletId, address _owner) external view returns(bool);\n', '\n', '    event CreateWallet(bytes32 indexed walletId, address[] indexed owners, address indexed operator);\n', '\n', '    event DepositToWallet(bytes32 indexed walletId, address indexed tokenAddress, uint amount);\n', '\n', '    event WithdrawFromWallet(bytes32 indexed walletId, address indexed tokenAddress, address indexed receiver, uint amount);\n', '\n', '    event TransferToWallet(bytes32 indexed fromWalletId, bytes32 indexed toWalletId, address indexed tokenAddress, address receiver, uint amount);\n', '\n', '    event ChangeOperator(bytes32 indexed walletId, address indexed oldOperator, address indexed newOperator);\n', '\n', '    event ProposeNewOperator(bytes32 indexed walletId, address indexed newOperator, address indexed proposer);\n', '\n', '    event DrainToken(address indexed tokenAddress, address indexed receiver, uint amount);\n', '}\n', '\n', '// File: contracts/lib/interface/IEthPool.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '/**\n', ' * @title EthPool interface\n', ' */\n', 'interface IEthPool {\n', '    function deposit(address _receiver) external payable;\n', '\n', '    function withdraw(uint _value) external;\n', '\n', '    function approve(address _spender, uint _value) external returns (bool);\n', '\n', '    function transferFrom(address _from, address payable _to, uint _value) external returns (bool);\n', '\n', '    function transferToCelerWallet(address _from, address _walletAddr, bytes32 _walletId, uint _value) external returns (bool);\n', '\n', '    function increaseAllowance(address _spender, uint _addedValue) external returns (bool);\n', '\n', '    function decreaseAllowance(address _spender, uint _subtractedValue) external returns (bool);\n', '\n', '    function balanceOf(address _owner) external view returns (uint);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '\n', '    event Deposit(address indexed receiver, uint value);\n', '    \n', '    // transfer from "from" account inside EthPool to real "to" address outside EthPool\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// File: contracts/lib/interface/IPayRegistry.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '/**\n', ' * @title PayRegistry interface\n', ' */\n', 'interface IPayRegistry {\n', '    function calculatePayId(bytes32 _payHash, address _setter) external pure returns(bytes32);\n', '\n', '    function setPayAmount(bytes32 _payHash, uint _amt) external;\n', '\n', '    function setPayDeadline(bytes32 _payHash, uint _deadline) external;\n', '\n', '    function setPayInfo(bytes32 _payHash, uint _amt, uint _deadline) external;\n', '\n', '    function setPayAmounts(bytes32[] calldata _payHashes, uint[] calldata _amts) external;\n', '\n', '    function setPayDeadlines(bytes32[] calldata _payHashes, uint[] calldata _deadlines) external;\n', '\n', '    function setPayInfos(bytes32[] calldata _payHashes, uint[] calldata _amts, uint[] calldata _deadlines) external;\n', '\n', '    function getPayAmounts(\n', '        bytes32[] calldata _payIds,\n', '        uint _lastPayResolveDeadline\n', '    ) external view returns(uint[] memory);\n', '\n', '    function getPayInfo(bytes32 _payId) external view returns(uint, uint);\n', '\n', '    event PayInfoUpdate(bytes32 indexed payId, uint amount, uint resolveDeadline);\n', '}\n', '\n', '// File: contracts/lib/data/Pb.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '// runtime proto sol library\n', 'library Pb {\n', '    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\n', '\n', '    struct Buffer {\n', "        uint idx;  // the start index of next read. when idx=b.length, we're done\n", '        bytes b;   // hold serialized proto msg, readonly\n', '    }\n', '\n', '    // create a new in-memory Buffer object from raw msg bytes\n', '    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\n', '        buf.b = raw;\n', '        buf.idx = 0;\n', '    }\n', '\n', '    // whether there are unread bytes\n', '    function hasMore(Buffer memory buf) internal pure returns (bool) {\n', '        return buf.idx < buf.b.length;\n', '    }\n', '\n', '    // decode current field number and wiretype\n', '    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\n', '        uint v = decVarint(buf);\n', '        tag = v / 8;\n', '        wiretype = WireType(v & 7);\n', '    }\n', '\n', '    // count tag occurrences, return an array due to no memory map support\n', '\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\n', '\t// should keep buf.idx unchanged because this is only a count function\n', '    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\n', '        uint originalIdx = buf.idx;\n', "        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\n", '        uint tag;\n', '        WireType wire;\n', '        while (hasMore(buf)) {\n', '            (tag, wire) = decKey(buf);\n', '            cnts[tag] += 1;\n', '            skipValue(buf, wire);\n', '        }\n', '        buf.idx = originalIdx;\n', '    }\n', '\n', '    // read varint from current buf idx, move buf.idx to next read, return the int value\n', '    function decVarint(Buffer memory buf) internal pure returns (uint v) {\n', '        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\n', '        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\n', '        v = buf.idx;  // use v to save one additional uint variable\n', '        assembly {\n', '            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\n', '        }\n', '        uint b; // store current byte content\n', '        v = 0; // reset to 0 for return value\n', '        for (uint i=0; i<10; i++) {\n', '            assembly {\n', "                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\n", '            }\n', '            v |= (b & 0x7F) << (i * 7);\n', '            if (b & 0x80 == 0) {\n', '                buf.idx += i + 1;\n', '                return v;\n', '            }\n', '        }\n', '        revert(); // i=10, invalid varint stream\n', '    }\n', '\n', '    // read length delimited field and return bytes\n', '    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\n', '        uint len = decVarint(buf);\n', '        uint end = buf.idx + len;\n', '        require(end <= buf.b.length);  // avoid overflow\n', '        b = new bytes(len);\n', '        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\n', '        uint bStart;\n', '        uint bufBStart = buf.idx;\n', '        assembly {\n', '            bStart := add(b, 32)\n', '            bufBStart := add(add(bufB, 32), bufBStart)\n', '        }\n', '        for (uint i=0; i<len; i+=32) {\n', '            assembly{\n', '                mstore(add(bStart, i), mload(add(bufBStart, i)))\n', '            }\n', '        }\n', '        buf.idx = end;\n', '    }\n', '\n', '    // return packed ints\n', '    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\n', '        uint len = decVarint(buf);\n', '        uint end = buf.idx + len;\n', '        require(end <= buf.b.length);  // avoid overflow\n', '        // array in memory must be init w/ known length\n', '        // so we have to create a tmp array w/ max possible len first\n', '        uint[] memory tmp = new uint[](len);\n', '        uint i = 0; // count how many ints are there\n', '        while (buf.idx < end) {\n', '            tmp[i] = decVarint(buf);\n', '            i++;\n', '        }\n', '        t = new uint[](i); // init t with correct length\n', '        for (uint j=0; j<i; j++) {\n', '            t[j] = tmp[j];\n', '        }\n', '        return t;\n', '    }\n', '\n', '    // move idx pass current value field, to beginning of next tag or msg end\n', '    function skipValue(Buffer memory buf, WireType wire) internal pure {\n', '        if (wire == WireType.Varint) { decVarint(buf); }\n', '        else if (wire == WireType.LengthDelim) {\n', '            uint len = decVarint(buf);\n', '            buf.idx += len; // skip len bytes value data\n', '            require(buf.idx <= buf.b.length);  // avoid overflow\n', '        } else { revert(); }  // unsupported wiretype\n', '    }\n', '\n', '    // type conversion help utils\n', '    function _bool(uint x) internal pure returns (bool v) {\n', '        return x != 0;\n', '    }\n', '\n', '    function _uint256(bytes memory b) internal pure returns (uint256 v) {\n', "        require(b.length <= 32);  // b's length must be smaller than or equal to 32\n", '        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\n', '        v = v >> (8 * (32 - b.length));  // only first b.length is valid\n', '    }\n', '\n', '    function _address(bytes memory b) internal pure returns (address v) {\n', '        v = _addressPayable(b);\n', '    }\n', '\n', '    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\n', '        require(b.length == 20);\n', '        //load 32bytes then shift right 12 bytes\n', '        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\n', '    }\n', '\n', '    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\n', '        require(b.length == 32);\n', '        assembly { v := mload(add(b, 32)) }\n', '    }\n', '\n', '    // uint[] to uint8[]\n', '    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\n', '        t = new uint8[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\n', '    }\n', '\n', '    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\n', '        t = new uint32[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\n', '    }\n', '\n', '    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\n', '        t = new uint64[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\n', '    }\n', '\n', '    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\n', '        t = new bool[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/data/PbEntity.sol\n', '\n', '// Code generated by protoc-gen-sol. DO NOT EDIT.\n', '// source: entity.proto\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'library PbEntity {\n', '    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\n', '\n', '    enum TokenType { INVALID, ETH, ERC20 }\n', '\n', '    // TokenType[] decode function\n', '    function TokenTypes(uint[] memory arr) internal pure returns (TokenType[] memory t) {\n', '        t = new TokenType[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = TokenType(arr[i]); }\n', '    }\n', '\n', '    enum TransferFunctionType { BOOLEAN_AND, BOOLEAN_OR, BOOLEAN_CIRCUIT, NUMERIC_ADD, NUMERIC_MAX, NUMERIC_MIN }\n', '\n', '    // TransferFunctionType[] decode function\n', '    function TransferFunctionTypes(uint[] memory arr) internal pure returns (TransferFunctionType[] memory t) {\n', '        t = new TransferFunctionType[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = TransferFunctionType(arr[i]); }\n', '    }\n', '\n', '    enum ConditionType { HASH_LOCK, DEPLOYED_CONTRACT, VIRTUAL_CONTRACT }\n', '\n', '    // ConditionType[] decode function\n', '    function ConditionTypes(uint[] memory arr) internal pure returns (ConditionType[] memory t) {\n', '        t = new ConditionType[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = ConditionType(arr[i]); }\n', '    }\n', '\n', '    struct AccountAmtPair {\n', '        address account;   // tag: 1\n', '        uint256 amt;   // tag: 2\n', '    } // end struct AccountAmtPair\n', '\n', '    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.account = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.amt = Pb._uint256(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder AccountAmtPair\n', '\n', '    struct TokenInfo {\n', '        TokenType tokenType;   // tag: 1\n', '        address tokenAddress;   // tag: 2\n', '    } // end struct TokenInfo\n', '\n', '    function decTokenInfo(bytes memory raw) internal pure returns (TokenInfo memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.tokenType = TokenType(buf.decVarint());\n', '            }\n', '            else if (tag == 2) {\n', '                m.tokenAddress = Pb._address(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder TokenInfo\n', '\n', '    struct TokenDistribution {\n', '        TokenInfo token;   // tag: 1\n', '        AccountAmtPair[] distribution;   // tag: 2\n', '    } // end struct TokenDistribution\n', '\n', '    function decTokenDistribution(bytes memory raw) internal pure returns (TokenDistribution memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(2);\n', '        m.distribution = new AccountAmtPair[](cnts[2]);\n', '        cnts[2] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.token = decTokenInfo(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.distribution[cnts[2]] = decAccountAmtPair(buf.decBytes());\n', '                cnts[2]++;\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder TokenDistribution\n', '\n', '    struct TokenTransfer {\n', '        TokenInfo token;   // tag: 1\n', '        AccountAmtPair receiver;   // tag: 2\n', '    } // end struct TokenTransfer\n', '\n', '    function decTokenTransfer(bytes memory raw) internal pure returns (TokenTransfer memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.token = decTokenInfo(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.receiver = decAccountAmtPair(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder TokenTransfer\n', '\n', '    struct SimplexPaymentChannel {\n', '        bytes32 channelId;   // tag: 1\n', '        address peerFrom;   // tag: 2\n', '        uint seqNum;   // tag: 3\n', '        TokenTransfer transferToPeer;   // tag: 4\n', '        PayIdList pendingPayIds;   // tag: 5\n', '        uint lastPayResolveDeadline;   // tag: 6\n', '        uint256 totalPendingAmount;   // tag: 7\n', '    } // end struct SimplexPaymentChannel\n', '\n', '    function decSimplexPaymentChannel(bytes memory raw) internal pure returns (SimplexPaymentChannel memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.channelId = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.peerFrom = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.seqNum = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 4) {\n', '                m.transferToPeer = decTokenTransfer(buf.decBytes());\n', '            }\n', '            else if (tag == 5) {\n', '                m.pendingPayIds = decPayIdList(buf.decBytes());\n', '            }\n', '            else if (tag == 6) {\n', '                m.lastPayResolveDeadline = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 7) {\n', '                m.totalPendingAmount = Pb._uint256(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder SimplexPaymentChannel\n', '\n', '    struct PayIdList {\n', '        bytes32[] payIds;   // tag: 1\n', '        bytes32 nextListHash;   // tag: 2\n', '    } // end struct PayIdList\n', '\n', '    function decPayIdList(bytes memory raw) internal pure returns (PayIdList memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(2);\n', '        m.payIds = new bytes32[](cnts[1]);\n', '        cnts[1] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.payIds[cnts[1]] = Pb._bytes32(buf.decBytes());\n', '                cnts[1]++;\n', '            }\n', '            else if (tag == 2) {\n', '                m.nextListHash = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder PayIdList\n', '\n', '    struct TransferFunction {\n', '        TransferFunctionType logicType;   // tag: 1\n', '        TokenTransfer maxTransfer;   // tag: 2\n', '    } // end struct TransferFunction\n', '\n', '    function decTransferFunction(bytes memory raw) internal pure returns (TransferFunction memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.logicType = TransferFunctionType(buf.decVarint());\n', '            }\n', '            else if (tag == 2) {\n', '                m.maxTransfer = decTokenTransfer(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder TransferFunction\n', '\n', '    struct ConditionalPay {\n', '        uint payTimestamp;   // tag: 1\n', '        address src;   // tag: 2\n', '        address dest;   // tag: 3\n', '        Condition[] conditions;   // tag: 4\n', '        TransferFunction transferFunc;   // tag: 5\n', '        uint resolveDeadline;   // tag: 6\n', '        uint resolveTimeout;   // tag: 7\n', '        address payResolver;   // tag: 8\n', '    } // end struct ConditionalPay\n', '\n', '    function decConditionalPay(bytes memory raw) internal pure returns (ConditionalPay memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(8);\n', '        m.conditions = new Condition[](cnts[4]);\n', '        cnts[4] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.payTimestamp = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 2) {\n', '                m.src = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.dest = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 4) {\n', '                m.conditions[cnts[4]] = decCondition(buf.decBytes());\n', '                cnts[4]++;\n', '            }\n', '            else if (tag == 5) {\n', '                m.transferFunc = decTransferFunction(buf.decBytes());\n', '            }\n', '            else if (tag == 6) {\n', '                m.resolveDeadline = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 7) {\n', '                m.resolveTimeout = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 8) {\n', '                m.payResolver = Pb._address(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder ConditionalPay\n', '\n', '    struct CondPayResult {\n', '        bytes condPay;   // tag: 1\n', '        uint256 amount;   // tag: 2\n', '    } // end struct CondPayResult\n', '\n', '    function decCondPayResult(bytes memory raw) internal pure returns (CondPayResult memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.condPay = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.amount = Pb._uint256(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder CondPayResult\n', '\n', '    struct VouchedCondPayResult {\n', '        bytes condPayResult;   // tag: 1\n', '        bytes sigOfSrc;   // tag: 2\n', '        bytes sigOfDest;   // tag: 3\n', '    } // end struct VouchedCondPayResult\n', '\n', '    function decVouchedCondPayResult(bytes memory raw) internal pure returns (VouchedCondPayResult memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.condPayResult = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.sigOfSrc = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.sigOfDest = bytes(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder VouchedCondPayResult\n', '\n', '    struct Condition {\n', '        ConditionType conditionType;   // tag: 1\n', '        bytes32 hashLock;   // tag: 2\n', '        address deployedContractAddress;   // tag: 3\n', '        bytes32 virtualContractAddress;   // tag: 4\n', '        bytes argsQueryFinalization;   // tag: 5\n', '        bytes argsQueryOutcome;   // tag: 6\n', '    } // end struct Condition\n', '\n', '    function decCondition(bytes memory raw) internal pure returns (Condition memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.conditionType = ConditionType(buf.decVarint());\n', '            }\n', '            else if (tag == 2) {\n', '                m.hashLock = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.deployedContractAddress = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 4) {\n', '                m.virtualContractAddress = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 5) {\n', '                m.argsQueryFinalization = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 6) {\n', '                m.argsQueryOutcome = bytes(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder Condition\n', '\n', '    struct CooperativeWithdrawInfo {\n', '        bytes32 channelId;   // tag: 1\n', '        uint seqNum;   // tag: 2\n', '        AccountAmtPair withdraw;   // tag: 3\n', '        uint withdrawDeadline;   // tag: 4\n', '        bytes32 recipientChannelId;   // tag: 5\n', '    } // end struct CooperativeWithdrawInfo\n', '\n', '    function decCooperativeWithdrawInfo(bytes memory raw) internal pure returns (CooperativeWithdrawInfo memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.channelId = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.seqNum = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 3) {\n', '                m.withdraw = decAccountAmtPair(buf.decBytes());\n', '            }\n', '            else if (tag == 4) {\n', '                m.withdrawDeadline = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 5) {\n', '                m.recipientChannelId = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder CooperativeWithdrawInfo\n', '\n', '    struct PaymentChannelInitializer {\n', '        TokenDistribution initDistribution;   // tag: 1\n', '        uint openDeadline;   // tag: 2\n', '        uint disputeTimeout;   // tag: 3\n', '        uint msgValueReceiver;   // tag: 4\n', '    } // end struct PaymentChannelInitializer\n', '\n', '    function decPaymentChannelInitializer(bytes memory raw) internal pure returns (PaymentChannelInitializer memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.initDistribution = decTokenDistribution(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.openDeadline = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 3) {\n', '                m.disputeTimeout = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 4) {\n', '                m.msgValueReceiver = uint(buf.decVarint());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder PaymentChannelInitializer\n', '\n', '    struct CooperativeSettleInfo {\n', '        bytes32 channelId;   // tag: 1\n', '        uint seqNum;   // tag: 2\n', '        AccountAmtPair[] settleBalance;   // tag: 3\n', '        uint settleDeadline;   // tag: 4\n', '    } // end struct CooperativeSettleInfo\n', '\n', '    function decCooperativeSettleInfo(bytes memory raw) internal pure returns (CooperativeSettleInfo memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(4);\n', '        m.settleBalance = new AccountAmtPair[](cnts[3]);\n', '        cnts[3] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.channelId = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.seqNum = uint(buf.decVarint());\n', '            }\n', '            else if (tag == 3) {\n', '                m.settleBalance[cnts[3]] = decAccountAmtPair(buf.decBytes());\n', '                cnts[3]++;\n', '            }\n', '            else if (tag == 4) {\n', '                m.settleDeadline = uint(buf.decVarint());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder CooperativeSettleInfo\n', '\n', '    struct ChannelMigrationInfo {\n', '        bytes32 channelId;   // tag: 1\n', '        address fromLedgerAddress;   // tag: 2\n', '        address toLedgerAddress;   // tag: 3\n', '        uint migrationDeadline;   // tag: 4\n', '    } // end struct ChannelMigrationInfo\n', '\n', '    function decChannelMigrationInfo(bytes memory raw) internal pure returns (ChannelMigrationInfo memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.channelId = Pb._bytes32(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.fromLedgerAddress = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.toLedgerAddress = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 4) {\n', '                m.migrationDeadline = uint(buf.decVarint());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder ChannelMigrationInfo\n', '\n', '}\n', '\n', '// File: contracts/lib/ledgerlib/LedgerStruct.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ledger Struct Library\n', ' * @notice CelerLedger library defining all used structs\n', ' */\n', 'library LedgerStruct {\n', '    enum ChannelStatus { Uninitialized, Operable, Settling, Closed, Migrated }\n', '\n', '    struct PeerState {\n', '        uint seqNum;\n', '        // balance sent out to the other peer of the channel, no need to record amtIn\n', '        uint transferOut;\n', '        bytes32 nextPayIdListHash;\n', '        uint lastPayResolveDeadline;\n', '        uint pendingPayOut;\n', '    }\n', '\n', '    struct PeerProfile {\n', '        address peerAddr;\n', '        // the (monotone increasing) amount that this peer deposit into this channel\n', '        uint deposit;\n', '        // the (monotone increasing) amount that this peer withdraw from this channel\n', '        uint withdrawal;\n', '        PeerState state;\n', '    }\n', '\n', '    struct WithdrawIntent {\n', '        address receiver;\n', '        uint amount;\n', '        uint requestTime;\n', '        bytes32 recipientChannelId;\n', '    }\n', '\n', '    // Channel is a representation of the state channel between peers which puts the funds\n', '    // in CelerWallet and is hosted by a CelerLedger. The status of a state channel can\n', '    // be migrated from one CelerLedger instance to another CelerLedger instance with probably\n', '    // different operation logic.\n', '    struct Channel {\n', '        // the time after which peers can confirmSettle and before which peers can intendSettle\n', '        uint settleFinalizedTime;\n', '        uint disputeTimeout;\n', '        PbEntity.TokenInfo token;\n', '        ChannelStatus status;\n', '        // record the new CelerLedger address after channel migration\n', '        address migratedTo;\n', '        // only support 2-peer channel for now\n', '        PeerProfile[2] peerProfiles;\n', '        uint cooperativeWithdrawSeqNum;\n', '        WithdrawIntent withdrawIntent;\n', '    }\n', '\n', '    // Ledger is a host to record and operate the activities of many state\n', '    // channels with specific operation logic.\n', '    struct Ledger {\n', '        // ChannelStatus => number of channels\n', '        mapping(uint => uint) channelStatusNums;\n', '        IEthPool ethPool;\n', '        IPayRegistry payRegistry;\n', '        ICelerWallet celerWallet;\n', '        // per channel deposit limits for different tokens\n', '        mapping(address => uint) balanceLimits;\n', '        // whether deposit limits of all tokens have been enabled\n', '        bool balanceLimitsEnabled;\n', '        mapping(bytes32 => Channel) channelMap;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/interface/ICelerLedger.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '\n', '\n', '/**\n', ' * @title CelerLedger interface\n', ' * @dev any changes in this interface must be synchronized to corresponding libraries\n', ' * @dev events in this interface must be exactly same in corresponding used libraries\n', ' */\n', 'interface ICelerLedger {\n', '    /********** LedgerOperation related functions and events **********/\n', '    function openChannel(bytes calldata _openChannelRequest) external payable;\n', '\n', '    function deposit(bytes32 _channelId, address _receiver, uint _transferFromAmount) external payable;\n', '\n', '    function depositInBatch(\n', '        bytes32[] calldata _channelIds,\n', '        address[] calldata _receivers,\n', '        uint[] calldata _transferFromAmounts\n', '    ) external;\n', '\n', '    function snapshotStates(bytes calldata _signedSimplexStateArray) external;\n', '\n', '    function intendWithdraw(bytes32 _channelId, uint _amount, bytes32 _recipientChannelId) external;\n', '    \n', '    function confirmWithdraw(bytes32 _channelId) external;\n', '\n', '    function vetoWithdraw(bytes32 _channelId) external;\n', '    \n', '    function cooperativeWithdraw(bytes calldata _cooperativeWithdrawRequest) external;\n', '    \n', '    function intendSettle(bytes calldata _signedSimplexStateArray) external;\n', '    \n', '    function clearPays(bytes32 _channelId, address _peerFrom, bytes calldata _payIdList) external;\n', '    \n', '    function confirmSettle(bytes32 _channelId) external;\n', '    \n', '    function cooperativeSettle(bytes calldata _settleRequest) external;\n', '    \n', '    function getChannelStatusNum(uint _channelStatus) external view returns(uint);\n', '\n', '    function getEthPool() external view returns(address);\n', '\n', '    function getPayRegistry() external view returns(address);\n', '\n', '    function getCelerWallet() external view returns(address);\n', '\n', '    event OpenChannel(\n', '        bytes32 indexed channelId,\n', '        uint tokenType,\n', '        address indexed tokenAddress,\n', '        // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\n', '        address[2] peerAddrs,\n', '        uint[2] initialDeposits\n', '    );\n', '\n', '    // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\n', '    event Deposit(bytes32 indexed channelId, address[2] peerAddrs, uint[2] deposits, uint[2] withdrawals);\n', '\n', '    event SnapshotStates(bytes32 indexed channelId, uint[2] seqNums);\n', '\n', '    event IntendSettle(bytes32 indexed channelId, uint[2] seqNums);\n', '\n', '    event ClearOnePay(bytes32 indexed channelId, bytes32 indexed payId, address indexed peerFrom, uint amount);\n', '\n', '    event ConfirmSettle(bytes32 indexed channelId, uint[2] settleBalance);\n', '\n', '    event ConfirmSettleFail(bytes32 indexed channelId);\n', '\n', '    event IntendWithdraw(bytes32 indexed channelId, address indexed receiver, uint amount);\n', '\n', '    event ConfirmWithdraw(\n', '        bytes32 indexed channelId,\n', '        uint withdrawnAmount,\n', '        address indexed receiver,\n', '        bytes32 indexed recipientChannelId,\n', '        uint[2] deposits,\n', '        uint[2] withdrawals\n', '    );\n', '\n', '    event VetoWithdraw(bytes32 indexed channelId);\n', '\n', '    event CooperativeWithdraw(\n', '        bytes32 indexed channelId,\n', '        uint withdrawnAmount,\n', '        address indexed receiver,\n', '        bytes32 indexed recipientChannelId,\n', '        uint[2] deposits,\n', '        uint[2] withdrawals,\n', '        uint seqNum\n', '    );\n', '\n', '    event CooperativeSettle(bytes32 indexed channelId, uint[2] settleBalance);\n', '    /********** End of LedgerOperation related functions and events **********/\n', '\n', '\n', '    /********** LedgerChannel related functions and events **********/\n', '    function getSettleFinalizedTime(bytes32 _channelId) external view returns(uint);\n', '\n', '    function getTokenContract(bytes32 _channelId) external view returns(address);\n', '\n', '    function getTokenType(bytes32 _channelId) external view returns(PbEntity.TokenType);\n', '\n', '    function getChannelStatus(bytes32 _channelId) external view returns(LedgerStruct.ChannelStatus);\n', '\n', '    function getCooperativeWithdrawSeqNum(bytes32 _channelId) external view returns(uint);\n', '\n', '    function getTotalBalance(bytes32 _channelId) external view returns(uint);\n', '\n', '    function getBalanceMap(bytes32 _channelId) external view returns(address[2] memory, uint[2] memory, uint[2] memory);\n', '\n', '    function getChannelMigrationArgs(bytes32 _channelId) external view returns(uint, uint, address, uint);\n', '\n', '    function getPeersMigrationInfo(bytes32 _channelId) external view returns(\n', '        address[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory\n', '    );\n', '\n', '    function getDisputeTimeout(bytes32 _channelId) external view returns(uint);\n', '\n', '    function getMigratedTo(bytes32 _channelId) external view returns(address);\n', '\n', '    function getStateSeqNumMap(bytes32 _channelId) external view returns(address[2] memory, uint[2] memory);\n', '\n', '    function getTransferOutMap(bytes32 _channelId) external view returns(\n', '        address[2] memory,\n', '        uint[2] memory\n', '    );\n', '\n', '    function getNextPayIdListHashMap(bytes32 _channelId) external view returns(\n', '        address[2] memory,\n', '        bytes32[2] memory\n', '    );\n', '\n', '    function getLastPayResolveDeadlineMap(bytes32 _channelId) external view returns(\n', '        address[2] memory,\n', '        uint[2] memory\n', '    );\n', '\n', '    function getPendingPayOutMap(bytes32 _channelId) external view returns(\n', '        address[2] memory,\n', '        uint[2] memory\n', '    );\n', '\n', '    function getWithdrawIntent(bytes32 _channelId) external view returns(address, uint, uint, bytes32);\n', '    /********** End of LedgerChannel related functions and events **********/\n', '\n', '\n', '    /********** LedgerBalanceLimit related functions and events **********/\n', '    function setBalanceLimits(address[] calldata _tokenAddrs, uint[] calldata _limits) external;\n', '\n', '    function disableBalanceLimits() external;\n', '\n', '    function enableBalanceLimits() external;\n', '\n', '    function getBalanceLimit(address _tokenAddr) external view returns(uint);\n', '\n', '    function getBalanceLimitsEnabled() external view returns(bool);\n', '    /********** End of LedgerBalanceLimit related functions and events **********/\n', '\n', '\n', '    /********** LedgerMigrate related functions and events **********/\n', '    function migrateChannelTo(bytes calldata _migrationRequest) external returns(bytes32);\n', '\n', '    function migrateChannelFrom(address _fromLedgerAddr, bytes calldata _migrationRequest) external;\n', '\n', '    event MigrateChannelTo(bytes32 indexed channelId, address indexed newLedgerAddr);\n', '\n', '    event MigrateChannelFrom(bytes32 indexed channelId, address indexed oldLedgerAddr);\n', '    /********** End of LedgerMigrate related functions and events **********/\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Elliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECDSA {\n', '    /**\n', '     * @dev Recover signer address from a message by using their signature\n', '     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            return ecrecover(hash, v, r, s);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * toEthSignedMessageHash\n', '     * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '     * and hash the result\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ledgerlib/LedgerChannel.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ledger Channel Library\n', ' * @notice CelerLedger library about Channel struct\n', ' * @dev this can be included in LedgerOperation to save some gas,\n', ' *   however, keep this for now for clearness.\n', ' */\n', 'library LedgerChannel {\n', '    using SafeMath for uint;\n', '    using ECDSA for bytes32;\n', '\n', '    /**\n', '     * @notice Get channel confirm settle open time\n', '     * @param _c the channel being used\n', '     * @return channel confirm settle open time\n', '     */\n', '    function getSettleFinalizedTime(LedgerStruct.Channel storage _c) public view returns(uint) {\n', '        return _c.settleFinalizedTime;\n', '    }\n', '\n', '    /**\n', '     * @notice Get channel token contract address\n', '     * @param _c the channel being used\n', '     * @return channel token contract address\n', '     */\n', '    function getTokenContract(LedgerStruct.Channel storage _c) public view returns(address) {\n', '        return _c.token.tokenAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Get channel token type\n', '     * @param _c the channel being used\n', '     * @return channel token type\n', '     */\n', '    function getTokenType(LedgerStruct.Channel storage _c) public view returns(PbEntity.TokenType) {\n', '        return _c.token.tokenType;\n', '    }\n', '\n', '    /**\n', '     * @notice Get channel status\n', '     * @param _c the channel being used\n', '     * @return channel status\n', '     */\n', '    function getChannelStatus(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        public\n', '        view\n', '        returns(LedgerStruct.ChannelStatus)\n', '    {\n', '        return _c.status;\n', '    }\n', '\n', '    /**\n', '     * @notice Get cooperative withdraw seqNum\n', '     * @param _c the channel being used\n', '     * @return cooperative withdraw seqNum\n', '     */\n', '    function getCooperativeWithdrawSeqNum(LedgerStruct.Channel storage _c) public view returns(uint) {\n', '        return _c.cooperativeWithdrawSeqNum;\n', '    }\n', '\n', '    /**\n', "     * @notice Return one channel's total balance amount\n", '     * @param _c the channel\n', "     * @return channel's balance amount\n", '     */\n', '    function getTotalBalance(LedgerStruct.Channel storage _c) public view returns(uint) {\n', '        uint balance = _c.peerProfiles[0].deposit\n', '            .add(_c.peerProfiles[1].deposit)\n', '            .sub(_c.peerProfiles[0].withdrawal)\n', '            .sub(_c.peerProfiles[1].withdrawal);\n', '        return balance;\n', '    }\n', '\n', '    /**\n', "     * @notice Return one channel's balance info (depositMap and withdrawalMap)\n", "     * @dev Solidity can't directly return an array of struct for now\n", '     * @param _c the channel\n', '     * @return addresses of peers in the channel\n', '     * @return corresponding deposits of the peers (with matched index)\n', '     * @return corresponding withdrawals of the peers (with matched index)\n', '     */\n', '    function getBalanceMap(LedgerStruct.Channel storage _c) public view\n', '        returns(address[2] memory, uint[2] memory, uint[2] memory)\n', '    {\n', '        address[2] memory peerAddrs = [_c.peerProfiles[0].peerAddr, _c.peerProfiles[1].peerAddr];\n', '        uint[2] memory deposits = [_c.peerProfiles[0].deposit, _c.peerProfiles[1].deposit];\n', '        uint[2] memory withdrawals = [_c.peerProfiles[0].withdrawal, _c.peerProfiles[1].withdrawal];\n', '        return (peerAddrs, deposits, withdrawals);\n', '    }\n', '\n', '    /**\n', '     * @notice Return channel-level migration arguments\n', '     * @param _c the channel to be viewed\n', '     * @return channel dispute timeout\n', '     * @return channel tokey type converted to uint\n', '     * @return channel token address\n', '     * @return sequence number of cooperative withdraw\n', '     * @dev related to Ledger Migration\n', '     */\n', '    function getChannelMigrationArgs(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(uint, uint, address, uint)\n', '    {\n', '        return (\n', '            _c.disputeTimeout,\n', '            uint(_c.token.tokenType),\n', '            _c.token.tokenAddress,\n', '            _c.cooperativeWithdrawSeqNum\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return migration info of the peers in the channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", "     * @return peers' deposits\n", "     * @return peers' withdrawals\n", "     * @return peers' state sequence numbers\n", "     * @return peers' transferOut map\n", "     * @return peers' pendingPayOut map\n", '     * @dev related to Ledger Migration\n', '     */\n', '    function getPeersMigrationInfo(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(\n', '        address[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory,\n', '        uint[2] memory\n', '    )\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].deposit, peerProfiles[1].deposit],\n', '            [peerProfiles[0].withdrawal, peerProfiles[1].withdrawal],\n', '            [peerProfiles[0].state.seqNum, peerProfiles[1].state.seqNum],\n', '            [peerProfiles[0].state.transferOut, peerProfiles[1].state.transferOut],\n', '            [peerProfiles[0].state.pendingPayOut, peerProfiles[1].state.pendingPayOut]\n', '        );\n', '    }\n', '\n', '    /**\n', "     * @notice Return channel's dispute timeout\n", '     * @param _c the channel to be viewed\n', "     * @return channel's dispute timeout\n", '     */\n', '    function getDisputeTimeout(LedgerStruct.Channel storage _c) external view returns(uint) {\n', '        return _c.disputeTimeout;\n', '    }\n', '\n', '    /**\n', "     * @notice Return channel's migratedTo address\n", '     * @param _c the channel to be viewed\n', "     * @return channel's migratedTo address\n", '     */\n', '    function getMigratedTo(LedgerStruct.Channel storage _c) external view returns(address) {\n', '        return _c.migratedTo;\n', '    }\n', '\n', '    /**\n', '     * @notice Return state seqNum map of a duplex channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", '     * @return two simplex state sequence numbers\n', '     */\n', '    function getStateSeqNumMap(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address[2] memory, uint[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].state.seqNum, peerProfiles[1].state.seqNum]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return transferOut map of a duplex channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", '     * @return transferOuts of two simplex channels\n', '     */\n', '    function getTransferOutMap(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address[2] memory, uint[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].state.transferOut, peerProfiles[1].state.transferOut]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return nextPayIdListHash map of a duplex channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", '     * @return nextPayIdListHashes of two simplex channels\n', '     */\n', '    function getNextPayIdListHashMap(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address[2] memory, bytes32[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].state.nextPayIdListHash, peerProfiles[1].state.nextPayIdListHash]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return lastPayResolveDeadline map of a duplex channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", '     * @return lastPayResolveDeadlines of two simplex channels\n', '     */\n', '    function getLastPayResolveDeadlineMap(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address[2] memory, uint[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].state.lastPayResolveDeadline, peerProfiles[1].state.lastPayResolveDeadline]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return pendingPayOut map of a duplex channel\n', '     * @param _c the channel to be viewed\n', "     * @return peers' addresses\n", '     * @return pendingPayOuts of two simplex channels\n', '     */\n', '    function getPendingPayOutMap(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address[2] memory, uint[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        return (\n', '            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\n', '            [peerProfiles[0].state.pendingPayOut, peerProfiles[1].state.pendingPayOut]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Return the withdraw intent info of the channel\n', '     * @param _c the channel to be viewed\n', '     * @return receiver of the withdraw intent\n', '     * @return amount of the withdraw intent\n', '     * @return requestTime of the withdraw intent\n', '     * @return recipientChannelId of the withdraw intent\n', '     */\n', '    function getWithdrawIntent(\n', '        LedgerStruct.Channel storage _c\n', '    )\n', '        external\n', '        view\n', '        returns(address, uint, uint, bytes32)\n', '    {\n', '        LedgerStruct.WithdrawIntent memory withdrawIntent = _c.withdrawIntent;\n', '        return (\n', '            withdrawIntent.receiver,\n', '            withdrawIntent.amount,\n', '            withdrawIntent.requestTime,\n', '            withdrawIntent.recipientChannelId\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Import channel migration arguments from old CelerLedger contract\n', '     * @param _c the channel to be viewed\n', '     * @param _fromLedgerAddr old ledger address to import channel config from\n', '     * @param _channelId ID of the channel to be viewed\n', '     * @dev related to Ledger Migration\n', '     */\n', '    function _importChannelMigrationArgs(\n', '        LedgerStruct.Channel storage _c,\n', '        address payable _fromLedgerAddr,\n', '        bytes32 _channelId\n', '    )\n', '        internal\n', '    {\n', '        uint tokenType;\n', '        (\n', '            _c.disputeTimeout,\n', '            tokenType,\n', '            _c.token.tokenAddress,\n', '            _c.cooperativeWithdrawSeqNum\n', '        ) = ICelerLedger(_fromLedgerAddr).getChannelMigrationArgs(_channelId);\n', '        _c.token.tokenType = PbEntity.TokenType(tokenType);\n', '    }\n', '\n', '    /**\n', "     * @notice import channel peers' migration info from old CelerLedger contract\n", '     * @param _c the channel to be viewed\n', '     * @param _fromLedgerAddr old ledger address to import channel config from\n', '     * @param _channelId ID of the channel to be viewed\n', '     * @dev related to Ledger Migration\n', '     */\n', '    function _importPeersMigrationInfo(\n', '        LedgerStruct.Channel storage _c,\n', '        address payable _fromLedgerAddr,\n', '        bytes32 _channelId\n', '    )\n', '        internal\n', '    {\n', '        (\n', '            address[2] memory peersAddrs,\n', '            uint[2] memory deposits,\n', '            uint[2] memory withdrawals,\n', '            uint[2] memory seqNums,\n', '            uint[2] memory transferOuts,\n', '            uint[2] memory pendingPayOuts\n', '        ) = ICelerLedger(_fromLedgerAddr).getPeersMigrationInfo(_channelId);\n', '\n', '        for (uint i = 0; i < 2; i++) {\n', '            LedgerStruct.PeerProfile storage peerProfile = _c.peerProfiles[i];\n', '            peerProfile.peerAddr = peersAddrs[i];\n', '            peerProfile.deposit = deposits[i];\n', '            peerProfile.withdrawal = withdrawals[i];\n', '            peerProfile.state.seqNum = seqNums[i];\n', '            peerProfile.state.transferOut = transferOuts[i];\n', '            peerProfile.state.pendingPayOut = pendingPayOuts[i];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the seqNums of two simplex channel states\n', '     * @param _c the channel\n', '     */\n', '    function _getStateSeqNums(LedgerStruct.Channel storage _c) internal view returns(uint[2] memory) {\n', '        return [_c.peerProfiles[0].state.seqNum, _c.peerProfiles[1].state.seqNum];\n', '    }\n', '\n', '    /**\n', '     * @notice Check if _addr is one of the peers in channel _c\n', '     * @param _c the channel\n', '     * @param _addr the address to check\n', '     * @return is peer or not\n', '     */\n', '    function _isPeer(LedgerStruct.Channel storage _c, address _addr) internal view returns(bool) {\n', '        return _addr == _c.peerProfiles[0].peerAddr || _addr == _c.peerProfiles[1].peerAddr;\n', '    }\n', '\n', '    /**\n', "     * @notice Get peer's ID\n", '     * @param _c the channel\n', '     * @param _peer address of peer\n', "     * @return peer's ID\n", '     */\n', '     function _getPeerId(LedgerStruct.Channel storage _c, address _peer) internal view returns(uint) {\n', '        if (_peer == _c.peerProfiles[0].peerAddr) {\n', '            return 0;\n', '        } else if (_peer == _c.peerProfiles[1].peerAddr) {\n', '            return 1;\n', '        } else {\n', '            revert("Nonexist peer");\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Check the correctness of one peer's signature\n", '     * @param _c the channel\n', '     * @param _h the hash of the message signed by the peer\n', '     * @param _sig signature of the peer\n', '     * @return message is signed by one of the peers or not\n', '     */\n', '    function _checkSingleSignature(\n', '        LedgerStruct.Channel storage _c,\n', '        bytes32 _h,\n', '        bytes memory _sig\n', '    )\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        address addr = _h.toEthSignedMessageHash().recover(_sig);\n', '        return _isPeer(_c, addr);\n', '    }\n', '\n', '    /**\n', '     * @notice Check the correctness of the co-signatures\n', '     * @param _c the channel\n', '     * @param _h the hash of the message signed by the peers\n', '     * @param _sigs signatures of the peers\n', '     * @return message are signed by both peers or not\n', '     */\n', '    function _checkCoSignatures(\n', '        LedgerStruct.Channel storage _c,\n', '        bytes32 _h,\n', '        bytes[] memory _sigs\n', '    )\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        if (_sigs.length != 2) {\n', '            return false;\n', '        }\n', '\n', '        // check signature\n', '        bytes32 hash = _h.toEthSignedMessageHash();\n', '        address addr;\n', '        for (uint i = 0; i < 2; i++) {\n', '            addr = hash.recover(_sigs[i]);\n', '            // enforce the order of sigs consistent with ascending addresses\n', '            if (addr != _c.peerProfiles[i].peerAddr) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Validate channel final balance\n', '     * @dev settleBalance = deposit - withdrawal + transferIn - transferOut\n', '     * @param _c the channel\n', '     * @return (balance is valid, settle balance)\n', '     */\n', '    function _validateSettleBalance(LedgerStruct.Channel storage _c)\n', '        internal\n', '        view\n', '        returns(bool, uint[2] memory)\n', '    {\n', '        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\n', '        uint[2] memory settleBalance = [\n', '            peerProfiles[0].deposit.add(peerProfiles[1].state.transferOut),\n', '            peerProfiles[1].deposit.add(peerProfiles[0].state.transferOut)\n', '        ];\n', '        for (uint i = 0; i < 2; i++) {\n', '            uint subAmt = peerProfiles[i].state.transferOut.add(peerProfiles[i].withdrawal);\n', '            if (settleBalance[i] < subAmt) {\n', '                return (false, [uint(0), uint(0)]);\n', '            }\n', '\n', '            settleBalance[i] = settleBalance[i].sub(subAmt);\n', '        }\n', '\n', '        return (true, settleBalance);\n', '    }\n', '\n', '    /**\n', "     * @notice Update record of one peer's withdrawal amount\n", '     * @param _c the channel\n', '     * @param _receiver receiver of this new withdrawal\n', '     * @param _amount amount of this new withdrawal\n', '     * @param _checkBalance check the balance if this is true\n', '     */\n', '    function _addWithdrawal(\n', '        LedgerStruct.Channel storage _c,\n', '        address _receiver,\n', '        uint _amount,\n', '        bool _checkBalance\n', '    )\n', '        internal\n', '    {\n', '        // this implicitly require receiver be a peer\n', '        uint rid = _getPeerId(_c, _receiver);\n', '        _c.peerProfiles[rid].withdrawal = _c.peerProfiles[rid].withdrawal.add(_amount);\n', '        if (_checkBalance) {\n', '            require(getTotalBalance(_c) >= 0);\n', '        }\n', '    }\n', '}']