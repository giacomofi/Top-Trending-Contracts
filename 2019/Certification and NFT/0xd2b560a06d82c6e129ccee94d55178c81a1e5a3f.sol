['pragma solidity ^0.5.0;\n', '\n', '\n', 'interface IERC20 {\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface Kyber {\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    ) external payable returns (uint);\n', '\n', '    function getExpectedRate(\n', '        address src,\n', '        address dest,\n', '        uint srcQty\n', '    ) external view returns (uint, uint);\n', '}\n', '\n', '\n', 'contract KyberSwap {\n', '\n', '    address public kyberAddress;\n', '    address public daiAddress;\n', '    address public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address public admin;\n', '    uint public fees;\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin, "Permission Denied");\n', '        _;\n', '    }\n', '\n', '    function getExpectedPrice(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt\n', '    ) public view returns (uint, uint)\n', '    {\n', '        Kyber kyberFunctions = Kyber(kyberAddress);\n', '        return kyberFunctions.getExpectedRate(\n', '            src,\n', '            dest,\n', '            srcAmt\n', '        );\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract PayModel is KyberSwap {\n', '\n', '    event Paid(address payer, address receiver, uint amount, address token);\n', '\n', '    function payETH(\n', '        uint daiToPay, // max amount of dest token\n', '        address payTo\n', '    ) public payable returns (uint destAmt)\n', '    {\n', '        Kyber kyberFunctions = Kyber(kyberAddress); // Interacting with Kyber Proxy Contract\n', '\n', '        uint minConversionRate;\n', '        (, minConversionRate) = kyberFunctions.getExpectedRate(\n', '            ethAddress,\n', '            daiAddress,\n', '            msg.value\n', '        );\n', '        \n', '        destAmt = kyberFunctions.trade.value(msg.value)(\n', '            ethAddress, // src is ETH\n', '            msg.value, // srcAmt\n', '            daiAddress, // dest is DAI\n', '            address(this), // destAmt receiver\n', '            daiToPay, // max destAmt\n', '            minConversionRate, // min accepted conversion rate\n', '            admin // affiliate\n', '        );\n', '        require(daiToPay == destAmt, "Can\'t pay less.");\n', '\n', '        IERC20 daiToken = IERC20(daiAddress);\n', '        daiToken.transfer(payTo, daiToPay * fees / 1000);\n', '        \n', '        // maxDestAmt usecase implementated (only works with ETH)\n', '        msg.sender.transfer(address(this).balance);\n', '\n', '        emit Paid(\n', '            msg.sender, payTo, daiToPay, ethAddress\n', '        );\n', '    }\n', '\n', '    function payDAI(address payTo, uint daiToPay) public {\n', '        IERC20 daiToken = IERC20(daiAddress);\n', '        daiToken.transferFrom(msg.sender, payTo, daiToPay * fees / 1000);\n', '        emit Paid(\n', '            msg.sender, payTo, daiToPay, daiAddress\n', '        );\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract PayDApp is PayModel {\n', '\n', '    constructor(address proxyAddr, address daiAddr) public {\n', '        kyberAddress = proxyAddr;\n', '        daiAddress = daiAddr;\n', '        admin = msg.sender;\n', '        fees = 995;\n', '    }\n', '\n', '    function () external payable {}\n', '\n', '    function setFees(uint newFee) public onlyAdmin {\n', '        fees = newFee;\n', '    }\n', '\n', '    function collectFees(uint amount) public onlyAdmin {\n', '        IERC20 daiToken = IERC20(daiAddress);\n', '        daiToken.transfer(admin, amount);\n', '    }\n', '\n', '    function setAdmin(address newAdmin) public onlyAdmin {\n', '        admin = newAdmin;\n', '    }\n', '\n', '}']