['// File: @ensdomains/ens/contracts/ENS.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface ENS {\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Deed.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', 'interface Deed {\n', '\n', '    function setOwner(address payable newOwner) external;\n', '    function setRegistrar(address newRegistrar) external;\n', '    function setBalance(uint newValue, bool throwOnFailure) external;\n', '    function closeDeed(uint refundRatio) external;\n', '    function destroyDeed() external;\n', '\n', '    function owner() external view returns (address);\n', '    function previousOwner() external view returns (address);\n', '    function value() external view returns (uint);\n', '    function creationDate() external view returns (uint);\n', '\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/DeedImplementation.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title Deed to hold ether in exchange for ownership of a node\n', ' * @dev The deed can be controlled only by the registrar and can only send ether back to the owner.\n', ' */\n', 'contract DeedImplementation is Deed {\n', '\n', '    address payable constant burn = address(0xdead);\n', '\n', '    address payable private _owner;\n', '    address private _previousOwner;\n', '    address private _registrar;\n', '\n', '    uint private _creationDate;\n', '    uint private _value;\n', '\n', '    bool active;\n', '\n', '    event OwnerChanged(address newOwner);\n', '    event DeedClosed();\n', '\n', '    modifier onlyRegistrar {\n', '        require(msg.sender == _registrar);\n', '        _;\n', '    }\n', '\n', '    modifier onlyActive {\n', '        require(active);\n', '        _;\n', '    }\n', '\n', '    constructor(address payable initialOwner) public payable {\n', '        _owner = initialOwner;\n', '        _registrar = msg.sender;\n', '        _creationDate = now;\n', '        active = true;\n', '        _value = msg.value;\n', '    }\n', '\n', '    function setOwner(address payable newOwner) external onlyRegistrar {\n', '        require(newOwner != address(0x0));\n', '        _previousOwner = _owner;  // This allows contracts to check who sent them the ownership\n', '        _owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '\n', '    function setRegistrar(address newRegistrar) external onlyRegistrar {\n', '        _registrar = newRegistrar;\n', '    }\n', '\n', '    function setBalance(uint newValue, bool throwOnFailure) external onlyRegistrar onlyActive {\n', '        // Check if it has enough balance to set the value\n', '        require(_value >= newValue);\n', '        _value = newValue;\n', '        // Send the difference to the owner\n', '        require(_owner.send(address(this).balance - newValue) || !throwOnFailure);\n', '    }\n', '\n', '    /**\n', '     * @dev Close a deed and refund a specified fraction of the bid value\n', '     *\n', '     * @param refundRatio The amount*1/1000 to refund\n', '     */\n', '    function closeDeed(uint refundRatio) external onlyRegistrar onlyActive {\n', '        active = false;\n', '        require(burn.send(((1000 - refundRatio) * address(this).balance)/1000));\n', '        emit DeedClosed();\n', '        _destroyDeed();\n', '    }\n', '\n', '    /**\n', '     * @dev Close a deed and refund a specified fraction of the bid value\n', '     */\n', '    function destroyDeed() external {\n', '        _destroyDeed();\n', '    }\n', '\n', '    function owner() external view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    function previousOwner() external view returns (address) {\n', '        return _previousOwner;\n', '    }\n', '\n', '    function value() external view returns (uint) {\n', '        return _value;\n', '    }\n', '\n', '    function creationDate() external view returns (uint) {\n', '        _creationDate;\n', '    }\n', '\n', '    function _destroyDeed() internal {\n', '        require(!active);\n', '\n', '        // Instead of selfdestruct(owner), invoke owner fallback function to allow\n', '        // owner to log an event if desired; but owner should also be aware that\n', '        // its fallback function can also be invoked by setBalance\n', '        if (_owner.send(address(this).balance)) {\n', '            selfdestruct(burn);\n', '        }\n', '    }\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/Registrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', 'interface Registrar {\n', '\n', '    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\n', '\n', '    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n', '    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n', '    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n', '    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n', '    event HashReleased(bytes32 indexed hash, uint value);\n', '    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\n', '\n', '    function startAuction(bytes32 _hash) external;\n', '    function startAuctions(bytes32[] calldata _hashes) external;\n', '    function newBid(bytes32 sealedBid) external payable;\n', '    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\n', '    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\n', '    function cancelBid(address bidder, bytes32 seal) external;\n', '    function finalizeAuction(bytes32 _hash) external;\n', '    function transfer(bytes32 _hash, address payable newOwner) external;\n', '    function releaseDeed(bytes32 _hash) external;\n', '    function invalidateName(string calldata unhashedName) external;\n', '    function eraseNode(bytes32[] calldata labels) external;\n', '    function transferRegistrars(bytes32 _hash) external;\n', '    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\n', '    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\n', '}\n', '\n', '// File: @ensdomains/ens/contracts/HashRegistrar.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/*\n', '\n', 'Temporary Hash Registrar\n', '========================\n', '\n', 'This is a simplified version of a hash registrar. It is purporsefully limited:\n', 'names cannot be six letters or shorter, new auctions will stop after 4 years.\n', '\n', 'The plan is to test the basic features and then move to a new contract in at most\n', '2 years, when some sort of renewal mechanism will be enabled.\n', '*/\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Registrar\n', ' * @dev The registrar handles the auction process for each subnode of the node it owns.\n', ' */\n', 'contract HashRegistrar is Registrar {\n', '    ENS public ens;\n', '    bytes32 public rootNode;\n', '\n', '    mapping (bytes32 => Entry) _entries;\n', '    mapping (address => mapping (bytes32 => Deed)) public sealedBids;\n', '\n', '    uint32 constant totalAuctionLength = 5 days;\n', '    uint32 constant revealPeriod = 48 hours;\n', '    uint32 public constant launchLength = 8 weeks;\n', '\n', '    uint constant minPrice = 0.01 ether;\n', '    uint public registryStarted;\n', '\n', '    struct Entry {\n', '        Deed deed;\n', '        uint registrationDate;\n', '        uint value;\n', '        uint highestBid;\n', '    }\n', '\n', '    modifier inState(bytes32 _hash, Mode _state) {\n', '        require(state(_hash) == _state);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner(bytes32 _hash) {\n', '        require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner());\n', '        _;\n', '    }\n', '\n', '    modifier registryOpen() {\n', '        require(now >= registryStarted && now <= registryStarted + (365 * 4) * 1 days && ens.owner(rootNode) == address(this));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n', '     *\n', '     * @param _ens The address of the ENS\n', '     * @param _rootNode The hash of the rootnode.\n', '     */\n', '    constructor(ENS _ens, bytes32 _rootNode, uint _startDate) public {\n', '        ens = _ens;\n', '        rootNode = _rootNode;\n', '        registryStarted = _startDate > 0 ? _startDate : now;\n', '    }\n', '\n', '    /**\n', '     * @dev Start an auction for an available hash\n', '     *\n', '     * @param _hash The hash to start an auction on\n', '     */\n', '    function startAuction(bytes32 _hash) external {\n', '        _startAuction(_hash);\n', '    }\n', '\n', '    /**\n', '     * @dev Start multiple auctions for better anonymity\n', '     *\n', '     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n', '     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n', '     * are only really interested in bidding for one. This will increase the cost for an\n', '     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n', '     * open but not bid on are closed after a week.\n', '     *\n', '     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n', '     */\n', '    function startAuctions(bytes32[] calldata _hashes) external {\n', '        _startAuctions(_hashes);\n', '    }\n', '\n', '    /**\n', '     * @dev Submit a new sealed bid on a desired hash in a blind auction\n', '     *\n', '     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n', '     * contains information about the bid, including the bidded hash, the bid amount, and a random\n', '     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n', '     * itself can be masqueraded by sending more than the value of your actual bid. This is\n', '     * followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable.\n', '     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n', '     * words, will have multiple bidders pushing the price up.\n', '     *\n', '     * @param sealedBid A sealedBid, created by the shaBid function\n', '     */\n', '    function newBid(bytes32 sealedBid) external payable {\n', '        _newBid(sealedBid);\n', '    }\n', '\n', '    /**\n', '     * @dev Start a set of auctions and bid on one of them\n', '     *\n', '     * This method functions identically to calling `startAuctions` followed by `newBid`,\n', '     * but all in one transaction.\n', '     *\n', '     * @param hashes A list of hashes to start auctions on.\n', '     * @param sealedBid A sealed bid for one of the auctions.\n', '     */\n', '    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable {\n', '        _startAuctions(hashes);\n', '        _newBid(sealedBid);\n', '    }\n', '\n', '    /**\n', '     * @dev Submit the properties of a bid to reveal them\n', '     *\n', '     * @param _hash The node in the sealedBid\n', '     * @param _value The bid amount in the sealedBid\n', '     * @param _salt The sale in the sealedBid\n', '     */\n', '    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external {\n', '        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n', '        Deed bid = sealedBids[msg.sender][seal];\n', '        require(address(bid) != address(0x0));\n', '\n', '        sealedBids[msg.sender][seal] = Deed(address(0x0));\n', '        Entry storage h = _entries[_hash];\n', '        uint value = min(_value, bid.value());\n', '        bid.setBalance(value, true);\n', '\n', '        Mode auctionState = state(_hash);\n', '        if (auctionState == Mode.Owned) {\n', '            // Too late! Bidder loses their bid. Gets 0.5% back.\n', '            bid.closeDeed(5);\n', '            emit BidRevealed(_hash, msg.sender, value, 1);\n', '        } else if (auctionState != Mode.Reveal) {\n', '            // Invalid phase\n', '            revert();\n', '        } else if (value < minPrice || bid.creationDate() > h.registrationDate - revealPeriod) {\n', '            // Bid too low or too late, refund 99.5%\n', '            bid.closeDeed(995);\n', '            emit BidRevealed(_hash, msg.sender, value, 0);\n', '        } else if (value > h.highestBid) {\n', '            // New winner\n', '            // Cancel the other bid, refund 99.5%\n', '            if (address(h.deed) != address(0x0)) {\n', '                Deed previousWinner = h.deed;\n', '                previousWinner.closeDeed(995);\n', '            }\n', '\n', '            // Set new winner\n', '            // Per the rules of a vickery auction, the value becomes the previous highestBid\n', "            h.value = h.highestBid;  // will be zero if there's only 1 bidder\n", '            h.highestBid = value;\n', '            h.deed = bid;\n', '            emit BidRevealed(_hash, msg.sender, value, 2);\n', '        } else if (value > h.value) {\n', '            // Not winner, but affects second place\n', '            h.value = value;\n', '            bid.closeDeed(995);\n', '            emit BidRevealed(_hash, msg.sender, value, 3);\n', '        } else {\n', "            // Bid doesn't affect auction\n", '            bid.closeDeed(995);\n', '            emit BidRevealed(_hash, msg.sender, value, 4);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel a bid\n', '     *\n', '     * @param seal The value returned by the shaBid function\n', '     */\n', '    function cancelBid(address bidder, bytes32 seal) external {\n', '        Deed bid = sealedBids[bidder][seal];\n', '        \n', '        // If a sole bidder does not `unsealBid` in time, they have a few more days\n', '        // where they can call `startAuction` (again) and then `unsealBid` during\n', '        // the revealPeriod to get back their bid value.\n', '        // For simplicity, they should call `startAuction` within\n', '        // 9 days (2 weeks - totalAuctionLength), otherwise their bid will be\n', '        // cancellable by anyone.\n', '        require(address(bid) != address(0x0) && now >= bid.creationDate() + totalAuctionLength + 2 weeks);\n', '\n', '        // Send the canceller 0.5% of the bid, and burn the rest.\n', '        bid.setOwner(msg.sender);\n', '        bid.closeDeed(5);\n', '        sealedBids[bidder][seal] = Deed(0);\n', '        emit BidRevealed(seal, bidder, 0, 5);\n', '    }\n', '\n', '    /**\n', '     * @dev Finalize an auction after the registration date has passed\n', '     *\n', '     * @param _hash The hash of the name the auction is for\n', '     */\n', '    function finalizeAuction(bytes32 _hash) external onlyOwner(_hash) {\n', '        Entry storage h = _entries[_hash];\n', '        \n', "        // Handles the case when there's only a single bidder (h.value is zero)\n", '        h.value = max(h.value, minPrice);\n', '        h.deed.setBalance(h.value, true);\n', '\n', '        trySetSubnodeOwner(_hash, h.deed.owner());\n', '        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n', '    }\n', '\n', '    /**\n', '     * @dev The owner of a domain may transfer it to someone else at any time.\n', '     *\n', '     * @param _hash The node to transfer\n', '     * @param newOwner The address to transfer ownership to\n', '     */\n', '    function transfer(bytes32 _hash, address payable newOwner) external onlyOwner(_hash) {\n', '        require(newOwner != address(0x0));\n', '\n', '        Entry storage h = _entries[_hash];\n', '        h.deed.setOwner(newOwner);\n', '        trySetSubnodeOwner(_hash, newOwner);\n', '    }\n', '\n', '    /**\n', "     * @dev After some time, or if we're no longer the registrar, the owner can release\n", '     *      the name and get their ether back.\n', '     *\n', '     * @param _hash The node to release\n', '     */\n', '    function releaseDeed(bytes32 _hash) external onlyOwner(_hash) {\n', '        Entry storage h = _entries[_hash];\n', '        Deed deedContract = h.deed;\n', '\n', '        require(now >= h.registrationDate + 365 days || ens.owner(rootNode) != address(this));\n', '\n', '        h.value = 0;\n', '        h.highestBid = 0;\n', '        h.deed = Deed(0);\n', '\n', '        _tryEraseSingleNode(_hash);\n', '        deedContract.closeDeed(1000);\n', '        emit HashReleased(_hash, h.value);        \n', '    }\n', '\n', '    /**\n', '     * @dev Submit a name 6 characters long or less. If it has been registered,\n', '     *      the submitter will earn 50% of the deed value. \n', '     * \n', '     * We are purposefully handicapping the simplified registrar as a way \n', '     * to force it into being restructured in a few years.\n', '     *\n', '     * @param unhashedName An invalid name to search for in the registry.\n', '     */\n', '    function invalidateName(string calldata unhashedName)\n', '        external\n', '        inState(keccak256(abi.encode(unhashedName)), Mode.Owned)\n', '    {\n', '        require(strlen(unhashedName) <= 6);\n', '        bytes32 hash = keccak256(abi.encode(unhashedName));\n', '\n', '        Entry storage h = _entries[hash];\n', '\n', '        _tryEraseSingleNode(hash);\n', '\n', '        if (address(h.deed) != address(0x0)) {\n', '            // Reward the discoverer with 50% of the deed\n', '            // The previous owner gets 50%\n', '            h.value = max(h.value, minPrice);\n', '            h.deed.setBalance(h.value/2, false);\n', '            h.deed.setOwner(msg.sender);\n', '            h.deed.closeDeed(1000);\n', '        }\n', '\n', '        emit HashInvalidated(hash, unhashedName, h.value, h.registrationDate);\n', '\n', '        h.value = 0;\n', '        h.highestBid = 0;\n', '        h.deed = Deed(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n', "     *      name that is not currently owned in the registrar. If passing, eg, 'foo.bar.eth',\n", "     *      the owner and resolver fields on 'foo.bar.eth' and 'bar.eth' will all be cleared.\n", '     *\n', '     * @param labels A series of label hashes identifying the name to zero out, rooted at the\n', "     *        registrar's root. Must contain at least one element. For instance, to zero \n", "     *        'foo.bar.eth' on a registrar that owns '.eth', pass an array containing\n", "     *        [keccak256('foo'), keccak256('bar')].\n", '     */\n', '    function eraseNode(bytes32[] calldata labels) external {\n', '        require(labels.length != 0);\n', '        require(state(labels[labels.length - 1]) != Mode.Owned);\n', '\n', '        _eraseNodeHierarchy(labels.length - 1, labels, rootNode);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the deed to the current registrar, if different from this one.\n', '     *\n', '     * Used during the upgrade process to a permanent registrar.\n', '     *\n', '     * @param _hash The name hash to transfer.\n', '     */\n', '    function transferRegistrars(bytes32 _hash) external onlyOwner(_hash) {\n', '        address registrar = ens.owner(rootNode);\n', '        require(registrar != address(this));\n', '\n', '        // Migrate the deed\n', '        Entry storage h = _entries[_hash];\n', '        h.deed.setRegistrar(registrar);\n', '\n', '        // Call the new registrar to accept the transfer\n', '        Registrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n', '\n', '        // Zero out the Entry\n', '        h.deed = Deed(0);\n', '        h.registrationDate = 0;\n', '        h.value = 0;\n', '        h.highestBid = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n', '     *      is no previous registrar implementing this interface.\n', '     *\n', '     * @param hash The sha3 hash of the label to transfer.\n', '     * @param deed The Deed object for the name being transferred in.\n', '     * @param registrationDate The date at which the name was originally registered.\n', '     */\n', '    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external {\n', "        hash; deed; registrationDate; // Don't warn about unused variables\n", '    }\n', '\n', '    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint) {\n', '        Entry storage h = _entries[_hash];\n', '        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\n', '    }\n', '\n', '    // State transitions for names:\n', '    //   Open -> Auction (startAuction)\n', '    //   Auction -> Reveal\n', '    //   Reveal -> Owned\n', '    //   Reveal -> Open (if nobody bid)\n', '    //   Owned -> Open (releaseDeed or invalidateName)\n', '    function state(bytes32 _hash) public view returns (Mode) {\n', '        Entry storage entry = _entries[_hash];\n', '\n', '        if (!isAllowed(_hash, now)) {\n', '            return Mode.NotYetAvailable;\n', '        } else if (now < entry.registrationDate) {\n', '            if (now < entry.registrationDate - revealPeriod) {\n', '                return Mode.Auction;\n', '            } else {\n', '                return Mode.Reveal;\n', '            }\n', '        } else {\n', '            if (entry.highestBid == 0) {\n', '                return Mode.Open;\n', '            } else {\n', '                return Mode.Owned;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Determines if a name is available for registration yet\n', '     *\n', '     * Each name will be assigned a random date in which its auction\n', '     * can be started, from 0 to 8 weeks\n', '     *\n', '     * @param _hash The hash to start an auction on\n', '     * @param _timestamp The timestamp to query about\n', '     */\n', '    function isAllowed(bytes32 _hash, uint _timestamp) public view returns (bool allowed) {\n', '        return _timestamp > getAllowedTime(_hash);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns available date for hash\n', '     *\n', '     * The available time from the `registryStarted` for a hash is proportional\n', '     * to its numeric value.\n', '     *\n', '     * @param _hash The hash to start an auction on\n', '     */\n', '    function getAllowedTime(bytes32 _hash) public view returns (uint) {\n', '        return registryStarted + ((launchLength * (uint(_hash) >> 128)) >> 128);\n', '        // Right shift operator: a >> b == a / 2**b\n', '    }\n', '\n', '    /**\n', '     * @dev Hash the values required for a secret bid\n', '     *\n', '     * @param hash The node corresponding to the desired namehash\n', '     * @param value The bid amount\n', '     * @param salt A random value to ensure secrecy of the bid\n', '     * @return The hash of the bid values\n', '     */\n', '    function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) public pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(hash, owner, value, salt));\n', '    }\n', '\n', '    function _tryEraseSingleNode(bytes32 label) internal {\n', '        if (ens.owner(rootNode) == address(this)) {\n', '            ens.setSubnodeOwner(rootNode, label, address(this));\n', '            bytes32 node = keccak256(abi.encodePacked(rootNode, label));\n', '            ens.setResolver(node, address(0x0));\n', '            ens.setOwner(node, address(0x0));\n', '        }\n', '    }\n', '\n', '    function _startAuction(bytes32 _hash) internal registryOpen() {\n', '        Mode mode = state(_hash);\n', '        if (mode == Mode.Auction) return;\n', '        require(mode == Mode.Open);\n', '\n', '        Entry storage newAuction = _entries[_hash];\n', '        newAuction.registrationDate = now + totalAuctionLength;\n', '        newAuction.value = 0;\n', '        newAuction.highestBid = 0;\n', '        emit AuctionStarted(_hash, newAuction.registrationDate);\n', '    }\n', '\n', '    function _startAuctions(bytes32[] memory _hashes) internal {\n', '        for (uint i = 0; i < _hashes.length; i ++) {\n', '            _startAuction(_hashes[i]);\n', '        }\n', '    }\n', '\n', '    function _newBid(bytes32 sealedBid) internal {\n', '        require(address(sealedBids[msg.sender][sealedBid]) == address(0x0));\n', '        require(msg.value >= minPrice);\n', '\n', '        // Creates a new hash contract with the owner\n', '        Deed bid = (new DeedImplementation).value(msg.value)(msg.sender);\n', '        sealedBids[msg.sender][sealedBid] = bid;\n', '        emit NewBid(sealedBid, msg.sender, msg.value);\n', '    }\n', '\n', '    function _eraseNodeHierarchy(uint idx, bytes32[] memory labels, bytes32 node) internal {\n', '        // Take ownership of the node\n', '        ens.setSubnodeOwner(node, labels[idx], address(this));\n', '        node = keccak256(abi.encodePacked(node, labels[idx]));\n', '\n', '        // Recurse if there are more labels\n', '        if (idx > 0) {\n', '            _eraseNodeHierarchy(idx - 1, labels, node);\n', '        }\n', '\n', '        // Erase the resolver and owner records\n', '        ens.setResolver(node, address(0x0));\n', '        ens.setOwner(node, address(0x0));\n', '    }\n', '\n', '    /**\n', "     * @dev Assign the owner in ENS, if we're still the registrar\n", '     *\n', '     * @param _hash hash to change owner\n', '     * @param _newOwner new owner to transfer to\n', '     */\n', '    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n', '        if (ens.owner(rootNode) == address(this))\n', '            ens.setSubnodeOwner(rootNode, _hash, _newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the maximum of two unsigned integers\n', '     *\n', '     * @param a A number to compare\n', '     * @param b A number to compare\n', '     * @return The maximum of two unsigned integers\n', '     */\n', '    function max(uint a, uint b) internal pure returns (uint) {\n', '        if (a > b)\n', '            return a;\n', '        else\n', '            return b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the minimum of two unsigned integers\n', '     *\n', '     * @param a A number to compare\n', '     * @param b A number to compare\n', '     * @return The minimum of two unsigned integers\n', '     */\n', '    function min(uint a, uint b) internal pure returns (uint) {\n', '        if (a < b)\n', '            return a;\n', '        else\n', '            return b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the length of a given string\n', '     *\n', '     * @param s The string to measure the length of\n', '     * @return The length of the input string\n', '     */\n', '    function strlen(string memory s) internal pure returns (uint) {\n', "        s; // Don't warn about unused variables\n", '        // Starting here means the LSB will be the byte we care about\n', '        uint ptr;\n', '        uint end;\n', '        assembly {\n', '            ptr := add(s, 1)\n', '            end := add(mload(s), ptr)\n', '        }\n', '        uint len = 0;\n', '        for (len; ptr < end; len++) {\n', '            uint8 b;\n', '            assembly { b := and(mload(ptr), 0xFF) }\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if (b < 0xE0) {\n', '                ptr += 2;\n', '            } else if (b < 0xF0) {\n', '                ptr += 3;\n', '            } else if (b < 0xF8) {\n', '                ptr += 4;\n', '            } else if (b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '        return len;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /**\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => uint256) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     *    is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner);\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: @ensdomains/ethregistrar/contracts/BaseRegistrar.sol\n', '\n', 'pragma solidity >=0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract BaseRegistrar is ERC721, Ownable {\n', '    uint constant public GRACE_PERIOD = 90 days;\n', '\n', '    event ControllerAdded(address indexed controller);\n', '    event ControllerRemoved(address indexed controller);\n', '    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n', '    event NameRenewed(uint256 indexed id, uint expires);\n', '\n', '    // Expiration timestamp for migrated domains.\n', '    uint public transferPeriodEnds;\n', '\n', '    // The ENS registry\n', '    ENS public ens;\n', '\n', '    // The namehash of the TLD this registrar owns (eg, .eth)\n', '    bytes32 public baseNode;\n', '\n', '    // The interim registrar\n', '    HashRegistrar public previousRegistrar;\n', '\n', '    // A map of addresses that are authorised to register and renew names.\n', '    mapping(address=>bool) public controllers;\n', '\n', '    // Authorises a controller, who can register and renew domains.\n', '    function addController(address controller) external;\n', '\n', '    // Revoke controller permission for an address.\n', '    function removeController(address controller) external;\n', '\n', '    // Set the resolver for the TLD this registrar manages.\n', '    function setResolver(address resolver) external;\n', '\n', '    // Returns the expiration timestamp of the specified label hash.\n', '    function nameExpires(uint256 id) external view returns(uint);\n', '\n', '    // Returns true iff the specified name is available for registration.\n', '    function available(uint256 id) public view returns(bool);\n', '\n', '    /**\n', '     * @dev Register a name.\n', '     */\n', '    function register(uint256 id, address owner, uint duration) external returns(uint);\n', '\n', '    function renew(uint256 id, uint duration) external returns(uint);\n', '\n', '    /**\n', '     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n', '     */\n', '    function reclaim(uint256 id, address owner) external;\n', '\n', '    /**\n', '     * @dev Transfers a registration from the initial registrar.\n', '     * This function is called by the initial registrar when a user calls `transferRegistrars`.\n', '     */\n', '    function acceptRegistrarTransfer(bytes32 label, Deed deed, uint) external;\n', '}\n', '\n', '// File: contracts/Resolver.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @dev A basic interface for ENS resolvers.\n', ' */\n', 'contract Resolver {\n', '    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\n', '    function addr(bytes32 node) public view returns (address);\n', '    function setAddr(bytes32 node, address addr) public;\n', '}\n', '\n', '// File: contracts/RegistrarInterface.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract RegistrarInterface {\n', '    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\n', '    event DomainConfigured(bytes32 indexed label);\n', '    event DomainUnlisted(bytes32 indexed label);\n', '    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address indexed referrer, uint price);\n', '    event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);\n', '\n', '    // InterfaceID of these four methods is 0xc1b15f5a\n', '    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint signupFee, uint rent, uint referralFeePPM);\n', '    function register(bytes32 label, string calldata subdomain, address owner, address payable referrer, address resolver) external payable;\n', '\n', '    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp);\n', '    function payRent(bytes32 label, string calldata subdomain) external payable;\n', '}\n', '\n', '// File: contracts/AbstractSubdomainRegistrar.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', 'contract AbstractSubdomainRegistrar is RegistrarInterface {\n', '\n', "    // namehash('eth')\n", '    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n', '\n', '    bool public stopped = false;\n', '    address public registrarOwner;\n', '    address public migration;\n', '\n', '    address public registrar;\n', '\n', '    ENS public ens;\n', '\n', '    modifier owner_only(bytes32 label) {\n', '        require(owner(label) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier not_stopped() {\n', '        require(!stopped);\n', '        _;\n', '    }\n', '\n', '    modifier registrar_owner_only() {\n', '        require(msg.sender == registrarOwner);\n', '        _;\n', '    }\n', '\n', '    event DomainTransferred(bytes32 indexed label, string name);\n', '\n', '    constructor(ENS _ens) public {\n', '        ens = _ens;\n', '        registrar = ens.owner(TLD_NODE);\n', '        registrarOwner = msg.sender;\n', '    }\n', '\n', '    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n', '        // Get the subdomain so we can configure it\n', '        ens.setSubnodeOwner(node, label, address(this));\n', '\n', '        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n', "        // Set the subdomain's resolver\n", '        ens.setResolver(subnode, address(resolver));\n', '\n', '        // Set the address record on the resolver\n', '        resolver.setAddr(subnode, subdomainOwner);\n', '\n', '        // Pass ownership of the new subdomain to the registrant\n', '        ens.setOwner(subnode, subdomainOwner);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n', '        return (\n', '            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\n', '            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\n', '        );\n', '    }\n', '\n', '    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\n', '        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the resolver record for a name in ENS.\n', '     * @param name The name to set the resolver for.\n', '     * @param resolver The address of the resolver\n', '     */\n', '    function setResolver(string memory name, address resolver) public owner_only(keccak256(bytes(name))) {\n', '        bytes32 label = keccak256(bytes(name));\n', '        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\n', '        ens.setResolver(node, resolver);\n', '    }\n', '\n', '    /**\n', '     * @dev Configures a domain for sale.\n', '     * @param name The name to configure.\n', '     * @param price The price in wei to charge for subdomain registrations\n', '     * @param referralFeePPM The referral fee to offer, in parts per million\n', '     */\n', '    function configureDomain(string memory name, uint price, uint referralFeePPM) public {\n', '        configureDomainFor(name, price, referralFeePPM, msg.sender, address(0x0));\n', '    }\n', '\n', '    /**\n', '     * @dev Stops the registrar, disabling configuring of new domains.\n', '     */\n', '    function stop() public not_stopped registrar_owner_only {\n', '        stopped = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address where domains are migrated to.\n', '     * @param _migration Address of the new registrar.\n', '     */\n', '    function setMigrationAddress(address _migration) public registrar_owner_only {\n', '        require(stopped);\n', '        migration = _migration;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public registrar_owner_only {\n', '        registrarOwner = newOwner;\n', '    }\n', '\n', '    function owner(bytes32 label) public view returns (address);\n', '    function configureDomainFor(string memory name, uint price, uint referralFeePPM, address payable _owner, address _transfer) public;\n', '}\n', '\n', '// File: contracts/EthRegistrarSubdomainRegistrar.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Implements an ENS registrar that sells subdomains on behalf of their owners.\n', ' *\n', ' * Users may register a subdomain by calling `register` with the name of the domain\n', ' * they wish to register under, and the label hash of the subdomain they want to\n', ' * register. They must also specify the new owner of the domain, and the referrer,\n', " * who is paid an optional finder's fee. The registrar then configures a simple\n", ' * default resolver, which resolves `addr` lookups to the new owner, and sets\n', ' * the `owner` account as the owner of the subdomain in ENS.\n', ' *\n', ' * New domains may be added by calling `configureDomain`, then transferring\n', ' * ownership in the ENS registry to this contract. Ownership in the contract\n', ' * may be transferred using `transfer`, and a domain may be unlisted for sale\n', ' * using `unlistDomain`. There is (deliberately) no way to recover ownership\n', ' * in ENS once the name is transferred to this registrar.\n', ' *\n', ' * Critically, this contract does not check one key property of a listed domain:\n', ' *\n', ' * - Is the name UTS46 normalised?\n', ' *\n', ' * User applications MUST check these two elements for each domain before\n', ' * offering them to users for registration.\n', ' *\n', ' * Applications should additionally check that the domains they are offering to\n', ' * register are controlled by this registrar, since calls to `register` will\n', ' * fail if this is not the case.\n', ' */\n', 'contract EthRegistrarSubdomainRegistrar is AbstractSubdomainRegistrar {\n', '\n', '    struct Domain {\n', '        string name;\n', '        address payable owner;\n', '        uint price;\n', '        uint referralFeePPM;\n', '    }\n', '\n', '    mapping (bytes32 => Domain) domains;\n', '\n', '    constructor(ENS ens) AbstractSubdomainRegistrar(ens) public { }\n', '\n', '    /**\n', '     * @dev owner returns the address of the account that controls a domain.\n', '     *      Initially this is a null address. If the name has been\n', '     *      transferred to this contract, then the internal mapping is consulted\n', '     *      to determine who controls it. If the owner is not set,\n', '     *      the owner of the domain in the Registrar is returned.\n', '     * @param label The label hash of the deed to check.\n', '     * @return The address owning the deed.\n', '     */\n', '    function owner(bytes32 label) public view returns (address) {\n', '        if (domains[label].owner != address(0x0)) {\n', '            return domains[label].owner;\n', '        }\n', '\n', '        return BaseRegistrar(registrar).ownerOf(uint256(label));\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers internal control of a name to a new account. Does not update\n', '     *      ENS.\n', '     * @param name The name to transfer.\n', '     * @param newOwner The address of the new owner.\n', '     */\n', '    function transfer(string memory name, address payable newOwner) public owner_only(keccak256(bytes(name))) {\n', '        bytes32 label = keccak256(bytes(name));\n', '        emit OwnerChanged(label, domains[label].owner, newOwner);\n', '        domains[label].owner = newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Configures a domain, optionally transferring it to a new owner.\n', '     * @param name The name to configure.\n', '     * @param price The price in wei to charge for subdomain registrations.\n', '     * @param referralFeePPM The referral fee to offer, in parts per million.\n', '     * @param _owner The address to assign ownership of this domain to.\n', '     * @param _transfer The address to set as the transfer address for the name\n', '     *        when the permanent registrar is replaced. Can only be set to a non-zero\n', '     *        value once.\n', '     */\n', '    function configureDomainFor(string memory name, uint price, uint referralFeePPM, address payable _owner, address _transfer) public owner_only(keccak256(bytes(name))) {\n', '        bytes32 label = keccak256(bytes(name));\n', '        Domain storage domain = domains[label];\n', '\n', '        if (BaseRegistrar(registrar).ownerOf(uint256(label)) != address(this)) {\n', '            BaseRegistrar(registrar).transferFrom(msg.sender, address(this), uint256(label));\n', '            BaseRegistrar(registrar).reclaim(uint256(label), address(this));\n', '        }\n', '\n', '        if (domain.owner != _owner) {\n', '            domain.owner = _owner;\n', '        }\n', '\n', '        if (keccak256(bytes(domain.name)) != label) {\n', '            // New listing\n', '            domain.name = name;\n', '        }\n', '\n', '        domain.price = price;\n', '        domain.referralFeePPM = referralFeePPM;\n', '\n', '        emit DomainConfigured(label);\n', '    }\n', '\n', '    /**\n', '     * @dev Unlists a domain\n', '     * May only be called by the owner.\n', '     * @param name The name of the domain to unlist.\n', '     */\n', '    function unlistDomain(string memory name) public owner_only(keccak256(bytes(name))) {\n', '        bytes32 label = keccak256(bytes(name));\n', '        Domain storage domain = domains[label];\n', '        emit DomainUnlisted(label);\n', '\n', "        domain.name = '';\n", '        domain.price = 0;\n', '        domain.referralFeePPM = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns information about a subdomain.\n', '     * @param label The label hash for the domain.\n', '     * @param subdomain The label for the subdomain.\n', '     * @return domain The name of the domain, or an empty string if the subdomain\n', '     *                is unavailable.\n', '     * @return price The price to register a subdomain, in wei.\n', '     * @return rent The rent to retain a subdomain, in wei per second.\n', '     * @return referralFeePPM The referral fee for the dapp, in ppm.\n', '     */\n', '    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint price, uint rent, uint referralFeePPM) {\n', '        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\n', '        bytes32 subnode = keccak256(abi.encodePacked(node, keccak256(bytes(subdomain))));\n', '\n', '        if (ens.owner(subnode) != address(0x0)) {\n', "            return ('', 0, 0, 0);\n", '        }\n', '\n', '        Domain storage data = domains[label];\n', '        return (data.name, data.price, 0, data.referralFeePPM);\n', '    }\n', '\n', '    /**\n', '     * @dev Registers a subdomain.\n', '     * @param label The label hash of the domain to register a subdomain of.\n', '     * @param subdomain The desired subdomain label.\n', '     * @param _subdomainOwner The account that should own the newly configured subdomain.\n', '     * @param referrer The address of the account to receive the referral fee.\n', '     */\n', '    function register(bytes32 label, string calldata subdomain, address _subdomainOwner, address payable referrer, address resolver) external not_stopped payable {\n', '        address subdomainOwner = _subdomainOwner;\n', '        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\n', '        bytes32 subdomainLabel = keccak256(bytes(subdomain));\n', '\n', '        // Subdomain must not be registered already.\n', '        require(ens.owner(keccak256(abi.encodePacked(domainNode, subdomainLabel))) == address(0));\n', '\n', '        Domain storage domain = domains[label];\n', '\n', '        // Domain must be available for registration\n', '        require(keccak256(bytes(domain.name)) == label);\n', '\n', '        // User must have paid enough\n', '        require(msg.value >= domain.price);\n', '\n', '        // Send any extra back\n', '        if (msg.value > domain.price) {\n', '            msg.sender.transfer(msg.value - domain.price);\n', '        }\n', '\n', '        // Send any referral fee\n', '        uint256 total = domain.price;\n', '        if (domain.referralFeePPM > 0 && referrer != address(0x0) && referrer != domain.owner) {\n', '            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n', '            referrer.transfer(referralFee);\n', '            total -= referralFee;\n', '        }\n', '\n', '        // Send the registration fee\n', '        if (total > 0) {\n', '            domain.owner.transfer(total);\n', '        }\n', '\n', '        // Register the domain\n', '        if (subdomainOwner == address(0x0)) {\n', '            subdomainOwner = msg.sender;\n', '        }\n', '        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n', '\n', '        emit NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n', '    }\n', '\n', '    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\n', '        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '    }\n', '\n', '    /**\n', '     * @dev Migrates the domain to a new registrar.\n', '     * @param name The name of the domain to migrate.\n', '     */\n', '    function migrate(string memory name) public owner_only(keccak256(bytes(name))) {\n', '        require(stopped);\n', '        require(migration != address(0x0));\n', '\n', '        bytes32 label = keccak256(bytes(name));\n', '        Domain storage domain = domains[label];\n', '\n', '        BaseRegistrar(registrar).approve(migration, uint256(label));\n', '\n', '        EthRegistrarSubdomainRegistrar(migration).configureDomainFor(\n', '            domain.name,\n', '            domain.price,\n', '            domain.referralFeePPM,\n', '            domain.owner,\n', '            address(0x0)\n', '        );\n', '\n', '        delete domains[label];\n', '\n', '        emit DomainTransferred(label, name);\n', '    }\n', '\n', '    function payRent(bytes32 label, string calldata subdomain) external payable {\n', '        revert();\n', '    }\n', '}']