['pragma solidity ^0.4.24;\n', '\n', 'interface ErrorThrower {\n', '    event Error(string func, string message);\n', '}\n', '\n', '\n', 'contract Ownable is ErrorThrower {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner(string _funcName) {\n', '        if(msg.sender != owner){\n', '            emit Error(_funcName,"Operation can only be performed by contract owner");\n', '            return;\n', '        }\n', '        _;\n', '    }\n', '\n', '\n', '    function renounceOwnership() public onlyOwner("renounceOwnership") {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner("transferOwnership") {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '    *  Transfers control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        if(_newOwner == address(0)){\n', '            emit Error("transferOwnership","New owner\'s address needs to be different than 0x0");\n', '            return;\n', '        }\n', '\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '@title AddressProxy contract\n', '@author App Store Foundation\n', ' This contract works as part of a set of mechanisms in order to maintain tracking of the latest\n', "version's contracts deployed to the network.\n", ' */\n', '\n', 'contract AddressProxy is Ownable {\n', '\n', '    struct ContractAddress {\n', '        bytes32 id;\n', '        string name;\n', '        address at;\n', '        uint createdTime;\n', '        uint updatedTime;\n', '    }\n', '\n', '    mapping(bytes32 => ContractAddress) private contractsAddress;\n', '    bytes32[] public availableIds;\n', '\n', '    event AddressCreated(bytes32 id, string name, address at, uint createdTime, uint updatedTime);\n', '    event AddressUpdated(bytes32 id, string name, address at, uint createdTime, uint updatedTime);\n', '\n', '    function AddressProxy() public {\n', '    }\n', '\n', '\n', '    /**\n', '    @notice Get all avaliable ids registered on the contract\n', '     Just shows the list of ids registerd on the contract\n', '    @return { "IdList" : "List of registered ids" }\n', '     */\n', '    function getAvailableIds() public view returns (bytes32[] IdList) {\n', '        return availableIds;\n', '    }\n', '\n', '    /**\n', '    @notice  Adds or updates an address\n', '     Used when a new address needs to be updated to a currently registered id or to a new id.\n', '    @param name Name of the contract\n', '    @param newAddress Address of the contract\n', '    */\n', '    function addAddress(string name, address newAddress) public onlyOwner("addAddress") {\n', '        bytes32 contAddId = stringToBytes32(name);\n', '\n', '        uint nowInMilliseconds = now * 1000;\n', '\n', '        if (contractsAddress[contAddId].id == 0x0) {\n', '            ContractAddress memory newContractAddress;\n', '            newContractAddress.id = contAddId;\n', '            newContractAddress.name = name;\n', '            newContractAddress.at = newAddress;\n', '            newContractAddress.createdTime = nowInMilliseconds;\n', '            newContractAddress.updatedTime = nowInMilliseconds;\n', '            availableIds.push(contAddId);\n', '            contractsAddress[contAddId] = newContractAddress;\n', '\n', '            emit AddressCreated(newContractAddress.id, newContractAddress.name, newContractAddress.at, newContractAddress.createdTime, newContractAddress.updatedTime);\n', '        } else {\n', '            ContractAddress storage contAdd = contractsAddress[contAddId];\n', '            contAdd.at = newAddress;\n', '            contAdd.updatedTime = nowInMilliseconds;\n', '\n', '            emit AddressUpdated(contAdd.id, contAdd.name, contAdd.at, contAdd.createdTime, contAdd.updatedTime);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Get the contract name associated to a certain id\n', '    @param id Id of the registry\n', "    @return { 'name' : 'Name of the contract associated to the given id' }\n", '     */\n', '    function getContractNameById(bytes32 id) public view returns(string name) {\n', '        return contractsAddress[id].name;\n', '    }\n', '\n', '\n', '    /**\n', '    @notice Get the contract address associated to a certain id\n', '    @param id Id of the registry\n', "    @return { 'contractAddr' : 'Address of the contract associated to the given id' }\n", '     */\n', '    function getContractAddressById(bytes32 id) public view returns(address contractAddr) {\n', '        return contractsAddress[id].at;\n', '    }\n', '\n', '    /**\n', '    @notice Get the specific date on which the contract address was firstly registered\n', '    to a certain id\n', '    @param id Id of the registry\n', "    @return { 'time' : 'Time in miliseconds of the first time the given id was registered' }\n", '     */\n', '    function getContractCreatedTimeById(bytes32 id) public view returns(uint time) {\n', '        return contractsAddress[id].createdTime;\n', '    }\n', '\n', '    /**\n', '    @notice Get the specific date on which the contract address was lastly updated to a certain id\n', '    @param id Id of the registry\n', "    @return { 'time' : 'Time in miliseconds of the last time the given id was updated' }\n", '     */\n', '    function getContractUpdatedTimeById(bytes32 id) public view returns(uint time) {\n', '        return contractsAddress[id].updatedTime;\n', '    }\n', '\n', '    /**\n', '    @notice Converts a string type variable into a byte32 type variable\n', '     This function is internal and uses inline assembly instructions.\n', '    @param source string to be converted to a byte32 type\n', "    @return { 'result' : 'Initial string content converted to a byte32 type' }\n", '     */\n', '    function stringToBytes32(string source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}']