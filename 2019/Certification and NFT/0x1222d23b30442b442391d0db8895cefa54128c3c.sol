['pragma solidity ^0.5.8;\n', '\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the average of two numbers. Since these are integers,\n', '     * averages of an even and odd number cannot be represented, and will be\n', '     * rounded down.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\n', '        require(token.approve(spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title TokenSale\n', ' */\n', 'contract TokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // token for sale\n', '    IERC20 public saleToken;\n', '\n', '    // address where funds are collected\n', '    address public fundCollector;\n', '\n', '    // address where has tokens to sell\n', '    address public tokenWallet;\n', '\n', '    // use whitelist[user] to get whether the user was allowed to buy\n', '    mapping(address => bool) public whitelist;\n', '\n', '    // exchangeable token\n', '    struct ExToken {\n', '        bool accepted;\n', '        uint256 rate;\n', '    }\n', '\n', '    // exchangeable tokens\n', '    mapping(address => ExToken) private _exTokens;\n', '\n', '    // bonus threshold\n', '    uint256 public bonusThreshold;\n', '\n', '    // tier-1 bonus\n', '    uint256 public tierOneBonusTime;\n', '    uint256 public tierOneBonusRate;\n', '\n', '    // tier-2 bonus\n', '    uint256 public tierTwoBonusTime;\n', '    uint256 public tierTwoBonusRate;\n', '\n', '    /**\n', '     * @param setter who set fund collector\n', '     * @param fundCollector address of fund collector\n', '     */\n', '    event FundCollectorSet(\n', '        address indexed setter,\n', '        address indexed fundCollector\n', '    );\n', '\n', '    /**\n', '     * @param setter who set sale token\n', '     * @param saleToken address of sale token\n', '     */\n', '    event SaleTokenSet(\n', '        address indexed setter,\n', '        address indexed saleToken\n', '    );\n', '\n', '    /**\n', '     * @param setter who set token wallet\n', '     * @param tokenWallet address of token wallet\n', '     */\n', '    event TokenWalletSet(\n', '        address indexed setter,\n', '        address indexed tokenWallet\n', '    );\n', '\n', '    /**\n', '     * @param setter who set bonus threshold\n', '     * @param bonusThreshold exceed the threshold will get bonus\n', '     * @param tierOneBonusTime tier one bonus timestamp\n', '     * @param tierOneBonusRate tier one bonus rate\n', '     * @param tierTwoBonusTime tier two bonus timestamp\n', '     * @param tierTwoBonusRate tier two bonus rate\n', '     */\n', '    event BonusConditionsSet(\n', '        address indexed setter,\n', '        uint256 bonusThreshold,\n', '        uint256 tierOneBonusTime,\n', '        uint256 tierOneBonusRate,\n', '        uint256 tierTwoBonusTime,\n', '        uint256 tierTwoBonusRate\n', '    );\n', '\n', '    /**\n', '     * @param setter who set the whitelist\n', '     * @param user address of the user\n', '     * @param allowed whether the user allowed to buy\n', '     */\n', '    event WhitelistSet(\n', '        address indexed setter,\n', '        address indexed user,\n', '        bool allowed\n', '    );\n', '\n', '    /**\n', '     * event for logging exchangeable token updates\n', '     * @param setter who set the exchangeable token\n', '     * @param exToken the exchangeable token\n', '     * @param accepted whether the exchangeable token was accepted\n', '     * @param rate exchange rate of the exchangeable token\n', '     */\n', '    event ExTokenSet(\n', '        address indexed setter,\n', '        address indexed exToken,\n', '        bool accepted,\n', '        uint256 rate\n', '    );\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param buyer address of token buyer\n', '     * @param exToken address of the exchangeable token\n', '     * @param exTokenAmount amount of the exchangeable tokens\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokensPurchased(\n', '        address indexed buyer,\n', '        address indexed exToken,\n', '        uint256 exTokenAmount,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '     * @param fundCollector address where collected funds will be forwarded to\n', '     * @param saleToken address of the token being sold\n', '     * @param tokenWallet address of wallet has tokens to sell\n', '     */\n', '    constructor (\n', '        address fundCollector,\n', '        address saleToken,\n', '        address tokenWallet,\n', '        uint256 bonusThreshold,\n', '        uint256 tierOneBonusTime,\n', '        uint256 tierOneBonusRate,\n', '        uint256 tierTwoBonusTime,\n', '        uint256 tierTwoBonusRate\n', '    )\n', '        public\n', '    {\n', '        _setFundCollector(fundCollector);\n', '        _setSaleToken(saleToken);\n', '        _setTokenWallet(tokenWallet);\n', '        _setBonusConditions(\n', '            bonusThreshold,\n', '            tierOneBonusTime,\n', '            tierOneBonusRate,\n', '            tierTwoBonusTime,\n', '            tierTwoBonusRate\n', '        );\n', '\n', '    }\n', '\n', '    /**\n', '     * @param fundCollector address of the fund collector\n', '     */\n', '    function setFundCollector(address fundCollector) external onlyOwner {\n', '        _setFundCollector(fundCollector);\n', '    }\n', '\n', '    /**\n', '     * @param collector address of the fund collector\n', '     */\n', '    function _setFundCollector(address collector) private {\n', '        require(collector != address(0), "fund collector cannot be 0x0");\n', '        fundCollector = collector;\n', '        emit FundCollectorSet(msg.sender, collector);\n', '    }\n', '\n', '    /**\n', '     * @param saleToken address of the sale token\n', '     */\n', '    function setSaleToken(address saleToken) external onlyOwner {\n', '        _setSaleToken(saleToken);\n', '    }\n', '\n', '    /**\n', '     * @param token address of the sale token\n', '     */\n', '    function _setSaleToken(address token) private {\n', '        require(token != address(0), "sale token cannot be 0x0");\n', '        saleToken = IERC20(token);\n', '        emit SaleTokenSet(msg.sender, token);\n', '    }\n', '\n', '    /**\n', '     * @param tokenWallet address of the token wallet\n', '     */\n', '    function setTokenWallet(address tokenWallet) external onlyOwner {\n', '        _setTokenWallet(tokenWallet);\n', '    }\n', '\n', '    /**\n', '     * @param wallet address of the token wallet\n', '     */\n', '    function _setTokenWallet(address wallet) private {\n', '        require(wallet != address(0), "token wallet cannot be 0x0");\n', '        tokenWallet = wallet;\n', '        emit TokenWalletSet(msg.sender, wallet);\n', '    }\n', '\n', '    /**\n', '     * @param threshold exceed the threshold will get bonus\n', '     * @param t1BonusTime before t1 bonus timestamp will use t1 bonus rate\n', '     * @param t1BonusRate tier-1 bonus rate\n', '     * @param t2BonusTime before t2 bonus timestamp will use t2 bonus rate\n', '     * @param t2BonusRate tier-2 bonus rate\n', '     */\n', '    function setBonusConditions(\n', '        uint256 threshold,\n', '        uint256 t1BonusTime,\n', '        uint256 t1BonusRate,\n', '        uint256 t2BonusTime,\n', '        uint256 t2BonusRate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _setBonusConditions(\n', '            threshold,\n', '            t1BonusTime,\n', '            t1BonusRate,\n', '            t2BonusTime,\n', '            t2BonusRate\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @param threshold exceed the threshold will get bonus\n', '     */\n', '    function _setBonusConditions(\n', '        uint256 threshold,\n', '        uint256 t1BonusTime,\n', '        uint256 t1BonusRate,\n', '        uint256 t2BonusTime,\n', '        uint256 t2BonusRate\n', '    )\n', '        private\n', '        onlyOwner\n', '    {\n', '        require(threshold > 0," threshold cannot be zero.");\n', '        require(t1BonusTime < t2BonusTime, "invalid bonus time");\n', '        require(t1BonusRate >= t2BonusRate, "invalid bonus rate");\n', '\n', '        bonusThreshold = threshold;\n', '        tierOneBonusTime = t1BonusTime;\n', '        tierOneBonusRate = t1BonusRate;\n', '        tierTwoBonusTime = t2BonusTime;\n', '        tierTwoBonusRate = t2BonusRate;\n', '\n', '        emit BonusConditionsSet(\n', '            msg.sender,\n', '            threshold,\n', '            t1BonusTime,\n', '            t1BonusRate,\n', '            t2BonusTime,\n', '            t2BonusRate\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice set allowed to ture to add the user into the whitelist\n', '     * @notice set allowed to false to remove the user from the whitelist\n', '     * @param user address of user\n', '     * @param allowed whether allow the user to deposit/withdraw or not\n', '     */\n', '    function setWhitelist(address user, bool allowed) external onlyOwner {\n', '        whitelist[user] = allowed;\n', '        emit WhitelistSet(msg.sender, user, allowed);\n', '    }\n', '\n', '    /**\n', '     * @dev checks the amount of tokens left in the allowance.\n', '     * @return amount of tokens left in the allowance\n', '     */\n', '    function remainingTokens() external view returns (uint256) {\n', '        return Math.min(\n', '            saleToken.balanceOf(tokenWallet),\n', '            saleToken.allowance(tokenWallet, address(this))\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @param exToken address of the exchangeable token\n', '     * @param accepted true: accepted; false: rejected\n', '     * @param rate exchange rate\n', '     */\n', '    function setExToken(\n', '        address exToken,\n', '        bool accepted,\n', '        uint256 rate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        _exTokens[exToken].accepted = accepted;\n', '        _exTokens[exToken].rate = rate;\n', '        emit ExTokenSet(msg.sender, exToken, accepted, rate);\n', '    }\n', '\n', '    /**\n', '     * @param exToken address of the exchangeable token\n', '     * @return whether the exchangeable token is accepted or not\n', '     */\n', '    function accepted(address exToken) public view returns (bool) {\n', '        return _exTokens[exToken].accepted;\n', '    }\n', '\n', '    /**\n', '     * @param exToken address of the exchangeale token\n', '     * @return amount of sale token a buyer gets per exchangeable token\n', '     */\n', '    function rate(address exToken) external view returns (uint256) {\n', '        return _exTokens[exToken].rate;\n', '    }\n', '\n', '    /**\n', '     * @dev get exchangeable sale token amount\n', '     * @param exToken address of the exchangeable token\n', '     * @param amount amount of the exchangeable token (how much to pay)\n', '     * @return purchased sale token amount\n', '     */\n', '    function exchangeableAmounts(\n', '        address exToken,\n', '        uint256 amount\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _getTokenAmount(exToken, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev buy tokens\n', '     * @dev buyer must be in whitelist\n', '     * @param exToken address of the exchangeable token\n', '     * @param amount amount of the exchangeable token\n', '     */\n', '    function buyTokens(\n', '        address exToken,\n', '        uint256 amount\n', '    )\n', '        external\n', '    {\n', '        require(_exTokens[exToken].accepted, "token was not accepted");\n', '        require(amount != 0, "amount cannot 0");\n', '        require(whitelist[msg.sender], "buyer must be in whitelist");\n', '        // calculate token amount to sell\n', '        uint256 tokens = _getTokenAmount(exToken, amount);\n', '        require(tokens >= 10**19, "at least buy 10 tokens per purchase");\n', '        _forwardFunds(exToken, amount);\n', '        _processPurchase(msg.sender, tokens);\n', '        emit TokensPurchased(msg.sender, exToken, amount, tokens);\n', '    }\n', '\n', '    /**\n', '     * @dev buyer transfers amount of the exchangeable token to fund collector\n', '     * @param exToken address of the exchangeable token\n', '     * @param amount amount of the exchangeable token will send to fund collector\n', '     */\n', '    function _forwardFunds(address exToken, uint256 amount) private {\n', '        IERC20(exToken).safeTransferFrom(msg.sender, fundCollector, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev calculated purchased sale token amount\n', '     * @param exToken address of the exchangeable token\n', '     * @param amount amount of the exchangeable token (how much to pay)\n', '     * @return amount of purchased sale token\n', '     */\n', '    function _getTokenAmount(\n', '        address exToken,\n', '        uint256 amount\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // round down value (v) by multiple (m) = (v / m) * m\n', '        uint256 value = amount\n', '            .div(100000000000000000)\n', '            .mul(100000000000000000)\n', '            .mul(_exTokens[exToken].rate);\n', '        return _applyBonus(value);\n', '    }\n', '\n', '    function _applyBonus(\n', '        uint256 amount\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (amount < bonusThreshold) {\n', '            return amount;\n', '        }\n', '\n', '        if (block.timestamp <= tierOneBonusTime) {\n', '            return amount.mul(tierOneBonusRate).div(100);\n', '        } else if (block.timestamp <= tierTwoBonusTime) {\n', '            return amount.mul(tierTwoBonusRate).div(100);\n', '        } else {\n', '            return amount;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev transfer sale token amounts from token wallet to beneficiary\n', '     * @param beneficiary purchased tokens will transfer to this address\n', '     * @param tokenAmount purchased token amount\n', '     */\n', '    function _processPurchase(\n', '        address beneficiary,\n', '        uint256 tokenAmount\n', '    )\n', '        private\n', '    {\n', '        saleToken.safeTransferFrom(tokenWallet, beneficiary, tokenAmount);\n', '    }\n', '}']