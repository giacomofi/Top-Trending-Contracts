['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/token/ERC20Cutted.sol\n', '\n', 'contract ERC20Cutted {\n', '\n', '  function balanceOf(address who) public view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/Room1.sol\n', '\n', 'contract Room1 is Ownable {\n', '\n', '  event TicketPurchased(address lotAddr, uint lotIndex, uint ticketNumber, address player, uint ticketPrice);\n', '\n', '  event TicketWon(address lotAddr, uint lotIndex, uint ticketNumber, address player, uint win);\n', '\n', '  event ParametersUpdated(uint lotIndex, address feeWallet, uint feePercent, uint starts, uint duration, uint interval, uint ticketPrice);\n', '\n', '  using SafeMath for uint;\n', '\n', '  uint diffRangeCounter = 0;\n', '\n', '  uint public LIMIT = 100;\n', '\n', '  uint public RANGE = 100000;\n', '\n', '  uint public PERCENT_RATE = 100;\n', '\n', '  enum LotState { Accepting, Processing, Rewarding, Finished }\n', '\n', '  uint public interval;\n', '\n', '  uint public duration;\n', '\n', '  uint public starts;\n', '\n', '  uint public ticketPrice;\n', '\n', '  uint public feePercent;\n', '\n', '  uint public lotProcessIndex;\n', '\n', '  uint public lastChangesIndex;\n', '\n', '  uint public MIN_DISPERSION_K = 10;\n', '\n', '  address public feeWallet;\n', '\n', '  mapping (address => uint) public summaryPayed;\n', '\n', '  struct Ticket {\n', '    address owner;\n', '    uint number;\n', '    uint win;\n', '  }\n', '\n', '  struct Lot {\n', '    LotState state;\n', '    uint processIndex;\n', '    uint summaryNumbers;\n', '    uint summaryInvested;\n', '    uint rewardBase;\n', '    uint ticketsCount;\n', '    uint playersCount;\n', '    mapping (uint => Ticket) tickets;\n', '    mapping (address => uint) invested;\n', '    address[] players;\n', '  }\n', '\n', '  mapping(uint => Lot) public lots;\n', '\n', '  modifier started() {\n', '    require(now >= starts, "Not started yet!");\n', '    _;\n', '  }\n', '\n', '  modifier notContract(address to) {\n', '    uint codeLength;\n', '    assembly {\n', '      codeLength := extcodesize(to)\n', '    }\n', '    require(codeLength == 0, "Contracts not supported!");\n', '    _;\n', '  }\n', '\n', '  function updateParameters(address newFeeWallet, uint newFeePercent, uint newStarts, uint newDuration, uint newInterval, uint newTicketPrice) public onlyOwner {\n', '    require(newStarts > now, "Lottery can only be started in the future!");\n', '    uint curLotIndex = getCurLotIndex();\n', '    Lot storage lot = lots[curLotIndex];\n', '    require(lot.state == LotState.Finished, "Contract parameters can only be changed if the current lottery is finished!");\n', '    lastChangesIndex = curLotIndex.add(1);\n', '    feeWallet = newFeeWallet;\n', '    feePercent = newFeePercent;\n', '    starts = newStarts;\n', '    duration = newDuration;\n', '    interval = newInterval;\n', '    ticketPrice = newTicketPrice;\n', '    emit ParametersUpdated(lastChangesIndex, newFeeWallet, newFeePercent, newStarts, newDuration, newInterval, newTicketPrice);\n', '  }\n', '\n', '  function getLotInvested(uint lotNumber, address player) view public returns(uint) {\n', '    Lot storage lot = lots[lotNumber];\n', '    return lot.invested[player];\n', '  }\n', '\n', '  function getTicketInfo(uint lotNumber, uint ticketNumber) view public returns(address, uint, uint) {\n', '    Ticket storage ticket = lots[lotNumber].tickets[ticketNumber];\n', '    return (ticket.owner, ticket.number, ticket.win);\n', '  }\n', '\n', '  function getCurLotIndex() view public returns(uint) {\n', '    if (starts > now) {\n', '      return lastChangesIndex;\n', '    }\n', '    uint passed = now.sub(starts);\n', '    if(passed == 0)\n', '      return 0;\n', '    return passed.div(interval.add(duration)).add(lastChangesIndex);\n', '  }\n', '\n', '  constructor() public {\n', '    starts = 1554026400;\n', '    ticketPrice = 10000000000000000;\n', '    feePercent = 10;\n', '    feeWallet = 0x53f22b8f420317e7cdcbf2a180a12534286cb578;\n', '    interval = 1800;\n', '    uint fullDuration = 3600;\n', '    duration = fullDuration.sub(interval);\n', '    emit ParametersUpdated(0, feeWallet, feePercent, starts, duration, interval, ticketPrice);\n', '  }\n', '\n', '  function setFeeWallet(address newFeeWallet) public onlyOwner {\n', '    feeWallet = newFeeWallet;\n', '  }\n', '\n', '  function getNotPayableTime(uint lotIndex) view public returns(uint) {\n', '    return starts.add(interval.add(duration).mul(lotIndex.add(1).sub(lastChangesIndex))).sub(interval);\n', '  }\n', '\n', '  function () public payable notContract(msg.sender) started {\n', '    require(RANGE.mul(RANGE).mul(address(this).balance.add(msg.value)) > 0, "Balance limit error!");\n', '    require(msg.value >= ticketPrice, "Not enough funds to buy ticket!");\n', '    uint curLotIndex = getCurLotIndex();\n', '    require(now < getNotPayableTime(curLotIndex), "Game finished!");\n', '    Lot storage lot = lots[curLotIndex];\n', '    require(RANGE.mul(RANGE) > lot.ticketsCount, "Ticket count limit exceeded!");\n', '\n', '    uint numTicketsToBuy = msg.value.div(ticketPrice);\n', '\n', '    uint toInvest = ticketPrice.mul(numTicketsToBuy);\n', '\n', '    if(lot.invested[msg.sender] == 0) {\n', '      lot.players.push(msg.sender);\n', '      lot.playersCount = lot.playersCount.add(1);\n', '    }\n', '\n', '    lot.invested[msg.sender] = lot.invested[msg.sender].add(toInvest);\n', '\n', '    for(uint i = 0; i < numTicketsToBuy; i++) {\n', '      lot.tickets[lot.ticketsCount].owner = msg.sender;\n', '      emit TicketPurchased(address(this), curLotIndex, lot.ticketsCount, msg.sender, ticketPrice);\n', '      lot.ticketsCount = lot.ticketsCount.add(1);\n', '    }\n', '\n', '    lot.summaryInvested = lot.summaryInvested.add(toInvest);\n', '\n', '    uint refund = msg.value.sub(toInvest);\n', '    msg.sender.transfer(refund);\n', '  }\n', '\n', '  function canUpdate() view public returns(bool) {\n', '    if (starts > now) {\n', '      return false;\n', '    }\n', '    uint curLotIndex = getCurLotIndex();\n', '    Lot storage lot = lots[curLotIndex];\n', '    return lot.state == LotState.Finished;\n', '  }\n', '\n', '  function isProcessNeeds() view public returns(bool) {\n', '    if (starts > now) {\n', '      return false;\n', '    }\n', '    uint curLotIndex = getCurLotIndex();\n', '    Lot storage lot = lots[curLotIndex];\n', '    return lotProcessIndex < curLotIndex || (now >= getNotPayableTime(lotProcessIndex) && lot.state != LotState.Finished);\n', '  }\n', '\n', '  function pow(uint number, uint count) private returns(uint) {\n', '    uint result = number;\n', '    if (count == 0) return 1;\n', '    for (uint i = 1; i < count; i++) {\n', '      result = result.mul(number);\n', '    }\n', '    return result;\n', '  }\n', '\n', '  function prepareToRewardProcess() public onlyOwner started {\n', '    Lot storage lot = lots[lotProcessIndex];\n', '\n', '    if(lot.state == LotState.Accepting) {\n', '      require(now >= getNotPayableTime(lotProcessIndex), "Lottery stakes accepting time not finished!");\n', '      lot.state = LotState.Processing;\n', '    }\n', '\n', '    require(lot.state == LotState.Processing || lot.state == LotState.Rewarding, "State should be Processing or Rewarding!");\n', '\n', '    uint index = lot.processIndex;\n', '\n', '    uint limit = lot.ticketsCount - index;\n', '    if(limit > LIMIT) {\n', '      limit = LIMIT;\n', '    }\n', '\n', '    limit = limit.add(index);\n', '\n', '    uint number;\n', '\n', '    if(lot.state == LotState.Processing) {\n', '\n', '      number = block.number;\n', '\n', '      uint dispersionK = MIN_DISPERSION_K;\n', '\n', '      uint diffRangeLimit = 0;\n', '\n', '      if(limit > 0) {\n', '        diffRangeLimit = limit.div(dispersionK);\n', '        if(diffRangeLimit == 0) {\n', '          diffRangeLimit = 1;\n', '        }\n', '      }\n', '\n', '      diffRangeCounter = 0;\n', '\n', '      uint enlargedRange = RANGE.mul(dispersionK);\n', '\n', '      bool enlargedWinnerGenerated = false;\n', '\n', '      bool enlargedWinnerPrepared = false;\n', '\n', '      uint enlargedWinnerIndex = 0;\n', '\n', '      for(; index < limit; index++) {\n', '\n', '        number = pow(uint(keccak256(abi.encodePacked(number)))%RANGE, 5);\n', '        lot.tickets[index].number = number;\n', '        lot.summaryNumbers = lot.summaryNumbers.add(number);\n', '\n', '        if(!enlargedWinnerGenerated) {\n', '          enlargedWinnerIndex = uint(keccak256(abi.encodePacked(number)))%enlargedRange;\n', '          enlargedWinnerGenerated = true;\n', '        } if(!enlargedWinnerPrepared && diffRangeCounter == enlargedWinnerIndex) {\n', '          number = pow(uint(keccak256(abi.encodePacked(number)))%enlargedRange, 5);\n', '          lot.tickets[index].number = lot.tickets[index].number.add(number);\n', '          lot.summaryNumbers = lot.summaryNumbers.add(number);\n', '          enlargedWinnerGenerated = true;\n', '        }\n', '\n', '        if(diffRangeCounter == diffRangeLimit) {\n', '          diffRangeCounter = 0;\n', '          enlargedWinnerPrepared = false;\n', '          enlargedWinnerGenerated = false;\n', '        }\n', '\n', '        diffRangeCounter++;\n', '      }\n', '\n', '      if(index == lot.ticketsCount) {\n', '        uint fee = lot.summaryInvested.mul(feePercent).div(PERCENT_RATE);\n', '        feeWallet.transfer(fee);\n', '        lot.rewardBase = lot.summaryInvested.sub(fee);\n', '        lot.state = LotState.Rewarding;\n', '        index = 0;\n', '      }\n', '\n', '    } else {\n', '\n', '      for(; index < limit; index++) {\n', '        Ticket storage ticket = lot.tickets[index];\n', '        number = ticket.number;\n', '        if(number > 0) {\n', '          ticket.win = lot.rewardBase.mul(number).div(lot.summaryNumbers);\n', '          if(ticket.win > 0) {\n', '            ticket.owner.transfer(ticket.win);\n', '            summaryPayed[ticket.owner] = summaryPayed[ticket.owner].add(ticket.win);\n', '            emit TicketWon(address(this), lotProcessIndex, index, ticket.owner, ticket.win);\n', '          }\n', '        }\n', '      }\n', '\n', '      if(index == lot.ticketsCount) {\n', '        lot.state = LotState.Finished;\n', '        lotProcessIndex = lotProcessIndex.add(1);\n', '      }\n', '    }\n', '\n', '    lot.processIndex = index;\n', '  }\n', '\n', '  function retrieveTokens(address tokenAddr, address to) public onlyOwner {\n', '    ERC20Cutted token = ERC20Cutted(tokenAddr);\n', '    token.transfer(to, token.balanceOf(address(this)));\n', '  }\n', '\n', '}']