['/*\n', '\n', 'Introducing "STAKE THEM ALL" Version 1.0\n', '"STAKE THEM ALL" is playable @ https://stakethemall.io (Ethereum Edition) and https://trx.stakethemall.io (TRON Edition)\n', '\n', 'About the game :\n', '\n', '"STAKE THEM ALL" IS A FUN AND REWARDING PHYSICS GAME RUNNING ON THE BLOCKCHAIN\n', 'HAVE FUN WHILE PARTICIPATING TO THE HDX20 TOKEN PRICE APPRECIATION @ https://hdx20.io\n', '\n', 'How to play "STAKE THEM ALL":\n', '\n', 'Challenge MODE\n', '--------------\n', 'Set the difficulty of your CHALLENGE by choosing how many cube you want\n', 'to stack on top of each other and get rewarded on success.\n', '\n', 'Builder MODE\n', '------------\n', 'Stack 15 cubes in order to reach the maximum height. \n', 'The best score, if not beaten within a 24H countdown, wins the whole POT.   \n', '   \n', '\n', 'This product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\n', '\n', 'Copyright 2019 HyperDevbox\n', '\n', '*/\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', 'interface HDX20Interface\n', '{\n', '    function() payable external;\n', '    \n', '    \n', '    function buyTokenFromGame( address _customerAddress , address _referrer_address ) payable external returns(uint256);\n', '  \n', '    function payWithToken( uint256 _eth , address _player_address ) external returns(uint256);\n', '  \n', '    function appreciateTokenPrice() payable external;\n', '   \n', '    function totalSupply() external view returns(uint256); \n', '    \n', '    function ethBalanceOf(address _customerAddress) external view returns(uint256);\n', '  \n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '    \n', '    function sellingPrice( bool includeFees) external view returns(uint256);\n', '  \n', '}\n', '\n', '\n', '\n', 'contract stakethemall\n', '{\n', '     HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882);\n', '     \n', '     using SafeMath for uint256;\n', '     using SafeMath128 for uint128;\n', '     \n', '     /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event OwnershipTransferred(\n', '        \n', '         address previousOwner,\n', '         address nextOwner,\n', '          uint256 timeStamp\n', '         );\n', '         \n', '    event HDXcontractChanged(\n', '        \n', '         address previous,\n', '         address next,\n', '         uint256 timeStamp\n', '         );\n', ' \n', '  \n', '    \n', '\t    \n', '     event onWithdrawGains(\n', '        address customerAddress,\n', '        uint256 ethereumWithdrawn,\n', '        uint256 timeStamp\n', '    );\n', '    \n', '     event onBuyMode1(\n', '        address     customerAddress,\n', '        uint256     BatchID,\n', '        uint256     BatchBlockTimeout,  \n', '        uint32      Challenge\n', '        );  \n', '        \n', '    event onBuyMode2(\n', '        address     customerAddress,\n', '        uint256     BatchID,\n', '        uint256     BatchBlockTimeout,  \n', '        uint256     nb_token\n', '        );   \n', '        \n', '    event onNewScoreMode1(\n', '        uint256 score,\n', '        address customerAddress,\n', '        uint256 winning,\n', '        uint256 nb_token\n', '    ); \n', '    \n', '    event onNewScoreMode2(\n', '        uint256 score,\n', '        address       customerAddress,\n', '        bool    newHighscore\n', '      \n', '    ); \n', '        \n', '  \n', '        \n', '    event onChangeMinimumPrice(\n', '        \n', '         uint256 minimum,\n', '         uint256 timeStamp\n', '         );\n', '         \n', '  \n', '      event onChangeBlockTimeout(\n', '        \n', '         uint32 b1,\n', '         uint32 b2\n', '         );\n', '         \n', '        event onChangeTreasurePercentage(\n', '        \n', '         uint32 percentage\n', '         );\n', '         \n', '       \n', '         \n', '    /*==============================\n', '    =            MODIFIERS         =\n', '    ==============================*/\n', '    modifier onlyOwner\n', '    {\n', '        require (msg.sender == owner );\n', '        _;\n', '    }\n', '    \n', '    modifier onlyFromHDXToken\n', '    {\n', '        require (msg.sender == address( HDXcontract ));\n', '        _;\n', '    }\n', '   \n', '     modifier onlyDirectTransaction\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '  \n', '    address public owner;\n', '  \n', '   \n', '    address public signerAuthority = 0xf77444cE64f3F46ba6b63F6b9411dF9c589E3319;\n', '   \n', '    \n', '\n', '    constructor () public\n', '    {\n', '        owner = msg.sender;\n', '       \n', '        GameRoundData.extraData[0] = 20; //mode1 20%\n', '        GameRoundData.extraData[1] = 0; //mode2 current highscore\n', '\t    GameRoundData.extraData[2] = uint32((3600*1) / 15);     //1 hour\n', '\t    GameRoundData.extraData[3] = uint32((3600*24) / 15);     //24 hour\n', '        \n', '        \n', '        if ( address(this).balance > 0)\n', '        {\n', '            owner.transfer( address(this).balance );\n', '        }\n', '    }\n', '    \n', '    function changeOwner(address _nextOwner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextOwner != owner);\n', '        require(_nextOwner != address(0));\n', '         \n', '        emit OwnershipTransferred(owner, _nextOwner , now);\n', '         \n', '        owner = _nextOwner;\n', '    }\n', '    \n', '    function changeSigner(address _nextSigner) public\n', '    onlyOwner\n', '    {\n', '        require (_nextSigner != signerAuthority);\n', '        require(_nextSigner != address(0));\n', '      \n', '        signerAuthority = _nextSigner;\n', '    }\n', '    \n', '    function changeHDXcontract(address _next) public\n', '    onlyOwner\n', '    {\n', '        require (_next != address( HDXcontract ));\n', '        require( _next != address(0));\n', '         \n', '        emit HDXcontractChanged(address(HDXcontract), _next , now);\n', '         \n', '        HDXcontract  = HDX20Interface( _next);\n', '    }\n', '  \n', '  \n', '    function changeMinimumPrice( uint256 newmini) public\n', '    onlyOwner\n', '    {\n', '      \n', '      if (newmini>0)\n', '      {\n', '          minimumSharePrice = newmini;\n', '      }\n', '       \n', '      emit onChangeMinimumPrice( newmini , now ); \n', '    }\n', '    \n', '    \n', '    function changeBlockTimeout( uint32 b1 , uint32 b2) public\n', '    onlyOwner\n', '    {\n', '        require( b1>0 && b2>0 );\n', '        \n', '       \n', '        GameRoundData.extraData[2] = b1;\n', '        GameRoundData.extraData[3] = b2;\n', '            \n', '        emit onChangeBlockTimeout( b1,b2 ); \n', '        \n', '       \n', '       \n', '    }\n', '    \n', '    function changeTreasurePercentage( uint32 percentage) public\n', '    onlyOwner\n', '    {\n', '        require( percentage>0 && percentage<=100);\n', '        \n', '        GameRoundData.extraData[0] = percentage;\n', '          \n', '        emit onChangeTreasurePercentage( percentage ); \n', '       \n', '       \n', '       \n', '    }\n', '    \n', '     /*================================\n', '    =       GAMES VARIABLES         =\n', '    ================================*/\n', '    \n', '    struct PlayerData_s\n', '    {\n', '   \n', '        uint256 chest;  \n', '        uint256 payoutsTo;\n', '       \n', '\t\t//credit locked until we validate the score mode1\n', '\t\tuint256         mode1LockedCredit;\t\n', '\t\tuint256         mode1BatchID;         \n', '        uint256         mode1BlockTimeout;   \n', '        \n', '        uint256         mode2BatchID;         \n', '        uint256         mode2BlockTimeout;   \n', '\n', '\t\tuint32[2]\t\tpackedData;\t\t//[0] = mode1 challenge how ,any cube to stack;\n', '\t\t                                //[1] = mode1 multiplier\n', '\t\t\t\t\t\t\n', '    }\n', '    \n', '    \n', '    struct GameRoundData_s\n', '    {\n', '\t   \n', '\t   //mode1 \n', '\t   uint256\t\t\t\ttreasureAmount;\n', '\t   \n', '\t   //mode2\n', '\t   uint256              potAmount;\n', '\t   address\t\t\t\tcurrentPotWinner;\n', '\t   uint256              potBlockCountdown;\n', '\t          \n', '       uint256              hdx20AppreciationPayout;\n', '       uint256              devAppreciationPayout;\n', '\t   \n', '       //********************************************************************************************\n', '\t   \n', '\t   uint32[4]\t\t\textraData;\t\t//[0] = mode1 percentage    treasure\n', '\t\t\t\t\t\t\t\t\t        //[1] =\tmode2 current       highscore\n', '                                            //[2] = mode1 and mode2 blocktimeout  how manyblock to submit a valid score\n', '                                            //[3] = mode2 countdown how many block\n', '                                           \n', '                                            \n', '    }\n', '      \n', '   \n', '    mapping (address => PlayerData_s)   private PlayerData;\n', '       \n', '    GameRoundData_s   private GameRoundData;\n', '   \n', '    uint8 constant private HDX20BuyFees = 5;\n', '     \n', '    uint8 constant private DevFees = 5;\n', '\tuint8 constant private AppreciationFees = 15;\t\t\n', '\n', '\tuint8 constant private TreasureAppreciation = 80;\n', '   \tuint8 constant private PotAppreciation = 80;\n', '   \t\n', '   \n', '    uint256 constant internal magnitude = 1e18;\n', '     \n', '    uint256 private minimumSharePrice = 0.1 ether;\n', '    \n', '\n', '    uint256 constant thresholdForAppreciation = 0.05 ether;\n', '      \n', '    /*================================\n', '    =       PUBLIC FUNCTIONS         =\n', '    ================================*/\n', '    \n', "    //fallback will be called only from the HDX token contract to fund the game from customers's HDX20\n", '    \n', '     function()\n', '     payable\n', '     public\n', '     onlyFromHDXToken \n', '    {\n', '       \n', '      \n', '      \n', '          \n', '    }\n', '    \n', '    function ChargePot() public payable\n', '    {\n', '\t\tuint256 _val = msg.value;\n', '\t\t\n', '\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val );\n', '\t\n', '    }\n', '    \n', '    function ChargeTreasure() public payable\n', '    {\n', '\t\tuint256 _val = msg.value;\n', '\t\n', '\t\t\n', '\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val );\n', '\t\t\t\t   \n', '    }\n', '\t\n', '\t//mode1\n', '\tfunction AddTreasure( uint256 _val ) private\n', '\t{\n', '\t\n', '\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val.mul( TreasureAppreciation ) / 100 );\n', '\t\t\n', '\t\t//now HDX20 appreciation and dev account\n', '\t\t\n', '\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \n', '          \n', '        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \n', '\t\t\n', '\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\n', '\t\t\n', '\t\tif (_dev>= thresholdForAppreciation )\n', '\t\t{\n', '\t\t\tGameRoundData.devAppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t GameRoundData.devAppreciationPayout = _dev;\n', '\t\t}\n', '\t\n', '\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\n', '\t\t\n', '\t\tif (_appreciation>= thresholdForAppreciation)\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\n', '\t\t}\n', '\t\t\n', '\t}\n', '\t\n', '    //mode2\n', '\tfunction AddPot( uint256 _val ) private\n', '\t{\n', '\t    \n', '        \n', '\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val.mul( PotAppreciation ) / 100 );\n', '\t\t\n', '\t\t//now HDX20 appreciation and dev account\n', '\t\t\n', '\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \n', '          \n', '        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \n', '\t\t\n', '\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\n', '\t\t\n', '\t\tif (_dev>= thresholdForAppreciation )\n', '\t\t{\n', '\t\t\tGameRoundData.devAppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t GameRoundData.devAppreciationPayout = _dev;\n', '\t\t}\n', '\t\n', '\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\n', '\t\t\n', '\t\tif (_appreciation>= thresholdForAppreciation)\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\n', '\t\t\t\n', '\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\n', '\t\t}\n', '\t\t\n', '\t}\n', '    \n', '    \n', '    function ValidMode1Score( uint256 score, uint256 mode1BatchID , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        address _customer_address = msg.sender;\n', '      \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = mode1BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '   \n', '        checkPayPot();\n', '   \n', '        coreValidMode1Score( _customer_address , gamevar  );\n', '    }\n', '    \n', '    function ValidMode2Score( uint256 score, uint256 mode2BatchID , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        address _customer_address = msg.sender;\n', '      \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = mode2BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '        \n', '        checkPayPot();\n', '   \n', '        coreValidMode2Score( _customer_address , gamevar  );\n', '    }\n', '    \n', '    struct GameVar_s\n', '    {\n', '        uint256  BatchID;\n', '       \n', ' \t    uint256   score;\n', '\t\n', '        bytes32  r;\n', '        bytes32  s;\n', '        uint8    v;\n', '        uint32   multiplier;\n', '    }\n', '    \n', '\tfunction checkPayPot() private\n', '\t{\n', '\t    uint256 b1 =  GameRoundData.potBlockCountdown;\n', '\t    \n', '\t    if (b1>0)\n', '\t    {\n', '\t        if (block.number>=b1)\n', '\t        {\n', '    \t\t    address _winner = GameRoundData.currentPotWinner;\n', '    \t\t    uint256 _j = GameRoundData.potAmount/2;\n', '    \t\t\n', '    \t\t   \n', '    \t\t\n', '    \t\t    if (_winner != address(0))\n', '    \t\t    {\n', '    \t\t\t    PlayerData[ _winner ].chest = PlayerData[ _winner ].chest.add( _j ); \n', '    \t\t    }\n', '    \t\t    \n', '        \t\tGameRoundData.currentPotWinner = address(0);\n', '        \t\tGameRoundData.potAmount = GameRoundData.potAmount.sub( _j );\n', '        \t\t\n', '        \t    //highscore to 0\n', '        \t\tGameRoundData.extraData[1] = 0;\n', '        \t\t//block at 0\n', '        \t\tGameRoundData.potBlockCountdown = 0;\n', '        \t\t\n', '    \t\t}\n', '\t    }\n', '\t\t\n', '\t}\n', '  \n', '    \n', '    function coreValidMode1Score( address _player_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '                \n', '        require((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode1BatchID) && ( _PlayerData.mode1LockedCredit>0 ));\n', '        \n', '        if (block.number>=_PlayerData.mode1BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\n', '        {\n', '            gamevar.score = 0;\n', '        }\n', '\t\t\n', '\t\n', '\t    if (gamevar.score> _PlayerData.packedData[0]) \tgamevar.score =  _PlayerData.packedData[0];\n', '\t    \n', '\t    uint256 _winning =0;\n', '\t    uint256 _hdx20 = 0;\n', '\t    uint256 _nb_token = 0;\n', '\t    uint256 _minimum =  _PlayerData.mode1LockedCredit.mul(5) / 100;\n', '\t   \n', '\t    \n', '\t   \n', '\t    if (gamevar.score>0)\n', '\t    {\n', '\t        uint256 _gain;\n', '\t    \n', '\t        //percentage of treasure      \n', '\t        _gain = GameRoundData.treasureAmount.mul( GameRoundData.extraData[0]) / 100;\n', '\t        \n', '\t        //scale the gain based the credit size\n', '\t        _gain = _gain.mul( _PlayerData.packedData[1]) / 10;\n', '\t   \n', '\t        //triple cube curve     \n', '\t        _gain = _gain.mul( _PlayerData.packedData[0] * _PlayerData.packedData[0] * _PlayerData.packedData[0] );\n', '\t        _gain /= (10*10*10);\n', '\t        \n', '\t          //maximum x2\n', '\t        if (_gain>_PlayerData.mode1LockedCredit) _gain = _PlayerData.mode1LockedCredit;\n', '\t        \n', '\t        //succed challenge ?\n', '\t        if (gamevar.score==_PlayerData.packedData[0])\n', '\t        {\n', '\t            _winning = _PlayerData.mode1LockedCredit.add( _gain);\n', '\t        }\n', '\t        else\n', '\t        {\n', '\t            _winning = _PlayerData.mode1LockedCredit.sub( _gain );\n', '\t            _gain = (_gain).mul( gamevar.score-1 );\n', '\t            _gain /= uint256( _PlayerData.packedData[0] );\n', '\t            _winning = _winning.add( _gain );\n', '\t        }\n', '\t    }\n', '\t    \n', '\t    if (_winning<_minimum) _winning = _minimum;\n', '\t    \n', '\t   //winning cannot be zero \n', '\t   \n', '\t   //HDX20BuyFees\n', '        _hdx20 = (_winning.mul(HDX20BuyFees)) / 100;\n', '\t\n', '\t    _nb_token =   HDXcontract.buyTokenFromGame.value( _hdx20 )( _player_address , address(0)); \n', '\t     \n', '\t\t//credit the player for what is won minus the HDX20\n', '\t\t_PlayerData.chest = _PlayerData.chest.add( _winning - _hdx20 );\n', '\t\t\n', '\t\t//loosing some ?\n', '\t\t\n', '\t\tif (_PlayerData.mode1LockedCredit> _winning)\n', '\t\t{\n', '\t\t\t\n', '\t\t\tAddTreasure( _PlayerData.mode1LockedCredit - _winning );\n', '\t\t}\n', '\t\t\n', '\t\t//we need to pay the difference from the treasure\n', '\t\tif (_winning>_PlayerData.mode1LockedCredit)\n', '\t\t{\n', '\t\t    GameRoundData.treasureAmount = GameRoundData.treasureAmount.sub( _winning - _PlayerData.mode1LockedCredit);\n', '\t\t}\n', '\t\n', '        //ok reset it so we can get a new one\n', '        _PlayerData.mode1BatchID = 0;\n', '        _PlayerData.mode1LockedCredit = 0;\n', '\t\t\n', '        emit onNewScoreMode1( gamevar.score , _player_address , _winning , _nb_token );\n', '\n', '    }\n', '    \n', '    function coreValidMode2Score( address _player_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '        \n', '                \n', '        if ((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode2BatchID))\n', '        {\n', '                \n', '            if (block.number>=_PlayerData.mode2BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\n', '            {\n', '                gamevar.score = 0;\n', '            }\n', '    \t\t\n', '    \t\n', '    \t    if (gamevar.score>80*2*15) \tgamevar.score = 80*2*15;\n', '    \t    \n', '    \t    bool _newHighscore = false;\n', '    \t    \n', '    \t    //new highscore\n', '    \t    if (gamevar.score > GameRoundData.extraData[1])\n', '    \t    {\n', '    \t        GameRoundData.extraData[1] = uint32(gamevar.score);\n', '    \t        GameRoundData.currentPotWinner = _player_address;\n', '    \t        GameRoundData.potBlockCountdown = block.number + uint256( GameRoundData.extraData[3] ); //24 hours countdown start\n', '    \t        \n', '    \t        _newHighscore = true;\n', '    \t        \n', '    \t    }\n', '    \t    \n', '    \t    emit onNewScoreMode2( gamevar.score , _player_address , _newHighscore);\n', '        }\n', '\t \n', '        //ok reset it so we can get a new one\n', '        _PlayerData.mode2BatchID = 0;\n', '     \n', '\t\t\n', '\n', '    }\n', '    \n', '    \n', '    function BuyMode1WithDividends( uint256 eth , uint32 challenge, uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        \n', '        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10) );\n', '  \n', '        address _customer_address = msg.sender;\n', '        \n', '        checkPayPot();\n', '        \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '        gamevar.multiplier = uint32(eth / minimumSharePrice);\n', '      \n', '        \n', '        eth = HDXcontract.payWithToken( eth , _customer_address );\n', '       \n', '        require( eth>0 );\n', '       \n', '         \n', '        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address , gamevar );\n', '        \n', '       \n', '    }\n', '    \n', ' \n', '    \n', '    function BuyMode1( uint32 challenge, uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\n', '    onlyDirectTransaction\n', '    {\n', '     \n', '        address _customer_address = msg.sender;\n', '        uint256 eth = msg.value;\n', '        \n', '        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10));\n', '        \n', '        checkPayPot();\n', '   \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '        gamevar.multiplier = uint32(eth / minimumSharePrice);\n', '     \n', '        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address, gamevar);\n', '     \n', '    }\n', '    \n', '    \n', '    function BuyMode2WithDividends( uint256 eth , uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\n', '    onlyDirectTransaction\n', '    {\n', '        \n', '        require( (eth==minimumSharePrice) );\n', '  \n', '        address _customer_address = msg.sender;\n', '        \n', '        checkPayPot();\n', '        \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '      \n', '        \n', '        eth = HDXcontract.payWithToken( eth , _customer_address );\n', '       \n', '        require( eth>0 );\n', '       \n', '         \n', '        CoreBuyMode2( _customer_address , eth , _referrer_address , gamevar );\n', '        \n', '       \n', '    }\n', '    \n', '    \n', '    function BuyMode2( uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\n', '    onlyDirectTransaction\n', '    {\n', '     \n', '        address _customer_address = msg.sender;\n', '        uint256 eth = msg.value;\n', '        \n', '        require( (eth==minimumSharePrice));\n', '        \n', '        checkPayPot();\n', '   \n', '        GameVar_s memory gamevar;\n', '        gamevar.score = score;\n', '        gamevar.BatchID = BatchID;\n', '        gamevar.r = r;\n', '        gamevar.s = s;\n', '        gamevar.v = v;\n', '     \n', '   \n', '        CoreBuyMode2( _customer_address , eth , _referrer_address, gamevar);\n', '     \n', '    }\n', '    \n', '    /*================================\n', '    =       CORE BUY FUNCTIONS       =\n', '    ================================*/\n', '    \n', '    function CoreBuyMode1( address _player_address , uint256 eth , uint32 challenge,  address _referrer_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '         \n', '        //we need to validate the score before buying a torpedo batch\n', '        if (gamevar.BatchID !=0 || _PlayerData.mode1BatchID !=0)\n', '        {\n', '             coreValidMode1Score( _player_address , gamevar);\n', '        }\n', '        \n', "        //if we can continue then everything is fine let's create the new batch\n", '        \n', '        _PlayerData.packedData[0] = challenge;\n', '        _PlayerData.packedData[1] = gamevar.multiplier;\n', '        \n', '        _PlayerData.mode1BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\n', '        _PlayerData.mode1BatchID = uint256((keccak256(abi.encodePacked( block.number,1,challenge, _player_address , address(this)))));\n', '      \n', '\t\t_PlayerData.mode1LockedCredit =  eth;\n', '\t\n', '        \n', '        emit onBuyMode1( _player_address, _PlayerData.mode1BatchID , _PlayerData.mode1BlockTimeout,  _PlayerData.packedData[0]);\n', '            \n', '        \n', '    }\n', '    \n', '    \n', '    function CoreBuyMode2( address _player_address , uint256 eth ,  address _referrer_address , GameVar_s gamevar) private\n', '    {\n', '    \n', '        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n', '         \n', '        //we need to validate the score before buying a torpedo batch\n', '        if (gamevar.BatchID !=0 || _PlayerData.mode2BatchID !=0)\n', '        {\n', '             coreValidMode2Score( _player_address , gamevar);\n', '        }\n', '        \n', "        //if we can continue then everything is fine let's create the new batch\n", '        \n', '       \n', '        _PlayerData.mode2BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\n', '        _PlayerData.mode2BatchID = uint256((keccak256(abi.encodePacked( block.number,2, _player_address , address(this)))));\n', '      \n', '         //HDX20BuyFees\n', '        uint256 _tempo = (eth.mul(HDX20BuyFees)) / 100;\n', '\t\n', '\t    eth = eth.sub( _tempo );\t\n', '\t\n', '        uint256 _nb_token =   HDXcontract.buyTokenFromGame.value( _tempo )( _player_address , _referrer_address);\n', '        \n', '        AddPot( eth );\n', '        \n', '        emit onBuyMode2( _player_address, _PlayerData.mode2BatchID , _PlayerData.mode2BlockTimeout, _nb_token );\n', '            \n', '        \n', '    }\n', '    \n', '    function getPotGain( address _player_address) private view\n', '    returns( uint256)\n', '\t{\n', '\t    uint256 b1 =  GameRoundData.potBlockCountdown;\n', '\t    \n', '\t    if (b1>0)\n', '\t    {\n', '\t        if (block.number>=b1 && _player_address==GameRoundData.currentPotWinner)\n', '\t        {\n', '\t            return( GameRoundData.potAmount/2);\n', '\t          \n', '    \t\t}\n', '\t    }\n', '\t    \n', '\t    return( 0 );\n', '\t\t\n', '\t}\n', '   \n', '    \n', '    function get_Gains(address _player_address) private view\n', '    returns( uint256)\n', '    {\n', '       \n', '        uint256 _gains = PlayerData[ _player_address ].chest;\n', '        \n', '        //we may have to temporary add the current pot gain to reflect the correct position\n', '        \n', '        _gains = _gains.add( getPotGain(_player_address ) );\n', '        \n', '        if (_gains > PlayerData[ _player_address].payoutsTo)\n', '        {\n', '            _gains -= PlayerData[ _player_address].payoutsTo;\n', '        }\n', '        else _gains = 0;\n', '     \n', '    \n', '        return( _gains );\n', '        \n', '    }\n', '    \n', '    \n', '    function WithdrawGains() public \n', '   \n', '    {\n', '        address _customer_address = msg.sender;\n', '        \n', '        checkPayPot();\n', '        \n', '        uint256 _gains = get_Gains( _customer_address );\n', '        \n', '        require( _gains>0);\n', '        \n', '        PlayerData[ _customer_address ].payoutsTo = PlayerData[ _customer_address ].payoutsTo.add( _gains );\n', '        \n', '      \n', '        emit onWithdrawGains( _customer_address , _gains , now);\n', '        \n', '        _customer_address.transfer( _gains );\n', '        \n', '        \n', '    }\n', '    \n', '   \n', '  \n', '    \n', '     /*================================\n', '    =  VIEW AND HELPERS FUNCTIONS    =\n', '    ================================*/\n', '  \n', '    \n', '    function view_get_Treasure() public\n', '    view\n', '    returns(uint256)\n', '    {\n', '      \n', '      return( GameRoundData.treasureAmount );  \n', '    }\n', '\t\n', '\tfunction view_get_Pot() public\n', '    view\n', '    returns(uint256)\n', '    {\n', '      \n', '      return( GameRoundData.potAmount );  \n', '    }\n', ' \n', '    function view_get_gameData() public\n', '    view\n', '    returns( \n', '             uint256 treasure,\n', '\t\t\t uint256 pot,\n', '\t\t\t uint32  highscore ,\n', '\t\t\t address highscore_address ,\n', '\t\t\n', '\t\t\t uint256 mode1BatchID,\n', '\t\t     uint256 mode1BlockTimeout,\n', '\t\t     uint32  mode1Challenge,\n', '\t\t     uint256 mode1Multiplier,\n', '\t\t     \n', '\t\t\t uint256 mode2BatchID,\n', '\t\t\t uint256 mode2BlockTimeout,\n', '\t\t\t \n', '\t\t\t uint256 potBlockCountdown,\n', '\t\t\t \n', '\t\t\t uint32  percentage)\n', '    {\n', '        address _player_address = msg.sender;\n', '\t\t\n', '\t\ttreasure = GameRoundData.treasureAmount;\n', '\t\tpot = GameRoundData.potAmount;\n', '\t\thighscore = GameRoundData.extraData[1];\n', '\t\thighscore_address = GameRoundData.currentPotWinner;\n', '\t\tpercentage = GameRoundData.extraData[0];\n', '\t\t      \n', '        mode1BatchID = PlayerData[_player_address].mode1BatchID;\n', '        mode1BlockTimeout = PlayerData[_player_address].mode1BlockTimeout;\n', '        mode1Challenge = PlayerData[_player_address].packedData[0];\n', '        mode1Multiplier =  PlayerData[_player_address].packedData[1];\n', '        \n', '        mode2BatchID =  PlayerData[_player_address].mode2BatchID;\n', '        mode2BlockTimeout = PlayerData[ _player_address].mode2BlockTimeout;\n', '        \n', '        potBlockCountdown = GameRoundData.potBlockCountdown;\n', '        \n', '      \n', '       \n', '    }\n', '  \n', '       \n', '  \n', '    \n', '    function view_get_Gains()\n', '    public\n', '    view\n', '    returns( uint256 gains)\n', '    {\n', '        \n', '        address _player_address = msg.sender;\n', '   \n', '        uint256 _gains = PlayerData[ _player_address ].chest;\n', '        \n', '        _gains = _gains.add( getPotGain( _player_address ) );\n', '        \n', '        if (_gains > PlayerData[ _player_address].payoutsTo)\n', '        {\n', '            _gains -= PlayerData[ _player_address].payoutsTo;\n', '        }\n', '        else _gains = 0;\n', '     \n', '    \n', '        return( _gains );\n', '        \n', '    }\n', '  \n', '  \n', '    \n', '    function view_get_gameStates() public \n', '    view\n', '    returns( uint256 minimumshare ,\n', '\t\t     uint256 blockNumberCurrent,\n', '\t\t     uint32  blockScoreTimeout,\n', '\t\t     uint32  blockPotTimout\n', '\t\t   \n', '\t\t    )\n', '    {\n', '       \n', '        \n', '        return( minimumSharePrice ,  block.number   , GameRoundData.extraData[2] , GameRoundData.extraData[3] );\n', '    }\n', '    \n', '    function view_get_pendingHDX20Appreciation()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return GameRoundData.hdx20AppreciationPayout;\n', '    }\n', '    \n', '    function view_get_pendingDevAppreciation()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return GameRoundData.devAppreciationPayout;\n', '    }\n', '  \n', ' \n', ' \n', '    function totalEthereumBalance()\n', '    public\n', '    view\n', '    returns(uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '  \n', '    \n', '    function view_get_blockNumbers()\n', '    public\n', '    view\n', '    returns( uint256 b1 )\n', '    {\n', '        return( block.number);\n', '        \n', '    }\n', '    \n', '  \n', '    \n', '   \n', '}\n', '\n', '\n', 'library SafeMath {\n', '    \n', '   \n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '   \n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '   \n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}\n', '\n', '\n', 'library SafeMath128 {\n', '    \n', '   \n', '    function mul(uint128 a, uint128 b) \n', '        internal \n', '        pure \n', '        returns (uint128 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '   \n', '    function sub(uint128 a, uint128 b)\n', '        internal\n', '        pure\n', '        returns (uint128) \n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '   \n', '    function add(uint128 a, uint128 b)\n', '        internal\n', '        pure\n', '        returns (uint128 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    \n', '   \n', '}']