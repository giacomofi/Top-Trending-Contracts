['/**\n', ' * Copyright 2017â€“2018, bZeroX, LLC. All Rights Reserved.\n', ' * Licensed under the Apache License, Version 2.0.\n', ' */\n', ' \n', 'pragma solidity 0.5.3;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract EIP20 is ERC20 {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '}\n', '\n', 'interface NonCompliantEIP20 {\n', '    function transfer(address _to, uint256 _value) external;\n', '    function transferFrom(address _from, address _to, uint256 _value) external;\n', '    function approve(address _spender, uint256 _value) external;\n', '}\n', '\n', 'contract EIP20Wrapper {\n', '\n', '    function eip20Transfer(\n', '        address token,\n', '        address to,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).transfer(to, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20Transfer failed");\n', '    }\n', '\n', '    function eip20TransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).transferFrom(from, to, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20TransferFrom failed");\n', '    }\n', '\n', '    function eip20Approve(\n', '        address token,\n', '        address spender,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).approve(spender, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20Approve failed");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, rounding up and truncating the quotient\n', '  */\n', '  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    return ((_a - 1) / _b) + 1;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract BZxOwnable is Ownable {\n', '\n', '    address public bZxContractAddress;\n', '\n', '    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\n', '\n', "    // modifier reverts if bZxContractAddress isn't set\n", '    modifier onlyBZx() {\n', '        require(msg.sender == bZxContractAddress, "only bZx contracts can call this function");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\n', '    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\n', '    */\n', '    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\n', '        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, "transferBZxOwnership::unauthorized");\n', '        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\n', '        bZxContractAddress = newBZxContractAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0) && newOwner != bZxContractAddress, "transferOwnership::unauthorized");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ExchangeV2Interface {\n', '\n', '    struct OrderV2 {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', "        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n", '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '    }\n', '\n', '    struct FillResults {\n', '        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n', '        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n', '        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n', '        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n', '    }\n', '\n', '    /// @dev Fills the input order.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param order Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrderNoThrow(\n', '        OrderV2 memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature)\n', '        public\n', '        returns (FillResults memory fillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketSellOrdersNoThrow(\n', '        OrderV2[] memory orders,\n', '        uint256 takerAssetFillAmount,\n', '        bytes[] memory signatures)\n', '        public\n', '        returns (FillResults memory totalFillResults);\n', '\n', '\n', '    /// @dev Verifies that a signature is valid.\n', '    /// @param hash Message hash that is signed.\n', '    /// @param signerAddress Address that should have signed the given hash.\n', '    /// @param signature Proof of signing.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        bytes32 hash,\n', '        address signerAddress,\n', '        bytes calldata signature)\n', '        external\n', '        view\n', '        returns (bool isValid);\n', '}\n', '\n', 'contract BZxTo0xShared {\n', '    using SafeMath for uint256;\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator rounded down.\n', '    ///      Reverts if rounding error is >= 0.1%\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target rounded down.\n', '    function _safeGetPartialAmountFloor(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256 partialAmount)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        require(\n', '            !_isRoundingErrorFloor(\n', '                numerator,\n', '                denominator,\n', '                target\n', '            ),\n', '            "ROUNDING_ERROR"\n', '        );\n', '        \n', '        partialAmount = SafeMath.div(\n', '            SafeMath.mul(numerator, target),\n', '            denominator\n', '        );\n', '        return partialAmount;\n', '    }\n', '\n', '    /// @dev Checks if rounding error >= 0.1% when rounding down.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function _isRoundingErrorFloor(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (bool isError)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '        \n', '        // The absolute rounding error is the difference between the rounded\n', '        // value and the ideal value. The relative rounding error is the\n', '        // absolute rounding error divided by the absolute value of the\n', '        // ideal value. This is undefined when the ideal value is zero.\n', '        //\n', '        // The ideal value is `numerator * target / denominator`.\n', "        // Let's call `numerator * target % denominator` the remainder.\n", '        // The absolute error is `remainder / denominator`.\n', '        //\n', '        // When the ideal value is zero, we require the absolute error to\n', '        // be zero. Fortunately, this is always the case. The ideal value is\n', '        // zero iff `numerator == 0` and/or `target == 0`. In this case the\n', '        // remainder and absolute error are also zero. \n', '        if (target == 0 || numerator == 0) {\n', '            return false;\n', '        }\n', '        \n', '        // Otherwise, we want the relative rounding error to be strictly\n', '        // less than 0.1%.\n', '        // The relative error is `remainder / (numerator * target)`.\n', '        // We want the relative error less than 1 / 1000:\n', '        //        remainder / (numerator * denominator)  <  1 / 1000\n', '        // or equivalently:\n', '        //        1000 * remainder  <  numerator * target\n', '        // so we have a rounding error iff:\n', '        //        1000 * remainder  >=  numerator * target\n', '        uint256 remainder = mulmod(\n', '            target,\n', '            numerator,\n', '            denominator\n', '        );\n', '        isError = SafeMath.mul(1000, remainder) >= SafeMath.mul(numerator, target);\n', '        return isError;\n', '    }\n', '}\n', '\n', 'contract BZxTo0xV2 is BZxTo0xShared, EIP20Wrapper, BZxOwnable {\n', '    using SafeMath for uint256;\n', '\n', '    event LogFillResults(\n', '        uint256 makerAssetFilledAmount,\n', '        uint256 takerAssetFilledAmount,\n', '        uint256 makerFeePaid,\n', '        uint256 takerFeePaid\n', '    );\n', '\n', '    bool public DEBUG = false;\n', '\n', '    address public exchangeV2Contract;\n', '    address public zrxTokenContract;\n', '    address public erc20ProxyContract;\n', '\n', '    constructor(\n', '        address _exchangeV2,\n', '        address _zrxToken,\n', '        address _proxy)\n', '        public\n', '    {\n', '        exchangeV2Contract = _exchangeV2;\n', '        zrxTokenContract = _zrxToken;\n', '        erc20ProxyContract = _proxy;\n', '    }\n', '\n', '    function()\n', '        external {\n', '        revert();\n', '    }\n', '\n', '    // 0xc78429c4 == "take0xV2Trade(address,address,uint256,(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[],bytes[])"\n', '    function take0xV2Trade(\n', '        address trader,\n', '        address vaultAddress,\n', '        uint256 sourceTokenAmountToUse,\n', '        ExchangeV2Interface.OrderV2[] memory orders0x, // Array of 0x V2 order structs\n', '        bytes[] memory signatures0x) // Array of signatures for each of the V2 orders\n', '        public\n', '        onlyBZx\n', '        returns (\n', '            address destTokenAddress,\n', '            uint256 destTokenAmount,\n', '            uint256 sourceTokenUsedAmount)\n', '    {\n', '        address sourceTokenAddress;\n', '\n', '        //destTokenAddress==makerToken, sourceTokenAddress==takerToken\n', '        (destTokenAddress, sourceTokenAddress) = getV2Tokens(orders0x[0]);\n', '\n', '        (sourceTokenUsedAmount, destTokenAmount) = _take0xV2Trade(\n', '            trader,\n', '            sourceTokenAddress,\n', '            sourceTokenAmountToUse,\n', '            orders0x,\n', '            signatures0x);\n', '\n', '        if (sourceTokenUsedAmount < sourceTokenAmountToUse) {\n', '            // all sourceToken has to be traded\n', '            revert("BZxTo0xV2::take0xTrade: sourceTokenUsedAmount < sourceTokenAmountToUse");\n', '        }\n', '\n', '        // transfer the destToken to the vault\n', '        eip20Transfer(\n', '            destTokenAddress,\n', '            vaultAddress,\n', '            destTokenAmount);\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint256 numerator, uint256 denominator, uint256 target)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\n', '    }\n', '\n', '    /// @dev Extracts the maker and taker token addresses from the 0x V2 order object.\n', '    /// @param order 0x V2 order object.\n', '    /// @return makerTokenAddress and takerTokenAddress.\n', '    function getV2Tokens(\n', '        ExchangeV2Interface.OrderV2 memory order)\n', '        public\n', '        pure\n', '        returns (\n', '            address makerTokenAddress,\n', '            address takerTokenAddress)\n', '    {\n', '        bytes memory makerAssetData = order.makerAssetData;\n', '        bytes memory takerAssetData = order.takerAssetData;\n', '        bytes4 makerProxyID;\n', '        bytes4 takerProxyID;\n', '\n', '        // example data: 0xf47261b00000000000000000000000001dc4c1cefef38a777b15aa20260a54e584b16c48\n', '        assembly {\n', '            makerProxyID := mload(add(makerAssetData, 32))\n', '            takerProxyID := mload(add(takerAssetData, 32))\n', '\n', '            makerTokenAddress := mload(add(makerAssetData, 36))\n', '            takerTokenAddress := mload(add(takerAssetData, 36))\n', '        }\n', '\n', '        // ERC20 Proxy ID -> bytes4(keccak256("ERC20Token(address)")) = 0xf47261b0\n', '        require(makerProxyID == 0xf47261b0 && takerProxyID == 0xf47261b0, "BZxTo0xV2::getV2Tokens: 0x V2 orders must use ERC20 tokens");\n', '    }\n', '\n', '    function set0xV2Exchange (\n', '        address _exchange)\n', '        public\n', '        onlyOwner\n', '    {\n', '        exchangeV2Contract = _exchange;\n', '    }\n', '\n', '    function setZRXToken (\n', '        address _zrxToken)\n', '        public\n', '        onlyOwner\n', '    {\n', '        zrxTokenContract = _zrxToken;\n', '    }\n', '\n', '    function set0xTokenProxy (\n', '        address _proxy)\n', '        public\n', '        onlyOwner\n', '    {\n', '        erc20ProxyContract = _proxy;\n', '    }\n', '\n', '    function approveFor (\n', '        address token,\n', '        address spender,\n', '        uint256 value)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        eip20Approve(\n', '            token,\n', '            spender,\n', '            value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function toggleDebug (\n', '        bool isDebug)\n', '        public\n', '        onlyOwner\n', '    {\n', '        DEBUG = isDebug;\n', '    }\n', '\n', '    function _take0xV2Trade(\n', '        address trader,\n', '        address sourceTokenAddress,\n', '        uint256 sourceTokenAmountToUse,\n', '        ExchangeV2Interface.OrderV2[] memory orders0x, // Array of 0x V2 order structs\n', '        bytes[] memory signatures0x)\n', '        internal\n', '        returns (uint256 sourceTokenUsedAmount, uint256 destTokenAmount)\n', '    {\n', '        uint256 zrxTokenAmount = 0;\n', '        uint256 takerAssetRemaining = sourceTokenAmountToUse;\n', '        for (uint256 i = 0; i < orders0x.length; i++) {\n', '            // Note: takerAssetData (sourceToken) is confirmed to be the same in 0x for batch orders\n', '            // To confirm makerAssetData is the same for each order, rather than doing a more expensive per order bytes\n', '            // comparison, we will simply set makerAssetData the same in each order to the first value observed. The 0x\n', '            // trade will fail for invalid orders.\n', '            if (i > 0)\n', '                orders0x[i].makerAssetData = orders0x[0].makerAssetData;\n', '\n', '            // calculate required takerFee\n', '            if (takerAssetRemaining > 0 && orders0x[i].takerFee > 0) { // takerFee\n', '                if (takerAssetRemaining >= orders0x[i].takerAssetAmount) {\n', '                    zrxTokenAmount = zrxTokenAmount.add(orders0x[i].takerFee);\n', '                    takerAssetRemaining = takerAssetRemaining.sub(orders0x[i].takerAssetAmount);\n', '                } else {\n', '                    zrxTokenAmount = zrxTokenAmount.add(_safeGetPartialAmountFloor(\n', '                        takerAssetRemaining,\n', '                        orders0x[i].takerAssetAmount,\n', '                        orders0x[i].takerFee\n', '                    ));\n', '                    takerAssetRemaining = 0;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (zrxTokenAmount > 0) {\n', '            // The 0x erc20ProxyContract already has unlimited transfer allowance for ZRX from this contract (set during deployment of this contract)\n', '            eip20TransferFrom(\n', '                zrxTokenContract,\n', '                trader,\n', '                address(this),\n', '                zrxTokenAmount);\n', '        }\n', '\n', '        // Make sure there is enough allowance for 0x Exchange Proxy to transfer the sourceToken needed for the 0x trade\n', '        uint256 tempAllowance = EIP20(sourceTokenAddress).allowance(address(this), erc20ProxyContract);\n', '        if (tempAllowance < sourceTokenAmountToUse) {\n', '            if (tempAllowance > 0) {\n', '                // reset approval to 0\n', '                eip20Approve(\n', '                    sourceTokenAddress,\n', '                    erc20ProxyContract,\n', '                    0);\n', '            }\n', '\n', '            eip20Approve(\n', '                sourceTokenAddress,\n', '                erc20ProxyContract,\n', '                sourceTokenAmountToUse);\n', '        }\n', '\n', '        ExchangeV2Interface.FillResults memory fillResults;\n', '        if (orders0x.length > 1) {\n', '            fillResults = ExchangeV2Interface(exchangeV2Contract).marketSellOrdersNoThrow(\n', '                orders0x,\n', '                sourceTokenAmountToUse,\n', '                signatures0x);\n', '        } else {\n', '            fillResults = ExchangeV2Interface(exchangeV2Contract).fillOrderNoThrow(\n', '                orders0x[0],\n', '                sourceTokenAmountToUse,\n', '                signatures0x[0]);\n', '        }\n', '\n', '        if (zrxTokenAmount > 0 && fillResults.takerFeePaid < zrxTokenAmount) {\n', '            // refund unused ZRX token (if any)\n', '            eip20Transfer(\n', '                zrxTokenContract,\n', '                trader,\n', '                zrxTokenAmount.sub(fillResults.takerFeePaid));\n', '        }\n', '\n', '        if (DEBUG) {\n', '            emit LogFillResults(\n', '                fillResults.makerAssetFilledAmount,\n', '                fillResults.takerAssetFilledAmount,\n', '                fillResults.makerFeePaid,\n', '                fillResults.takerFeePaid\n', '            );\n', '        }\n', '\n', '        sourceTokenUsedAmount = fillResults.takerAssetFilledAmount;\n', '        destTokenAmount = fillResults.makerAssetFilledAmount;\n', '    }\n', '}']