['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistedRole\n', ' * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n', ' * it), and not Whitelisteds themselves.\n', ' */\n', 'contract WhitelistedRole is WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistedAdded(address indexed account);\n', '    event WhitelistedRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelisteds;\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isWhitelisted(address account) public view returns (bool) {\n', '        return _whitelisteds.has(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        _removeWhitelisted(msg.sender);\n', '    }\n', '\n', '    function _addWhitelisted(address account) internal {\n', '        _whitelisteds.add(account);\n', '        emit WhitelistedAdded(account);\n', '    }\n', '\n', '    function _removeWhitelisted(address account) internal {\n', '        _whitelisteds.remove(account);\n', '        emit WhitelistedRemoved(account);\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'library MathFixed {\n', '\n', '  /**\n', '  * @dev Multiplies two fixed_point numbers.\n', '  */\n', '  function mulFixed(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return (((a * b) >> 95) + 1) >> 1;\n', '  }\n', '\n', '  /**\n', '  * @dev return a^n with fixed_point a, unsinged integer n.\n', '  * using exponentiation_by_squaring\n', '  */\n', '  function powFixed(uint256 a, uint256 n) internal pure returns (uint256){\n', '    uint256 r = 79228162514264337593543950336; // 1.0  * 2^96\n', '    while(n > 0){\n', '      if(n&1 > 0){\n', '        r = mulFixed(a, r);\n', '      }\n', '      a = mulFixed(a, a);\n', '      n >>= 1;\n', '    }\n', '    return r;\n', '  }\n', '}\n', '\n', 'contract TokenBase is ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract WR2Token is TokenBase {\n', '\n', '    WiredToken public wiredToken;\n', '\n', '    string public constant name = "WRD Exodus";\n', '    string public constant symbol = "WR2";\n', '    uint8 public constant decimals = 8;\n', '\n', '    constructor() public {\n', '        wiredToken = WiredToken(msg.sender);\n', '        emit Transfer(address(0), address(this), 0);\n', '    }\n', '\n', '    function balanceOf(address _holder) public view returns (uint256) {\n', '        return wiredToken.lookBalanceWR2(_holder);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        wiredToken.transferWR2(msg.sender, _to, _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        wiredToken.transferWR2(_from, _to, _value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return wiredToken.totalWR2();\n', '    }\n', '\n', '    function mint(address _holder, uint256 _value) external {\n', '        require(msg.sender == address(wiredToken));\n', '        wiredToken.mintWR2(_holder, _value);\n', '        emit Transfer(address(0), _holder, _value);\n', '    }\n', '\n', '    function transferByAdmin(address _from, uint256 _value) external {\n', '        require(wiredToken.isWhitelistAdmin(msg.sender));\n', '        wiredToken.transferWR2(_from, msg.sender, _value);\n', '        emit Transfer(_from, msg.sender, _value);\n', '    }\n', '}\n', '\n', 'contract WiredToken is WhitelistedRole, TokenBase {\n', '    using SafeMath for uint256;\n', '    using MathFixed for uint256;\n', '\n', '    string public constant name = "WRD Genesis";\n', '    string public constant symbol = "WRD";\n', '    uint8 public constant decimals = 8;\n', '\n', '    uint32 constant month = 30 days;\n', '    uint256 public constant bonusWRDtoWR2 = 316912650057057350374175801; //0.4%\n', '    uint256 public constant bonusWR2toWRD = 7922816251426433759354395; //0.01%\n', '    uint256 public initialSupply = uint256(250000000000).mul(uint(10)**decimals);\n', '\n', '    WR2Token public wr2Token;\n', '    uint256 private totalWRD;\n', '    uint256 public totalWR2;\n', '\n', '    bool public listing = false;\n', '    uint256 public launchTime = 9999999999999999999999;\n', '\n', '    mapping(address => uint256) lastUpdate;\n', '//    mapping(address => uint256) public startTime;\n', '    mapping(address => uint256) WRDBalances;\n', '    mapping(address => uint256) WRDDailyHoldBalances;\n', '    mapping(address => uint256) WR2Balances;\n', '    mapping(address => uint256) WR2DailyHoldBalances;\n', '\n', '    mapping(address => uint256) public presaleTokens;\n', '\n', '    uint256 public totalAirdropTokens;\n', '    uint256 public totalPresaleTokens;\n', '\n', '    constructor() public {\n', '        wr2Token = new WR2Token();\n', '\n', '        mint(address(this), initialSupply.mul(2).div(10));\n', '        WRDDailyHoldBalances[address(this)] = initialSupply.mul(2).div(10);\n', '\n', '        mint(msg.sender, initialSupply.mul(8).div(10));\n', '        WRDDailyHoldBalances[msg.sender] = initialSupply.mul(8).div(10);\n', '\n', '        _addWhitelisted(address(this));\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return totalWRD;\n', '    }\n', '\n', '    function balanceOf(address _holder) public view returns (uint256) {\n', '        uint[2] memory arr = lookBonus(_holder);\n', '        return WRDBalances[_holder].add(arr[0]).sub(lockUpAmount(_holder));\n', '    }\n', '\n', '    function lookBalanceWR2(address _holder) public view returns (uint256) {\n', '        uint[2] memory arr = lookBonus(_holder);\n', '        return WR2Balances[_holder].add(arr[1]);\n', '    }\n', '\n', '    function lockUpAmount(address _holder) internal view returns (uint) {\n', '        uint percentage = 100;\n', '        if (now >= launchTime.add(uint(12).mul(month))) {\n', '            uint pastMonths = (now.sub(launchTime.add(uint(12).mul(month)))).div(month);\n', '            percentage = 0;\n', '            if (pastMonths < 50) {\n', '                percentage = uint(100).sub(uint(2).mul(pastMonths));\n', '            }\n', '        }\n', '        return (presaleTokens[_holder]).mul(percentage).div(100);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        transferWRD(msg.sender, _to, _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        transferWRD(_from, _to, _value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferWRD(address _from, address _to, uint256 _value) internal {\n', '        if (listing) {\n', '            updateBonus(_from);\n', '            updateBonus(_to);\n', '        } else {\n', '            WRDDailyHoldBalances[_to] = WRDDailyHoldBalances[_to].add(_value);\n', '        }\n', '\n', '        require(WRDBalances[_from].sub(lockUpAmount(_from)) >= _value);\n', '\n', '        WRDBalances[_from] = WRDBalances[_from].sub(_value);\n', '        WRDBalances[_to] = WRDBalances[_to].add(_value);\n', '\n', '        WRDDailyHoldBalances[_from] = min(\n', '            WRDDailyHoldBalances[_from],\n', '            WRDBalances[_from]\n', '        );\n', '    }\n', '\n', '    function transferWR2(address _from, address _to, uint256 _value) external {\n', '        require(msg.sender == address(wr2Token));\n', '\n', '        if (listing) {\n', '            updateBonus(_from);\n', '            updateBonus(_to);\n', '        } else {\n', '            WR2DailyHoldBalances[_to] = WR2DailyHoldBalances[_to].add(_value);\n', '        }\n', '\n', '        require(WR2Balances[_from] >= _value);\n', '\n', '        WR2Balances[_from] = WR2Balances[_from].sub(_value);\n', '        WR2Balances[_to] = WR2Balances[_to].add(_value);\n', '\n', '\n', '        WR2DailyHoldBalances[_from] = min(\n', '            WR2DailyHoldBalances[_from],\n', '            WR2Balances[_from]\n', '        );\n', '    }\n', '\n', '    function mint(address _holder, uint _value) internal {\n', '        WRDBalances[_holder] = WRDBalances[_holder].add(_value);\n', '        totalWRD = totalWRD.add(_value);\n', '        emit Transfer(address(0), _holder, _value);\n', '    }\n', '\n', '    function mintWR2(address _holder, uint _value) external {\n', '        require(msg.sender == address(wr2Token));\n', '        WR2Balances[_holder] = WR2Balances[_holder].add(_value);\n', '        totalWR2 = totalWR2.add(_value);\n', '    }\n', '\n', '    function min(uint a, uint b) internal pure returns (uint) {\n', '        if(a > b) return b;\n', '        return a;\n', '    }\n', '\n', '    function updateBonus(address _holder) internal {\n', '        uint256 pastDays = now.sub((lastUpdate[_holder].mul(1 days)).add(launchTime)).div(1 days);\n', '        if (pastDays > 0) {\n', '            uint256[2] memory arr = lookBonus(_holder);\n', '\n', '            lastUpdate[_holder] = lastUpdate[_holder].add(pastDays);\n', '            WRDDailyHoldBalances[_holder] = WRDBalances[_holder].add(arr[0]);\n', '            WR2DailyHoldBalances[_holder] = WR2Balances[_holder].add(arr[1]);\n', '\n', '            if(arr[0] > 0) mint(_holder, arr[0]);\n', '            if(arr[1] > 0) wr2Token.mint(_holder, arr[1]);\n', '        }\n', '    }\n', '\n', '    function lookBonus(address _holder) internal view returns (uint256[2] memory bonuses) {\n', '        bonuses[0] = 0;\n', '        bonuses[1] = 0;\n', '        if (!isBonus(_holder) || !listing ){\n', '            return bonuses;\n', '        }\n', '        uint256 pastDays = (now.sub((lastUpdate[_holder].mul(1 days)).add(launchTime))).div(1 days);\n', '        if (pastDays == 0){\n', '            return bonuses;\n', '        }\n', '\n', '        // X(n+1) = X(n) + A*Y(n), Y(n+1) = B*X(n) + Y(n)\n', '        // => a := sqrt(A)\n', '        //    b := sqrt(B)\n', '        //    c := ((1+ab)^n + (1-ab)^n)/2\n', '        //    d := ((1+ab)^n - (1-ab)^n)/2\n', '        //    X(n) = c*X(0) + d*(a/b)*Y(0)\n', '        //    Y(n) = d*(b/a)*X(0) + c*Y(0)\n', '\n', '        // 1.0 : 79228162514264337593543950336\n', '        // A = 0.0001, B = 0.004\n', '        // A : 7922816251426433759354395\n', '        // a : 792281625142643375935439503\n', '        // B : 316912650057057350374175801\n', '        // b : 5010828967500958623728276031\n', '        // ab : 50108289675009586237282760\n', '        // 1+ab : 79278270803939347179781233096\n', '        // 1-ab : 79178054224589328007306667576\n', '        // a/b : 12527072418752396559320690078\n', '        // b/a : 501082896750095862372827603139\n', '\n', '        pastDays--;\n', '        uint256 ratePlus  = (uint256(79278270803939347179781233096)).powFixed(pastDays); // (1+sqrt(ab)) ^ n\n', '        uint256 rateMinus = (uint256(79178054224589328007306667576)).powFixed(pastDays); // (1-sqrt(ab)) ^ n\n', '        ratePlus += rateMinus;                 // c*2\n', '        rateMinus = ratePlus - (rateMinus<<1); // d*2\n', '        uint256 x0 = WRDBalances[_holder] + WR2DailyHoldBalances[_holder].mulFixed(bonusWR2toWRD);  // x(0)\n', '        uint256 y0 = WR2Balances[_holder] + WRDDailyHoldBalances[_holder].mulFixed(bonusWRDtoWR2); // y(0)\n', '        bonuses[0] = ratePlus.mulFixed(x0) + rateMinus.mulFixed(y0).mulFixed(uint256(12527072418752396559320690078));  // x(n)*2\n', '        bonuses[1] = rateMinus.mulFixed(x0).mulFixed(uint256(501082896750095862372827603139)) + ratePlus.mulFixed(y0); // y(n)*2\n', '        bonuses[0] = (bonuses[0]>>1) - WRDBalances[_holder]; // x(n) - balance\n', '        bonuses[1] = (bonuses[1]>>1) - WR2Balances[_holder]; // y(n) - balance\n', '        return bonuses;\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        if(listing) updateBonus(account);\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        if(listing) updateBonus(account);\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        if(listing) updateBonus(msg.sender);\n', '        _removeWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        if(listing) updateBonus(account);\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        if(listing) updateBonus(msg.sender);\n', '        _removeWhitelisted(msg.sender);\n', '    }\n', '\n', '    function isBonus(address _holder) internal view returns(bool) {\n', '        return !isWhitelistAdmin(_holder) && !isWhitelisted(_holder);\n', '    }\n', '\n', '    function startListing() public onlyWhitelistAdmin {\n', '        require(!listing);\n', '        launchTime = now;\n', '        listing = true;\n', '    }\n', '\n', '    function addAirdropTokens(address[] calldata sender, uint256[] calldata amount) external onlyWhitelistAdmin {\n', '        require(sender.length > 0 && sender.length == amount.length);\n', '\n', '        for (uint i = 0; i < sender.length; i++) {\n', '            transferWRD(address(this), sender[i], amount[i]);\n', '            //send as presaletoken\n', '            presaleTokens[sender[i]] = presaleTokens[sender[i]].add(amount[i]);\n', '            totalAirdropTokens = totalAirdropTokens.add(amount[i]);\n', '            emit Transfer(address(this), sender[i], amount[i]);\n', '        }\n', '    }\n', '\n', '    function addPresaleTokens(address[] calldata sender, uint256[] calldata amount) external onlyWhitelistAdmin {\n', '        require(sender.length > 0 && sender.length == amount.length);\n', '\n', '        for (uint i = 0; i < sender.length; i++) {\n', '            transferWRD(address(this), sender[i], amount[i]);\n', '            presaleTokens[sender[i]] = presaleTokens[sender[i]].add(amount[i]);\n', '            totalPresaleTokens = totalPresaleTokens.add(amount[i]);\n', '            emit Transfer(address(this), sender[i], amount[i]);\n', '        }\n', '    }\n', '\n', '    function addSpecialsaleTokens(address to, uint256 amount) external onlyWhitelisted {\n', '        transferWRD(msg.sender, to, amount);\n', '        presaleTokens[to] = presaleTokens[to].add(amount);\n', '        emit Transfer(msg.sender, to, amount);\n', '    }\n', '\n', '    function transferByAdmin(address from, uint256 amount) external onlyWhitelistAdmin {\n', '        transferWRD(from, msg.sender, amount);\n', '        emit Transfer(from, msg.sender, amount);\n', '    }\n', '}']