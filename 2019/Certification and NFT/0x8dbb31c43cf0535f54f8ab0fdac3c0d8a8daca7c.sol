['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/WhitelistableConstraints.sol\n', '\n', '/**\n', ' * @title WhitelistableConstraints\n', ' * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\n', ' */\n', 'contract WhitelistableConstraints {\n', '\n', '    /**\n', '     * @dev Check if whitelist with specified parameters is allowed.\n', '     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\n', '     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\n', '     * @return true if whitelist with specified parameters is allowed, false otherwise\n', '     */\n', '    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\n', '        public pure returns(bool isReallyAllowedWhitelist) {\n', '        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev Base contract implementing a whitelist to keep track of investors.\n', ' * The construction parameters allow for both whitelisted and non-whitelisted contracts:\n', ' * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\n', ' * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\n', ' * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\n', ' */\n', 'contract Whitelistable is WhitelistableConstraints {\n', '\n', '    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\n', '    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\n', '    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\n', '    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\n', '\n', '    mapping (address => bool) public whitelist;\n', '\n', '    uint256 public whitelistLength;\n', '\n', '    uint256 public maxWhitelistLength;\n', '\n', '    uint256 public whitelistThresholdBalance;\n', '\n', '    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), "parameters not allowed");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '    }\n', '\n', '    /**\n', '     * @return true if whitelist is currently enabled, false otherwise\n', '     */\n', '    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\n', '        return maxWhitelistLength > 0;\n', '    }\n', '\n', '    /**\n', '     * @return true if subscriber is whitelisted, false otherwise\n', '     */\n', '    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\n', '        return whitelist[_subscriber];\n', '    }\n', '\n', '    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\n', '            "_maxWhitelistLength not allowed");\n', '        require(_maxWhitelistLength != maxWhitelistLength, "_maxWhitelistLength equal to current one");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '\n', '        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\n', '    }\n', '\n', '    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\n', '            "_whitelistThresholdBalance not allowed");\n', '        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\n', '            "_whitelistThresholdBalance not greater than current one");\n', '\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '\n', '        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\n', '    }\n', '\n', '    function addToWhitelistInternal(address _subscriber) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(!whitelist[_subscriber], "already whitelisted");\n', '        require(whitelistLength < maxWhitelistLength, "max whitelist length reached");\n', '\n', '        whitelistLength++;\n', '\n', '        whitelist[_subscriber] = true;\n', '\n', '        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\n', '    }\n', '\n', '    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(whitelist[_subscriber], "not whitelisted");\n', '        require(_balance <= whitelistThresholdBalance, "_balance greater than whitelist threshold");\n', '\n', '        assert(whitelistLength > 0);\n', '\n', '        whitelistLength--;\n', '\n', '        whitelist[_subscriber] = false;\n', '\n', '        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\n', '    }\n', '\n', '    /**\n', '     * @param _subscriber The subscriber for which the balance check is required.\n', '     * @param _balance The balance value to check for allowance.\n', '     * @return true if the balance is allowed for the subscriber, false otherwise\n', '     */\n', '    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\n', '        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/Presale.sol\n', '\n', '/**\n', ' * @title Presale\n', ' * @dev A simple Presale Contract (PsC) for deposit collection during pre-sale events.\n', ' */\n', 'contract Presale is Whitelistable, Pausable {\n', '    using AddressUtils for address;\n', '    using SafeMath for uint256;\n', '\n', '    event LogCreated(\n', '        address caller,\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 minDeposit,\n', '        address wallet,\n', '        address indexed providerWallet,\n', '        uint256 maxWhitelistLength,\n', '        uint256 whitelistThreshold\n', '    );\n', '    event LogMinDepositChanged(address indexed caller, uint256 indexed minDeposit);\n', '    event LogInvestmentReceived(\n', '        address indexed caller,\n', '        address indexed beneficiary,\n', '        uint256 indexed amount,\n', '        uint256 netAmount\n', '    );\n', '    event LogPresaleTokenChanged(\n', '        address indexed caller,\n', '        address indexed presaleToken,\n', '        uint256 indexed rate\n', '    );\n', '\n', '    // The start and end block where investments are allowed (both inclusive)\n', '    uint256 public startBlock;\n', '    uint256 public endBlock;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // Presale minimum deposit in wei\n', '    uint256 public minDeposit;\n', '\n', '    // Presale balances (expressed in wei) deposited by each subscriber\n', '    mapping (address => uint256) public balanceOf;\n', '    \n', '    // Amount of raised money in wei\n', '    uint256 public raisedFunds;\n', '\n', '    // Amount of service provider fees in wei\n', '    uint256 public providerFees;\n', '\n', '    // Address where service provider fees are collected\n', '    address public providerWallet;\n', '\n', '    // Two fee thresholds separating the raised money into three partitions\n', '    uint256 public feeThreshold1;\n', '    uint256 public feeThreshold2;\n', '\n', '    // Three percentage levels for fee calculation in each partition\n', '    uint256 public lowFeePercentage;\n', '    uint256 public mediumFeePercentage;\n', '    uint256 public highFeePercentage;\n', '\n', '    // Optional ERC20 presale token (0 means no presale token)\n', '    MintableToken public presaleToken;\n', '\n', '    // How many ERC20 presale token units a buyer gets per wei (0 means no presale token)\n', '    uint256 public rate;\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage\n', '    )\n', '    Whitelistable(_maxWhitelistLength, _whitelistThreshold)\n', '    public\n', '    {\n', '        require(_startBlock >= block.number, "_startBlock is lower than current block number");\n', '        require(_endBlock >= _startBlock, "_endBlock is lower than _startBlock");\n', '        require(_minDeposit > 0, "_minDeposit is zero");\n', '        require(_wallet != address(0) && !_wallet.isContract(), "_wallet is zero or contract");\n', '        require(!_providerWallet.isContract(), "_providerWallet is contract");\n', '        require(_feeThreshold2 >= _feeThreshold1, "_feeThreshold2 is lower than _feeThreshold1");\n', '        require(0 <= _lowFeePercentage && _lowFeePercentage <= 100, "_lowFeePercentage not in range [0, 100]");\n', '        require(0 <= _mediumFeePercentage && _mediumFeePercentage <= 100, "_mediumFeePercentage not in range [0, 100]");\n', '        require(0 <= _highFeePercentage && _highFeePercentage <= 100, "_highFeePercentage not in range [0, 100]");\n', '\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '        minDeposit = _minDeposit;\n', '        wallet = _wallet;\n', '        providerWallet = _providerWallet;\n', '        feeThreshold1 = _feeThreshold1;\n', '        feeThreshold2 = _feeThreshold2;\n', '        lowFeePercentage = _lowFeePercentage;\n', '        mediumFeePercentage = _mediumFeePercentage;\n', '        highFeePercentage = _highFeePercentage;\n', '\n', '        emit LogCreated(\n', '            msg.sender,\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '\n', '    function hasStarted() public view returns (bool ended) {\n', '        return block.number >= startBlock;\n', '    }\n', '\n', '    // @return true if presale event has ended\n', '    function hasEnded() public view returns (bool ended) {\n', '        return block.number > endBlock;\n', '    }\n', '\n', '    // @return The current fee percentage based on raised funds\n', '    function currentFeePercentage() public view returns (uint256 feePercentage) {\n', '        return raisedFunds < feeThreshold1 ? lowFeePercentage :\n', '            raisedFunds < feeThreshold2 ? mediumFeePercentage : highFeePercentage;\n', '    }\n', '\n', '    /**\n', '     * Change the minimum deposit for each subscriber. New value shall be lower than previous.\n', '     * @param _minDeposit The minimum deposit for each subscriber, expressed in wei\n', '     */\n', '    function setMinDeposit(uint256 _minDeposit) external onlyOwner {\n', '        require(0 < _minDeposit && _minDeposit < minDeposit, "_minDeposit not in range [0, minDeposit]");\n', '        require(!hasEnded(), "presale has ended");\n', '\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMinDepositChanged(msg.sender, _minDeposit);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _maxWhitelistLength The maximum whitelist length\n', '     */\n', '    function setMaxWhitelistLength(uint256 _maxWhitelistLength) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        setMaxWhitelistLengthInternal(_maxWhitelistLength);\n', '    }\n', '\n', '    /**\n', '     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\n', '     */\n', '    function setWhitelistThresholdBalance(uint256 _whitelistThreshold) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        setWhitelistThresholdBalanceInternal(_whitelistThreshold);\n', '    }\n', '\n', '    /**\n', '     * Add the subscriber to the whitelist.\n', '     * @param _subscriber The subscriber to add to the whitelist.\n', '     */\n', '    function addToWhitelist(address _subscriber) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        addToWhitelistInternal(_subscriber);\n', '    }\n', '\n', '    /**\n', '     * Removed the subscriber from the whitelist.\n', '     * @param _subscriber The subscriber to remove from the whitelist.\n', '     */\n', '    function removeFromWhitelist(address _subscriber) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        removeFromWhitelistInternal(_subscriber, balanceOf[_subscriber]);\n', '    }\n', '\n', '    /**\n', '     * Set the ERC20 presale token address and conversion rate.\n', '     * @param _presaleToken The ERC20 presale token.\n', '     * @param _rate How many ERC20 presale token units a buyer gets per wei.\n', '     */\n', '    function setPresaleToken(MintableToken _presaleToken, uint256 _rate) external onlyOwner {\n', '        require(_presaleToken != presaleToken || _rate != rate, "both _presaleToken and _rate equal to current ones");\n', '        require(!hasEnded(), "presale has ended");\n', '\n', '        presaleToken = _presaleToken;\n', '        rate = _rate;\n', '\n', '        emit LogPresaleTokenChanged(msg.sender, _presaleToken, _rate);\n', '    }\n', '\n', '    function isAllowedBalance(address _beneficiary, uint256 _balance) public view returns (bool isReallyAllowed) {\n', '        bool hasMinimumBalance = _balance >= minDeposit;\n', '        return hasMinimumBalance && super.isAllowedBalance(_beneficiary, _balance);\n', '    }\n', '\n', '    function isValidInvestment(address _beneficiary, uint256 _amount) public view returns (bool isValid) {\n', '        bool withinPeriod = startBlock <= block.number && block.number <= endBlock;\n', '        bool nonZeroPurchase = _amount != 0;\n', '        bool isAllowedAmount = isAllowedBalance(_beneficiary, balanceOf[_beneficiary].add(_amount));\n', '\n', '        return withinPeriod && nonZeroPurchase && isAllowedAmount;\n', '    }\n', '\n', '    function invest(address _beneficiary) public payable whenNotPaused {\n', '        require(_beneficiary != address(0), "_beneficiary is zero");\n', '        require(_beneficiary != wallet, "_beneficiary is equal to wallet");\n', '        require(_beneficiary != providerWallet, "_beneficiary is equal to providerWallet");\n', '        require(isValidInvestment(_beneficiary, msg.value), "forbidden investment for _beneficiary");\n', '\n', '        balanceOf[_beneficiary] = balanceOf[_beneficiary].add(msg.value);\n', '        raisedFunds = raisedFunds.add(msg.value);\n', '\n', '        // Optionally distribute presale token to buyer, if configured\n', '        if (presaleToken != address(0) && rate != 0) {\n', '            uint256 tokenAmount = msg.value.mul(rate);\n', '            presaleToken.mint(_beneficiary, tokenAmount);\n', '        }\n', '\n', '        if (providerWallet == 0) {\n', '            wallet.transfer(msg.value);\n', '\n', '            emit LogInvestmentReceived(msg.sender, _beneficiary, msg.value, msg.value);\n', '        }\n', '        else {\n', '            uint256 feePercentage = currentFeePercentage();\n', '            uint256 fees = msg.value.mul(feePercentage).div(100);\n', '            uint256 netAmount = msg.value.sub(fees);\n', '\n', '            providerFees = providerFees.add(fees);\n', '\n', '            providerWallet.transfer(fees);\n', '            wallet.transfer(netAmount);\n', '\n', '            emit LogInvestmentReceived(msg.sender, _beneficiary, msg.value, netAmount);\n', '        }\n', '    }\n', '\n', '    function () external payable whenNotPaused {\n', '        invest(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/CappedPresale.sol\n', '\n', '/**\n', ' * @title CappedPresale\n', ' * @dev Extension of Presale with a max amount of funds raised\n', ' */\n', 'contract CappedPresale is Presale {\n', '    using SafeMath for uint256;\n', '\n', '    event LogMaxCapChanged(address indexed caller, uint256 indexed maxCap);\n', '\n', '    // Maximum cap in wei\n', '    uint256 public maxCap;\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    Presale(\n', '        _startBlock,\n', '        _endBlock,\n', '        _minDeposit,\n', '        _wallet,\n', '        _providerWallet,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold,\n', '        _feeThreshold1,\n', '        _feeThreshold2,\n', '        _lowFeePercentage,\n', '        _mediumFeePercentage,\n', '        _highFeePercentage\n', '    )\n', '    public\n', '    {\n', '        require(_maxCap > 0, "_maxCap is zero");\n', '        require(_maxCap >= _feeThreshold2, "_maxCap is lower than _feeThreshold2");\n', '        \n', '        maxCap = _maxCap;\n', '    }\n', '\n', '    /**\n', '     * Change the maximum cap of the presale. New value shall be greater than previous one.\n', '     * @param _maxCap The maximum cap of the presale, expressed in wei\n', '     */\n', '    function setMaxCap(uint256 _maxCap) external onlyOwner {\n', '        require(_maxCap > maxCap, "_maxCap is not greater than current maxCap");\n', '        require(!hasEnded(), "presale has ended");\n', '        \n', '        maxCap = _maxCap;\n', '\n', '        emit LogMaxCapChanged(msg.sender, _maxCap);\n', '    }\n', '\n', '    // overriding Presale#hasEnded to add cap logic\n', '    // @return true if presale event has ended\n', '    function hasEnded() public view returns (bool ended) {\n', '        bool capReached = raisedFunds >= maxCap;\n', '        \n', '        return super.hasEnded() || capReached;\n', '    }\n', '\n', '    // overriding Presale#isValidInvestment to add extra cap logic\n', '    // @return true if beneficiary can buy at the moment\n', '    function isValidInvestment(address _beneficiary, uint256 _amount) public view returns (bool isValid) {\n', '        bool withinCap = raisedFunds.add(_amount) <= maxCap;\n', '\n', '        return super.isValidInvestment(_beneficiary, _amount) && withinCap;\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomPresale.sol\n', '\n', '/**\n', ' * @title NokuCustomPresale\n', ' * @dev Extension of CappedPresale.\n', ' */\n', 'contract NokuCustomPresale is CappedPresale {\n', '    event LogNokuCustomPresaleCreated(\n', '        address caller,\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 minDeposit,\n', '        address wallet,\n', '        address indexed providerWallet,\n', '        uint256 maxWhitelistLength,\n', '        uint256 whitelistThreshold\n', '    );\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    CappedPresale(\n', '        _startBlock,\n', '        _endBlock,\n', '        _minDeposit,\n', '        _wallet,\n', '        _providerWallet,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold,\n', '        _feeThreshold1,\n', '        _feeThreshold2,\n', '        _lowFeePercentage,\n', '        _mediumFeePercentage,\n', '        _highFeePercentage,\n', '        _maxCap\n', '    )\n', '    public {\n', '        emit LogNokuCustomPresaleCreated(\n', '            msg.sender,\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/NokuPricingPlan.sol\n', '\n', '/**\n', '* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\n', '*/\n', 'contract NokuPricingPlan {\n', '    /**\n', '    * @dev Pay the fee for the service identified by the specified name.\n', '    * The fee amount shall already be approved by the client.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @param client The client of the target service.\n', '    * @return true if fee has been paid.\n', '    */\n', '    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n', '\n', '    /**\n', '    * @dev Get the usage fee for the service identified by the specified name.\n', '    * The returned fee amount shall be approved before using #payFee method.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @return The amount to approve before really paying such fee.\n', '    */\n', '    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n', '}\n', '\n', '// File: contracts/NokuCustomService.sol\n', '\n', 'contract NokuCustomService is Pausable {\n', '    using AddressUtils for address;\n', '\n', '    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n', '\n', '    // The pricing plan determining the fee to be paid in NOKU tokens by customers\n', '    NokuPricingPlan public pricingPlan;\n', '\n', '    constructor(address _pricingPlan) internal {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '\n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '    }\n', '\n', '    function setPricingPlan(address _pricingPlan) public onlyOwner {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '        require(NokuPricingPlan(_pricingPlan) != pricingPlan, "_pricingPlan equal to current");\n', '        \n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '\n', '        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomPresaleService.sol\n', '\n', '/**\n', ' * @title NokuCustomPresaleService\n', ' * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\n', ' */\n', 'contract NokuCustomPresaleService is NokuCustomService {\n', '    event LogNokuCustomPresaleServiceCreated(address indexed caller);\n', '\n', '    bytes32 public constant SERVICE_NAME = "NokuCustomERC20.presale";\n', '    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n', '\n', '    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n', '        emit LogNokuCustomPresaleServiceCreated(msg.sender);\n', '    }\n', '\n', '    function createCustomPresale(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    public returns(NokuCustomPresale customPresale)\n', '    {\n', '        customPresale = new NokuCustomPresale(\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold,\n', '            _feeThreshold1,\n', '            _feeThreshold2,\n', '            _lowFeePercentage,\n', '            _mediumFeePercentage,\n', '            _highFeePercentage,\n', '            _maxCap\n', '        );\n', '\n', '        // Transfer NokuCustomPresale ownership to the client\n', '        customPresale.transferOwnership(msg.sender);\n', '\n', '        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/WhitelistableConstraints.sol\n', '\n', '/**\n', ' * @title WhitelistableConstraints\n', ' * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\n', ' */\n', 'contract WhitelistableConstraints {\n', '\n', '    /**\n', '     * @dev Check if whitelist with specified parameters is allowed.\n', '     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\n', '     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\n', '     * @return true if whitelist with specified parameters is allowed, false otherwise\n', '     */\n', '    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\n', '        public pure returns(bool isReallyAllowedWhitelist) {\n', '        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev Base contract implementing a whitelist to keep track of investors.\n', ' * The construction parameters allow for both whitelisted and non-whitelisted contracts:\n', ' * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\n', ' * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\n', ' * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\n', ' */\n', 'contract Whitelistable is WhitelistableConstraints {\n', '\n', '    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\n', '    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\n', '    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\n', '    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\n', '\n', '    mapping (address => bool) public whitelist;\n', '\n', '    uint256 public whitelistLength;\n', '\n', '    uint256 public maxWhitelistLength;\n', '\n', '    uint256 public whitelistThresholdBalance;\n', '\n', '    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), "parameters not allowed");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '    }\n', '\n', '    /**\n', '     * @return true if whitelist is currently enabled, false otherwise\n', '     */\n', '    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\n', '        return maxWhitelistLength > 0;\n', '    }\n', '\n', '    /**\n', '     * @return true if subscriber is whitelisted, false otherwise\n', '     */\n', '    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\n', '        return whitelist[_subscriber];\n', '    }\n', '\n', '    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\n', '            "_maxWhitelistLength not allowed");\n', '        require(_maxWhitelistLength != maxWhitelistLength, "_maxWhitelistLength equal to current one");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '\n', '        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\n', '    }\n', '\n', '    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\n', '            "_whitelistThresholdBalance not allowed");\n', '        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\n', '            "_whitelistThresholdBalance not greater than current one");\n', '\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '\n', '        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\n', '    }\n', '\n', '    function addToWhitelistInternal(address _subscriber) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(!whitelist[_subscriber], "already whitelisted");\n', '        require(whitelistLength < maxWhitelistLength, "max whitelist length reached");\n', '\n', '        whitelistLength++;\n', '\n', '        whitelist[_subscriber] = true;\n', '\n', '        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\n', '    }\n', '\n', '    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(whitelist[_subscriber], "not whitelisted");\n', '        require(_balance <= whitelistThresholdBalance, "_balance greater than whitelist threshold");\n', '\n', '        assert(whitelistLength > 0);\n', '\n', '        whitelistLength--;\n', '\n', '        whitelist[_subscriber] = false;\n', '\n', '        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\n', '    }\n', '\n', '    /**\n', '     * @param _subscriber The subscriber for which the balance check is required.\n', '     * @param _balance The balance value to check for allowance.\n', '     * @return true if the balance is allowed for the subscriber, false otherwise\n', '     */\n', '    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\n', '        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/Presale.sol\n', '\n', '/**\n', ' * @title Presale\n', ' * @dev A simple Presale Contract (PsC) for deposit collection during pre-sale events.\n', ' */\n', 'contract Presale is Whitelistable, Pausable {\n', '    using AddressUtils for address;\n', '    using SafeMath for uint256;\n', '\n', '    event LogCreated(\n', '        address caller,\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 minDeposit,\n', '        address wallet,\n', '        address indexed providerWallet,\n', '        uint256 maxWhitelistLength,\n', '        uint256 whitelistThreshold\n', '    );\n', '    event LogMinDepositChanged(address indexed caller, uint256 indexed minDeposit);\n', '    event LogInvestmentReceived(\n', '        address indexed caller,\n', '        address indexed beneficiary,\n', '        uint256 indexed amount,\n', '        uint256 netAmount\n', '    );\n', '    event LogPresaleTokenChanged(\n', '        address indexed caller,\n', '        address indexed presaleToken,\n', '        uint256 indexed rate\n', '    );\n', '\n', '    // The start and end block where investments are allowed (both inclusive)\n', '    uint256 public startBlock;\n', '    uint256 public endBlock;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // Presale minimum deposit in wei\n', '    uint256 public minDeposit;\n', '\n', '    // Presale balances (expressed in wei) deposited by each subscriber\n', '    mapping (address => uint256) public balanceOf;\n', '    \n', '    // Amount of raised money in wei\n', '    uint256 public raisedFunds;\n', '\n', '    // Amount of service provider fees in wei\n', '    uint256 public providerFees;\n', '\n', '    // Address where service provider fees are collected\n', '    address public providerWallet;\n', '\n', '    // Two fee thresholds separating the raised money into three partitions\n', '    uint256 public feeThreshold1;\n', '    uint256 public feeThreshold2;\n', '\n', '    // Three percentage levels for fee calculation in each partition\n', '    uint256 public lowFeePercentage;\n', '    uint256 public mediumFeePercentage;\n', '    uint256 public highFeePercentage;\n', '\n', '    // Optional ERC20 presale token (0 means no presale token)\n', '    MintableToken public presaleToken;\n', '\n', '    // How many ERC20 presale token units a buyer gets per wei (0 means no presale token)\n', '    uint256 public rate;\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage\n', '    )\n', '    Whitelistable(_maxWhitelistLength, _whitelistThreshold)\n', '    public\n', '    {\n', '        require(_startBlock >= block.number, "_startBlock is lower than current block number");\n', '        require(_endBlock >= _startBlock, "_endBlock is lower than _startBlock");\n', '        require(_minDeposit > 0, "_minDeposit is zero");\n', '        require(_wallet != address(0) && !_wallet.isContract(), "_wallet is zero or contract");\n', '        require(!_providerWallet.isContract(), "_providerWallet is contract");\n', '        require(_feeThreshold2 >= _feeThreshold1, "_feeThreshold2 is lower than _feeThreshold1");\n', '        require(0 <= _lowFeePercentage && _lowFeePercentage <= 100, "_lowFeePercentage not in range [0, 100]");\n', '        require(0 <= _mediumFeePercentage && _mediumFeePercentage <= 100, "_mediumFeePercentage not in range [0, 100]");\n', '        require(0 <= _highFeePercentage && _highFeePercentage <= 100, "_highFeePercentage not in range [0, 100]");\n', '\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '        minDeposit = _minDeposit;\n', '        wallet = _wallet;\n', '        providerWallet = _providerWallet;\n', '        feeThreshold1 = _feeThreshold1;\n', '        feeThreshold2 = _feeThreshold2;\n', '        lowFeePercentage = _lowFeePercentage;\n', '        mediumFeePercentage = _mediumFeePercentage;\n', '        highFeePercentage = _highFeePercentage;\n', '\n', '        emit LogCreated(\n', '            msg.sender,\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '\n', '    function hasStarted() public view returns (bool ended) {\n', '        return block.number >= startBlock;\n', '    }\n', '\n', '    // @return true if presale event has ended\n', '    function hasEnded() public view returns (bool ended) {\n', '        return block.number > endBlock;\n', '    }\n', '\n', '    // @return The current fee percentage based on raised funds\n', '    function currentFeePercentage() public view returns (uint256 feePercentage) {\n', '        return raisedFunds < feeThreshold1 ? lowFeePercentage :\n', '            raisedFunds < feeThreshold2 ? mediumFeePercentage : highFeePercentage;\n', '    }\n', '\n', '    /**\n', '     * Change the minimum deposit for each subscriber. New value shall be lower than previous.\n', '     * @param _minDeposit The minimum deposit for each subscriber, expressed in wei\n', '     */\n', '    function setMinDeposit(uint256 _minDeposit) external onlyOwner {\n', '        require(0 < _minDeposit && _minDeposit < minDeposit, "_minDeposit not in range [0, minDeposit]");\n', '        require(!hasEnded(), "presale has ended");\n', '\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMinDepositChanged(msg.sender, _minDeposit);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _maxWhitelistLength The maximum whitelist length\n', '     */\n', '    function setMaxWhitelistLength(uint256 _maxWhitelistLength) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        setMaxWhitelistLengthInternal(_maxWhitelistLength);\n', '    }\n', '\n', '    /**\n', '     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\n', '     */\n', '    function setWhitelistThresholdBalance(uint256 _whitelistThreshold) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        setWhitelistThresholdBalanceInternal(_whitelistThreshold);\n', '    }\n', '\n', '    /**\n', '     * Add the subscriber to the whitelist.\n', '     * @param _subscriber The subscriber to add to the whitelist.\n', '     */\n', '    function addToWhitelist(address _subscriber) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        addToWhitelistInternal(_subscriber);\n', '    }\n', '\n', '    /**\n', '     * Removed the subscriber from the whitelist.\n', '     * @param _subscriber The subscriber to remove from the whitelist.\n', '     */\n', '    function removeFromWhitelist(address _subscriber) external onlyOwner {\n', '        require(!hasEnded(), "presale has ended");\n', '        removeFromWhitelistInternal(_subscriber, balanceOf[_subscriber]);\n', '    }\n', '\n', '    /**\n', '     * Set the ERC20 presale token address and conversion rate.\n', '     * @param _presaleToken The ERC20 presale token.\n', '     * @param _rate How many ERC20 presale token units a buyer gets per wei.\n', '     */\n', '    function setPresaleToken(MintableToken _presaleToken, uint256 _rate) external onlyOwner {\n', '        require(_presaleToken != presaleToken || _rate != rate, "both _presaleToken and _rate equal to current ones");\n', '        require(!hasEnded(), "presale has ended");\n', '\n', '        presaleToken = _presaleToken;\n', '        rate = _rate;\n', '\n', '        emit LogPresaleTokenChanged(msg.sender, _presaleToken, _rate);\n', '    }\n', '\n', '    function isAllowedBalance(address _beneficiary, uint256 _balance) public view returns (bool isReallyAllowed) {\n', '        bool hasMinimumBalance = _balance >= minDeposit;\n', '        return hasMinimumBalance && super.isAllowedBalance(_beneficiary, _balance);\n', '    }\n', '\n', '    function isValidInvestment(address _beneficiary, uint256 _amount) public view returns (bool isValid) {\n', '        bool withinPeriod = startBlock <= block.number && block.number <= endBlock;\n', '        bool nonZeroPurchase = _amount != 0;\n', '        bool isAllowedAmount = isAllowedBalance(_beneficiary, balanceOf[_beneficiary].add(_amount));\n', '\n', '        return withinPeriod && nonZeroPurchase && isAllowedAmount;\n', '    }\n', '\n', '    function invest(address _beneficiary) public payable whenNotPaused {\n', '        require(_beneficiary != address(0), "_beneficiary is zero");\n', '        require(_beneficiary != wallet, "_beneficiary is equal to wallet");\n', '        require(_beneficiary != providerWallet, "_beneficiary is equal to providerWallet");\n', '        require(isValidInvestment(_beneficiary, msg.value), "forbidden investment for _beneficiary");\n', '\n', '        balanceOf[_beneficiary] = balanceOf[_beneficiary].add(msg.value);\n', '        raisedFunds = raisedFunds.add(msg.value);\n', '\n', '        // Optionally distribute presale token to buyer, if configured\n', '        if (presaleToken != address(0) && rate != 0) {\n', '            uint256 tokenAmount = msg.value.mul(rate);\n', '            presaleToken.mint(_beneficiary, tokenAmount);\n', '        }\n', '\n', '        if (providerWallet == 0) {\n', '            wallet.transfer(msg.value);\n', '\n', '            emit LogInvestmentReceived(msg.sender, _beneficiary, msg.value, msg.value);\n', '        }\n', '        else {\n', '            uint256 feePercentage = currentFeePercentage();\n', '            uint256 fees = msg.value.mul(feePercentage).div(100);\n', '            uint256 netAmount = msg.value.sub(fees);\n', '\n', '            providerFees = providerFees.add(fees);\n', '\n', '            providerWallet.transfer(fees);\n', '            wallet.transfer(netAmount);\n', '\n', '            emit LogInvestmentReceived(msg.sender, _beneficiary, msg.value, netAmount);\n', '        }\n', '    }\n', '\n', '    function () external payable whenNotPaused {\n', '        invest(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/CappedPresale.sol\n', '\n', '/**\n', ' * @title CappedPresale\n', ' * @dev Extension of Presale with a max amount of funds raised\n', ' */\n', 'contract CappedPresale is Presale {\n', '    using SafeMath for uint256;\n', '\n', '    event LogMaxCapChanged(address indexed caller, uint256 indexed maxCap);\n', '\n', '    // Maximum cap in wei\n', '    uint256 public maxCap;\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    Presale(\n', '        _startBlock,\n', '        _endBlock,\n', '        _minDeposit,\n', '        _wallet,\n', '        _providerWallet,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold,\n', '        _feeThreshold1,\n', '        _feeThreshold2,\n', '        _lowFeePercentage,\n', '        _mediumFeePercentage,\n', '        _highFeePercentage\n', '    )\n', '    public\n', '    {\n', '        require(_maxCap > 0, "_maxCap is zero");\n', '        require(_maxCap >= _feeThreshold2, "_maxCap is lower than _feeThreshold2");\n', '        \n', '        maxCap = _maxCap;\n', '    }\n', '\n', '    /**\n', '     * Change the maximum cap of the presale. New value shall be greater than previous one.\n', '     * @param _maxCap The maximum cap of the presale, expressed in wei\n', '     */\n', '    function setMaxCap(uint256 _maxCap) external onlyOwner {\n', '        require(_maxCap > maxCap, "_maxCap is not greater than current maxCap");\n', '        require(!hasEnded(), "presale has ended");\n', '        \n', '        maxCap = _maxCap;\n', '\n', '        emit LogMaxCapChanged(msg.sender, _maxCap);\n', '    }\n', '\n', '    // overriding Presale#hasEnded to add cap logic\n', '    // @return true if presale event has ended\n', '    function hasEnded() public view returns (bool ended) {\n', '        bool capReached = raisedFunds >= maxCap;\n', '        \n', '        return super.hasEnded() || capReached;\n', '    }\n', '\n', '    // overriding Presale#isValidInvestment to add extra cap logic\n', '    // @return true if beneficiary can buy at the moment\n', '    function isValidInvestment(address _beneficiary, uint256 _amount) public view returns (bool isValid) {\n', '        bool withinCap = raisedFunds.add(_amount) <= maxCap;\n', '\n', '        return super.isValidInvestment(_beneficiary, _amount) && withinCap;\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomPresale.sol\n', '\n', '/**\n', ' * @title NokuCustomPresale\n', ' * @dev Extension of CappedPresale.\n', ' */\n', 'contract NokuCustomPresale is CappedPresale {\n', '    event LogNokuCustomPresaleCreated(\n', '        address caller,\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 minDeposit,\n', '        address wallet,\n', '        address indexed providerWallet,\n', '        uint256 maxWhitelistLength,\n', '        uint256 whitelistThreshold\n', '    );\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    CappedPresale(\n', '        _startBlock,\n', '        _endBlock,\n', '        _minDeposit,\n', '        _wallet,\n', '        _providerWallet,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold,\n', '        _feeThreshold1,\n', '        _feeThreshold2,\n', '        _lowFeePercentage,\n', '        _mediumFeePercentage,\n', '        _highFeePercentage,\n', '        _maxCap\n', '    )\n', '    public {\n', '        emit LogNokuCustomPresaleCreated(\n', '            msg.sender,\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/NokuPricingPlan.sol\n', '\n', '/**\n', '* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\n', '*/\n', 'contract NokuPricingPlan {\n', '    /**\n', '    * @dev Pay the fee for the service identified by the specified name.\n', '    * The fee amount shall already be approved by the client.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @param client The client of the target service.\n', '    * @return true if fee has been paid.\n', '    */\n', '    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n', '\n', '    /**\n', '    * @dev Get the usage fee for the service identified by the specified name.\n', '    * The returned fee amount shall be approved before using #payFee method.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @return The amount to approve before really paying such fee.\n', '    */\n', '    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n', '}\n', '\n', '// File: contracts/NokuCustomService.sol\n', '\n', 'contract NokuCustomService is Pausable {\n', '    using AddressUtils for address;\n', '\n', '    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n', '\n', '    // The pricing plan determining the fee to be paid in NOKU tokens by customers\n', '    NokuPricingPlan public pricingPlan;\n', '\n', '    constructor(address _pricingPlan) internal {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '\n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '    }\n', '\n', '    function setPricingPlan(address _pricingPlan) public onlyOwner {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '        require(NokuPricingPlan(_pricingPlan) != pricingPlan, "_pricingPlan equal to current");\n', '        \n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '\n', '        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomPresaleService.sol\n', '\n', '/**\n', ' * @title NokuCustomPresaleService\n', ' * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\n', ' */\n', 'contract NokuCustomPresaleService is NokuCustomService {\n', '    event LogNokuCustomPresaleServiceCreated(address indexed caller);\n', '\n', '    bytes32 public constant SERVICE_NAME = "NokuCustomERC20.presale";\n', '    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n', '\n', '    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n', '        emit LogNokuCustomPresaleServiceCreated(msg.sender);\n', '    }\n', '\n', '    function createCustomPresale(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _minDeposit,\n', '        address _wallet,\n', '        address _providerWallet,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold,\n', '        uint256 _feeThreshold1,\n', '        uint256 _feeThreshold2,\n', '        uint256 _lowFeePercentage,\n', '        uint256 _mediumFeePercentage,\n', '        uint256 _highFeePercentage,\n', '        uint256 _maxCap\n', '    )\n', '    public returns(NokuCustomPresale customPresale)\n', '    {\n', '        customPresale = new NokuCustomPresale(\n', '            _startBlock,\n', '            _endBlock,\n', '            _minDeposit,\n', '            _wallet,\n', '            _providerWallet,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold,\n', '            _feeThreshold1,\n', '            _feeThreshold2,\n', '            _lowFeePercentage,\n', '            _mediumFeePercentage,\n', '            _highFeePercentage,\n', '            _maxCap\n', '        );\n', '\n', '        // Transfer NokuCustomPresale ownership to the client\n', '        customPresale.transferOwnership(msg.sender);\n', '\n', '        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");\n', '    }\n', '}']
