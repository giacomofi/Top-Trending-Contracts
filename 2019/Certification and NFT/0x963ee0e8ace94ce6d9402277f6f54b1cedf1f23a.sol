['pragma solidity ^0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: contracts/lib/ERC20SafeTransfer.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ERC20SafeTransfer {\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value)\n', '    internal\n', '    returns (bool success)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (success, ) = token.call(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value)\n', '    internal\n', '    returns (bool success)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (success, ) = token.call(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lib/LibBytes.sol\n', '\n', '// Modified from 0x LibBytes\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'library LibBytes {\n', '\n', '    using LibBytes for bytes;\n', '\n', '    /// @dev Gets the memory address for the contents of a byte array.\n', '    /// @param input Byte array to lookup.\n', '    /// @return memoryAddress Memory address of the contents of the byte array.\n', '    function contentAddress(bytes memory input)\n', '    internal\n', '    pure\n', '    returns (uint256 memoryAddress)\n', '    {\n', '        assembly {\n', '            memoryAddress := add(input, 32)\n', '        }\n', '        return memoryAddress;\n', '    }\n', '\n', '    /// @dev Copies `length` bytes from memory location `source` to `dest`.\n', '    /// @param dest memory address to copy bytes to.\n', '    /// @param source memory address to copy bytes from.\n', '    /// @param length number of bytes to copy.\n', '    function memCopy(\n', '        uint256 dest,\n', '        uint256 source,\n', '        uint256 length\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (length < 32) {\n', '            // Handle a partial word by reading destination and masking\n', '            // off the bits we are interested in.\n', '            // This correctly handles overlap, zero lengths and source == dest\n', '            assembly {\n', '                let mask := sub(exp(256, sub(32, length)), 1)\n', '                let s := and(mload(source), not(mask))\n', '                let d := and(mload(dest), mask)\n', '                mstore(dest, or(s, d))\n', '            }\n', '        } else {\n', '            // Skip the O(length) loop when source == dest.\n', '            if (source == dest) {\n', '                return;\n', '            }\n', '\n', '            // For large copies we copy whole words at a time. The final\n', '            // word is aligned to the end of the range (instead of after the\n', '            // previous) to handle partial words. So a copy will look like this:\n', '            //\n', '            //  ####\n', '            //      ####\n', '            //          ####\n', '            //            ####\n', '            //\n', '            // We handle overlap in the source and destination range by\n', '            // changing the copying direction. This prevents us from\n', '            // overwriting parts of source that we still need to copy.\n', '            //\n', '            // This correctly handles source == dest\n', '            //\n', '            if (source > dest) {\n', '                assembly {\n', '                // We subtract 32 from `sEnd` and `dEnd` because it\n', '                // is easier to compare with in the loop, and these\n', '                // are also the addresses we need for copying the\n', '                // last bytes.\n', '                    length := sub(length, 32)\n', '                    let sEnd := add(source, length)\n', '                    let dEnd := add(dest, length)\n', '\n', '                // Remember the last 32 bytes of source\n', '                // This needs to be done here and not after the loop\n', '                // because we may have overwritten the last bytes in\n', '                // source already due to overlap.\n', '                    let last := mload(sEnd)\n', '\n', '                // Copy whole words front to back\n', '                // Note: the first check is always true,\n', '                // this could have been a do-while loop.\n', '                // solhint-disable-next-line no-empty-blocks\n', '                    for {} lt(source, sEnd) {} {\n', '                        mstore(dest, mload(source))\n', '                        source := add(source, 32)\n', '                        dest := add(dest, 32)\n', '                    }\n', '\n', '                // Write the last 32 bytes\n', '                    mstore(dEnd, last)\n', '                }\n', '            } else {\n', '                assembly {\n', '                // We subtract 32 from `sEnd` and `dEnd` because those\n', '                // are the starting points when copying a word at the end.\n', '                    length := sub(length, 32)\n', '                    let sEnd := add(source, length)\n', '                    let dEnd := add(dest, length)\n', '\n', '                // Remember the first 32 bytes of source\n', '                // This needs to be done here and not after the loop\n', '                // because we may have overwritten the first bytes in\n', '                // source already due to overlap.\n', '                    let first := mload(source)\n', '\n', '                // Copy whole words back to front\n', '                // We use a signed comparisson here to allow dEnd to become\n', '                // negative (happens when source and dest < 32). Valid\n', '                // addresses in local memory will never be larger than\n', '                // 2**255, so they can be safely re-interpreted as signed.\n', '                // Note: the first check is always true,\n', '                // this could have been a do-while loop.\n', '                // solhint-disable-next-line no-empty-blocks\n', '                    for {} slt(dest, dEnd) {} {\n', '                        mstore(dEnd, mload(sEnd))\n', '                        sEnd := sub(sEnd, 32)\n', '                        dEnd := sub(dEnd, 32)\n', '                    }\n', '\n', '                // Write the first 32 bytes\n', '                    mstore(dest, first)\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Returns a slices from a byte array.\n', '    /// @param b The byte array to take a slice from.\n', '    /// @param from The starting index for the slice (inclusive).\n', '    /// @param to The final index for the slice (exclusive).\n', '    /// @return result The slice containing bytes at indices [from, to)\n', '    function slice(\n', '        bytes memory b,\n', '        uint256 from,\n', '        uint256 to\n', '    )\n', '    internal\n', '    pure\n', '    returns (bytes memory result)\n', '    {\n', '        if (from > to || to > b.length) {\n', '            return "";\n', '        }\n', '\n', '        // Create a new bytes structure and copy contents\n', '        result = new bytes(to - from);\n', '        memCopy(\n', '            result.contentAddress(),\n', '            b.contentAddress() + from,\n', '            result.length\n', '        );\n', '        return result;\n', '    }\n', '\n', '    /// @dev Reads an address from a position in a byte array.\n', '    /// @param b Byte array containing an address.\n', '    /// @param index Index in byte array of address.\n', '    /// @return address from byte array.\n', '    function readAddress(\n', '        bytes memory b,\n', '        uint256 index\n', '    )\n', '    internal\n', '    pure\n', '    returns (address result)\n', '    {\n', '        require(\n', '            b.length >= index + 20,  // 20 is length of address\n', '            "GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED"\n', '        );\n', '\n', '        // Add offset to index:\n', '        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n', '        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n', '        index += 20;\n', '\n', '        // Read address from array memory\n', '        assembly {\n', '        // 1. Add index to address of bytes array\n', '        // 2. Load 32-byte word from memory\n', '        // 3. Apply 20-byte mask to obtain address\n', '            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /// @dev Reads a bytes32 value from a position in a byte array.\n', '    /// @param b Byte array containing a bytes32 value.\n', '    /// @param index Index in byte array of bytes32 value.\n', '    /// @return bytes32 value from byte array.\n', '    function readBytes32(\n', '        bytes memory b,\n', '        uint256 index\n', '    )\n', '    internal\n', '    pure\n', '    returns (bytes32 result)\n', '    {\n', '        require(\n', '            b.length >= index + 32,\n', '            "GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED"\n', '        );\n', '\n', '        // Arrays are prefixed by a 256 bit length parameter\n', '        index += 32;\n', '\n', '        // Read the bytes32 from array memory\n', '        assembly {\n', '            result := mload(add(b, index))\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /// @dev Reads a uint256 value from a position in a byte array.\n', '    /// @param b Byte array containing a uint256 value.\n', '    /// @param index Index in byte array of uint256 value.\n', '    /// @return uint256 value from byte array.\n', '    function readUint256(\n', '        bytes memory b,\n', '        uint256 index\n', '    )\n', '    internal\n', '    pure\n', '    returns (uint256 result)\n', '    {\n', '        result = uint256(readBytes32(b, index));\n', '        return result;\n', '    }\n', '\n', '    /// @dev Reads an unpadded bytes4 value from a position in a byte array.\n', '    /// @param b Byte array containing a bytes4 value.\n', '    /// @param index Index in byte array of bytes4 value.\n', '    /// @return bytes4 value from byte array.\n', '    function readBytes4(\n', '        bytes memory b,\n', '        uint256 index\n', '    )\n', '    internal\n', '    pure\n', '    returns (bytes4 result)\n', '    {\n', '        require(\n', '            b.length >= index + 4,\n', '            "GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED"\n', '        );\n', '\n', '        // Arrays are prefixed by a 32 byte length field\n', '        index += 32;\n', '\n', '        // Read the bytes4 from array memory\n', '        assembly {\n', '            result := mload(add(b, index))\n', '        // Solidity does not require us to clean the trailing bytes.\n', '        // We do it anyway\n', '            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/LibMath.sol\n', '\n', 'contract LibMath {\n', '    // Copied from openzeppelin Math\n', '    /**\n', '    * @dev Returns the largest of two numbers.\n', '    */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the smallest of two numbers.\n', '    */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '    * @dev Calculates the average of two numbers. Since these are integers,\n', '    * averages of an even and odd number cannot be represented, and will be\n', '    * rounded down.\n', '    */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    // Modified from openzeppelin SafeMath\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '\n', '    // Copied from 0x LibMath\n', '    /*\n', '      Copyright 2018 ZeroEx Intl.\n', '      Licensed under the Apache License, Version 2.0 (the "License");\n', '      you may not use this file except in compliance with the License.\n', '      You may obtain a copy of the License at\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '      Unless required by applicable law or agreed to in writing, software\n', '      distributed under the License is distributed on an "AS IS" BASIS,\n', '      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '      See the License for the specific language governing permissions and\n', '      limitations under the License.\n', '    */\n', '    /// @dev Calculates partial value given a numerator and denominator rounded down.\n', '    ///      Reverts if rounding error is >= 0.1%\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target rounded down.\n', '    function safeGetPartialAmountFloor(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (uint256 partialAmount)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        require(\n', '            !isRoundingErrorFloor(\n', '            numerator,\n', '            denominator,\n', '            target\n', '        ),\n', '            "ROUNDING_ERROR"\n', '        );\n', '\n', '        partialAmount = div(\n', '            mul(numerator, target),\n', '            denominator\n', '        );\n', '        return partialAmount;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator rounded down.\n', '    ///      Reverts if rounding error is >= 0.1%\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target rounded up.\n', '    function safeGetPartialAmountCeil(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (uint256 partialAmount)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        require(\n', '            !isRoundingErrorCeil(\n', '            numerator,\n', '            denominator,\n', '            target\n', '        ),\n', '            "ROUNDING_ERROR"\n', '        );\n', '\n', '        partialAmount = div(\n', '            add(\n', '                mul(numerator, target),\n', '                sub(denominator, 1)\n', '            ),\n', '            denominator\n', '        );\n', '        return partialAmount;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator rounded down.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target rounded down.\n', '    function getPartialAmountFloor(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (uint256 partialAmount)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        partialAmount = div(\n', '            mul(numerator, target),\n', '            denominator\n', '        );\n', '        return partialAmount;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator rounded down.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target rounded up.\n', '    function getPartialAmountCeil(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (uint256 partialAmount)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        partialAmount = div(\n', '            add(\n', '                mul(numerator, target),\n', '                sub(denominator, 1)\n', '            ),\n', '            denominator\n', '        );\n', '        return partialAmount;\n', '    }\n', '\n', '    /// @dev Checks if rounding error >= 0.1% when rounding down.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingErrorFloor(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool isError)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        // The absolute rounding error is the difference between the rounded\n', '        // value and the ideal value. The relative rounding error is the\n', '        // absolute rounding error divided by the absolute value of the\n', '        // ideal value. This is undefined when the ideal value is zero.\n', '        //\n', '        // The ideal value is `numerator * target / denominator`.\n', "        // Let's call `numerator * target % denominator` the remainder.\n", '        // The absolute error is `remainder / denominator`.\n', '        //\n', '        // When the ideal value is zero, we require the absolute error to\n', '        // be zero. Fortunately, this is always the case. The ideal value is\n', '        // zero iff `numerator == 0` and/or `target == 0`. In this case the\n', '        // remainder and absolute error are also zero.\n', '        if (target == 0 || numerator == 0) {\n', '            return false;\n', '        }\n', '\n', '        // Otherwise, we want the relative rounding error to be strictly\n', '        // less than 0.1%.\n', '        // The relative error is `remainder / (numerator * target)`.\n', '        // We want the relative error less than 1 / 1000:\n', '        //        remainder / (numerator * denominator)  <  1 / 1000\n', '        // or equivalently:\n', '        //        1000 * remainder  <  numerator * target\n', '        // so we have a rounding error iff:\n', '        //        1000 * remainder  >=  numerator * target\n', '        uint256 remainder = mulmod(\n', '            target,\n', '            numerator,\n', '            denominator\n', '        );\n', '        isError = mul(1000, remainder) >= mul(numerator, target);\n', '        return isError;\n', '    }\n', '\n', '    /// @dev Checks if rounding error >= 0.1% when rounding up.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingErrorCeil(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '    internal\n', '    pure\n', '    returns (bool isError)\n', '    {\n', '        require(\n', '            denominator > 0,\n', '            "DIVISION_BY_ZERO"\n', '        );\n', '\n', '        // See the comments in `isRoundingError`.\n', '        if (target == 0 || numerator == 0) {\n', '            // When either is zero, the ideal value and rounded value are zero\n', '            // and there is no rounding error. (Although the relative error\n', '            // is undefined.)\n', '            return false;\n', '        }\n', '        // Compute remainder as before\n', '        uint256 remainder = mulmod(\n', '            target,\n', '            numerator,\n', '            denominator\n', '        );\n', '        remainder = sub(denominator, remainder) % denominator;\n', '        isError = mul(1000, remainder) >= mul(numerator, target);\n', '        return isError;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/router/IExchangeHandler.sol\n', '\n', '/// Interface of exchange handler.\n', 'interface IExchangeHandler {\n', '\n', '    /// Gets maximum available amount can be spent on order (fee not included).\n', '    /// @param data General order data.\n', '    /// @return availableToFill Amount can be spent on order.\n', '    /// @return feePercentage Fee percentage of order.\n', '    function getAvailableToFill(\n', '        bytes calldata data\n', '    )\n', '    external\n', '    view\n', '    returns (uint256 availableToFill, uint256 feePercentage);\n', '\n', '    /// Fills an order on the target exchange.\n', '    /// NOTE: The required funds must be transferred to this contract in the same transaction of calling this function.\n', '    /// @param data General order data.\n', '    /// @param takerAmountToFill Taker token amount to spend on order (fee not included).\n', '    /// @return makerAmountReceived Amount received from trade.\n', '    function fillOrder(\n', '        bytes calldata data,\n', '        uint256 takerAmountToFill\n', '    )\n', '    external\n', '    payable\n', '    returns (uint256 makerAmountReceived);\n', '}\n', '\n', '// File: contracts/router/RouterCommon.sol\n', '\n', 'contract RouterCommon {\n', '    struct GeneralOrder {\n', '        address handler;\n', '        address makerToken;\n', '        address takerToken;\n', '        uint256 makerAmount;\n', '        uint256 takerAmount;\n', '        bytes data;\n', '    }\n', '\n', '    struct FillResults {\n', '        uint256 makerAmountReceived;\n', '        uint256 takerAmountSpentOnOrder;\n', '        uint256 takerAmountSpentOnFee;\n', '    }\n', '}\n', '\n', '// File: contracts/router/ZeroExV2Handler.sol\n', '\n', '/// Abstract contract of core 0x v2 contract.\n', 'contract ZeroExV2Exchange {\n', '    struct Order {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', "        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n", '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '    }\n', '\n', '    struct OrderInfo {\n', "        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n", '        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n', '        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n', '    }\n', '\n', '    struct FillResults {\n', '        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n', '        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n', '        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n', '        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n', '    }\n', '\n', '    function getAssetProxy(bytes4 assetProxyId)\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '    function isValidSignature(\n', '        bytes32 hash,\n', '        address signerAddress,\n', '        bytes calldata signature\n', '    )\n', '    external\n', '    view\n', '    returns (bool isValid);\n', '\n', '    function fillOrder(\n', '        Order calldata order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes calldata signature\n', '    )\n', '    external\n', '    returns (FillResults memory fillResults);\n', '\n', '    function getOrderInfo(Order calldata order)\n', '    external\n', '    view\n', '    returns (OrderInfo memory orderInfo);\n', '}\n', '\n', '/// Interface of ERC20 approve function.\n', 'interface IERC20 {\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '}\n', '\n', '// Simple WETH interface to wrap ETH.\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '}\n', '\n', '/// 0x v2 implementation of exchange handler. ERC721 orders are not currently supported.\n', 'contract ZeroExV2Handler is IExchangeHandler, LibMath, Ownable {\n', '\n', '    using LibBytes for bytes;\n', '\n', '    ZeroExV2Exchange constant public EXCHANGE = ZeroExV2Exchange(0x4F833a24e1f95D70F028921e27040Ca56E09AB0b);\n', '    address constant public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address public ROUTER;\n', '    address payable public FEE_ACCOUNT;\n', '    uint256 public PROCESSING_FEE_PERCENTAGE;\n', '\n', '    constructor(\n', '        address router,\n', '        address payable feeAccount,\n', '        uint256 processingFeePercentage\n', '    ) public {\n', '        ROUTER = router;\n', '        FEE_ACCOUNT = feeAccount;\n', '        PROCESSING_FEE_PERCENTAGE = processingFeePercentage;\n', '    }\n', '\n', '    /// Fallback function to receive ETH.\n', '    function() external payable {}\n', '\n', '    /// Sets fee account. Only contract owner can call this function.\n', '    /// @param feeAccount Fee account address.\n', '    function setFeeAccount(\n', '        address payable feeAccount\n', '    )\n', '    external\n', '    onlyOwner\n', '    {\n', '        FEE_ACCOUNT = feeAccount;\n', '    }\n', '\n', '    /// Gets maximum available amount can be spent on order (fee not included).\n', '    /// @param data General order data.\n', '    /// @return availableToFill Amount can be spent on order.\n', '    /// @return feePercentage Fee percentage of order.\n', '    function getAvailableToFill(\n', '        bytes calldata data\n', '    )\n', '    external\n', '    view\n', '    returns (uint256 availableToFill, uint256 feePercentage)\n', '    {\n', '        (ZeroExV2Exchange.Order memory order, bytes memory signature) = getOrder(data);\n', '        ZeroExV2Exchange.OrderInfo memory orderInfo = EXCHANGE.getOrderInfo(order);\n', '        if ((order.takerAddress == address(0) || order.takerAddress == address(this)) &&\n', '            (order.senderAddress == address(0) || order.senderAddress == address(this)) &&\n', '            order.takerFee == 0 &&\n', '            orderInfo.orderStatus == 3 &&\n', '            EXCHANGE.isValidSignature(orderInfo.orderHash, order.makerAddress, signature)\n', '        ) {\n', '            availableToFill = sub(order.takerAssetAmount, orderInfo.orderTakerAssetFilledAmount);\n', '        }\n', '        feePercentage = PROCESSING_FEE_PERCENTAGE;\n', '    }\n', '\n', '    /// Fills an order on the target exchange.\n', '    /// NOTE: The required funds must be transferred to this contract in the same transaction of calling this function.\n', '    /// @param data General order data.\n', '    /// @param takerAmountToFill Taker token amount to spend on order (fee not included).\n', '    /// @return makerAmountReceived Amount received from trade.\n', '    function fillOrder(\n', '        bytes calldata data,\n', '        uint256 takerAmountToFill\n', '    )\n', '    external\n', '    payable\n', '    returns (uint256 makerAmountReceived)\n', '    {\n', '        require(msg.sender == ROUTER, "SENDER_NOT_ROUTER");\n', '        (ZeroExV2Exchange.Order memory order, bytes memory signature) = getOrder(data);\n', '        address makerToken = order.makerAssetData.readAddress(16);\n', '        address takerToken = order.takerAssetData.readAddress(16);\n', '        uint256 processingFee = mul(takerAmountToFill, PROCESSING_FEE_PERCENTAGE) / (1 ether);\n', '        if (takerToken == WETH) {\n', '            IWETH(WETH).deposit.value(takerAmountToFill)();\n', '            if (processingFee > 0) {\n', '                require(FEE_ACCOUNT.send(processingFee), "FAILED_SEND_ETH_TO_FEE_ACCOUNT");\n', '            }\n', '        } else if (processingFee > 0) {\n', '            require(ERC20SafeTransfer.safeTransfer(takerToken, FEE_ACCOUNT, processingFee), "FAILED_SEND_ERC20_TO_FEE_ACCOUNT");\n', '        }\n', '        require(IERC20(takerToken).approve(EXCHANGE.getAssetProxy(order.takerAssetData.readBytes4(0)), takerAmountToFill));\n', '        ZeroExV2Exchange.FillResults memory results = EXCHANGE.fillOrder(\n', '            order,\n', '            takerAmountToFill,\n', '            signature\n', '        );\n', '        makerAmountReceived = results.makerAssetFilledAmount;\n', '        if (makerAmountReceived > 0) {\n', '            require(ERC20SafeTransfer.safeTransfer(makerToken, msg.sender, makerAmountReceived), "FAILED_SEND_ERC20_TO_ROUTER");\n', '        }\n', '    }\n', '\n', '    /// Assembles order object in 0x format.\n', '    /// @param data General order data.\n', '    /// @return order Order object in 0x format.\n', '    /// @return signature Signature object in 0x format.\n', '    function getOrder(\n', '        bytes memory data\n', '    )\n', '    internal\n', '    pure\n', '    returns (ZeroExV2Exchange.Order memory order, bytes memory signature)\n', '    {\n', '        uint256 makerAssetDataOffset = data.readUint256(320);\n', '        uint256 takerAssetDataOffset = data.readUint256(352);\n', '        uint256 signatureOffset = data.readUint256(384);\n', '        order.makerAddress = data.readAddress(12);\n', '        order.takerAddress = data.readAddress(44);\n', '        order.feeRecipientAddress = data.readAddress(76);\n', '        order.senderAddress = data.readAddress(108);\n', '        order.makerAssetAmount = data.readUint256(128);\n', '        order.takerAssetAmount = data.readUint256(160);\n', '        order.makerFee = data.readUint256(192);\n', '        order.takerFee = data.readUint256(224);\n', '        order.expirationTimeSeconds = data.readUint256(256);\n', '        order.salt = data.readUint256(288);\n', '        order.makerAssetData = data.slice(makerAssetDataOffset + 32, makerAssetDataOffset + 32 + data.readUint256(makerAssetDataOffset));\n', '        order.takerAssetData = data.slice(takerAssetDataOffset + 32, takerAssetDataOffset + 32 + data.readUint256(takerAssetDataOffset));\n', '        signature = data.slice(signatureOffset + 32, signatureOffset + 32 + data.readUint256(signatureOffset));\n', '    }\n', '\n', '}']