['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-18\n', '*/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != 0x0);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract BasicToken is owned {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) internal balance_of;\n', '    mapping (address => mapping (address => uint256)) internal allowances;\n', '\n', '    mapping (address => bool) private address_exist;\n', '    address[] private address_list;\n', '\n', '    bool public transfer_close = false;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function BasicToken() public {\n', '    }\n', '\n', '    function balanceOf(address token_owner) public constant returns (uint balance) {\n', '        return balance_of[token_owner];\n', '    }\n', '\n', '    function allowance(\n', '        address _hoarder,\n', '        address _spender\n', '    ) public constant returns (uint256) {\n', '        return allowances[_hoarder][_spender];\n', '    }\n', '\n', '    function superApprove(\n', '        address _hoarder,\n', '        address _spender,\n', '        uint256 _value\n', '    ) onlyOwner public returns(bool) {\n', '        require(_hoarder != address(0));\n', '        require(_spender != address(0));\n', '        require(_value >= 0);\n', '        allowances[_hoarder][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(msg.sender != address(0));\n', '        require(_spender != address(0));\n', '        require(_value >= 0);\n', '        allowances[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function getAddressLength() onlyOwner public constant returns (uint) {\n', '        return address_list.length;\n', '    }\n', '\n', '    function getAddressIndex(uint _address_index) onlyOwner public constant returns (address _address) {\n', '        _address = address_list[_address_index];\n', '    }\n', '\n', '    function getAllAddress() onlyOwner public constant returns (address[]) {\n', '        return address_list;\n', '    }\n', '\n', '    function getAddressExist(address _target) public constant returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        } else {\n', '            return address_exist[_target];\n', '        }\n', '    }\n', '\n', '    function addAddress(address _target) internal returns(bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        } else if (address_exist[_target] == true) {\n', '            return false;\n', '        } else {\n', '            address_exist[_target] = true;\n', '            address_list[address_list.length++] = _target;\n', '        }\n', '    }\n', '\n', '    function mintToken(\n', '        address _to,\n', '        uint256 token_amount,\n', '        uint256 freeze_timestamp\n', '    ) onlyOwner public returns (bool);\n', '\n', '    function superMint(\n', '        address _to,\n', '        uint256 token_amount,\n', '        uint256 freeze_timestamp) onlyOwner public returns(bool);\n', '\n', '    function transfer(address to, uint256 value) public;\n', '    function transferFrom(address _from, address _to, uint256 _amount) public;\n', '\n', '    function transferOpen() onlyOwner public {\n', '        transfer_close = false;\n', '    }\n', '\n', '    function transferClose() onlyOwner public {\n', '        transfer_close = true;\n', '    }\n', '}\n', '\n', 'contract PreSale is owned{\n', '    using SafeMath for uint256;\n', '\n', '    struct Sale {\n', '        uint sale_number;\n', '        uint256 start_timestamp;\n', '        uint256 end_timestamp;\n', '        uint8 bonus_rate;\n', '        uint256 sell_limit;\n', '    }\n', '\n', '    Sale[] private sale_list;\n', '    uint256[] private sale_sold;\n', '\n', '    function PreSale () public {\n', '\n', '    }\n', '\n', '    function getSaleLength() public constant returns(uint) {\n', '        return sale_list.length;\n', '    }\n', '\n', '    function getSaleInfo(uint _index) public constant returns(\n', '        uint sale_number,\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        uint8 bonus_rate,\n', '        uint256 sell_limit\n', '    ) {\n', '        sale_number = sale_list[_index].sale_number;\n', '        start_timestamp = sale_list[_index].start_timestamp;\n', '        end_timestamp = sale_list[_index].end_timestamp;\n', '        bonus_rate = sale_list[_index].bonus_rate;\n', '        sell_limit = sale_list[_index].sell_limit;\n', '    }\n', '\n', '    function getSaleSold(uint _index) public constant returns(uint256) {\n', '        return sale_sold[_index];\n', '    }\n', '\n', '\n', '    function addBonus(\n', '        uint256 _amount,\n', '        uint8 _bonus\n', '    ) internal pure returns(uint256) {\n', '        return _amount.add((_amount.mul(_bonus)).div(100));\n', '    }\n', '\n', '\n', '    function newSale(\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        uint8 bonus_rate,\n', '        uint256 sell_token_limit\n', '    ) onlyOwner public {\n', '        require(start_timestamp > 0);\n', '        require(end_timestamp > 0);\n', '        require(sell_token_limit > 0);\n', '\n', '        uint256 sale_number = sale_list.length;\n', '        for (uint i=0; i < sale_list.length; i++) {\n', '            require(sale_list[i].end_timestamp < start_timestamp);\n', '        }\n', '\n', '        sale_list[sale_list.length++] = Sale({\n', '            sale_number: sale_number,\n', '            start_timestamp: start_timestamp,\n', '            end_timestamp: end_timestamp,\n', '            bonus_rate: bonus_rate,\n', '            sell_limit: sell_token_limit\n', '        });\n', '        sale_sold[sale_sold.length++] = 0;\n', '    }\n', '\n', '    function changeSaleInfo(\n', '        uint256 _index,\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        uint8 bonus_rate,\n', '        uint256 sell_token_limit\n', '    ) onlyOwner public returns(bool) {\n', '        require(_index < sale_list.length);\n', '        require(start_timestamp > 0);\n', '        require(end_timestamp > 0);\n', '        require(sell_token_limit > 0);\n', '\n', '        sale_list[_index].start_timestamp = start_timestamp;\n', '        sale_list[_index].end_timestamp = end_timestamp;\n', '        sale_list[_index].bonus_rate = bonus_rate;\n', '        sale_list[_index].sell_limit = sell_token_limit;\n', '        return true;\n', '    }\n', '\n', '    function changeSaleStart(\n', '        uint256 _index,\n', '        uint256 start_timestamp\n', '    ) onlyOwner public returns(bool) {\n', '        require(_index < sale_list.length);\n', '        require(start_timestamp > 0);\n', '        sale_list[_index].start_timestamp = start_timestamp;\n', '        return true;\n', '    }\n', '\n', '    function changeSaleEnd(\n', '        uint256 _index,\n', '        uint256 end_timestamp\n', '    ) onlyOwner public returns(bool) {\n', '        require(_index < sale_list.length);\n', '        require(end_timestamp > 0);\n', '        sale_list[_index].end_timestamp = end_timestamp;\n', '        return true;\n', '    }\n', '\n', '    function changeSaleBonusRate(\n', '        uint256 _index,\n', '        uint8 bonus_rate\n', '    ) onlyOwner public returns(bool) {\n', '        require(_index < sale_list.length);\n', '        sale_list[_index].bonus_rate = bonus_rate;\n', '        return true;\n', '    }\n', '\n', '    function changeSaleTokenLimit(\n', '        uint256 _index,\n', '        uint256 sell_token_limit\n', '    ) onlyOwner public returns(bool) {\n', '        require(_index < sale_list.length);\n', '        require(sell_token_limit > 0);\n', '        sale_list[_index].sell_limit = sell_token_limit;\n', '        return true;\n', '    }\n', '\n', '\n', '    function checkSaleCanSell(\n', '        uint256 _index,\n', '        uint256 _amount\n', '    ) internal view returns(bool) {\n', '        uint256 index_sold = sale_sold[_index];\n', '        uint256 index_end_timestamp = sale_list[_index].end_timestamp;\n', '        uint256 sell_limit = sale_list[_index].sell_limit;\n', '        uint8 bonus_rate = sale_list[_index].bonus_rate;\n', '        uint256 sell_limit_plus_bonus = addBonus(sell_limit, bonus_rate);\n', '\n', '        if (now >= index_end_timestamp) {\n', '            return false;\n', '        } else if (index_sold.add(_amount) > sell_limit_plus_bonus) {\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function addSaleSold(uint256 _index, uint256 amount) internal {\n', '        require(amount > 0);\n', '        require(_index < sale_sold.length);\n', '        require(checkSaleCanSell(_index, amount) == true);\n', '        sale_sold[_index] += amount;\n', '    }\n', '\n', '    function subSaleSold(uint256 _index, uint256 amount) internal {\n', '        require(amount > 0);\n', '        require(_index < sale_sold.length);\n', '        require(sale_sold[_index].sub(amount) >= 0);\n', '        sale_sold[_index] -= amount;\n', '    }\n', '\n', '    function canSaleInfo() public view returns(\n', '        uint sale_number,\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        uint8 bonus_rate,\n', '        uint256 sell_limit\n', '    ) {\n', '        var(sale_info, isSale) = nowSaleInfo();\n', '        require(isSale == true);\n', '        sale_number = sale_info.sale_number;\n', '        start_timestamp = sale_info.start_timestamp;\n', '        end_timestamp = sale_info.end_timestamp;\n', '        bonus_rate = sale_info.bonus_rate;\n', '        sell_limit = sale_info.sell_limit;\n', '    }\n', '\n', '    function nowSaleInfo() internal view returns(Sale sale_info, bool isSale) {\n', '        isSale = false;\n', '        for (uint i=0; i < sale_list.length; i++) {\n', '            uint256 end_timestamp = sale_list[i].end_timestamp;\n', '            uint256 sell_limit = sale_list[i].sell_limit;\n', '            uint8 bonus_rate = sale_list[i].bonus_rate;\n', '            uint256 sell_limit_plus_bonus = addBonus(sell_limit, bonus_rate);\n', '            uint256 temp_sold_token = sale_sold[i];\n', '            if ((now <= end_timestamp) && (temp_sold_token < sell_limit_plus_bonus)) {\n', '                sale_info = Sale({\n', '                    sale_number: sale_list[i].sale_number,\n', '                    start_timestamp: sale_list[i].start_timestamp,\n', '                    end_timestamp: sale_list[i].end_timestamp,\n', '                    bonus_rate: sale_list[i].bonus_rate,\n', '                    sell_limit: sale_list[i].sell_limit\n', '                });\n', '                isSale = true;\n', '                break;\n', '            } else {\n', '                isSale = false;\n', '                continue;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Vote is owned {\n', '    event ProposalAdd(uint vote_id, address generator, string descript);\n', '    event ProposalEnd(uint vote_id, string descript);\n', '\n', '    struct Proposal {\n', '        address generator;\n', '        string descript;\n', '        uint256 start_timestamp;\n', '        uint256 end_timestamp;\n', '        bool executed;\n', '        uint256 voting_cut;\n', '        uint256 threshold;\n', '\n', '        uint256 voting_count;\n', '        uint256 total_weight;\n', '        mapping (address => uint256) voteWeightOf;\n', '        mapping (address => bool) votedOf;\n', '        address[] voter_address;\n', '    }\n', '\n', '    uint private vote_id = 0;\n', '    Proposal[] private Proposals;\n', '\n', '    function getProposalLength() public constant returns (uint) {\n', '        return Proposals.length;\n', '    }\n', '\n', '    function getProposalIndex(uint _proposal_index) public constant returns (\n', '        address generator,\n', '        string descript,\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        bool executed,\n', '        uint256 voting_count,\n', '        uint256 total_weight,\n', '        uint256 voting_cut,\n', '        uint256 threshold\n', '    ) {\n', '        generator = Proposals[_proposal_index].generator;\n', '        descript = Proposals[_proposal_index].descript;\n', '        start_timestamp = Proposals[_proposal_index].start_timestamp;\n', '        end_timestamp = Proposals[_proposal_index].end_timestamp;\n', '        executed = Proposals[_proposal_index].executed;\n', '        voting_count = Proposals[_proposal_index].voting_count;\n', '        total_weight = Proposals[_proposal_index].total_weight;\n', '        voting_cut = Proposals[_proposal_index].voting_cut;\n', '        threshold = Proposals[_proposal_index].threshold;\n', '    }\n', '\n', '    function getProposalVoterList(uint _proposal_index) public constant returns (address[]) {\n', '        return Proposals[_proposal_index].voter_address;\n', '    }\n', '\n', '    function newVote(\n', '        address who,\n', '        string descript,\n', '        uint256 start_timestamp,\n', '        uint256 end_timestamp,\n', '        uint256 voting_cut,\n', '        uint256 threshold\n', '    ) onlyOwner public returns (uint256) {\n', '        if (Proposals.length >= 1) {\n', '            require(Proposals[vote_id].end_timestamp < start_timestamp);\n', '            require(Proposals[vote_id].executed == true);\n', '        }\n', '\n', '        vote_id = Proposals.length;\n', '        Proposal storage p = Proposals[Proposals.length++];\n', '        p.generator = who;\n', '        p.descript = descript;\n', '        p.start_timestamp = start_timestamp;\n', '        p.end_timestamp = end_timestamp;\n', '        p.executed = false;\n', '        p.voting_cut = voting_cut;\n', '        p.threshold = threshold;\n', '\n', '        p.voting_count = 0;\n', '        delete p.voter_address;\n', '        ProposalAdd(vote_id, who, descript);\n', '        return vote_id;\n', '    }\n', '\n', '    function voting(address _voter, uint256 _weight) internal returns(bool) {\n', '        if (Proposals[vote_id].end_timestamp < now) {\n', '            Proposals[vote_id].executed = true;\n', '        }\n', '\n', '        require(Proposals[vote_id].executed == false);\n', '        require(Proposals[vote_id].end_timestamp > now);\n', '        require(Proposals[vote_id].start_timestamp <= now);\n', '        require(Proposals[vote_id].votedOf[_voter] == false);\n', '        require(Proposals[vote_id].voting_cut <= _weight);\n', '\n', '        Proposals[vote_id].votedOf[_voter] = true;\n', '        Proposals[vote_id].voting_count += 1;\n', '        Proposals[vote_id].voteWeightOf[_voter] = _weight;\n', '        Proposals[vote_id].total_weight += _weight;\n', '        Proposals[vote_id].voter_address[Proposals[vote_id].voter_address.length++] = _voter;\n', '\n', '        if (Proposals[vote_id].total_weight >= Proposals[vote_id].threshold) {\n', '            Proposals[vote_id].executed = true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function voteClose() onlyOwner public {\n', '        if (Proposals.length >= 1) {\n', '            Proposals[vote_id].executed = true;\n', '            ProposalEnd(vote_id, Proposals[vote_id].descript);\n', '        }\n', '    }\n', '\n', '    function checkVote() onlyOwner public {\n', '        if ((Proposals.length >= 1) &&\n', '            (Proposals[vote_id].end_timestamp < now)) {\n', '            voteClose();\n', '        }\n', '    }\n', '}\n', '\n', 'contract FreezeToken is owned {\n', '    mapping (address => uint256) public freezeDateOf;\n', '\n', '    event Freeze(address indexed _who, uint256 _date);\n', '    event Melt(address indexed _who);\n', '\n', '    function checkFreeze(address _sender) public constant returns (bool) {\n', '        if (now >= freezeDateOf[_sender]) {\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function freezeTo(address _who, uint256 _date) internal {\n', '        freezeDateOf[_who] = _date;\n', '        Freeze(_who, _date);\n', '    }\n', '\n', '    function meltNow(address _who) internal onlyOwner {\n', '        freezeDateOf[_who] = now;\n', '        Melt(_who);\n', '    }\n', '}\n', '\n', 'contract TokenInfo is owned {\n', '    using SafeMath for uint256;\n', '\n', '    address public token_wallet_address;\n', '\n', '    string public name = "K_Currency";\n', '    string public symbol = "KCR";\n', '    uint256 public decimals = 18;\n', '    uint256 public total_supply = 100000000 * (10 ** uint256(decimals));\n', '\n', '    // 1 ether : 10,000 token\n', '    uint256 public conversion_rate = 10;\n', '\n', '    event ChangeTokenName(address indexed who);\n', '    event ChangeTokenSymbol(address indexed who);\n', '    event ChangeTokenWalletAddress(address indexed from, address indexed to);\n', '    event ChangeTotalSupply(uint256 indexed from, uint256 indexed to);\n', '    event ChangeConversionRate(uint256 indexed from, uint256 indexed to);\n', '    event ChangeFreezeTime(uint256 indexed from, uint256 indexed to);\n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return total_supply;\n', '    }\n', '\n', '    function changeTokenName(string newName) onlyOwner public {\n', '        name = newName;\n', '        ChangeTokenName(msg.sender);\n', '    }\n', '\n', '    function changeTokenSymbol(string newSymbol) onlyOwner public {\n', '        symbol = newSymbol;\n', '        ChangeTokenSymbol(msg.sender);\n', '    }\n', '\n', '    function changeTokenWallet(address newTokenWallet) onlyOwner internal {\n', '        require(newTokenWallet != address(0));\n', '        address pre_address = token_wallet_address;\n', '        token_wallet_address = newTokenWallet;\n', '        ChangeTokenWalletAddress(pre_address, token_wallet_address);\n', '    }\n', '\n', '    function changeTotalSupply(uint256 _total_supply) onlyOwner internal {\n', '        require(_total_supply > 0);\n', '        uint256 pre_total_supply = total_supply;\n', '        total_supply = _total_supply;\n', '        ChangeTotalSupply(pre_total_supply, total_supply);\n', '    }\n', '\n', '    function changeConversionRate(uint256 _conversion_rate) onlyOwner public {\n', '        require(_conversion_rate > 0);\n', '        uint256 pre_conversion_rate = conversion_rate;\n', '        conversion_rate = _conversion_rate;\n', '        ChangeConversionRate(pre_conversion_rate, conversion_rate);\n', '    }\n', '}\n', '\n', 'contract Token is owned, PreSale, FreezeToken, TokenInfo, Vote, BasicToken {\n', '    using SafeMath for uint256;\n', '\n', '    bool public open_free = false;\n', '\n', '    event Payable(address indexed who, uint256 eth_amount);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Mint(address indexed to, uint256 value);\n', '\n', '    function Token (address _owner_address, address _token_wallet_address) public {\n', '        require(_token_wallet_address != address(0));\n', '\n', '        if (_owner_address != address(0)) {\n', '            owner = _owner_address;\n', '            balance_of[owner] = 0;\n', '        } else {\n', '            owner = msg.sender;\n', '            balance_of[owner] = 0;\n', '        }\n', '\n', '        token_wallet_address = _token_wallet_address;\n', '        balance_of[token_wallet_address] = total_supply;\n', '    }\n', '\n', '    function mintToken(\n', '        address to,\n', '        uint256 token_amount,\n', '        uint256 freeze_timestamp\n', '    ) onlyOwner public returns (bool) {\n', '        require(token_amount > 0);\n', '        require(balance_of[token_wallet_address] >= token_amount);\n', '        require(balance_of[to] + token_amount > balance_of[to]);\n', '        uint256 token_plus_bonus = 0;\n', '        uint sale_number = 0;\n', '\n', '        var(sale_info, isSale) = nowSaleInfo();\n', '        if (isSale) {\n', '            sale_number = sale_info.sale_number;\n', '            uint8 bonus_rate = sale_info.bonus_rate;\n', '            token_plus_bonus = addBonus(token_amount, bonus_rate);\n', '            require(checkSaleCanSell(sale_number, token_plus_bonus) == true);\n', '            addSaleSold(sale_number, token_plus_bonus);\n', '        } else if (open_free) {\n', '            token_plus_bonus = token_amount;\n', '        } else {\n', '            require(open_free == true);\n', '        }\n', '\n', '        balance_of[token_wallet_address] -= token_plus_bonus;\n', '        balance_of[to] += token_plus_bonus;\n', '\n', '        uint256 _freeze = 0;\n', '        if (freeze_timestamp >= 0) {\n', '            _freeze = freeze_timestamp;\n', '        }\n', '\n', '        freezeTo(to, now + _freeze); // FreezeToken.sol\n', '        Transfer(0x0, to, token_plus_bonus);\n', '        addAddress(to);\n', '        return true;\n', '    }\n', '\n', '    function mintTokenBulk(address[] _tos, uint256[] _amounts) onlyOwner public {\n', '        require(_tos.length == _amounts.length);\n', '        for (uint i=0; i < _tos.length; i++) {\n', '            mintToken(_tos[i], _amounts[i], 0);\n', '        }\n', '    }\n', '\n', '    function superMint(\n', '        address to,\n', '        uint256 token_amount,\n', '        uint256 freeze_timestamp\n', '    ) onlyOwner public returns(bool) {\n', '        require(token_amount > 0);\n', '        require(balance_of[token_wallet_address] >= token_amount);\n', '        require(balance_of[to] + token_amount > balance_of[to]);\n', '\n', '        balance_of[token_wallet_address] -= token_amount;\n', '        balance_of[to] += token_amount;\n', '\n', '        uint256 _freeze = 0;\n', '        if (freeze_timestamp >= 0) {\n', '            _freeze = freeze_timestamp;\n', '        }\n', '\n', '        freezeTo(to, now + _freeze);\n', '        Transfer(0x0, to, token_amount);\n', '        Mint(to, token_amount);\n', '        addAddress(to);\n', '        return true;\n', '    }\n', '\n', '    function superMintBulk(address[] _tos, uint256[] _amounts) onlyOwner public {\n', '        require(_tos.length == _amounts.length);\n', '        for (uint i=0; i < _tos.length; i++) {\n', '            superMint(_tos[i], _amounts[i], 0);\n', '        }\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public {\n', '        _transfer(msg.sender, to, value);\n', '    }\n', '\n', '    function transferBulk(address[] tos, uint256[] values) public {\n', '        require(tos.length == values.length);\n', '        for (uint i=0; i < tos.length; i++) {\n', '            transfer(tos[i], values[i]);\n', '        }\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) public {\n', '        require(msg.sender != address(0));\n', '        require(_from != address(0));\n', '        require(_amount <= allowances[_from][msg.sender]);\n', '        _transfer(_from, _to, _amount);\n', '        allowances[_from][msg.sender] -= _amount;\n', '    }\n', '\n', '    function _transfer(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) private {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        require(balance_of[_from] >= _amount);\n', '        require(balance_of[_to].add(_amount) >= balance_of[_to]);\n', '        require(transfer_close == false);\n', '        require(checkFreeze(_from) == false);\n', '\n', '        uint256 prevBalance = balance_of[_from] + balance_of[_to];\n', '        balance_of[_from] -= _amount;\n', '        balance_of[_to] += _amount;\n', '        assert(balance_of[_from] + balance_of[_to] == prevBalance);\n', '        addAddress(_to);\n', '        Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    function burn(address _who, uint256 _amount) onlyOwner public returns(bool) {\n', '        require(_amount > 0);\n', '        require(balanceOf(_who) >= _amount);\n', '        balance_of[_who] -= _amount;\n', '        total_supply -= _amount;\n', '        Burn(_who, _amount);\n', '        return true;\n', '    }\n', '\n', '    function additionalTotalSupply(uint256 _addition) onlyOwner public returns(bool) {\n', '        require(_addition > 0);\n', '        uint256 change_total_supply = total_supply.add(_addition);\n', '        balance_of[token_wallet_address] += _addition;\n', '        changeTotalSupply(change_total_supply);\n', '    }\n', '\n', '    function tokenWalletChange(address newTokenWallet) onlyOwner public returns(bool) {\n', '        require(newTokenWallet != address(0));\n', '        uint256 token_wallet_amount = balance_of[token_wallet_address];\n', '        balance_of[newTokenWallet] = token_wallet_amount;\n', '        balance_of[token_wallet_address] = 0;\n', '        changeTokenWallet(newTokenWallet);\n', '    }\n', '\n', '    function () payable public {\n', '        uint256 eth_amount = msg.value;\n', '        msg.sender.transfer(eth_amount);\n', '        Payable(msg.sender, eth_amount);\n', '    }\n', '\n', '    function tokenOpen() onlyOwner public {\n', '        open_free = true;\n', '    }\n', '\n', '    function tokenClose() onlyOwner public {\n', '        open_free = false;\n', '    }\n', '\n', '    function freezeAddress(\n', '        address _who,\n', '        uint256 _addTimestamp\n', '    ) onlyOwner public returns(bool) {\n', '        freezeTo(_who, _addTimestamp);\n', '        return true;\n', '    }\n', '\n', '    function meltAddress(\n', '        address _who\n', '    ) onlyOwner public returns(bool) {\n', '        meltNow(_who);\n', '        return true;\n', '    }\n', '\n', '    // call a voting in Vote.sol\n', '    function voteAgree() public returns (bool) {\n', '        address _voter = msg.sender;\n', '        uint256 _balance = balanceOf(_voter);\n', '        require(_balance > 0);\n', '        return voting(_voter, _balance);\n', '    }\n', '\n', '    function superVoteAgree(address who) onlyOwner public returns(bool) {\n', '        require(who != address(0));\n', '        uint256 _balance = balanceOf(who);\n', '        require(_balance > 0);\n', '        return voting(who, _balance);\n', '    }\n', '}']