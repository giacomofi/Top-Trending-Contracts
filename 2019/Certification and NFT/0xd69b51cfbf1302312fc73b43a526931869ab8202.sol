['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title LinkedListLib\n', ' * @author Darryl Morris (o0ragman0o) and Modular.network\n', ' *\n', ' * This utility library was forked from https://github.com/o0ragman0o/LibCLL\n', ' * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\n', ' * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\n', ' * coding patterns.\n', ' *\n', ' * version 1.1.1\n', ' * Copyright (c) 2017 Modular Inc.\n', ' * The MIT License (MIT)\n', ' * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The LinkedListLib provides functionality for implementing data indexing using\n', ' * a circlular linked list\n', ' *\n', ' * Modular provides smart contract services and security reviews for contract\n', ' * deployments in addition to working on open source projects in the Ethereum\n', ' * community. Our purpose is to test, document, and deploy reusable code onto the\n', ' * blockchain and improve both security and usability. We also educate non-profits,\n', ' * schools, and other community members about the application of blockchain\n', ' * technology. For further information: modular.network\n', ' *\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', '*/\n', '\n', '\n', 'library LinkedListLib {\n', '\n', '    uint256 constant NULL = 0;\n', '    uint256 constant HEAD = 0;\n', '    bool constant PREV = false;\n', '    bool constant NEXT = true;\n', '\n', '    struct LinkedList{\n', '        mapping (uint256 => mapping (bool => uint256)) list;\n', '    }\n', '\n', '    /// @dev returns true if the list exists\n', '    /// @param self stored linked list from contract\n', '    function listExists(LinkedList storage self)\n', '        public\n', '        view returns (bool)\n', '    {\n', '        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n', '        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev returns true if the node exists\n', '    /// @param self stored linked list from contract\n', '    /// @param _node a node to search for\n', '    function nodeExists(LinkedList storage self, uint256 _node)\n', '        public\n', '        view returns (bool)\n', '    {\n', '        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n', '            if (self.list[HEAD][NEXT] == _node) {\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the number of elements in the list\n', '    /// @param self stored linked list from contract\n', '    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\n', '        bool exists;\n', '        uint256 i;\n', '        (exists,i) = getAdjacent(self, HEAD, NEXT);\n', '        while (i != HEAD) {\n', '            (exists,i) = getAdjacent(self, i, NEXT);\n', '            numElements++;\n', '        }\n', '        return;\n', '    }\n', '\n', '    /// @dev Returns the links of a node as a tuple\n', '    /// @param self stored linked list from contract\n', '    /// @param _node id of the node to get\n', '    function getNode(LinkedList storage self, uint256 _node)\n', '        public view returns (bool,uint256,uint256)\n', '    {\n', '        if (!nodeExists(self,_node)) {\n', '            return (false,0,0);\n', '        } else {\n', '            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the link of a node `_node` in direction `_direction`.\n', '    /// @param self stored linked list from contract\n', '    /// @param _node id of the node to step from\n', '    /// @param _direction direction to step in\n', '    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n', '        public view returns (bool,uint256)\n', '    {\n', '        if (!nodeExists(self,_node)) {\n', '            return (false,0);\n', '        } else {\n', '            return (true,self.list[_node][_direction]);\n', '        }\n', '    }\n', '\n', '    /// @dev Can be used before `insert` to build an ordered list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node an existing node to search from, e.g. HEAD.\n', '    /// @param _value value to seek\n', '    /// @param _direction direction to seek in\n', "    //  @return next first node beyond '_node' in direction `_direction`\n", '    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n', '        public view returns (uint256)\n', '    {\n', '        if (sizeOf(self) == 0) { return 0; }\n', '        require((_node == 0) || nodeExists(self,_node));\n', '        bool exists;\n', '        uint256 next;\n', '        (exists,next) = getAdjacent(self, _node, _direction);\n', '        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\n', '        return next;\n', '    }\n', '\n', '    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\n', '    /// @param self stored linked list from contract\n', '    /// @param _node first node for linking\n', '    /// @param _link  node to link to in the _direction\n', '    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\n', '        self.list[_link][!_direction] = _node;\n', '        self.list[_node][_direction] = _link;\n', '    }\n', '\n', '    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n', '    /// @param self stored linked list from contract\n', '    /// @param _node existing node\n', '    /// @param _new  new node to insert\n', '    /// @param _direction direction to insert node in\n', '    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n', '        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\n', '            uint256 c = self.list[_node][_direction];\n', '            createLink(self, _node, _new, _direction);\n', '            createLink(self, _new, c, _direction);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev removes an entry from the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node node to remove from the list\n', '    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\n', '        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\n', '        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\n', '        delete self.list[_node][PREV];\n', '        delete self.list[_node][NEXT];\n', '        return _node;\n', '    }\n', '\n', '    /// @dev pushes an enrty to the head of the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node new entry to push to the head\n', '    /// @param _direction push to the head (NEXT) or tail (PREV)\n', '    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n', '        insert(self, HEAD, _node, _direction);\n', '    }\n', '\n', '    /// @dev pops the first entry from the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _direction pop from the head (NEXT) or the tail (PREV)\n', '    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\n', '        bool exists;\n', '        uint256 adj;\n', '\n', '        (exists,adj) = getAdjacent(self, HEAD, _direction);\n', '\n', '        return remove(self, adj);\n', '    }\n', '}\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'library AttributeStore {\n', '    struct Data {\n', '        mapping(bytes32 => uint) store;\n', '    }\n', '\n', '    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n', '    public view returns (uint) {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        return self.store[key];\n', '    }\n', '\n', '    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n', '    public {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        self.store[key] = _attrVal;\n', '    }\n', '}\n', '\n', '\n', 'library DLL {\n', '\n', '  uint constant NULL_NODE_ID = 0;\n', '\n', '  struct Node {\n', '    uint next;\n', '    uint prev;\n', '  }\n', '\n', '  struct Data {\n', '    mapping(uint => Node) dll;\n', '  }\n', '\n', '  function isEmpty(Data storage self) public view returns (bool) {\n', '    return getStart(self) == NULL_NODE_ID;\n', '  }\n', '\n', '  function contains(Data storage self, uint _curr) public view returns (bool) {\n', '    if (isEmpty(self) || _curr == NULL_NODE_ID) {\n', '      return false;\n', '    } \n', '\n', '    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n', '    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n', '    return isSingleNode || !isNullNode;\n', '  }\n', '\n', '  function getNext(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].next;\n', '  }\n', '\n', '  function getPrev(Data storage self, uint _curr) public view returns (uint) {\n', '    return self.dll[_curr].prev;\n', '  }\n', '\n', '  function getStart(Data storage self) public view returns (uint) {\n', '    return getNext(self, NULL_NODE_ID);\n', '  }\n', '\n', '  function getEnd(Data storage self) public view returns (uint) {\n', '    return getPrev(self, NULL_NODE_ID);\n', '  }\n', '\n', '  /**\n', '  @dev Inserts a new node between _prev and _next. When inserting a node already existing in \n', '  the list it will be automatically removed from the old position.\n', '  @param _prev the node which _new will be inserted after\n', '  @param _curr the id of the new node being inserted\n', '  @param _next the node which _new will be inserted before\n', '  */\n', '  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n', '    require(_curr != NULL_NODE_ID);\n', '\n', '    remove(self, _curr);\n', '\n', '    require(_prev == NULL_NODE_ID || contains(self, _prev));\n', '    require(_next == NULL_NODE_ID || contains(self, _next));\n', '\n', '    require(getNext(self, _prev) == _next);\n', '    require(getPrev(self, _next) == _prev);\n', '\n', '    self.dll[_curr].prev = _prev;\n', '    self.dll[_curr].next = _next;\n', '\n', '    self.dll[_prev].next = _curr;\n', '    self.dll[_next].prev = _curr;\n', '  }\n', '\n', '  function remove(Data storage self, uint _curr) public {\n', '    if (!contains(self, _curr)) {\n', '      return;\n', '    }\n', '\n', '    uint next = getNext(self, _curr);\n', '    uint prev = getPrev(self, _curr);\n', '\n', '    self.dll[next].prev = prev;\n', '    self.dll[prev].next = next;\n', '\n', '    delete self.dll[_curr];\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '/***************************************************************************************************\n', '*                                                                                                  *\n', '* (c) 2019 Quantstamp, Inc. This content and its use are governed by the license terms at          *\n', '* <https://github.com/quantstamp/qsp-protocol-node/blob/develop/LICENSE>                           *\n', '*                                                                                                  *\n', '***************************************************************************************************/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\n', '@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\n', '*/\n', 'contract PLCRVoting {\n', '\n', '    // ============\n', '    // EVENTS:\n', '    // ============\n', '\n', '    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n', '    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter, uint salt);\n', '    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n', '    event _VotingRightsGranted(uint numTokens, address indexed voter);\n', '    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n', '    event _TokensRescued(uint indexed pollID, address indexed voter);\n', '\n', '    // ============\n', '    // DATA STRUCTURES:\n', '    // ============\n', '\n', '    using AttributeStore for AttributeStore.Data;\n', '    using DLL for DLL.Data;\n', '    using SafeMath for uint;\n', '\n', '    struct Poll {\n', '        uint commitEndDate;     /// expiration date of commit period for poll\n', '        uint revealEndDate;     /// expiration date of reveal period for poll\n', '        uint voteQuorum;\t    /// number of votes required for a proposal to pass\n', '        uint votesFor;\t\t    /// tally of votes supporting proposal\n', '        uint votesAgainst;      /// tally of votes countering proposal\n', '        mapping(address => bool) didCommit;   /// indicates whether an address committed a vote for this poll\n', '        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\n', '        mapping(address => uint) voteOptions; /// stores the voteOption of an address that revealed\n', '    }\n', '\n', '    // ============\n', '    // STATE VARIABLES:\n', '    // ============\n', '\n', '    uint constant public INITIAL_POLL_NONCE = 0;\n', '    uint public pollNonce;\n', '\n', '    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\n', "    mapping(address => uint) public voteTokenBalance; // maps user's address to voteToken balance\n", '\n', '    mapping(address => DLL.Data) dllMap;\n', '    AttributeStore.Data store;\n', '\n', '    EIP20Interface public token;\n', '\n', '    /**\n', '    @dev Initializer. Can only be called once.\n', '    @param _token The address where the ERC20 token contract is deployed\n', '    */\n', '    function init(address _token) public {\n', '        require(_token != address(0) && address(token) == address(0));\n', '\n', '        token = EIP20Interface(_token);\n', '        pollNonce = INITIAL_POLL_NONCE;\n', '    }\n', '\n', '    // ================\n', '    // TOKEN INTERFACE:\n', '    // ================\n', '\n', '    /**\n', '    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\n', '    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\n', '    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\n', '    */\n', '    function requestVotingRights(uint _numTokens) public {\n', '        require(token.balanceOf(msg.sender) >= _numTokens);\n', '        voteTokenBalance[msg.sender] += _numTokens;\n', '        require(token.transferFrom(msg.sender, this, _numTokens));\n', '        emit _VotingRightsGranted(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\n', '    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\n', '    */\n', '    function withdrawVotingRights(uint _numTokens) external {\n', '        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n', '        require(availableTokens >= _numTokens);\n', '        voteTokenBalance[msg.sender] -= _numTokens;\n', '        require(token.transfer(msg.sender, _numTokens));\n', '        emit _VotingRightsWithdrawn(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed vote where poll has ended\n', '    @param _pollID Integer identifier associated with the target poll\n', '    */\n', '    function rescueTokens(uint _pollID) public {\n', '        require(isExpired(pollMap[_pollID].revealEndDate));\n', '        require(dllMap[msg.sender].contains(_pollID));\n', '\n', '        dllMap[msg.sender].remove(_pollID);\n', '        emit _TokensRescued(_pollID, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed votes where polls have ended\n', '    @param _pollIDs Array of integer identifiers associated with the target polls\n', '    */\n', '    function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\n', '        // loop through arrays, rescuing tokens from all\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            rescueTokens(_pollIDs[i]);\n', '        }\n', '    }\n', '\n', '    // =================\n', '    // VOTING INTERFACE:\n', '    // =================\n', '\n', '    /**\n', '    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\n', '    @param _pollID Integer identifier associated with target poll\n', "    @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)\n", '    @param _numTokens The number of tokens to be committed towards the target poll\n', '    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\n', '        require(commitPeriodActive(_pollID));\n', '\n', "        // if msg.sender doesn't have enough voting rights,\n", '        // request for enough voting rights\n', '        if (voteTokenBalance[msg.sender] < _numTokens) {\n', '            uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\n', '            requestVotingRights(remainder);\n', '        }\n', '\n', '        // make sure msg.sender has enough voting rights\n', '        require(voteTokenBalance[msg.sender] >= _numTokens);\n', '        // prevent user from committing to zero node placeholder\n', '        require(_pollID != 0);\n', '        // prevent user from committing a secretHash of 0\n', '        require(_secretHash != 0);\n', '\n', "        // Check if _prevPollID exists in the user's DLL or if _prevPollID is 0\n", '        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n', '\n', '        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n', '\n', '        // edge case: in-place update\n', '        if (nextPollID == _pollID) {\n', '            nextPollID = dllMap[msg.sender].getNext(_pollID);\n', '        }\n', '\n', '        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n', '        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n', '\n', '        bytes32 UUID = attrUUID(msg.sender, _pollID);\n', '\n', '        store.setAttribute(UUID, "numTokens", _numTokens);\n', '        store.setAttribute(UUID, "commitHash", uint(_secretHash));\n', '\n', '        pollMap[_pollID].didCommit[msg.sender] = true;\n', '        emit _VoteCommitted(_pollID, _numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice                 Commits votes using hashes of choices and secret salts to conceal votes until reveal\n', '    @param _pollIDs         Array of integer identifiers associated with target polls\n', "    @param _secretHashes    Array of commit keccak256 hashes of voter's choices and salts (tightly packed in this order)\n", '    @param _numsTokens      Array of numbers of tokens to be committed towards the target polls\n', '    @param _prevPollIDs     Array of IDs of the polls that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\n', '        // make sure the array lengths are all the same\n', '        require(_pollIDs.length == _secretHashes.length);\n', '        require(_pollIDs.length == _numsTokens.length);\n', '        require(_pollIDs.length == _prevPollIDs.length);\n', '\n', '        // loop through arrays, committing each individual vote values\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', "    @dev Compares previous and next poll's committed tokens for sorting purposes\n", '    @param _prevID Integer identifier associated with previous poll in sorted order\n', '    @param _nextID Integer identifier associated with next poll in sorted order\n', '    @param _voter Address of user to check DLL position for\n', '    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\n', '    @return valid Boolean indication of if the specified position maintains the sort\n', '    */\n', '    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n', '        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n', '        // if next is zero node, _numTokens does not need to be greater\n', '        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n', '        return prevValid && nextValid;\n', '    }\n', '\n', '    /**\n', '    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _voteOption Vote choice used to generate commitHash for associated poll\n', '    @param _salt Secret number used to generate commitHash for associated poll\n', '    */\n', '    function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\n', '        // Make sure the reveal period is active\n', '        require(revealPeriodActive(_pollID));\n', '        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\n', '        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\n', '        require(keccak256(abi.encodePacked(_voteOption, _salt)) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\n', '\n', '        uint numTokens = getNumTokens(msg.sender, _pollID);\n', '\n', '        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\n', '            pollMap[_pollID].votesFor += numTokens;\n', '        } else {\n', '            pollMap[_pollID].votesAgainst += numTokens;\n', '        }\n', '\n', '        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\n', '        pollMap[_pollID].didReveal[msg.sender] = true;\n', '        pollMap[_pollID].voteOptions[msg.sender] = _voteOption;\n', '\n', '        emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender, _salt);\n', '    }\n', '\n', '    /**\n', '    @notice             Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens\n', '    @param _pollIDs     Array of integer identifiers associated with target polls\n', '    @param _voteOptions Array of vote choices used to generate commitHashes for associated polls\n', '    @param _salts       Array of secret numbers used to generate commitHashes for associated polls\n', '    */\n', '    function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\n', '        // make sure the array lengths are all the same\n', '        require(_pollIDs.length == _voteOptions.length);\n', '        require(_pollIDs.length == _salts.length);\n', '\n', '        // loop through arrays, revealing each individual vote values\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @param _voter           Address of voter who voted in the majority bloc\n', '    @param _pollID          Integer identifier associated with target poll\n', '    @return correctVotes    Number of tokens voted for winning option\n', '    */\n', '    function getNumPassingTokens(address _voter, uint _pollID) public constant returns (uint correctVotes) {\n', '        require(pollEnded(_pollID));\n', '        require(pollMap[_pollID].didReveal[_voter]);\n', '\n', '        uint winningChoice = isPassed(_pollID) ? 1 : 0;\n', '        uint voterVoteOption = pollMap[_pollID].voteOptions[_voter];\n', '\n', '        require(voterVoteOption == winningChoice, "Voter revealed, but not in the majority");\n', '\n', '        return getNumTokens(_voter, _pollID);\n', '    }\n', '\n', '    // ==================\n', '    // POLLING INTERFACE:\n', '    // ==================\n', '\n', '    /**\n', '    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\n', '    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\n', '    @param _commitDuration Length of desired commit period in seconds\n', '    @param _revealDuration Length of desired reveal period in seconds\n', '    */\n', '    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n', '        pollNonce = pollNonce + 1;\n', '\n', '        uint commitEndDate = block.timestamp.add(_commitDuration);\n', '        uint revealEndDate = commitEndDate.add(_revealDuration);\n', '\n', '        pollMap[pollNonce] = Poll({\n', '            voteQuorum: _voteQuorum,\n', '            commitEndDate: commitEndDate,\n', '            revealEndDate: revealEndDate,\n', '            votesFor: 0,\n', '            votesAgainst: 0\n', '        });\n', '\n', '        emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n', '        return pollNonce;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if proposal has passed\n', '    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function isPassed(uint _pollID) constant public returns (bool passed) {\n', '        require(pollEnded(_pollID));\n', '\n', '        Poll memory poll = pollMap[_pollID];\n', '        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n', '    }\n', '\n', '    // ----------------\n', '    // POLLING HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Gets the total winning votes for reward distribution purposes\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Total number of votes committed to the winning option for specified poll\n', '    */\n', '    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n', '        require(pollEnded(_pollID));\n', '\n', '        if (isPassed(_pollID))\n', '            return pollMap[_pollID].votesFor;\n', '        else\n', '            return pollMap[_pollID].votesAgainst;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if poll is over\n', "    @dev Checks isExpired for specified poll's revealEndDate\n", '    @return Boolean indication of whether polling period is over\n', '    */\n', '    function pollEnded(uint _pollID) constant public returns (bool ended) {\n', '        require(pollExists(_pollID));\n', '\n', '        return isExpired(pollMap[_pollID].revealEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the commit period is still active for the specified poll\n', "    @dev Checks isExpired for the specified poll's commitEndDate\n", '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of isCommitPeriodActive for target poll\n', '    */\n', '    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].commitEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the reveal period is still active for the specified poll\n', "    @dev Checks isExpired for the specified poll's revealEndDate\n", '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has committed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has committed\n', '    */\n', '    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didCommit[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has revealed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has revealed\n', '    */\n', '    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didReveal[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if a poll exists\n', '    @param _pollID The pollID whose existance is to be evaluated.\n', '    @return Boolean Indicates whether a poll exists for the provided pollID\n', '    */\n', '    function pollExists(uint _pollID) constant public returns (bool exists) {\n', '        return (_pollID != 0 && _pollID <= pollNonce);\n', '    }\n', '\n', '    // ---------------------------\n', '    // DOUBLE-LINKED-LIST HELPERS:\n', '    // ---------------------------\n', '\n', '    /**\n', '    @dev Gets the bytes32 commitHash property of target poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Bytes32 hash property attached to target poll\n', '    */\n', '    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n', '        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), "commitHash"));\n', '    }\n', '\n', '    /**\n', '    @dev Wrapper for getAttribute with attrName="numTokens"\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Number of tokens committed to poll in sorted poll-linked-list\n', '    */\n', '    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n', '        return store.getAttribute(attrUUID(_voter, _pollID), "numTokens");\n', '    }\n', '\n', '    /**\n', '    @dev Gets top element of sorted poll-linked-list\n', '    @param _voter Address of user to check against\n', '    @return Integer identifier to poll with maximum number of tokens committed to it\n', '    */\n', '    function getLastNode(address _voter) constant public returns (uint pollID) {\n', '        return dllMap[_voter].getPrev(0);\n', '    }\n', '\n', '    /**\n', '    @dev Gets the numTokens property of getLastNode\n', '    @param _voter Address of user to check against\n', '    @return Maximum number of tokens committed in poll specified\n', '    */\n', '    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n', '        return getNumTokens(_voter, getLastNode(_voter));\n', '    }\n', '\n', '    /*\n', "    @dev Takes the last node in the user's DLL and iterates backwards through the list searching\n", '    for a node with a value less than or equal to the provided _numTokens value. When such a node\n', '    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\n', '    update. In that case, return the previous node of the node being updated. Otherwise return the\n', '    first node that was found with a value less than or equal to the provided _numTokens.\n', '    @param _voter The voter whose DLL will be searched\n', '    @param _numTokens The value for the numTokens attribute in the node to be inserted\n', '    @return the node which the propoded node should be inserted after\n', '    */\n', '    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n', '    constant public returns (uint prevNode) {\n', '        // Get the last node in the list and the number of tokens in that node\n', '        uint nodeID = getLastNode(_voter);\n', '        uint tokensInNode = getNumTokens(_voter, nodeID);\n', '\n', '        // Iterate backwards through the list until reaching the root node\n', '        while(nodeID != 0) {\n', '            // Get the number of tokens in the current node\n', '            tokensInNode = getNumTokens(_voter, nodeID);\n', '            if(tokensInNode <= _numTokens) { // We found the insert point!\n', '                if(nodeID == _pollID) {\n', '                    // This is an in-place update. Return the prev node of the node being updated\n', '                    nodeID = dllMap[_voter].getPrev(nodeID);\n', '                }\n', '                // Return the insert point\n', '                return nodeID;\n', '            }\n', '            // We did not find the insert point. Continue iterating backwards through the list\n', '            nodeID = dllMap[_voter].getPrev(nodeID);\n', '        }\n', '\n', '        // The list is empty, or a smaller value than anything else in the list is being inserted\n', '        return nodeID;\n', '    }\n', '\n', '    // ----------------\n', '    // GENERAL HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Checks if an expiration date has been reached\n', '    @param _terminationDate Integer timestamp of date to compare current timestamp with\n', '    @return expired Boolean indication of whether the terminationDate has passed\n', '    */\n', '    function isExpired(uint _terminationDate) constant public returns (bool expired) {\n', '        return (block.timestamp > _terminationDate);\n', '    }\n', '\n', '    /**\n', '    @dev Generates an identifier which associates a user and a poll together\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return UUID Hash which is deterministic from _user and _pollID\n', '    */\n', '    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n', '        return keccak256(abi.encodePacked(_user, _pollID));\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Parameterizer {\n', '\n', '    // ------\n', '    // EVENTS\n', '    // ------\n', '\n', '    event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\n', '    event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '    event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\n', '    event _ProposalExpired(bytes32 indexed propID);\n', '    event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '\n', '\n', '    // ------\n', '    // DATA STRUCTURES\n', '    // ------\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct ParamProposal {\n', '        uint appExpiry;\n', '        uint challengeID;\n', '        uint deposit;\n', '        string name;\n', '        address owner;\n', '        uint processBy;\n', '        uint value;\n', '    }\n', '\n', '    struct Challenge {\n', '        uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters\n', '        address challenger;     // owner of Challenge\n', '        bool resolved;          // indication of if challenge is resolved\n', '        uint stake;             // number of tokens at risk for either party during challenge\n', '        uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side\n', '        mapping(address => bool) tokenClaims;\n', '    }\n', '\n', '    // ------\n', '    // STATE\n', '    // ------\n', '\n', '    mapping(bytes32 => uint) public params;\n', '\n', '    // maps challengeIDs to associated challenge data\n', '    mapping(uint => Challenge) public challenges;\n', '\n', '    // maps pollIDs to intended data change if poll passes\n', '    mapping(bytes32 => ParamProposal) public proposals;\n', '\n', '    // Global Variables\n', '    EIP20Interface public token;\n', '    PLCRVoting public voting;\n', '    uint public PROCESSBY = 604800; // 7 days\n', '\n', '    /**\n', '    @dev Initializer        Can only be called once\n', '    @param _token           The address where the ERC20 token contract is deployed\n', '    @param _plcr            address of a PLCR voting contract for the provided token\n', '    @notice _parameters     array of canonical parameters\n', '    */\n', '    function init(\n', '        address _token,\n', '        address _plcr,\n', '        uint[] _parameters\n', '    ) public {\n', '        require(_token != 0 && address(token) == 0);\n', '        require(_plcr != 0 && address(voting) == 0);\n', '\n', '        token = EIP20Interface(_token);\n', '        voting = PLCRVoting(_plcr);\n', '\n', '        // minimum deposit for listing to be whitelisted\n', '        set("minDeposit", _parameters[0]);\n', '\n', '        // minimum deposit to propose a reparameterization\n', '        set("pMinDeposit", _parameters[1]);\n', '\n', '        // period over which applicants wait to be whitelisted\n', '        set("applyStageLen", _parameters[2]);\n', '\n', '        // period over which reparmeterization proposals wait to be processed\n', '        set("pApplyStageLen", _parameters[3]);\n', '\n', '        // length of commit period for voting\n', '        set("commitStageLen", _parameters[4]);\n', '\n', '        // length of commit period for voting in parameterizer\n', '        set("pCommitStageLen", _parameters[5]);\n', '\n', '        // length of reveal period for voting\n', '        set("revealStageLen", _parameters[6]);\n', '\n', '        // length of reveal period for voting in parameterizer\n', '        set("pRevealStageLen", _parameters[7]);\n', '\n', "        // percentage of losing party's deposit distributed to winning party\n", '        set("dispensationPct", _parameters[8]);\n', '\n', "        // percentage of losing party's deposit distributed to winning party in parameterizer\n", '        set("pDispensationPct", _parameters[9]);\n', '\n', '        // type of majority out of 100 necessary for candidate success\n', '        set("voteQuorum", _parameters[10]);\n', '\n', '        // type of majority out of 100 necessary for proposal success in parameterizer\n', '        set("pVoteQuorum", _parameters[11]);\n', '\n', '        // minimum length of time user has to wait to exit the registry\n', '        set("exitTimeDelay", _parameters[12]);\n', '\n', '        // maximum length of time user can wait to exit the registry\n', '        set("exitPeriodLen", _parameters[13]);\n', '    }\n', '\n', '    // -----------------------\n', '    // TOKEN HOLDER INTERFACE\n', '    // -----------------------\n', '\n', '    /**\n', "    @notice propose a reparamaterization of the key _name's value to _value.\n", '    @param _name the name of the proposed param to be set\n', '    @param _value the proposed value to set the param to be set\n', '    */\n', '    function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\n', '        uint deposit = get("pMinDeposit");\n', '        bytes32 propID = keccak256(abi.encodePacked(_name, _value));\n', '\n', '        if (keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked("dispensationPct")) ||\n', '            keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked("pDispensationPct"))) {\n', '            require(_value <= 100);\n', '        }\n', '\n', '        require(!propExists(propID)); // Forbid duplicate proposals\n', '        require(get(_name) != _value); // Forbid NOOP reparameterizations\n', '\n', '        // attach name and value to pollID\n', '        proposals[propID] = ParamProposal({\n', '            appExpiry: now.add(get("pApplyStageLen")),\n', '            challengeID: 0,\n', '            deposit: deposit,\n', '            name: _name,\n', '            owner: msg.sender,\n', '            processBy: now.add(get("pApplyStageLen"))\n', '                .add(get("pCommitStageLen"))\n', '                .add(get("pRevealStageLen"))\n', '                .add(PROCESSBY),\n', '            value: _value\n', '        });\n', '\n', '        require(token.transferFrom(msg.sender, this, deposit)); // escrow tokens (deposit amt)\n', '\n', '        emit _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\n', '        return propID;\n', '    }\n', '\n', '    /**\n', '    @notice challenge the provided proposal ID, and put tokens at stake to do so.\n', '    @param _propID the proposal ID to challenge\n', '    */\n', '    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\n', '        ParamProposal memory prop = proposals[_propID];\n', '        uint deposit = prop.deposit;\n', '\n', '        require(propExists(_propID) && prop.challengeID == 0);\n', '\n', '        //start poll\n', '        uint pollID = voting.startPoll(\n', '            get("pVoteQuorum"),\n', '            get("pCommitStageLen"),\n', '            get("pRevealStageLen")\n', '        );\n', '\n', '        challenges[pollID] = Challenge({\n', '            challenger: msg.sender,\n', '            rewardPool: SafeMath.sub(100, get("pDispensationPct")).mul(deposit).div(100),\n', '            stake: deposit,\n', '            resolved: false,\n', '            winningTokens: 0\n', '        });\n', '\n', '        proposals[_propID].challengeID = pollID;       // update listing to store most recent challenge\n', '\n', '        //take tokens from challenger\n', '        require(token.transferFrom(msg.sender, this, deposit));\n', '\n', '        (uint commitEndDate, uint revealEndDate,,,) = voting.pollMap(pollID);\n', '\n', '        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\n', '        return pollID;\n', '    }\n', '\n', '    /**\n', '    @notice             for the provided proposal ID, set it, resolve its challenge, or delete it depending on whether it can be set, has a challenge which can be resolved, or if its "process by" date has passed\n', '    @param _propID      the proposal ID to make a determination and state transition for\n', '    */\n', '    function processProposal(bytes32 _propID) public {\n', '        ParamProposal storage prop = proposals[_propID];\n', '        address propOwner = prop.owner;\n', '        uint propDeposit = prop.deposit;\n', '\n', '\n', '        // Before any token transfers, deleting the proposal will ensure that if reentrancy occurs the\n', '        // prop.owner and prop.deposit will be 0, thereby preventing theft\n', '        if (canBeSet(_propID)) {\n', '            // There is no challenge against the proposal. The processBy date for the proposal has not\n', "            // passed, but the proposal's appExpirty date has passed.\n", '            set(prop.name, prop.value);\n', '            emit _ProposalAccepted(_propID, prop.name, prop.value);\n', '            delete proposals[_propID];\n', '            require(token.transfer(propOwner, propDeposit));\n', '        } else if (challengeCanBeResolved(_propID)) {\n', '            // There is a challenge against the proposal.\n', '            resolveChallenge(_propID);\n', '        } else if (now > prop.processBy) {\n', '            // There is no challenge against the proposal, but the processBy date has passed.\n', '            emit _ProposalExpired(_propID);\n', '            delete proposals[_propID];\n', '            require(token.transfer(propOwner, propDeposit));\n', '        } else {\n', '            // There is no challenge against the proposal, and neither the appExpiry date nor the\n', '            // processBy date has passed.\n', '            revert();\n', '        }\n', '\n', '        assert(get("dispensationPct") <= 100);\n', '        assert(get("pDispensationPct") <= 100);\n', '\n', '        // verify that future proposal appExpiry and processBy times will not overflow\n', '        now.add(get("pApplyStageLen"))\n', '            .add(get("pCommitStageLen"))\n', '            .add(get("pRevealStageLen"))\n', '            .add(PROCESSBY);\n', '\n', '        delete proposals[_propID];\n', '    }\n', '\n', '    /**\n', '    @notice                 Claim the tokens owed for the msg.sender in the provided challenge\n', '    @param _challengeID     the challenge ID to claim tokens for\n', '    */\n', '    function claimReward(uint _challengeID) public {\n', '        Challenge storage challenge = challenges[_challengeID];\n', '        // ensure voter has not already claimed tokens and challenge results have been processed\n', '        require(challenge.tokenClaims[msg.sender] == false);\n', '        require(challenge.resolved == true);\n', '\n', '        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID);\n', '        uint reward = voterReward(msg.sender, _challengeID);\n', '\n', "        // subtract voter's information to preserve the participation ratios of other voters\n", '        // compared to the remaining pool of rewards\n', '        challenge.winningTokens -= voterTokens;\n', '        challenge.rewardPool -= reward;\n', '\n', '        // ensures a voter cannot claim tokens again\n', '        challenge.tokenClaims[msg.sender] = true;\n', '\n', '        emit _RewardClaimed(_challengeID, reward, msg.sender);\n', '        require(token.transfer(msg.sender, reward));\n', '    }\n', '\n', '    /**\n', '    @dev                    Called by a voter to claim their rewards for each completed vote.\n', '                            Someone must call updateStatus() before this can be called.\n', '    @param _challengeIDs    The PLCR pollIDs of the challenges rewards are being claimed for\n', '    */\n', '    function claimRewards(uint[] _challengeIDs) public {\n', '        // loop through arrays, claiming each individual vote reward\n', '        for (uint i = 0; i < _challengeIDs.length; i++) {\n', '            claimReward(_challengeIDs[i]);\n', '        }\n', '    }\n', '\n', '    // --------\n', '    // GETTERS\n', '    // --------\n', '\n', '    /**\n', "    @dev                Calculates the provided voter's token reward for the given poll.\n", '    @param _voter       The address of the voter whose reward balance is to be returned\n', "    @param _challengeID The ID of the challenge the voter's reward is being calculated for\n", "    @return             The uint indicating the voter's reward\n", '    */\n', '    function voterReward(address _voter, uint _challengeID)\n', '    public view returns (uint) {\n', '        uint winningTokens = challenges[_challengeID].winningTokens;\n', '        uint rewardPool = challenges[_challengeID].rewardPool;\n', '        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID);\n', '        return (voterTokens * rewardPool) / winningTokens;\n', '    }\n', '\n', '    /**\n', '    @notice Determines whether a proposal passed its application stage without a challenge\n', '    @param _propID The proposal ID for which to determine whether its application stage passed without a challenge\n', '    */\n', '    function canBeSet(bytes32 _propID) view public returns (bool) {\n', '        ParamProposal memory prop = proposals[_propID];\n', '\n', '        return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\n', '    }\n', '\n', '    /**\n', '    @notice Determines whether a proposal exists for the provided proposal ID\n', '    @param _propID The proposal ID whose existance is to be determined\n', '    */\n', '    function propExists(bytes32 _propID) view public returns (bool) {\n', '        return proposals[_propID].processBy > 0;\n', '    }\n', '\n', '    /**\n', '    @notice Determines whether the provided proposal ID has a challenge which can be resolved\n', '    @param _propID The proposal ID whose challenge to inspect\n', '    */\n', '    function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\n', '        ParamProposal memory prop = proposals[_propID];\n', '        Challenge memory challenge = challenges[prop.challengeID];\n', '\n', '        return (prop.challengeID > 0 && challenge.resolved == false && voting.pollEnded(prop.challengeID));\n', '    }\n', '\n', '    /**\n', '    @notice Determines the number of tokens to awarded to the winning party in a challenge\n', '    @param _challengeID The challengeID to determine a reward for\n', '    */\n', '    function challengeWinnerReward(uint _challengeID) public view returns (uint) {\n', '        if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '            // Edge case, nobody voted, give all tokens to the challenger.\n', '            return 2 * challenges[_challengeID].stake;\n', '        }\n', '\n', '        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '    }\n', '\n', '    /**\n', '    @notice gets the parameter keyed by the provided name value from the params mapping\n', '    @param _name the key whose value is to be determined\n', '    */\n', '    function get(string _name) public view returns (uint value) {\n', '        return params[keccak256(abi.encodePacked(_name))];\n', '    }\n', '\n', '    /**\n', '    @dev                Getter for Challenge tokenClaims mappings\n', '    @param _challengeID The challengeID to query\n', '    @param _voter       The voter whose claim status to query for the provided challengeID\n', '    */\n', '    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '        return challenges[_challengeID].tokenClaims[_voter];\n', '    }\n', '\n', '    // ----------------\n', '    // PRIVATE FUNCTIONS\n', '    // ----------------\n', '\n', '    /**\n', '    @dev resolves a challenge for the provided _propID. It must be checked in advance whether the _propID has a challenge on it\n', '    @param _propID the proposal ID whose challenge is to be resolved.\n', '    */\n', '    function resolveChallenge(bytes32 _propID) private {\n', '        ParamProposal memory prop = proposals[_propID];\n', '        Challenge storage challenge = challenges[prop.challengeID];\n', '\n', "        // winner gets back their full staked deposit, and dispensationPct*loser's stake\n", '        uint reward = challengeWinnerReward(prop.challengeID);\n', '\n', '        challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\n', '        challenge.resolved = true;\n', '\n', '        if (voting.isPassed(prop.challengeID)) { // The challenge failed\n', '            if(prop.processBy > now) {\n', '                set(prop.name, prop.value);\n', '            }\n', '            emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '            require(token.transfer(prop.owner, reward));\n', '        }\n', '        else { // The challenge succeeded or nobody voted\n', '            emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n', '            require(token.transfer(challenges[prop.challengeID].challenger, reward));\n', '        }\n', '    }\n', '\n', '    /**\n', '    @dev sets the param keted by the provided name to the provided value\n', '    @param _name the name of the param to be set\n', '    @param _value the value to set the param to be set\n', '    */\n', '    function set(string _name, uint _value) private {\n', '        params[keccak256(abi.encodePacked(_name))] = _value;\n', '    }\n', '}\n', ' // Imports PLCRVoting and SafeMath\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    checkRole(msg.sender, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressAdded(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(addr, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      addAddressToWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressRemoved(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      removeAddressFromWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/***************************************************************************************************\n', '*                                                                                                  *\n', '* (c) 2019 Quantstamp, Inc. This content and its use are governed by the license terms at          *\n', '* <https://github.com/quantstamp/qsp-protocol-node/blob/develop/LICENSE>                           *\n', '*                                                                                                  *\n', '***************************************************************************************************/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Registry {\n', '\n', '    // ------\n', '    // EVENTS\n', '    // ------\n', '\n', '    event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant);\n', '    event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger);\n', '    event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner);\n', '    event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner);\n', '    event _ApplicationWhitelisted(bytes32 indexed listingHash);\n', '    event _ApplicationRemoved(bytes32 indexed listingHash);\n', '    event _ListingRemoved(bytes32 indexed listingHash);\n', '    event _ListingWithdrawn(bytes32 indexed listingHash, address indexed owner);\n', '    event _TouchAndRemoved(bytes32 indexed listingHash);\n', '    event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n', '    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n', '    event _ExitInitialized(bytes32 indexed listingHash, uint exitTime, uint exitDelayEndDate, address indexed owner);\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Listing {\n', '        uint applicationExpiry; // Expiration date of apply stage\n', '        bool whitelisted;       // Indicates registry status\n', '        address owner;          // Owner of Listing\n', '        uint unstakedDeposit;   // Number of tokens in the listing not locked in a challenge\n', '        uint challengeID;       // Corresponds to a PollID in PLCRVoting\n', '\tuint exitTime;\t\t// Time the listing may leave the registry\n', '        uint exitTimeExpiry;    // Expiration date of exit period\n', '    }\n', '\n', '    struct Challenge {\n', '        uint rewardPool;        // (remaining) Pool of tokens to be distributed to winning voters\n', '        address challenger;     // Owner of Challenge\n', '        bool resolved;          // Indication of if challenge is resolved\n', '        uint stake;             // Number of tokens at stake for either party during challenge\n', '        uint totalTokens;       // (remaining) Number of tokens used in voting by the winning side\n', '        mapping(address => bool) tokenClaims; // Indicates whether a voter has claimed a reward yet\n', '    }\n', '\n', '    // Maps challengeIDs to associated challenge data\n', '    mapping(uint => Challenge) public challenges;\n', '\n', '    // Maps listingHashes to associated listingHash data\n', '    mapping(bytes32 => Listing) public listings;\n', '\n', '    // Global Variables\n', '    EIP20Interface public token;\n', '    PLCRVoting public voting;\n', '    Parameterizer public parameterizer;\n', '    string public name;\n', '\n', '    /**\n', '    @dev Initializer. Can only be called once.\n', '    @param _token The address where the ERC20 token contract is deployed\n', '    */\n', '    function init(address _token, address _voting, address _parameterizer, string _name) public {\n', '        require(_token != 0 && address(token) == 0);\n', '        require(_voting != 0 && address(voting) == 0);\n', '        require(_parameterizer != 0 && address(parameterizer) == 0);\n', '\n', '        token = EIP20Interface(_token);\n', '        voting = PLCRVoting(_voting);\n', '        parameterizer = Parameterizer(_parameterizer);\n', '        name = _name;\n', '    }\n', '\n', '    // --------------------\n', '    // PUBLISHER INTERFACE:\n', '    // --------------------\n', '\n', '    /**\n', '    @dev                Allows a user to start an application. Takes tokens from user and sets\n', '                        apply stage end time.\n', '    @param _listingHash The hash of a potential listing a user is applying to add to the registry\n', '    @param _amount      The number of ERC20 tokens a user is willing to potentially stake\n', '    @param _data        Extra data relevant to the application. Think IPFS hashes.\n', '    */\n', '    function apply(bytes32 _listingHash, uint _amount, string _data) external {\n', '        require(!isWhitelisted(_listingHash));\n', '        require(!appWasMade(_listingHash));\n', '        require(_amount >= parameterizer.get("minDeposit"));\n', '\n', '        // Sets owner\n', '        Listing storage listing = listings[_listingHash];\n', '        listing.owner = msg.sender;\n', '\n', '        // Sets apply stage end time\n', '        listing.applicationExpiry = block.timestamp.add(parameterizer.get("applyStageLen"));\n', '        listing.unstakedDeposit = _amount;\n', '\n', '        // Transfers tokens from user to Registry contract\n', '        require(token.transferFrom(listing.owner, this, _amount));\n', '\n', '        emit _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to increase their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of\n', "    @param _amount      The number of ERC20 tokens to increase a user's unstaked deposit\n", '    */\n', '    function deposit(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '\n', '        listing.unstakedDeposit += _amount;\n', '        require(token.transferFrom(msg.sender, this, _amount));\n', '\n', '        emit _Deposit(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                Allows the owner of a listingHash to decrease their unstaked deposit.\n', '    @param _listingHash A listingHash msg.sender is the owner of.\n', '    @param _amount      The number of ERC20 tokens to withdraw from the unstaked deposit.\n', '    */\n', '    function withdraw(bytes32 _listingHash, uint _amount) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(listing.owner == msg.sender);\n', '        require(_amount <= listing.unstakedDeposit);\n', '        require(listing.unstakedDeposit - _amount >= parameterizer.get("minDeposit"));\n', '\n', '        listing.unstakedDeposit -= _amount;\n', '        require(token.transfer(msg.sender, _amount));\n', '\n', '        emit _Withdrawal(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev\t\tInitialize an exit timer for a listing to leave the whitelist\n', '    @param _listingHash\tA listing hash msg.sender is the owner of\n', '    */\n', '    function initExit(bytes32 _listingHash) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(msg.sender == listing.owner);\n', '        require(isWhitelisted(_listingHash));\n', '        // Cannot exit during ongoing challenge\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        // Ensure user never initializedExit or exitPeriodLen passed\n', '        require(listing.exitTime == 0 || now > listing.exitTimeExpiry);\n', '\n', '        // Set when the listing may be removed from the whitelist\n', '        listing.exitTime = now.add(parameterizer.get("exitTimeDelay"));\n', '\t// Set exit period end time\n', '\tlisting.exitTimeExpiry = listing.exitTime.add(parameterizer.get("exitPeriodLen"));\n', '        emit _ExitInitialized(_listingHash, listing.exitTime,\n', '            listing.exitTimeExpiry, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev\t\tAllow a listing to leave the whitelist\n', '    @param _listingHash A listing hash msg.sender is the owner of\n', '    */\n', '    function finalizeExit(bytes32 _listingHash) external {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        require(msg.sender == listing.owner);\n', '        require(isWhitelisted(_listingHash));\n', '        // Cannot exit during ongoing challenge\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        // Make sure the exit was initialized\n', '        require(listing.exitTime > 0);\n', '        // Time to exit has to be after exit delay but before the exitPeriodLen is over\n', '\trequire(listing.exitTime < now && now < listing.exitTimeExpiry);\n', '\n', '        resetListing(_listingHash);\n', '        emit _ListingWithdrawn(_listingHash, msg.sender);\n', '    }\n', '\n', '    // -----------------------\n', '    // TOKEN HOLDER INTERFACE:\n', '    // -----------------------\n', '\n', '    /**\n', '    @dev                Starts a poll for a listingHash which is either in the apply stage or\n', '                        already in the whitelist. Tokens are taken from the challenger and the\n', "                        applicant's deposits are locked.\n", '    @param _listingHash The listingHash being challenged, whether listed or in application\n', '    @param _data        Extra data relevant to the challenge. Think IPFS hashes.\n', '    */\n', '    function challenge(bytes32 _listingHash, string _data) external returns (uint challengeID) {\n', '        Listing storage listing = listings[_listingHash];\n', '        uint minDeposit = parameterizer.get("minDeposit");\n', '\n', '        // Listing must be in apply stage or already on the whitelist\n', '        require(appWasMade(_listingHash) || listing.whitelisted);\n', '        // Prevent multiple challenges\n', '        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n', '\n', '        if (listing.unstakedDeposit < minDeposit) {\n', '            // Not enough tokens, listingHash auto-delisted\n', '            resetListing(_listingHash);\n', '            emit _TouchAndRemoved(_listingHash);\n', '            return 0;\n', '        }\n', '\n', '        // Starts poll\n', '        uint pollID = voting.startPoll(\n', '            parameterizer.get("voteQuorum"),\n', '            parameterizer.get("commitStageLen"),\n', '            parameterizer.get("revealStageLen")\n', '        );\n', '\n', '        uint oneHundred = 100; // Kludge that we need to use SafeMath\n', '        challenges[pollID] = Challenge({\n', '            challenger: msg.sender,\n', '            rewardPool: ((oneHundred.sub(parameterizer.get("dispensationPct"))).mul(minDeposit)).div(100),\n', '            stake: minDeposit,\n', '            resolved: false,\n', '            totalTokens: 0\n', '        });\n', '\n', '        // Updates listingHash to store most recent challenge\n', '        listing.challengeID = pollID;\n', '\n', '        // Locks tokens for listingHash during challenge\n', '        listing.unstakedDeposit -= minDeposit;\n', '\n', '        // Takes tokens from challenger\n', '        require(token.transferFrom(msg.sender, this, minDeposit));\n', '\n', '        (uint commitEndDate, uint revealEndDate,,,) = voting.pollMap(pollID);\n', '\n', '        emit _Challenge(_listingHash, pollID, _data, commitEndDate, revealEndDate, msg.sender);\n', '        return pollID;\n', '    }\n', '\n', '    /**\n', "    @dev                Updates a listingHash's status from 'application' to 'listing' or resolves\n", '                        a challenge if one exists.\n', '    @param _listingHash The listingHash whose status is being updated\n', '    */\n', '    function updateStatus(bytes32 _listingHash) public {\n', '        if (canBeWhitelisted(_listingHash)) {\n', '            whitelistApplication(_listingHash);\n', '        } else if (challengeCanBeResolved(_listingHash)) {\n', '            resolveChallenge(_listingHash);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /**\n', "    @dev                  Updates an array of listingHashes' status from 'application' to 'listing' or resolves\n", '                          a challenge if one exists.\n', '    @param _listingHashes The listingHashes whose status are being updated\n', '    */\n', '    function updateStatuses(bytes32[] _listingHashes) public {\n', '        // loop through arrays, revealing each individual vote values\n', '        for (uint i = 0; i < _listingHashes.length; i++) {\n', '            updateStatus(_listingHashes[i]);\n', '        }\n', '    }\n', '\n', '    // ----------------\n', '    // TOKEN FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Called by a voter to claim their reward for each completed vote. Someone\n', '                        must call updateStatus() before this can be called.\n', '    @param _challengeID The PLCR pollID of the challenge a reward is being claimed for\n', '    */\n', '    function claimReward(uint _challengeID) public {\n', '        Challenge storage challengeInstance = challenges[_challengeID];\n', '        // Ensures the voter has not already claimed tokens and challengeInstance results have\n', '        // been processed\n', '        require(challengeInstance.tokenClaims[msg.sender] == false);\n', '        require(challengeInstance.resolved == true);\n', '\n', '        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID);\n', '        uint reward = voterTokens.mul(challengeInstance.rewardPool)\n', '                      .div(challengeInstance.totalTokens);\n', '\n', "        // Subtracts the voter's information to preserve the participation ratios\n", '        // of other voters compared to the remaining pool of rewards\n', '        challengeInstance.totalTokens -= voterTokens;\n', '        challengeInstance.rewardPool -= reward;\n', '\n', '        // Ensures a voter cannot claim tokens again\n', '        challengeInstance.tokenClaims[msg.sender] = true;\n', '\n', '        require(token.transfer(msg.sender, reward));\n', '\n', '        emit _RewardClaimed(_challengeID, reward, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev                 Called by a voter to claim their rewards for each completed vote. Someone\n', '                         must call updateStatus() before this can be called.\n', '    @param _challengeIDs The PLCR pollIDs of the challenges rewards are being claimed for\n', '    */\n', '    function claimRewards(uint[] _challengeIDs) public {\n', '        // loop through arrays, claiming each individual vote reward\n', '        for (uint i = 0; i < _challengeIDs.length; i++) {\n', '            claimReward(_challengeIDs[i]);\n', '        }\n', '    }\n', '\n', '    // --------\n', '    // GETTERS:\n', '    // --------\n', '\n', '    /**\n', "    @dev                Calculates the provided voter's token reward for the given poll.\n", '    @param _voter       The address of the voter whose reward balance is to be returned\n', '    @param _challengeID The pollID of the challenge a reward balance is being queried for\n', "    @return             The uint indicating the voter's reward\n", '    */\n', '    function voterReward(address _voter, uint _challengeID)\n', '    public view returns (uint) {\n', '        uint totalTokens = challenges[_challengeID].totalTokens;\n', '        uint rewardPool = challenges[_challengeID].rewardPool;\n', '        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID);\n', '        return voterTokens.mul(rewardPool).div(totalTokens);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether the given listingHash be whitelisted.\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        // Ensures that the application was made,\n', '        // the application period has ended,\n', '        // the listingHash can be whitelisted,\n', '        // and either: the challengeID == 0, or the challenge has been resolved.\n', '        if (\n', '            appWasMade(_listingHash) &&\n', '            listings[_listingHash].applicationExpiry < now &&\n', '            !isWhitelisted(_listingHash) &&\n', '            (challengeID == 0 || challenges[challengeID].resolved == true)\n', '        ) { return true; }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the provided listingHash is whitelisted\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function isWhitelisted(bytes32 _listingHash) view public returns (bool whitelisted) {\n', '        return listings[_listingHash].whitelisted;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if apply was called for this listingHash\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function appWasMade(bytes32 _listingHash) view public returns (bool exists) {\n', '        return listings[_listingHash].applicationExpiry > 0;\n', '    }\n', '\n', '    /**\n', '    @dev                Returns true if the application/listingHash has an unresolved challenge\n', '    @param _listingHash The listingHash whose status is to be examined\n', '    */\n', '    function challengeExists(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines whether voting has concluded in a challenge for a given\n', '                        listingHash. Throws if no challenge exists.\n', '    @param _listingHash A listingHash with an unresolved challenge\n', '    */\n', '    function challengeCanBeResolved(bytes32 _listingHash) view public returns (bool) {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', '        require(challengeExists(_listingHash));\n', '\n', '        return voting.pollEnded(challengeID);\n', '    }\n', '\n', '    /**\n', '    @dev                Determines the number of tokens awarded to the winning party in a challenge.\n', '    @param _challengeID The challengeID to determine a reward for\n', '    */\n', '    function determineReward(uint _challengeID) public view returns (uint) {\n', '        require(!challenges[_challengeID].resolved && voting.pollEnded(_challengeID));\n', '\n', '        // Edge case, nobody voted, give all tokens to the challenger.\n', '        if (voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n', '            return 2 * challenges[_challengeID].stake;\n', '        }\n', '\n', '        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n', '    }\n', '\n', '    /**\n', '    @dev                Getter for Challenge tokenClaims mappings\n', '    @param _challengeID The challengeID to query\n', '    @param _voter       The voter whose claim status to query for the provided challengeID\n', '    */\n', '    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n', '        return challenges[_challengeID].tokenClaims[_voter];\n', '    }\n', '\n', '    // ----------------\n', '    // PRIVATE FUNCTIONS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev                Determines the winner in a challenge. Rewards the winner tokens and\n', '                        either whitelists or de-whitelists the listingHash.\n', '    @param _listingHash A listingHash with a challenge that is to be resolved\n', '    */\n', '    function resolveChallenge(bytes32 _listingHash) private {\n', '        uint challengeID = listings[_listingHash].challengeID;\n', '\n', "        // Calculates the winner's reward,\n", "        // which is: (winner's full stake) + (dispensationPct * loser's stake)\n", '        uint reward = determineReward(challengeID);\n', '\n', '        // Sets flag on challenge being processed\n', '        challenges[challengeID].resolved = true;\n', '\n', '        // Stores the total tokens used for voting by the winning side for reward purposes\n', '        challenges[challengeID].totalTokens =\n', '            voting.getTotalNumberOfTokensForWinningOption(challengeID);\n', '\n', '        // Case: challenge failed\n', '        if (voting.isPassed(challengeID)) {\n', '            whitelistApplication(_listingHash);\n', '            // Unlock stake so that it can be retrieved by the applicant\n', '            listings[_listingHash].unstakedDeposit += reward;\n', '\n', '            emit _ChallengeFailed(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '        // Case: challenge succeeded or nobody voted\n', '        else {\n', '            resetListing(_listingHash);\n', '            // Transfer the reward to the challenger\n', '            require(token.transfer(challenges[challengeID].challenger, reward));\n', '\n', '            emit _ChallengeSucceeded(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @dev                Called by updateStatus() if the applicationExpiry date passed without a\n', '                        challenge being made. Called by resolveChallenge() if an\n', '                        application/listing beat a challenge.\n', '    @param _listingHash The listingHash of an application/listingHash to be whitelisted\n', '    */\n', '    function whitelistApplication(bytes32 _listingHash) private {\n', '        if (!listings[_listingHash].whitelisted) { emit _ApplicationWhitelisted(_listingHash); }\n', '        listings[_listingHash].whitelisted = true;\n', '    }\n', '\n', '    /**\n', '    @dev                Deletes a listingHash from the whitelist and transfers tokens back to owner\n', '    @param _listingHash The listing hash to delete\n', '    */\n', '    function resetListing(bytes32 _listingHash) private {\n', '        Listing storage listing = listings[_listingHash];\n', '\n', '        // Emit events before deleting listing to check whether is whitelisted\n', '        if (listing.whitelisted) {\n', '            emit _ListingRemoved(_listingHash);\n', '        } else {\n', '            emit _ApplicationRemoved(_listingHash);\n', '        }\n', '\n', '        // Deleting listing to prevent reentry\n', '        address owner = listing.owner;\n', '        uint unstakedDeposit = listing.unstakedDeposit;\n', '        delete listings[_listingHash];\n', '\n', '        // Transfers any remaining balance back to the owner\n', '        if (unstakedDeposit > 0){\n', '            require(token.transfer(owner, unstakedDeposit));\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/***************************************************************************************************\n', '*                                                                                                  *\n', '* (c) 2019 Quantstamp, Inc. This content and its use are governed by the license terms at          *\n', '* <https://github.com/quantstamp/qsp-protocol-node/blob/develop/LICENSE>                           *\n', '*                                                                                                  *\n', '***************************************************************************************************/\n', '\n', '\n', '\n', ' // Imports PLCRVoting and SafeMath\n', '\n', '\n', ' //Imports SafeMath\n', '\n', '\n', '\n', 'contract QuantstampBountyData is Whitelist {\n', '\n', '  using SafeMath for uint256;\n', '  using LinkedListLib for LinkedListLib.LinkedList;\n', '\n', '  // constants used by LinkedListLib\n', '  uint256 constant internal NULL = 0;\n', '  uint256 constant internal HEAD = 0;\n', '  bool constant internal PREV = false;\n', '  bool constant internal NEXT = true;\n', '\n', '\n', '  uint256 constant internal NUMBER_OF_PHASES = 3;\n', '\n', '  struct Bounty {\n', '    address submitter;\n', '    string contractAddress;\n', '    uint256 size; // R1\n', '    uint256 minVotes; // R3\n', '    uint256 duration; // R2. Number of seconds\n', '    uint256 judgeDeposit; // R5\n', '    uint256 hunterDeposit; // R6\n', '    uint256 initiationTimestamp; // Time in seconds that the bounty is created\n', '    bool remainingFeesWithdrawn; // true if the remaining fees have been withdrawn by the submitter\n', '    uint256 numApprovedBugs;\n', '  }\n', '\n', '  // holds information about a revealed bug\n', '  struct Bug {\n', '    address hunter; // address that submitted the hash\n', '    uint256 bountyId; // the ID of the associated bounty\n', '    string bugDescription; // the description of the bug\n', '    uint256 numTokens; // the number of tokens staked on the commit\n', '    uint256 pollId; // the poll that decided on the validity of the bug\n', '  }\n', '\n', '  // holds information relevant to a bug commit\n', '  struct BugCommit {\n', '    address hunter;  // address that submitted the hash\n', '    uint256 bountyId;  // the ID of the associated bounty\n', '    bytes32 bugDescriptionHash;  // keccak256 hash of the bug\n', '    uint256 commitTimestamp;  // Time in seconds that the bug commit occurred\n', '    uint256 revealStartTimestamp;  // Time in seconds when the the reveal phase starts\n', '    uint256 revealEndTimestamp;  // Time in seconds when the the reveal phase ends\n', '    uint256 numTokens;  // the number of tokens staked on the commit\n', '  }\n', '\n', '  mapping (uint256 => Bounty) public bounties;\n', '\n', '  // maps pollIds back to bugIds\n', '  mapping (uint256 => uint256) public pollIdToBugId;\n', '\n', '  // For generating bountyIDs starting from 1\n', '  uint256 private bountyCounter;\n', '\n', '  // For generating bugIDs starting from 1\n', '  uint256 private bugCounter;\n', '\n', '  // token used to pay for participants in a bounty. This contract assumes that the owner of the contract\n', "  // trusts token's code and that transfer function (such as transferFrom, transfer) do the right thing\n", '  StandardToken public token;\n', '\n', '  // The partial-locking commit-reveal voting interface used by the TCR to determine the validity of bugs\n', '  RestrictedPLCRVoting public voting;\n', '\n', '  // The underlying contract to hold PLCR voting parameters\n', '  Parameterizer public parameterizer;\n', '\n', '  // Recording reported bugs not yet awarded for each hunter\n', '  mapping (address => LinkedListLib.LinkedList) private hunterReportedBugs;\n', '  mapping (address => uint256) public hunterReportedBugsCount;\n', '\n', '  /**\n', '   * @dev The constructor creates a QuantstampBountyData contract.\n', '   * @param tokenAddress The address of a StandardToken that will be used to pay auditor nodes.\n', '   */\n', '  constructor (address tokenAddress, address votingAddress, address parameterizerAddress) public {\n', '    require(tokenAddress != address(0));\n', '    require(votingAddress != address(0));\n', '    require(parameterizerAddress != address(0));\n', '    token = StandardToken(tokenAddress);\n', '    voting = RestrictedPLCRVoting(votingAddress);\n', '    parameterizer = Parameterizer(parameterizerAddress);\n', '  }\n', '\n', '  // maps bountyIDs to list of corresponding bugIDs\n', '  // each list contains all revealed bugs for a given bounty, ordered by time\n', '  // NOTE: this cannot be part of the Bounty struct due to solidity limitations\n', '  mapping(uint256 => LinkedListLib.LinkedList) private bugLists;\n', '\n', '  // maps bugIDs to BugCommits\n', '  mapping(uint256 => BugCommit) public bugCommitMap;\n', '\n', '  // maps bugIDs to revealed bugs; uses the same ID as the bug commit\n', '  mapping(uint256 => Bug) public bugs;\n', '\n', '  function addBugCommitment(address hunter,\n', '                            uint256 bountyId,\n', '                            bytes32 bugDescriptionHash,\n', '                            uint256 hunterDeposit) public onlyWhitelisted returns (uint256) {\n', '    bugCounter = bugCounter.add(1);\n', '    bugCommitMap[bugCounter] = BugCommit({\n', '      hunter: hunter,\n', '      bountyId: bountyId,\n', '      bugDescriptionHash: bugDescriptionHash,\n', '      commitTimestamp: block.timestamp,\n', '      revealStartTimestamp: getBountyRevealPhaseStartTimestamp(bountyId),\n', '      revealEndTimestamp: getBountyRevealPhaseEndTimestamp(bountyId),\n', '      numTokens: hunterDeposit\n', '    });\n', '    return bugCounter;\n', '  }\n', '\n', '  function addBug(uint256 bugId, string bugDescription, uint256 pollId) public onlyWhitelisted returns (bool) {\n', '    // create a Bug\n', '    bugs[bugId] = Bug({\n', '      hunter: bugCommitMap[bugId].hunter,\n', '      bountyId: bugCommitMap[bugId].bountyId,\n', '      bugDescription: bugDescription,\n', '      numTokens: bugCommitMap[bugId].numTokens,\n', '      pollId: pollId\n', '    });\n', '    // add pointer to it in the corresponding bounty\n', '    bugLists[bugCommitMap[bugId].bountyId].push(bugId, PREV);\n', '    pollIdToBugId[pollId] = bugId;\n', '    return true;\n', '  }\n', '\n', '  function addBounty (address submitter,\n', '                      string contractAddress,\n', '                      uint256 size,\n', '                      uint256 minVotes,\n', '                      uint256 duration,\n', '                      uint256 judgeDeposit,\n', '                      uint256 hunterDeposit) public onlyWhitelisted returns(uint256) {\n', '    bounties[++bountyCounter] = Bounty(submitter,\n', '                                        contractAddress,\n', '                                        size,\n', '                                        minVotes,\n', '                                        duration,\n', '                                        judgeDeposit,\n', '                                        hunterDeposit,\n', '                                        block.timestamp,\n', '                                        false,\n', '                                        0);\n', '    return bountyCounter;\n', '  }\n', '\n', '  function removeBugCommitment(uint256 bugId) public onlyWhitelisted returns (bool) {\n', '    delete bugCommitMap[bugId];\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets a new value for the number of approved bugs, if appropriate\n', '   * @param pollId The ID of the poll being that a vote was received for\n', '   * @param wasPassing true if and only if more affirmative votes prior to this vote\n', '   * @param isPassing true if and only if more affirmative votes after this vote\n', '   * @param wasEnoughVotes true if and only if quorum was reached prior to this vote\n', '   */\n', '  function updateNumApprovedBugs(uint256 pollId, bool wasPassing, bool isPassing, bool wasEnoughVotes) public {\n', '    require(msg.sender == address(voting));\n', '    uint256 bountyId = getBugBountyId(getBugIdFromPollId(pollId));\n', '\n', '    if (wasEnoughVotes) {\n', '      if (!wasPassing && isPassing) {\n', '        bounties[bountyId].numApprovedBugs = bounties[bountyId].numApprovedBugs.add(1);\n', '      } else if (wasPassing && !isPassing) {\n', '        bounties[bountyId].numApprovedBugs = bounties[bountyId].numApprovedBugs.sub(1);\n', '      }\n', '    } else if (voting.isEnoughVotes(pollId) && isPassing) {\n', '      bounties[bountyId].numApprovedBugs = bounties[bountyId].numApprovedBugs.add(1);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Reports the number of approved bugs of a bounty\n', '   * @param bountyId The ID of the bounty.\n', '   */\n', '  function getNumApprovedBugs(uint256 bountyId) public view returns (uint256) {\n', '    return bounties[bountyId].numApprovedBugs;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets remainingFeesWithdrawn to true after the submitter withdraws.\n', '   * @param bountyId The ID of the bounty.\n', '   */\n', '  function setBountyRemainingFeesWithdrawn (uint256 bountyId) public onlyWhitelisted {\n', '    bounties[bountyId].remainingFeesWithdrawn = true;\n', '  }\n', '\n', '  function addBugToHunter (address hunter, uint256 bugId) public onlyWhitelisted {\n', '    hunterReportedBugs[hunter].push(bugId, PREV);\n', '    hunterReportedBugsCount[hunter] = hunterReportedBugsCount[hunter].add(1);\n', '  }\n', '\n', '  function removeBugFromHunter (address hunter, uint256 bugId) public onlyWhitelisted returns (bool) {\n', '    if (hunterReportedBugs[hunter].remove(bugId) != 0) {\n', '      hunterReportedBugsCount[hunter] = hunterReportedBugsCount[hunter].sub(1);\n', '      bugs[bugId].hunter = 0x0;\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function getListHeadConstant () public pure returns(uint256 head) {\n', '    return HEAD;\n', '  }\n', '\n', '  function getBountySubmitter (uint256 bountyId) public view returns(address) {\n', '    return bounties[bountyId].submitter;\n', '  }\n', '\n', '  function getBountyContractAddress (uint256 bountyId) public view returns(string) {\n', '    return bounties[bountyId].contractAddress;\n', '  }\n', '\n', '  function getBountySize (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].size;\n', '  }\n', '\n', '  function getBountyMinVotes (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].minVotes;\n', '  }\n', '\n', '  function getBountyDuration (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].duration;\n', '  }\n', '\n', '  function getBountyJudgeDeposit (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].judgeDeposit;\n', '  }\n', '\n', '  function getBountyHunterDeposit (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].hunterDeposit;\n', '  }\n', '\n', '  function getBountyInitiationTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].initiationTimestamp;\n', '  }\n', '\n', '  function getBountyCommitPhaseEndTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].initiationTimestamp.add(getBountyDuration(bountyId).div(NUMBER_OF_PHASES));\n', '  }\n', '\n', '  function getBountyRevealPhaseStartTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return getBountyCommitPhaseEndTimestamp(bountyId).add(1);\n', '  }\n', '\n', '  function getBountyRevealPhaseEndTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return getBountyCommitPhaseEndTimestamp(bountyId).add(getBountyDuration(bountyId).div(NUMBER_OF_PHASES));\n', '  }\n', '\n', '  function getBountyJudgePhaseStartTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return getBountyRevealPhaseEndTimestamp(bountyId).add(1);\n', '  }\n', '\n', '  function getBountyJudgePhaseEndTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    return bounties[bountyId].initiationTimestamp.add(getBountyDuration(bountyId));\n', '  }\n', '\n', '  function getBountyJudgeCommitPhaseEndTimestamp (uint256 bountyId) public view returns(uint256) {\n', '    uint256 judgePhaseDuration = getBountyDuration(bountyId).div(NUMBER_OF_PHASES);\n', '    return getBountyJudgePhaseStartTimestamp(bountyId).add(judgePhaseDuration.div(2));\n', '  }\n', '\n', '  function getBountyJudgeRevealDuration (uint256 bountyId) public view returns(uint256) {\n', '    return getBountyJudgePhaseEndTimestamp(bountyId).sub(getBountyJudgeCommitPhaseEndTimestamp(bountyId));\n', '  }\n', '\n', '  function isCommitPeriod (uint256 bountyId) public view returns(bool) {\n', '    return block.timestamp >= bounties[bountyId].initiationTimestamp && block.timestamp <= getBountyCommitPhaseEndTimestamp(bountyId);\n', '  }\n', '\n', '  function isRevealPeriod (uint256 bountyId) public view returns(bool) {\n', '    return block.timestamp >= getBountyRevealPhaseStartTimestamp(bountyId) && block.timestamp <= getBountyRevealPhaseEndTimestamp(bountyId);\n', '  }\n', '\n', '  function isJudgingPeriod (uint256 bountyId) public view returns(bool) {\n', '    return block.timestamp >= getBountyJudgePhaseStartTimestamp(bountyId) && block.timestamp <= getBountyJudgePhaseEndTimestamp(bountyId);\n', '  }\n', '\n', '  function getBountyRemainingFeesWithdrawn (uint256 bountyId) public view returns(bool) {\n', '    return bounties[bountyId].remainingFeesWithdrawn;\n', '  }\n', '\n', '  function getBugCommitCommitter(uint256 bugCommitId) public view returns (address) {\n', '    return bugCommitMap[bugCommitId].hunter;\n', '  }\n', '\n', '  function getBugCommitBountyId(uint256 bugCommitId) public view returns (uint256) {\n', '    return bugCommitMap[bugCommitId].bountyId;\n', '  }\n', '\n', '  function getBugCommitBugDescriptionHash(uint256 bugCommitId) public view returns (bytes32) {\n', '    return bugCommitMap[bugCommitId].bugDescriptionHash;\n', '  }\n', '\n', '  function getBugCommitCommitTimestamp(uint256 bugCommitId) public view returns (uint256) {\n', '    return bugCommitMap[bugCommitId].commitTimestamp;\n', '  }\n', '\n', '  function getBugCommitRevealStartTimestamp(uint256 bugCommitId) public view returns (uint256) {\n', '    return bugCommitMap[bugCommitId].revealStartTimestamp;\n', '  }\n', '\n', '  function getBugCommitRevealEndTimestamp(uint256 bugCommitId) public view returns (uint256) {\n', '    return bugCommitMap[bugCommitId].revealEndTimestamp;\n', '  }\n', '\n', '  function getBugCommitNumTokens(uint256 bugCommitId) public view returns (uint256) {\n', '    return bugCommitMap[bugCommitId].numTokens;\n', '  }\n', '\n', '  function bugRevealPeriodActive(uint256 bugCommitId) public view returns (bool) {\n', '    return bugCommitMap[bugCommitId].revealStartTimestamp <= block.timestamp && block.timestamp <= bugCommitMap[bugCommitId].revealEndTimestamp;\n', '  }\n', '\n', '  function bugRevealPeriodExpired(uint256 bugCommitId) public view returns (bool) {\n', '    return block.timestamp > bugCommitMap[bugCommitId].revealEndTimestamp;\n', '  }\n', '\n', '  function bugRevealDelayPeriodActive(uint256 bugCommitId) public view returns (bool) {\n', '    return block.timestamp < bugCommitMap[bugCommitId].revealStartTimestamp;\n', '  }\n', '\n', '  function bountyActive(uint256 bountyId) public view returns (bool) {\n', '    return block.timestamp <= getBountyInitiationTimestamp(bountyId).add(getBountyDuration(bountyId));\n', '  }\n', '\n', '  function getHunterReportedBugsCount (address hunter) public view returns (uint256) {\n', '    return hunterReportedBugsCount[hunter];\n', '  }\n', '\n', '  // Bug Functions\n', '  function getBugBountyId(uint256 bugId) public view returns (uint256) {\n', '    return bugs[bugId].bountyId;\n', '  }\n', '\n', '  function getBugHunter(uint256 bugId) public view returns (address) {\n', '    return bugs[bugId].hunter;\n', '  }\n', '\n', '  function getBugDescription(uint256 bugId) public view returns (string) {\n', '    return bugs[bugId].bugDescription;\n', '  }\n', '\n', '  function getBugNumTokens(uint256 bugId) public view returns (uint256) {\n', '    return bugs[bugId].numTokens;\n', '  }\n', '\n', '  function getBugPollId(uint256 bugId) public view returns (uint256) {\n', '    return bugs[bugId].pollId;\n', '  }\n', '\n', '  function getFirstRevealedBug(uint256 bountyId) public view returns (bool, uint256, string) {\n', '    return getNextRevealedBug(bountyId, HEAD);\n', '  }\n', '\n', '  function getBugIdFromPollId(uint256 pollId) public view returns (uint256) {\n', '    return pollIdToBugId[pollId];\n', '  }\n', '\n', '  /*\n', '   * @dev Gets the bug description of a revealed bug associated with a bounty\n', '   * @param bountyId The ID of the bounty\n', '   * @param previousBugId The ID of the previous bug in the linked list (HEAD for the first bug)\n', '   * @return a triple containing 1) whether the bug exists; 2) its bugId (0 if non-existent); 3) the description\n', '   */\n', '  function getNextRevealedBug(uint256 bountyId, uint256 previousBugId) public view returns (bool, uint256, string) {\n', '    if (!bugLists[bountyId].listExists()) {\n', '      return (false, 0, "");\n', '    }\n', '    uint256 bugId;\n', '    bool exists;\n', '    (exists, bugId) = bugLists[bountyId].getAdjacent(previousBugId, NEXT);\n', '    if (!exists || bugId == 0) {\n', '      return (false, 0, "");\n', '    }\n', '    string memory bugDescription = bugs[bugId].bugDescription;\n', '    return (true, bugId, bugDescription);\n', '  }\n', '\n', '  /**\n', '   * @dev Given a bugId, it retrieves the next bugId reported by a hunter. Such bugs have not been cashed yet.\n', '   * @param hunter The address of a hunter\n', '   * @param previousBugId The id of the previous reported bug. Passing 0, it returns the first reported bug.\n', '   */\n', '  function getNextBugFromHunter(address hunter, uint256 previousBugId) public view returns (bool, uint256) {\n', '    if (!hunterReportedBugs[hunter].listExists()) {\n', '      return (false, 0);\n', '    }\n', '    uint256 bugId;\n', '    bool exists;\n', '    (exists, bugId) = hunterReportedBugs[hunter].getAdjacent(previousBugId, NEXT);\n', '    if (!exists || bugId == 0) {\n', '      return (false, 0);\n', '    }\n', '    return (true, bugId);\n', '  }\n', '\n', '  /**\n', '   * @dev Determines if the judge meets the requirements to claim an award for voting in a poll\n', '   * @param bugId Id of a bug\n', '   * Note: moved to this contract as the Bounty contract was getting too large to deploy\n', '   */\n', '  function canClaimJudgeAward(address judge, uint256 bugId) public view returns (bool) {\n', '    // NOTE: these cannot be a require statement as this check occurs in a loop that should not fail\n', '    // the poll has concluded\n', '    uint256 pollId = getBugPollId(bugId);\n', '    bool pollHasConcluded = voting.pollExists(pollId) && voting.pollEnded(pollId);\n', '    // the judge voted in the majority\n', '    // this is needed to avoid hitting a require statement when in the minority in PLCRVoting\n', '    bool votedWithMajority = pollHasConcluded && voting.isEnoughVotes(pollId) &&\n', '      (voting.isPassed(pollId) && voting.hasVotedAffirmatively(judge, pollId) ||\n', '      !voting.isPassed(pollId) && !voting.hasVotedAffirmatively(judge, pollId));\n', '    // the judge should not have already claimed an award for this poll\n', '    bool alreadyClaimed = voting.hasVoterClaimedReward(judge, pollId);\n', '    // the bounty should be over\n', '    bool bountyStillActive = bountyActive(getBugBountyId(bugId));\n', '    return votedWithMajority && !alreadyClaimed && !bountyStillActive;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'Extends PLCR Voting to have restricted polls that can only be voted on by the TCR.\n', '*/\n', 'contract RestrictedPLCRVoting is PLCRVoting, Whitelist {\n', '\n', '  using SafeMath for uint256;\n', '  using LinkedListLib for LinkedListLib.LinkedList;\n', '\n', '  // constants used by LinkedListLib\n', '  uint256 constant internal NULL = 0;\n', '  uint256 constant internal HEAD = 0;\n', '  bool constant internal PREV = false;\n', '  bool constant internal NEXT = true;\n', '\n', '  // TCR used to list judge stakers.\n', '  Registry public judgeRegistry;\n', '\n', '  QuantstampBountyData public bountyData;\n', '\n', '  // Map that contains IDs of restricted polls that can only be voted on by the TCR\n', '  mapping(uint256 => bool) isRestrictedPoll;\n', '\n', '  // Map from IDs of restricted polls to the minimum number of votes needed for a bug to pass\n', '  mapping(uint256 => uint256) minimumVotes;\n', '\n', '  // Map from IDs of restricted polls to the amount a judge must deposit to vote\n', '  mapping(uint256 => uint256) judgeDeposit;\n', '\n', '  // Map from (voter x pollId) -> bool to determine whether a voter has already claimed a reward of a given poll\n', '  mapping(address => mapping(uint256 => bool)) private voterHasClaimedReward;\n', '\n', '  // Map from (voter x pollId) -> bool indicating whether a voter voted yes (true) or no (false) for a poll.\n', '  // Needed due to visibility issues with Poll structs in PLCRVoting\n', '  mapping(address => mapping(uint256 => bool)) private votedAffirmatively;\n', '\n', '  // Recording polls voted on but not yet awarded for each voter\n', '  mapping (address => LinkedListLib.LinkedList) private voterPolls;\n', '  mapping (address => uint256) public voterPollsCount;\n', '\n', '  event LogPollRestricted(uint256 pollId);\n', '\n', '  /**\n', '   * @dev Initializer. Can only be called once.\n', '   * @param _registry The address of the TCR registry\n', '   * @param _token The address of the token\n', '   */\n', '  function initialize(address _token, address _registry, address _bountyData) public {\n', '    require(_token != 0 && address(token) == 0);\n', '    require(_registry != 0 && address(judgeRegistry) == 0);\n', '    require(_bountyData != 0 && address(bountyData) == 0);\n', '    bountyData = QuantstampBountyData(_bountyData);\n', '    token = EIP20Interface(_token);\n', '    judgeRegistry = Registry(_registry);\n', '    pollNonce = INITIAL_POLL_NONCE;\n', '  }\n', '\n', '  /*\n', '   * @dev addr is of type Address which is 20 Bytes, but the TCR expects all\n', '   * entries to be of type Bytes32. addr is first cast to Uint256 so that it\n', '   * becomes 32 bytes long, addr is then shifted 12 bytes (96 bits) to the\n', '   * left so the 20 important bytes are in the correct spot.\n', '   * @param addr The address of the person who may be an judge.\n', '   * @return true If addr is on the TCR (is an judge)\n', '   */\n', '  function isJudge(address addr) public view returns(bool) {\n', '    return judgeRegistry.isWhitelisted(bytes32(uint256(addr) << 96));\n', '  }\n', '\n', '  /**\n', '   * @dev Set a poll to be restricted to TCR voting\n', '   * @param _pollId The ID of the poll\n', '   * @param _minimumVotes The minimum number of votes needed for the vote to go through. Each voter counts as 1 vote (not weighted).\n', '   * @param _judgeDepositAmount The deposit of a judge to vote\n', '   */\n', '  function restrictPoll(uint256 _pollId, uint256 _minimumVotes, uint256 _judgeDepositAmount) public onlyWhitelisted {\n', '    isRestrictedPoll[_pollId] = true;\n', '    minimumVotes[_pollId] = _minimumVotes;\n', '    judgeDeposit[_pollId] = _judgeDepositAmount;\n', '    emit LogPollRestricted(_pollId);\n', '  }\n', '\n', '  /**\n', '   * @dev Set that a voter has claimed a reward for voting with the majority\n', '   * @param _voter The address of the voter\n', '   * @param _pollID Integer identifier associated with target poll\n', '   */\n', '  function setVoterClaimedReward(address _voter, uint256 _pollID) public onlyWhitelisted {\n', '    voterHasClaimedReward[_voter][_pollID] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines whether a restricted poll has met the minimum vote requirements\n', '   * @param _pollId The ID of the poll\n', '   */\n', '  function isEnoughVotes(uint256 _pollId) public view returns (bool) {\n', '    return pollMap[_pollId].votesFor.add(pollMap[_pollId].votesAgainst) >= minimumVotes[_pollId].mul(judgeDeposit[_pollId]);\n', '  }\n', '\n', '  // Overridden methods from PLCRVoting. Needed for special requirements of the bounty protocol\n', '\n', '  /**\n', '  * @dev Overridden Initializer from PLCR Voting. Always reverts to ensure the registry is initialized in the above initialize function.\n', '  * @param _token The address of the token\n', '  */\n', '  function init(address _token) public {\n', '    require(false);\n', '  }\n', '\n', '  /**\n', '   * @dev Overrides PLCRVoting to only allow TCR members to vote on restricted votes.\n', '   *      Commits vote using hash of choice and secret salt to conceal vote until reveal.\n', '   * @param _pollID Integer identifier associated with target poll\n', "   * @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)\n", '   * @param _numTokens The number of tokens to be committed towards the target poll\n', '   * @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '   */\n', '  function commitVote(uint256 _pollID, bytes32 _secretHash, uint256 _numTokens, uint256 _prevPollID) public {\n', '    if (isRestrictedPoll[_pollID]) {\n', '      require(isJudge(msg.sender));\n', "      // Note: The PLCR weights votes by numTokens, so here we use strict equality rather than '>='\n", '      // This must be accounted for when tallying votes.\n', '      require(_numTokens == judgeDeposit[_pollID]);\n', '      require(bountyData.isJudgingPeriod(bountyData.getBugBountyId(bountyData.getBugIdFromPollId(_pollID))));\n', '    }\n', '    super.commitVote(_pollID, _secretHash, _numTokens, _prevPollID);\n', '  }\n', '\n', '  /**\n', '   * @dev Overrides PLCRVoting to track which polls are associated with a voter.\n', '   * @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\n', '   * @param _pollID Integer identifier associated with target poll\n', '   * @param _voteOption Vote choice used to generate commitHash for associated poll\n', '   * @param _salt Secret number used to generate commitHash for associated poll\n', '   */\n', '  function revealVote(uint256 _pollID, uint256 _voteOption, uint256 _salt) public {\n', '    address voter = msg.sender;\n', '    // record the vote\n', '    if (_voteOption == 1) {\n', '      votedAffirmatively[voter][_pollID] = true;\n', '    }\n', '    // do not allow multiple votes for the same poll\n', '    require(!voterPolls[voter].nodeExists(_pollID));\n', '    bool wasPassing = isPassing(_pollID);\n', '    bool wasEnoughVotes = isEnoughVotes(_pollID);\n', '    voterPolls[voter].push(_pollID, PREV);\n', '    voterPollsCount[voter] = voterPollsCount[voter].add(1);\n', '    super.revealVote(_pollID, _voteOption, _salt);\n', '    bool voteIsPassing = isPassing(_pollID);\n', '    bountyData.updateNumApprovedBugs(_pollID, wasPassing, voteIsPassing, wasEnoughVotes);\n', '  }\n', '\n', '  function removePollFromVoter (address _voter, uint256 _pollID) public onlyWhitelisted returns (bool) {\n', '    if (voterPolls[_voter].remove(_pollID) != 0) {\n', '      voterPollsCount[_voter] = voterPollsCount[_voter] - 1;\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines if proposal has more affirmative votes\n', '   *      Check if votesFor out of totalVotes exceeds votesQuorum (does not require pollEnded)\n', '   * @param _pollID Integer identifier associated with target poll\n', '   */\n', '  function isPassing(uint _pollID) public view returns (bool) {\n', '    Poll memory poll = pollMap[_pollID];\n', '    return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the total winning votes for reward distribution purposes.\n', '   *      Returns 0 if there were not enough votes.\n', '   * @param _pollID Integer identifier associated with target poll\n', '   * @return Total number of votes committed to the winning option for specified poll\n', '   */\n', '  function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint256) {\n', '    if (isRestrictedPoll[_pollID] && !isEnoughVotes(_pollID)) {\n', '      return 0;\n', '    }\n', '    return super.getTotalNumberOfTokensForWinningOption(_pollID);\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the number of tokens allocated toward the winning vote for a particular voter.\n', '   *      Zero if there were not enough votes for a restricted poll.\n', '   * @param _voter Address of voter who voted in the majority bloc\n', '   * @param _pollID Integer identifier associated with target poll\n', '   * @return correctVotes Number of tokens voted for winning option\n', '   */\n', '  function getNumPassingTokens(address _voter, uint _pollID) public constant returns (uint256) {\n', '    if (isRestrictedPoll[_pollID] && !isEnoughVotes(_pollID)) {\n', '      return 0;\n', '    }\n', '    return super.getNumPassingTokens(_voter, _pollID);\n', '  }\n', '\n', '  /**\n', '   * @dev Determines if proposal has passed\n', '   *      Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\n', '   * @param _pollID Integer identifier associated with target poll\n', '   */\n', '  function isPassed(uint _pollID) constant public returns (bool) {\n', '    if (isRestrictedPoll[_pollID] && !isEnoughVotes(_pollID)) {\n', '      return false;\n', '    }\n', '    return super.isPassed(_pollID);\n', '  }\n', '\n', '  /**\n', '   * @dev Determines if a voter has already claimed a reward for voting with the majority\n', '   * @param _voter The address of the voter\n', '   * @param _pollID Integer identifier associated with target poll\n', '   */\n', '  function hasVoterClaimedReward(address _voter, uint256 _pollID) public view returns (bool) {\n', '    return voterHasClaimedReward[_voter][_pollID];\n', '  }\n', '\n', '  /**\n', '   * @dev Determines if a voter voted yes or no for a poll\n', '   * @param _voter The address of the voter\n', '   * @param _pollID Integer identifier associated with target poll\n', '   */\n', '  function hasVotedAffirmatively(address _voter, uint256 _pollID) public view returns (bool) {\n', '    return votedAffirmatively[_voter][_pollID];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of unclaimed polls associated with the voter.\n', '   * @param _voter The address of the voter\n', '   */\n', '  function getVoterPollsCount (address _voter) public view returns (uint256) {\n', '    return voterPollsCount[_voter];\n', '  }\n', '\n', '  function getListHeadConstant () public pure returns(uint256 head) {\n', '    return HEAD;\n', '  }\n', '\n', '  /**\n', '   * @dev Given a pollID, it retrieves the next pollID voted on but unclaimed by the voter.\n', '   * @param _voter The address of the voter\n', '   * @param _prevPollID The id of the previous unclaimed poll. Passing 0, it returns the first poll.\n', '   */\n', '  function getNextPollFromVoter(address _voter, uint256 _prevPollID) public view returns (bool, uint256) {\n', '    if (!voterPolls[_voter].listExists()) {\n', '      return (false, 0);\n', '    }\n', '    uint256 pollID;\n', '    bool exists;\n', '    (exists, pollID) = voterPolls[_voter].getAdjacent(_prevPollID, NEXT);\n', '    if (!exists || pollID == 0) {\n', '      return (false, 0);\n', '    }\n', '    return (true, pollID);\n', '  }\n', '}\n', ' //Imports SafeMath']