['pragma solidity ^0.4.19;\n', '\n', "//--------- OpenZeppelin's Safe Math\n", '//Source : https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  \tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '  \tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    \tuint256 c = a / b;\n', '    \treturn c;\n', '  \t}\n', '\n', '  \tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    \tassert(b <= a);\n', '    \treturn a - b;\n', '  \t}\n', '\n', '  \tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    \tuint256 c = a + b;\n', '    \tassert(c >= a);\n', '    \treturn c;\n', '  \t}\n', '}\n', '//-----------------------------------------------------B\n', '\n', '\n', '//"EXTERN" CONTRACTS\n', '//============================\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  \tfunction transfer(address _to, uint256 _value) public returns (bool success);\n', '  \tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n', '}\n', '\n', 'contract Viscous {\n', '    function is_whitelisted(address) constant returns (bool);\n', '}\n', '//============================\n', '\n', 'contract Controller {\n', '\n', '\taddress public owner;\n', '  \t//event ChangeOwner(address new_owner);\n', '\n', '\tmodifier onlyOwner {\n', '    \trequire(msg.sender == owner);\n', '    \t_;\n', '  \t}\n', '\n', '  \tfunction change_owner(address new_owner) onlyOwner {\n', '    \trequire(new_owner != 0x0);\n', '    \towner = new_owner;\n', '    \t//ChangeOwner(new_owner);\n', '  \t}\n', '\n', '  \tfunction Controller() {\n', '    \towner = msg.sender;\n', '  \t}\n', '}\n', '\n', 'contract Contract is Controller {\n', '\n', '  //EVENTS\n', '  //============================\n', '  /* event BuyTheTokens(address sale, uint256 amount, bytes data);\n', '  event Whitelist(bool boolean);\n', '  event Contribution(address sender, uint256 amount, uint256 total_amount, uint256 contract_balance);\n', '  event Withdraw(address sender, uint256 amount);\n', '  event Refund(address sender, uint256 amount, uint256 total_amount, uint256 contract_balance); */\n', '  //============================\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '  \tstruct Contributor {\n', '\t\tuint256 balance;\n', '\t    uint256 fee;\n', '\t    uint8 rounds;\n', '\t    bool whitelisted;\n', '  \t}\n', '\n', '\tstruct Snapshot {\n', '\t\tuint256 tokens_balance;\n', '\t\tuint256 eth_balance;\n', '\t}\n', '\n', '\tmodifier minAmountReached {\n', '\t\trequire(this.balance >= min_amount);\n', '\t\t_;\n', '\t}\n', '\n', '  \tmodifier underMaxAmount {\n', '    \trequire(max_amount == 0 || this.balance <= max_amount);\n', '    \t_;\n', '  \t}\n', '\n', '\t//FEES RELATED\n', '\t//============================\n', '\taddress constant public DEVELOPER1 = 0x8C006d807EBAe91F341a4308132Fd756808e0126;\n', '\taddress constant public DEVELOPER2 = 0x63F7547Ac277ea0B52A0B060Be6af8C5904953aa;\n', '\tuint256 constant public FEE_DEV = 670; //0.2% fee per dev -> so 0.4% fee in total\n', '\t//============================\n', '\n', '\t//VARIABLES TO BE CHANGED BY OWNER\n', '\t//============================\n', '\tuint256 public FEE_OWNER; //value as divisor (ie. 1 / FEE_OWNER = % Rate) or (1 / 200 = 0.4%)\n', '\tuint256 public max_amount;  //0 means there is no limit\n', '\tuint256 public min_amount;\n', '\tuint256 public individual_cap;\n', '\tuint256 public gas_price_max;\n', '\tuint8 public rounds;\n', '\t//flag controlled by owner to enable/disable whitelists for viscous or temporary whitelist\n', '\tbool public whitelist_enabled;\n', '\t//Contract containing the data\n', '\tViscous public viscous_contract = Viscous(0x0);\n', '\t//============================\n', '\n', '  //###############################################################################################################################\n', '\n', '\t//CONTRACT VARIABLES\n', '\t//============================\n', '\t//=== ARRAYS & MAPPINGS ===\n', '\tmapping (address => Contributor) public contributors;\n', '\t//First element will be the first wave of tokens, and so forth\n', '\tSnapshot[] public snapshots;\n', '\n', '\t//=== UINT ===\n', '\t// Record ETH value of tokens currently held by contract.\n', '\tuint256 public const_contract_eth_value;\n', '\t//The reduction of the allocation in % | example : 40 -> 40% reduction\n', '\tuint256 public percent_reduction;\n', '\n', '\t//=== ADDRESSES ===\n', '\t//The address of the contact.\n', '\taddress public sale;\n', '\t//Token address\n', '\tERC20 public token;\n', '\t//=== BOOLS ===\n', '\t//Track whether the contract has bought the tokens yet.\n', '\tbool public bought_tokens;\n', '\t//Track if the owner partially refunds his fee in the event of a partial refund post-buy\n', '\tbool public owner_supplied_eth;\n', '\tbool public allow_contributions = true;\n', '  //============================\n', '\n', '\tfunction Contract(\n', '\t\tuint256 _max_amount,\n', '\t\tuint256 _min_amount,\n', '\t\tbool _whitelist,\n', '\t\tuint256 _owner_fee_divisor\n', '\t\t) {\n', '\t\t\tmax_amount = calculate_with_fees(_max_amount);  //0 means there is no limit\n', '\t\t  \tmin_amount = calculate_with_fees(_min_amount);\n', '\t\t  \twhitelist_enabled = _whitelist;\n', '\t\t  \tFEE_OWNER = _owner_fee_divisor;\n', '\t\t  \tContributor storage contributor = contributors[msg.sender];\n', '\t\t  \tcontributor.whitelisted = true;\n', '  \t\t}\n', '\n', '  //###############################################################################################################################\n', '\n', '\t//OWNER FUNCTIONS\n', '\t//============================\n', '\t// Buy the tokens. Sends ETH to the presale wallet and records the ETH amount held in the contract.\n', '\tfunction buy_the_tokens(bytes _data) onlyOwner minAmountReached {\n', '\t\t//Avoids burning the funds\n', '\t\trequire(!bought_tokens && sale != 0x0);\n', '\t\t//Record that the contract has bought the tokens.\n', '\t\tbought_tokens = true;\n', '\t\tconst_contract_eth_value = this.balance;\n', '\t\ttake_fees_eth_dev();\n', '\t\ttake_fees_eth_owner();\n', "\t\t//Record the amount of ETH sent as the contract's current value.\n", '\t\tconst_contract_eth_value = this.balance;\n', '\t\t// Transfer all the funds to the crowdsale address.\n', '\t\trequire(sale.call.gas(msg.gas).value(this.balance)(_data));\n', '\t\t//BuyTheTokens(sale, const_contract_eth_value, _data);\n', '\t}\n', '\n', '\t//These two functions concern the "temporary" whitelist\n', '\tfunction whitelist_addys(address[] _addys) onlyOwner {\n', '\t\tfor (uint256 i = 0; i < _addys.length; i++) {\n', '\t\t\tContributor storage contributor = contributors[_addys[i]];\n', '\t\t\tcontributor.whitelisted = true;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction blacklist_addys(address[] _addys) onlyOwner {\n', '\t\tfor (uint256 i = 0; i < _addys.length; i++) {\n', '\t\t\tContributor storage contributor = contributors[_addys[i]];\n', '\t\t\tcontributor.whitelisted = false;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction set_gas_price_max(uint256 _gas_price) onlyOwner {\n', '\t\tgas_price_max = _gas_price;\n', '\t}\n', '\n', '\tfunction set_sale_address(address _sale) onlyOwner {\n', '\t\t//Avoid mistake of putting 0x0\n', '\t\trequire(_sale != 0x0);\n', '\t\tsale = _sale;\n', '\t}\n', '\n', '\tfunction set_token_address(address _token) onlyOwner {\n', '\t\trequire(_token != 0x0);\n', '\t\ttoken = ERC20(_token);\n', '\t}\n', '\n', '\tfunction set_allow_contributions(bool _boolean) onlyOwner {\n', '\t\tallow_contributions = _boolean;\n', '\t}\n', '\n', '\tfunction set_tokens_received() onlyOwner {\n', '\t\ttokens_received();\n', '\t}\n', '\n', '\tfunction set_percent_reduction(uint256 _reduction) onlyOwner payable {\n', '\t\trequire(bought_tokens && rounds == 0 && _reduction <= 100);\n', '\t\tpercent_reduction = _reduction;\n', '\t\tif (msg.value > 0) {\n', '\t\t\towner_supplied_eth = true;\n', '\t\t}\n', '\t\t//we substract by contract_eth_value*_reduction basically\n', '\t\tconst_contract_eth_value = const_contract_eth_value.sub((const_contract_eth_value.mul(_reduction)).div(100));\n', '\t}\n', '\n', '\tfunction set_whitelist_enabled(bool _boolean) onlyOwner {\n', '\t\twhitelist_enabled = _boolean;\n', '\t\t//Whitelist(_boolean);\n', '\t}\n', '\n', '\tfunction change_viscous_contract(address _addy) onlyOwner {\n', '\t\tviscous_contract = Viscous(_addy);\n', '\t}\n', '\n', '\tfunction change_individual_cap(uint256 _cap) onlyOwner {\n', '\t\tindividual_cap = _cap;\n', '\t}\n', '\n', '\tfunction change_max_amount(uint256 _amount) onlyOwner {\n', '\t\t//ATTENTION! The new amount should be in wei\n', '\t\t//Use https://etherconverter.online/\n', '\t\tmax_amount = calculate_with_fees(_amount);\n', '\t}\n', '\n', '\tfunction change_min_amount(uint256 _amount) onlyOwner {\n', '\t\t//ATTENTION! The new amount should be in wei\n', '\t\t//Use https://etherconverter.online/\n', '\t\tmin_amount = calculate_with_fees(_amount);\n', '\t}\n', '\n', '\tfunction change_fee(uint256 _fee) onlyOwner {\n', '\t\tFEE_OWNER = _fee;\n', '\t}\n', '\n', '\tfunction emergency_token_withdraw(address _address) onlyOwner {\n', '\t \tERC20 temp_token = ERC20(_address);\n', '\t\trequire(temp_token.transfer(msg.sender, temp_token.balanceOf(this)));\n', '\t}\n', '\n', '\tfunction emergency_eth_withdraw() onlyOwner {\n', '\t\tmsg.sender.transfer(this.balance);\n', '\t}\n', '\n', '//###############################################################################################################################\n', '\n', '\n', '\t//INTERNAL FUNCTIONS\n', '\t//============================\n', '\t// Allows any user to withdraw his tokens.\n', '\tfunction withdraw(address _user) internal {\n', "\t\t// Disallow withdraw if tokens haven't been bought yet.\n", '\t\trequire(bought_tokens);\n', '\t\tuint256 contract_token_balance = token.balanceOf(address(this));\n', '\t\t// Disallow token withdrawals if there are no tokens to withdraw.\n', '\t\trequire(contract_token_balance != 0);\n', '\t\tContributor storage contributor = contributors[_user];\n', '\t\tif (contributor.rounds < rounds) {\n', "            //contributor can claim his bonus tokens of previous rounds if he didn't withdrawn\n", '            //uint256 this_contribution_claim = (rounds-contributor.rounds)*contributor.balance;\n', '\t\t\tSnapshot storage snapshot = snapshots[contributor.rounds];\n', '            uint256 tokens_to_withdraw = contributor.balance.mul(snapshot.tokens_balance).div(snapshot.eth_balance);\n', '\t\t\tsnapshot.tokens_balance = snapshot.tokens_balance.sub(tokens_to_withdraw);\n', '\t\t\tsnapshot.eth_balance = snapshot.eth_balance.sub(contributor.balance);\n', '            // Update the value of tokens currently held by the contract.\n', '            //contract_eth_value -= contributor.balance;\n', '            contributor.rounds++;\n', '            // Send the funds.  Throws on failure to prevent loss of funds.\n', '            require(token.transfer(_user, tokens_to_withdraw));\n', '            //Withdraw(_user, tokens_to_withdraw);\n', '        }\n', '\t}\n', '\n', '\t// Allows any user to get his eth refunded before the purchase is made.\n', '\tfunction refund(address _user) internal {\n', '\t\trequire(!bought_tokens && percent_reduction == 0);\n', '\t\tContributor storage contributor = contributors[_user];\n', '\t\tuint256 eth_to_withdraw = contributor.balance.add(contributor.fee);\n', "\t\t// Update the user's balance prior to sending ETH to prevent recursive call.\n", '\t\tcontributor.balance = 0;\n', '\t\tcontributor.fee = 0;\n', "\t\t// Return the user's funds.  Throws on failure to prevent loss of funds.\n", '\t\t_user.transfer(eth_to_withdraw);\n', '\t\t//Refund(_user, eth_to_withdraw, contributor.balance, this.balance);\n', '\t}\n', '\n', '\t//Allows any user to get a part of his ETH refunded, in proportion\n', '\t//to the % reduced of the allocation\n', '\tfunction partial_refund(address _user) internal {\n', '\t\trequire(bought_tokens && rounds == 0 && percent_reduction > 0);\n', '\t\tContributor storage contributor = contributors[_user];\n', '\t\trequire(contributor.rounds == 0);\n', '\t\tuint256 eth_to_withdraw = contributor.balance.mul(percent_reduction).div(100);\n', '\t\tcontributor.balance = contributor.balance.sub(eth_to_withdraw);\n', '\t\tif (owner_supplied_eth) {\n', "\t\t\t//dev fees aren't refunded, only owner fees\n", "\t\t\t//We don't care about updatng contributor's fee, it doesn't matter for receiving the tokens\n", '\t\t\tuint256 fee = contributor.fee.mul(percent_reduction).div(100);\n', '\t\t\teth_to_withdraw = eth_to_withdraw.add(fee);\n', '\t\t}\n', '\t\t_user.transfer(eth_to_withdraw);\n', '\t\t//Refund(_user, eth_to_withdraw, contributor.balance, this.balance);\n', '\t}\n', '\n', '\tfunction take_fees_eth_dev() internal {\n', '\t\tif (FEE_DEV != 0) {\n', '\t\t\tDEVELOPER1.transfer(const_contract_eth_value.div(FEE_DEV));\n', '\t\t\tDEVELOPER2.transfer(const_contract_eth_value.div(FEE_DEV));\n', '\t\t}\n', '\t}\n', '\n', '\tfunction take_fees_eth_owner() internal {\n', '\t//Owner takes fees on the ETH in this case\n', "\t//In case owner doesn't want to take fees\n", '\t\tif (FEE_OWNER != 0) {\n', '\t\t\towner.transfer(const_contract_eth_value.div(FEE_OWNER));\n', '\t\t}\n', '\t}\n', '\n', '\tfunction calculate_with_fees(uint256 _amount) internal returns (uint256) {\n', '\t\t//divided by two because 2 devs, so 0.4% in total\n', '\t\tuint256 temp = _amount;\n', '\t\tif (FEE_DEV != 0) {\n', '\t\t\ttemp = temp.add(_amount.div(FEE_DEV/2));\n', '\t\t}\n', '\t\tif (FEE_OWNER != 0) {\n', '\t\t\ttemp = temp.add(_amount.div(FEE_OWNER));\n', '\t\t}\n', '\t\treturn temp;\n', '\t}\n', '\n', '\tfunction tokens_received() internal {\n', '\t\t//We need to check the previous token balance\n', '\t\tuint256 previous_balance;\n', '\t\tfor (uint8 i = 0; i < snapshots.length; i++) {\n', '\t\t\tprevious_balance = previous_balance.add(snapshots[i].tokens_balance);\n', '\t\t}\n', '\t\tsnapshots.push(Snapshot(token.balanceOf(address(this)).sub(previous_balance), const_contract_eth_value));\n', "\t\t//we don't leave out the tokens that didn't get withdrawn\n", '\t\trounds++;\n', '\t}\n', '\n', '\n', '//###############################################################################################################################\n', '\n', '  //PUBLIC FUNCTIONS\n', '  //============================\n', '\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '\t\tif (ERC20(msg.sender) == token) {\n', '\t\t\ttokens_received();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction withdraw_my_tokens() {\n', '\t\tfor (uint8 i = contributors[msg.sender].rounds; i < rounds; i++) {\n', '\t\t\twithdraw(msg.sender);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction withdraw_tokens_for(address _addy) {\n', '\t\tfor (uint8 i = contributors[_addy].rounds; i < rounds; i++) {\n', '\t\t\twithdraw(_addy);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction refund_my_ether() {\n', '\t\trefund(msg.sender);\n', '\t}\n', '\n', '\tfunction partial_refund_my_ether() {\n', '\t\tpartial_refund(msg.sender);\n', '\t}\n', '\n', '\tfunction provide_eth() payable {}\n', '\n', '\t// Default function.  Called when a user sends ETH to the contract.\n', '\tfunction () payable underMaxAmount {\n', '\t\trequire(!bought_tokens && allow_contributions && (gas_price_max == 0 || tx.gasprice <= gas_price_max));\n', '\t\tContributor storage contributor = contributors[msg.sender];\n', '\t\t//Checks if contributor is whitelisted\n', '\t\tif (whitelist_enabled) {\n', '\t\t\trequire(contributor.whitelisted || viscous_contract.is_whitelisted(msg.sender));\n', '\t\t}\n', '\t\t//Manages cases of dev and/or owner taking fees\n', '\t\t//"Worst case", substract 0 from the msg.value\n', '\t\tuint256 fee = 0;\n', '\t\tif (FEE_OWNER != 0) {\n', '\t\t\tfee = SafeMath.div(msg.value, FEE_OWNER);\n', '\t\t}\n', '\t\tuint256 fees = fee;\n', '\t\tif (FEE_DEV != 0) {\n', '\t\t\tfee = msg.value.div(FEE_DEV/2);\n', '\t\t\tfees = fees.add(fee);\n', '\t\t}\n', '\t\t//Updates both of the balances\n', '\t\tcontributor.balance = contributor.balance.add(msg.value).sub(fees);\n', '\t\tcontributor.fee = contributor.fee.add(fees);\n', '\n', '\t\t//Checks if the individual cap is respected\n', "\t\t//If it's not, changes are reverted\n", '\t\trequire(individual_cap == 0 || contributor.balance <= individual_cap);\n', '\t\t//Contribution(msg.sender, msg.value, contributor.balance, this.balance);\n', '\t}\n', '}']