['pragma solidity 0.4.24;\n', '\n', 'contract Kitties {\n', '\n', '    function ownerOf(uint id) public view returns (address);\n', '\n', '}\n', '\n', 'contract ICollectable {\n', '\n', '    function mint(uint32 delegateID, address to) public returns (uint);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '}\n', '\n', 'contract IAuction {\n', '\n', '    function getAuction(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 startingPrice,\n', '        uint256 endingPrice,\n', '        uint256 duration,\n', '        uint256 startedAt);\n', '}\n', '\n', 'contract IPack {\n', '\n', '    function purchase(uint16, address) public payable;\n', '    function purchaseFor(address, uint16, address) public payable;\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '\n', '    function getOwner() public view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract CatInThePack is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // the pack of GU cards which will be purchased\n', '    IPack public pack;\n', '    // the core CK contract\n', '    Kitties public kitties;\n', '    // the core GU collectable contract\n', '    ICollectable public collectables;\n', '    // the list of CK auction contracts, usually [Sale, Sire]\n', '    IAuction[] public auctions;\n', '    \n', '    // whether it is currently possible to claim cats\n', '    bool public canClaim = true;\n', '    // the collectable delegate id \n', '    uint32 public delegateID;\n', '    // whether the contract is locked (i.e. no more claiming)\n', '    bool public locked = false;\n', '    // whether kitties on auction are considered to be owned by the sender\n', '    bool public includeAuctions = true;\n', '    // contract where funds will be sent\n', '    address public vault;\n', '    // max number of kitties per call\n', '    uint public claimLimit = 20;\n', '    // price per statue\n', '    uint public price = 0.024 ether;\n', '    \n', '    \n', '    // map to track whether a kitty has been claimed\n', '    mapping(uint => bool) public claimed;\n', '    // map from statue id to kitty id\n', '    mapping(uint => uint) public statues;\n', '\n', '    constructor(IPack _pack, IAuction[] memory _auctions, Kitties _kitties, \n', '        ICollectable _collectables, uint32 _delegateID, address _vault) public {\n', '        pack = _pack;\n', '        auctions = _auctions;\n', '        kitties = _kitties;\n', '        collectables = _collectables;\n', '        delegateID = _delegateID;\n', '        vault = _vault;\n', '    }\n', '\n', '    event CatsClaimed(uint[] statueIDs, uint[] kittyIDs);\n', '\n', '    // claim statues tied to the following kittyIDs\n', '    function claim(uint[] memory kittyIDs, address referrer) public payable returns (uint[] memory ids) {\n', '\n', '        require(canClaim, "claiming not enabled");\n', '        require(kittyIDs.length > 0, "you must claim at least one cat");\n', '        require(claimLimit >= kittyIDs.length, "must claim >= the claim limit at a time");\n', '        \n', '        // statue id array\n', '        ids = new uint[](kittyIDs.length);\n', '        \n', '        for (uint i = 0; i < kittyIDs.length; i++) {\n', '\n', '            uint kittyID = kittyIDs[i];\n', '\n', '            // mark the kitty as being claimed\n', '            require(!claimed[kittyID], "kitty must not be claimed");\n', '            claimed[kittyID] = true;\n', '\n', '            require(ownsOrSelling(kittyID), "you must own all the cats you claim");\n', '\n', '            // create the statue token\n', '            uint id = collectables.mint(delegateID, msg.sender);\n', '            ids[i] = id;\n', '            // record which kitty is associated with this statue\n', '            statues[id] = kittyID;    \n', '        }\n', '        \n', '        // calculate the total purchase price\n', '        uint totalPrice = price.mul(kittyIDs.length);\n', '\n', '        require(msg.value >= totalPrice, "wrong value sent to contract");\n', '       \n', '        uint half = totalPrice.div(2);\n', '\n', '        // send half the price to buy the packs\n', '        pack.purchaseFor.value(half)(msg.sender, uint16(kittyIDs.length), referrer); \n', '\n', '        // send the other half directly to the vault contract\n', '        vault.transfer(half);\n', '\n', '        emit CatsClaimed(ids, kittyIDs);\n', '        \n', '        return ids;\n', '    }\n', '\n', '    // returns whether the msg.sender owns or is auctioning a kitty\n', '    function ownsOrSelling(uint kittyID) public view returns (bool) {\n', '        // call to the core CK contract to find the owner of the kitty\n', '        address owner = kitties.ownerOf(kittyID);\n', '        if (owner == msg.sender) {\n', '            return true;\n', '        } \n', '        // check whether we are including the auction contracts\n', '        if (includeAuctions) {\n', '            address seller;\n', '            for (uint i = 0; i < auctions.length; i++) {\n', '                IAuction auction = auctions[i];\n', '                // make sure you check that this cat is owned by the auction \n', '                // before calling the method, or getAuction will throw\n', '                if (owner == address(auction)) {\n', '                    (seller, , , ,) = auction.getAuction(kittyID);\n', '                    return seller == msg.sender;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', ' \n', '    function setCanClaim(bool _can, bool lock) public onlyOwner {\n', '        require(!locked, "claiming is permanently locked");\n', '        if (lock) {\n', '            require(!_can, "can&#39;t lock on permanently");\n', '            locked = true;\n', '        }\n', '        canClaim = _can;\n', '    }\n', '\n', '    function getKitty(uint statueID) public view returns (uint) {\n', '        return statues[statueID];\n', '    }\n', '\n', '    function setClaimLimit(uint limit) public onlyOwner {\n', '        claimLimit = limit;\n', '    }\n', '\n', '    function setIncludeAuctions(bool _include) public onlyOwner {\n', '        includeAuctions = _include;\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract Kitties {\n', '\n', '    function ownerOf(uint id) public view returns (address);\n', '\n', '}\n', '\n', 'contract ICollectable {\n', '\n', '    function mint(uint32 delegateID, address to) public returns (uint);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '}\n', '\n', 'contract IAuction {\n', '\n', '    function getAuction(uint256 _tokenId)\n', '        external\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 startingPrice,\n', '        uint256 endingPrice,\n', '        uint256 duration,\n', '        uint256 startedAt);\n', '}\n', '\n', 'contract IPack {\n', '\n', '    function purchase(uint16, address) public payable;\n', '    function purchaseFor(address, uint16, address) public payable;\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '\n', '    function getOwner() public view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract CatInThePack is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // the pack of GU cards which will be purchased\n', '    IPack public pack;\n', '    // the core CK contract\n', '    Kitties public kitties;\n', '    // the core GU collectable contract\n', '    ICollectable public collectables;\n', '    // the list of CK auction contracts, usually [Sale, Sire]\n', '    IAuction[] public auctions;\n', '    \n', '    // whether it is currently possible to claim cats\n', '    bool public canClaim = true;\n', '    // the collectable delegate id \n', '    uint32 public delegateID;\n', '    // whether the contract is locked (i.e. no more claiming)\n', '    bool public locked = false;\n', '    // whether kitties on auction are considered to be owned by the sender\n', '    bool public includeAuctions = true;\n', '    // contract where funds will be sent\n', '    address public vault;\n', '    // max number of kitties per call\n', '    uint public claimLimit = 20;\n', '    // price per statue\n', '    uint public price = 0.024 ether;\n', '    \n', '    \n', '    // map to track whether a kitty has been claimed\n', '    mapping(uint => bool) public claimed;\n', '    // map from statue id to kitty id\n', '    mapping(uint => uint) public statues;\n', '\n', '    constructor(IPack _pack, IAuction[] memory _auctions, Kitties _kitties, \n', '        ICollectable _collectables, uint32 _delegateID, address _vault) public {\n', '        pack = _pack;\n', '        auctions = _auctions;\n', '        kitties = _kitties;\n', '        collectables = _collectables;\n', '        delegateID = _delegateID;\n', '        vault = _vault;\n', '    }\n', '\n', '    event CatsClaimed(uint[] statueIDs, uint[] kittyIDs);\n', '\n', '    // claim statues tied to the following kittyIDs\n', '    function claim(uint[] memory kittyIDs, address referrer) public payable returns (uint[] memory ids) {\n', '\n', '        require(canClaim, "claiming not enabled");\n', '        require(kittyIDs.length > 0, "you must claim at least one cat");\n', '        require(claimLimit >= kittyIDs.length, "must claim >= the claim limit at a time");\n', '        \n', '        // statue id array\n', '        ids = new uint[](kittyIDs.length);\n', '        \n', '        for (uint i = 0; i < kittyIDs.length; i++) {\n', '\n', '            uint kittyID = kittyIDs[i];\n', '\n', '            // mark the kitty as being claimed\n', '            require(!claimed[kittyID], "kitty must not be claimed");\n', '            claimed[kittyID] = true;\n', '\n', '            require(ownsOrSelling(kittyID), "you must own all the cats you claim");\n', '\n', '            // create the statue token\n', '            uint id = collectables.mint(delegateID, msg.sender);\n', '            ids[i] = id;\n', '            // record which kitty is associated with this statue\n', '            statues[id] = kittyID;    \n', '        }\n', '        \n', '        // calculate the total purchase price\n', '        uint totalPrice = price.mul(kittyIDs.length);\n', '\n', '        require(msg.value >= totalPrice, "wrong value sent to contract");\n', '       \n', '        uint half = totalPrice.div(2);\n', '\n', '        // send half the price to buy the packs\n', '        pack.purchaseFor.value(half)(msg.sender, uint16(kittyIDs.length), referrer); \n', '\n', '        // send the other half directly to the vault contract\n', '        vault.transfer(half);\n', '\n', '        emit CatsClaimed(ids, kittyIDs);\n', '        \n', '        return ids;\n', '    }\n', '\n', '    // returns whether the msg.sender owns or is auctioning a kitty\n', '    function ownsOrSelling(uint kittyID) public view returns (bool) {\n', '        // call to the core CK contract to find the owner of the kitty\n', '        address owner = kitties.ownerOf(kittyID);\n', '        if (owner == msg.sender) {\n', '            return true;\n', '        } \n', '        // check whether we are including the auction contracts\n', '        if (includeAuctions) {\n', '            address seller;\n', '            for (uint i = 0; i < auctions.length; i++) {\n', '                IAuction auction = auctions[i];\n', '                // make sure you check that this cat is owned by the auction \n', '                // before calling the method, or getAuction will throw\n', '                if (owner == address(auction)) {\n', '                    (seller, , , ,) = auction.getAuction(kittyID);\n', '                    return seller == msg.sender;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', ' \n', '    function setCanClaim(bool _can, bool lock) public onlyOwner {\n', '        require(!locked, "claiming is permanently locked");\n', '        if (lock) {\n', '            require(!_can, "can\'t lock on permanently");\n', '            locked = true;\n', '        }\n', '        canClaim = _can;\n', '    }\n', '\n', '    function getKitty(uint statueID) public view returns (uint) {\n', '        return statues[statueID];\n', '    }\n', '\n', '    function setClaimLimit(uint limit) public onlyOwner {\n', '        claimLimit = limit;\n', '    }\n', '\n', '    function setIncludeAuctions(bool _include) public onlyOwner {\n', '        includeAuctions = _include;\n', '    }\n', '\n', '}']
