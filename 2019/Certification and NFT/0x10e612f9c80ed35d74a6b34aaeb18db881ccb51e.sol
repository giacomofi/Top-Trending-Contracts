['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract EthMadness is Ownable {\n', '    \n', '    // Represents the submission to the contest.\n', '    struct Entrant {\n', '        // The user who submitted this entry\n', '        address submitter;\n', '        \n', '        // The "index" of this entry. Used to break ties incase two submissions are the same. (earlier submission wins)\n', '        uint48 entryIndex;\n', '    }\n', '    \n', '    // Represents a current top score in the contest\n', '    struct TopScore {\n', '        // The index of this entry (used for tie-breakas a de-dups)\n', '        uint48 entryIndex;\n', '\n', "        // This bracket's score\n", '        uint32 score;\n', '\n', '        // The total point differential for this bracket\n', '        uint64 difference;\n', '\n', '        // The account which submitted this bracket\n', '        address submitter;\n', '    }\n', '    \n', '    // Represents the results of the contest. \n', '    struct Result {\n', '        // The encoded results of the tournament\n', '        bytes16 winners;\n', '\n', "        // Team A's score in the final\n", '        uint8 scoreA;\n', '\n', "        // Team B's score in the final\n", '        uint8 scoreB;\n', '\n', '        // Whether or not this is the final Results (used to tell if a vote is real or not)\n', '        bool isFinal;\n', '    }\n', '    \n', '    // Represents the various states that the contest will go through.\n', '    enum ContestState {\n', '        // The contest is open for people to submit entries. Oracles can also be added during this period.\n', '        OPEN_FOR_ENTRIES,\n', '        \n', '        // The tournament is in progress, no more entries can be received and no oracles can vote\n', '        TOURNAMENT_IN_PROGRESS,\n', '        \n', "        // The tournament is over and we're waiting for all the oracles to submit the results\n", '        WAITING_FOR_ORACLES,\n', '        \n', "        // The oracels have submitted the results and we're waiting for winners to claim their prize\n", '        WAITING_FOR_WINNING_CLAIMS,\n', '        \n', '        // The contest has completed and the winners have been paid out\n', '        COMPLETED\n', '    }\n', '    \n', '    // Maximum number of entries that will be allowed\n', '    uint constant MAX_ENTRIES = 2**48;\n', '    \n', '    // The number of entries which have been received.\n', '    uint48 entryCount = 0;\n', '    \n', '    // Map of the encoded entry to the user who crreated it.\n', '    mapping (uint256 => Entrant) public entries;\n', '    \n', "    // The times where we're allowed to transition the contract's state\n", '    mapping (uint => uint) public transitionTimes;\n', '    \n', '    // The current state of the contest\n', '    ContestState public currentState;\n', '    \n', '    // The recorded votes of our oracles\n', '    mapping (address => Result) public oracleVotes;\n', '    \n', '    // The oracles who will submit the results of the tournament\n', '    address[] public oracles;\n', '    \n', "    // The maximum number of oracles we'll allow vote in our contest\n", '    uint constant MAX_ORACLES = 10;\n', '    \n', '    // The final result of the tournament that the oracles agreed on\n', '    Result public finalResult;\n', '    \n', "    // Keeps the current top 3 best scores and who submitted them. When the contest ends, they'll be paid out\n", '    TopScore[3] public topThree;\n', '    \n', '    // The address of the ERC20 token that defines our prize\n', '    address public prizeERC20TokenAddress;\n', '    \n', '    // The amount of the prize to reward\n', '    uint public prizeAmount;\n', '    \n', '    // Event emitted when a new entry gets submitted to the contest\n', '    event EntrySubmitted(\n', '        // The account who submitted this bracket\n', '        address indexed submitter,\n', '\n', '        // A compressed representation of the entry combining the picks and final game scores\n', '        uint256 indexed entryCompressed,\n', '\n', '        // The order this entry was received. Used for tiebreaks\n', '        uint48 indexed entryIndex,\n', '\n', '        // Optional bracket name provided by the submitter\n', '        string bracketName\n', '    );\n', '\n', '    // Constructs a new instance of the EthMadness contract with the given transition times\n', '    constructor(uint[] memory times, address erc20Token, uint erc20Amount) public {\n', '        \n', "        // Initialize the oracles array with the sender's address\n", '        oracles = [msg.sender];\n', '        \n', '        // Set up our prize info\n', '        prizeERC20TokenAddress = erc20Token;\n', '        prizeAmount = erc20Amount;\n', '        \n', '        // Set up our transition times\n', '        require(times.length == 4);\n', '        transitionTimes[uint(ContestState.TOURNAMENT_IN_PROGRESS)] = times[0];\n', '        transitionTimes[uint(ContestState.WAITING_FOR_ORACLES)] = times[1];\n', '        transitionTimes[uint(ContestState.WAITING_FOR_WINNING_CLAIMS)] = times[2];\n', '        transitionTimes[uint(ContestState.COMPLETED)] = times[3];\n', '        \n', '        // The initial state should be allowing people to make entries\n', '        currentState = ContestState.OPEN_FOR_ENTRIES;\n', '    }\n', '\n', "    // Gets the total number of entries we've received\n", '    function getEntryCount() public view returns (uint256) {\n', '        return entryCount;\n', '    }\n', '    \n', '    // Gets the number of Oracles we have registered\n', '    function getOracleCount() public view returns(uint256) {\n', '        return oracles.length;\n', '    }\n', '    \n', '    // Returns the transition times for our contest\n', '    function getTransitionTimes() public view returns (uint256, uint256, uint256, uint256) {\n', '        return (\n', '            transitionTimes[uint(ContestState.TOURNAMENT_IN_PROGRESS)],\n', '            transitionTimes[uint(ContestState.WAITING_FOR_ORACLES)],\n', '            transitionTimes[uint(ContestState.WAITING_FOR_WINNING_CLAIMS)],\n', '            transitionTimes[uint(ContestState.COMPLETED)]\n', '        );\n', '    }\n', '    \n', '    // Internal function for advancing the state of the bracket\n', '    function advanceState(ContestState nextState) private {\n', '        require(uint(nextState) == uint(currentState) + 1, "Can only advance state by 1");\n', '        require(now > transitionTimes[uint(nextState)], "Transition time hasn\'t happened yet");\n', '        \n', '        currentState = nextState;\n', '    }\n', '\n', '    // Helper to make sure the picks submitted are legal\n', '    function arePicksOrResultsValid(bytes16 picksOrResults) public pure returns (bool) {\n', '        // Go through and make sure that this entry has 1 pick for each game\n', '        for (uint8 gameId = 0; gameId < 63; gameId++) {\n', '            uint128 currentPick = extractResult(picksOrResults, gameId);\n', '            if (currentPick != 2 && currentPick != 1) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Submits a new entry to the tournament\n', '    function submitEntry(bytes16 picks, uint64 scoreA, uint64 scoreB, string memory bracketName) public {\n', '        require(currentState == ContestState.OPEN_FOR_ENTRIES, "Must be in the open for entries state");\n', '        require(arePicksOrResultsValid(picks), "The supplied picks are not valid");\n', '\n', '        // Do some work to encode the picks and scores into a single uint256 which becomes a key\n', '        uint256 scoreAShifted = uint256(scoreA) * (2 ** (24 * 8));\n', '        uint256 scoreBShifted = uint256(scoreB) * (2 ** (16 * 8));\n', '        uint256 picksAsNumber = uint128(picks);\n', '        uint256 entryCompressed = scoreAShifted | scoreBShifted | picksAsNumber;\n', '\n', '        require(entries[entryCompressed].submitter == address(0), "This exact bracket & score has already been submitted");\n', '        \n', '        // Emit the event that this entry was received and save the entry\n', '        emit EntrySubmitted(msg.sender, entryCompressed, entryCount, bracketName);\n', '        Entrant memory entrant = Entrant(msg.sender, entryCount);\n', '        entries[entryCompressed] = entrant;\n', '        entryCount++;\n', '    }\n', '\n', '    // Adds an allowerd oracle who will vote on the results of the contest. Only the contract owner can do this\n', '    // and it can only be done while the tournament is still open for entries\n', '    function addOracle(address oracle) public onlyOwner {\n', '        require(currentState == ContestState.OPEN_FOR_ENTRIES, "Must be accepting entries");\n', '        require(oracles.length < MAX_ORACLES - 1, "Must be less than max number of oracles");\n', '        oracles.push(oracle);\n', '    }\n', '\n', '    // In case something goes wrong, allow the owner to eject from the contract\n', '    // but only while picks are still being made or after the contest completes\n', '    function refundRemaining(uint256 amount) public onlyOwner {\n', '        require(currentState == ContestState.OPEN_FOR_ENTRIES || currentState == ContestState.COMPLETED, "Must be accepting entries");\n', '        \n', '        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\n', '        erc20.transfer(msg.sender, amount);\n', '    }\n', '    \n', "    // Submits a new oracle's vote describing the results of the tournament\n", '    function submitOracleVote(uint oracleIndex, bytes16 winners, uint8 scoreA, uint8 scoreB) public {\n', '        require(currentState == ContestState.WAITING_FOR_ORACLES, "Must be in waiting for oracles state");\n', '        require(oracles[oracleIndex] == msg.sender, "Wrong oracle index");\n', '        require(arePicksOrResultsValid(winners), "Results are not valid");\n', '        oracleVotes[msg.sender] = Result(winners, scoreA, scoreB, true);\n', '    }\n', '    \n', '    // Close the voting and set the final result. Pass in what should be the consensus agreed by the\n', '    // 70% of the oracles\n', '    function closeOracleVoting(bytes16 winners, uint8 scoreA, uint8 scoreB) public {\n', '        require(currentState == ContestState.WAITING_FOR_ORACLES);\n', '\n', '        // Count up how many oracles agree with this result\n', '        uint confirmingOracles = 0;\n', '        for (uint i = 0; i < oracles.length; i++) {\n', '            Result memory oracleVote = oracleVotes[oracles[i]];\n', '            if (oracleVote.isFinal &&\n', '                oracleVote.winners == winners &&\n', '                oracleVote.scoreA == scoreA &&\n', '                oracleVote.scoreB == scoreB) {\n', '\n', '                confirmingOracles++;\n', '            }\n', '        }\n', '        \n', '        // Require 70%+ of Oracles to have voted and agree on the result\n', '        uint percentAggreement = (confirmingOracles * 100) / oracles.length;\n', '        require(percentAggreement > 70, "To close oracle voting, > 70% of oracles must agree");\n', '        \n', '        // Change the state and set our final result which will be used to compute scores\n', '        advanceState(ContestState.WAITING_FOR_WINNING_CLAIMS);\n', '        finalResult = Result(winners, scoreA, scoreB, true);\n', '    }\n', '    \n', '    // Closes the entry period and marks that the actual tournament is in progress\n', '    function markTournamentInProgress() public {\n', '        advanceState(ContestState.TOURNAMENT_IN_PROGRESS);\n', '        \n', '        require(oracles.length > 0, "Must have at least 1 oracle registered");\n', '        \n', '        // Require that we have the amount of funds locked in the contract we expect\n', '        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\n', '        require(erc20.balanceOf(address(this)) >= prizeAmount, "Must have a balance in this contract");\n', '    }\n', '    \n', '    // Mark that the tournament has completed and oracles can start submitting results\n', '    function markTournamentFinished() public {\n', '        advanceState(ContestState.WAITING_FOR_ORACLES);\n', '    }\n', '    \n', '    // After the oracles have voted and winners have claimed their prizes, this closes the contest and\n', '    // pays out the winnings to the 3 winners\n', '    function closeContestAndPayWinners() public {\n', '        advanceState(ContestState.COMPLETED);\n', '        require(topThree[0].submitter != address(0), "Not enough claims");\n', '        require(topThree[1].submitter != address(0), "Not enough claims");\n', '        require(topThree[2].submitter != address(0), "Not enough claims");\n', '        \n', '        uint firstPrize = (prizeAmount * 70) / 100;\n', '        uint secondPrize = (prizeAmount * 20) / 100;\n', '        uint thirdPrize = (prizeAmount * 10) / 100;\n', '        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\n', '        erc20.transfer(topThree[0].submitter, firstPrize);\n', '        erc20.transfer(topThree[1].submitter, secondPrize);\n', '        erc20.transfer(topThree[2].submitter, thirdPrize);\n', '    }\n', '    \n', '    // Scores an entry and places it in the right sort order\n', '    function scoreAndSortEntry(uint256 entryCompressed, bytes16 results, uint64 scoreAActual, uint64 scoreBActual) private returns (uint32) {\n', '        require(currentState == ContestState.WAITING_FOR_WINNING_CLAIMS, "Must be in the waiting for claims state");\n', '        require(entries[entryCompressed].submitter != address(0), "The entry must have actually been submitted");\n', '\n', '        // Pull out the pick information from the compressed entry\n', '        bytes16 picks = bytes16(uint128((entryCompressed & uint256((2 ** 128) - 1))));\n', '        uint256 shifted = entryCompressed / (2 ** 128); // shift over 128 bits\n', '        uint64 scoreA = uint64((shifted & uint256((2 ** 64) - 1)));\n', '        shifted = entryCompressed / (2 ** 192);\n', '        uint64 scoreB = uint64((shifted & uint256((2 ** 64) - 1)));\n', '\n', '        // Compute the score and the total difference\n', '        uint32 score = scoreEntry(picks, results);\n', '        uint64 difference = computeFinalGameDifference(scoreA, scoreB, scoreAActual, scoreBActual);\n', '\n', '        // Make a score and place it in the right sort order\n', '        TopScore memory scoreResult = TopScore(entries[entryCompressed].entryIndex, score, difference, entries[entryCompressed].submitter);\n', '        if (isScoreBetter(scoreResult, topThree[0])) {\n', '            topThree[2] = topThree[1];\n', '            topThree[1] = topThree[0];\n', '            topThree[0] = scoreResult;\n', '        } else if (isScoreBetter(scoreResult, topThree[1])) {\n', '            topThree[2] = topThree[1];\n', '            topThree[1] = scoreResult;\n', '        } else if (isScoreBetter(scoreResult, topThree[2])) {\n', '            topThree[2] = scoreResult;\n', '        }\n', '        \n', '        return score;\n', '    }\n', '    \n', '    function claimTopEntry(uint256 entryCompressed) public {\n', '        require(currentState == ContestState.WAITING_FOR_WINNING_CLAIMS, "Must be in the waiting for winners state");\n', '        require(finalResult.isFinal, "The final result must be marked as final");\n', '        scoreAndSortEntry(entryCompressed, finalResult.winners, finalResult.scoreA, finalResult.scoreB);\n', '    }\n', '    \n', '    function computeFinalGameDifference(\n', '        uint64 scoreAGuess, uint64 scoreBGuess, uint64 scoreAActual, uint64 scoreBActual) private pure returns (uint64) {\n', '        \n', "        // Don't worry about overflow here, not much you can really do with it\n", '        uint64 difference = 0;\n', '        difference += ((scoreAActual > scoreAGuess) ? (scoreAActual - scoreAGuess) : (scoreAGuess - scoreAActual));\n', '        difference += ((scoreBActual > scoreBGuess) ? (scoreBActual - scoreBGuess) : (scoreBGuess - scoreBActual));\n', '        return difference;\n', '    }\n', '    \n', '    // Gets the bit at index n in a\n', '    function getBit16(bytes16 a, uint16 n) private pure returns (bool) {\n', '        uint128 mask = uint128(2) ** n;\n', '        return uint128(a) & mask != 0;\n', '    }\n', '    \n', '    // Sets the bit at index n to 1 in a\n', '    function setBit16(bytes16 a, uint16 n) private pure returns (bytes16) {\n', '        uint128 mask = uint128(2) ** n;\n', '        return a | bytes16(mask);\n', '    }\n', '    \n', '    // Sets the bit at index n to 0 in a\n', '    function clearBit16(bytes16 a, uint16 n) private pure returns (bytes16) {\n', '        uint128 mask = uint128(2) ** n;\n', '        mask = mask ^ uint128(-1);\n', '        return a & bytes16(mask);\n', '    }\n', '    \n', '    // Returns either 0 if there is no possible winner, 1 if team B is chosen, or 2 if team A is chosen\n', '    function extractResult(bytes16 a, uint8 n) private pure returns (uint128) {\n', '        uint128 mask = uint128(0x00000000000000000000000000000003) * uint128(2) ** (n * 2);\n', '        uint128 masked = uint128(a) & mask;\n', '        \n', '        // Shift back to get either 0, 1 or 2\n', '        return (masked / (uint128(2) ** (n * 2)));\n', '    }\n', '    \n', '    // Gets which round a game belongs to based on its id\n', '    function getRoundForGame(uint8 gameId) private pure returns (uint8) {\n', '        if (gameId < 32) {\n', '            return 0;\n', '        } else if (gameId < 48) {\n', '            return 1;\n', '        } else if (gameId < 56) {\n', '            return 2;\n', '        } else if (gameId < 60) {\n', '            return 3;\n', '        } else if (gameId < 62) {\n', '            return 4;\n', '        } else {\n', '            return 5;\n', '        }\n', '    }\n', '    \n', '    // Gets the first game in a round given the round number\n', '    function getFirstGameIdOfRound(uint8 round) private pure returns (uint8) {\n', '        if (round == 0) {\n', '            return 0;\n', '        } else if (round == 1) {\n', '            return 32;\n', '        } else if (round == 2) {\n', '            return 48;\n', '        } else if (round == 3) {\n', '            return 56;\n', '        } else if (round == 4) {\n', '            return 60;\n', '        } else {\n', '            return 62;\n', '        }\n', '    }\n', '    \n', '    // Looks at two scores and decided whether newScore is a better score than old score\n', '    function isScoreBetter(TopScore memory newScore, TopScore memory oldScore) private pure returns (bool) {\n', '        if (newScore.score > oldScore.score) {\n', '            return true;\n', '        }\n', '        \n', '        if (newScore.score < oldScore.score) {\n', '            return false;\n', '        }\n', '        \n', '        // Case where we have a tie\n', '        if (newScore.difference < oldScore.difference) {\n', '            return true;\n', '        }\n', '        \n', '        if (newScore.difference < oldScore.difference) {\n', '            return false;\n', '        }\n', '\n', '        require(newScore.entryIndex != oldScore.entryIndex, "This entry has already claimed a prize");\n', '        \n', '        // Crazy case where we have the same score and same diference. Return the earlier entry as the winnner\n', '        return newScore.entryIndex < oldScore.entryIndex;\n', '    }\n', '    \n', '    // Scores an entry given the picks and the results\n', '    function scoreEntry(bytes16 picks, bytes16 results) private pure returns (uint32) {\n', '        uint32 score = 0;\n', '        uint8 round = 0;\n', '        bytes16 currentPicks = picks;\n', '        for (uint8 gameId = 0; gameId < 63; gameId++) {\n', '            \n', "            // Update which round we're in when on the transitions\n", '            round = getRoundForGame(gameId);\n', '            \n', '            uint128 currentPick = extractResult(currentPicks, gameId);\n', '            if (currentPick == extractResult(results, gameId)) {\n', '                score += (uint32(2) ** round);\n', '            } else if (currentPick != 0) { // If we actually had a pick, propagate forward\n', '                // Mark all the future currentPicks which required this team winning as null\n', '                uint16 currentPickId = (gameId * 2) + (currentPick == 2 ? 1 : 0);\n', '                for (uint8 futureRound = round + 1; futureRound < 6; futureRound++) {\n', '                    uint16 currentPickOffset = currentPickId - (getFirstGameIdOfRound(futureRound - 1) * 2);\n', '                    currentPickId = (getFirstGameIdOfRound(futureRound) * 2) + (currentPickOffset / 2);\n', '                    \n', '                    bool pickedLoser = getBit16(currentPicks, currentPickId);\n', '                    if (pickedLoser) {\n', '                        currentPicks = clearBit16(currentPicks, currentPickId);\n', '                    } else {\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        \n', '        return score;\n', '    }\n', '}']