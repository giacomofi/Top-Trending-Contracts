['pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/// @title SelfAuthorized - authorizes current contract to perform actions\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract SelfAuthorized {\n', '    modifier authorized() {\n', '        require(msg.sender == address(this), "Method can only be called from this contract");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract MasterCopy is SelfAuthorized {\n', '  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n', '  // It should also always be ensured that the address is stored alone (uses a full word)\n', '    address masterCopy;\n', '\n', '  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\n', '  /// @param _masterCopy New contract address.\n', '    function changeMasterCopy(address _masterCopy)\n', '        public\n', '        authorized\n', '    {\n', '        // Master copy address cannot be null.\n', '        require(_masterCopy != address(0), "Invalid master copy address provided");\n', '        masterCopy = _masterCopy;\n', '    }\n', '}\n', '\n', '\n', '/// @title Enum - Collection of enums\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract Enum {\n', '    enum Operation {\n', '        Call,\n', '        DelegateCall,\n', '        Create\n', '    }\n', '}\n', '\n', '\n', '/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract EtherPaymentFallback {\n', '\n', '    /// @dev Fallback function accepts Ether transactions.\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '\n', '    }\n', '}\n', '\n', '\n', '/// @title Executor - A contract that can execute transactions\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract Executor is EtherPaymentFallback {\n', '\n', '    event ContractCreation(address newContract);\n', '\n', '    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (operation == Enum.Operation.Call)\n', '            success = executeCall(to, value, data, txGas);\n', '        else if (operation == Enum.Operation.DelegateCall)\n', '            success = executeDelegateCall(to, data, txGas);\n', '        else {\n', '            address newContract = executeCreate(data);\n', '            success = newContract != address(0);\n', '            emit ContractCreation(newContract);\n', '        }\n', '    }\n', '\n', '    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n', '        }\n', '    }\n', '\n', '    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n', '        }\n', '    }\n', '\n', '    function executeCreate(bytes memory data)\n', '        internal\n', '        returns (address newContract)\n', '    {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            newContract := create(0, add(data, 0x20), mload(data))\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n', '/// @author Stefan George - <stefan@gnosis.pm>\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract ModuleManager is SelfAuthorized, Executor {\n', '\n', '    event EnabledModule(Module module);\n', '    event DisabledModule(Module module);\n', '\n', '    address public constant SENTINEL_MODULES = address(0x1);\n', '\n', '    mapping (address => address) internal modules;\n', '    \n', '    function setupModules(address to, bytes memory data)\n', '        internal\n', '    {\n', '        require(modules[SENTINEL_MODULES] == address(0), "Modules have already been initialized");\n', '        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n', '        if (to != address(0))\n', '            // Setup has to complete successfully or transaction fails.\n', '            require(executeDelegateCall(to, data, gasleft()), "Could not finish initialization");\n', '    }\n', '\n', '    /// @dev Allows to add a module to the whitelist.\n', '    ///      This can only be done via a Safe transaction.\n', '    /// @param module Module to be whitelisted.\n', '    function enableModule(Module module)\n', '        public\n', '        authorized\n', '    {\n', '        // Module address cannot be null or sentinel.\n', '        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, "Invalid module address provided");\n', '        // Module cannot be added twice.\n', '        require(modules[address(module)] == address(0), "Module has already been added");\n', '        modules[address(module)] = modules[SENTINEL_MODULES];\n', '        modules[SENTINEL_MODULES] = address(module);\n', '        emit EnabledModule(module);\n', '    }\n', '\n', '    /// @dev Allows to remove a module from the whitelist.\n', '    ///      This can only be done via a Safe transaction.\n', '    /// @param prevModule Module that pointed to the module to be removed in the linked list\n', '    /// @param module Module to be removed.\n', '    function disableModule(Module prevModule, Module module)\n', '        public\n', '        authorized\n', '    {\n', '        // Validate module address and check that it corresponds to module index.\n', '        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, "Invalid module address provided");\n', '        require(modules[address(prevModule)] == address(module), "Invalid prevModule, module pair provided");\n', '        modules[address(prevModule)] = modules[address(module)];\n', '        modules[address(module)] = address(0);\n', '        emit DisabledModule(module);\n', '    }\n', '\n', '    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n', '    /// @param to Destination address of module transaction.\n', '    /// @param value Ether value of module transaction.\n', '    /// @param data Data payload of module transaction.\n', '    /// @param operation Operation type of module transaction.\n', '    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        // Only whitelisted modules are allowed.\n', '        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), "Method can only be called from an enabled module");\n', '        // Execute transaction without further confirmations.\n', '        success = execute(to, value, data, operation, gasleft());\n', '    }\n', '\n', '    /// @dev Returns array of modules.\n', '    /// @return Array of modules.\n', '    function getModules()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        // Calculate module count\n', '        uint256 moduleCount = 0;\n', '        address currentModule = modules[SENTINEL_MODULES];\n', '        while(currentModule != SENTINEL_MODULES) {\n', '            currentModule = modules[currentModule];\n', '            moduleCount ++;\n', '        }\n', '        address[] memory array = new address[](moduleCount);\n', '\n', '        // populate return array\n', '        moduleCount = 0;\n', '        currentModule = modules[SENTINEL_MODULES];\n', '        while(currentModule != SENTINEL_MODULES) {\n', '            array[moduleCount] = currentModule;\n', '            currentModule = modules[currentModule];\n', '            moduleCount ++;\n', '        }\n', '        return array;\n', '    }\n', '}\n', '\n', '\n', '/// @title Module - Base class for modules.\n', '/// @author Stefan George - <stefan@gnosis.pm>\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract Module is MasterCopy {\n', '\n', '    ModuleManager public manager;\n', '\n', '    modifier authorized() {\n', '        require(msg.sender == address(manager), "Method can only be called from manager");\n', '        _;\n', '    }\n', '\n', '    function setManager()\n', '        internal\n', '    {\n', '        // manager can only be 0 at initalization of contract.\n', '        // Check ensures that setup function can only be called once.\n', '        require(address(manager) == address(0), "Manager has already been set");\n', '        manager = ModuleManager(msg.sender);\n', '    }\n', '}\n', '\n', 'interface SM {\n', '\n', '    function isValidSubscription(\n', '        bytes32 subscriptionHash,\n', '        bytes calldata signatures\n', '    ) external view returns (bool);\n', '\n', '    function execSubscription (\n', '        address to,\n', '        uint256 value,\n', '        bytes calldata data,\n', '        Enum.Operation operation,\n', '        uint256 safeTxGas,\n', '        uint256 dataGas,\n', '        uint256 gasPrice,\n', '        address gasToken,\n', '        address payable refundReceiver,\n', '        bytes calldata meta,\n', '        bytes calldata signatures) external returns (bool);\n', '\n', '    function cancelSubscriptionAsRecipient(\n', '        address to,\n', '        uint256 value,\n', '        bytes calldata data,\n', '        Enum.Operation operation,\n', '        uint256 safeTxGas,\n', '        uint256 dataGas,\n', '        uint256 gasPrice,\n', '        address gasToken,\n', '        address payable refundReceiver,\n', '        bytes calldata meta,\n', '        bytes calldata signatures) external returns (bool);\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', 'library DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    function tmul(uint x, uint y, uint z) internal pure returns (uint a) {\n', '        require(z != 0);\n', '        a = add(mul(x, y), z / 2) / z;\n', '    }\n', '\n', '    function tdiv(uint x, uint y, uint z) internal pure returns (uint a) {\n', '        a = add(mul(x, z), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface OracleRegistry {\n', '\n', '    function read(\n', '        uint256 currencyPair\n', '    ) external view returns (bytes32);\n', '\n', '    function getNetworkExecutor()\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '    function getNetworkWallet()\n', '    external\n', '    view\n', '    returns (address payable);\n', '\n', '    function getNetworkFee(address asset)\n', '    external\n', '    view\n', '    returns (uint256 fee);\n', '}\n', '\n', '\n', '/// @title SecuredTokenTransfer - Secure token transfer\n', '/// @author Richard Meissner - <richard@gnosis.pm>\n', 'contract SecuredTokenTransfer {\n', '\n', '    /// @dev Transfers a token and returns if it was a success\n', '    /// @param token Token that should be transferred\n', '    /// @param receiver Receiver to whom the token should be transferred\n', '    /// @param amount The amount of tokens that should be transferred\n', '    function transferToken (\n', '        address token, \n', '        address receiver,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        returns (bool transferred)\n', '    {\n', '        bytes memory data = abi.encodeWithSignature("transfer(address,uint256)", receiver, amount);\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, returndatasize)\n', '            switch returndatasize \n', '            case 0 { transferred := success }\n', '            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n', '            default { transferred := 0 }\n', '        }\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    function decimals() external view returns (uint256 digits);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract MerchantModule is Module, SecuredTokenTransfer {\n', '\n', '    using DSMath for uint256;\n', '\n', '    OracleRegistry public oracleRegistry;\n', '\n', '    event IncomingPayment(uint256 payment);\n', '    event PaymentSent(address asset, address receiver, uint256 payment);\n', '\n', '\n', '    function setup(address _oracleRegistry)\n', '    public\n', '    {\n', '        setManager();\n', '        require(\n', '            address(oracleRegistry) == address(0),\n', '            "MerchantModule::setup: INVALID_STATE: ORACLE_REGISTRY_SET"\n', '        );\n', '        oracleRegistry = OracleRegistry(_oracleRegistry);\n', '    }\n', '\n', '    function()\n', '    payable\n', '    external\n', '    {\n', '        emit IncomingPayment(msg.value);\n', '    }\n', '\n', '    function split(\n', '        address tokenAddress\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(\n', '            msg.sender == oracleRegistry.getNetworkExecutor(),\n', '            "MerchantModule::split: INVALID_DATA: MSG_SENDER_NOT_EXECUTOR"\n', '        );\n', '\n', '        address payable networkWallet = oracleRegistry.getNetworkWallet();\n', '        address payable merchantWallet = address(manager);\n', '\n', '        if (tokenAddress == address(0)) {\n', '\n', '            uint256 splitterBalanceStart = address(this).balance;\n', '            if (splitterBalanceStart == 0) return false;\n', '            //\n', '            uint256 fee = oracleRegistry.getNetworkFee(address(0));\n', '\n', '\n', '            uint256 networkBalanceStart = networkWallet.balance;\n', '\n', '            uint256 merchantBalanceStart = merchantWallet.balance;\n', '\n', '\n', '            uint256 networkSplit = splitterBalanceStart.wmul(fee);\n', '\n', '            uint256 merchantSplit = splitterBalanceStart.sub(networkSplit);\n', '\n', '\n', '            require(merchantSplit > networkSplit, "Split Math is Wrong");\n', '            //pay network\n', '\n', '            networkWallet.transfer(networkSplit);\n', '            emit PaymentSent(address(0x0), networkWallet, networkSplit);\n', '            //pay merchant\n', '\n', '            merchantWallet.transfer(merchantSplit);\n', '            emit PaymentSent(address(0x0), merchantWallet, merchantSplit);\n', '\n', '            require(\n', '                (networkBalanceStart.add(networkSplit) == networkWallet.balance)\n', '                &&\n', '                (merchantBalanceStart.add(merchantSplit) == merchantWallet.balance),\n', '                "MerchantModule::withdraw: INVALID_EXEC SPLIT_PAYOUT"\n', '            );\n', '        } else {\n', '\n', '            ERC20 token = ERC20(tokenAddress);\n', '\n', '            uint256 splitterBalanceStart = token.balanceOf(address(this));\n', '\n', '\n', '            if (splitterBalanceStart == 0) return false;\n', '\n', '            uint256 fee = oracleRegistry.getNetworkFee(address(token));\n', '\n', '\n', '            uint256 merchantBalanceStart = token.balanceOf(merchantWallet);\n', '\n', '\n', '            uint256 networkSplit = splitterBalanceStart.wmul(fee);\n', '\n', '\n', '            uint256 merchantSplit = splitterBalanceStart.sub(networkSplit);\n', '\n', '\n', '            require(\n', '                networkSplit.add(merchantSplit) == splitterBalanceStart,\n', '                "MerchantModule::withdraw: INVALID_EXEC TOKEN_SPLIT"\n', '            );\n', '\n', '            //pay network\n', '\n', '            require(\n', '                transferToken(address(token), networkWallet, networkSplit),\n', '                "MerchantModule::withdraw: INVALID_EXEC TOKEN_NETWORK_PAYOUT"\n', '            );\n', '\n', '            emit PaymentSent(address(token), networkWallet, networkSplit);\n', '\n', '            //pay merchant\n', '            require(\n', '                transferToken(address(token), merchantWallet, merchantSplit),\n', '                "MerchantModule::withdraw: INVALID_EXEC TOKEN_MERCHANT_PAYOUT"\n', '            );\n', '            emit PaymentSent(address(token), merchantWallet, merchantSplit);\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function cancelCXSubscription(\n', '        address customer,\n', '        address to,\n', '        uint256 value,\n', '        bytes memory data,\n', '        Enum.Operation operation,\n', '        uint256 safeTxGas,\n', '        uint256 dataGas,\n', '        uint256 gasPrice,\n', '        address gasToken,\n', '        address payable refundReceiver,\n', '        bytes memory meta,\n', '        bytes memory signatures\n', '    )\n', '    public\n', '    authorized\n', '    {\n', '        SM(customer).cancelSubscriptionAsRecipient(\n', '            to,\n', '            value,\n', '            data,\n', '            operation,\n', '            safeTxGas,\n', '            dataGas,\n', '            gasPrice,\n', '            gasToken,\n', '            refundReceiver,\n', '            meta,\n', '            signatures\n', '        );\n', '    }\n', '\n', '}']