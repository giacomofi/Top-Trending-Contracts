['pragma solidity >=0.4.22 <0.6.0;\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization\n', '/// control functions, this simplifies the implementation of "user permissions".\n', '//-----------------------------------------------------------------------------\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '//-----------------------------------------------------------------------------\n', '/// @title Crusades Configurations\n', '//-----------------------------------------------------------------------------\n', 'contract CrusadesConfig is Ownable {\n', '    //=========================================================================\n', '    // RESOURCES\n', '    //=========================================================================\n', '    string[] public resourceTypes;\n', '    \n', '    function addNewResourceType (string calldata _description) external onlyOwner {\n', '        resourceTypes.push(_description);\n', '    }\n', '    \n', '    function resourcesLength () external view returns (uint) {\n', '        return resourceTypes.length;\n', '    }\n', '    \n', '    //=========================================================================\n', '    // PLANET\n', '    //=========================================================================\n', '    struct CrusadesTileData {\n', '        string description;\n', '        uint weight;\n', '        mapping (uint => uint) resourceIdToYield;\n', '    }\n', '    struct CrusadesCoordinates {\n', '        uint x;\n', '        uint y;\n', '    }\n', '    struct CrusadesPlanetTile {\n', '        uint tileDataId;                        // id of the data\n', '        uint cityId;                            // The ID of the city on this tile. 0 if none.\n', '        // an array of coordinates of all neighboring tiles\n', '        // neighbors[0] = up + left\n', '        // neighbors[1] = up\n', '        // neighbors[2] = up + right\n', '        // neighbors[3] = down + left\n', '        // neighbors[4] = down\n', '        // neighbors[5] = down + right\n', '        CrusadesCoordinates[6] neighbors;\n', '        \n', '    }\n', '    \n', '    mapping (uint => CrusadesTileData) public idToTileData;\n', '    mapping (uint => mapping (uint => CrusadesPlanetTile)) public planetTiles;\n', '\n', '    function setTileData (\n', '        uint _tileId, \n', '        string calldata _description, \n', '        uint _weight,\n', '        uint[] calldata _resourceYields\n', '    ) external onlyOwner {\n', '        require (_resourceYields.length == resourceTypes.length);\n', '        CrusadesTileData storage tileData = idToTileData[_tileId];\n', '        tileData.description = _description;\n', '        tileData.weight = _weight;\n', '        for (uint i = 0; i < _resourceYields.length; ++i) {\n', '            tileData.resourceIdToYield[i] = _resourceYields[i];\n', '        }\n', '    }\n', '\n', '    function initializePlanetTile (\n', '        uint _xCoordinate, \n', '        uint _yCoordinate, \n', '        uint _tileDataId\n', '    ) external onlyOwner {\n', '        CrusadesPlanetTile storage planetTile = planetTiles[_xCoordinate][_yCoordinate];\n', '        planetTile.tileDataId = _tileDataId;\n', '        \n', '        // TODO: EDGE CHECKING FOR WRAPPING OF COORDINATES ON GLOBE\n', '        // neighbor up + left\n', '        planetTile.neighbors[0].x = _xCoordinate - 1;\n', '        planetTile.neighbors[0].y = _yCoordinate - 1;\n', '        \n', '        // neighbor up\n', '        planetTile.neighbors[1].x = _xCoordinate;\n', '        planetTile.neighbors[1].y = _yCoordinate - 1;\n', '        \n', '        // neighbor up + right\n', '        planetTile.neighbors[2].x = _xCoordinate + 1;\n', '        planetTile.neighbors[2].y = _yCoordinate - 1;\n', '        \n', '        // neighbor down + left\n', '        planetTile.neighbors[3].x = _xCoordinate - 1;\n', '        planetTile.neighbors[3].y = _yCoordinate + 1;\n', '        \n', '        // neighbor up + left\n', '        planetTile.neighbors[4].x = _xCoordinate;\n', '        planetTile.neighbors[4].y = _yCoordinate + 1;\n', '        \n', '        // neighbor up + left\n', '        planetTile.neighbors[5].x = _xCoordinate + 1;\n', '        planetTile.neighbors[5].y = _yCoordinate + 1;\n', '    }\n', '\n', '    function addCityToPlanetTile (\n', '        uint _xCoordinate, \n', '        uint _yCoordinate, \n', '        uint _cityId\n', '    ) external onlyOwner {\n', '        planetTiles[_xCoordinate][_yCoordinate].cityId = _cityId;\n', '    }\n', '    \n', '    function getPlanetTile(uint _xCoordinate, uint _yCoordinate) external view returns (\n', '        uint tileDataId,\n', '        uint cityId,\n', '        uint[] memory neighborsXCoordinates,\n', '        uint[] memory neighborsYCoordinates\n', '    ) {\n', '        tileDataId = planetTiles[_xCoordinate][_yCoordinate].tileDataId;\n', '        cityId = planetTiles[_xCoordinate][_yCoordinate].cityId;\n', '        neighborsXCoordinates = new uint[](6);\n', '        neighborsYCoordinates = new uint[](6);\n', '        for (uint i = 0; i < 6; ++i) {\n', '            neighborsXCoordinates[i] = planetTiles[_xCoordinate][_yCoordinate].neighbors[i].x;\n', '            neighborsYCoordinates[i] = planetTiles[_xCoordinate][_yCoordinate].neighbors[i].y;\n', '        }\n', '    }\n', '    \n', '    function getResourceYield(uint _tileId) external view returns (uint[] memory resources) {\n', '        resources = new uint[](resourceTypes.length);\n', '        for (uint i = 0; i < resources.length; ++i) {\n', '            resources[i] = idToTileData[_tileId].resourceIdToYield[i];\n', '        }\n', '    }\n', '    \n', '    function getNeighbors(uint _originX, uint _originY, uint _distance) external view returns (\n', '        uint[] memory neighborsXCoordinates, \n', '        uint[] memory neighborsYCoordinates\n', '    ) {\n', '        require (_distance > 0 && _distance < 3);\n', '        // the formula is 3n^2 + 3n\n', '        neighborsXCoordinates = new uint[]((_distance ** 2 * 3) + (3 * _distance));\n', '        neighborsYCoordinates = new uint[]((_distance ** 2 * 3) + (3 * _distance));\n', '        for (uint i = 0; i < 6; ++i) {\n', '            if (planetTiles[_originX][_originY].neighbors[i].x != 0 || planetTiles[_originX][_originY].neighbors[i].y != 0) {\n', '                neighborsXCoordinates[i] = planetTiles[_originX][_originY].neighbors[i].x;\n', '                neighborsYCoordinates[i] = planetTiles[_originX][_originY].neighbors[i].y;\n', '            }\n', '            if (_distance == 2) {\n', '                for(i = 0; i < 6; ++i) {\n', '                    if (planetTiles[_originX][_originY].neighbors[i].x != 0 || planetTiles[_originX][_originY].neighbors[i].y != 0) {\n', '                        neighborsXCoordinates[i] = planetTiles[_originX][_originY].neighbors[i].x;\n', '                        neighborsYCoordinates[i] = planetTiles[_originX][_originY].neighbors[i].y;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getHarvest(uint _originX, uint _originY) external view returns (\n', '        uint[] memory\n', '    ) {\n', '        // the formula is 3n^2 + 3n\n', '        CrusadesCoordinates[] memory neighborCoordinates = new CrusadesCoordinates[](6);\n', '        for (uint i = 0; i < 6; ++i) {\n', '            if (planetTiles[_originX][_originY].neighbors[i].x != 0 || planetTiles[_originX][_originY].neighbors[i].y != 0) {\n', '                neighborCoordinates[i] = planetTiles[_originX][_originY].neighbors[i];\n', '            }\n', '        }\n', '        \n', '        uint[] memory resourcesToHarvest = new uint[](resourceTypes.length);\n', '        for (uint i = 0; i < neighborCoordinates.length; ++i) {\n', '            uint tileId = planetTiles[neighborCoordinates[i].x][neighborCoordinates[i].y].tileDataId;\n', '            for (uint j = 0; j < resourceTypes.length; ++j) {\n', '                resourcesToHarvest[j] += idToTileData[tileId].resourceIdToYield[j];\n', '            }\n', '        }\n', '    }\n', '    \n', '    //=========================================================================\n', '    // TROOPS\n', '    //=========================================================================\n', '    struct CrusadesTroopData {\n', '        string description;\n', '        mapping (uint => uint) troopAttributeIdToValue;\n', '        mapping (uint => uint) resourceIdToCost;\n', '    }\n', '    \n', '    mapping (uint => CrusadesTroopData) public idToTroopData;\n', '    mapping (uint => mapping (uint => int)) public typeIdToTypeIdToEffectiveness;\n', '    string[] public troopAttributes;\n', '\n', '    \n', '    function addNewTroopAttribute (string calldata _description) external onlyOwner {\n', '        troopAttributes.push(_description);\n', '    }\n', '    \n', '    function initializeTroopData (\n', '        uint _troopId,\n', '        string calldata _description,\n', '        uint[] calldata _troopAttributeValues,\n', '        uint[] calldata _resourceCosts\n', '    ) external onlyOwner {\n', '        require (_resourceCosts.length == resourceTypes.length);\n', '        require (_troopAttributeValues.length == troopAttributes.length);\n', '        CrusadesTroopData storage troopData = idToTroopData[_troopId];\n', '        troopData.description = _description;\n', '        for (uint i = 0; i < _troopAttributeValues.length; ++i) {\n', '            troopData.troopAttributeIdToValue[i] = _troopAttributeValues[i];\n', '        }\n', '        for(uint i = 0; i < _resourceCosts.length; ++i) {\n', '            troopData.resourceIdToCost[i] = _resourceCosts[i];\n', '        }\n', '    }\n', '    \n', '    function getTroopAttributeValue(uint _troopId, uint _attributeId) external view returns (uint) {\n', '        return idToTroopData[_troopId].troopAttributeIdToValue[_attributeId];\n', '    }\n', '    \n', '    function getTroopResourceCost(uint _troopId, uint _resourceId) external view returns (uint) {\n', '        return idToTroopData[_troopId].resourceIdToCost[_resourceId];\n', '    }\n', '    \n', '    //=========================================================================\n', '    // MODIFIERS\n', '    //=========================================================================\n', '    string[] public modifiers;\n', '    function addNewModifier (string calldata _description) external onlyOwner {\n', '        modifiers.push(_description);\n', '    }\n', '    function modifiersLength () external view returns (uint) {\n', '        return modifiers.length;\n', '    }\n', '    \n', '    //=========================================================================\n', '    // POLICIES\n', '    //=========================================================================\n', '    struct CrusadesPolicyData {\n', '        string description;\n', '        mapping (uint => uint) resourceIdToCost;\n', '        mapping (uint => bool) policyIdToRequired;\n', '        mapping (uint => int) modifierIdToAmountChangedByThisPolicy;\n', '    }\n', '    \n', '    mapping (uint => CrusadesPolicyData) public idToPolicyData;\n', '    \n', '    function setPolicyData (\n', '        uint _policyId,\n', '        string calldata _description,\n', '        uint[] calldata _resourceCosts, \n', '        uint[] calldata _requirements, \n', '        int[] calldata _modifiers\n', '    ) external onlyOwner {\n', '        require (_resourceCosts.length == resourceTypes.length);\n', '        require (_modifiers.length == modifiers.length);\n', '        CrusadesPolicyData storage policyData = idToPolicyData[_policyId];\n', '        policyData.description = _description;\n', '        for (uint i = 0; i < _resourceCosts.length; ++i) {\n', '            policyData.resourceIdToCost[i] = _resourceCosts[i];\n', '        }\n', '        for (uint i = 0; i < _requirements.length; ++i) {\n', '            policyData.policyIdToRequired[_requirements[i]] = true;\n', '        }\n', '        for (uint i = 0; i < _modifiers.length; ++i){\n', '            policyData.modifierIdToAmountChangedByThisPolicy[i] = _modifiers[i];\n', '        }\n', '    }\n', '    \n', '    //=========================================================================\n', '    // BUILDINGS\n', '    //=========================================================================\n', '    struct CrusadesBuildingData {\n', '        string description;\n', '        mapping (uint => mapping(uint => uint)) buildingLevelToAttributeIdToValue;\n', '        mapping (uint => mapping(uint => uint)) buildingLevelToResourceIdToCost;\n', '    }\n', '    \n', '    mapping (uint => CrusadesBuildingData) public idToBuildingData;\n', '    string[] public buildingAttributes;\n', '    \n', '    function addNewBuildingAttribute (string calldata _description) external onlyOwner {\n', '        buildingAttributes.push(_description);\n', '    }\n', '    \n', '    function initializeBuildingData (\n', '        uint _buildingId,\n', '        string calldata _description\n', '    ) external onlyOwner {\n', '        idToBuildingData[_buildingId].description = _description;\n', '    }\n', '    \n', '    function setBuildingAttributesByLevel(\n', '        uint _buildingId, \n', '        uint _buildingLevel, \n', '        uint[] calldata _attributeValues\n', '    ) external onlyOwner {\n', '        require(_attributeValues.length == buildingAttributes.length);\n', '        for (uint i = 0; i < _attributeValues.length; ++i) {\n', '            idToBuildingData[_buildingId].buildingLevelToAttributeIdToValue[_buildingLevel][i] = _attributeValues[i];\n', '        }\n', '        \n', '    }\n', '    \n', '    function setBuildingCostsByLevel(\n', '        uint _buildingId,\n', '        uint _buildingLevel,\n', '        uint[] calldata _resourceCosts\n', '    ) external onlyOwner {\n', '        require(_resourceCosts.length == resourceTypes.length);\n', '        for(uint i = 0; i < _resourceCosts.length; ++i) {\n', '            idToBuildingData[_buildingId].buildingLevelToResourceIdToCost[_buildingLevel][i] = _resourceCosts[i];\n', '        }\n', '    }\n', '    \n', '    function getBuildingAttributeValue(\n', '        uint _buildingId,\n', '        uint _buildingLevel,\n', '        uint _attributeId\n', '    ) external view returns (uint) {\n', '        return idToBuildingData[_buildingId].buildingLevelToAttributeIdToValue[_buildingLevel][_attributeId];\n', '    }\n', '    \n', '    function getBuildingResourceCost(\n', '        uint _buildingId, \n', '        uint _buildingLevel, \n', '        uint _resourceId\n', '    ) external view returns (uint) {\n', '        return idToBuildingData[_buildingId].buildingLevelToResourceIdToCost[_buildingLevel][_resourceId];\n', '    }\n', '    \n', '    //=========================================================================\n', '    // OTHER CONFIGURATIONS\n', '    //=========================================================================\n', '    uint public cityPrice = 1 ether / 5;\n', '    uint public harvestInterval = 1 hours;\n', '    uint public maxHarvests = 8;\n', '    string[] public customizations;\n', '    mapping (uint => string) public customizationIdToSkin;\n', '    mapping (uint => string) public customizationIdToChroma;\n', '    \n', '    function changeCityPrice(uint _newPrice) external onlyOwner {\n', '        require (_newPrice > 0);\n', '        cityPrice = _newPrice;\n', '    }\n', '    \n', '    function changeHarvestInterval(uint _newInterval) external onlyOwner {\n', '        require (_newInterval > 0);\n', '        cityPrice = _newInterval;\n', '    }\n', '}']