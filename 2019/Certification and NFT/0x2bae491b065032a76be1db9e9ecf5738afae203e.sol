['pragma solidity ^0.5.2;\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\n', '\n', '/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\n', '/// @author Alan Lu - <alan@gnosis.pm>\n', 'contract Proxied {\n', '    address public masterCopy;\n', '}\n', '\n', '/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n', '/// @author Stefan George - <stefan@gnosis.pm>\n', 'contract Proxy is Proxied {\n', '    /// @dev Constructor function sets address of master copy contract.\n', '    /// @param _masterCopy Master copy address.\n', '    constructor(address _masterCopy) public {\n', '        require(_masterCopy != address(0), "The master copy is required");\n', '        masterCopy = _masterCopy;\n', '    }\n', '\n', '    /// @dev Fallback function forwards all transactions and returns all received return data.\n', '    function() external payable {\n', '        address _masterCopy = masterCopy;\n', '        assembly {\n', '            calldatacopy(0, 0, calldatasize)\n', '            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n', '            returndatacopy(0, 0, returndatasize)\n', '            switch success\n', '                case 0 {\n', '                    revert(0, returndatasize)\n', '                }\n', '                default {\n', '                    return(0, returndatasize)\n', '                }\n', '        }\n', '    }\n', '}\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/Token.sol\n', '\n', '/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'pragma solidity ^0.5.2;\n', '\n', '/// @title Abstract token contract - Functions to be implemented by token contracts\n', 'contract Token {\n', '    /*\n', '     *  Events\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '}\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/Math.sol\n', '\n', '/// @title Math library - Allows calculation of logarithmic and exponential functions\n', '/// @author Alan Lu - <alan.lu@gnosis.pm>\n', '/// @author Stefan George - <stefan@gnosis.pm>\n', 'library GnosisMath {\n', '    /*\n', '     *  Constants\n', '     */\n', '    // This is equal to 1 in our calculations\n', '    uint public constant ONE = 0x10000000000000000;\n', '    uint public constant LN2 = 0xb17217f7d1cf79ac;\n', '    uint public constant LOG2_E = 0x171547652b82fe177;\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    /// @dev Returns natural exponential function value of given x\n', '    /// @param x x\n', '    /// @return e**x\n', '    function exp(int x) public pure returns (uint) {\n', '        // revert if x is > MAX_POWER, where\n', '        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\n', '        require(x <= 2454971259878909886679);\n', '        // return 0 if exp(x) is tiny, using\n', '        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\n', '        if (x < -818323753292969962227) return 0;\n', '        // Transform so that e^x -> 2^x\n', '        x = x * int(ONE) / int(LN2);\n', '        // 2^x = 2^whole(x) * 2^frac(x)\n', '        //       ^^^^^^^^^^ is a bit shift\n', '        // so Taylor expand on z = frac(x)\n', '        int shift;\n', '        uint z;\n', '        if (x >= 0) {\n', '            shift = x / int(ONE);\n', '            z = uint(x % int(ONE));\n', '        } else {\n', '            shift = x / int(ONE) - 1;\n', '            z = ONE - uint(-x % int(ONE));\n', '        }\n', '        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\n', '        //\n', '        // Can generate the z coefficients using mpmath and the following lines\n', '        // >>> from mpmath import mp\n', '        // >>> mp.dps = 100\n', '        // >>> ONE =  0x10000000000000000\n', "        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\n", '        // 0xb17217f7d1cf79ab\n', '        // 0x3d7f7bff058b1d50\n', '        // 0xe35846b82505fc5\n', '        // 0x276556df749cee5\n', '        // 0x5761ff9e299cc4\n', '        // 0xa184897c363c3\n', '        uint zpow = z;\n', '        uint result = ONE;\n', '        result += 0xb17217f7d1cf79ab * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x3d7f7bff058b1d50 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0xe35846b82505fc5 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x276556df749cee5 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x5761ff9e299cc4 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0xa184897c363c3 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0xffe5fe2c4586 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x162c0223a5c8 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x1b5253d395e * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x1e4cf5158b * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x1e8cac735 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x1c3bd650 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x1816193 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x131496 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0xe1b7 * zpow / ONE;\n', '        zpow = zpow * z / ONE;\n', '        result += 0x9c7 * zpow / ONE;\n', '        if (shift >= 0) {\n', '            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\n', '            return result << shift;\n', '        } else return result >> (-shift);\n', '    }\n', '\n', '    /// @dev Returns natural logarithm value of given x\n', '    /// @param x x\n', '    /// @return ln(x)\n', '    function ln(uint x) public pure returns (int) {\n', '        require(x > 0);\n', '        // binary search for floor(log2(x))\n', '        int ilog2 = floorLog2(x);\n', '        int z;\n', '        if (ilog2 < 0) z = int(x << uint(-ilog2));\n', '        else z = int(x >> uint(ilog2));\n', '        // z = x * 2^-⌊log₂x⌋\n', '        // so 1 <= z < 2\n', '        // and ln z = ln x - ⌊log₂x⌋/log₂e\n', '        // so just compute ln z using artanh series\n', '        // and calculate ln x from that\n', '        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\n', '        int halflnz = term;\n', '        int termpow = term * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 3;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 5;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 7;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 9;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 11;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 13;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 15;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 17;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 19;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 21;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 23;\n', '        termpow = termpow * term / int(ONE) * term / int(ONE);\n', '        halflnz += termpow / 25;\n', '        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\n', '    }\n', '\n', '    /// @dev Returns base 2 logarithm value of given x\n', '    /// @param x x\n', '    /// @return logarithmic value\n', '    function floorLog2(uint x) public pure returns (int lo) {\n', '        lo = -64;\n', '        int hi = 193;\n', '        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\n', '        int mid = (hi + lo) >> 1;\n', '        while ((lo + 1) < hi) {\n', '            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\n', '            else lo = mid;\n', '            mid = (hi + lo) >> 1;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns maximum of an array\n', '    /// @param nums Numbers to look through\n', '    /// @return Maximum number\n', '    function max(int[] memory nums) public pure returns (int maxNum) {\n', '        require(nums.length > 0);\n', '        maxNum = -2 ** 255;\n', '        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\n', '    }\n', '\n', '    /// @dev Returns whether an add operation causes an overflow\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Did no overflow occur?\n', '    function safeToAdd(uint a, uint b) internal pure returns (bool) {\n', '        return a + b >= a;\n', '    }\n', '\n', '    /// @dev Returns whether a subtraction operation causes an underflow\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Did no underflow occur?\n', '    function safeToSub(uint a, uint b) internal pure returns (bool) {\n', '        return a >= b;\n', '    }\n', '\n', '    /// @dev Returns whether a multiply operation causes an overflow\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Did no overflow occur?\n', '    function safeToMul(uint a, uint b) internal pure returns (bool) {\n', '        return b == 0 || a * b / b == a;\n', '    }\n', '\n', '    /// @dev Returns sum if no overflow occurred\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Sum\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        require(safeToAdd(a, b));\n', '        return a + b;\n', '    }\n', '\n', '    /// @dev Returns difference if no overflow occurred\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Difference\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(safeToSub(a, b));\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Returns product if no overflow occurred\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Product\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        require(safeToMul(a, b));\n', '        return a * b;\n', '    }\n', '\n', '    /// @dev Returns whether an add operation causes an overflow\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Did no overflow occur?\n', '    function safeToAdd(int a, int b) internal pure returns (bool) {\n', '        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n', '    }\n', '\n', '    /// @dev Returns whether a subtraction operation causes an underflow\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Did no underflow occur?\n', '    function safeToSub(int a, int b) internal pure returns (bool) {\n', '        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n', '    }\n', '\n', '    /// @dev Returns whether a multiply operation causes an overflow\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Did no overflow occur?\n', '    function safeToMul(int a, int b) internal pure returns (bool) {\n', '        return (b == 0) || (a * b / b == a);\n', '    }\n', '\n', '    /// @dev Returns sum if no overflow occurred\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Sum\n', '    function add(int a, int b) internal pure returns (int) {\n', '        require(safeToAdd(a, b));\n', '        return a + b;\n', '    }\n', '\n', '    /// @dev Returns difference if no overflow occurred\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Difference\n', '    function sub(int a, int b) internal pure returns (int) {\n', '        require(safeToSub(a, b));\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Returns product if no overflow occurred\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Product\n', '    function mul(int a, int b) internal pure returns (int) {\n', '        require(safeToMul(a, b));\n', '        return a * b;\n', '    }\n', '}\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\n', '\n', '/**\n', ' * Deprecated: Use Open Zeppeling one instead\n', ' */\n', 'contract StandardTokenData {\n', '    /*\n', '     *  Storage\n', '     */\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowances;\n', '    uint totalTokens;\n', '}\n', '\n', '/**\n', ' * Deprecated: Use Open Zeppeling one instead\n', ' */\n', '/// @title Standard token contract with overflow protection\n', 'contract GnosisStandardToken is Token, StandardTokenData {\n', '    using GnosisMath for *;\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', "    /// @dev Transfers sender's tokens to a given address. Returns success\n", '    /// @param to Address of token receiver\n', '    /// @param value Number of tokens to transfer\n', '    /// @return Was transfer successful?\n', '    function transfer(address to, uint value) public returns (bool) {\n', '        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\n', '            return false;\n', '        }\n', '\n', '        balances[msg.sender] -= value;\n', '        balances[to] += value;\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\n', '    /// @param from Address from where tokens are withdrawn\n', '    /// @param to Address to where tokens are sent\n', '    /// @param value Number of tokens to transfer\n', '    /// @return Was transfer successful?\n', '    function transferFrom(address from, address to, uint value) public returns (bool) {\n', '        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n', '            value\n', '        ) || !balances[to].safeToAdd(value)) {\n', '            return false;\n', '        }\n', '        balances[from] -= value;\n', '        allowances[from][msg.sender] -= value;\n', '        balances[to] += value;\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success\n', '    /// @param spender Address of allowed account\n', '    /// @param value Number of approved tokens\n', '    /// @return Was approval successful?\n', '    function approve(address spender, uint value) public returns (bool) {\n', '        allowances[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens for given address\n', '    /// @param owner Address of token owner\n', '    /// @param spender Address of token spender\n', '    /// @return Remaining allowance for spender\n', '    function allowance(address owner, address spender) public view returns (uint) {\n', '        return allowances[owner][spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address\n', '    /// @param owner Address of token owner\n', '    /// @return Balance of owner\n', '    function balanceOf(address owner) public view returns (uint) {\n', '        return balances[owner];\n', '    }\n', '\n', '    /// @dev Returns total supply of tokens\n', '    /// @return Total supply\n', '    function totalSupply() public view returns (uint) {\n', '        return totalTokens;\n', '    }\n', '}\n', '\n', '// File: contracts/TokenFRT.sol\n', '\n', '/// @title Standard token contract with overflow protection\n', 'contract TokenFRT is Proxied, GnosisStandardToken {\n', '    address public owner;\n', '\n', '    string public constant symbol = "MGN";\n', '    string public constant name = "Magnolia Token";\n', '    uint8 public constant decimals = 18;\n', '\n', '    struct UnlockedToken {\n', '        uint amountUnlocked;\n', '        uint withdrawalTime;\n', '    }\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public minter;\n', '\n', '    // user => UnlockedToken\n', '    mapping(address => UnlockedToken) public unlockedTokens;\n', '\n', '    // user => amount\n', '    mapping(address => uint) public lockedTokenBalances;\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '\n', '    // @dev allows to set the minter of Magnolia tokens once.\n', '    // @param   _minter the minter of the Magnolia tokens, should be the DX-proxy\n', '    function updateMinter(address _minter) public {\n', '        require(msg.sender == owner, "Only the minter can set a new one");\n', '        require(_minter != address(0), "The new minter must be a valid address");\n', '\n', '        minter = _minter;\n', '    }\n', '\n', '    // @dev the intention is to set the owner as the DX-proxy, once it is deployed\n', '    // Then only an update of the DX-proxy contract after a 30 days delay could change the minter again.\n', '    function updateOwner(address _owner) public {\n', '        require(msg.sender == owner, "Only the owner can update the owner");\n', '        require(_owner != address(0), "The new owner must be a valid address");\n', '        owner = _owner;\n', '    }\n', '\n', '    function mintTokens(address user, uint amount) public {\n', '        require(msg.sender == minter, "Only the minter can mint tokens");\n', '\n', '        lockedTokenBalances[user] = add(lockedTokenBalances[user], amount);\n', '        totalTokens = add(totalTokens, amount);\n', '    }\n', '\n', '    /// @dev Lock Token\n', '    function lockTokens(uint amount) public returns (uint totalAmountLocked) {\n', '        // Adjust amount by balance\n', '        uint actualAmount = min(amount, balances[msg.sender]);\n', '\n', '        // Update state variables\n', '        balances[msg.sender] = sub(balances[msg.sender], actualAmount);\n', '        lockedTokenBalances[msg.sender] = add(lockedTokenBalances[msg.sender], actualAmount);\n', '\n', '        // Get return variable\n', '        totalAmountLocked = lockedTokenBalances[msg.sender];\n', '    }\n', '\n', '    function unlockTokens() public returns (uint totalAmountUnlocked, uint withdrawalTime) {\n', '        // Adjust amount by locked balances\n', '        uint amount = lockedTokenBalances[msg.sender];\n', '\n', '        if (amount > 0) {\n', '            // Update state variables\n', '            lockedTokenBalances[msg.sender] = sub(lockedTokenBalances[msg.sender], amount);\n', '            unlockedTokens[msg.sender].amountUnlocked = add(unlockedTokens[msg.sender].amountUnlocked, amount);\n', '            unlockedTokens[msg.sender].withdrawalTime = now + 24 hours;\n', '        }\n', '\n', '        // Get return variables\n', '        totalAmountUnlocked = unlockedTokens[msg.sender].amountUnlocked;\n', '        withdrawalTime = unlockedTokens[msg.sender].withdrawalTime;\n', '    }\n', '\n', '    function withdrawUnlockedTokens() public {\n', '        require(unlockedTokens[msg.sender].withdrawalTime < now, "The tokens cannot be withdrawn yet");\n', '        balances[msg.sender] = add(balances[msg.sender], unlockedTokens[msg.sender].amountUnlocked);\n', '        unlockedTokens[msg.sender].amountUnlocked = 0;\n', '    }\n', '\n', '    function min(uint a, uint b) public pure returns (uint) {\n', '        if (a < b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '    \n', '    /// @dev Returns whether an add operation causes an overflow\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Did no overflow occur?\n', '    function safeToAdd(uint a, uint b) public pure returns (bool) {\n', '        return a + b >= a;\n', '    }\n', '\n', '    /// @dev Returns whether a subtraction operation causes an underflow\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Did no underflow occur?\n', '    function safeToSub(uint a, uint b) public pure returns (bool) {\n', '        return a >= b;\n', '    }\n', '\n', '    /// @dev Returns sum if no overflow occurred\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Sum\n', '    function add(uint a, uint b) public pure returns (uint) {\n', '        require(safeToAdd(a, b), "It must be a safe adition");\n', '        return a + b;\n', '    }\n', '\n', '    /// @dev Returns difference if no overflow occurred\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Difference\n', '    function sub(uint a, uint b) public pure returns (uint) {\n', '        require(safeToSub(a, b), "It must be a safe substraction");\n', '        return a - b;\n', '    }\n', '}\n', '\n', '// File: @gnosis.pm/owl-token/contracts/TokenOWL.sol\n', '\n', 'contract TokenOWL is Proxied, GnosisStandardToken {\n', '    using GnosisMath for *;\n', '\n', '    string public constant name = "OWL Token";\n', '    string public constant symbol = "OWL";\n', '    uint8 public constant decimals = 18;\n', '\n', '    struct masterCopyCountdownType {\n', '        address masterCopy;\n', '        uint timeWhenAvailable;\n', '    }\n', '\n', '    masterCopyCountdownType masterCopyCountdown;\n', '\n', '    address public creator;\n', '    address public minter;\n', '\n', '    event Minted(address indexed to, uint256 amount);\n', '    event Burnt(address indexed from, address indexed user, uint256 amount);\n', '\n', '    modifier onlyCreator() {\n', '        // R1\n', '        require(msg.sender == creator, "Only the creator can perform the transaction");\n', '        _;\n', '    }\n', '    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\n', '    /// updating is only possible after 30 days\n', '    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\n', '        require(address(_masterCopy) != address(0), "The master copy must be a valid address");\n', '\n', '        // Update masterCopyCountdown\n', '        masterCopyCountdown.masterCopy = _masterCopy;\n', '        masterCopyCountdown.timeWhenAvailable = now + 30 days;\n', '    }\n', '\n', '    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\n', '    function updateMasterCopy() public onlyCreator {\n', '        require(address(masterCopyCountdown.masterCopy) != address(0), "The master copy must be a valid address");\n', '        require(\n', '            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\n', '            "It\'s not possible to update the master copy during the waiting period"\n', '        );\n', '\n', '        // Update masterCopy\n', '        masterCopy = masterCopyCountdown.masterCopy;\n', '    }\n', '\n', '    function getMasterCopy() public view returns (address) {\n', '        return masterCopy;\n', '    }\n', '\n', '    /// @dev Set minter. Only the creator of this contract can call this.\n', '    /// @param newMinter The new address authorized to mint this token\n', '    function setMinter(address newMinter) public onlyCreator {\n', '        minter = newMinter;\n', '    }\n', '\n', '    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\n', '    /// @param newOwner The new address, which should become the owner\n', '    function setNewOwner(address newOwner) public onlyCreator {\n', '        creator = newOwner;\n', '    }\n', '\n', '    /// @dev Mints OWL.\n', '    /// @param to Address to which the minted token will be given\n', '    /// @param amount Amount of OWL to be minted\n', '    function mintOWL(address to, uint amount) public {\n', '        require(minter != address(0), "The minter must be initialized");\n', '        require(msg.sender == minter, "Only the minter can mint OWL");\n', '        balances[to] = balances[to].add(amount);\n', '        totalTokens = totalTokens.add(amount);\n', '        emit Minted(to, amount);\n', '    }\n', '\n', '    /// @dev Burns OWL.\n', '    /// @param user Address of OWL owner\n', '    /// @param amount Amount of OWL to be burnt\n', '    function burnOWL(address user, uint amount) public {\n', '        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\n', '        balances[user] = balances[user].sub(amount);\n', '        totalTokens = totalTokens.sub(amount);\n', '        emit Burnt(msg.sender, user, amount);\n', '    }\n', '}\n', '\n', '// File: contracts/base/SafeTransfer.sol\n', '\n', 'interface BadToken {\n', '    function transfer(address to, uint value) external;\n', '    function transferFrom(address from, address to, uint value) external;\n', '}\n', '\n', 'contract SafeTransfer {\n', '    function safeTransfer(address token, address to, uint value, bool from) internal returns (bool result) {\n', '        if (from) {\n', '            BadToken(token).transferFrom(msg.sender, address(this), value);\n', '        } else {\n', '            BadToken(token).transfer(to, value);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            switch returndatasize\n', '                case 0 {\n', '                    // This is our BadToken\n', '                    result := not(0) // result is true\n', '                }\n', '                case 32 {\n', '                    // This is our GoodToken\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0) // result == returndata of external call\n', '                }\n', '                default {\n', '                    // This is not an ERC20 token\n', '                    result := 0\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/base/AuctioneerManaged.sol\n', '\n', 'contract AuctioneerManaged {\n', '    // auctioneer has the power to manage some variables\n', '    address public auctioneer;\n', '\n', '    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\n', '        require(_auctioneer != address(0), "The auctioneer must be a valid address");\n', '        auctioneer = _auctioneer;\n', '    }\n', '\n', '    // > Modifiers\n', '    modifier onlyAuctioneer() {\n', '        // Only allows auctioneer to proceed\n', '        // R1\n', '        // require(msg.sender == auctioneer, "Only auctioneer can perform this operation");\n', '        require(msg.sender == auctioneer, "Only the auctioneer can nominate a new one");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/base/TokenWhitelist.sol\n', '\n', 'contract TokenWhitelist is AuctioneerManaged {\n', '    // Mapping that stores the tokens, which are approved\n', '    // Only tokens approved by auctioneer generate frtToken tokens\n', '    // addressToken => boolApproved\n', '    mapping(address => bool) public approvedTokens;\n', '\n', '    event Approval(address indexed token, bool approved);\n', '\n', '    /// @dev for quick overview of approved Tokens\n', '    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\n', '    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\n', '        uint length = addressesToCheck.length;\n', '\n', '        bool[] memory isApproved = new bool[](length);\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            isApproved[i] = approvedTokens[addressesToCheck[i]];\n', '        }\n', '\n', '        return isApproved;\n', '    }\n', '    \n', '    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\n', '        for (uint i = 0; i < token.length; i++) {\n', '            approvedTokens[token[i]] = approved;\n', '            emit Approval(token[i], approved);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/base/DxMath.sol\n', '\n', 'contract DxMath {\n', '    // > Math fns\n', '    function min(uint a, uint b) public pure returns (uint) {\n', '        if (a < b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    function atleastZero(int a) public pure returns (uint) {\n', '        if (a < 0) {\n', '            return 0;\n', '        } else {\n', '            return uint(a);\n', '        }\n', '    }\n', '    \n', '    /// @dev Returns whether an add operation causes an overflow\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Did no overflow occur?\n', '    function safeToAdd(uint a, uint b) public pure returns (bool) {\n', '        return a + b >= a;\n', '    }\n', '\n', '    /// @dev Returns whether a subtraction operation causes an underflow\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Did no underflow occur?\n', '    function safeToSub(uint a, uint b) public pure returns (bool) {\n', '        return a >= b;\n', '    }\n', '\n', '    /// @dev Returns whether a multiply operation causes an overflow\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Did no overflow occur?\n', '    function safeToMul(uint a, uint b) public pure returns (bool) {\n', '        return b == 0 || a * b / b == a;\n', '    }\n', '\n', '    /// @dev Returns sum if no overflow occurred\n', '    /// @param a First addend\n', '    /// @param b Second addend\n', '    /// @return Sum\n', '    function add(uint a, uint b) public pure returns (uint) {\n', '        require(safeToAdd(a, b));\n', '        return a + b;\n', '    }\n', '\n', '    /// @dev Returns difference if no overflow occurred\n', '    /// @param a Minuend\n', '    /// @param b Subtrahend\n', '    /// @return Difference\n', '    function sub(uint a, uint b) public pure returns (uint) {\n', '        require(safeToSub(a, b));\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Returns product if no overflow occurred\n', '    /// @param a First factor\n', '    /// @param b Second factor\n', '    /// @return Product\n', '    function mul(uint a, uint b) public pure returns (uint) {\n', '        require(safeToMul(a, b));\n', '        return a * b;\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/DSMath.sol\n', '\n', 'contract DSMath {\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '\n', '    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '\n', '    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) internal pure returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Oracle/DSAuth.sol\n', '\n', 'contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n', '}\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority(address indexed authority);\n', '    event LogSetOwner(address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority public authority;\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) public auth {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_) public auth {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "It must be an authorized call");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/DSNote.sol\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4 indexed sig,\n', '        address indexed guy,\n', '        bytes32 indexed foo,\n', '        bytes32 bar,\n', '        uint wad,\n', '        bytes fax\n', '    );\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(\n', '            msg.sig,\n', '            msg.sender,\n', '            foo,\n', '            bar,\n', '            msg.value,\n', '            msg.data\n', '        );\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/DSThing.sol\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {}\n', '\n', '// File: contracts/Oracle/PriceFeed.sol\n', '\n', '/// price-feed.sol\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', '\n', 'contract PriceFeed is DSThing {\n', '    uint128 val;\n', '    uint32 public zzz;\n', '\n', '    function peek() public view returns (bytes32, bool) {\n', '        return (bytes32(uint256(val)), block.timestamp < zzz);\n', '    }\n', '\n', '    function read() public view returns (bytes32) {\n', '        assert(block.timestamp < zzz);\n', '        return bytes32(uint256(val));\n', '    }\n', '\n', '    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\n', '        val = val_;\n', '        zzz = zzz_;\n', '        (bool success, ) = med_.call(abi.encodeWithSignature("poke()"));\n', '        require(success, "The poke must succeed");\n', '    }\n', '\n', '    function void() public payable note auth {\n', '        zzz = 0;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Oracle/DSValue.sol\n', '\n', 'contract DSValue is DSThing {\n', '    bool has;\n', '    bytes32 val;\n', '    function peek() public view returns (bytes32, bool) {\n', '        return (val, has);\n', '    }\n', '\n', '    function read() public view returns (bytes32) {\n', '        (bytes32 wut, bool _has) = peek();\n', '        assert(_has);\n', '        return wut;\n', '    }\n', '\n', '    function poke(bytes32 wut) public payable note auth {\n', '        val = wut;\n', '        has = true;\n', '    }\n', '\n', '    function void() public payable note auth {\n', '        // unset the value\n', '        has = false;\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/Medianizer.sol\n', '\n', 'contract Medianizer is DSValue {\n', '    mapping(bytes12 => address) public values;\n', '    mapping(address => bytes12) public indexes;\n', '    bytes12 public next = bytes12(uint96(1));\n', '    uint96 public minimun = 0x1;\n', '\n', '    function set(address wat) public auth {\n', '        bytes12 nextId = bytes12(uint96(next) + 1);\n', '        assert(nextId != 0x0);\n', '        set(next, wat);\n', '        next = nextId;\n', '    }\n', '\n', '    function set(bytes12 pos, address wat) public payable note auth {\n', '        require(pos != 0x0, "pos cannot be 0x0");\n', '        require(wat == address(0) || indexes[wat] == 0, "wat is not defined or it has an index");\n', '\n', '        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\n', '\n', '        if (wat != address(0)) {\n', '            indexes[wat] = pos;\n', '        }\n', '\n', '        values[pos] = wat;\n', '    }\n', '\n', '    function setMin(uint96 min_) public payable note auth {\n', '        require(min_ != 0x0, "min cannot be 0x0");\n', '        minimun = min_;\n', '    }\n', '\n', '    function setNext(bytes12 next_) public payable note auth {\n', '        require(next_ != 0x0, "next cannot be 0x0");\n', '        next = next_;\n', '    }\n', '\n', '    function unset(bytes12 pos) public {\n', '        set(pos, address(0));\n', '    }\n', '\n', '    function unset(address wat) public {\n', '        set(indexes[wat], address(0));\n', '    }\n', '\n', '    function poke() public {\n', '        poke(0);\n', '    }\n', '\n', '    function poke(bytes32) public payable note {\n', '        (val, has) = compute();\n', '    }\n', '\n', '    function compute() public view returns (bytes32, bool) {\n', '        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n', '        uint96 ctr = 0;\n', '        for (uint96 i = 1; i < uint96(next); i++) {\n', '            if (values[bytes12(i)] != address(0)) {\n', '                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\n', '                if (wuz) {\n', '                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n', '                        wuts[ctr] = wut;\n', '                    } else {\n', '                        uint96 j = 0;\n', '                        while (wut >= wuts[j]) {\n', '                            j++;\n', '                        }\n', '                        for (uint96 k = ctr; k > j; k--) {\n', '                            wuts[k] = wuts[k - 1];\n', '                        }\n', '                        wuts[j] = wut;\n', '                    }\n', '                    ctr++;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (ctr < minimun)\n', '            return (val, false);\n', '\n', '        bytes32 value;\n', '        if (ctr % 2 == 0) {\n', '            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\n', '            uint128 val2 = uint128(uint(wuts[ctr / 2]));\n', '            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\n', '        } else {\n', '            value = wuts[(ctr - 1) / 2];\n', '        }\n', '\n', '        return (value, true);\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/PriceOracleInterface.sol\n', '\n', '/*\n', 'This contract is the interface between the MakerDAO priceFeed and our DX platform.\n', '*/\n', '\n', '\n', '\n', '\n', 'contract PriceOracleInterface {\n', '    address public priceFeedSource;\n', '    address public owner;\n', '    bool public emergencyMode;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Only the owner can do the operation");\n', '        _;\n', '    }\n', '\n', '    /// @dev constructor of the contract\n', '    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\n', '    constructor(address _owner, address _priceFeedSource) public {\n', '        owner = _owner;\n', '        priceFeedSource = _priceFeedSource;\n', '    }\n', '    \n', '    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\n', '    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\n', '    function raiseEmergency(bool _emergencyMode) public onlyOwner {\n', '        emergencyMode = _emergencyMode;\n', '    }\n', '\n', '    /// @dev updates the priceFeedSource\n', '    /// @param _owner address of owner\n', '    function updateCurator(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '\n', '    /// @dev returns the USDETH price\n', '    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\n', '        return Medianizer(priceFeedSource).peek();\n', '    }\n', '\n', '    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\n', '    function getUSDETHPrice() public view returns (uint256) {\n', '        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\n', '        if (emergencyMode) {\n', '            return 600;\n', '        }\n', '        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\n', '\n', '        // ensuring that there is no underflow or overflow possible,\n', '        // even if the price is compromised\n', '        uint priceUint = uint256(price)/(1 ether);\n', '        if (priceUint == 0) {\n', '            return 1;\n', '        }\n', '        if (priceUint > 1000000) {\n', '            return 1000000; \n', '        }\n', '        return priceUint;\n', '    }\n', '}\n', '\n', '// File: contracts/base/EthOracle.sol\n', '\n', 'contract EthOracle is AuctioneerManaged, DxMath {\n', '    uint constant WAITING_PERIOD_CHANGE_ORACLE = 30 days;\n', '\n', '    // Price Oracle interface\n', '    PriceOracleInterface public ethUSDOracle;\n', '    // Price Oracle interface proposals during update process\n', '    PriceOracleInterface public newProposalEthUSDOracle;\n', '\n', '    uint public oracleInterfaceCountdown;\n', '\n', '    event NewOracleProposal(PriceOracleInterface priceOracleInterface);\n', '\n', '    function initiateEthUsdOracleUpdate(PriceOracleInterface _ethUSDOracle) public onlyAuctioneer {\n', '        require(address(_ethUSDOracle) != address(0), "The oracle address must be valid");\n', '        newProposalEthUSDOracle = _ethUSDOracle;\n', '        oracleInterfaceCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_ORACLE);\n', '        emit NewOracleProposal(_ethUSDOracle);\n', '    }\n', '\n', '    function updateEthUSDOracle() public {\n', '        require(address(newProposalEthUSDOracle) != address(0), "The new proposal must be a valid addres");\n', '        require(\n', '            oracleInterfaceCountdown < block.timestamp,\n', '            "It\'s not possible to update the oracle during the waiting period"\n', '        );\n', '        ethUSDOracle = newProposalEthUSDOracle;\n', '        newProposalEthUSDOracle = PriceOracleInterface(0);\n', '    }\n', '}\n', '\n', '// File: contracts/base/DxUpgrade.sol\n', '\n', 'contract DxUpgrade is Proxied, AuctioneerManaged, DxMath {\n', '    uint constant WAITING_PERIOD_CHANGE_MASTERCOPY = 30 days;\n', '\n', '    address public newMasterCopy;\n', '    // Time when new masterCopy is updatabale\n', '    uint public masterCopyCountdown;\n', '\n', '    event NewMasterCopyProposal(address newMasterCopy);\n', '\n', '    function startMasterCopyCountdown(address _masterCopy) public onlyAuctioneer {\n', '        require(_masterCopy != address(0), "The new master copy must be a valid address");\n', '\n', '        // Update masterCopyCountdown\n', '        newMasterCopy = _masterCopy;\n', '        masterCopyCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_MASTERCOPY);\n', '        emit NewMasterCopyProposal(_masterCopy);\n', '    }\n', '\n', '    function updateMasterCopy() public {\n', '        require(newMasterCopy != address(0), "The new master copy must be a valid address");\n', '        require(block.timestamp >= masterCopyCountdown, "The master contract cannot be updated in a waiting period");\n', '\n', '        // Update masterCopy\n', '        masterCopy = newMasterCopy;\n', '        newMasterCopy = address(0);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/DutchExchange.sol\n', '\n', '/// @title Dutch Exchange - exchange token pairs with the clever mechanism of the dutch auction\n', '/// @author Alex Herrmann - <alex@gnosis.pm>\n', '/// @author Dominik Teiml - <dominik@gnosis.pm>\n', '\n', 'contract DutchExchange is DxUpgrade, TokenWhitelist, EthOracle, SafeTransfer {\n', '\n', '    // The price is a rational number, so we need a concept of a fraction\n', '    struct Fraction {\n', '        uint num;\n', '        uint den;\n', '    }\n', '\n', '    uint constant WAITING_PERIOD_NEW_TOKEN_PAIR = 6 hours;\n', '    uint constant WAITING_PERIOD_NEW_AUCTION = 10 minutes;\n', '    uint constant AUCTION_START_WAITING_FOR_FUNDING = 1;\n', '\n', '    // > Storage\n', '    // Ether ERC-20 token\n', '    address public ethToken;\n', '\n', '    // Minimum required sell funding for adding a new token pair, in USD\n', '    uint public thresholdNewTokenPair;\n', '    // Minimum required sell funding for starting antoher auction, in USD\n', '    uint public thresholdNewAuction;\n', '    // Fee reduction token (magnolia, ERC-20 token)\n', '    TokenFRT public frtToken;\n', '    // Token for paying fees\n', '    TokenOWL public owlToken;\n', '\n', '    // For the following three mappings, there is one mapping for each token pair\n', '    // The order which the tokens should be called is smaller, larger\n', '    // These variables should never be called directly! They have getters below\n', '    // Token => Token => index\n', '    mapping(address => mapping(address => uint)) public latestAuctionIndices;\n', '    // Token => Token => time\n', '    mapping (address => mapping (address => uint)) public auctionStarts;\n', '    // Token => Token => auctionIndex => time\n', '    mapping (address => mapping (address => mapping (uint => uint))) public clearingTimes;\n', '\n', '    // Token => Token => auctionIndex => price\n', '    mapping(address => mapping(address => mapping(uint => Fraction))) public closingPrices;\n', '\n', '    // Token => Token => amount\n', '    mapping(address => mapping(address => uint)) public sellVolumesCurrent;\n', '    // Token => Token => amount\n', '    mapping(address => mapping(address => uint)) public sellVolumesNext;\n', '    // Token => Token => amount\n', '    mapping(address => mapping(address => uint)) public buyVolumes;\n', '\n', '    // Token => user => amount\n', "    // balances stores a user's balance in the DutchX\n", '    mapping(address => mapping(address => uint)) public balances;\n', '\n', '    // Token => Token => auctionIndex => amount\n', '    mapping(address => mapping(address => mapping(uint => uint))) public extraTokens;\n', '\n', '    // Token => Token =>  auctionIndex => user => amount\n', '    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\n', '    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\n', '    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\n', '\n', '    function depositAndSell(address sellToken, address buyToken, uint amount)\n', '        external\n', '        returns (uint newBal, uint auctionIndex, uint newSellerBal)\n', '    {\n', '        newBal = deposit(sellToken, amount);\n', '        (auctionIndex, newSellerBal) = postSellOrder(sellToken, buyToken, 0, amount);\n', '    }\n', '\n', '    function claimAndWithdraw(address sellToken, address buyToken, address user, uint auctionIndex, uint amount)\n', '        external\n', '        returns (uint returned, uint frtsIssued, uint newBal)\n', '    {\n', '        (returned, frtsIssued) = claimSellerFunds(sellToken, buyToken, user, auctionIndex);\n', '        newBal = withdraw(buyToken, amount);\n', '    }\n', '\n', '    /// @dev for multiple claims\n', '    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n', '    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n', '    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n', '    /// @param user is the user who wants to his tokens\n', '    function claimTokensFromSeveralAuctionsAsSeller(\n', '        address[] calldata auctionSellTokens,\n', '        address[] calldata auctionBuyTokens,\n', '        uint[] calldata auctionIndices,\n', '        address user\n', '    ) external returns (uint[] memory, uint[] memory)\n', '    {\n', '        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n', '\n', '        uint[] memory claimAmounts = new uint[](length);\n', '        uint[] memory frtsIssuedList = new uint[](length);\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            (claimAmounts[i], frtsIssuedList[i]) = claimSellerFunds(\n', '                auctionSellTokens[i],\n', '                auctionBuyTokens[i],\n', '                user,\n', '                auctionIndices[i]\n', '            );\n', '        }\n', '\n', '        return (claimAmounts, frtsIssuedList);\n', '    }\n', '\n', '    /// @dev for multiple claims\n', '    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n', '    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n', '    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n', '    /// @param user is the user who wants to his tokens\n', '    function claimTokensFromSeveralAuctionsAsBuyer(\n', '        address[] calldata auctionSellTokens,\n', '        address[] calldata auctionBuyTokens,\n', '        uint[] calldata auctionIndices,\n', '        address user\n', '    ) external returns (uint[] memory, uint[] memory)\n', '    {\n', '        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n', '\n', '        uint[] memory claimAmounts = new uint[](length);\n', '        uint[] memory frtsIssuedList = new uint[](length);\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            (claimAmounts[i], frtsIssuedList[i]) = claimBuyerFunds(\n', '                auctionSellTokens[i],\n', '                auctionBuyTokens[i],\n', '                user,\n', '                auctionIndices[i]\n', '            );\n', '        }\n', '\n', '        return (claimAmounts, frtsIssuedList);\n', '    }\n', '\n', '    /// @dev for multiple withdraws\n', '    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n', '    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n', '    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n', '    function claimAndWithdrawTokensFromSeveralAuctionsAsSeller(\n', '        address[] calldata auctionSellTokens,\n', '        address[] calldata auctionBuyTokens,\n', '        uint[] calldata auctionIndices\n', '    ) external returns (uint[] memory, uint frtsIssued)\n', '    {\n', '        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n', '\n', '        uint[] memory claimAmounts = new uint[](length);\n', '        uint claimFrts = 0;\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            (claimAmounts[i], claimFrts) = claimSellerFunds(\n', '                auctionSellTokens[i],\n', '                auctionBuyTokens[i],\n', '                msg.sender,\n', '                auctionIndices[i]\n', '            );\n', '\n', '            frtsIssued += claimFrts;\n', '\n', '            withdraw(auctionBuyTokens[i], claimAmounts[i]);\n', '        }\n', '\n', '        return (claimAmounts, frtsIssued);\n', '    }\n', '\n', '    /// @dev for multiple withdraws\n', '    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n', '    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n', '    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n', '    function claimAndWithdrawTokensFromSeveralAuctionsAsBuyer(\n', '        address[] calldata auctionSellTokens,\n', '        address[] calldata auctionBuyTokens,\n', '        uint[] calldata auctionIndices\n', '    ) external returns (uint[] memory, uint frtsIssued)\n', '    {\n', '        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n', '\n', '        uint[] memory claimAmounts = new uint[](length);\n', '        uint claimFrts = 0;\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            (claimAmounts[i], claimFrts) = claimBuyerFunds(\n', '                auctionSellTokens[i],\n', '                auctionBuyTokens[i],\n', '                msg.sender,\n', '                auctionIndices[i]\n', '            );\n', '\n', '            frtsIssued += claimFrts;\n', '\n', '            withdraw(auctionSellTokens[i], claimAmounts[i]);\n', '        }\n', '\n', '        return (claimAmounts, frtsIssued);\n', '    }\n', '\n', '    function getMasterCopy() external view returns (address) {\n', '        return masterCopy;\n', '    }\n', '\n', '    /// @dev Constructor-Function creates exchange\n', '    /// @param _frtToken - address of frtToken ERC-20 token\n', '    /// @param _owlToken - address of owlToken ERC-20 token\n', '    /// @param _auctioneer - auctioneer for managing interfaces\n', '    /// @param _ethToken - address of ETH ERC-20 token\n', '    /// @param _ethUSDOracle - address of the oracle contract for fetching feeds\n', '    /// @param _thresholdNewTokenPair - Minimum required sell funding for adding a new token pair, in USD\n', '    function setupDutchExchange(\n', '        TokenFRT _frtToken,\n', '        TokenOWL _owlToken,\n', '        address _auctioneer,\n', '        address _ethToken,\n', '        PriceOracleInterface _ethUSDOracle,\n', '        uint _thresholdNewTokenPair,\n', '        uint _thresholdNewAuction\n', '    ) public\n', '    {\n', "        // Make sure contract hasn't been initialised\n", '        require(ethToken == address(0), "The contract must be uninitialized");\n', '\n', '        // Validates inputs\n', '        require(address(_owlToken) != address(0), "The OWL address must be valid");\n', '        require(address(_frtToken) != address(0), "The FRT address must be valid");\n', '        require(_auctioneer != address(0), "The auctioneer address must be valid");\n', '        require(_ethToken != address(0), "The WETH address must be valid");\n', '        require(address(_ethUSDOracle) != address(0), "The oracle address must be valid");\n', '\n', '        frtToken = _frtToken;\n', '        owlToken = _owlToken;\n', '        auctioneer = _auctioneer;\n', '        ethToken = _ethToken;\n', '        ethUSDOracle = _ethUSDOracle;\n', '        thresholdNewTokenPair = _thresholdNewTokenPair;\n', '        thresholdNewAuction = _thresholdNewAuction;\n', '    }\n', '\n', '    function updateThresholdNewTokenPair(uint _thresholdNewTokenPair) public onlyAuctioneer {\n', '        thresholdNewTokenPair = _thresholdNewTokenPair;\n', '    }\n', '\n', '    function updateThresholdNewAuction(uint _thresholdNewAuction) public onlyAuctioneer {\n', '        thresholdNewAuction = _thresholdNewAuction;\n', '    }\n', '\n', '    /// @param initialClosingPriceNum initial price will be 2 * initialClosingPrice. This is its numerator\n', '    /// @param initialClosingPriceDen initial price will be 2 * initialClosingPrice. This is its denominator\n', '    function addTokenPair(\n', '        address token1,\n', '        address token2,\n', '        uint token1Funding,\n', '        uint token2Funding,\n', '        uint initialClosingPriceNum,\n', '        uint initialClosingPriceDen\n', '    ) public\n', '    {\n', '        // R1\n', '        require(token1 != token2, "You cannot add a token pair using the same token");\n', '\n', '        // R2\n', '        require(initialClosingPriceNum != 0, "You must set the numerator for the initial price");\n', '\n', '        // R3\n', '        require(initialClosingPriceDen != 0, "You must set the denominator for the initial price");\n', '\n', '        // R4\n', '        require(getAuctionIndex(token1, token2) == 0, "The token pair was already added");\n', '\n', '        // R5: to prevent overflow\n', '        require(initialClosingPriceNum < 10 ** 18, "You must set a smaller numerator for the initial price");\n', '\n', '        // R6\n', '        require(initialClosingPriceDen < 10 ** 18, "You must set a smaller denominator for the initial price");\n', '\n', '        setAuctionIndex(token1, token2);\n', '\n', '        token1Funding = min(token1Funding, balances[token1][msg.sender]);\n', '        token2Funding = min(token2Funding, balances[token2][msg.sender]);\n', '\n', '        // R7\n', '        require(token1Funding < 10 ** 30, "You should use a smaller funding for token 1");\n', '\n', '        // R8\n', '        require(token2Funding < 10 ** 30, "You should use a smaller funding for token 2");\n', '\n', '        uint fundedValueUSD;\n', '        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n', '\n', '        // Compute fundedValueUSD\n', '        address ethTokenMem = ethToken;\n', '        if (token1 == ethTokenMem) {\n', '            // C1\n', '            // MUL: 10^30 * 10^6 = 10^36\n', '            fundedValueUSD = mul(token1Funding, ethUSDPrice);\n', '        } else if (token2 == ethTokenMem) {\n', '            // C2\n', '            // MUL: 10^30 * 10^6 = 10^36\n', '            fundedValueUSD = mul(token2Funding, ethUSDPrice);\n', '        } else {\n', '            // C3: Neither token is ethToken\n', '            fundedValueUSD = calculateFundedValueTokenToken(\n', '                token1,\n', '                token2,\n', '                token1Funding,\n', '                token2Funding,\n', '                ethTokenMem,\n', '                ethUSDPrice\n', '            );\n', '        }\n', '\n', '        // R5\n', '        require(fundedValueUSD >= thresholdNewTokenPair, "You should surplus the threshold for adding token pairs");\n', '\n', '        // Save prices of opposite auctions\n', '        closingPrices[token1][token2][0] = Fraction(initialClosingPriceNum, initialClosingPriceDen);\n', '        closingPrices[token2][token1][0] = Fraction(initialClosingPriceDen, initialClosingPriceNum);\n', '\n', '        // Split into two fns because of 16 local-var cap\n', '        addTokenPairSecondPart(token1, token2, token1Funding, token2Funding);\n', '    }\n', '\n', '    function deposit(address tokenAddress, uint amount) public returns (uint) {\n', '        // R1\n', '        require(safeTransfer(tokenAddress, msg.sender, amount, true), "The deposit transaction must succeed");\n', '\n', '        uint newBal = add(balances[tokenAddress][msg.sender], amount);\n', '\n', '        balances[tokenAddress][msg.sender] = newBal;\n', '\n', '        emit NewDeposit(tokenAddress, amount);\n', '\n', '        return newBal;\n', '    }\n', '\n', '    function withdraw(address tokenAddress, uint amount) public returns (uint) {\n', '        uint usersBalance = balances[tokenAddress][msg.sender];\n', '        amount = min(amount, usersBalance);\n', '\n', '        // R1\n', '        require(amount > 0, "The amount must be greater than 0");\n', '\n', '        uint newBal = sub(usersBalance, amount);\n', '        balances[tokenAddress][msg.sender] = newBal;\n', '\n', '        // R2\n', '        require(safeTransfer(tokenAddress, msg.sender, amount, false), "The withdraw transfer must succeed");\n', '        emit NewWithdrawal(tokenAddress, amount);\n', '\n', '        return newBal;\n', '    }\n', '\n', '    function postSellOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n', '        public\n', '        returns (uint, uint)\n', '    {\n', '        // Note: if a user specifies auctionIndex of 0, it\n', '        // means he is agnostic which auction his sell order goes into\n', '\n', '        amount = min(amount, balances[sellToken][msg.sender]);\n', '\n', '        // R1\n', '        // require(amount >= 0, "Sell amount should be greater than 0");\n', '\n', '        // R2\n', '        uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n', '        require(latestAuctionIndex > 0);\n', '\n', '        // R3\n', '        uint auctionStart = getAuctionStart(sellToken, buyToken);\n', '        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n', '            // C1: We are in the 10 minute buffer period\n', '            // OR waiting for an auction to receive sufficient sellVolume\n', '            // Auction has already cleared, and index has been incremented\n', '            // sell order must use that auction index\n', '            // R1.1\n', '            if (auctionIndex == 0) {\n', '                auctionIndex = latestAuctionIndex;\n', '            } else {\n', '                require(auctionIndex == latestAuctionIndex, "Auction index should be equal to latest auction index");\n', '            }\n', '\n', '            // R1.2\n', '            require(add(sellVolumesCurrent[sellToken][buyToken], amount) < 10 ** 30);\n', '        } else {\n', '            // C2\n', '            // R2.1: Sell orders must go to next auction\n', '            if (auctionIndex == 0) {\n', '                auctionIndex = latestAuctionIndex + 1;\n', '            } else {\n', '                require(auctionIndex == latestAuctionIndex + 1);\n', '            }\n', '\n', '            // R2.2\n', '            require(add(sellVolumesNext[sellToken][buyToken], amount) < 10 ** 30);\n', '        }\n', '\n', '        // Fee mechanism, fees are added to extraTokens\n', '        uint amountAfterFee = settleFee(sellToken, buyToken, auctionIndex, amount);\n', '\n', '        // Update variables\n', '        balances[sellToken][msg.sender] = sub(balances[sellToken][msg.sender], amount);\n', '        uint newSellerBal = add(sellerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n', '        sellerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newSellerBal;\n', '\n', '        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n', '            // C1\n', '            uint sellVolumeCurrent = sellVolumesCurrent[sellToken][buyToken];\n', '            sellVolumesCurrent[sellToken][buyToken] = add(sellVolumeCurrent, amountAfterFee);\n', '        } else {\n', '            // C2\n', '            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n', '            sellVolumesNext[sellToken][buyToken] = add(sellVolumeNext, amountAfterFee);\n', '\n', '            // close previous auction if theoretically closed\n', '            closeTheoreticalClosedAuction(sellToken, buyToken, latestAuctionIndex);\n', '        }\n', '\n', '        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING) {\n', '            scheduleNextAuction(sellToken, buyToken);\n', '        }\n', '\n', '        emit NewSellOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n', '\n', '        return (auctionIndex, newSellerBal);\n', '    }\n', '\n', '    function postBuyOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n', '        public\n', '        returns (uint newBuyerBal)\n', '    {\n', '        // R1: auction must not have cleared\n', '        require(closingPrices[sellToken][buyToken][auctionIndex].den == 0);\n', '\n', '        uint auctionStart = getAuctionStart(sellToken, buyToken);\n', '\n', '        // R2\n', '        require(auctionStart <= now);\n', '\n', '        // R4\n', '        require(auctionIndex == getAuctionIndex(sellToken, buyToken));\n', '\n', '        // R5: auction must not be in waiting period\n', '        require(auctionStart > AUCTION_START_WAITING_FOR_FUNDING);\n', '\n', '        // R6: auction must be funded\n', '        require(sellVolumesCurrent[sellToken][buyToken] > 0);\n', '\n', '        uint buyVolume = buyVolumes[sellToken][buyToken];\n', '        amount = min(amount, balances[buyToken][msg.sender]);\n', '\n', '        // R7\n', '        require(add(buyVolume, amount) < 10 ** 30);\n', '\n', '        // Overbuy is when a part of a buy order clears an auction\n', '        // In that case we only process the part before the overbuy\n', '        // To calculate overbuy, we first get current price\n', '        uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n', '\n', '        uint num;\n', '        uint den;\n', '        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n', '        // 10^30 * 10^37 = 10^67\n', '        uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n', '\n', '        uint amountAfterFee;\n', '        if (amount < outstandingVolume) {\n', '            if (amount > 0) {\n', '                amountAfterFee = settleFee(buyToken, sellToken, auctionIndex, amount);\n', '            }\n', '        } else {\n', '            amount = outstandingVolume;\n', '            amountAfterFee = outstandingVolume;\n', '        }\n', '\n', "        // Here we could also use outstandingVolume or amountAfterFee, it doesn't matter\n", '        if (amount > 0) {\n', '            // Update variables\n', '            balances[buyToken][msg.sender] = sub(balances[buyToken][msg.sender], amount);\n', '            newBuyerBal = add(buyerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n', '            buyerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newBuyerBal;\n', '            buyVolumes[sellToken][buyToken] = add(buyVolumes[sellToken][buyToken], amountAfterFee);\n', '            emit NewBuyOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n', '        }\n', '\n', '        // Checking for equality would suffice here. nevertheless:\n', '        if (amount >= outstandingVolume) {\n', '            // Clear auction\n', '            clearAuction(sellToken, buyToken, auctionIndex, sellVolume);\n', '        }\n', '\n', '        return (newBuyerBal);\n', '    }\n', '\n', '    function claimSellerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n', '        public\n', '        returns (\n', '        // < (10^60, 10^61)\n', '        uint returned,\n', '        uint frtsIssued\n', '    )\n', '    {\n', '        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n', '        uint sellerBalance = sellerBalances[sellToken][buyToken][auctionIndex][user];\n', '\n', '        // R1\n', '        require(sellerBalance > 0);\n', '\n', '        // Get closing price for said auction\n', '        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n', '        uint num = closingPrice.num;\n', '        uint den = closingPrice.den;\n', '\n', '        // R2: require auction to have cleared\n', '        require(den > 0);\n', '\n', '        // Calculate return\n', '        // < 10^30 * 10^30 = 10^60\n', '        returned = mul(sellerBalance, num) / den;\n', '\n', '        frtsIssued = issueFrts(\n', '            sellToken,\n', '            buyToken,\n', '            returned,\n', '            auctionIndex,\n', '            sellerBalance,\n', '            user\n', '        );\n', '\n', '        // Claim tokens\n', '        sellerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n', '        if (returned > 0) {\n', '            balances[buyToken][user] = add(balances[buyToken][user], returned);\n', '        }\n', '        emit NewSellerFundsClaim(\n', '            sellToken,\n', '            buyToken,\n', '            user,\n', '            auctionIndex,\n', '            returned,\n', '            frtsIssued\n', '        );\n', '    }\n', '\n', '    function claimBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n', '        public\n', '        returns (uint returned, uint frtsIssued)\n', '    {\n', '        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n', '\n', '        uint num;\n', '        uint den;\n', '        (returned, num, den) = getUnclaimedBuyerFunds(sellToken, buyToken, user, auctionIndex);\n', '\n', '        if (closingPrices[sellToken][buyToken][auctionIndex].den == 0) {\n', '            // Auction is running\n', '            claimedAmounts[sellToken][buyToken][auctionIndex][user] = add(\n', '                claimedAmounts[sellToken][buyToken][auctionIndex][user],\n', '                returned\n', '            );\n', '        } else {\n', '            // Auction has closed\n', "            // We DON'T want to check for returned > 0, because that would fail if a user claims\n", '            // intermediate funds & auction clears in same block (he/she would not be able to claim extraTokens)\n', '\n', '            // Assign extra sell tokens (this is possible only after auction has cleared,\n', '            // because buyVolume could still increase before that)\n', '            uint extraTokensTotal = extraTokens[sellToken][buyToken][auctionIndex];\n', '            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n', '\n', '            // closingPrices.num represents buyVolume\n', '            // < 10^30 * 10^30 = 10^60\n', '            uint tokensExtra = mul(\n', '                buyerBalance,\n', '                extraTokensTotal\n', '            ) / closingPrices[sellToken][buyToken][auctionIndex].num;\n', '            returned = add(returned, tokensExtra);\n', '\n', '            frtsIssued = issueFrts(\n', '                buyToken,\n', '                sellToken,\n', '                mul(buyerBalance, den) / num,\n', '                auctionIndex,\n', '                buyerBalance,\n', '                user\n', '            );\n', '\n', '            // Auction has closed\n', '            // Reset buyerBalances and claimedAmounts\n', '            buyerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n', '            claimedAmounts[sellToken][buyToken][auctionIndex][user] = 0;\n', '        }\n', '\n', '        // Claim tokens\n', '        if (returned > 0) {\n', '            balances[sellToken][user] = add(balances[sellToken][user], returned);\n', '        }\n', '\n', '        emit NewBuyerFundsClaim(\n', '            sellToken,\n', '            buyToken,\n', '            user,\n', '            auctionIndex,\n', '            returned,\n', '            frtsIssued\n', '        );\n', '    }\n', '\n', '    /// @dev allows to close possible theoretical closed markets\n', '    /// @param sellToken sellToken of an auction\n', '    /// @param buyToken buyToken of an auction\n', '    /// @param auctionIndex is the auctionIndex of the auction\n', '    function closeTheoreticalClosedAuction(address sellToken, address buyToken, uint auctionIndex) public {\n', '        if (auctionIndex == getAuctionIndex(\n', '            buyToken,\n', '            sellToken\n', '        ) && closingPrices[sellToken][buyToken][auctionIndex].num == 0) {\n', '            uint buyVolume = buyVolumes[sellToken][buyToken];\n', '            uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n', '            uint num;\n', '            uint den;\n', '            (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n', '            // 10^30 * 10^37 = 10^67\n', '            if (sellVolume > 0) {\n', '                uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n', '\n', '                if (outstandingVolume == 0) {\n', '                    postBuyOrder(sellToken, buyToken, auctionIndex, 0);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Claim buyer funds for one auction\n', '    function getUnclaimedBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n', '        public\n', '        view\n', '        returns (\n', '        // < (10^67, 10^37)\n', '        uint unclaimedBuyerFunds,\n', '        uint num,\n', '        uint den\n', '    )\n', '    {\n', '        // R1: checks if particular auction has ever run\n', '        require(auctionIndex <= getAuctionIndex(sellToken, buyToken));\n', '\n', '        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n', '\n', '        if (num == 0) {\n', '            // This should rarely happen - as long as there is >= 1 buy order,\n', '            // auction will clear before price = 0. So this is just fail-safe\n', '            unclaimedBuyerFunds = 0;\n', '        } else {\n', '            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n', '            // < 10^30 * 10^37 = 10^67\n', '            unclaimedBuyerFunds = atleastZero(\n', '                int(mul(buyerBalance, den) / num - claimedAmounts[sellToken][buyToken][auctionIndex][user])\n', '            );\n', '        }\n', '    }\n', '\n', '    function getFeeRatio(address user)\n', '        public\n', '        view\n', '        returns (\n', '        // feeRatio < 10^4\n', '        uint num,\n', '        uint den\n', '    )\n', '    {\n', '        uint totalSupply = frtToken.totalSupply();\n', '        uint lockedFrt = frtToken.lockedTokenBalances(user);\n', '\n', '        /*\n', '          Fee Model:\n', '            locked FRT range     Fee\n', '            -----------------   ------\n', '            [0, 0.01%)           0.5%\n', '            [0.01%, 0.1%)        0.4%\n', '            [0.1%, 1%)           0.3%\n', '            [1%, 10%)            0.2%\n', '            [10%, 100%)          0.1%\n', '        */\n', '\n', '        if (lockedFrt * 10000 < totalSupply || totalSupply == 0) {\n', '            // Maximum fee, if user has locked less than 0.01% of the total FRT\n', '            // Fee: 0.5%\n', '            num = 1;\n', '            den = 200;\n', '        } else if (lockedFrt * 1000 < totalSupply) {\n', '            // If user has locked more than 0.01% and less than 0.1% of the total FRT\n', '            // Fee: 0.4%\n', '            num = 1;\n', '            den = 250;\n', '        } else if (lockedFrt * 100 < totalSupply) {\n', '            // If user has locked more than 0.1% and less than 1% of the total FRT\n', '            // Fee: 0.3%\n', '            num = 3;\n', '            den = 1000;\n', '        } else if (lockedFrt * 10 < totalSupply) {\n', '            // If user has locked more than 1% and less than 10% of the total FRT\n', '            // Fee: 0.2%\n', '            num = 1;\n', '            den = 500;\n', '        } else {\n', '            // If user has locked more than 10% of the total FRT\n', '            // Fee: 0.1%\n', '            num = 1;\n', '            den = 1000;\n', '        }\n', '    }\n', '\n', '    //@ dev returns price in units [token2]/[token1]\n', '    //@ param token1 first token for price calculation\n', '    //@ param token2 second token for price calculation\n', '    //@ param auctionIndex index for the auction to get the averaged price from\n', '    function getPriceInPastAuction(\n', '        address token1,\n', '        address token2,\n', '        uint auctionIndex\n', '    )\n', '        public\n', '        view\n', '        // price < 10^31\n', '        returns (uint num, uint den)\n', '    {\n', '        if (token1 == token2) {\n', '            // C1\n', '            num = 1;\n', '            den = 1;\n', '        } else {\n', '            // C2\n', '            // R2.1\n', '            // require(auctionIndex >= 0);\n', '\n', '            // C3\n', '            // R3.1\n', '            require(auctionIndex <= getAuctionIndex(token1, token2));\n', '            // auction still running\n', '\n', '            uint i = 0;\n', '            bool correctPair = false;\n', '            Fraction memory closingPriceToken1;\n', '            Fraction memory closingPriceToken2;\n', '\n', '            while (!correctPair) {\n', '                closingPriceToken2 = closingPrices[token2][token1][auctionIndex - i];\n', '                closingPriceToken1 = closingPrices[token1][token2][auctionIndex - i];\n', '\n', '                if (closingPriceToken1.num > 0 && closingPriceToken1.den > 0 ||\n', '                    closingPriceToken2.num > 0 && closingPriceToken2.den > 0)\n', '                {\n', '                    correctPair = true;\n', '                }\n', '                i++;\n', '            }\n', '\n', '            // At this point at least one closing price is strictly positive\n', '            // If only one is positive, we want to output that\n', '            if (closingPriceToken1.num == 0 || closingPriceToken1.den == 0) {\n', '                num = closingPriceToken2.den;\n', '                den = closingPriceToken2.num;\n', '            } else if (closingPriceToken2.num == 0 || closingPriceToken2.den == 0) {\n', '                num = closingPriceToken1.num;\n', '                den = closingPriceToken1.den;\n', '            } else {\n', '                // If both prices are positive, output weighted average\n', '                num = closingPriceToken2.den + closingPriceToken1.num;\n', '                den = closingPriceToken2.num + closingPriceToken1.den;\n', '            }\n', '        }\n', '    }\n', '\n', '    function scheduleNextAuction(\n', '        address sellToken,\n', '        address buyToken\n', '    )\n', '        internal\n', '    {\n', '        (uint sellVolume, uint sellVolumeOpp) = getSellVolumesInUSD(sellToken, buyToken);\n', '\n', '        bool enoughSellVolume = sellVolume >= thresholdNewAuction;\n', '        bool enoughSellVolumeOpp = sellVolumeOpp >= thresholdNewAuction;\n', '        bool schedule;\n', '        // Make sure both sides have liquidity in order to start the auction\n', '        if (enoughSellVolume && enoughSellVolumeOpp) {\n', '            schedule = true;\n', '        } else if (enoughSellVolume || enoughSellVolumeOpp) {\n', "            // But if the auction didn't start in 24h, then is enough to have\n", '            // liquidity in one of the two sides\n', '            uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n', '            uint clearingTime = getClearingTime(sellToken, buyToken, latestAuctionIndex - 1);\n', '            schedule = clearingTime <= now - 24 hours;\n', '        }\n', '\n', '        if (schedule) {\n', '            // Schedule next auction\n', '            setAuctionStart(sellToken, buyToken, WAITING_PERIOD_NEW_AUCTION);\n', '        } else {\n', '            resetAuctionStart(sellToken, buyToken);\n', '        }\n', '    }\n', '\n', '    function getSellVolumesInUSD(\n', '        address sellToken,\n', '        address buyToken\n', '    )\n', '        internal\n', '        view\n', '        returns (uint sellVolume, uint sellVolumeOpp)\n', '    {\n', '        // Check if auctions received enough sell orders\n', '        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n', '\n', '        uint sellNum;\n', '        uint sellDen;\n', '        (sellNum, sellDen) = getPriceOfTokenInLastAuction(sellToken);\n', '\n', '        uint buyNum;\n', '        uint buyDen;\n', '        (buyNum, buyDen) = getPriceOfTokenInLastAuction(buyToken);\n', '\n', '        // We use current sell volume, because in clearAuction() we set\n', '        // sellVolumesCurrent = sellVolumesNext before calling this function\n', "        // (this is so that we don't need case work,\n", '        // since it might also be called from postSellOrder())\n', '\n', '        // < 10^30 * 10^31 * 10^6 = 10^67\n', '        sellVolume = mul(mul(sellVolumesCurrent[sellToken][buyToken], sellNum), ethUSDPrice) / sellDen;\n', '        sellVolumeOpp = mul(mul(sellVolumesCurrent[buyToken][sellToken], buyNum), ethUSDPrice) / buyDen;\n', '    }\n', '\n', '    /// @dev Gives best estimate for market price of a token in ETH of any price oracle on the Ethereum network\n', '    /// @param token address of ERC-20 token\n', '    /// @return Weighted average of closing prices of opposite Token-ethToken auctions, based on their sellVolume\n', '    function getPriceOfTokenInLastAuction(address token)\n', '        public\n', '        view\n', '        returns (\n', '        // price < 10^31\n', '        uint num,\n', '        uint den\n', '    )\n', '    {\n', '        uint latestAuctionIndex = getAuctionIndex(token, ethToken);\n', '        // getPriceInPastAuction < 10^30\n', '        (num, den) = getPriceInPastAuction(token, ethToken, latestAuctionIndex - 1);\n', '    }\n', '\n', '    function getCurrentAuctionPrice(address sellToken, address buyToken, uint auctionIndex)\n', '        public\n', '        view\n', '        returns (\n', '        // price < 10^37\n', '        uint num,\n', '        uint den\n', '    )\n', '    {\n', '        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n', '\n', '        if (closingPrice.den != 0) {\n', '            // Auction has closed\n', '            (num, den) = (closingPrice.num, closingPrice.den);\n', '        } else if (auctionIndex > getAuctionIndex(sellToken, buyToken)) {\n', '            (num, den) = (0, 0);\n', '        } else {\n', '            // Auction is running\n', '            uint pastNum;\n', '            uint pastDen;\n', '            (pastNum, pastDen) = getPriceInPastAuction(sellToken, buyToken, auctionIndex - 1);\n', '\n', "            // If we're calling the function into an unstarted auction,\n", '            // it will return the starting price of that auction\n', '            uint timeElapsed = atleastZero(int(now - getAuctionStart(sellToken, buyToken)));\n', '\n', '            // The numbers below are chosen such that\n', '            // P(0 hrs) = 2 * lastClosingPrice, P(6 hrs) = lastClosingPrice, P(>=24 hrs) = 0\n', '\n', '            // 10^5 * 10^31 = 10^36\n', '            num = atleastZero(int((24 hours - timeElapsed) * pastNum));\n', '            // 10^6 * 10^31 = 10^37\n', '            den = mul((timeElapsed + 12 hours), pastDen);\n', '\n', '            if (mul(num, sellVolumesCurrent[sellToken][buyToken]) <= mul(den, buyVolumes[sellToken][buyToken])) {\n', '                num = buyVolumes[sellToken][buyToken];\n', '                den = sellVolumesCurrent[sellToken][buyToken];\n', '            }\n', '        }\n', '    }\n', '\n', '    // > Helper fns\n', '    function getTokenOrder(address token1, address token2) public pure returns (address, address) {\n', '        if (token2 < token1) {\n', '            (token1, token2) = (token2, token1);\n', '        }\n', '\n', '        return (token1, token2);\n', '    }\n', '\n', '    function getAuctionStart(address token1, address token2) public view returns (uint auctionStart) {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        auctionStart = auctionStarts[token1][token2];\n', '    }\n', '\n', '    function getAuctionIndex(address token1, address token2) public view returns (uint auctionIndex) {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        auctionIndex = latestAuctionIndices[token1][token2];\n', '    }\n', '\n', '    function calculateFundedValueTokenToken(\n', '        address token1,\n', '        address token2,\n', '        uint token1Funding,\n', '        uint token2Funding,\n', '        address ethTokenMem,\n', '        uint ethUSDPrice\n', '    )\n', '        internal\n', '        view\n', '        returns (uint fundedValueUSD)\n', '    {\n', '        // We require there to exist ethToken-Token auctions\n', '        // R3.1\n', '        require(getAuctionIndex(token1, ethTokenMem) > 0);\n', '\n', '        // R3.2\n', '        require(getAuctionIndex(token2, ethTokenMem) > 0);\n', '\n', '        // Price of Token 1\n', '        uint priceToken1Num;\n', '        uint priceToken1Den;\n', '        (priceToken1Num, priceToken1Den) = getPriceOfTokenInLastAuction(token1);\n', '\n', '        // Price of Token 2\n', '        uint priceToken2Num;\n', '        uint priceToken2Den;\n', '        (priceToken2Num, priceToken2Den) = getPriceOfTokenInLastAuction(token2);\n', '\n', '        // Compute funded value in ethToken and USD\n', '        // 10^30 * 10^30 = 10^60\n', '        uint fundedValueETH = add(\n', '            mul(token1Funding, priceToken1Num) / priceToken1Den,\n', '            token2Funding * priceToken2Num / priceToken2Den\n', '        );\n', '\n', '        fundedValueUSD = mul(fundedValueETH, ethUSDPrice);\n', '    }\n', '\n', '    function addTokenPairSecondPart(\n', '        address token1,\n', '        address token2,\n', '        uint token1Funding,\n', '        uint token2Funding\n', '    )\n', '        internal\n', '    {\n', '        balances[token1][msg.sender] = sub(balances[token1][msg.sender], token1Funding);\n', '        balances[token2][msg.sender] = sub(balances[token2][msg.sender], token2Funding);\n', '\n', '        // Fee mechanism, fees are added to extraTokens\n', '        uint token1FundingAfterFee = settleFee(token1, token2, 1, token1Funding);\n', '        uint token2FundingAfterFee = settleFee(token2, token1, 1, token2Funding);\n', '\n', '        // Update other variables\n', '        sellVolumesCurrent[token1][token2] = token1FundingAfterFee;\n', '        sellVolumesCurrent[token2][token1] = token2FundingAfterFee;\n', '        sellerBalances[token1][token2][1][msg.sender] = token1FundingAfterFee;\n', '        sellerBalances[token2][token1][1][msg.sender] = token2FundingAfterFee;\n', '\n', '        // Save clearingTime as adding time\n', '        (address tokenA, address tokenB) = getTokenOrder(token1, token2);\n', '        clearingTimes[tokenA][tokenB][0] = now;\n', '\n', '        setAuctionStart(token1, token2, WAITING_PERIOD_NEW_TOKEN_PAIR);\n', '        emit NewTokenPair(token1, token2);\n', '    }\n', '\n', '    function setClearingTime(\n', '        address token1,\n', '        address token2,\n', '        uint auctionIndex,\n', '        uint auctionStart,\n', '        uint sellVolume,\n', '        uint buyVolume\n', '    )\n', '        internal\n', '    {\n', '        (uint pastNum, uint pastDen) = getPriceInPastAuction(token1, token2, auctionIndex - 1);\n', '        // timeElapsed = (12 hours)*(2 * pastNum * sellVolume - buyVolume * pastDen)/\n', '            // (sellVolume * pastNum + buyVolume * pastDen)\n', '        uint numerator = sub(mul(mul(pastNum, sellVolume), 24 hours), mul(mul(buyVolume, pastDen), 12 hours));\n', '        uint timeElapsed = numerator / (add(mul(sellVolume, pastNum), mul(buyVolume, pastDen)));\n', '        uint clearingTime = auctionStart + timeElapsed;\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        clearingTimes[token1][token2][auctionIndex] = clearingTime;\n', '    }\n', '\n', '    function getClearingTime(\n', '        address token1,\n', '        address token2,\n', '        uint auctionIndex\n', '    )\n', '        public\n', '        view\n', '        returns (uint time)\n', '    {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        time = clearingTimes[token1][token2][auctionIndex];\n', '    }\n', '\n', '    function issueFrts(\n', '        address primaryToken,\n', '        address secondaryToken,\n', '        uint x,\n', '        uint auctionIndex,\n', '        uint bal,\n', '        address user\n', '    )\n', '        internal\n', '        returns (uint frtsIssued)\n', '    {\n', '        if (approvedTokens[primaryToken] && approvedTokens[secondaryToken]) {\n', '            address ethTokenMem = ethToken;\n', '            // Get frts issued based on ETH price of returned tokens\n', '            if (primaryToken == ethTokenMem) {\n', '                frtsIssued = bal;\n', '            } else if (secondaryToken == ethTokenMem) {\n', '                // 10^30 * 10^39 = 10^66\n', '                frtsIssued = x;\n', '            } else {\n', '                // Neither token is ethToken, so we use getHhistoricalPriceOracle()\n', '                uint pastNum;\n', '                uint pastDen;\n', '                (pastNum, pastDen) = getPriceInPastAuction(primaryToken, ethTokenMem, auctionIndex - 1);\n', '                // 10^30 * 10^35 = 10^65\n', '                frtsIssued = mul(bal, pastNum) / pastDen;\n', '            }\n', '\n', '            if (frtsIssued > 0) {\n', '                // Issue frtToken\n', '                frtToken.mintTokens(user, frtsIssued);\n', '            }\n', '        }\n', '    }\n', '\n', '    function settleFee(address primaryToken, address secondaryToken, uint auctionIndex, uint amount)\n', '        internal\n', '        returns (\n', '        // < 10^30\n', '        uint amountAfterFee\n', '    )\n', '    {\n', '        uint feeNum;\n', '        uint feeDen;\n', '        (feeNum, feeDen) = getFeeRatio(msg.sender);\n', '        // 10^30 * 10^3 / 10^4 = 10^29\n', '        uint fee = mul(amount, feeNum) / feeDen;\n', '\n', '        if (fee > 0) {\n', '            fee = settleFeeSecondPart(primaryToken, fee);\n', '\n', '            uint usersExtraTokens = extraTokens[primaryToken][secondaryToken][auctionIndex + 1];\n', '            extraTokens[primaryToken][secondaryToken][auctionIndex + 1] = add(usersExtraTokens, fee);\n', '\n', '            emit Fee(primaryToken, secondaryToken, msg.sender, auctionIndex, fee);\n', '        }\n', '\n', '        amountAfterFee = sub(amount, fee);\n', '    }\n', '\n', '    function settleFeeSecondPart(address primaryToken, uint fee) internal returns (uint newFee) {\n', '        // Allow user to reduce up to half of the fee with owlToken\n', '        uint num;\n', '        uint den;\n', '        (num, den) = getPriceOfTokenInLastAuction(primaryToken);\n', '\n', '        // Convert fee to ETH, then USD\n', '        // 10^29 * 10^30 / 10^30 = 10^29\n', '        uint feeInETH = mul(fee, num) / den;\n', '\n', '        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n', '        // 10^29 * 10^6 = 10^35\n', '        // Uses 18 decimal places <> exactly as owlToken tokens: 10**18 owlToken == 1 USD\n', '        uint feeInUSD = mul(feeInETH, ethUSDPrice);\n', '        uint amountOfowlTokenBurned = min(owlToken.allowance(msg.sender, address(this)), feeInUSD / 2);\n', '        amountOfowlTokenBurned = min(owlToken.balanceOf(msg.sender), amountOfowlTokenBurned);\n', '\n', '        if (amountOfowlTokenBurned > 0) {\n', '            owlToken.burnOWL(msg.sender, amountOfowlTokenBurned);\n', '            // Adjust fee\n', '            // 10^35 * 10^29 = 10^64\n', '            uint adjustment = mul(amountOfowlTokenBurned, fee) / feeInUSD;\n', '            newFee = sub(fee, adjustment);\n', '        } else {\n', '            newFee = fee;\n', '        }\n', '    }\n', '\n', '    // addClearTimes\n', '    /// @dev clears an Auction\n', '    /// @param sellToken sellToken of the auction\n', '    /// @param buyToken  buyToken of the auction\n', '    /// @param auctionIndex of the auction to be cleared.\n', '    function clearAuction(\n', '        address sellToken,\n', '        address buyToken,\n', '        uint auctionIndex,\n', '        uint sellVolume\n', '    )\n', '        internal\n', '    {\n', '        // Get variables\n', '        uint buyVolume = buyVolumes[sellToken][buyToken];\n', '        uint sellVolumeOpp = sellVolumesCurrent[buyToken][sellToken];\n', '        uint closingPriceOppDen = closingPrices[buyToken][sellToken][auctionIndex].den;\n', '        uint auctionStart = getAuctionStart(sellToken, buyToken);\n', '\n', '        // Update closing price\n', '        if (sellVolume > 0) {\n', '            closingPrices[sellToken][buyToken][auctionIndex] = Fraction(buyVolume, sellVolume);\n', '        }\n', '\n', '        // if (opposite is 0 auction OR price = 0 OR opposite auction cleared)\n', '        // price = 0 happens if auction pair has been running for >= 24 hrs\n', '        if (sellVolumeOpp == 0 || now >= auctionStart + 24 hours || closingPriceOppDen > 0) {\n', '            // Close auction pair\n', '            uint buyVolumeOpp = buyVolumes[buyToken][sellToken];\n', '            if (closingPriceOppDen == 0 && sellVolumeOpp > 0) {\n', '                // Save opposite price\n', '                closingPrices[buyToken][sellToken][auctionIndex] = Fraction(buyVolumeOpp, sellVolumeOpp);\n', '            }\n', '\n', '            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n', '            uint sellVolumeNextOpp = sellVolumesNext[buyToken][sellToken];\n', '\n', '            // Update state variables for both auctions\n', '            sellVolumesCurrent[sellToken][buyToken] = sellVolumeNext;\n', '            if (sellVolumeNext > 0) {\n', '                sellVolumesNext[sellToken][buyToken] = 0;\n', '            }\n', '            if (buyVolume > 0) {\n', '                buyVolumes[sellToken][buyToken] = 0;\n', '            }\n', '\n', '            sellVolumesCurrent[buyToken][sellToken] = sellVolumeNextOpp;\n', '            if (sellVolumeNextOpp > 0) {\n', '                sellVolumesNext[buyToken][sellToken] = 0;\n', '            }\n', '            if (buyVolumeOpp > 0) {\n', '                buyVolumes[buyToken][sellToken] = 0;\n', '            }\n', '\n', '            // Save clearing time\n', '            setClearingTime(sellToken, buyToken, auctionIndex, auctionStart, sellVolume, buyVolume);\n', '            // Increment auction index\n', '            setAuctionIndex(sellToken, buyToken);\n', '            // Check if next auction can be scheduled\n', '            scheduleNextAuction(sellToken, buyToken);\n', '        }\n', '\n', '        emit AuctionCleared(sellToken, buyToken, sellVolume, buyVolume, auctionIndex);\n', '    }\n', '\n', '    function setAuctionStart(address token1, address token2, uint value) internal {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        uint auctionStart = now + value;\n', '        uint auctionIndex = latestAuctionIndices[token1][token2];\n', '        auctionStarts[token1][token2] = auctionStart;\n', '        emit AuctionStartScheduled(token1, token2, auctionIndex, auctionStart);\n', '    }\n', '\n', '    function resetAuctionStart(address token1, address token2) internal {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        if (auctionStarts[token1][token2] != AUCTION_START_WAITING_FOR_FUNDING) {\n', '            auctionStarts[token1][token2] = AUCTION_START_WAITING_FOR_FUNDING;\n', '        }\n', '    }\n', '\n', '    function setAuctionIndex(address token1, address token2) internal {\n', '        (token1, token2) = getTokenOrder(token1, token2);\n', '        latestAuctionIndices[token1][token2] += 1;\n', '    }\n', '\n', '    function checkLengthsForSeveralAuctionClaiming(\n', '        address[] memory auctionSellTokens,\n', '        address[] memory auctionBuyTokens,\n', '        uint[] memory auctionIndices\n', '    ) internal pure returns (uint length)\n', '    {\n', '        length = auctionSellTokens.length;\n', '        uint length2 = auctionBuyTokens.length;\n', '        require(length == length2);\n', '\n', '        uint length3 = auctionIndices.length;\n', '        require(length2 == length3);\n', '    }\n', '\n', '    // > Events\n', '    event NewDeposit(address indexed token, uint amount);\n', '\n', '    event NewWithdrawal(address indexed token, uint amount);\n', '\n', '    event NewSellOrder(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        address indexed user,\n', '        uint auctionIndex,\n', '        uint amount\n', '    );\n', '\n', '    event NewBuyOrder(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        address indexed user,\n', '        uint auctionIndex,\n', '        uint amount\n', '    );\n', '\n', '    event NewSellerFundsClaim(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        address indexed user,\n', '        uint auctionIndex,\n', '        uint amount,\n', '        uint frtsIssued\n', '    );\n', '\n', '    event NewBuyerFundsClaim(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        address indexed user,\n', '        uint auctionIndex,\n', '        uint amount,\n', '        uint frtsIssued\n', '    );\n', '\n', '    event NewTokenPair(address indexed sellToken, address indexed buyToken);\n', '\n', '    event AuctionCleared(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        uint sellVolume,\n', '        uint buyVolume,\n', '        uint indexed auctionIndex\n', '    );\n', '\n', '    event AuctionStartScheduled(\n', '        address indexed sellToken,\n', '        address indexed buyToken,\n', '        uint indexed auctionIndex,\n', '        uint auctionStart\n', '    );\n', '\n', '    event Fee(\n', '        address indexed primaryToken,\n', '        address indexed secondarToken,\n', '        address indexed user,\n', '        uint auctionIndex,\n', '        uint fee\n', '    );\n', '}']