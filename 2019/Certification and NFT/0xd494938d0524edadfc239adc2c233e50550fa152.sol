['contract Administrable {\n', '    using SafeMath for uint256;\n', '    mapping (address => bool) private admins;\n', '    uint256 private _nAdmin;\n', '    uint256 private _nLimit;\n', '\n', '    event Activated(address indexed admin);\n', '    event Deactivated(address indexed admin);\n', '\n', '    /**\n', '     * @dev The Administrable constructor sets the original `admin` of the contract to the sender\n', '     * account. The initial limit amount of admin is 2.\n', '     */\n', '    constructor() internal {\n', '        _setAdminLimit(2);\n', '        _activateAdmin(msg.sender);\n', '    }\n', '\n', '    function isAdmin() public view returns(bool) {\n', '        return admins[msg.sender];\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by non-admin.\n', '     */\n', '    modifier onlyAdmin() {\n', '        require(isAdmin(), "sender not admin");\n', '        _;\n', '    }\n', '\n', '    function activateAdmin(address admin) external onlyAdmin {\n', '        _activateAdmin(admin);\n', '    }\n', '\n', '    function deactivateAdmin(address admin) external onlyAdmin {\n', '        _safeDeactivateAdmin(admin);\n', '    }\n', '\n', '    function setAdminLimit(uint256 n) external onlyAdmin {\n', '        _setAdminLimit(n);\n', '    }\n', '\n', '    function _setAdminLimit(uint256 n) internal {\n', '        require(_nLimit != n, "same limit");\n', '        _nLimit = n;\n', '    }\n', '\n', '    /**\n', '     * @notice The Amount of admin should be bounded by _nLimit.\n', '     */\n', '    function _activateAdmin(address admin) internal {\n', '        require(admin != address(0), "invalid address");\n', '        require(_nAdmin < _nLimit, "too many admins existed");\n', '        require(!admins[admin], "already admin");\n', '        admins[admin] = true;\n', '        _nAdmin = _nAdmin.add(1);\n', '        emit Activated(admin);\n', '    }\n', '\n', '    /**\n', '     * @notice At least one admin should exists.\n', '     */\n', '    function _safeDeactivateAdmin(address admin) internal {\n', '        require(_nAdmin > 1, "admin should > 1");\n', '        _deactivateAdmin(admin);\n', '    }\n', '\n', '    function _deactivateAdmin(address admin) internal {\n', '        require(admins[admin], "not admin");\n', '        admins[admin] = false;\n', '        _nAdmin = _nAdmin.sub(1);\n', '        emit Deactivated(admin);\n', '    }\n', '}\n', '\n', 'library ErrorHandler {\n', '    function errorHandler(bytes memory ret) internal pure {\n', '        if (ret.length > 0) {\n', '            byte ec = abi.decode(ret, (byte));\n', '            if (ec != 0x00)\n', '                revert(byteToHexString(ec));\n', '        }\n', '    }\n', '\n', '    function byteToHexString(byte data) internal pure returns (string memory ret) {\n', '        bytes memory ec = bytes("0x00");\n', '        byte dataL = data & 0x0f;\n', '        byte dataH = data >> 4;\n', '        if (dataL < 0x0a)\n', '            ec[3] = byte(uint8(ec[3]) + uint8(dataL));\n', '        else\n', '            ec[3] = byte(uint8(ec[3]) + uint8(dataL) + 0x27);\n', '        if (dataH < 0x0a)\n', '            ec[2] = byte(uint8(ec[2]) + uint8(dataH));\n', '        else\n', '            ec[2] = byte(uint8(ec[2]) + uint8(dataH) + 0x27);\n', '\n', '        return string(ec);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'contract Proxy is Ownable {\n', '    using Address for address;\n', '\n', '    // keccak256 hash of "dinngo.proxy.implementation"\n', '    bytes32 private constant IMPLEMENTATION_SLOT =\n', '        0x3b2ff02c0f36dba7cc1b20a669e540b974575f04ef71846d482983efb03bebb4;\n', '\n', '    event Upgraded(address indexed implementation);\n', '\n', '    constructor(address implementation) internal {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("dinngo.proxy.implementation"));\n', '        _setImplementation(implementation);\n', '    }\n', '\n', '    /**\n', '     * @notice Upgrade the implementation contract. Can only be triggered\n', '     * by the owner. Emits the Upgraded event.\n', '     * @param implementation The new implementation address.\n', '     */\n', '    function upgrade(address implementation) external onlyOwner {\n', '        _setImplementation(implementation);\n', '        emit Upgraded(implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the implementation address in the storage slot.\n', '     * @param implementation The new implementation address.\n', '     */\n', '    function _setImplementation(address implementation) internal {\n', '        require(implementation.isContract(),\n', '            "Implementation address should be a contract address"\n', '        );\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        assembly {\n', '            sstore(slot, implementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation address.\n', '     */\n', '    function _implementation() internal view returns (address implementation) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        assembly {\n', '            implementation := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', 'contract TimelockUpgradableProxy is Proxy {\n', '    // keccak256 hash of "dinngo.proxy.registration"\n', '    bytes32 private constant REGISTRATION_SLOT =\n', '        0x90215db359d12011b32ff0c897114c39e26956599904ee846adb0dd49f782e97;\n', '    // keccak256 hash of "dinngo.proxy.time"\n', '    bytes32 private constant TIME_SLOT =\n', '        0xe89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6;\n', '    uint256 private constant UPGRADE_TIME = 14 days;\n', '\n', '    event UpgradeAnnounced(address indexed implementation, uint256 time);\n', '\n', '    constructor() internal {\n', '        assert(REGISTRATION_SLOT == keccak256("dinngo.proxy.registration"));\n', '        assert(TIME_SLOT == keccak256("dinngo.proxy.time"));\n', '    }\n', '\n', '    /**\n', '     * @notice Register the implementation address as the candidate contract\n', '     * to be upgraded. Emits the UpgradeAnnounced event.\n', '     * @param implementation The implementation contract address to be registered.\n', '     */\n', '    function register(address implementation) external onlyOwner {\n', '        _registerImplementation(implementation);\n', '        emit UpgradeAnnounced(implementation, _time());\n', '    }\n', '\n', '    /**\n', '     * @dev Overload the function in contract Proxy.\n', '     * @notice Upgrade the implementation contract.\n', '     * @param implementation The new implementation contract.\n', '     */\n', '    function upgrade(address implementation) external {\n', '        require(implementation == _registration());\n', '        upgradeAnnounced();\n', '    }\n', '\n', '    /**\n', '     * @notice Upgrade the implementation contract to the announced address.\n', '     * Emits the Upgraded event.\n', '     */\n', '    function upgradeAnnounced() public onlyOwner {\n', '        require(now >= _time());\n', '        _setImplementation(_registration());\n', '        emit Upgraded(_registration());\n', '    }\n', '\n', '    /**\n', '     * @dev Register the imeplemtation address to the registation slot. Record the\n', '     * valid time by adding the UPGRADE_TIME to the registration time to the time slot.\n', '     * @param implementation The implemetation address to be registered.\n', '     */\n', '    function _registerImplementation(address implementation) internal {\n', '        require(implementation.isContract(),\n', '            "Implementation address should be a contract address"\n', '        );\n', '        uint256 time = now + UPGRADE_TIME;\n', '\n', '        bytes32 implSlot = REGISTRATION_SLOT;\n', '        bytes32 timeSlot = TIME_SLOT;\n', '\n', '        assembly {\n', '            sstore(implSlot, implementation)\n', '            sstore(timeSlot, time)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Return the valid time of registered implementation address.\n', '     */\n', '    function _time() internal view returns (uint256 time) {\n', '        bytes32 slot = TIME_SLOT;\n', '\n', '        assembly {\n', '            time := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Return the registered implementation address.\n', '     */\n', '    function _registration() internal view returns (address implementation) {\n', '        bytes32 slot = REGISTRATION_SLOT;\n', '\n', '        assembly {\n', '            implementation := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', 'contract DinngoProxy is Ownable, Administrable, TimelockUpgradableProxy {\n', '    using ErrorHandler for bytes;\n', '\n', '    uint256 public processTime;\n', '\n', '    mapping (address => mapping (address => uint256)) public balances;\n', '    mapping (bytes32 => uint256) public orderFills;\n', '    mapping (uint256 => address payable) public userID_Address;\n', '    mapping (uint256 => address) public tokenID_Address;\n', '    mapping (address => uint256) public userRanks;\n', '    mapping (address => uint256) public tokenRanks;\n', '    mapping (address => uint256) public lockTimes;\n', '\n', '    /**\n', '     * @dev User ID 0 is the management wallet.\n', '     * Token ID 0 is ETH (address 0). Token ID 1 is DGO.\n', '     * @param dinngoWallet The main address of dinngo\n', '     * @param dinngoToken The contract address of DGO\n', '     */\n', '    constructor(\n', '        address payable dinngoWallet,\n', '        address dinngoToken,\n', '        address impl\n', '    ) Proxy(impl) public {\n', '        processTime = 90 days;\n', '        userID_Address[0] = dinngoWallet;\n', '        userRanks[dinngoWallet] = 255;\n', '        tokenID_Address[0] = address(0);\n', '        tokenID_Address[1] = dinngoToken;\n', '    }\n', '\n', '    /**\n', '     * @dev All ether directly sent to contract will be refunded\n', '     */\n', '    function() external payable {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '     * @notice Add the address to the user list. Event AddUser will be emitted\n', '     * after execution.\n', '     * @dev Record the user list to map the user address to a specific user ID, in\n', '     * order to compact the data size when transferring user address information\n', '     * @param id The user id to be assigned\n', '     * @param user The user address to be added\n', '     */\n', '    function addUser(uint256 id, address user) external onlyAdmin {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("addUser(uint256,address)", id, user)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove the address from the user list.\n', '     * @dev The user rank is set to 0 to remove the user.\n', '     * @param user The user address to be added\n', '     */\n', '    function removeUser(address user) external onlyAdmin {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("removeUser(address)", user)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Update the rank of user. Can only be called by owner.\n', '     * @param user The user address\n', '     * @param rank The rank to be assigned\n', '     */\n', '    function updateUserRank(address user, uint256 rank) external onlyAdmin {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("updateUserRank(address,uint256)",user, rank)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Add the token to the token list. Event AddToken will be emitted\n', '     * after execution.\n', '     * @dev Record the token list to map the token contract address to a specific\n', '     * token ID, in order to compact the data size when transferring token contract\n', '     * address information\n', '     * @param id The token id to be assigned\n', '     * @param token The token contract address to be added\n', '     */\n', '    function addToken(uint256 id, address token) external onlyOwner {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("addToken(uint256,address)", id, token)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove the token to the token list.\n', '     * @dev The token rank is set to 0 to remove the token.\n', '     * @param token The token contract address to be removed.\n', '     */\n', '    function removeToken(address token) external onlyOwner {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("removeToken(address)", token)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Update the rank of token. Can only be called by owner.\n', '     * @param token The token contract address.\n', '     * @param rank The rank to be assigned.\n', '     */\n', '    function updateTokenRank(address token, uint256 rank) external onlyOwner {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("updateTokenRank(address,uint256)", token, rank)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    function activateAdmin(address admin) external onlyOwner {\n', '        _activateAdmin(admin);\n', '    }\n', '\n', '    function deactivateAdmin(address admin) external onlyOwner {\n', '        _safeDeactivateAdmin(admin);\n', '    }\n', '\n', '    /**\n', '     * @notice Force-deactivate allows owner to deactivate admin even there will be\n', '     * no admin left. Should only be executed under emergency situation.\n', '     */\n', '    function forceDeactivateAdmin(address admin) external onlyOwner {\n', '        _deactivateAdmin(admin);\n', '    }\n', '\n', '    function setAdminLimit(uint256 n) external onlyOwner {\n', '        _setAdminLimit(n);\n', '    }\n', '\n', '    /**\n', '     * @notice The deposit function for ether. The ether that is sent with the function\n', '     * call will be deposited. The first time user will be added to the user list.\n', '     * Event Deposit will be emitted after execution.\n', '     */\n', '    function deposit() external payable {\n', '        (bool ok,) = _implementation().delegatecall(abi.encodeWithSignature("deposit()"));\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice The deposit function for tokens. The first time user will be added to\n', '     * the user list. Event Deposit will be emitted after execution.\n', '     * @param token Address of the token contract to be deposited\n', '     * @param amount Amount of the token to be depositied\n', '     */\n', '    function depositToken(address token, uint256 amount) external {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("depositToken(address,uint256)", token, amount)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice The withdraw function for ether. Event Withdraw will be emitted\n', '     * after execution. User needs to be locked before calling withdraw.\n', '     * @param amount The amount to be withdrawn.\n', '     */\n', '    function withdraw(uint256 amount) external {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("withdraw(uint256)", amount)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice The withdraw function for tokens. Event Withdraw will be emitted\n', '     * after execution. User needs to be locked before calling withdraw.\n', '     * @param token The token contract address to be withdrawn.\n', '     * @param amount The token amount to be withdrawn.\n', '     */\n', '    function withdrawToken(address token, uint256 amount) external {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("withdrawToken(address,uint256)", token, amount)\n', '        );\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice The withdraw function that can only be triggered by owner.\n', '     * Event Withdraw will be emitted after execution.\n', '     * @param withdrawal The serialized withdrawal data\n', '     */\n', '    function withdrawByAdmin(bytes calldata withdrawal) external onlyAdmin {\n', '        (bool ok, bytes memory ret) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("withdrawByAdmin(bytes)", withdrawal)\n', '        );\n', '        require(ok);\n', '        ret.errorHandler();\n', '    }\n', '\n', '    /**\n', '     * @notice The settle function for orders. First order is taker order and the followings\n', '     * are maker orders.\n', '     * @param orders The serialized orders.\n', '     */\n', '    function settle(bytes calldata orders) external onlyAdmin {\n', '        (bool ok, bytes memory ret) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("settle(bytes)", orders)\n', '        );\n', '        require(ok);\n', '        ret.errorHandler();\n', '    }\n', '\n', '    /**\n', '     * @notice The migrate function that can only be triggered by admin.\n', '     * @param migration The serialized migration data\n', '     */\n', '    function migrateByAdmin(bytes calldata migration) external onlyAdmin {\n', '        (bool ok, bytes memory ret) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("migrateByAdmin(bytes)", migration)\n', '        );\n', '        require(ok);\n', '        ret.errorHandler();\n', '    }\n', '\n', '    /**\n', '     * @notice Announce lock of the sender\n', '     */\n', '    function lock() external {\n', '        (bool ok,) = _implementation().delegatecall(abi.encodeWithSignature("lock()"));\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Unlock the sender\n', '     */\n', '    function unlock() external {\n', '        (bool ok,) = _implementation().delegatecall(abi.encodeWithSignature("unlock()"));\n', '        require(ok);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the processing time of locking the user address\n', '     */\n', '    function changeProcessTime(uint256 time) external onlyOwner {\n', '        (bool ok,) = _implementation().delegatecall(\n', '            abi.encodeWithSignature("changeProcessTime(uint256)", time)\n', '        );\n', '        require(ok);\n', '    }\n', '}']