['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-05\n', '*/\n', '\n', 'pragma solidity ^0.5.10;\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '  /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `+` operator.\n', '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * Counterpart to Solidity&#39;s `-` operator.\n', '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `*` operator.\n', '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a\n', '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '  \n', '}\n', '\n', 'contract ERC20Detailed is IERC20 {\n', '\n', '  uint8 private _Tokendecimals;\n', '  string private _Tokenname;\n', '  string private _Tokensymbol;\n', '\n', '  constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '   \n', '   _Tokendecimals = decimals;\n', '    _Tokenname = name;\n', '    _Tokensymbol = symbol;\n', '    \n', '  }\n', '\n', '  function name() public view returns(string memory) {\n', '    return _Tokenname;\n', '  }\n', '\n', '  function symbol() public view returns(string memory) {\n', '    return _Tokensymbol;\n', '  }\n', '\n', '  function decimals() public view returns(uint8) {\n', '    return _Tokendecimals;\n', '  }\n', ' \n', '}\n', '\n', 'contract BLVD is ERC20Detailed {\n', '    //ERC20 contract for rewards within the BULVRD ecosystem\n', '    //https://bulvrdapp.com\n', '\n', '    using SafeMath for uint256;\n', '\n', '    //The oracle checks the authenticity of the rewards\n', '    address public oracle;\n', '    \n', '    //The maintainer is in charge of keeping the oracle running\n', '    address public maintainer;\n', '    \n', '    //The owner can replace the oracle or maintainer if they are compromised\n', '    address public owner;\n', '\n', '    //Set max tokens that can be minted\n', '    uint256 public maxMintable;\n', '\n', '    mapping(address => uint256) private _balanceOf;\n', '    mapping(address => mapping (address => uint256)) private _allowed;\n', '    \n', '    string public constant tokenSymbol = "BLVD";\n', '    string public constant tokenName = "BULVRD";\n', '    uint8 public constant tokenDecimals = 18;\n', '    uint256 public _totalSupply = 0;\n', '    \n', '    //Constant values for rewards\n', '    uint256 public limiter = 5;\n', '    uint256 public referral = 35;\n', '    uint256 public ar_drive = 15;\n', '    uint256 public closure = 15;\n', '    uint256 public map_drive = 10;\n', '    uint256 public dash_drive = 10;\n', '    uint256 public odb2_drive = 10;\n', '    uint256 public police = 10;\n', '    uint256 public hazard = 10;\n', '    uint256 public accident = 10;\n', '    uint256 public traffic = 5;\n', '    uint256 public twitter_share = 5;\n', '    uint256 public mastodon_share = 5;\n', '    uint256 public base_report = 5;\n', '    uint256 public validated_poi = 5;\n', '    uint256 public speed_sign = 1;\n', '    uint256 public report_init = 1;\n', ' \n', '    //Keep track of BULVRD users and their redeemed rewards\n', '    mapping(address => uint256) redeemedRewards;\n', '    mapping(address => uint256) latestWithdrawBlock;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    //The Redeem event is activated when a BULVRD user redeems rewards\n', '    event RedeemRewards(address indexed addr, uint256 rewards);\n', '    \n', '    constructor() public ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n', '        owner = msg.sender;\n', '        maintainer = msg.sender;\n', '        oracle = msg.sender;\n', '        maxMintable = 50000000000 * 10**uint256(tokenDecimals);\n', '        //initial grant\n', '        redeemRewards(87500000000 * 10**uint256(tokenDecimals), owner);\n', '    }\n', '    \n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        return IERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return _balanceOf[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address spender) public view returns (uint256) {\n', '        return _allowed[_owner][spender];\n', '    }\n', '\n', '    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n', '        for (uint256 i = 0; i < receivers.length; i++) {\n', '            transfer(receivers[i], amounts[i]);\n', '        }\n', '    }\n', '  \n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '  \n', '     function transfer(address to, uint tokens) public returns (bool success) {\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(tokens);\n', '        _balanceOf[to] = _balanceOf[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', ' \n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        _balanceOf[from] = _balanceOf[from].sub(tokens);\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n', '        _balanceOf[to] = _balanceOf[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', ' \n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        _allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //The owner can transfer ownership\n', '    function transferOwnership(address newOwner) public {\n', '        require(owner == msg.sender);\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //The owner can change the oracle\n', '    //This works only if removeOracle() was never called\n', '    function changeOracle(address newOracle) public {\n', '        require(owner == msg.sender);\n', '        require(oracle != address(0) && newOracle != address(0));\n', '        oracle = newOracle;\n', '    }\n', '    \n', '    //The owner can change the maintainer\n', '    function changeMaintainer(address newMaintainer) public {\n', '        require(owner == msg.sender);\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    //Allow address to redeem rewards verified from BULVRD\n', '    function redeemRewards(uint256 rewards, address destination) public {\n', '        \n', '        //Must be oracle \n', '        require(msg.sender == oracle, "Must be Oracle to complete");\n', '\n', '        //Make sure we have moved on since the last transaction of the give\n', '        require(block.number > latestWithdrawBlock[destination], "Have not moved on from last block");\n', '        \n', '        //rewards to token conversion\n', '        uint256 reward = SafeMath.div(rewards, limiter);\n', '        \n', '        //The amount of rewards needs to be more than the previous redeemed amount\n', '        require(reward > redeemedRewards[destination], "Has not earned since last redeem");\n', '        \n', '        //check if reward amount can be redeemed against supply\n', '        uint256 total = SafeMath.add(_totalSupply, reward);\n', '        require(total <= maxMintable, "Max Mintable Reached");\n', '\n', '        //The new rewards that is available to be redeemed\n', '        uint256 newUserRewards = SafeMath.sub(reward, redeemedRewards[destination]);\n', '        \n', '        //The user&#39;s rewards balance is updated with the new reward\n', '        _balanceOf[destination] = SafeMath.add(_balanceOf[destination], newUserRewards);\n', '        \n', '        //The total supply (ERC20) is updated\n', '        _totalSupply = SafeMath.add(_totalSupply, newUserRewards);\n', '        \n', '        //The amount of rewards redeemed by a user is updated\n', '        redeemedRewards[destination] = reward;\n', '        \n', '        //Set block status for user transaction\n', '        latestWithdrawBlock[destination] = block.number;\n', '        \n', '        //The Redeem event is triggered\n', '        emit RedeemRewards(destination, newUserRewards);\n', '        //Update token holder balance on chain explorers\n', '        emit Transfer(oracle, destination, newUserRewards);\n', '    }\n', '    \n', '    //This function is a workaround because this.redeemedRewards cannot be public\n', '    //This is the limitation of the current Solidity compiler\n', '    function redeemedRewardsOf(address destination) public view returns(uint256) {\n', '        return redeemedRewards[destination];\n', '    }\n', '    \n', '    \n', '    //Helper methods to update rewards\n', '     function updateLimiter(uint256 value) public{\n', '         require(maintainer == msg.sender);\n', '         limiter = value;\n', '     }\n', '     \n', '     function updateReferral(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         referral = value;\n', '     }\n', '     \n', '     function updateTwitterShare(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         twitter_share = value;\n', '     }\n', '     \n', '     function updateMastodonShare(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         mastodon_share = value;\n', '     }\n', '     \n', '     function updateArDrive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         ar_drive = value;\n', '     }\n', '     \n', '     function updateMapDrive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         map_drive = value;\n', '     }\n', '    \n', '    function updateDashDrive(uint256 value) public {\n', '        require(maintainer == msg.sender);\n', '         dash_drive = value;\n', '     }\n', '     \n', '     function updateObd2Drive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         odb2_drive = value;\n', '     }\n', '     \n', '     function updatePolice(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         police = value;\n', '     }\n', '     \n', '     function updateClosure(uint256 value) public {\n', '        require(maintainer == msg.sender);\n', '         closure = value;\n', '     }\n', '     \n', '     function updateHazard(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         hazard = value;\n', '     }\n', '     \n', '     function updateTraffic(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         traffic = value;\n', '     }\n', '     \n', '     function updateAccident(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         accident = value;\n', '     }\n', '     \n', '     function updateSpeedSign(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         speed_sign = value;\n', '     }\n', '     \n', '     function updateBaseReport(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         base_report = value;\n', '     }\n', '     \n', '     function updateValidatedPoi(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         validated_poi = value;\n', '     }\n', '     \n', '     function updateReportInit(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         report_init = value;\n', '     }\n', '}']
['pragma solidity ^0.5.10;\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '  /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '  \n', '}\n', '\n', 'contract ERC20Detailed is IERC20 {\n', '\n', '  uint8 private _Tokendecimals;\n', '  string private _Tokenname;\n', '  string private _Tokensymbol;\n', '\n', '  constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '   \n', '   _Tokendecimals = decimals;\n', '    _Tokenname = name;\n', '    _Tokensymbol = symbol;\n', '    \n', '  }\n', '\n', '  function name() public view returns(string memory) {\n', '    return _Tokenname;\n', '  }\n', '\n', '  function symbol() public view returns(string memory) {\n', '    return _Tokensymbol;\n', '  }\n', '\n', '  function decimals() public view returns(uint8) {\n', '    return _Tokendecimals;\n', '  }\n', ' \n', '}\n', '\n', 'contract BLVD is ERC20Detailed {\n', '    //ERC20 contract for rewards within the BULVRD ecosystem\n', '    //https://bulvrdapp.com\n', '\n', '    using SafeMath for uint256;\n', '\n', '    //The oracle checks the authenticity of the rewards\n', '    address public oracle;\n', '    \n', '    //The maintainer is in charge of keeping the oracle running\n', '    address public maintainer;\n', '    \n', '    //The owner can replace the oracle or maintainer if they are compromised\n', '    address public owner;\n', '\n', '    //Set max tokens that can be minted\n', '    uint256 public maxMintable;\n', '\n', '    mapping(address => uint256) private _balanceOf;\n', '    mapping(address => mapping (address => uint256)) private _allowed;\n', '    \n', '    string public constant tokenSymbol = "BLVD";\n', '    string public constant tokenName = "BULVRD";\n', '    uint8 public constant tokenDecimals = 18;\n', '    uint256 public _totalSupply = 0;\n', '    \n', '    //Constant values for rewards\n', '    uint256 public limiter = 5;\n', '    uint256 public referral = 35;\n', '    uint256 public ar_drive = 15;\n', '    uint256 public closure = 15;\n', '    uint256 public map_drive = 10;\n', '    uint256 public dash_drive = 10;\n', '    uint256 public odb2_drive = 10;\n', '    uint256 public police = 10;\n', '    uint256 public hazard = 10;\n', '    uint256 public accident = 10;\n', '    uint256 public traffic = 5;\n', '    uint256 public twitter_share = 5;\n', '    uint256 public mastodon_share = 5;\n', '    uint256 public base_report = 5;\n', '    uint256 public validated_poi = 5;\n', '    uint256 public speed_sign = 1;\n', '    uint256 public report_init = 1;\n', ' \n', '    //Keep track of BULVRD users and their redeemed rewards\n', '    mapping(address => uint256) redeemedRewards;\n', '    mapping(address => uint256) latestWithdrawBlock;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    //The Redeem event is activated when a BULVRD user redeems rewards\n', '    event RedeemRewards(address indexed addr, uint256 rewards);\n', '    \n', '    constructor() public ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n', '        owner = msg.sender;\n', '        maintainer = msg.sender;\n', '        oracle = msg.sender;\n', '        maxMintable = 50000000000 * 10**uint256(tokenDecimals);\n', '        //initial grant\n', '        redeemRewards(87500000000 * 10**uint256(tokenDecimals), owner);\n', '    }\n', '    \n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        require(owner == msg.sender);\n', '        return IERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return _balanceOf[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address spender) public view returns (uint256) {\n', '        return _allowed[_owner][spender];\n', '    }\n', '\n', '    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n', '        for (uint256 i = 0; i < receivers.length; i++) {\n', '            transfer(receivers[i], amounts[i]);\n', '        }\n', '    }\n', '  \n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '  \n', '     function transfer(address to, uint tokens) public returns (bool success) {\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(tokens);\n', '        _balanceOf[to] = _balanceOf[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', ' \n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        _balanceOf[from] = _balanceOf[from].sub(tokens);\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n', '        _balanceOf[to] = _balanceOf[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', ' \n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        _allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //The owner can transfer ownership\n', '    function transferOwnership(address newOwner) public {\n', '        require(owner == msg.sender);\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //The owner can change the oracle\n', '    //This works only if removeOracle() was never called\n', '    function changeOracle(address newOracle) public {\n', '        require(owner == msg.sender);\n', '        require(oracle != address(0) && newOracle != address(0));\n', '        oracle = newOracle;\n', '    }\n', '    \n', '    //The owner can change the maintainer\n', '    function changeMaintainer(address newMaintainer) public {\n', '        require(owner == msg.sender);\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    //Allow address to redeem rewards verified from BULVRD\n', '    function redeemRewards(uint256 rewards, address destination) public {\n', '        \n', '        //Must be oracle \n', '        require(msg.sender == oracle, "Must be Oracle to complete");\n', '\n', '        //Make sure we have moved on since the last transaction of the give\n', '        require(block.number > latestWithdrawBlock[destination], "Have not moved on from last block");\n', '        \n', '        //rewards to token conversion\n', '        uint256 reward = SafeMath.div(rewards, limiter);\n', '        \n', '        //The amount of rewards needs to be more than the previous redeemed amount\n', '        require(reward > redeemedRewards[destination], "Has not earned since last redeem");\n', '        \n', '        //check if reward amount can be redeemed against supply\n', '        uint256 total = SafeMath.add(_totalSupply, reward);\n', '        require(total <= maxMintable, "Max Mintable Reached");\n', '\n', '        //The new rewards that is available to be redeemed\n', '        uint256 newUserRewards = SafeMath.sub(reward, redeemedRewards[destination]);\n', '        \n', "        //The user's rewards balance is updated with the new reward\n", '        _balanceOf[destination] = SafeMath.add(_balanceOf[destination], newUserRewards);\n', '        \n', '        //The total supply (ERC20) is updated\n', '        _totalSupply = SafeMath.add(_totalSupply, newUserRewards);\n', '        \n', '        //The amount of rewards redeemed by a user is updated\n', '        redeemedRewards[destination] = reward;\n', '        \n', '        //Set block status for user transaction\n', '        latestWithdrawBlock[destination] = block.number;\n', '        \n', '        //The Redeem event is triggered\n', '        emit RedeemRewards(destination, newUserRewards);\n', '        //Update token holder balance on chain explorers\n', '        emit Transfer(oracle, destination, newUserRewards);\n', '    }\n', '    \n', '    //This function is a workaround because this.redeemedRewards cannot be public\n', '    //This is the limitation of the current Solidity compiler\n', '    function redeemedRewardsOf(address destination) public view returns(uint256) {\n', '        return redeemedRewards[destination];\n', '    }\n', '    \n', '    \n', '    //Helper methods to update rewards\n', '     function updateLimiter(uint256 value) public{\n', '         require(maintainer == msg.sender);\n', '         limiter = value;\n', '     }\n', '     \n', '     function updateReferral(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         referral = value;\n', '     }\n', '     \n', '     function updateTwitterShare(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         twitter_share = value;\n', '     }\n', '     \n', '     function updateMastodonShare(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         mastodon_share = value;\n', '     }\n', '     \n', '     function updateArDrive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         ar_drive = value;\n', '     }\n', '     \n', '     function updateMapDrive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         map_drive = value;\n', '     }\n', '    \n', '    function updateDashDrive(uint256 value) public {\n', '        require(maintainer == msg.sender);\n', '         dash_drive = value;\n', '     }\n', '     \n', '     function updateObd2Drive(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         odb2_drive = value;\n', '     }\n', '     \n', '     function updatePolice(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         police = value;\n', '     }\n', '     \n', '     function updateClosure(uint256 value) public {\n', '        require(maintainer == msg.sender);\n', '         closure = value;\n', '     }\n', '     \n', '     function updateHazard(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         hazard = value;\n', '     }\n', '     \n', '     function updateTraffic(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         traffic = value;\n', '     }\n', '     \n', '     function updateAccident(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         accident = value;\n', '     }\n', '     \n', '     function updateSpeedSign(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         speed_sign = value;\n', '     }\n', '     \n', '     function updateBaseReport(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         base_report = value;\n', '     }\n', '     \n', '     function updateValidatedPoi(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         validated_poi = value;\n', '     }\n', '     \n', '     function updateReportInit(uint256 value) public {\n', '         require(maintainer == msg.sender);\n', '         report_init = value;\n', '     }\n', '}']
