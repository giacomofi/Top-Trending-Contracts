['pragma solidity ^0.4.23;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Administrable.sol\n', '\n', '/**\n', ' * @title Administrable\n', ' * @dev Base contract extending Ownable with support for administration capabilities.\n', ' */\n', 'contract Administrable is Ownable {\n', '\n', '    event LogAdministratorAdded(address indexed caller, address indexed administrator);\n', '    event LogAdministratorRemoved(address indexed caller, address indexed administrator);\n', '\n', '    mapping (address => bool) private administrators;\n', '\n', '    modifier onlyAdministrator() {\n', '        require(administrators[msg.sender], "caller is not administrator");\n', '        _;\n', '    }\n', '\n', '    constructor() internal {\n', '        administrators[msg.sender] = true;\n', '\n', '        emit LogAdministratorAdded(msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Add a new administrator to the list.\n', '     * @param newAdministrator The administrator address to add.\n', '     */\n', '    function addAdministrator(address newAdministrator) public onlyOwner {\n', '        require(newAdministrator != address(0), "newAdministrator is zero");\n', '        require(!administrators[newAdministrator], "newAdministrator is already present");\n', '\n', '        administrators[newAdministrator] = true;\n', '\n', '        emit LogAdministratorAdded(msg.sender, newAdministrator);\n', '    }\n', '\n', '    /**\n', '     * Remove an existing administrator from the list.\n', '     * @param oldAdministrator The administrator address to remove.\n', '     */\n', '    function removeAdministrator(address oldAdministrator) public onlyOwner {\n', '        require(oldAdministrator != address(0), "oldAdministrator is zero");\n', '        require(administrators[oldAdministrator], "oldAdministrator is not present");\n', '\n', '        administrators[oldAdministrator] = false;\n', '\n', '        emit LogAdministratorRemoved(msg.sender, oldAdministrator);\n', '    }\n', '\n', '    /**\n', '     * @return true if target address has administrator privileges, false otherwise\n', '     */\n', '    function isAdministrator(address target) public view returns(bool isReallyAdministrator) {\n', '        return administrators[target];\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership taking administration privileges into account.\n', '     * @param newOwner The new contract owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        administrators[msg.sender] = false;\n', '        emit LogAdministratorRemoved(msg.sender, msg.sender);\n', '\n', '        administrators[newOwner] = true;\n', '        emit LogAdministratorAdded(msg.sender, newOwner);\n', '\n', '        Ownable.transferOwnership(newOwner);\n', '    }\n', '}\n', '\n', '// File: contracts/TokenSale.sol\n', '\n', 'contract TokenSale {\n', '    /**\n', '    * Buy tokens for the beneficiary using paid Ether.\n', '    * @param beneficiary the beneficiary address that will receive the tokens.\n', '    */\n', '    function buyTokens(address beneficiary) public payable;\n', '}\n', '\n', '// File: contracts/WhitelistableConstraints.sol\n', '\n', '/**\n', ' * @title WhitelistableConstraints\n', ' * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\n', ' */\n', 'contract WhitelistableConstraints {\n', '\n', '    /**\n', '     * @dev Check if whitelist with specified parameters is allowed.\n', '     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\n', '     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\n', '     * @return true if whitelist with specified parameters is allowed, false otherwise\n', '     */\n', '    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\n', '        public pure returns(bool isReallyAllowedWhitelist) {\n', '        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev Base contract implementing a whitelist to keep track of investors.\n', ' * The construction parameters allow for both whitelisted and non-whitelisted contracts:\n', ' * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\n', ' * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\n', ' * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\n', ' */\n', 'contract Whitelistable is WhitelistableConstraints {\n', '\n', '    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\n', '    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\n', '    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\n', '    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\n', '\n', '    mapping (address => bool) public whitelist;\n', '\n', '    uint256 public whitelistLength;\n', '\n', '    uint256 public maxWhitelistLength;\n', '\n', '    uint256 public whitelistThresholdBalance;\n', '\n', '    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), "parameters not allowed");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '    }\n', '\n', '    /**\n', '     * @return true if whitelist is currently enabled, false otherwise\n', '     */\n', '    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\n', '        return maxWhitelistLength > 0;\n', '    }\n', '\n', '    /**\n', '     * @return true if subscriber is whitelisted, false otherwise\n', '     */\n', '    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\n', '        return whitelist[_subscriber];\n', '    }\n', '\n', '    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\n', '            "_maxWhitelistLength not allowed");\n', '        require(_maxWhitelistLength != maxWhitelistLength, "_maxWhitelistLength equal to current one");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '\n', '        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\n', '    }\n', '\n', '    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\n', '            "_whitelistThresholdBalance not allowed");\n', '        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\n', '            "_whitelistThresholdBalance not greater than current one");\n', '\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '\n', '        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\n', '    }\n', '\n', '    function addToWhitelistInternal(address _subscriber) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(!whitelist[_subscriber], "already whitelisted");\n', '        require(whitelistLength < maxWhitelistLength, "max whitelist length reached");\n', '\n', '        whitelistLength++;\n', '\n', '        whitelist[_subscriber] = true;\n', '\n', '        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\n', '    }\n', '\n', '    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(whitelist[_subscriber], "not whitelisted");\n', '        require(_balance <= whitelistThresholdBalance, "_balance greater than whitelist threshold");\n', '\n', '        assert(whitelistLength > 0);\n', '\n', '        whitelistLength--;\n', '\n', '        whitelist[_subscriber] = false;\n', '\n', '        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\n', '    }\n', '\n', '    /**\n', '     * @param _subscriber The subscriber for which the balance check is required.\n', '     * @param _balance The balance value to check for allowance.\n', '     * @return true if the balance is allowed for the subscriber, false otherwise\n', '     */\n', '    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\n', '        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/MultipleBidReservation.sol\n', '\n', '/**\n', ' * A multiple-bid Reservation Contract (RC) for early deposit collection and manual token bid during\n', ' * the Initial Coin Offering (ICO) crowdsale events.\n', ' * The RC implements the following spec:\n', ' * - investors allowed to simply send ethers to the RC address\n', ' * - investors allowed to get refunded after ICO event if RC failed\n', ' * - multiple bids using investor addresses performed by owner or authorized administator\n', ' * - maximum cap on the total balance\n', ' * - minimum threshold on each subscriber balance\n', ' * - maximum number of subscribers\n', ' * - optional whitelist with max deposit threshold for non-whitelisted subscribers\n', ' * - kill switch callable by owner or authorized administator\n', ' * - withdraw pattern for refunding\n', ' * Just the RC owner or an authorized administator is allowed to shutdown the lifecycle halting the\n', ' * RC; no bounties are provided.\n', ' */\n', 'contract MultipleBidReservation is Administrable, Whitelistable {\n', '    using SafeMath for uint256;\n', '\n', '    event LogMultipleBidReservationCreated(\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 maxSubscribers,\n', '        uint256 maxCap,\n', '        uint256 minDeposit,\n', '        uint256 maxWhitelistLength,\n', '        uint256 indexed whitelistThreshold\n', '    );\n', '    event LogStartBlockChanged(uint256 indexed startBlock);\n', '    event LogEndBlockChanged(uint256 indexed endBlock);\n', '    event LogMaxCapChanged(uint256 indexed maxCap);\n', '    event LogMinDepositChanged(uint256 indexed minDeposit);\n', '    event LogMaxSubscribersChanged(uint256 indexed maxSubscribers);\n', '    event LogCrowdsaleAddressChanged(address indexed crowdsale);\n', '    event LogAbort(address indexed caller);\n', '    event LogDeposit(\n', '        address indexed subscriber,\n', '        uint256 indexed amount,\n', '        uint256 indexed balance,\n', '        uint256 raisedFunds\n', '    );\n', '    event LogBuy(address caller, uint256 indexed from, uint256 indexed to);\n', '    event LogRefund(address indexed subscriber, uint256 indexed amount, uint256 indexed raisedFunds);\n', '\n', '    // The block interval [start, end] where investments are allowed (both inclusive)\n', '    uint256 public startBlock;\n', '    uint256 public endBlock;\n', '\n', '    // RC maximum cap (expressed in wei)\n', '    uint256 public maxCap;\n', '\n', '    // RC minimum balance per subscriber (expressed in wei)\n', '    uint256 public minDeposit;\n', '\n', '    // RC maximum number of allowed subscribers\n', '    uint256 public maxSubscribers;\n', '\n', '    // Crowdsale public address\n', '    TokenSale public crowdsale;\n', '\n', '    // RC current raised balance expressed in wei\n', '    uint256 public raisedFunds;\n', '\n', '    // ERC20-compliant token issued during ICO\n', '    ERC20 public token;\n', '\n', '    // Reservation balances (expressed in wei) deposited by each subscriber\n', '    mapping (address => uint256) public balances;\n', '\n', '    // The list of subscribers in incoming order\n', '    address[] public subscribers;\n', '\n', '    // Flag indicating if reservation has been forcibly terminated\n', '    bool public aborted;\n', '\n', '    // The maximum value for whitelist threshold in wei\n', '    uint256 constant public MAX_WHITELIST_THRESHOLD = 2**256 - 1;\n', '\n', '    modifier beforeStart() {\n', '        require(block.number < startBlock, "already started");\n', '        _;\n', '    }\n', '\n', '    modifier beforeEnd() {\n', '        require(block.number <= endBlock, "already ended");\n', '        _;\n', '    }\n', '\n', '    modifier whenReserving() {\n', '        require(!aborted, "aborted");\n', '        _;\n', '    }\n', '\n', '    modifier whenAborted() {\n', '        require(aborted, "not aborted");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    Whitelistable(_maxWhitelistLength, _whitelistThreshold) public\n', '    {\n', '        require(_startBlock >= block.number, "_startBlock < current block");\n', '        require(_endBlock >= _startBlock, "_endBlock < _startBlock");\n', '        require(_maxSubscribers > 0, "_maxSubscribers is 0");\n', '        require(_maxCap > 0, "_maxCap is 0");\n', '        require(_minDeposit > 0, "_minDeposit is 0");\n', '\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '        maxSubscribers = _maxSubscribers;\n', '        maxCap = _maxCap;\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMultipleBidReservationCreated(\n', '            startBlock,\n', '            endBlock,\n', '            maxSubscribers,\n', '            maxCap,\n', '            minDeposit,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '\n', '    function hasStarted() public view returns(bool started) {\n', '        return block.number >= startBlock;\n', '    }\n', '\n', '    function hasEnded() public view returns(bool ended) {\n', '        return block.number > endBlock;\n', '    }\n', '\n', '    /**\n', '     * @return The current number of RC subscribers\n', '     */\n', '    function numSubscribers() public view returns(uint256 numberOfSubscribers) {\n', '        return subscribers.length;\n', '    }\n', '\n', '    /**\n', '     * Change the RC start block number.\n', '     * @param _startBlock The start block\n', '     */\n', '    function setStartBlock(uint256 _startBlock) external onlyOwner beforeStart whenReserving {\n', '        require(_startBlock >= block.number, "_startBlock < current block");\n', '        require(_startBlock <= endBlock, "_startBlock > endBlock");\n', '        require(_startBlock != startBlock, "_startBlock == startBlock");\n', '\n', '        startBlock = _startBlock;\n', '\n', '        emit LogStartBlockChanged(_startBlock);\n', '    }\n', '\n', '    /**\n', '     * Change the RC end block number.\n', '     * @param _endBlock The end block\n', '     */\n', '    function setEndBlock(uint256 _endBlock) external onlyOwner beforeEnd whenReserving {\n', '        require(_endBlock >= block.number, "_endBlock < current block");\n', '        require(_endBlock >= startBlock, "_endBlock < startBlock");\n', '        require(_endBlock != endBlock, "_endBlock == endBlock");\n', '\n', '        endBlock = _endBlock;\n', '\n', '        emit LogEndBlockChanged(_endBlock);\n', '    }\n', '\n', '    /**\n', '     * Change the RC maximum cap. New value shall be at least equal to raisedFunds.\n', '     * @param _maxCap The RC maximum cap, expressed in wei\n', '     */\n', '    function setMaxCap(uint256 _maxCap) external onlyOwner beforeEnd whenReserving {\n', '        require(_maxCap > 0 && _maxCap >= raisedFunds, "invalid _maxCap");\n', '\n', '        maxCap = _maxCap;\n', '\n', '        emit LogMaxCapChanged(maxCap);\n', '    }\n', '\n', '    /**\n', '     * Change the minimum deposit for each RC subscriber. New value shall be lower than previous.\n', '     * @param _minDeposit The minimum deposit for each RC subscriber, expressed in wei\n', '     */\n', '    function setMinDeposit(uint256 _minDeposit) external onlyOwner beforeEnd whenReserving {\n', '        require(_minDeposit > 0 && _minDeposit < minDeposit, "_minDeposit not in (0, minDeposit)");\n', '\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMinDepositChanged(minDeposit);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum number of accepted RC subscribers. New value shall be at least equal to the current\n', '     * number of subscribers.\n', '     * @param _maxSubscribers The maximum number of subscribers\n', '     */\n', '    function setMaxSubscribers(uint256 _maxSubscribers) external onlyOwner beforeEnd whenReserving {\n', '        require(_maxSubscribers > 0 && _maxSubscribers >= subscribers.length, "invalid _maxSubscribers");\n', '\n', '        maxSubscribers = _maxSubscribers;\n', '\n', '        emit LogMaxSubscribersChanged(maxSubscribers);\n', '    }\n', '\n', '    /**\n', '     * Change the ICO crowdsale address.\n', '     * @param _crowdsale The ICO crowdsale address\n', '     */\n', '    function setCrowdsaleAddress(address _crowdsale) external onlyOwner whenReserving {\n', '        require(_crowdsale != address(0), "_crowdsale is 0");\n', '\n', '        crowdsale = TokenSale(_crowdsale);\n', '\n', '        emit LogCrowdsaleAddressChanged(_crowdsale);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _maxWhitelistLength The maximum whitelist length\n', '     */\n', '    function setMaxWhitelistLength(uint256 _maxWhitelistLength) external onlyOwner beforeEnd whenReserving {\n', '        setMaxWhitelistLengthInternal(_maxWhitelistLength);\n', '    }\n', '\n', '    /**\n', '     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\n', '     */\n', '    function setWhitelistThresholdBalance(uint256 _whitelistThreshold) external onlyOwner beforeEnd whenReserving {\n', '        setWhitelistThresholdBalanceInternal(_whitelistThreshold);\n', '    }\n', '\n', '    /**\n', '     * Add the subscriber to the whitelist.\n', '     * @param _subscriber The subscriber to add to the whitelist.\n', '     */\n', '    function addToWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\n', '        addToWhitelistInternal(_subscriber);\n', '    }\n', '\n', '    /**\n', '     * Removed the subscriber from the whitelist.\n', '     * @param _subscriber The subscriber to remove from the whitelist.\n', '     */\n', '    function removeFromWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\n', '        removeFromWhitelistInternal(_subscriber, balances[_subscriber]);\n', '    }\n', '\n', '    /**\n', '     * Abort the contract before the ICO start time. An administrator is allowed to use this &#39;kill switch&#39;\n', '     * to deactivate any contract function except the investor refunding.\n', '     */\n', '    function abort() external onlyAdministrator whenReserving {\n', '        aborted = true;\n', '\n', '        emit LogAbort(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Let the caller invest its money before the ICO start time.\n', '     */\n', '    function invest() external payable whenReserving {\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * Execute a batch of multiple bids into the ICO crowdsale.\n', '     * @param _from The subscriber index, included, from which the batch starts.\n', '     * @param _to The subscriber index, excluded, to which the batch ends.\n', '     */\n', '    function buy(uint256 _from, uint256 _to) external onlyAdministrator whenReserving {\n', '        require(_from < _to, "_from >= _to");\n', '        require(crowdsale != address(0), "crowdsale not set");\n', '        require(subscribers.length > 0, "subscribers size is 0");\n', '        require(hasEnded(), "not ended");\n', '\n', '        uint to = _to > subscribers.length ? subscribers.length : _to;\n', '\n', '        for (uint256 i=_from; i<to; i++) {\n', '            address subscriber = subscribers[i];\n', '\n', '            uint256 subscriberBalance = balances[subscriber];\n', '\n', '            if (subscriberBalance > 0) {\n', '                balances[subscriber] = 0;\n', '\n', '                crowdsale.buyTokens.value(subscriberBalance)(subscriber);\n', '            }\n', '        }\n', '\n', '        emit LogBuy(msg.sender, _from, _to);\n', '    }\n', '\n', '    /**\n', '     * Refund the invested money to the caller after the RC termination.\n', '     */\n', '    function refund() external whenAborted {\n', '        // Read the calling subscriber balance once\n', '        uint256 subscriberBalance = balances[msg.sender];\n', '\n', '        // Withdraw is allowed IFF the calling subscriber has not zero balance\n', '        require(subscriberBalance > 0, "caller balance is 0");\n', '\n', '        // Withdraw is allowed IFF the contract has some token balance\n', '        require(raisedFunds > 0, "token balance is 0");\n', '\n', '        // Safely decrease the total balance\n', '        raisedFunds = raisedFunds.sub(subscriberBalance);\n', '\n', '        // Clear the subscriber balance before transfer to prevent re-entrant attacks\n', '        balances[msg.sender] = 0;\n', '\n', '        emit LogRefund(msg.sender, subscriberBalance, raisedFunds);\n', '\n', '        // Transfer the balance back to the calling subscriber or throws on error\n', '        msg.sender.transfer(subscriberBalance);\n', '    }\n', '\n', '    /**\n', '     * Allow investing by just sending money to the contract address.\n', '     */\n', '    function () external payable whenReserving {\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * Deposit the money amount for the beneficiary when RC is running.\n', '     */\n', '    function deposit(address beneficiary, uint256 amount) internal {\n', '        // Deposit is allowed IFF the RC is currently running\n', '        require(startBlock <= block.number && block.number <= endBlock, "not open");\n', '\n', '        uint256 newRaisedFunds = raisedFunds.add(amount);\n', '\n', '        // Deposit is allowed IFF the contract balance will not reach its maximum cap\n', '        require(newRaisedFunds <= maxCap, "over max cap");\n', '\n', '        uint256 currentBalance = balances[beneficiary];\n', '        uint256 finalBalance = currentBalance.add(amount);\n', '\n', '        // Deposit is allowed IFF investor deposit shall be at least equal to the minimum deposit threshold\n', '        require(finalBalance >= minDeposit, "deposit < min deposit");\n', '\n', '        // Balances over whitelist threshold are allowed IFF the sender is in whitelist\n', '        require(isAllowedBalance(beneficiary, finalBalance), "balance not allowed");\n', '\n', '        // Increase the subscriber count if sender does not have a balance yet\n', '        if (currentBalance == 0) {\n', '            // New subscribers are allowed IFF the contract has not yet the max number of subscribers\n', '            require(subscribers.length < maxSubscribers, "max subscribers reached");\n', '\n', '            subscribers.push(beneficiary);\n', '        }\n', '\n', '        // Add the received amount to the subscriber balance\n', '        balances[beneficiary] = finalBalance;\n', '\n', '        raisedFunds = newRaisedFunds;\n', '\n', '        emit LogDeposit(beneficiary, amount, finalBalance, newRaisedFunds);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomReservation.sol\n', '\n', '/**\n', ' * @title NokuCustomReservation\n', ' * @dev Extension of MultipleBidReservation.\n', ' */\n', 'contract NokuCustomReservation is MultipleBidReservation {\n', '    event LogNokuCustomReservationCreated();\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    MultipleBidReservation(\n', '        _startBlock,\n', '        _endBlock,\n', '        _maxSubscribers,\n', '        _maxCap,\n', '        _minDeposit,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold\n', '    )\n', '    public {\n', '        emit LogNokuCustomReservationCreated();\n', '    }\n', '}\n', '\n', '// File: contracts/NokuPricingPlan.sol\n', '\n', '/**\n', '* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\n', '*/\n', 'contract NokuPricingPlan {\n', '    /**\n', '    * @dev Pay the fee for the service identified by the specified name.\n', '    * The fee amount shall already be approved by the client.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @param client The client of the target service.\n', '    * @return true if fee has been paid.\n', '    */\n', '    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n', '\n', '    /**\n', '    * @dev Get the usage fee for the service identified by the specified name.\n', '    * The returned fee amount shall be approved before using #payFee method.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @return The amount to approve before really paying such fee.\n', '    */\n', '    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/NokuCustomService.sol\n', '\n', 'contract NokuCustomService is Pausable {\n', '    using AddressUtils for address;\n', '\n', '    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n', '\n', '    // The pricing plan determining the fee to be paid in NOKU tokens by customers\n', '    NokuPricingPlan public pricingPlan;\n', '\n', '    constructor(address _pricingPlan) internal {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '\n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '    }\n', '\n', '    function setPricingPlan(address _pricingPlan) public onlyOwner {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '        require(NokuPricingPlan(_pricingPlan) != pricingPlan, "_pricingPlan equal to current");\n', '        \n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '\n', '        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomReservationService.sol\n', '\n', '/**\n', ' * @title NokuCustomReservationService\n', ' * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\n', ' */\n', 'contract NokuCustomReservationService is NokuCustomService {\n', '    event LogNokuCustomReservationServiceCreated(address indexed caller);\n', '\n', '    bytes32 public constant SERVICE_NAME = "NokuCustomERC20.reservation";\n', '    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n', '\n', '    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n', '        emit LogNokuCustomReservationServiceCreated(msg.sender);\n', '    }\n', '\n', '    function createCustomReservation(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    public returns(NokuCustomReservation customReservation)\n', '    {\n', '        customReservation = new NokuCustomReservation(\n', '            _startBlock,\n', '            _endBlock,\n', '            _maxSubscribers,\n', '            _maxCap,\n', '            _minDeposit,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '\n', '        // Transfer NokuCustomReservation ownership to the client\n', '        customReservation.transferOwnership(msg.sender);\n', '\n', '        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Administrable.sol\n', '\n', '/**\n', ' * @title Administrable\n', ' * @dev Base contract extending Ownable with support for administration capabilities.\n', ' */\n', 'contract Administrable is Ownable {\n', '\n', '    event LogAdministratorAdded(address indexed caller, address indexed administrator);\n', '    event LogAdministratorRemoved(address indexed caller, address indexed administrator);\n', '\n', '    mapping (address => bool) private administrators;\n', '\n', '    modifier onlyAdministrator() {\n', '        require(administrators[msg.sender], "caller is not administrator");\n', '        _;\n', '    }\n', '\n', '    constructor() internal {\n', '        administrators[msg.sender] = true;\n', '\n', '        emit LogAdministratorAdded(msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Add a new administrator to the list.\n', '     * @param newAdministrator The administrator address to add.\n', '     */\n', '    function addAdministrator(address newAdministrator) public onlyOwner {\n', '        require(newAdministrator != address(0), "newAdministrator is zero");\n', '        require(!administrators[newAdministrator], "newAdministrator is already present");\n', '\n', '        administrators[newAdministrator] = true;\n', '\n', '        emit LogAdministratorAdded(msg.sender, newAdministrator);\n', '    }\n', '\n', '    /**\n', '     * Remove an existing administrator from the list.\n', '     * @param oldAdministrator The administrator address to remove.\n', '     */\n', '    function removeAdministrator(address oldAdministrator) public onlyOwner {\n', '        require(oldAdministrator != address(0), "oldAdministrator is zero");\n', '        require(administrators[oldAdministrator], "oldAdministrator is not present");\n', '\n', '        administrators[oldAdministrator] = false;\n', '\n', '        emit LogAdministratorRemoved(msg.sender, oldAdministrator);\n', '    }\n', '\n', '    /**\n', '     * @return true if target address has administrator privileges, false otherwise\n', '     */\n', '    function isAdministrator(address target) public view returns(bool isReallyAdministrator) {\n', '        return administrators[target];\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership taking administration privileges into account.\n', '     * @param newOwner The new contract owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        administrators[msg.sender] = false;\n', '        emit LogAdministratorRemoved(msg.sender, msg.sender);\n', '\n', '        administrators[newOwner] = true;\n', '        emit LogAdministratorAdded(msg.sender, newOwner);\n', '\n', '        Ownable.transferOwnership(newOwner);\n', '    }\n', '}\n', '\n', '// File: contracts/TokenSale.sol\n', '\n', 'contract TokenSale {\n', '    /**\n', '    * Buy tokens for the beneficiary using paid Ether.\n', '    * @param beneficiary the beneficiary address that will receive the tokens.\n', '    */\n', '    function buyTokens(address beneficiary) public payable;\n', '}\n', '\n', '// File: contracts/WhitelistableConstraints.sol\n', '\n', '/**\n', ' * @title WhitelistableConstraints\n', ' * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\n', ' */\n', 'contract WhitelistableConstraints {\n', '\n', '    /**\n', '     * @dev Check if whitelist with specified parameters is allowed.\n', '     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\n', '     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\n', '     * @return true if whitelist with specified parameters is allowed, false otherwise\n', '     */\n', '    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\n', '        public pure returns(bool isReallyAllowedWhitelist) {\n', '        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev Base contract implementing a whitelist to keep track of investors.\n', ' * The construction parameters allow for both whitelisted and non-whitelisted contracts:\n', ' * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\n', ' * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\n', ' * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\n', ' */\n', 'contract Whitelistable is WhitelistableConstraints {\n', '\n', '    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\n', '    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\n', '    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\n', '    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\n', '\n', '    mapping (address => bool) public whitelist;\n', '\n', '    uint256 public whitelistLength;\n', '\n', '    uint256 public maxWhitelistLength;\n', '\n', '    uint256 public whitelistThresholdBalance;\n', '\n', '    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), "parameters not allowed");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '    }\n', '\n', '    /**\n', '     * @return true if whitelist is currently enabled, false otherwise\n', '     */\n', '    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\n', '        return maxWhitelistLength > 0;\n', '    }\n', '\n', '    /**\n', '     * @return true if subscriber is whitelisted, false otherwise\n', '     */\n', '    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\n', '        return whitelist[_subscriber];\n', '    }\n', '\n', '    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\n', '        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\n', '            "_maxWhitelistLength not allowed");\n', '        require(_maxWhitelistLength != maxWhitelistLength, "_maxWhitelistLength equal to current one");\n', '\n', '        maxWhitelistLength = _maxWhitelistLength;\n', '\n', '        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\n', '    }\n', '\n', '    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\n', '        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\n', '            "_whitelistThresholdBalance not allowed");\n', '        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\n', '            "_whitelistThresholdBalance not greater than current one");\n', '\n', '        whitelistThresholdBalance = _whitelistThresholdBalance;\n', '\n', '        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\n', '    }\n', '\n', '    function addToWhitelistInternal(address _subscriber) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(!whitelist[_subscriber], "already whitelisted");\n', '        require(whitelistLength < maxWhitelistLength, "max whitelist length reached");\n', '\n', '        whitelistLength++;\n', '\n', '        whitelist[_subscriber] = true;\n', '\n', '        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\n', '    }\n', '\n', '    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\n', '        require(_subscriber != address(0), "_subscriber is zero");\n', '        require(whitelist[_subscriber], "not whitelisted");\n', '        require(_balance <= whitelistThresholdBalance, "_balance greater than whitelist threshold");\n', '\n', '        assert(whitelistLength > 0);\n', '\n', '        whitelistLength--;\n', '\n', '        whitelist[_subscriber] = false;\n', '\n', '        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\n', '    }\n', '\n', '    /**\n', '     * @param _subscriber The subscriber for which the balance check is required.\n', '     * @param _balance The balance value to check for allowance.\n', '     * @return true if the balance is allowed for the subscriber, false otherwise\n', '     */\n', '    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\n', '        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/MultipleBidReservation.sol\n', '\n', '/**\n', ' * A multiple-bid Reservation Contract (RC) for early deposit collection and manual token bid during\n', ' * the Initial Coin Offering (ICO) crowdsale events.\n', ' * The RC implements the following spec:\n', ' * - investors allowed to simply send ethers to the RC address\n', ' * - investors allowed to get refunded after ICO event if RC failed\n', ' * - multiple bids using investor addresses performed by owner or authorized administator\n', ' * - maximum cap on the total balance\n', ' * - minimum threshold on each subscriber balance\n', ' * - maximum number of subscribers\n', ' * - optional whitelist with max deposit threshold for non-whitelisted subscribers\n', ' * - kill switch callable by owner or authorized administator\n', ' * - withdraw pattern for refunding\n', ' * Just the RC owner or an authorized administator is allowed to shutdown the lifecycle halting the\n', ' * RC; no bounties are provided.\n', ' */\n', 'contract MultipleBidReservation is Administrable, Whitelistable {\n', '    using SafeMath for uint256;\n', '\n', '    event LogMultipleBidReservationCreated(\n', '        uint256 indexed startBlock,\n', '        uint256 indexed endBlock,\n', '        uint256 maxSubscribers,\n', '        uint256 maxCap,\n', '        uint256 minDeposit,\n', '        uint256 maxWhitelistLength,\n', '        uint256 indexed whitelistThreshold\n', '    );\n', '    event LogStartBlockChanged(uint256 indexed startBlock);\n', '    event LogEndBlockChanged(uint256 indexed endBlock);\n', '    event LogMaxCapChanged(uint256 indexed maxCap);\n', '    event LogMinDepositChanged(uint256 indexed minDeposit);\n', '    event LogMaxSubscribersChanged(uint256 indexed maxSubscribers);\n', '    event LogCrowdsaleAddressChanged(address indexed crowdsale);\n', '    event LogAbort(address indexed caller);\n', '    event LogDeposit(\n', '        address indexed subscriber,\n', '        uint256 indexed amount,\n', '        uint256 indexed balance,\n', '        uint256 raisedFunds\n', '    );\n', '    event LogBuy(address caller, uint256 indexed from, uint256 indexed to);\n', '    event LogRefund(address indexed subscriber, uint256 indexed amount, uint256 indexed raisedFunds);\n', '\n', '    // The block interval [start, end] where investments are allowed (both inclusive)\n', '    uint256 public startBlock;\n', '    uint256 public endBlock;\n', '\n', '    // RC maximum cap (expressed in wei)\n', '    uint256 public maxCap;\n', '\n', '    // RC minimum balance per subscriber (expressed in wei)\n', '    uint256 public minDeposit;\n', '\n', '    // RC maximum number of allowed subscribers\n', '    uint256 public maxSubscribers;\n', '\n', '    // Crowdsale public address\n', '    TokenSale public crowdsale;\n', '\n', '    // RC current raised balance expressed in wei\n', '    uint256 public raisedFunds;\n', '\n', '    // ERC20-compliant token issued during ICO\n', '    ERC20 public token;\n', '\n', '    // Reservation balances (expressed in wei) deposited by each subscriber\n', '    mapping (address => uint256) public balances;\n', '\n', '    // The list of subscribers in incoming order\n', '    address[] public subscribers;\n', '\n', '    // Flag indicating if reservation has been forcibly terminated\n', '    bool public aborted;\n', '\n', '    // The maximum value for whitelist threshold in wei\n', '    uint256 constant public MAX_WHITELIST_THRESHOLD = 2**256 - 1;\n', '\n', '    modifier beforeStart() {\n', '        require(block.number < startBlock, "already started");\n', '        _;\n', '    }\n', '\n', '    modifier beforeEnd() {\n', '        require(block.number <= endBlock, "already ended");\n', '        _;\n', '    }\n', '\n', '    modifier whenReserving() {\n', '        require(!aborted, "aborted");\n', '        _;\n', '    }\n', '\n', '    modifier whenAborted() {\n', '        require(aborted, "not aborted");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    Whitelistable(_maxWhitelistLength, _whitelistThreshold) public\n', '    {\n', '        require(_startBlock >= block.number, "_startBlock < current block");\n', '        require(_endBlock >= _startBlock, "_endBlock < _startBlock");\n', '        require(_maxSubscribers > 0, "_maxSubscribers is 0");\n', '        require(_maxCap > 0, "_maxCap is 0");\n', '        require(_minDeposit > 0, "_minDeposit is 0");\n', '\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '        maxSubscribers = _maxSubscribers;\n', '        maxCap = _maxCap;\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMultipleBidReservationCreated(\n', '            startBlock,\n', '            endBlock,\n', '            maxSubscribers,\n', '            maxCap,\n', '            minDeposit,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '    }\n', '\n', '    function hasStarted() public view returns(bool started) {\n', '        return block.number >= startBlock;\n', '    }\n', '\n', '    function hasEnded() public view returns(bool ended) {\n', '        return block.number > endBlock;\n', '    }\n', '\n', '    /**\n', '     * @return The current number of RC subscribers\n', '     */\n', '    function numSubscribers() public view returns(uint256 numberOfSubscribers) {\n', '        return subscribers.length;\n', '    }\n', '\n', '    /**\n', '     * Change the RC start block number.\n', '     * @param _startBlock The start block\n', '     */\n', '    function setStartBlock(uint256 _startBlock) external onlyOwner beforeStart whenReserving {\n', '        require(_startBlock >= block.number, "_startBlock < current block");\n', '        require(_startBlock <= endBlock, "_startBlock > endBlock");\n', '        require(_startBlock != startBlock, "_startBlock == startBlock");\n', '\n', '        startBlock = _startBlock;\n', '\n', '        emit LogStartBlockChanged(_startBlock);\n', '    }\n', '\n', '    /**\n', '     * Change the RC end block number.\n', '     * @param _endBlock The end block\n', '     */\n', '    function setEndBlock(uint256 _endBlock) external onlyOwner beforeEnd whenReserving {\n', '        require(_endBlock >= block.number, "_endBlock < current block");\n', '        require(_endBlock >= startBlock, "_endBlock < startBlock");\n', '        require(_endBlock != endBlock, "_endBlock == endBlock");\n', '\n', '        endBlock = _endBlock;\n', '\n', '        emit LogEndBlockChanged(_endBlock);\n', '    }\n', '\n', '    /**\n', '     * Change the RC maximum cap. New value shall be at least equal to raisedFunds.\n', '     * @param _maxCap The RC maximum cap, expressed in wei\n', '     */\n', '    function setMaxCap(uint256 _maxCap) external onlyOwner beforeEnd whenReserving {\n', '        require(_maxCap > 0 && _maxCap >= raisedFunds, "invalid _maxCap");\n', '\n', '        maxCap = _maxCap;\n', '\n', '        emit LogMaxCapChanged(maxCap);\n', '    }\n', '\n', '    /**\n', '     * Change the minimum deposit for each RC subscriber. New value shall be lower than previous.\n', '     * @param _minDeposit The minimum deposit for each RC subscriber, expressed in wei\n', '     */\n', '    function setMinDeposit(uint256 _minDeposit) external onlyOwner beforeEnd whenReserving {\n', '        require(_minDeposit > 0 && _minDeposit < minDeposit, "_minDeposit not in (0, minDeposit)");\n', '\n', '        minDeposit = _minDeposit;\n', '\n', '        emit LogMinDepositChanged(minDeposit);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum number of accepted RC subscribers. New value shall be at least equal to the current\n', '     * number of subscribers.\n', '     * @param _maxSubscribers The maximum number of subscribers\n', '     */\n', '    function setMaxSubscribers(uint256 _maxSubscribers) external onlyOwner beforeEnd whenReserving {\n', '        require(_maxSubscribers > 0 && _maxSubscribers >= subscribers.length, "invalid _maxSubscribers");\n', '\n', '        maxSubscribers = _maxSubscribers;\n', '\n', '        emit LogMaxSubscribersChanged(maxSubscribers);\n', '    }\n', '\n', '    /**\n', '     * Change the ICO crowdsale address.\n', '     * @param _crowdsale The ICO crowdsale address\n', '     */\n', '    function setCrowdsaleAddress(address _crowdsale) external onlyOwner whenReserving {\n', '        require(_crowdsale != address(0), "_crowdsale is 0");\n', '\n', '        crowdsale = TokenSale(_crowdsale);\n', '\n', '        emit LogCrowdsaleAddressChanged(_crowdsale);\n', '    }\n', '\n', '    /**\n', '     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _maxWhitelistLength The maximum whitelist length\n', '     */\n', '    function setMaxWhitelistLength(uint256 _maxWhitelistLength) external onlyOwner beforeEnd whenReserving {\n', '        setMaxWhitelistLengthInternal(_maxWhitelistLength);\n', '    }\n', '\n', '    /**\n', '     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\n', '     * @param _whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\n', '     */\n', '    function setWhitelistThresholdBalance(uint256 _whitelistThreshold) external onlyOwner beforeEnd whenReserving {\n', '        setWhitelistThresholdBalanceInternal(_whitelistThreshold);\n', '    }\n', '\n', '    /**\n', '     * Add the subscriber to the whitelist.\n', '     * @param _subscriber The subscriber to add to the whitelist.\n', '     */\n', '    function addToWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\n', '        addToWhitelistInternal(_subscriber);\n', '    }\n', '\n', '    /**\n', '     * Removed the subscriber from the whitelist.\n', '     * @param _subscriber The subscriber to remove from the whitelist.\n', '     */\n', '    function removeFromWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\n', '        removeFromWhitelistInternal(_subscriber, balances[_subscriber]);\n', '    }\n', '\n', '    /**\n', "     * Abort the contract before the ICO start time. An administrator is allowed to use this 'kill switch'\n", '     * to deactivate any contract function except the investor refunding.\n', '     */\n', '    function abort() external onlyAdministrator whenReserving {\n', '        aborted = true;\n', '\n', '        emit LogAbort(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Let the caller invest its money before the ICO start time.\n', '     */\n', '    function invest() external payable whenReserving {\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * Execute a batch of multiple bids into the ICO crowdsale.\n', '     * @param _from The subscriber index, included, from which the batch starts.\n', '     * @param _to The subscriber index, excluded, to which the batch ends.\n', '     */\n', '    function buy(uint256 _from, uint256 _to) external onlyAdministrator whenReserving {\n', '        require(_from < _to, "_from >= _to");\n', '        require(crowdsale != address(0), "crowdsale not set");\n', '        require(subscribers.length > 0, "subscribers size is 0");\n', '        require(hasEnded(), "not ended");\n', '\n', '        uint to = _to > subscribers.length ? subscribers.length : _to;\n', '\n', '        for (uint256 i=_from; i<to; i++) {\n', '            address subscriber = subscribers[i];\n', '\n', '            uint256 subscriberBalance = balances[subscriber];\n', '\n', '            if (subscriberBalance > 0) {\n', '                balances[subscriber] = 0;\n', '\n', '                crowdsale.buyTokens.value(subscriberBalance)(subscriber);\n', '            }\n', '        }\n', '\n', '        emit LogBuy(msg.sender, _from, _to);\n', '    }\n', '\n', '    /**\n', '     * Refund the invested money to the caller after the RC termination.\n', '     */\n', '    function refund() external whenAborted {\n', '        // Read the calling subscriber balance once\n', '        uint256 subscriberBalance = balances[msg.sender];\n', '\n', '        // Withdraw is allowed IFF the calling subscriber has not zero balance\n', '        require(subscriberBalance > 0, "caller balance is 0");\n', '\n', '        // Withdraw is allowed IFF the contract has some token balance\n', '        require(raisedFunds > 0, "token balance is 0");\n', '\n', '        // Safely decrease the total balance\n', '        raisedFunds = raisedFunds.sub(subscriberBalance);\n', '\n', '        // Clear the subscriber balance before transfer to prevent re-entrant attacks\n', '        balances[msg.sender] = 0;\n', '\n', '        emit LogRefund(msg.sender, subscriberBalance, raisedFunds);\n', '\n', '        // Transfer the balance back to the calling subscriber or throws on error\n', '        msg.sender.transfer(subscriberBalance);\n', '    }\n', '\n', '    /**\n', '     * Allow investing by just sending money to the contract address.\n', '     */\n', '    function () external payable whenReserving {\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * Deposit the money amount for the beneficiary when RC is running.\n', '     */\n', '    function deposit(address beneficiary, uint256 amount) internal {\n', '        // Deposit is allowed IFF the RC is currently running\n', '        require(startBlock <= block.number && block.number <= endBlock, "not open");\n', '\n', '        uint256 newRaisedFunds = raisedFunds.add(amount);\n', '\n', '        // Deposit is allowed IFF the contract balance will not reach its maximum cap\n', '        require(newRaisedFunds <= maxCap, "over max cap");\n', '\n', '        uint256 currentBalance = balances[beneficiary];\n', '        uint256 finalBalance = currentBalance.add(amount);\n', '\n', '        // Deposit is allowed IFF investor deposit shall be at least equal to the minimum deposit threshold\n', '        require(finalBalance >= minDeposit, "deposit < min deposit");\n', '\n', '        // Balances over whitelist threshold are allowed IFF the sender is in whitelist\n', '        require(isAllowedBalance(beneficiary, finalBalance), "balance not allowed");\n', '\n', '        // Increase the subscriber count if sender does not have a balance yet\n', '        if (currentBalance == 0) {\n', '            // New subscribers are allowed IFF the contract has not yet the max number of subscribers\n', '            require(subscribers.length < maxSubscribers, "max subscribers reached");\n', '\n', '            subscribers.push(beneficiary);\n', '        }\n', '\n', '        // Add the received amount to the subscriber balance\n', '        balances[beneficiary] = finalBalance;\n', '\n', '        raisedFunds = newRaisedFunds;\n', '\n', '        emit LogDeposit(beneficiary, amount, finalBalance, newRaisedFunds);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomReservation.sol\n', '\n', '/**\n', ' * @title NokuCustomReservation\n', ' * @dev Extension of MultipleBidReservation.\n', ' */\n', 'contract NokuCustomReservation is MultipleBidReservation {\n', '    event LogNokuCustomReservationCreated();\n', '\n', '    constructor(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    MultipleBidReservation(\n', '        _startBlock,\n', '        _endBlock,\n', '        _maxSubscribers,\n', '        _maxCap,\n', '        _minDeposit,\n', '        _maxWhitelistLength,\n', '        _whitelistThreshold\n', '    )\n', '    public {\n', '        emit LogNokuCustomReservationCreated();\n', '    }\n', '}\n', '\n', '// File: contracts/NokuPricingPlan.sol\n', '\n', '/**\n', '* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\n', '*/\n', 'contract NokuPricingPlan {\n', '    /**\n', '    * @dev Pay the fee for the service identified by the specified name.\n', '    * The fee amount shall already be approved by the client.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @param client The client of the target service.\n', '    * @return true if fee has been paid.\n', '    */\n', '    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n', '\n', '    /**\n', '    * @dev Get the usage fee for the service identified by the specified name.\n', '    * The returned fee amount shall be approved before using #payFee method.\n', '    * @param serviceName The name of the target service.\n', '    * @param multiplier The multiplier of the base service fee to apply.\n', '    * @return The amount to approve before really paying such fee.\n', '    */\n', '    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/NokuCustomService.sol\n', '\n', 'contract NokuCustomService is Pausable {\n', '    using AddressUtils for address;\n', '\n', '    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n', '\n', '    // The pricing plan determining the fee to be paid in NOKU tokens by customers\n', '    NokuPricingPlan public pricingPlan;\n', '\n', '    constructor(address _pricingPlan) internal {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '\n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '    }\n', '\n', '    function setPricingPlan(address _pricingPlan) public onlyOwner {\n', '        require(_pricingPlan.isContract(), "_pricingPlan is not contract");\n', '        require(NokuPricingPlan(_pricingPlan) != pricingPlan, "_pricingPlan equal to current");\n', '        \n', '        pricingPlan = NokuPricingPlan(_pricingPlan);\n', '\n', '        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n', '    }\n', '}\n', '\n', '// File: contracts/NokuCustomReservationService.sol\n', '\n', '/**\n', ' * @title NokuCustomReservationService\n', ' * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\n', ' */\n', 'contract NokuCustomReservationService is NokuCustomService {\n', '    event LogNokuCustomReservationServiceCreated(address indexed caller);\n', '\n', '    bytes32 public constant SERVICE_NAME = "NokuCustomERC20.reservation";\n', '    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n', '\n', '    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n', '        emit LogNokuCustomReservationServiceCreated(msg.sender);\n', '    }\n', '\n', '    function createCustomReservation(\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _maxSubscribers,\n', '        uint256 _maxCap,\n', '        uint256 _minDeposit,\n', '        uint256 _maxWhitelistLength,\n', '        uint256 _whitelistThreshold\n', '    )\n', '    public returns(NokuCustomReservation customReservation)\n', '    {\n', '        customReservation = new NokuCustomReservation(\n', '            _startBlock,\n', '            _endBlock,\n', '            _maxSubscribers,\n', '            _maxCap,\n', '            _minDeposit,\n', '            _maxWhitelistLength,\n', '            _whitelistThreshold\n', '        );\n', '\n', '        // Transfer NokuCustomReservation ownership to the client\n', '        customReservation.transferOwnership(msg.sender);\n', '\n', '        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), "fee payment failed");\n', '    }\n', '}']
