['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    hasMintPermission\n', '    canMint\n', '    public\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/NectarToken.sol\n', '\n', 'contract NectarToken is MintableToken {\n', '    string public name = "Nectar";\n', '    string public symbol = "NCT";\n', '    uint8 public decimals = 18;\n', '\n', '    bool public transfersEnabled = false;\n', '    event TransfersEnabled();\n', '\n', '    // Disable transfers until after the sale\n', '    modifier whenTransfersEnabled() {\n', '        require(transfersEnabled, "Transfers not enabled");\n', '        _;\n', '    }\n', '\n', '    modifier whenTransfersNotEnabled() {\n', '        require(!transfersEnabled, "Transfers enabled");\n', '        _;\n', '    }\n', '\n', '    function enableTransfers() public onlyOwner whenTransfersNotEnabled {\n', '        transfersEnabled = true;\n', '        emit TransfersEnabled();\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public whenTransfersEnabled returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public whenTransfersEnabled returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    // Approves and then calls the receiving contract\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        // Call the receiveApproval function on the contract you want to be notified.\n', '        // This crafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\n', '        //\n', '        // receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //\n', '        // It is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '\n', '        // solium-disable-next-line security/no-low-level-calls, indentation\n', '        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))),\n', '            msg.sender, _value, this, _extraData), "receiveApproval failed");\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/OfferMultiSig.sol\n', '\n', 'contract OfferMultiSig is Pausable {\n', '    using SafeMath for uint256;\n', '    \n', '    string public constant NAME = "Offer MultiSig";\n', '    string public constant VERSION = "0.0.1";\n', '    uint256 public constant MIN_SETTLEMENT_PERIOD = 10;\n', '    uint256 public constant MAX_SETTLEMENT_PERIOD = 3600;\n', '\n', '    event CommunicationsSet(\n', '        bytes32 websocketUri\n', '    );\n', '\n', '    event OpenedAgreement(\n', '        address _ambassador\n', '    );\n', '\n', '    event CanceledAgreement(\n', '        address _ambassador\n', '    );\n', '\n', '    event JoinedAgreement(\n', '        address _expert\n', '    );\n', '\n', '    event ClosedAgreement(\n', '        address _expert,\n', '        address _ambassador\n', '    );\n', '\n', '    event FundsDeposited(\n', '        address _ambassador,\n', '        address _expert,\n', '        uint256 ambassadorBalance,\n', '        uint256 expertBalance\n', '    );\n', '\n', '    event StartedSettle(\n', '        address initiator,\n', '        uint sequence,\n', '        uint settlementPeriodEnd\n', '    );\n', '\n', '    event SettleStateChallenged(\n', '        address challenger,\n', '        uint sequence,\n', '        uint settlementPeriodEnd\n', '    );\n', '\n', '    address public nectarAddress; // Address of offer nectar token\n', '    address public ambassador; // Address of first channel participant\n', '    address public expert; // Address of second channel participant\n', '    \n', '    bool public isOpen = false; // true when both parties have joined\n', '    bool public isPending = false; // true when waiting for counterparty to join agreement\n', '\n', '    uint public settlementPeriodLength; // How long challengers have to reply to settle engagement\n', '    uint public isClosed; // if the period has closed\n', '    uint public sequence; // state nonce used in during settlement\n', '    uint public isInSettlementState; // meta channel is in settling 1: Not settling 0\n', '    uint public settlementPeriodEnd; // The time when challenges are no longer accepted after\n', '\n', '    bytes public state; // the current state\n', '    bytes32 public websocketUri; // a geth node running whisper (shh)\n', '\n', '    constructor(address _nectarAddress, address _ambassador, address _expert, uint _settlementPeriodLength) public {\n', '        require(_ambassador != address(0), "No ambassador lib provided to constructor");\n', '        require(_expert != address(0), "No expert provided to constructor");\n', '        require(_nectarAddress != address(0), "No token provided to constructor");\n', '\n', '        // solium-disable-next-line indentation\n', '        require(_settlementPeriodLength >= MIN_SETTLEMENT_PERIOD && _settlementPeriodLength <= MAX_SETTLEMENT_PERIOD,\n', '            "Settlement period out of range");\n', '\n', '        ambassador = _ambassador;\n', '        expert = _expert;\n', '        settlementPeriodLength = _settlementPeriodLength;\n', '        nectarAddress = _nectarAddress;\n', '    }\n', '\n', '    /** Function only callable by participants */\n', '    modifier onlyParticipants() {\n', '        require(msg.sender == ambassador || msg.sender == expert, "msg.sender is not a participant");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador to open channel with _expert \n', '     * \n', '     * @param _state inital offer state\n', '     * @param _v the recovery id from signature of state\n', '     * @param _r output of ECDSA signature of state\n', '     * @param _s output of ECDSA signature of state\n', '     */\n', '    function openAgreement(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) public whenNotPaused {\n', '        // require the channel is not open yet\n', '        require(isOpen == false, "openAgreement already called, isOpen true");\n', '        require(isPending == false, "openAgreement already called, isPending true");\n', '        require(msg.sender == ambassador, "msg.sender is not the ambassador");\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '        require(msg.sender == getPartyA(_state), "Party A does not match signature recovery");\n', '\n', '        // check the account opening a channel signed the initial state\n', '        address initiator = getSig(_state, _v, _r, _s);\n', '\n', '        require(ambassador == initiator, "Initiator in state is not the ambassador");\n', '\n', '        isPending = true;\n', '\n', '        state = _state;\n', '\n', '        open(_state);\n', '\n', '        emit OpenedAgreement(ambassador);\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador to cancel a channel that hasn&#39;t been joined yet\n', '     */\n', '    function cancelAgreement() public whenNotPaused {\n', '        // require the channel is not open yet\n', '        require(isPending == true, "Only a channel in a pending state can be canceled");\n', '        require(msg.sender == ambassador, "Only an ambassador can cancel an agreement");\n', '\n', '        isPending = false;\n', '\n', '        cancel(nectarAddress);\n', '\n', '        emit CanceledAgreement(ambassador);\n', '    }\n', '\n', '    /**\n', '     * Function called by expert to complete opening the channel with an ambassador defined in the _state\n', '     * \n', '     * @param _state offer state from ambassador\n', '     * @param _v the recovery id from signature of state\n', '     * @param _r output of ECDSA signature  of state\n', '     * @param _s output of ECDSA signature of state\n', '     */\n', '    function joinAgreement(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) public whenNotPaused {\n', '        require(isOpen == false, "openAgreement already called, isOpen true");\n', '        require(msg.sender == expert, "msg.sender is not the expert");\n', '        require(isPending, "Offer not pending");\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '\n', '        // check that the state is signed by the sender and sender is in the state\n', '        address joiningParty = getSig(_state, _v, _r, _s);\n', '\n', '        require(expert == joiningParty, "Joining party in state is not the expert");\n', '\n', '        // no longer allow joining functions to be called\n', '        isOpen = true;\n', '\n', '        isPending = false;\n', '\n', '        join(state);\n', '\n', '        emit JoinedAgreement(expert);\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador to update balance and add to escrow\n', '     * by default to escrows the allowed balance\n', '     * @param _state offer state from ambassador\n', '     * @param _sigV the recovery id from signature of state by both parties\n', '     * @param _sigR output of ECDSA signature  of state by both parties\n', '     * @param _sigS output of ECDSA signature of state by both parties\n', '     * @dev index 0 is the ambassador signature\n', '     * @dev index 1 is the expert signature\n', '     */\n', '    function depositFunds(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\n', '        require(isOpen == true, "Tried adding funds to a closed msig wallet");\n', '        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\n', '        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '        // Require both signatures\n', '        require(_hasAllSigs(_ambassador, _expert), "Missing signatures");\n', '\n', '        state = _state;\n', '\n', '        update(_state);\n', '\n', '        emit FundsDeposited(_ambassador, _expert, getBalanceA(_state), getBalanceB(_state));\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador or expert to close a their channel after a dispute has timedout\n', '     *\n', '     * @param _state final offer state agreed on by both parties through dispute settlement\n', '     * @param _sigV the recovery id from signature of state by both parties\n', '     * @param _sigR output of ECDSA signature  of state by both parties\n', '     * @param _sigS output of ECDSA signature of state by both parties\n', '     * @dev index 0 is the ambassador signature\n', '     * @dev index 1 is the expert signature\n', '     */\n', '    function closeAgreementWithTimeout(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\n', '        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\n', '        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '        require(settlementPeriodEnd <= block.number, "Settlement period hasn&#39;t ended");\n', '        require(isClosed == 0, "Offer is closed");\n', '        require(isInSettlementState == 1, "Offer is not in settlement state");\n', '\n', '        require(_hasAllSigs(_ambassador, _expert), "Missing signatures");\n', '        require(keccak256(state) == keccak256(_state), "State hash mismatch");\n', '\n', '        isClosed = 1;\n', '\n', '        finalize(_state);\n', '        isOpen = false;\n', '\n', '        emit ClosedAgreement(_expert, _ambassador);\n', '    }\n', '\n', '\n', '    /**\n', '     * Function called by ambassador or expert to close a their channel with close flag\n', '     *\n', '     * @param _state final offer state agreed on by both parties with close flag\n', '     * @param _sigV the recovery id from signature of state by both parties\n', '     * @param _sigR output of ECDSA signature  of state by both parties\n', '     * @param _sigS output of ECDSA signature of state by both parties\n', '     * @dev index 0 is the ambassador signature\n', '     * @dev index 1 is the expert signature\n', '     */\n', '    function closeAgreement(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\n', '        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\n', '        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '        require(isClosed == 0, "Offer is closed");\n', '        \n', '        /// @dev make sure we&#39;re not in dispute\n', '        require(isInSettlementState == 0, "Offer is in settlement state");\n', '\n', '        /// @dev must have close flag\n', '        require(_isClosed(_state), "State did not have a signed close out state");\n', '        require(_hasAllSigs(_ambassador, _expert), "Missing signatures");\n', '\n', '        isClosed = 1;\n', '        state = _state;\n', '\n', '        finalize(_state);\n', '        isOpen = false;\n', '\n', '        emit ClosedAgreement(_expert, _ambassador);\n', '\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador or expert to start initalize a disputed settlement\n', '     * using an agreed upon state. It starts a timeout for a reply using `settlementPeriodLength`\n', '     * \n', '     * @param _state offer state agreed on by both parties\n', '     * @param _sigV the recovery id from signature of state by both parties\n', '     * @param _sigR output of ECDSA signature  of state by both parties\n', '     * @param _sigS output of ECDSA signature of state by both parties\n', '     */\n', '    function startSettle(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\n', '        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\n', '        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '\n', '        require(_hasAllSigs(_ambassador, _expert), "Missing signatures");\n', '\n', '        require(isClosed == 0, "Offer is closed");\n', '        require(isInSettlementState == 0, "Offer is in settlement state");\n', '\n', '        state = _state;\n', '\n', '        sequence = getSequence(_state);\n', '\n', '        isInSettlementState = 1;\n', '        settlementPeriodEnd = block.number.add(settlementPeriodLength);\n', '\n', '        emit StartedSettle(msg.sender, sequence, settlementPeriodEnd);\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador or expert to challenge a disputed state\n', '     * The new state is accepted if it is signed by both parties and has a higher sequence number\n', '     * \n', '     * @param _state offer state agreed on by both parties\n', '     * @param _sigV the recovery id from signature of state by both parties\n', '     * @param _sigR output of ECDSA signature  of state by both parties\n', '     * @param _sigS output of ECDSA signature of state by both parties\n', '     */\n', '    function challengeSettle(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\n', '        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\n', '        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\n', '        require(getTokenAddress(_state) == nectarAddress, "Invalid token address");\n', '        require(_hasAllSigs(_ambassador, _expert), "Missing signatures");\n', '\n', '        require(isInSettlementState == 1, "Offer is not in settlement state");\n', '        require(block.number < settlementPeriodEnd, "Settlement period has ended");\n', '\n', '        require(getSequence(_state) > sequence, "Sequence number is too old");\n', '\n', '        settlementPeriodEnd = block.number.add(settlementPeriodLength);\n', '        state = _state;\n', '        sequence = getSequence(_state);\n', '\n', '        emit SettleStateChallenged(msg.sender, sequence, settlementPeriodEnd);\n', '    }\n', '\n', '    /**\n', '     * Return when the settlement period is going to end. This is the amount of time\n', '     * an ambassor or expert has to reply with a new state\n', '     */\n', '    function getSettlementPeriodEnd() public view returns (uint) {\n', '        return settlementPeriodEnd;\n', '    }\n', '\n', '    /**\n', '    * Function to be called by ambassador to set comunication information\n', '    *\n', '    * @param _websocketUri uri of whisper node\n', '    */\n', '    function setCommunicationUri(bytes32 _websocketUri) external whenNotPaused {\n', '        require(msg.sender == ambassador, "msg.sender is not the ambassador");\n', '\n', '        websocketUri = _websocketUri;\n', '\n', '        emit CommunicationsSet(websocketUri);\n', '    }\n', '\n', '    /**\n', '     * Function called to get the state sequence/nonce\n', '     *\n', '     * @param _state offer state\n', '     */\n', '    function getSequence(bytes _state) public pure returns (uint _seq) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _seq := mload(add(_state, 64))\n', '        }\n', '    }\n', '\n', '    function isChannelOpen() public view returns (bool) {\n', '        return isOpen;\n', '    }\n', '\n', '    function getWebsocketUri() public view returns (bytes32) {\n', '        return websocketUri;\n', '    }\n', '\n', '    /**\n', '     * A utility function to check if both parties have signed\n', '     *\n', '     * @param _a ambassador address\n', '     * @param _b expert address\n', '     */\n', '\n', '    function _hasAllSigs(address _a, address _b) internal view returns (bool) {\n', '        require(_a == ambassador && _b == expert, "Signatures do not match parties in state");\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * A utility function to check for the closed flag in the offer state\n', '     *\n', '     * @param _state current offer state\n', '     */\n', '    function _isClosed(bytes _state) internal pure returns (bool) {\n', '        require(getCloseFlag(_state) == 1, "Offer is not closed");\n', '\n', '        return true;\n', '    }\n', '\n', '    function getCloseFlag(bytes _state) public pure returns (uint8 _flag) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _flag := mload(add(_state, 32))\n', '        }\n', '    }\n', '\n', '    function getPartyA(bytes _state) public pure returns (address _ambassador) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _ambassador := mload(add(_state, 96))\n', '        }\n', '    }\n', '\n', '    function getPartyB(bytes _state) public pure returns (address _expert) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _expert := mload(add(_state, 128))\n', '        }\n', '    }\n', '\n', '    function getBalanceA(bytes _state) public pure returns (uint256 _balanceA) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _balanceA := mload(add(_state, 192))\n', '        }\n', '    }\n', '\n', '    function getBalanceB(bytes _state) public pure returns (uint256 _balanceB) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _balanceB := mload(add(_state, 224))\n', '        }\n', '    }\n', '\n', '    function getTokenAddress(bytes _state) public pure returns (address _token) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            _token := mload(add(_state, 256))\n', '        }\n', '    }\n', '\n', '    function getTotal(bytes _state) public pure returns (uint256) {\n', '        uint256 _a = getBalanceA(_state);\n', '        uint256 _b = getBalanceB(_state);\n', '\n', '        return _a.add(_b);\n', '    }\n', '\n', '    function open(bytes _state) internal returns (bool) {\n', '        require(msg.sender == getPartyA(_state), "Party A does not match signature recovery");\n', '\n', '        // get the token instance used to allow funds to msig\n', '        NectarToken _t = NectarToken(getTokenAddress(_state));\n', '\n', '        // ensure the amount sent to open channel matches the signed state balance\n', '        require(_t.allowance(getPartyA(_state), this) == getBalanceA(_state), "value does not match ambassador state balance");\n', '\n', '        // complete the tranfer of ambassador approved tokens\n', '        require(_t.transferFrom(getPartyA(_state), this, getBalanceA(_state)), "failed tranfering approved balance from ambassador");\n', '        return true;\n', '    }\n', '\n', '    function join(bytes _state) internal view returns (bool) {\n', '        // get the token instance used to allow funds to msig\n', '        NectarToken _t = NectarToken(getTokenAddress(_state));\n', '\n', '        // ensure the amount sent to join channel matches the signed state balance\n', '        require(msg.sender == getPartyB(_state), "Party B does not match signature recovery");\n', '\n', '        // Require bonded is the sum of balances in state\n', '        require(getTotal(_state) == _t.balanceOf(this), "token total deposited does not match state balance");\n', '\n', '        return true;\n', '    }\n', '\n', '    function update(bytes _state) internal returns (bool) {\n', '        // get the token instance used to allow funds to msig\n', '        NectarToken _t = NectarToken(getTokenAddress(_state));\n', '\n', '        if(_t.allowance(getPartyA(_state), this) > 0) {\n', '            require(_t.transferFrom(getPartyA(_state), this, _t.allowance(getPartyA(_state), this)), "failed transfering deposit from party A to contract");\n', '        }\n', '\n', '        require(getTotal(_state) == _t.balanceOf(this), "token total deposited does not match state balance");\n', '    }\n', '\n', '    function cancel(address tokenAddress) internal returns (bool) {\n', '        NectarToken _t = NectarToken(tokenAddress);\n', '\n', '        return _t.transfer(msg.sender, _t.balanceOf(this));\n', '    }\n', '\n', '    /**\n', '     * Function called by closeAgreementWithTimeout or closeAgreement to disperse payouts\n', '     *\n', '     * @param _state final offer state agreed on by both parties with close flag\n', '     */\n', '\n', '    function finalize(bytes _state) internal returns (bool) {\n', '        address _a = getPartyA(_state);\n', '        address _b = getPartyB(_state);\n', '\n', '        NectarToken _t = NectarToken(getTokenAddress(_state));\n', '        require(getTotal(_state) == _t.balanceOf(this), "tried finalizing token state that does not match bonded value");\n', '\n', '        require(_t.transfer(_a, getBalanceA(_state)), "failed transfering balance to party A");\n', '        require(_t.transfer(_b, getBalanceB(_state)), "failed transfering balance to party B");\n', '    }\n', '\n', '\n', '    /**\n', '     * A utility function to return the address of the person that signed the state\n', '     *\n', '     * @param _state offer state that was signed\n', '     * @param _v the recovery id from signature of state by both parties\n', '     * @param _r output of ECDSA signature  of state by both parties\n', '     * @param _s output of ECDSA signature of state by both parties\n', '     */\n', '    function getSig(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 h = keccak256(_state);\n', '\n', '        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, h));\n', '\n', '        address a = ecrecover(prefixedHash, _v, _r, _s);\n', '\n', '        return a;\n', '    }\n', '}\n', '\n', '// File: contracts/OfferRegistry.sol\n', '\n', '/// @title Creates new Offer Channel contracts and keeps track of them\n', 'contract OfferRegistry is Pausable {\n', '\n', '    struct OfferChannel {\n', '        address msig;\n', '        address ambassador;\n', '        address expert;\n', '    }\n', '\n', '    event InitializedChannel(\n', '        address msig,\n', '        address ambassador,\n', '        address expert,\n', '        uint128 guid\n', '    );\n', '\n', '    uint128[] public channelsGuids;\n', '    mapping (bytes32 => address) public participantsToChannel;\n', '    mapping (uint128 => OfferChannel) public guidToChannel;\n', '\n', '    address public nectarAddress;\n', '\n', '    constructor(address _nectarAddress) public {\n', '        require(_nectarAddress != address(0), "Invalid token address");\n', '\n', '        nectarAddress = _nectarAddress;\n', '    }\n', '\n', '    /**\n', '     * Function called by ambassador to initialize an offer contract\n', '     * It deploys a new offer multi sig and saves it for each participant\n', '     *\n', '     * @param _ambassador address of ambassador\n', '     * @param _expert address of expert\n', '     * @param _settlementPeriodLength how long the parties have to dispute the settlement offer channel\n', '     */\n', '    function initializeOfferChannel(uint128 guid, address _ambassador, address _expert, uint _settlementPeriodLength) external whenNotPaused {\n', '        require(address(0) != _expert, "Invalid expert address");\n', '        require(address(0) != _ambassador, "Invalid ambassador address");\n', '        require(msg.sender == _ambassador, "Initializer isn&#39;t ambassador");\n', '        require(guidToChannel[guid].msig == address(0), "GUID already in use");\n', '\n', '        bytes32 key = getParticipantsHash(_ambassador, _expert);\n', '\n', '        if (participantsToChannel[key] != address(0)) {\n', '            /// @dev check to make sure the participants don&#39;t already have an open channel\n', '            // solium-disable-next-line indentation\n', '            require(OfferMultiSig(participantsToChannel[key]).isChannelOpen() == false,\n', '                "Channel already exists between parties");\n', '        }\n', '\n', '        address msig = new OfferMultiSig(nectarAddress, _ambassador, _expert, _settlementPeriodLength);\n', '\n', '        participantsToChannel[key] = msig;\n', '\n', '        guidToChannel[guid].msig = msig;\n', '        guidToChannel[guid].ambassador = _ambassador;\n', '        guidToChannel[guid].expert = _expert;\n', '\n', '        channelsGuids.push(guid);\n', '\n', '        emit InitializedChannel(msig, _ambassador, _expert, guid);\n', '    }\n', '\n', '    /**\n', '     * Get the total number of offer channels tracked by the contract\n', '     *\n', '     * @return total number of offer channels\n', '     */\n', '    function getNumberOfOffers() external view returns (uint) {\n', '        return channelsGuids.length;\n', '    }\n', '\n', '    /**\n', '     * Function to get channel participants are on\n', '     *\n', '     * @param _ambassador the address of ambassador\n', '     * @param _expert the address of ambassador\n', '     */\n', '    function getParticipantsChannel(address _ambassador, address _expert) external view returns (address) {\n', '        bytes32 key = getParticipantsHash(_ambassador, _expert);\n', '\n', '        require(participantsToChannel[key] != address(0), "Channel does not exist between parties");\n', '\n', '        return participantsToChannel[key];\n', '    }\n', '\n', '    /**\n', '     * Gets all the created channelsGuids\n', '     *\n', '     * @return list of every channel registered\n', '     */\n', '    function getChannelsGuids() external view returns (address[]) {\n', '        require(channelsGuids.length != 0, "No channels initialized");\n', '\n', '        address[] memory registeredChannelsGuids = new address[](channelsGuids.length);\n', '\n', '        for (uint i = 0; i < channelsGuids.length; i++) {\n', '            registeredChannelsGuids[i] = channelsGuids[i];\n', '        }\n', '\n', '        return registeredChannelsGuids;\n', '    }\n', '\n', '    /**\n', '     * Pause all channels\n', '     *\n', '     * @return list of every channel registered\n', '     */\n', '    function pauseChannels() external onlyOwner whenNotPaused {\n', '        require(channelsGuids.length != 0, "No channels initialized");\n', '\n', '        pause();\n', '\n', '        for (uint i = 0; i < channelsGuids.length; i++) {\n', '            OfferMultiSig(guidToChannel[channelsGuids[i]].msig).pause();\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * Unpause all channels\n', '     *\n', '     * @return list of every channel registered\n', '     */\n', '\n', '    function unpauseChannels() external onlyOwner whenPaused {\n', '        require(channelsGuids.length != 0, "No channels initialized");\n', '\n', '        for (uint i = 0; i < channelsGuids.length; i++) {\n', '            OfferMultiSig(guidToChannel[channelsGuids[i]].msig).unpause();\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * Return offer information from state\n', '     *\n', '     * @return list of every channel registered\n', '     * @param _state offer state agreed on by both parties\n', '     */\n', '\n', '    function getOfferState(\n', '        bytes _state\n', '    )\n', '    public\n', '    pure\n', '        returns (\n', '            bytes32 _guid,\n', '            uint256 _nonce,\n', '            uint256 _amount,\n', '            address _msigAddress,\n', '            uint256 _balanceA,\n', '            uint256 _balanceB,\n', '            address _ambassador,\n', '            address _expert,\n', '            uint256 _isClosed,\n', '            address _token,\n', '            uint256 _mask,\n', '            uint256 _assertion\n', '        )\n', '    {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '             _guid := mload(add(_state, 288)) // [256-287] - a globally-unique identifier for the listing\n', '             _nonce:= mload(add(_state, 64)) // [32-63] - the sequence of state\n', '             _amount := mload(add(_state, 320)) // [288-319] - the offer amount awarded to expert for responses\n', '             _msigAddress := mload(add(_state, 160)) // [128-159] - msig address where funds and offer are managed\n', '             _balanceA := mload(add(_state,192)) // [160-191] balance in nectar for ambassador\n', '             _balanceB := mload(add(_state,224)) // [192-223] balance in nectar for expert\n', '             _ambassador := mload(add(_state, 96)) // [64-95] - offer&#39;s ambassador address\n', '             _expert := mload(add(_state, 128)) // [96-127] - offer&#39;s expert address\n', '             _isClosed := mload(add(_state, 32)) // [0-31] - 0 or 1 for if the state is marked as closed\n', '             _token := mload(add(_state, 256)) // [224-255] - nectar token address\n', '             _mask := mload(add(_state, 480)) // [448-479] - assertion mask\n', '             _assertion := mload(add(_state, 512)) // [480-511] - assertions from expert\n', '        }\n', '    }\n', '\n', '    // Internals\n', '\n', '    /**\n', '     * Utility function to get hash\n', '     *\n', '     * @param _ambassador address of ambassador\n', '     * @param _expert address of expert\n', '     * @return hash of ambassador and expert\n', '     */\n', '\n', '    function getParticipantsHash(address _ambassador, address _expert) internal pure returns (bytes32) {\n', '        string memory str_ambassador = toString(_ambassador);\n', '        string memory str_expert = toString(_expert);\n', '\n', '        return keccak256(abi.encodePacked(strConcat(str_ambassador, str_expert)));\n', '    }\n', '\n', '    function toString(address x) internal pure returns (string) {\n', '        bytes memory b = new bytes(20);\n', '        for (uint i = 0; i < 20; i++) {\n', '            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '        }\n', '        return string(b);\n', '    }\n', '\n', '    function strConcat(string _a, string _b) internal pure returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        string memory abcde = new string(_ba.length + _bb.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '\n', '        for (uint i = 0; i < _ba.length; i++) {\n', '            babcde[k++] = _ba[i];\n', '        }\n', '\n', '        for (i = 0; i < _bb.length; i++) {\n', '            babcde[k++] = _bb[i];\n', '        }\n', '\n', '        return string(babcde);\n', '    }\n', '\n', '\n', '    /** Disable usage of the fallback function */\n', '    function() public payable {\n', '        revert("Do not allow sending Eth to this contract");\n', '    }\n', '}']