['pragma solidity ^0.5.1;\n', '\n', 'contract LockRequestable {\n', '\n', '        // MEMBERS\n', '        /// @notice  the count of all invocations of `generateLockId`.\n', '        uint256 public lockRequestCount;\n', '\n', '        constructor() public {\n', '                lockRequestCount = 0;\n', '        }\n', '\n', '        // FUNCTIONS\n', '        /** @notice  Returns a fresh unique identifier.\n', '            *\n', '            * @dev the generation scheme uses three components.\n', '            * First, the blockhash of the previous block.\n', '            * Second, the deployed address.\n', '            * Third, the next value of the counter.\n', '            * This ensure that identifiers are unique across all contracts\n', '            * following this scheme, and that future identifiers are\n', '            * unpredictable.\n', '            *\n', '            * @return a 32-byte unique identifier.\n', '            */\n', '        function generateLockId() internal returns (bytes32 lockId) {\n', '                return keccak256(\n', '                abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount)\n', '                );\n', '        }\n', '}\n', '\n', 'contract CustodianUpgradeable is LockRequestable {\n', '\n', '        // TYPES\n', '        /// @dev  The struct type for pending custodian changes.\n', '        struct CustodianChangeRequest {\n', '                address proposedNew;\n', '        }\n', '\n', '        // MEMBERS\n', '        /// @dev  The address of the account or contract that acts as the custodian.\n', '        address public custodian;\n', '\n', '        /// @dev  The map of lock ids to pending custodian changes.\n', '        mapping (bytes32 => CustodianChangeRequest) public custodianChangeReqs;\n', '\n', '        constructor(address _custodian) public LockRequestable() {\n', '                custodian = _custodian;\n', '        }\n', '\n', '        // MODIFIERS\n', '        modifier onlyCustodian {\n', '                require(msg.sender == custodian);\n', '                _;\n', '        }\n', '\n', '        /** @notice  Requests a change of the custodian associated with this contract.\n', '            *\n', '            * @dev  Returns a unique lock id associated with the request.\n', '            * Anyone can call this function, but confirming the request is authorized\n', '            * by the custodian.\n', '            *\n', '            * @param  _proposedCustodian  The address of the new custodian.\n', '            * @return  lockId  A unique identifier for this request.\n', '            */\n', '        function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n', '                require(_proposedCustodian != address(0));\n', '\n', '                lockId = generateLockId();\n', '\n', '                custodianChangeReqs[lockId] = CustodianChangeRequest({\n', '                        proposedNew: _proposedCustodian\n', '                });\n', '\n', '                emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n', '        }\n', '\n', '        /** @notice  Confirms a pending change of the custodian associated with this contract.\n', '            *\n', '            * @dev  When called by the current custodian with a lock id associated with a\n', '            * pending custodian change, the `address custodian` member will be updated with the\n', '            * requested address.\n', '            *\n', '            * @param  _lockId  The identifier of a pending change request.\n', '            */\n', '        function confirmCustodianChange(bytes32 _lockId) public onlyCustodian {\n', '                custodian = getCustodianChangeReq(_lockId);\n', '\n', '                delete custodianChangeReqs[_lockId];\n', '\n', '                emit CustodianChangeConfirmed(_lockId, custodian);\n', '        }\n', '\n', '        // PRIVATE FUNCTIONS\n', '        function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\n', '                CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\n', '\n', '                // reject ‘null’ results from the map lookup\n', '                // this can only be the case if an unknown `_lockId` is received\n', '                require(changeRequest.proposedNew != address(0));\n', '\n', '                return changeRequest.proposedNew;\n', '        }\n', '\n', '        /// @dev  Emitted by successful `requestCustodianChange` calls.\n', '        event CustodianChangeRequested(\n', '                bytes32 _lockId,\n', '                address _msgSender,\n', '                address _proposedCustodian\n', '        );\n', '\n', '        /// @dev Emitted by successful `confirmCustodianChange` calls.\n', '        event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\n', '}\n', '\n', 'contract ServiceRegistry is CustodianUpgradeable {\n', '    mapping (string => address) services;\n', '\n', '    event ServiceReplaced(string indexed _name, address _oldAddr, address _newAddr);\n', '\n', '    constructor(address _custodian) public CustodianUpgradeable(_custodian) {\n', '    }\n', '\n', '    function replaceService(string calldata _name, address _newAddr) external onlyCustodian withContract(_newAddr) {\n', '        address _prevAddr = services[_name];\n', '        services[_name] = _newAddr;\n', '        emit ServiceReplaced(_name, _prevAddr, _newAddr);\n', '    }\n', '\n', '    function getService(string memory _name) public view returns (address) {\n', '        return services[_name];\n', '    }\n', '\n', '    modifier withContract(address _addr) {\n', '        uint length;\n', '        assembly { length := extcodesize(_addr) }\n', '        require(length > 0);\n', '        _;\n', '    }\n', '}']