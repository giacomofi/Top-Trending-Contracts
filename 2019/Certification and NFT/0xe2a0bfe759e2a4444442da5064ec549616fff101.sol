['/*\n', '\n', '    Copyright 2019 The Hydro Protocol Foundation\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @dev Math operations with safety checks that revert on error\n', 'library SafeMath {\n', '\n', '    /// @dev Multiplies two numbers, reverts on overflow.\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MUL_ERROR");\n', '\n', '        return c;\n', '    }\n', '\n', '    /// @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "DIVIDING_ERROR");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    /// @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SUB_ERROR");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /// @dev Adds two numbers, reverts on overflow.\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ADD_ERROR");\n', '        return c;\n', '    }\n', '\n', '    /// @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "MOD_ERROR");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * EIP712 Ethereum typed structured data hashing and signing\n', ' */\n', 'contract EIP712 {\n', '    string internal constant DOMAIN_NAME = "Hydro Protocol";\n', '\n', '    /**\n', '     * Hash of the EIP712 Domain Separator Schema\n', '     */\n', '    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        abi.encodePacked("EIP712Domain(string name)")\n', '    );\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    constructor () public {\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encodePacked(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(DOMAIN_NAME))\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n', '     *\n', '     * @param eip712hash The EIP712 hash struct.\n', '     * @return EIP712 hash applied to this EIP712 Domain.\n', '     */\n', '    function hashEIP712Message(bytes32 eip712hash) internal view returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, eip712hash));\n', '    }\n', '}\n', '\n', 'contract LibSignature {\n', '\n', '    enum SignatureMethod {\n', '        EthSign,\n', '        EIP712\n', '    }\n', '\n', '    /**\n', '     * OrderSignature struct contains typical signature data as v, r, and s with the signature\n', '     * method encoded in as well.\n', '     */\n', '    struct OrderSignature {\n', '        /**\n', '         * Config contains the following values packed into 32 bytes\n', '         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n', '         * ║                    │ length(bytes)   desc                                      ║\n', '         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\n', '         * ║ v                  │ 1               the v parameter of a signature            ║\n', '         * ║ signatureMethod    │ 1               SignatureMethod enum value                ║\n', '         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n', '         */\n', '        bytes32 config;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    /**\n', '     * Validate a signature given a hash calculated from the order data, the signer, and the\n', '     * signature data passed in with the order.\n', '     *\n', '     * This function will revert the transaction if the signature method is invalid.\n', '     *\n', '     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\n', '     * @param signerAddress The address of the signer\n', '     * @param signature The signature data passed along with the order to validate against\n', '     * @return True if the calculated signature matches the order signature data, false otherwise.\n', '     */\n', '    function isValidSignature(bytes32 hash, address signerAddress, OrderSignature memory signature)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint8 method = uint8(signature.config[1]);\n', '        address recovered;\n', '        uint8 v = uint8(signature.config[0]);\n', '\n', '        if (method == uint8(SignatureMethod.EthSign)) {\n', '            recovered = ecrecover(\n', '                keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),\n', '                v,\n', '                signature.r,\n', '                signature.s\n', '            );\n', '        } else if (method == uint8(SignatureMethod.EIP712)) {\n', '            recovered = ecrecover(hash, v, signature.r, signature.s);\n', '        } else {\n', '            revert("INVALID_SIGN_METHOD");\n', '        }\n', '\n', '        return signerAddress == recovered;\n', '    }\n', '}\n', '\n', 'contract LibMath {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\n', "     * do this, we check the remainder and make sure it's proportionally less than 0.1%. So we have:\n", '     *\n', '     *     ((numerator * multiple) % denominator)     1\n', '     *     -------------------------------------- < ----\n', '     *              numerator * multiple            1000\n', '     *\n', '     * To avoid further division, we can move the denominators to the other sides and we get:\n', '     *\n', '     *     ((numerator * multiple) % denominator) * 1000 < numerator * multiple\n', '     *\n', '     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\n', '     * final equation becomes:\n', '     *\n', '     *     ((numerator * multiple) % denominator) * 1000 >= numerator * multiple\n', '     *\n', '     * @param numerator The numerator of the proportion\n', '     * @param denominator The denominator of the proportion\n', '     * @param multiple The amount we want a proportion of\n', '     * @return Boolean indicating if there is a rounding error when calculating the proportion\n', '     */\n', '    function isRoundingError(uint256 numerator, uint256 denominator, uint256 multiple)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple);\n', '    }\n', '\n', '    /// @dev calculate "multiple * (numerator / denominator)", rounded down.\n', '    /// revert when there is a rounding error.\n', '    /**\n', '     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\n', '     * pair of values. The final value will be rounded down to the nearest integer value.\n', '     *\n', '     * This function will revert the transaction if rounding the final value down would lose more\n', '     * than 0.1% precision.\n', '     *\n', '     * @param numerator The numerator of the proportion\n', '     * @param denominator The denominator of the proportion\n', '     * @param multiple The amount we want a proportion of\n', '     * @return The final proportion of multiple rounded down\n', '     */\n', '    function getPartialAmountFloor(uint256 numerator, uint256 denominator, uint256 multiple)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(!isRoundingError(numerator, denominator, multiple), "ROUNDING_ERROR");\n', '        return numerator.mul(multiple).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Returns the smaller integer of the two passed in.\n', '     *\n', '     * @param a Unsigned integer\n', '     * @param b Unsigned integer\n', '     * @return The smaller of the two integers\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract LibOrder is EIP712, LibSignature, LibMath {\n', '\n', '    uint256 public constant REBATE_RATE_BASE = 100;\n', '\n', '    struct Order {\n', '        address trader;\n', '        address relayer;\n', '        address baseToken;\n', '        address quoteToken;\n', '        uint256 baseTokenAmount;\n', '        uint256 quoteTokenAmount;\n', '        uint256 gasTokenAmount;\n', '\n', '        /**\n', '         * Data contains the following values packed into 32 bytes\n', '         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n', '         * ║                    │ length(bytes)   desc                                      ║\n', '         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\n', '         * ║ version            │ 1               order version                             ║\n', '         * ║ side               │ 1               0: buy, 1: sell                           ║\n', '         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\n', '         * ║ expiredAt          │ 5               order expiration time in seconds          ║\n', '         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\n', '         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\n', '         * ║ makerRebateRate    │ 2               rebate rate for maker (base 100)          ║\n', '         * ║ salt               │ 8               salt                                      ║\n', '         * ║ isMakerOnly        │ 1               is maker only                             ║\n', '         * ║                    │ 9               reserved                                  ║\n', '         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n', '         */\n', '        bytes32 data;\n', '    }\n', '\n', '    enum OrderStatus {\n', '        EXPIRED,\n', '        CANCELLED,\n', '        FILLABLE,\n', '        FULLY_FILLED\n', '    }\n', '\n', '    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\n', '        abi.encodePacked(\n', '            "Order(address trader,address relayer,address baseToken,address quoteToken,uint256 baseTokenAmount,uint256 quoteTokenAmount,uint256 gasTokenAmount,bytes32 data)"\n', '        )\n', '    );\n', '\n', '    /**\n', '     * Calculates the Keccak-256 EIP712 hash of the order using the Hydro Protocol domain.\n', '     *\n', '     * @param order The order data struct.\n', '     * @return Fully qualified EIP712 hash of the order in the Hydro Protocol domain.\n', '     */\n', '    function getOrderHash(Order memory order) internal view returns (bytes32 orderHash) {\n', '        orderHash = hashEIP712Message(hashOrder(order));\n', '        return orderHash;\n', '    }\n', '\n', '    /**\n', '     * Calculates the EIP712 hash of the order.\n', '     *\n', '     * @param order The order data struct.\n', '     * @return Hash of the order.\n', '     */\n', '    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\n', '        /**\n', '         * Calculate the following hash in solidity assembly to save gas.\n', '         *\n', '         * keccak256(\n', '         *     abi.encodePacked(\n', '         *         EIP712_ORDER_TYPE,\n', '         *         bytes32(order.trader),\n', '         *         bytes32(order.relayer),\n', '         *         bytes32(order.baseToken),\n', '         *         bytes32(order.quoteToken),\n', '         *         order.baseTokenAmount,\n', '         *         order.quoteTokenAmount,\n', '         *         order.gasTokenAmount,\n', '         *         order.data\n', '         *     )\n', '         * );\n', '         */\n', '\n', '        bytes32 orderType = EIP712_ORDER_TYPE;\n', '\n', '        assembly {\n', '            let start := sub(order, 32)\n', '            let tmp := mload(start)\n', '\n', '            // 288 = (1 + 8) * 32\n', '            //\n', '            // [0...32)   bytes: EIP712_ORDER_TYPE\n', '            // [32...288) bytes: order\n', '            mstore(start, orderType)\n', '            result := keccak256(start, 288)\n', '\n', '            mstore(start, tmp)\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /* Functions to extract info from data bytes in Order struct */\n', '\n', '    function getOrderVersion(bytes32 data) internal pure returns (uint256) {\n', '        return uint256(byte(data));\n', '    }\n', '\n', '    function getExpiredAtFromOrderData(bytes32 data) internal pure returns (uint256) {\n', '        return uint256(bytes5(data << (8*3)));\n', '    }\n', '\n', '    function isSell(bytes32 data) internal pure returns (bool) {\n', '        return data[1] == 1;\n', '    }\n', '\n', '    function isMarketOrder(bytes32 data) internal pure returns (bool) {\n', '        return data[2] == 1;\n', '    }\n', '\n', '    function isMakerOnly(bytes32 data) internal pure returns (bool) {\n', '        return data[22] == 1;\n', '    }\n', '\n', '    function isMarketBuy(bytes32 data) internal pure returns (bool) {\n', '        return !isSell(data) && isMarketOrder(data);\n', '    }\n', '\n', '    function getAsMakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n', '        return uint256(bytes2(data << (8*8)));\n', '    }\n', '\n', '    function getAsTakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n', '        return uint256(bytes2(data << (8*10)));\n', '    }\n', '\n', '    function getMakerRebateRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n', '        uint256 makerRebate = uint256(bytes2(data << (8*12)));\n', '\n', '        // make sure makerRebate will never be larger than REBATE_RATE_BASE, which is 100\n', '        return min(makerRebate, REBATE_RATE_BASE);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title LibRelayer provides two distinct features for relayers.\n', ' *\n', ' * First, Relayers can opt into or out of the Hydro liquidity incentive system.\n', ' *\n', ' * Second, a relayer can register a delegate address.\n', ' * Delegates can send matching requests on behalf of relayers.\n', ' * The delegate scheme allows additional possibilities for smart contract interaction.\n', ' * on behalf of the relayer.\n', ' */\n', 'contract LibRelayer {\n', '\n', '    /**\n', '     * Mapping of relayerAddress => delegateAddress\n', '     */\n', '    mapping (address => mapping (address => bool)) public relayerDelegates;\n', '\n', '    /**\n', '     * Mapping of relayerAddress => whether relayer is opted out of the liquidity incentive system\n', '     */\n', '    mapping (address => bool) hasExited;\n', '\n', '    event RelayerApproveDelegate(address indexed relayer, address indexed delegate);\n', '    event RelayerRevokeDelegate(address indexed relayer, address indexed delegate);\n', '\n', '    event RelayerExit(address indexed relayer);\n', '    event RelayerJoin(address indexed relayer);\n', '\n', '    /**\n', '     * Approve an address to match orders on behalf of msg.sender\n', '     */\n', '    function approveDelegate(address delegate) external {\n', '        relayerDelegates[msg.sender][delegate] = true;\n', '        emit RelayerApproveDelegate(msg.sender, delegate);\n', '    }\n', '\n', '    /**\n', '     * Revoke an existing delegate\n', '     */\n', '    function revokeDelegate(address delegate) external {\n', '        relayerDelegates[msg.sender][delegate] = false;\n', '        emit RelayerRevokeDelegate(msg.sender, delegate);\n', '    }\n', '\n', '    /**\n', '     * @return true if msg.sender is allowed to match orders which belong to relayer\n', '     */\n', '    function canMatchOrdersFrom(address relayer) public view returns(bool) {\n', '        return msg.sender == relayer || relayerDelegates[relayer][msg.sender] == true;\n', '    }\n', '\n', '    /**\n', '     * Join the Hydro incentive system.\n', '     */\n', '    function joinIncentiveSystem() external {\n', '        delete hasExited[msg.sender];\n', '        emit RelayerJoin(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Exit the Hydro incentive system.\n', '     * For relayers that choose to opt-out, the Hydro Protocol\n', '     * effective becomes a tokenless protocol.\n', '     */\n', '    function exitIncentiveSystem() external {\n', '        hasExited[msg.sender] = true;\n', '        emit RelayerExit(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @return true if relayer is participating in the Hydro incentive system.\n', '     */\n', '    function isParticipant(address relayer) public view returns(bool) {\n', '        return !hasExited[relayer];\n', '    }\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization control\n', '/// functions, this simplifies the implementation of "user permissions".\n', 'contract LibOwnable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /// @return the address of the owner.\n', '    function owner() public view returns(address) {\n', '        return _owner;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    /// @return true if `msg.sender` is the owner of the contract.\n', '    function isOwner() public view returns(bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /// @dev Allows the current owner to relinquish control of the contract.\n', '    /// @notice Renouncing to ownership will leave the contract without an owner.\n', '    /// It will not be possible to call the functions with the `onlyOwner`\n', '    /// modifier anymore.\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "INVALID_OWNER");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Library to handle fee discount calculation\n', ' */\n', 'contract LibDiscount is LibOwnable {\n', '    using SafeMath for uint256;\n', '\n', '    // The base discounted rate is 100% of the current rate, or no discount.\n', '    uint256 public constant DISCOUNT_RATE_BASE = 100;\n', '\n', '    address public hotTokenAddress;\n', '\n', '    constructor(address _hotTokenAddress) internal {\n', '        hotTokenAddress = _hotTokenAddress;\n', '    }\n', '\n', '    /**\n', '     * Get the HOT token balance of an address.\n', '     *\n', '     * @param owner The address to check.\n', '     * @return The HOT balance for the owner address.\n', '     */\n', '    function getHotBalance(address owner) internal view returns (uint256 result) {\n', '        address hotToken = hotTokenAddress;\n', '\n', '        // IERC20(hotTokenAddress).balanceOf(owner)\n', '\n', '        /**\n', '         * We construct calldata for the `balanceOf` ABI.\n', '         * The layout of this calldata is in the table below.\n', '         *\n', '         * ╔════════╤════════╤════════╤═══════════════════╗\n', '         * ║ Area   │ Offset │ Length │ Contents          ║\n', '         * ╟────────┼────────┼────────┼───────────────────╢\n', '         * ║ Header │ 0      │ 4      │ function selector ║\n', '         * ║ Params │ 4      │ 32     │ owner address     ║\n', '         * ╚════════╧════════╧════════╧═══════════════════╝\n', '         */\n', '        assembly {\n', '            // Keep these so we can restore stack memory upon completion\n', '            let tmp1 := mload(0)\n', '            let tmp2 := mload(4)\n', '\n', "            // keccak256('balanceOf(address)') bitmasked to 4 bytes\n", '            mstore(0, 0x70a0823100000000000000000000000000000000000000000000000000000000)\n', '            mstore(4, owner)\n', '\n', '            // No need to check the return value because hotToken is a trustworthy contract\n', '            result := call(\n', '                gas,      // Forward all gas\n', '                hotToken, // HOT token deployment address\n', "                0,        // Don't send any ETH\n", '                0,        // Pointer to start of calldata\n', '                36,       // Length of calldata\n', '                0,        // Overwrite calldata with output\n', '                32        // Expecting uint256 output, the token balance\n', '            )\n', '            result := mload(0)\n', '\n', '            // Restore stack memory\n', '            mstore(0, tmp1)\n', '            mstore(4, tmp2)\n', '        }\n', '    }\n', '\n', '    bytes32 public discountConfig = 0x043c000027106400004e205a000075305000009c404600000000000000000000;\n', '\n', '    /**\n', '     * Calculate and return the rate at which fees will be charged for an address. The discounted\n', '     * rate depends on how much HOT token is owned by the user. Values returned will be a percentage\n', '     * used to calculate how much of the fee is paid, so a return value of 100 means there is 0\n', '     * discount, and a return value of 70 means a 30% rate reduction.\n', '     *\n', '     * The discountConfig is defined as such:\n', '     * ╔═══════════════════╤════════════════════════════════════════════╗\n', '     * ║                   │ length(bytes)   desc                       ║\n', '     * ╟───────────────────┼────────────────────────────────────────────╢\n', '     * ║ count             │ 1               the count of configs       ║\n', '     * ║ maxDiscountedRate │ 1               the max discounted rate    ║\n', '     * ║ config            │ 5 each                                     ║\n', '     * ╚═══════════════════╧════════════════════════════════════════════╝\n', '     *\n', '     * The default discount structure as defined in code would give the following result:\n', '     *\n', '     * Fee discount table\n', '     * ╔════════════════════╤══════════╗\n', '     * ║     HOT BALANCE    │ DISCOUNT ║\n', '     * ╠════════════════════╪══════════╣\n', '     * ║     0 <= x < 10000 │     0%   ║\n', '     * ╟────────────────────┼──────────╢\n', '     * ║ 10000 <= x < 20000 │    10%   ║\n', '     * ╟────────────────────┼──────────╢\n', '     * ║ 20000 <= x < 30000 │    20%   ║\n', '     * ╟────────────────────┼──────────╢\n', '     * ║ 30000 <= x < 40000 │    30%   ║\n', '     * ╟────────────────────┼──────────╢\n', '     * ║ 40000 <= x         │    40%   ║\n', '     * ╚════════════════════╧══════════╝\n', '     *\n', '     * Breaking down the bytes of 0x043c000027106400004e205a000075305000009c404600000000000000000000\n', '     *\n', '     * 0x  04           3c          0000271064  00004e205a  0000753050  00009c4046  0000000000  0000000000;\n', '     *     ~~           ~~          ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~\n', '     *      |            |               |           |           |           |           |           |\n', '     *    count  maxDiscountedRate       1           2           3           4           5           6\n', '     *\n', '     * The first config breaks down as follows:  00002710   64\n', '     *                                           ~~~~~~~~   ~~\n', '     *                                               |      |\n', '     *                                              bar    rate\n', '     *\n', '     * Meaning if a user has less than 10000 (0x00002710) HOT, they will pay 100%(0x64) of the\n', '     * standard fee.\n', '     *\n', '     * @param user The user address to calculate a fee discount for.\n', '     * @return The percentage of the regular fee this user will pay.\n', '     */\n', '    function getDiscountedRate(address user) public view returns (uint256 result) {\n', '        uint256 hotBalance = getHotBalance(user);\n', '\n', '        if (hotBalance == 0) {\n', '            return DISCOUNT_RATE_BASE;\n', '        }\n', '\n', '        bytes32 config = discountConfig;\n', '        uint256 count = uint256(byte(config));\n', '        uint256 bar;\n', '\n', '        // HOT Token has 18 decimals\n', '        hotBalance = hotBalance.div(10**18);\n', '\n', '        for (uint256 i = 0; i < count; i++) {\n', '            bar = uint256(bytes4(config << (2 + i * 5) * 8));\n', '\n', '            if (hotBalance < bar) {\n', '                result = uint256(byte(config << (2 + i * 5 + 4) * 8));\n', '                break;\n', '            }\n', '        }\n', '\n', "        // If we haven't found a rate in the config yet, use the maximum rate.\n", '        if (result == 0) {\n', '            result = uint256(config[1]);\n', '        }\n', '\n', '        // Make sure our discount algorithm never returns a higher rate than the base.\n', '        require(result <= DISCOUNT_RATE_BASE, "DISCOUNT_ERROR");\n', '    }\n', '\n', '    /**\n', '     * Owner can modify discount configuration.\n', '     *\n', '     * @param newConfig A data blob representing the new discount config. Details on format above.\n', '     */\n', '    function changeDiscountConfig(bytes32 newConfig) external onlyOwner {\n', '        discountConfig = newConfig;\n', '    }\n', '}\n', '\n', 'contract LibExchangeErrors {\n', '    string constant INVALID_TRADER = "INVALID_TRADER";\n', '    string constant INVALID_SENDER = "INVALID_SENDER";\n', "    // Taker order and maker order can't be matched\n", '    string constant INVALID_MATCH = "INVALID_MATCH";\n', '    string constant INVALID_SIDE = "INVALID_SIDE";\n', '    // Signature validation failed\n', '    string constant INVALID_ORDER_SIGNATURE = "INVALID_ORDER_SIGNATURE";\n', '    // Taker order is not valid\n', '    string constant ORDER_IS_NOT_FILLABLE = "ORDER_IS_NOT_FILLABLE";\n', '    string constant MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER = "MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER";\n', '    string constant TRANSFER_FROM_FAILED = "TRANSFER_FROM_FAILED";\n', '    string constant MAKER_ORDER_OVER_MATCH = "MAKER_ORDER_OVER_MATCH";\n', '    string constant TAKER_ORDER_OVER_MATCH = "TAKER_ORDER_OVER_MATCH";\n', '    string constant ORDER_VERSION_NOT_SUPPORTED = "ORDER_VERSION_NOT_SUPPORTED";\n', '\n', '    string constant MAKER_ONLY_ORDER_CANNOT_BE_TAKER = "MAKER_ONLY_ORDER_CANNOT_BE_TAKER";\n', '}\n', '\n', 'contract HybridExchange is LibMath, LibOrder, LibRelayer, LibDiscount, LibExchangeErrors {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant FEE_RATE_BASE = 100000;\n', '\n', '    /* Order v2 data is uncompatible with v1. This contract can only handle v2 order. */\n', '    uint256 public constant SUPPORTED_ORDER_VERSION = 2;\n', '\n', '    /**\n', '     * Address of the proxy responsible for asset transfer.\n', '     */\n', '    address public proxyAddress;\n', '\n', '    /**\n', '     * Mapping of orderHash => amount\n', '     * Generally the amount will be specified in base token units, however in the case of a market\n', '     * buy order the amount is specified in quote token units.\n', '     */\n', '    mapping (bytes32 => uint256) public filled;\n', '    /**\n', '     * Mapping of orderHash => whether order has been cancelled.\n', '     */\n', '    mapping (bytes32 => bool) public cancelled;\n', '\n', '    event Cancel(bytes32 indexed orderHash);\n', '\n', '    /**\n', '     * When orders are being matched, they will always contain the exact same base token,\n', '     * quote token, and relayer. Since excessive call data is very expensive, we choose\n', '     * to create a stripped down OrderParam struct containing only data that may vary between\n', '     * Order objects, and separate out the common elements into a set of addresses that will\n', '     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\n', "     * the call data, reducing it's size, and hence saving gas.\n", '     */\n', '    struct OrderParam {\n', '        address trader;\n', '        uint256 baseTokenAmount;\n', '        uint256 quoteTokenAmount;\n', '        uint256 gasTokenAmount;\n', '        bytes32 data;\n', '        OrderSignature signature;\n', '    }\n', '\n', '    /**\n', '     * Calculated data about an order object.\n', '     * Generally the filledAmount is specified in base token units, however in the case of a market\n', '     * buy order the filledAmount is specified in quote token units.\n', '     */\n', '    struct OrderInfo {\n', '        bytes32 orderHash;\n', '        uint256 filledAmount;\n', '    }\n', '\n', '    struct OrderAddressSet {\n', '        address baseToken;\n', '        address quoteToken;\n', '        address relayer;\n', '    }\n', '\n', '    struct MatchResult {\n', '        address maker;\n', '        address taker;\n', '        address buyer;\n', '        uint256 makerFee;\n', '        uint256 makerRebate;\n', '        uint256 takerFee;\n', '        uint256 makerGasFee;\n', '        uint256 takerGasFee;\n', '        uint256 baseTokenFilledAmount;\n', '        uint256 quoteTokenFilledAmount;\n', '    }\n', '\n', '\n', '    event Match(\n', '        OrderAddressSet addressSet,\n', '        MatchResult result\n', '    );\n', '\n', '    constructor(address _proxyAddress, address hotTokenAddress)\n', '        LibDiscount(hotTokenAddress)\n', '        public\n', '    {\n', '        proxyAddress = _proxyAddress;\n', '    }\n', '\n', '    /**\n', '     * Match taker order to a list of maker orders. Common addresses are passed in\n', '     * separately as an OrderAddressSet to reduce call size data and save gas.\n', '     *\n', '     * @param takerOrderParam A OrderParam object representing the order from the taker.\n', '     * @param makerOrderParams An array of OrderParam objects representing orders from a list of makers.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     */\n', '    function matchOrders(\n', '        OrderParam memory takerOrderParam,\n', '        OrderParam[] memory makerOrderParams,\n', '        uint256[] memory baseTokenFilledAmounts,\n', '        OrderAddressSet memory orderAddressSet\n', '    ) public {\n', '        require(canMatchOrdersFrom(orderAddressSet.relayer), INVALID_SENDER);\n', '        require(!isMakerOnly(takerOrderParam.data), MAKER_ONLY_ORDER_CANNOT_BE_TAKER);\n', '\n', '        bool isParticipantRelayer = isParticipant(orderAddressSet.relayer);\n', '        uint256 takerFeeRate = getTakerFeeRate(takerOrderParam, isParticipantRelayer);\n', '        OrderInfo memory takerOrderInfo = getOrderInfo(takerOrderParam, orderAddressSet);\n', '\n', '        // Calculate which orders match for settlement.\n', '        MatchResult[] memory results = new MatchResult[](makerOrderParams.length);\n', '\n', '        for (uint256 i = 0; i < makerOrderParams.length; i++) {\n', '            require(!isMarketOrder(makerOrderParams[i].data), MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER);\n', '            require(isSell(takerOrderParam.data) != isSell(makerOrderParams[i].data), INVALID_SIDE);\n', '            validatePrice(takerOrderParam, makerOrderParams[i]);\n', '\n', '            OrderInfo memory makerOrderInfo = getOrderInfo(makerOrderParams[i], orderAddressSet);\n', '\n', '            results[i] = getMatchResult(\n', '                takerOrderParam,\n', '                takerOrderInfo,\n', '                makerOrderParams[i],\n', '                makerOrderInfo,\n', '                baseTokenFilledAmounts[i],\n', '                takerFeeRate,\n', '                isParticipantRelayer\n', '            );\n', '\n', '            // Update amount filled for this maker order.\n', '            filled[makerOrderInfo.orderHash] = makerOrderInfo.filledAmount;\n', '        }\n', '\n', '        // Update amount filled for this taker order.\n', '        filled[takerOrderInfo.orderHash] = takerOrderInfo.filledAmount;\n', '\n', '        settleResults(results, takerOrderParam, orderAddressSet);\n', '    }\n', '\n', '    /**\n', '     * Cancels an order, preventing it from being matched. In practice, matching mode relayers will\n', '     * generally handle cancellation off chain by removing the order from their system, however if\n', '     * the trader wants to ensure the order never goes through, or they no longer trust the relayer,\n', '     * this function may be called to block it from ever matching at the contract level.\n', '     *\n', '     * Emits a Cancel event on success.\n', '     *\n', '     * @param order The order to be cancelled.\n', '     */\n', '    function cancelOrder(Order memory order) public {\n', '        require(order.trader == msg.sender, INVALID_TRADER);\n', '\n', '        bytes32 orderHash = getOrderHash(order);\n', '        cancelled[orderHash] = true;\n', '\n', '        emit Cancel(orderHash);\n', '    }\n', '\n', '    /**\n', '     * Calculates current state of the order. Will revert transaction if this order is not\n', '     * fillable for any reason, or if the order signature is invalid.\n', '     *\n', '     * @param orderParam The OrderParam object containing Order data.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     * @return An OrderInfo object containing the hash and current amount filled\n', '     */\n', '    function getOrderInfo(OrderParam memory orderParam, OrderAddressSet memory orderAddressSet)\n', '        internal\n', '        view\n', '        returns (OrderInfo memory orderInfo)\n', '    {\n', '        require(getOrderVersion(orderParam.data) == SUPPORTED_ORDER_VERSION, ORDER_VERSION_NOT_SUPPORTED);\n', '\n', '        Order memory order = getOrderFromOrderParam(orderParam, orderAddressSet);\n', '        orderInfo.orderHash = getOrderHash(order);\n', '        orderInfo.filledAmount = filled[orderInfo.orderHash];\n', '        uint8 status = uint8(OrderStatus.FILLABLE);\n', '\n', '        if (!isMarketBuy(order.data) && orderInfo.filledAmount >= order.baseTokenAmount) {\n', '            status = uint8(OrderStatus.FULLY_FILLED);\n', '        } else if (isMarketBuy(order.data) && orderInfo.filledAmount >= order.quoteTokenAmount) {\n', '            status = uint8(OrderStatus.FULLY_FILLED);\n', '        } else if (block.timestamp >= getExpiredAtFromOrderData(order.data)) {\n', '            status = uint8(OrderStatus.EXPIRED);\n', '        } else if (cancelled[orderInfo.orderHash]) {\n', '            status = uint8(OrderStatus.CANCELLED);\n', '        }\n', '\n', '        require(status == uint8(OrderStatus.FILLABLE), ORDER_IS_NOT_FILLABLE);\n', '        require(\n', '            isValidSignature(orderInfo.orderHash, orderParam.trader, orderParam.signature),\n', '            INVALID_ORDER_SIGNATURE\n', '        );\n', '\n', '        return orderInfo;\n', '    }\n', '\n', '    /**\n', '     * Reconstruct an Order object from the given OrderParam and OrderAddressSet objects.\n', '     *\n', '     * @param orderParam The OrderParam object containing the Order data.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     * @return The reconstructed Order object.\n', '     */\n', '    function getOrderFromOrderParam(OrderParam memory orderParam, OrderAddressSet memory orderAddressSet)\n', '        internal\n', '        pure\n', '        returns (Order memory order)\n', '    {\n', '        order.trader = orderParam.trader;\n', '        order.baseTokenAmount = orderParam.baseTokenAmount;\n', '        order.quoteTokenAmount = orderParam.quoteTokenAmount;\n', '        order.gasTokenAmount = orderParam.gasTokenAmount;\n', '        order.data = orderParam.data;\n', '        order.baseToken = orderAddressSet.baseToken;\n', '        order.quoteToken = orderAddressSet.quoteToken;\n', '        order.relayer = orderAddressSet.relayer;\n', '    }\n', '\n', '    /**\n', '     * Validates that the maker and taker orders can be matched based on the listed prices.\n', '     *\n', '     * If the taker submitted a sell order, the matching maker order must have a price greater than\n', '     * or equal to the price the taker is willing to sell for.\n', '     *\n', '     * Since the price of an order is computed by order.quoteTokenAmount / order.baseTokenAmount\n', '     * we can establish the following formula:\n', '     *\n', '     *    takerOrder.quoteTokenAmount        makerOrder.quoteTokenAmount\n', '     *   -----------------------------  <=  -----------------------------\n', '     *     takerOrder.baseTokenAmount        makerOrder.baseTokenAmount\n', '     *\n', '     * To avoid precision loss from division, we modify the formula to avoid division entirely.\n', '     * In shorthand, this becomes:\n', '     *\n', '     *   takerOrder.quote * makerOrder.base <= takerOrder.base * makerOrder.quote\n', '     *\n', '     * We can apply this same process to buy orders - if the taker submitted a buy order then\n', '     * the matching maker order must have a price less than or equal to the price the taker is\n', '     * willing to pay. This means we can use the same result as above, but simply flip the\n', '     * sign of the comparison operator.\n', '     *\n', '     * The function will revert the transaction if the orders cannot be matched.\n', '     *\n', "     * @param takerOrderParam The OrderParam object representing the taker's order data\n", "     * @param makerOrderParam The OrderParam object representing the maker's order data\n", '     */\n', '    function validatePrice(OrderParam memory takerOrderParam, OrderParam memory makerOrderParam)\n', '        internal\n', '        pure\n', '    {\n', '        uint256 left = takerOrderParam.quoteTokenAmount.mul(makerOrderParam.baseTokenAmount);\n', '        uint256 right = takerOrderParam.baseTokenAmount.mul(makerOrderParam.quoteTokenAmount);\n', '        require(isSell(takerOrderParam.data) ? left <= right : left >= right, INVALID_MATCH);\n', '    }\n', '\n', '    /**\n', '     * Construct a MatchResult from matching taker and maker order data, which will be used when\n', '     * settling the orders and transferring token.\n', '     *\n', "     * @param takerOrderParam The OrderParam object representing the taker's order data\n", '     * @param takerOrderInfo The OrderInfo object representing the current taker order state\n', "     * @param makerOrderParam The OrderParam object representing the maker's order data\n", '     * @param makerOrderInfo The OrderInfo object representing the current maker order state\n', '     * @param takerFeeRate The rate used to calculate the fee charged to the taker\n', '     * @param isParticipantRelayer Whether this relayer is participating in hot discount\n', '     * @return MatchResult object containing data that will be used during order settlement.\n', '     */\n', '    function getMatchResult(\n', '        OrderParam memory takerOrderParam,\n', '        OrderInfo memory takerOrderInfo,\n', '        OrderParam memory makerOrderParam,\n', '        OrderInfo memory makerOrderInfo,\n', '        uint256 baseTokenFilledAmount,\n', '        uint256 takerFeeRate,\n', '        bool isParticipantRelayer\n', '    )\n', '        internal\n', '        view\n', '        returns (MatchResult memory result)\n', '    {\n', '        result.baseTokenFilledAmount = baseTokenFilledAmount;\n', '        result.quoteTokenFilledAmount = convertBaseToQuote(makerOrderParam, baseTokenFilledAmount);\n', '\n', '        // Each order only pays gas once, so only pay gas when nothing has been filled yet.\n', '        if (takerOrderInfo.filledAmount == 0) {\n', '            result.takerGasFee = takerOrderParam.gasTokenAmount;\n', '        }\n', '\n', '        if (makerOrderInfo.filledAmount == 0) {\n', '            result.makerGasFee = makerOrderParam.gasTokenAmount;\n', '        }\n', '\n', '        if(!isMarketBuy(takerOrderParam.data)) {\n', '            takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(result.baseTokenFilledAmount);\n', '            require(takerOrderInfo.filledAmount <= takerOrderParam.baseTokenAmount, TAKER_ORDER_OVER_MATCH);\n', '        } else {\n', '            takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(result.quoteTokenFilledAmount);\n', '            require(takerOrderInfo.filledAmount <= takerOrderParam.quoteTokenAmount, TAKER_ORDER_OVER_MATCH);\n', '        }\n', '\n', '        makerOrderInfo.filledAmount = makerOrderInfo.filledAmount.add(result.baseTokenFilledAmount);\n', '        require(makerOrderInfo.filledAmount <= makerOrderParam.baseTokenAmount, MAKER_ORDER_OVER_MATCH);\n', '\n', '        result.maker = makerOrderParam.trader;\n', '        result.taker = takerOrderParam.trader;\n', '\n', '        if(isSell(takerOrderParam.data)) {\n', '            result.buyer = result.maker;\n', '        } else {\n', '            result.buyer = result.taker;\n', '        }\n', '\n', '        uint256 rebateRate = getMakerRebateRateFromOrderData(makerOrderParam.data);\n', '\n', '        if (rebateRate > 0) {\n', '            // If the rebate rate is not zero, maker pays no fees.\n', '            result.makerFee = 0;\n', '\n', '            // RebateRate will never exceed REBATE_RATE_BASE, so rebateFee will never exceed the fees paid by the taker.\n', '            result.makerRebate = result.quoteTokenFilledAmount.mul(takerFeeRate).mul(rebateRate).div(\n', '                FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE).mul(REBATE_RATE_BASE)\n', '            );\n', '        } else {\n', '            uint256 makerRawFeeRate = getAsMakerFeeRateFromOrderData(makerOrderParam.data);\n', '            result.makerRebate = 0;\n', '\n', '            // maker fee will be reduced, but still >= 0\n', '            uint256 makerFeeRate = getFinalFeeRate(\n', '                makerOrderParam.trader,\n', '                makerRawFeeRate,\n', '                isParticipantRelayer\n', '            );\n', '\n', '            result.makerFee = result.quoteTokenFilledAmount.mul(makerFeeRate).div(\n', '                FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE)\n', '            );\n', '        }\n', '\n', '        result.takerFee = result.quoteTokenFilledAmount.mul(takerFeeRate).div(\n', '            FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the rate used to calculate the taker fee.\n', '     *\n', '     * @param orderParam The OrderParam object representing the taker order data.\n', '     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\n', '     * @return The final potentially discounted rate to use for the taker fee.\n', '     */\n', '    function getTakerFeeRate(OrderParam memory orderParam, bool isParticipantRelayer)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 rawRate = getAsTakerFeeRateFromOrderData(orderParam.data);\n', '        return getFinalFeeRate(orderParam.trader, rawRate, isParticipantRelayer);\n', '    }\n', '\n', '    /**\n', '     * Take a fee rate and calculate the potentially discounted rate for this trader based on\n', '     * HOT token ownership.\n', '     *\n', '     * @param trader The address of the trader who made the order.\n', '     * @param rate The raw rate which we will discount if needed.\n', '     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\n', '     * @return The final potentially discounted rate.\n', '     */\n', '    function getFinalFeeRate(address trader, uint256 rate, bool isParticipantRelayer)\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if (isParticipantRelayer) {\n', '            return rate.mul(getDiscountedRate(trader));\n', '        } else {\n', '            return rate.mul(DISCOUNT_RATE_BASE);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Take an amount and convert it from base token units to quote token units based on the price\n', '     * in the order param.\n', '     *\n', '     * @param orderParam The OrderParam object containing the Order data.\n', '     * @param amount An amount of base token.\n', '     * @return The converted amount in quote token units.\n', '     */\n', '    function convertBaseToQuote(OrderParam memory orderParam, uint256 amount)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return getPartialAmountFloor(\n', '            orderParam.quoteTokenAmount,\n', '            orderParam.baseTokenAmount,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Take an amount and convert it from quote token units to base token units based on the price\n', '     * in the order param.\n', '     *\n', '     * @param orderParam The OrderParam object containing the Order data.\n', '     * @param amount An amount of quote token.\n', '     * @return The converted amount in base token units.\n', '     */\n', '    function convertQuoteToBase(OrderParam memory orderParam, uint256 amount)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return getPartialAmountFloor(\n', '            orderParam.baseTokenAmount,\n', '            orderParam.quoteTokenAmount,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Take a list of matches and settle them with the taker order, transferring tokens all tokens\n', '     * and paying all fees necessary to complete the transaction.\n', '     *\n', '     * @param results List of MatchResult objects representing each individual trade to settle.\n', '     * @param takerOrderParam The OrderParam object representing the taker order data.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     */\n', '    function settleResults(\n', '        MatchResult[] memory results,\n', '        OrderParam memory takerOrderParam,\n', '        OrderAddressSet memory orderAddressSet\n', '    )\n', '        internal\n', '    {\n', '        if (isSell(takerOrderParam.data)) {\n', '            settleTakerSell(results, orderAddressSet);\n', '        } else {\n', '            settleTakerBuy(results, orderAddressSet);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Settles a sell order given a list of MatchResult objects. A naive approach would be to take\n', '     * each result, have the taker and maker transfer the appropriate tokens, and then have them\n', '     * each send the appropriate fees to the relayer, meaning that for n makers there would be 4n\n', '     * transactions. Additionally the taker would have to have an allowance set for the quote token\n', '     * in order to pay the fees to the relayer.\n', '     *\n', '     * Instead we do the following:\n', '     *  - Taker transfers the required base token to each maker\n', '     *  - Each maker sends an amount of quote token to the relayer equal to:\n', '     *    [Amount owed to taker] + [Maker fee] + [Maker gas cost] - [Maker rebate amount]\n', '     *  - The relayer will then take all of this quote token and in a single batch transaction\n', '     *    send the appropriate amount to the taker, equal to:\n', '     *    [Total amount owed to taker] - [All taker fees] - [All taker gas costs]\n', '     *\n', '     * Thus in the end the taker will have the full amount of quote token, sans the fee and cost of\n', '     * their share of gas. Each maker will have their share of base token, sans the fee and cost of\n', '     * their share of gas, and will keep their rebate in quote token. The relayer will end up with\n', '     * the fees from the taker and each maker (sans rebate), and the gas costs will pay for the\n', '     * transactions. In this scenario, with n makers there will be 2n + 1 transactions, which will\n', '     * be a significant gas savings over the original method.\n', '     *\n', '     * @param results A list of MatchResult objects representing each individual trade to settle.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     */\n', '    function settleTakerSell(MatchResult[] memory results, OrderAddressSet memory orderAddressSet) internal {\n', '        uint256 totalTakerQuoteTokenFilledAmount = 0;\n', '\n', '        for (uint256 i = 0; i < results.length; i++) {\n', '            transferFrom(\n', '                orderAddressSet.baseToken,\n', '                results[i].taker,\n', '                results[i].maker,\n', '                results[i].baseTokenFilledAmount\n', '            );\n', '\n', '            transferFrom(\n', '                orderAddressSet.quoteToken,\n', '                results[i].maker,\n', '                orderAddressSet.relayer,\n', '                results[i].quoteTokenFilledAmount.\n', '                    add(results[i].makerFee).\n', '                    add(results[i].makerGasFee).\n', '                    sub(results[i].makerRebate)\n', '            );\n', '\n', '            totalTakerQuoteTokenFilledAmount = totalTakerQuoteTokenFilledAmount.add(\n', '                results[i].quoteTokenFilledAmount.sub(results[i].takerFee)\n', '            );\n', '\n', '            emitMatchEvent(results[i], orderAddressSet);\n', '        }\n', '\n', '        transferFrom(\n', '            orderAddressSet.quoteToken,\n', '            orderAddressSet.relayer,\n', '            results[0].taker,\n', '            totalTakerQuoteTokenFilledAmount.sub(results[0].takerGasFee)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Settles a buy order given a list of MatchResult objects. A naive approach would be to take\n', '     * each result, have the taker and maker transfer the appropriate tokens, and then have them\n', '     * each send the appropriate fees to the relayer, meaning that for n makers there would be 4n\n', '     * transactions. Additionally each maker would have to have an allowance set for the quote token\n', '     * in order to pay the fees to the relayer.\n', '     *\n', '     * Instead we do the following:\n', '     *  - Each maker transfers base tokens to the taker\n', '     *  - The taker sends an amount of quote tokens to each maker equal to:\n', '     *    [Amount owed to maker] + [Maker rebate amount] - [Maker fee] - [Maker gas cost]\n', '     *  - Since the taker saved all the maker fees and gas costs, it can then send them as a single\n', '     *    batch transaction to the relayer, equal to:\n', '     *    [All maker and taker fees] + [All maker and taker gas costs] - [All maker rebates]\n', '     *\n', '     * Thus in the end the taker will have the full amount of base token, sans the fee and cost of\n', '     * their share of gas. Each maker will have their share of quote token, including their rebate,\n', '     * but sans the fee and cost of their share of gas. The relayer will end up with the fees from\n', '     * the taker and each maker (sans rebates), and the gas costs will pay for the transactions. In\n', '     * this scenario, with n makers there will be 2n + 1 transactions, which will be a significant\n', '     * gas savings over the original method.\n', '     *\n', '     * @param results A list of MatchResult objects representing each individual trade to settle.\n', '     * @param orderAddressSet An object containing addresses common across each order.\n', '     */\n', '    function settleTakerBuy(MatchResult[] memory results, OrderAddressSet memory orderAddressSet) internal {\n', '        uint256 totalFee = 0;\n', '\n', '        for (uint256 i = 0; i < results.length; i++) {\n', '            transferFrom(\n', '                orderAddressSet.baseToken,\n', '                results[i].maker,\n', '                results[i].taker,\n', '                results[i].baseTokenFilledAmount\n', '            );\n', '\n', '            transferFrom(\n', '                orderAddressSet.quoteToken,\n', '                results[i].taker,\n', '                results[i].maker,\n', '                results[i].quoteTokenFilledAmount.\n', '                    sub(results[i].makerFee).\n', '                    sub(results[i].makerGasFee).\n', '                    add(results[i].makerRebate)\n', '            );\n', '\n', '            totalFee = totalFee.\n', '                add(results[i].takerFee).\n', '                add(results[i].makerFee).\n', '                add(results[i].makerGasFee).\n', '                add(results[i].takerGasFee).\n', '                sub(results[i].makerRebate);\n', '\n', '            emitMatchEvent(results[i], orderAddressSet);\n', '        }\n', '\n', '        transferFrom(\n', '            orderAddressSet.quoteToken,\n', '            results[0].taker,\n', '            orderAddressSet.relayer,\n', '            totalFee\n', '        );\n', '    }\n', '\n', '    /**\n', '     * A helper function to call the transferFrom function in Proxy.sol with solidity assembly.\n', '     * Copying the data in order to make an external call can be expensive, but performing the\n', '     * operations in assembly seems to reduce gas cost.\n', '     *\n', '     * The function will revert the transaction if the transfer fails.\n', '     *\n', '     * @param token The address of the ERC20 token we will be transferring, 0 for ETH.\n', '     * @param from The address we will be transferring from.\n', '     * @param to The address we will be transferring to.\n', '     * @param value The amount of token we will be transferring.\n', '     */\n', '    function transferFrom(address token, address from, address to, uint256 value) internal {\n', '        if (value == 0) {\n', '            return;\n', '        }\n', '\n', '        address proxy = proxyAddress;\n', '        uint256 result;\n', '\n', '        /**\n', '         * We construct calldata for the `Proxy.transferFrom` ABI.\n', '         * The layout of this calldata is in the table below.\n', '         *\n', '         * ╔════════╤════════╤════════╤═══════════════════╗\n', '         * ║ Area   │ Offset │ Length │ Contents          ║\n', '         * ╟────────┼────────┼────────┼───────────────────╢\n', '         * ║ Header │ 0      │ 4      │ function selector ║\n', '         * ║ Params │ 4      │ 32     │ token address     ║\n', '         * ║        │ 36     │ 32     │ from address      ║\n', '         * ║        │ 68     │ 32     │ to address        ║\n', '         * ║        │ 100    │ 32     │ amount of token   ║\n', '         * ╚════════╧════════╧════════╧═══════════════════╝\n', '         */\n', '        assembly {\n', '            // Keep these so we can restore stack memory upon completion\n', '            let tmp1 := mload(0)\n', '            let tmp2 := mload(4)\n', '            let tmp3 := mload(36)\n', '            let tmp4 := mload(68)\n', '            let tmp5 := mload(100)\n', '\n', "            // keccak256('transferFrom(address,address,address,uint256)') bitmasked to 4 bytes\n", '            mstore(0, 0x15dacbea00000000000000000000000000000000000000000000000000000000)\n', '            mstore(4, token)\n', '            mstore(36, from)\n', '            mstore(68, to)\n', '            mstore(100, value)\n', '\n', '            // Call Proxy contract transferFrom function using constructed calldata\n', '            result := call(\n', '                gas,   // Forward all gas\n', '                proxy, // Proxy.sol deployment address\n', "                0,     // Don't send any ETH\n", '                0,     // Pointer to start of calldata\n', '                132,   // Length of calldata\n', '                0,     // Output location\n', "                0      // We don't expect any output\n", '            )\n', '\n', '            // Restore stack memory\n', '            mstore(0, tmp1)\n', '            mstore(4, tmp2)\n', '            mstore(36, tmp3)\n', '            mstore(68, tmp4)\n', '            mstore(100, tmp5)\n', '        }\n', '\n', '        if (result == 0) {\n', '            revert(TRANSFER_FROM_FAILED);\n', '        }\n', '    }\n', '\n', '    function emitMatchEvent(MatchResult memory result, OrderAddressSet memory orderAddressSet) internal {\n', '        emit Match(\n', '            orderAddressSet, result\n', '        );\n', '    }\n', '}']