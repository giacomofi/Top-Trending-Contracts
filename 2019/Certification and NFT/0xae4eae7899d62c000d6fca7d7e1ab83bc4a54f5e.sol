['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', 'contract ERC1404 is ERC20 {\n', '    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n', '    /// @param from Sending address\n', '    /// @param to Receiving address\n', '    /// @param value Amount of tokens being transferred\n', '    /// @return Code by which to reference message for rejection reasoning\n', '    /// @dev Overwrite with your custom transfer restriction logic\n', '    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);\n', '\n', '    /// @notice Returns a human-readable message for a given restriction code\n', '    /// @param restrictionCode Identifier for looking up a message\n', '    /// @return Text showing the restriction&#39;s reasoning\n', '    /// @dev Overwrite with your custom message and restrictionCode handling\n', '    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/// @notice Standard interface for `RegulatorService`s\n', 'contract RegulatorServiceI {\n', '\n', '  /*\n', '   * @notice This method *MUST* be called by `RegulatedToken`s during `transfer()` and `transferFrom()`.\n', '   *         The implementation *SHOULD* check whether or not a transfer can be approved.\n', '   *\n', '   * @dev    This method *MAY* call back to the token contract specified by `_token` for\n', '   *         more information needed to enforce trade approval.\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return uint8 The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *               to assign meaning.\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title  On-chain RegulatorService implementation for approving trades\n', ' * @author Originally Bob Remeika, modified by TokenSoft Inc\n', ' * @dev Orignal source: https://github.com/harborhq/r-token/blob/master/contracts/TokenRegulatorService.sol\n', ' */\n', 'contract RegulatorService is RegulatorServiceI, Ownable {\n', '  /**\n', '   * @dev Throws if called by any account other than the admin\n', '   */\n', '  modifier onlyAdmins() {\n', '    require(msg.sender == admin || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /// @dev Settings that affect token trading at a global level\n', '  struct Settings {\n', '\n', '    /**\n', '     * @dev Toggle for locking/unlocking trades at a token level.\n', '     *      The default behavior of the zero memory state for locking will be unlocked.\n', '     */\n', '    bool locked;\n', '\n', '    /**\n', '     * @dev Toggle for allowing/disallowing fractional token trades at a token level.\n', '     *      The default state when this contract is created `false` (or no partial\n', '     *      transfers allowed).\n', '     */\n', '    bool partialTransfers;\n', '  }\n', '\n', '  // @dev Check success code & message\n', '  uint8 constant private CHECK_SUCCESS = 0;\n', '  string constant private SUCCESS_MESSAGE = &#39;Success&#39;;\n', '\n', '  // @dev Check error reason: Token is locked\n', '  uint8 constant private CHECK_ELOCKED = 1;\n', '  string constant private ELOCKED_MESSAGE = &#39;Token is locked&#39;;\n', '\n', '  // @dev Check error reason: Token can not trade partial amounts\n', '  uint8 constant private CHECK_EDIVIS = 2;\n', '  string constant private EDIVIS_MESSAGE = &#39;Token can not trade partial amounts&#39;;\n', '\n', '  // @dev Check error reason: Sender is not allowed to send the token\n', '  uint8 constant private CHECK_ESEND = 3;\n', '  string constant private ESEND_MESSAGE = &#39;Sender is not allowed to send the token&#39;;\n', '\n', '  // @dev Check error reason: Receiver is not allowed to receive the token\n', '  uint8 constant private CHECK_ERECV = 4;\n', '  string constant private ERECV_MESSAGE = &#39;Receiver is not allowed to receive the token&#39;;\n', '\n', '  /// @dev Permission bits for allowing a participant to send tokens\n', '  uint8 constant private PERM_SEND = 0x1;\n', '\n', '  /// @dev Permission bits for allowing a participant to receive tokens\n', '  uint8 constant private PERM_RECEIVE = 0x2;\n', '\n', '  // @dev Address of the administrator\n', '  address public admin;\n', '\n', '  /// @notice Permissions that allow/disallow token trades on a per token level\n', '  mapping(address => Settings) private settings;\n', '\n', '  /// @dev Permissions that allow/disallow token trades on a per participant basis.\n', '  ///      The format for key based access is `participants[tokenAddress][participantAddress]`\n', '  ///      which returns the permission bits of a participant for a particular token.\n', '  mapping(address => mapping(address => uint8)) private participants;\n', '\n', '  /// @dev Event raised when a token&#39;s locked setting is set\n', '  event LogLockSet(address indexed token, bool locked);\n', '\n', '  /// @dev Event raised when a token&#39;s partial transfer setting is set\n', '  event LogPartialTransferSet(address indexed token, bool enabled);\n', '\n', '  /// @dev Event raised when a participant permissions are set for a token\n', '  event LogPermissionSet(address indexed token, address indexed participant, uint8 permission);\n', '\n', '  /// @dev Event raised when the admin address changes\n', '  event LogTransferAdmin(address indexed oldAdmin, address indexed newAdmin);\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the ability to trade a token\n', '   *\n', '   * @dev    This method can only be called by this contract&#39;s owner\n', '   *\n', '   * @param  _token The address of the token to lock\n', '   */\n', '  function setLocked(address _token, bool _locked) onlyOwner public {\n', '    settings[_token].locked = _locked;\n', '\n', '    emit LogLockSet(_token, _locked);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the ability to trade a fraction of a token\n', '   *\n', '   * @dev    This method can only be called by this contract&#39;s owner\n', '   *\n', '   * @param  _token The address of the token to allow partial transfers\n', '   */\n', '  function setPartialTransfers(address _token, bool _enabled) onlyOwner public {\n', '   settings[_token].partialTransfers = _enabled;\n', '\n', '   emit LogPartialTransferSet(_token, _enabled);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the trade permissions for a participant on a token\n', '   *\n', '   * @dev    The `_permission` bits overwrite the previous trade permissions and can\n', '   *         only be called by the contract&#39;s owner.  `_permissions` can be bitwise\n', '   *         `|`&#39;d together to allow for more than one permission bit to be set.\n', '   *\n', '   * @param  _token The address of the token\n', '   * @param  _participant The address of the trade participant\n', '   * @param  _permission Permission bits to be set\n', '   */\n', '  function setPermission(address _token, address _participant, uint8 _permission) onlyAdmins public {\n', '    participants[_token][_participant] = _permission;\n', '\n', '    emit LogPermissionSet(_token, _participant, _permission);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to transfer admin controls to newAdmin.\n', '   *\n', '   * @param newAdmin The address to transfer admin rights to.\n', '   */\n', '  function transferAdmin(address newAdmin) onlyOwner public {\n', '    require(newAdmin != address(0));\n', '\n', '    address oldAdmin = admin;\n', '    admin = newAdmin;\n', '\n', '    emit LogTransferAdmin(oldAdmin, newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether or not a trade should be approved\n', '   *\n', '   * @dev    This method calls back to the token contract specified by `_token` for\n', '   *         information needed to enforce trade approval if needed\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token (unused in this implementation)\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return `true` if the trade should be approved and `false` if the trade should not be approved\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8) {\n', '    if (settings[_token].locked) {\n', '      return CHECK_ELOCKED;\n', '    }\n', '\n', '    if (participants[_token][_from] & PERM_SEND == 0) {\n', '      return CHECK_ESEND;\n', '    }\n', '\n', '    if (participants[_token][_to] & PERM_RECEIVE == 0) {\n', '      return CHECK_ERECV;\n', '    }\n', '\n', '    if (!settings[_token].partialTransfers && _amount % _wholeToken(_token) != 0) {\n', '      return CHECK_EDIVIS;\n', '    }\n', '\n', '    return CHECK_SUCCESS;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the error message for a passed failed check reason\n', '   *\n', '   * @param  _reason The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *                 to assign meaning.\n', '   *\n', '   * @return The human-readable mesage string\n', '   */\n', '  function messageForReason (uint8 _reason) public pure returns (string) {\n', '    if (_reason == CHECK_ELOCKED) {\n', '      return ELOCKED_MESSAGE;\n', '    }\n', '    \n', '    if (_reason == CHECK_ESEND) {\n', '      return ESEND_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_ERECV) {\n', '      return ERECV_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_EDIVIS) {\n', '      return EDIVIS_MESSAGE;\n', '    }\n', '\n', '    return SUCCESS_MESSAGE;\n', '  }\n', '\n', '  /**\n', '   * @notice Retrieves the whole token value from a token that this `RegulatorService` manages\n', '   *\n', '   * @param  _token The token address of the managed token\n', '   *\n', '   * @return The uint256 value that represents a single whole token\n', '   */\n', '  function _wholeToken(address _token) view private returns (uint256) {\n', '    return uint256(10)**DetailedERC20(_token).decimals();\n', '  }\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/// @notice A service that points to a `RegulatorService`\n', 'contract ServiceRegistry is Ownable {\n', '  address public service;\n', '\n', '  /**\n', '   * @notice Triggered when service address is replaced\n', '   */\n', '  event ReplaceService(address oldService, address newService);\n', '\n', '  /**\n', '   * @dev Validate contract address\n', '   * Credit: https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/ERC223_Token.sol#L107-L114\n', '   *\n', '   * @param _addr The address of a smart contract\n', '   */\n', '  modifier withContract(address _addr) {\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    require(length > 0);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Constructor\n', '   *\n', '   * @param _service The address of the `RegulatorService`\n', '   *\n', '   */\n', '  constructor(address _service) public {\n', '    service = _service;\n', '  }\n', '\n', '  /**\n', '   * @notice Replaces the address pointer to the `RegulatorService`\n', '   *\n', '   * @dev This method is only callable by the contract&#39;s owner\n', '   *\n', '   * @param _service The address of the new `RegulatorService`\n', '   */\n', '  function replaceService(address _service) onlyOwner withContract(_service) public {\n', '    address oldService = service;\n', '    service = _service;\n', '    emit ReplaceService(oldService, service);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    public\n', '    hasMintPermission\n', '    canMint\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() public onlyOwner canMint returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @notice An ERC-20 token that has the ability to check for trade validity\n', 'contract RegulatedToken is DetailedERC20, MintableToken, BurnableToken {\n', '\n', '  /**\n', '   * @notice R-Token decimals setting (used when constructing DetailedERC20)\n', '   */\n', '  uint8 constant public RTOKEN_DECIMALS = 18;\n', '\n', '  /**\n', '   * @notice Triggered when regulator checks pass or fail\n', '   */\n', '  event CheckStatus(uint8 reason, address indexed spender, address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @notice Address of the `ServiceRegistry` that has the location of the\n', '   *         `RegulatorService` contract responsible for checking trade\n', '   *         permissions.\n', '   */\n', '  ServiceRegistry public registry;\n', '\n', '  /**\n', '   * @notice Constructor\n', '   *\n', '   * @param _registry Address of `ServiceRegistry` contract\n', '   * @param _name Name of the token: See DetailedERC20\n', '   * @param _symbol Symbol of the token: See DetailedERC20\n', '   */\n', '  constructor(ServiceRegistry _registry, string _name, string _symbol) public\n', '    DetailedERC20(_name, _symbol, RTOKEN_DECIMALS)\n', '  {\n', '    require(_registry != address(0));\n', '\n', '    registry = _registry;\n', '  }\n', '\n', '  /**\n', '   * @notice ERC-20 overridden function that include logic to check for trade validity.\n', '   *\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if successful and `false` if unsuccessful\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    if (_check(msg.sender, _to, _value)) {\n', '      return super.transfer(_to, _value);\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice ERC-20 overridden function that include logic to check for trade validity.\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if successful and `false` if unsuccessful\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    if (_check(_from, _to, _value)) {\n', '      return super.transferFrom(_from, _to, _value);\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Performs the regulator check\n', '   *\n', '   * @dev This method raises a CheckStatus event indicating success or failure of the check\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if the check was successful and `false` if unsuccessful\n', '   */\n', '  function _check(address _from, address _to, uint256 _value) private returns (bool) {\n', '    require(_from != address(0) && _to != address(0));\n', '    uint8 reason = _service().check(this, msg.sender, _from, _to, _value);\n', '\n', '    emit CheckStatus(reason, msg.sender, _from, _to, _value);\n', '\n', '    return reason == 0;\n', '  }\n', '\n', '  /**\n', '   * @notice Retreives the address of the `RegulatorService` that manages this token.\n', '   *\n', '   * @dev This function *MUST NOT* memoize the `RegulatorService` address.  This would\n', '   *      break the ability to upgrade the `RegulatorService`.\n', '   *\n', '   * @return The `RegulatorService` that manages this token.\n', '   */\n', '  function _service() view public returns (RegulatorService) {\n', '    return RegulatorService(registry.service());\n', '  }\n', '}\n', '\n', '\n', 'contract RegulatedTokenERC1404 is ERC1404, RegulatedToken {\n', '    constructor(ServiceRegistry _registry, string _name, string _symbol) public\n', '        RegulatedToken(_registry, _name, _symbol)\n', '    {\n', '\n', '    }\n', '\n', '   /**\n', '    * @notice Implementing detectTransferRestriction makes this token ERC-1404 compatible\n', '    * \n', '    * @dev Notice in the call to _service.check(), the 2nd argument is address 0.\n', '    *      This "spender" parameter is unused in Harbor&#39;s own R-Token implementation\n', '    *      and will have to be remain unused for the purposes of our example.\n', '    *\n', '    * @param from The address of the sender\n', '    * @param to The address of the receiver\n', '    * @param value The number of tokens to transfer\n', '    *\n', '    * @return A code that is associated with the reason for a failed check\n', '    */\n', '    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8) {\n', '        return _service().check(this, address(0), from, to, value);\n', '    }\n', '\n', '   /**\n', '    * @notice Implementing messageForTransferRestriction makes this token ERC-1404 compatible\n', '    *\n', '    * @dev The RegulatorService contract must implement the function messageforReason in this implementation\n', '    * \n', '    * @param reason The restrictionCode returned from the service check\n', '    *\n', '    * @return The human-readable mesage string\n', '    */\n', '    function messageForTransferRestriction (uint8 reason) public view returns (string) {\n', '        return _service().messageForReason(reason);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', 'contract ERC1404 is ERC20 {\n', '    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n', '    /// @param from Sending address\n', '    /// @param to Receiving address\n', '    /// @param value Amount of tokens being transferred\n', '    /// @return Code by which to reference message for rejection reasoning\n', '    /// @dev Overwrite with your custom transfer restriction logic\n', '    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);\n', '\n', '    /// @notice Returns a human-readable message for a given restriction code\n', '    /// @param restrictionCode Identifier for looking up a message\n', "    /// @return Text showing the restriction's reasoning\n", '    /// @dev Overwrite with your custom message and restrictionCode handling\n', '    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/// @notice Standard interface for `RegulatorService`s\n', 'contract RegulatorServiceI {\n', '\n', '  /*\n', '   * @notice This method *MUST* be called by `RegulatedToken`s during `transfer()` and `transferFrom()`.\n', '   *         The implementation *SHOULD* check whether or not a transfer can be approved.\n', '   *\n', '   * @dev    This method *MAY* call back to the token contract specified by `_token` for\n', '   *         more information needed to enforce trade approval.\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return uint8 The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *               to assign meaning.\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title  On-chain RegulatorService implementation for approving trades\n', ' * @author Originally Bob Remeika, modified by TokenSoft Inc\n', ' * @dev Orignal source: https://github.com/harborhq/r-token/blob/master/contracts/TokenRegulatorService.sol\n', ' */\n', 'contract RegulatorService is RegulatorServiceI, Ownable {\n', '  /**\n', '   * @dev Throws if called by any account other than the admin\n', '   */\n', '  modifier onlyAdmins() {\n', '    require(msg.sender == admin || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /// @dev Settings that affect token trading at a global level\n', '  struct Settings {\n', '\n', '    /**\n', '     * @dev Toggle for locking/unlocking trades at a token level.\n', '     *      The default behavior of the zero memory state for locking will be unlocked.\n', '     */\n', '    bool locked;\n', '\n', '    /**\n', '     * @dev Toggle for allowing/disallowing fractional token trades at a token level.\n', '     *      The default state when this contract is created `false` (or no partial\n', '     *      transfers allowed).\n', '     */\n', '    bool partialTransfers;\n', '  }\n', '\n', '  // @dev Check success code & message\n', '  uint8 constant private CHECK_SUCCESS = 0;\n', "  string constant private SUCCESS_MESSAGE = 'Success';\n", '\n', '  // @dev Check error reason: Token is locked\n', '  uint8 constant private CHECK_ELOCKED = 1;\n', "  string constant private ELOCKED_MESSAGE = 'Token is locked';\n", '\n', '  // @dev Check error reason: Token can not trade partial amounts\n', '  uint8 constant private CHECK_EDIVIS = 2;\n', "  string constant private EDIVIS_MESSAGE = 'Token can not trade partial amounts';\n", '\n', '  // @dev Check error reason: Sender is not allowed to send the token\n', '  uint8 constant private CHECK_ESEND = 3;\n', "  string constant private ESEND_MESSAGE = 'Sender is not allowed to send the token';\n", '\n', '  // @dev Check error reason: Receiver is not allowed to receive the token\n', '  uint8 constant private CHECK_ERECV = 4;\n', "  string constant private ERECV_MESSAGE = 'Receiver is not allowed to receive the token';\n", '\n', '  /// @dev Permission bits for allowing a participant to send tokens\n', '  uint8 constant private PERM_SEND = 0x1;\n', '\n', '  /// @dev Permission bits for allowing a participant to receive tokens\n', '  uint8 constant private PERM_RECEIVE = 0x2;\n', '\n', '  // @dev Address of the administrator\n', '  address public admin;\n', '\n', '  /// @notice Permissions that allow/disallow token trades on a per token level\n', '  mapping(address => Settings) private settings;\n', '\n', '  /// @dev Permissions that allow/disallow token trades on a per participant basis.\n', '  ///      The format for key based access is `participants[tokenAddress][participantAddress]`\n', '  ///      which returns the permission bits of a participant for a particular token.\n', '  mapping(address => mapping(address => uint8)) private participants;\n', '\n', "  /// @dev Event raised when a token's locked setting is set\n", '  event LogLockSet(address indexed token, bool locked);\n', '\n', "  /// @dev Event raised when a token's partial transfer setting is set\n", '  event LogPartialTransferSet(address indexed token, bool enabled);\n', '\n', '  /// @dev Event raised when a participant permissions are set for a token\n', '  event LogPermissionSet(address indexed token, address indexed participant, uint8 permission);\n', '\n', '  /// @dev Event raised when the admin address changes\n', '  event LogTransferAdmin(address indexed oldAdmin, address indexed newAdmin);\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the ability to trade a token\n', '   *\n', "   * @dev    This method can only be called by this contract's owner\n", '   *\n', '   * @param  _token The address of the token to lock\n', '   */\n', '  function setLocked(address _token, bool _locked) onlyOwner public {\n', '    settings[_token].locked = _locked;\n', '\n', '    emit LogLockSet(_token, _locked);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the ability to trade a fraction of a token\n', '   *\n', "   * @dev    This method can only be called by this contract's owner\n", '   *\n', '   * @param  _token The address of the token to allow partial transfers\n', '   */\n', '  function setPartialTransfers(address _token, bool _enabled) onlyOwner public {\n', '   settings[_token].partialTransfers = _enabled;\n', '\n', '   emit LogPartialTransferSet(_token, _enabled);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the trade permissions for a participant on a token\n', '   *\n', '   * @dev    The `_permission` bits overwrite the previous trade permissions and can\n', "   *         only be called by the contract's owner.  `_permissions` can be bitwise\n", "   *         `|`'d together to allow for more than one permission bit to be set.\n", '   *\n', '   * @param  _token The address of the token\n', '   * @param  _participant The address of the trade participant\n', '   * @param  _permission Permission bits to be set\n', '   */\n', '  function setPermission(address _token, address _participant, uint8 _permission) onlyAdmins public {\n', '    participants[_token][_participant] = _permission;\n', '\n', '    emit LogPermissionSet(_token, _participant, _permission);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to transfer admin controls to newAdmin.\n', '   *\n', '   * @param newAdmin The address to transfer admin rights to.\n', '   */\n', '  function transferAdmin(address newAdmin) onlyOwner public {\n', '    require(newAdmin != address(0));\n', '\n', '    address oldAdmin = admin;\n', '    admin = newAdmin;\n', '\n', '    emit LogTransferAdmin(oldAdmin, newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether or not a trade should be approved\n', '   *\n', '   * @dev    This method calls back to the token contract specified by `_token` for\n', '   *         information needed to enforce trade approval if needed\n', '   *\n', '   * @param  _token The address of the token to be transfered\n', '   * @param  _spender The address of the spender of the token (unused in this implementation)\n', '   * @param  _from The address of the sender account\n', '   * @param  _to The address of the receiver account\n', '   * @param  _amount The quantity of the token to trade\n', '   *\n', '   * @return `true` if the trade should be approved and `false` if the trade should not be approved\n', '   */\n', '  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8) {\n', '    if (settings[_token].locked) {\n', '      return CHECK_ELOCKED;\n', '    }\n', '\n', '    if (participants[_token][_from] & PERM_SEND == 0) {\n', '      return CHECK_ESEND;\n', '    }\n', '\n', '    if (participants[_token][_to] & PERM_RECEIVE == 0) {\n', '      return CHECK_ERECV;\n', '    }\n', '\n', '    if (!settings[_token].partialTransfers && _amount % _wholeToken(_token) != 0) {\n', '      return CHECK_EDIVIS;\n', '    }\n', '\n', '    return CHECK_SUCCESS;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the error message for a passed failed check reason\n', '   *\n', '   * @param  _reason The reason code: 0 means success.  Non-zero values are left to the implementation\n', '   *                 to assign meaning.\n', '   *\n', '   * @return The human-readable mesage string\n', '   */\n', '  function messageForReason (uint8 _reason) public pure returns (string) {\n', '    if (_reason == CHECK_ELOCKED) {\n', '      return ELOCKED_MESSAGE;\n', '    }\n', '    \n', '    if (_reason == CHECK_ESEND) {\n', '      return ESEND_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_ERECV) {\n', '      return ERECV_MESSAGE;\n', '    }\n', '\n', '    if (_reason == CHECK_EDIVIS) {\n', '      return EDIVIS_MESSAGE;\n', '    }\n', '\n', '    return SUCCESS_MESSAGE;\n', '  }\n', '\n', '  /**\n', '   * @notice Retrieves the whole token value from a token that this `RegulatorService` manages\n', '   *\n', '   * @param  _token The token address of the managed token\n', '   *\n', '   * @return The uint256 value that represents a single whole token\n', '   */\n', '  function _wholeToken(address _token) view private returns (uint256) {\n', '    return uint256(10)**DetailedERC20(_token).decimals();\n', '  }\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/// @notice A service that points to a `RegulatorService`\n', 'contract ServiceRegistry is Ownable {\n', '  address public service;\n', '\n', '  /**\n', '   * @notice Triggered when service address is replaced\n', '   */\n', '  event ReplaceService(address oldService, address newService);\n', '\n', '  /**\n', '   * @dev Validate contract address\n', '   * Credit: https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/ERC223_Token.sol#L107-L114\n', '   *\n', '   * @param _addr The address of a smart contract\n', '   */\n', '  modifier withContract(address _addr) {\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    require(length > 0);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Constructor\n', '   *\n', '   * @param _service The address of the `RegulatorService`\n', '   *\n', '   */\n', '  constructor(address _service) public {\n', '    service = _service;\n', '  }\n', '\n', '  /**\n', '   * @notice Replaces the address pointer to the `RegulatorService`\n', '   *\n', "   * @dev This method is only callable by the contract's owner\n", '   *\n', '   * @param _service The address of the new `RegulatorService`\n', '   */\n', '  function replaceService(address _service) onlyOwner withContract(_service) public {\n', '    address oldService = service;\n', '    service = _service;\n', '    emit ReplaceService(oldService, service);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    public\n', '    hasMintPermission\n', '    canMint\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() public onlyOwner canMint returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '/**\n', '   Copyright (c) 2017 Harbor Platform, Inc.\n', '\n', '   Licensed under the Apache License, Version 2.0 (the “License”);\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '   http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an “AS IS” BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @notice An ERC-20 token that has the ability to check for trade validity\n', 'contract RegulatedToken is DetailedERC20, MintableToken, BurnableToken {\n', '\n', '  /**\n', '   * @notice R-Token decimals setting (used when constructing DetailedERC20)\n', '   */\n', '  uint8 constant public RTOKEN_DECIMALS = 18;\n', '\n', '  /**\n', '   * @notice Triggered when regulator checks pass or fail\n', '   */\n', '  event CheckStatus(uint8 reason, address indexed spender, address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @notice Address of the `ServiceRegistry` that has the location of the\n', '   *         `RegulatorService` contract responsible for checking trade\n', '   *         permissions.\n', '   */\n', '  ServiceRegistry public registry;\n', '\n', '  /**\n', '   * @notice Constructor\n', '   *\n', '   * @param _registry Address of `ServiceRegistry` contract\n', '   * @param _name Name of the token: See DetailedERC20\n', '   * @param _symbol Symbol of the token: See DetailedERC20\n', '   */\n', '  constructor(ServiceRegistry _registry, string _name, string _symbol) public\n', '    DetailedERC20(_name, _symbol, RTOKEN_DECIMALS)\n', '  {\n', '    require(_registry != address(0));\n', '\n', '    registry = _registry;\n', '  }\n', '\n', '  /**\n', '   * @notice ERC-20 overridden function that include logic to check for trade validity.\n', '   *\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if successful and `false` if unsuccessful\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    if (_check(msg.sender, _to, _value)) {\n', '      return super.transfer(_to, _value);\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice ERC-20 overridden function that include logic to check for trade validity.\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if successful and `false` if unsuccessful\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    if (_check(_from, _to, _value)) {\n', '      return super.transferFrom(_from, _to, _value);\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Performs the regulator check\n', '   *\n', '   * @dev This method raises a CheckStatus event indicating success or failure of the check\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the receiver\n', '   * @param _value The number of tokens to transfer\n', '   *\n', '   * @return `true` if the check was successful and `false` if unsuccessful\n', '   */\n', '  function _check(address _from, address _to, uint256 _value) private returns (bool) {\n', '    require(_from != address(0) && _to != address(0));\n', '    uint8 reason = _service().check(this, msg.sender, _from, _to, _value);\n', '\n', '    emit CheckStatus(reason, msg.sender, _from, _to, _value);\n', '\n', '    return reason == 0;\n', '  }\n', '\n', '  /**\n', '   * @notice Retreives the address of the `RegulatorService` that manages this token.\n', '   *\n', '   * @dev This function *MUST NOT* memoize the `RegulatorService` address.  This would\n', '   *      break the ability to upgrade the `RegulatorService`.\n', '   *\n', '   * @return The `RegulatorService` that manages this token.\n', '   */\n', '  function _service() view public returns (RegulatorService) {\n', '    return RegulatorService(registry.service());\n', '  }\n', '}\n', '\n', '\n', 'contract RegulatedTokenERC1404 is ERC1404, RegulatedToken {\n', '    constructor(ServiceRegistry _registry, string _name, string _symbol) public\n', '        RegulatedToken(_registry, _name, _symbol)\n', '    {\n', '\n', '    }\n', '\n', '   /**\n', '    * @notice Implementing detectTransferRestriction makes this token ERC-1404 compatible\n', '    * \n', '    * @dev Notice in the call to _service.check(), the 2nd argument is address 0.\n', '    *      This "spender" parameter is unused in Harbor\'s own R-Token implementation\n', '    *      and will have to be remain unused for the purposes of our example.\n', '    *\n', '    * @param from The address of the sender\n', '    * @param to The address of the receiver\n', '    * @param value The number of tokens to transfer\n', '    *\n', '    * @return A code that is associated with the reason for a failed check\n', '    */\n', '    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8) {\n', '        return _service().check(this, address(0), from, to, value);\n', '    }\n', '\n', '   /**\n', '    * @notice Implementing messageForTransferRestriction makes this token ERC-1404 compatible\n', '    *\n', '    * @dev The RegulatorService contract must implement the function messageforReason in this implementation\n', '    * \n', '    * @param reason The restrictionCode returned from the service check\n', '    *\n', '    * @return The human-readable mesage string\n', '    */\n', '    function messageForTransferRestriction (uint8 reason) public view returns (string) {\n', '        return _service().messageForReason(reason);\n', '    }\n', '}']
