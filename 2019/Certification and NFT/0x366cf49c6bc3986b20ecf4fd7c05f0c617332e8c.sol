['pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /**\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '        public returns (bytes4);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) public _tokenOwner;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => uint256) public _ownedTokensCount;\n', '\n', '    bytes4 internal constant _INTERFACE_ID_ERC721 = 0xab7fecf1;\n', '    /*\n', '     * 0xab7fecf1 ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '        _tokenOwner[tokenId] = to;\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to]= _ownedTokensCount[to].add(1);\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', 'contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n', '\n', '    // Token class name e.g. "2019 Coachella Gathering Trophies" \n', '    string internal _name;\n', '\n', '    // Token class symbol e.g. "CGT19"\n', '    string internal _symbol;\n', '\n', '    // Mapping for token URIs\n', '    mapping(uint256 => string) internal _tokenURIs;\n', '\n', '    // // Optional mapping for token names\n', '    mapping(uint256 => string) internal _tokenNames;\n', '\n', '    bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0xbc7bebe8;\n', '    /**\n', '     * 0xbc7bebe8 ===\n', "     *     bytes4(keccak256('name()')) ^\n", "     *     bytes4(keccak256('symbol()')) ^\n", "     *     bytes4(keccak256('tokenURI(uint256)')) ^\n", "     *     bytes4(keccak256('tokenName(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId));\n', '        return _tokenURIs[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns a trophy name for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenName(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId));\n', '        return _tokenNames[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the token URI for a given token\n', '     * Reverts if the token ID does not exist\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param uri string URI to assign\n', '     */\n', '    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n', '        require(_exists(tokenId));\n', '        _tokenURIs[tokenId] = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that extracts the part of a string based on the desired length and offset. The\n', '     *      offset and length must not exceed the lenth of the base string.\n', '     * \n', '     * @param _base When being used for a data type this is the extended object\n', '     *              otherwise this is the string that will be used for \n', '     *              extracting the sub string from\n', '     * @param _length The length of the sub string to extract\n', '     * @param _offset The starting point to extract the sub string from\n', '     * @return string The extracted sub string\n', '     */\n', '\n', '    function _substring(string memory _base, int _length, int _offset) internal pure returns (string memory) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '\n', '        assert(uint(_offset+_length) <= _baseBytes.length);\n', '\n', '        string memory _tmp = new string(uint(_length));\n', '        bytes memory _tmpBytes = bytes(_tmp);\n', '\n', '        uint j = 0;\n', '            for(uint i = uint(_offset); i < uint(_offset+_length); i++) {\n', '                _tmpBytes[j++] = _baseBytes[i];\n', '            }\n', '            return string(_tmpBytes);\n', '        }\n', '}\n', '\n', '/**\n', ' * @title Gather Standard Trophies - Gathering-based Non-Fungible ERC721 Tokens \n', ' * @author Victor Rortvedt (@vrortvedt)\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract GatherStandardTrophies is ERC721, ERC721Metadata {\n', '\n', '    // Address of contract deployer/trophy minter\n', '    address public creator;\n', '\n', '     /**\n', '     * @dev Modifier limiting certain functions to creator address\n', '     */\n', '    modifier onlyCreator() {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        creator = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Mints six standard trophies at conclusion of gathering\n', '     * @param winners Array containing six addresses of trophy winners \n', "     * @param uri String containing ordered list of all trophies' URI info, in 59 character length chunks pointing to ipfs URL\n", '     */\n', '    function mintStandardTrophies(address[] memory winners, string memory uri) public onlyCreator {\n', '        mintSchmoozerTrophy((winners[0]), _substring(uri,59,0));\n', '        mintCupidTrophy((winners[1]), _substring(uri,59,59));\n', '        mintMVPTrophy((winners[2]), _substring(uri,59,118));\n', '        mintHumanRouterTrophy((winners[3]), _substring(uri,59,177));\n', '        mintOracleTrophy((winners[4]), _substring(uri,59,236));\n', '        mintKevinBaconTrophy((winners[5]), _substring(uri,59,295));\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that mints Schmoozer trophy at conclusion of gathering to gatherNode with most connections made\n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */\n', '    function mintSchmoozerTrophy(address winner, string memory uri) public onlyCreator {\n', '        _mint(winner, 1);\n', '        _tokenNames[1] = "Schmoozer Trophy";\n', '        _tokenURIs[1] = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that mints Cupid trophy at conclusion of gathering to gatherNode with most matches made\n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */\n', '    function mintCupidTrophy(address winner, string memory uri) public onlyCreator  {\n', '        _mint(winner, 2);\n', '        _tokenNames[2] = "Cupid Trophy";\n', '        _tokenURIs[2] = uri;\n', '    } \n', '    \n', '    /**\n', '     * @dev Public function that mints  MVP trophy at conclusion of gathering to gatherNode with most total points\n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */ \n', '    function mintMVPTrophy(address winner, string memory uri) public onlyCreator {\n', '        _mint(winner, 3);\n', '        _tokenNames[3] = "MVP Trophy";\n', '        _tokenURIs[3] = uri;\n', '    } \n', '\n', '    /**\n', '     * @dev Public function that mints Human Router trophy at conclusion of gathering to gatherNode with most recommendations made\n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */\n', '    function mintHumanRouterTrophy(address winner, string memory uri) public onlyCreator {\n', '        _mint(winner, 4);\n', '        _tokenNames[4] = "Human Router Trophy";\n', '        _tokenURIs[4] = uri;\n', '    }\n', '    \n', '    /**\n', '     * @dev Public function that mints Oracle trophy at conclusion of gathering to gatherNode with most supermatches \n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */\n', '    function mintOracleTrophy(address winner, string memory uri) public onlyCreator {\n', '        _mint(winner, 5);\n', '        _tokenNames[5] = "Oracle Trophy";\n', '        _tokenURIs[5] = uri;\n', '    } \n', '\n', '\n', '    /**\n', '     * @dev Public function that mints Kevin Bacon trophy at conclusion of gathering \n', '     * to gatherNode with fewest average degrees of separation from all other gatherNodes\n', '     * @param winner Address of trophy winner \n', '     * @param uri String containing IPFS link to URI info\n', '     */\n', '    function mintKevinBaconTrophy(address winner, string memory uri) public onlyCreator {\n', '        _mint(winner, 6);\n', '        _tokenNames[6] = "Kevin Bacon Trophy";\n', '        _tokenURIs[6] = uri;\n', '    }   \n', '\n', '}']