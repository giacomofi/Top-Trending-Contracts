['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-07\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IGST2 {\n', '\n', '    function freeUpTo(uint256 value) external returns (uint256 freed);\n', '\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '}\n', '\n', '// solhint-disable max-line-length\n', 'contract LibConstants {\n', '\n', '    // Asset data for ZRX token. Used for fee transfers.\n', '\n', '    // The proxyId for ZRX_ASSET_DATA is bytes4(keccak256("ERC20Token(address)")) = 0xf47261b0\n', '\n', '    // Kovan ZRX address is 0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570.\n', '    // The ABI encoded proxyId and address is 0xf47261b00000000000000000000000006ff6c0ff1d68b964901f986d4c9fa3ac68346570\n', '    // bytes constant public ZRX_ASSET_DATA = "\\xf4\\x72\\x61\\xb0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x6f\\xf6\\xc0\\xff\\x1d\\x68\\xb9\\x64\\x90\\x1f\\x98\\x6d\\x4c\\x9f\\xa3\\xac\\x68\\x34\\x65\\x70";\n', '\n', '    // Mainnet ZRX address is 0xe41d2489571d322189246dafa5ebde1f4699f498.\n', '    // The ABI encoded proxyId and address is 0xf47261b0000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f498\n', '    bytes constant public ZRX_ASSET_DATA = "\\xf4\\x72\\x61\\xb0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe4\\x1d\\x24\\x89\\x57\\x1d\\x32\\x21\\x89\\x24\\x6d\\xaf\\xa5\\xeb\\xde\\x1f\\x46\\x99\\xf4\\x98";\n', '}\n', '// solhint-enable max-line-length\n', '\n', 'contract LibFillResults\n', '{\n', '    struct FillResults {\n', '        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n', '        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n', '        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n', '        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n', '    }\n', '\n', '    struct MatchedFillResults {\n', '        FillResults left;                    // Amounts filled and fees paid of left order.\n', '        FillResults right;                   // Amounts filled and fees paid of right order.\n', '        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order&#39;s makerAsset, paid to taker.\n', '    }\n', '}\n', '\n', 'contract LibOrder\n', '{\n', '    // Hash for the EIP712 Order Schema\n', '    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n', '        "Order(",\n', '        "address makerAddress,",\n', '        "address takerAddress,",\n', '        "address feeRecipientAddress,",\n', '        "address senderAddress,",\n', '        "uint256 makerAssetAmount,",\n', '        "uint256 takerAssetAmount,",\n', '        "uint256 makerFee,",\n', '        "uint256 takerFee,",\n', '        "uint256 expirationTimeSeconds,",\n', '        "uint256 salt,",\n', '        "bytes makerAssetData,",\n', '        "bytes takerAssetData",\n', '        ")"\n', '    ));\n', '\n', '    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n', '    // An order&#39;s state is unaffected by external factors, like account balances.\n', '    enum OrderStatus {\n', '        INVALID,                     // Default value\n', '        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n', '        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n', '        FILLABLE,                    // Order is fillable\n', '        EXPIRED,                     // Order has already expired\n', '        FULLY_FILLED,                // Order is fully filled\n', '        CANCELLED                    // Order has been cancelled\n', '    }\n', '\n', '    // solhint-disable max-line-length\n', '    struct Order {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', '        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order&#39;s hash.\n', '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '    }\n', '    // solhint-enable max-line-length\n', '\n', '    struct OrderInfo {\n', '        uint8 orderStatus;                    // Status that describes order&#39;s validity and fillability.\n', '        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n', '        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n', '    }\n', '}\n', '\n', 'contract IExchangeCore {\n', '\n', '    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n', '    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n', '    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n', '    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n', '        external;\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param order Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrder(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev After calling, the order can not be filled anymore.\n', '    /// @param order Order struct containing order specifications.\n', '    function cancelOrder(LibOrder.Order memory order)\n', '        public;\n', '\n', '    /// @dev Gets information about an order: status, hash, and amount filled.\n', '    /// @param order Order to gather information on.\n', '    /// @return OrderInfo Information about the order and its state.\n', '    ///                   See LibOrder.OrderInfo for a complete description.\n', '    function getOrderInfo(LibOrder.Order memory order)\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo memory orderInfo);\n', '}\n', '\n', 'contract IAssetProxyDispatcher {\n', '\n', '    /// @dev Registers an asset proxy to its asset proxy id.\n', '    ///      Once an asset proxy is registered, it cannot be unregistered.\n', '    /// @param assetProxy Address of new asset proxy to register.\n', '    function registerAssetProxy(address assetProxy)\n', '        external;\n', '\n', '    /// @dev Gets an asset proxy.\n', '    /// @param assetProxyId Id of the asset proxy.\n', '    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\n', '    function getAssetProxy(bytes4 assetProxyId)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'contract IMatchOrders {\n', '\n', '    /// @dev Match two complementary orders that have a profitable spread.\n', '    ///      Each order is filled at their respective price point. However, the calculations are\n', '    ///      carried out as though the orders are both being filled at the right order&#39;s price point.\n', '    ///      The profit made by the left order goes to the taker (who matched the two orders).\n', '    /// @param leftOrder First order to match.\n', '    /// @param rightOrder Second order to match.\n', '    /// @param leftSignature Proof that order was created by the left maker.\n', '    /// @param rightSignature Proof that order was created by the right maker.\n', '    /// @return matchedFillResults Amounts filled and fees paid by maker and taker of matched orders.\n', '    function matchOrders(\n', '        LibOrder.Order memory leftOrder,\n', '        LibOrder.Order memory rightOrder,\n', '        bytes memory leftSignature,\n', '        bytes memory rightSignature\n', '    )\n', '        public\n', '        returns (LibFillResults.MatchedFillResults memory matchedFillResults);\n', '}\n', '\n', 'contract IWrapperFunctions {\n', '\n', '    /// @dev Fills the input order. Reverts if exact takerAssetFillAmount not filled.\n', '    /// @param order LibOrder.Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    function fillOrKillOrder(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param order LibOrder.Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrderNoThrow(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrKill.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrKillOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketSellOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 takerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketSellOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 takerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of makerAsset is bought by taker.\n', '    /// @param orders Array of order specifications.\n', '    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketBuyOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 makerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total amount is bought by taker.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketBuyOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 makerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orders Array of order specifications.\n', '    function batchCancelOrders(LibOrder.Order[] memory orders)\n', '        public;\n', '\n', '    /// @dev Fetches information for all passed in orders\n', '    /// @param orders Array of order specifications.\n', '    /// @return Array of OrderInfo instances that correspond to each order.\n', '    function getOrdersInfo(LibOrder.Order[] memory orders)\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo[] memory);\n', '}\n', '\n', '// solhint-disable no-empty-blocks\n', 'contract IZrxExchange is\n', '    IExchangeCore,\n', '    IMatchOrders,\n', '    IAssetProxyDispatcher,\n', '    IWrapperFunctions\n', '{}\n', '\n', '\n', '\n', 'library ExternalCall {\n', '    // Source: https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\n', '    // call has been separated into its own function in order to take advantage\n', '    // of the Solidity&#39;s code generator to produce a loop that copies tx.data into memory.\n', '    function externalCall(address destination, uint value, bytes memory data, uint dataOffset, uint dataLength) internal returns(bool result) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)\n', '            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n', '            result := call(\n', '                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n', '                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n', '                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n', '                destination,\n', '                value,\n', '                add(d, dataOffset),\n', '                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n', '                x,\n', '                0                  // Output is ignored, therefore the output size is zero\n', '            )\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract CompressedCaller {\n', '\n', '    function compressedCall(\n', '        address target,\n', '        uint256 totalLength,\n', '        bytes memory zipped\n', '    )\n', '        public\n', '        payable\n', '        returns (bytes memory result)\n', '    {\n', '        (bytes memory data, uint decompressedLength) = decompress(totalLength, zipped);\n', '        require(decompressedLength == totalLength, "Uncompress error");\n', '\n', '        bool success;\n', '        (success, result) = target.call.value(msg.value)(data);\n', '        require(success, "Decompressed call failed");\n', '    }\n', '\n', '    function decompress(\n', '        uint256 totalLength,\n', '        bytes memory zipped\n', '    )\n', '        public\n', '        pure\n', '        returns (\n', '            bytes memory data,\n', '            uint256 index\n', '        )\n', '    {\n', '        data = new bytes(totalLength);\n', '\n', '        for (uint i = 0; i < zipped.length; i++) {\n', '\n', '            uint len = uint(uint8(zipped[i]) & 0x7F);\n', '\n', '            if ((zipped[i] & 0x80) == 0) {\n', '                memcpy(data, index, zipped, i + 1, len);\n', '                i += len;\n', '            }\n', '\n', '            index += len;\n', '        }\n', '    }\n', '\n', '    //\n', '    // Modified version of:\n', '    // https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol#L45\n', '    //\n', '    function memcpy(\n', '        bytes memory destMem,\n', '        uint dest,\n', '        bytes memory srcMem,\n', '        uint src,\n', '        uint len\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        uint mask = 256 ** (32 - len % 32) - 1;\n', '\n', '        assembly {\n', '            dest := add(add(destMem, 32), dest)\n', '            src := add(add(srcMem, 32), src)\n', '\n', '            // Copy word-length chunks while possible\n', '            for { } gt(len, 31) { len := sub(len, 32) } { // (!<) is the same as (>=)\n', '                mstore(dest, mload(src))\n', '                dest := add(dest, 32)\n', '                src := add(src, 32)\n', '            }\n', '\n', '            // Copy remaining bytes\n', '            let srcPart := and(mload(src), not(mask))\n', '            let destPart := and(mload(dest), mask)\n', '            mstore(dest, or(destPart, srcPart))\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', '     * condition is to first reduce the spender&#39;s allowance to 0 and set the\n', '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', '     * allowance mechanism. `amount` is then deducted from the caller&#39;s\n', '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @dev Wrappers over Solidity&#39;s arithmetic operations with added overflow\n', ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', ' * class of bugs, so it&#39;s recommended to use it always.\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `+` operator.\n', '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * Counterpart to Solidity&#39;s `-` operator.\n', '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `*` operator.\n', '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a\n', '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`\n', '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type,\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', '     * execution of a contract&#39;s constructor, its address will be reported as\n', '     * not containing a contract.\n', '     *\n', '     * > It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', '        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;\n', '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since\n', '        // we&#39;re implementing it ourselves.\n', '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract IWETH is IERC20 {\n', '\n', '    function deposit() external payable;\n', '\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', '\n', '\n', 'contract TokenSpender is Ownable {\n', '\n', '    using SafeERC20 for IERC20;\n', '\n', '    function claimTokens(IERC20 token, address who, address dest, uint256 amount) external onlyOwner {\n', '        token.safeTransferFrom(who, dest, amount);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract AggregatedTokenSwap is CompressedCaller {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '    using ExternalCall for address;\n', '\n', '    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    TokenSpender public spender;\n', '    IGST2 gasToken;\n', '    address payable owner;\n', '    uint fee; // 10000 => 100%, 1 => 0.01%\n', '\n', '    event OneInchFeePaid(\n', '        IERC20 indexed toToken,\n', '        address indexed referrer,\n', '        uint256 fee\n', '    );\n', '\n', '    modifier onlyOwner {\n', '        require(\n', '            msg.sender == owner,\n', '            "Only owner can call this function."\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address payable _owner,\n', '        IGST2 _gasToken,\n', '        uint _fee\n', '    )\n', '    public\n', '    {\n', '        spender = new TokenSpender();\n', '        owner = _owner;\n', '        gasToken = _gasToken;\n', '        fee = _fee;\n', '    }\n', '\n', '    function setFee(uint _fee) public onlyOwner {\n', '\n', '        require(_fee <= 20, "Fee should not exceed 0.2%"); // <= 0.2%\n', '        fee = _fee;\n', '    }\n', '\n', '    function aggregate(\n', '        address payable msgSender,\n', '        IERC20 fromToken,\n', '        IERC20 toToken,\n', '        uint tokensAmount,\n', '        address[] memory callAddresses,\n', '        bytes memory callDataConcat,\n', '        uint[] memory starts,\n', '        uint[] memory values,\n', '        uint mintGasPrice,\n', '        uint minTokensAmount,\n', '        address payable referrer\n', '    )\n', '    public\n', '    payable\n', '    returns (uint returnAmount)\n', '    {\n', '        returnAmount = gasleft();\n', '        uint gasTokenBalance = gasToken.balanceOf(address(this));\n', '\n', '        require(callAddresses.length + 1 == starts.length);\n', '\n', '        if (address(fromToken) != ETH_ADDRESS) {\n', '\n', '            spender.claimTokens(fromToken, msgSender, address(this), tokensAmount);\n', '        }\n', '\n', '        for (uint i = 0; i < starts.length - 1; i++) {\n', '\n', '            if (starts[i + 1] - starts[i] > 0) {\n', '\n', '                require(\n', '                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n', '                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n', '                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n', '                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n', '                );\n', '                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n', '            }\n', '        }\n', '\n', '        require(_balanceOf(toToken, address(this)) >= minTokensAmount);\n', '\n', '        //\n', '\n', '        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n', '        if (mintGasPrice > 0) {\n', '            audoRefundGas(returnAmount, mintGasPrice);\n', '        }\n', '\n', '        //\n', '\n', '        returnAmount = _balanceOf(toToken, address(this)) * fee / 10000;\n', '        if (referrer != address(0)) {\n', '            returnAmount /= 2;\n', '            if (!_transfer(toToken, referrer, returnAmount, true)) {\n', '                returnAmount *= 2;\n', '                emit OneInchFeePaid(toToken, address(0), returnAmount);\n', '            } else {\n', '                emit OneInchFeePaid(toToken, referrer, returnAmount / 2);\n', '            }\n', '        }\n', '\n', '        _transfer(toToken, owner, returnAmount, false);\n', '\n', '        returnAmount = _balanceOf(toToken, address(this));\n', '        _transfer(toToken, msgSender, returnAmount, false);\n', '    }\n', '\n', '    function infiniteApproveIfNeeded(IERC20 token, address to) external {\n', '        if (\n', '            address(token) != ETH_ADDRESS &&\n', '            token.allowance(address(this), to) == 0\n', '        ) {\n', '            token.safeApprove(to, uint256(-1));\n', '        }\n', '    }\n', '\n', '    function withdrawAllToken(IWETH token) external {\n', '        uint256 amount = token.balanceOf(address(this));\n', '        token.withdraw(amount);\n', '    }\n', '\n', '    function marketSellOrders(\n', '        IERC20 token,\n', '        IZrxExchange zrxExchange,\n', '        LibOrder.Order[] calldata orders,\n', '        bytes[] calldata signatures,\n', '        uint256 mul,\n', '        uint256 div\n', '    )\n', '    external\n', '    {\n', '        uint256 amount = token.balanceOf(address(this)).mul(mul).div(div);\n', '        zrxExchange.marketSellOrders(orders, amount, signatures);\n', '    }\n', '\n', '    function _balanceOf(IERC20 token, address who) internal view returns(uint256) {\n', '        if (address(token) == ETH_ADDRESS || token == IERC20(0)) {\n', '            return who.balance;\n', '        } else {\n', '            return token.balanceOf(who);\n', '        }\n', '    }\n', '\n', '    function _transfer(IERC20 token, address payable to, uint256 amount, bool allowFail) internal returns(bool) {\n', '        if (address(token) == ETH_ADDRESS || token == IERC20(0)) {\n', '            if (allowFail) {\n', '                return to.send(amount);\n', '            } else {\n', '                to.transfer(amount);\n', '                return true;\n', '            }\n', '        } else {\n', '            token.safeTransfer(to, amount);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function audoRefundGas(\n', '        uint startGas,\n', '        uint mintGasPrice\n', '    )\n', '    private\n', '    returns (uint freed)\n', '    {\n', '        uint MINT_BASE = 32254;\n', '        uint MINT_TOKEN = 36543;\n', '        uint FREE_BASE = 14154;\n', '        uint FREE_TOKEN = 6870;\n', '        uint REIMBURSE = 24000;\n', '\n', '        uint tokensAmount = ((startGas - gasleft()) + FREE_BASE) / (2 * REIMBURSE - FREE_TOKEN);\n', '        uint maxReimburse = tokensAmount * REIMBURSE;\n', '\n', '        uint mintCost = MINT_BASE + (tokensAmount * MINT_TOKEN);\n', '        uint freeCost = FREE_BASE + (tokensAmount * FREE_TOKEN);\n', '\n', '        uint efficiency = (maxReimburse * 100 * tx.gasprice) / (mintCost * mintGasPrice + freeCost * tx.gasprice);\n', '\n', '        if (efficiency > 100) {\n', '\n', '            return refundGas(\n', '                tokensAmount\n', '            );\n', '        } else {\n', '\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function refundGas(\n', '        uint tokensAmount\n', '    )\n', '    private\n', '    returns (uint freed)\n', '    {\n', '\n', '        if (tokensAmount > 0) {\n', '\n', '            uint safeNumTokens = 0;\n', '            uint gas = gasleft();\n', '\n', '            if (gas >= 27710) {\n', '                safeNumTokens = (gas - 27710) / (1148 + 5722 + 150);\n', '            }\n', '\n', '            if (tokensAmount > safeNumTokens) {\n', '                tokensAmount = safeNumTokens;\n', '            }\n', '\n', '            uint gasTokenBalance = IERC20(address(gasToken)).balanceOf(address(this));\n', '\n', '            if (tokensAmount > 0 && gasTokenBalance >= tokensAmount) {\n', '\n', '                return gasToken.freeUpTo(tokensAmount);\n', '            } else {\n', '\n', '                return 0;\n', '            }\n', '        } else {\n', '\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function() external payable {\n', '\n', '        if (msg.value == 0 && msg.sender == owner) {\n', '\n', '            IERC20 _gasToken = IERC20(address(gasToken));\n', '\n', '            owner.transfer(address(this).balance);\n', '            _gasToken.safeTransfer(owner, _gasToken.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    function getOrdersInfoRespectingBalancesAndAllowances(\n', '        IERC20 token,\n', '        IZrxExchange zrx,\n', '        address zrxTokenProxy,\n', '        bool respectIntersections,\n', '        LibOrder.Order[] memory orders\n', '    )\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo[] memory ordersInfo)\n', '    {\n', '        ordersInfo = zrx.getOrdersInfo(orders);\n', '\n', '        for (uint i = 0; i < ordersInfo.length; i++) {\n', '\n', '            uint256 remainingOrderTakerAmount = orders[i].takerAssetAmount.sub(ordersInfo[i].orderTakerAssetFilledAmount);\n', '\n', '            uint256 allowance = token.allowance(orders[i].takerAddress, zrxTokenProxy);\n', '            uint256 balance = token.balanceOf(orders[i].takerAddress);\n', '            uint256 possibleMakerAmount = (allowance < balance) ? allowance : balance;\n', '            uint256 possibleTakerAmount = possibleMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\n', '\n', '            if (possibleTakerAmount < remainingOrderTakerAmount) {\n', '                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(possibleTakerAmount);\n', '            }\n', '\n', '            if (respectIntersections) {\n', '                for (uint j = 0; j < i; j++) {\n', '                    if (orders[j].makerAddress == orders[i].makerAddress) {\n', '                        ordersInfo[i].orderTakerAssetFilledAmount = ordersInfo[i].orderTakerAssetFilledAmount.add(orders[j].takerAssetAmount);\n', '\n', '                        if (ordersInfo[i].orderTakerAssetFilledAmount > orders[i].takerAssetAmount) {\n', '                            ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount;\n', '                            break;\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']