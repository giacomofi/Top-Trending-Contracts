['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-05\n', '*/\n', '\n', 'pragma solidity ^0.5.8;\n', '\n', '/*\n', '    IdeaFeX Token crowdsale contract\n', '\n', '    Deployed to     : 0xa0f9783497969a160d640bc8a0f5d53838a39416\n', '    IFX token       : 0x2CF588136b15E47b555331d2f5258063AE6D01ed\n', '    Funds wallet    : 0x1bD99BA31f1056F962e017410c9514dD4d6da4c6\n', '    Supply for sale : 400,000,000.000000000000000000\n', '    Rate            : 2000 IFX = 1 ETH\n', '    Bonus           : 40% before 20% sold\n', '                      30% between 20% and 40% sold\n', '                      20% between 40% and 60% sold\n', '                      10% between 60% and 80% sold\n', '*/\n', '\n', '\n', '/* Safe maths */\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "Addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a, "Subtraction overflow");\n', '        uint c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a==0){\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, "Multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        require(b > 0,"Division by 0");\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint a, uint b) internal pure returns (uint) {\n', '        require(b != 0, "Modulo by 0");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/* ERC20 standard interface */\n', '\n', 'interface ERC20Interface {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '\n', '    event Transfer(address indexed sender, address indexed recipient, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/* Safe ERC20 */\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint;\n', '\n', '    function safeTransferFrom(ERC20Interface token, address from, address recipient, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, recipient, value));\n', '    }\n', '\n', '    function callOptionalReturn(ERC20Interface token, bytes memory data) private {\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/* No nested calls */\n', '\n', 'contract ReentrancyGuard {\n', '    uint private _guardCounter;\n', '\n', '    constructor () internal {\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', '\n', '/* IFX crowdsale */\n', '\n', 'contract IFXCrowdsale is ReentrancyGuard {\n', '    using SafeMath for uint;\n', '    using SafeERC20 for ERC20Interface;\n', '\n', '    // Addresses!!!\n', '    ERC20Interface private _IFX = ERC20Interface(0x2CF588136b15E47b555331d2f5258063AE6D01ed);\n', '    address payable private _fundingWallet = 0x1bD99BA31f1056F962e017410c9514dD4d6da4c6;\n', '    address payable private _tokenSaleWallet = 0x6924E015c192C0f1839a432B49e1e96e06571227;\n', '\n', '    uint private _rate = 2000;\n', '    uint private _weiRaised;\n', '    uint private _ifxSold;\n', '    uint private _bonus = 40;\n', '    uint private _rateCurrent = 2800;\n', '\n', '    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint ethValue, uint ifxAmount);\n', '\n', '\n', '    // Basics\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function token() public view returns (ERC20Interface) {\n', '        return _IFX;\n', '    }\n', '\n', '    function fundingWallet() public view returns (address payable) {\n', '        return _fundingWallet;\n', '    }\n', '\n', '    function rate() public view returns (uint) {\n', '        return _rate;\n', '    }\n', '\n', '    function rateWithBonus() public view returns (uint){\n', '        return _rateCurrent;\n', '    }\n', '\n', '    function bonus() public view returns (uint) {\n', '        return _bonus;\n', '    }\n', '\n', '    function weiRaised() public view returns (uint) {\n', '        return _weiRaised;\n', '    }\n', '\n', '    function ifxSold() public view returns (uint) {\n', '        return _ifxSold;\n', '    }\n', '\n', '\n', '    // Default when people send ETH to contract address\n', '\n', '    function buyTokens(address beneficiary) public nonReentrant payable {\n', '\n', '        // Ensures that the call is valid\n', '        require(beneficiary != address(0), "Beneficiary is zero address");\n', '        require(msg.value != 0, "Value is 0");\n', '\n', '        // Obtain token amount\n', '        uint tokenAmount = msg.value.mul(_rateCurrent);\n', '\n', '        // Ensures that the hard cap is not breached\n', '        require(_ifxSold + tokenAmount < 400000000 * 10**18, "Hard cap reached");\n', '\n', '        // Records the purchase internally\n', '        _weiRaised = _weiRaised.add(msg.value);\n', '        _ifxSold = _ifxSold.add(tokenAmount);\n', '\n', '        // Update the bonus after each purchase\n', '        _currentBonus();\n', '\n', '        // Process the purchase\n', '        _IFX.safeTransferFrom(_tokenSaleWallet, beneficiary, tokenAmount);\n', '        _fundingWallet.transfer(msg.value);\n', '\n', '        // Announce the purchase event\n', '        emit TokensPurchased(msg.sender, beneficiary, msg.value, tokenAmount);\n', '    }\n', '\n', '\n', '    // Bonus\n', '\n', '    function _currentBonus() internal {\n', '        if(_ifxSold < 80000000 * 10**18){\n', '            _bonus = 40;\n', '        } else if(_ifxSold >= 80000000 * 10**18 && _ifxSold < 160000000 * 10**18){\n', '            _bonus = 30;\n', '        } else if(_ifxSold >= 160000000 * 10**18 && _ifxSold < 240000000 * 10**18){\n', '            _bonus = 20;\n', '        } else if(_ifxSold >= 240000000 * 10**18 && _ifxSold < 320000000 * 10**18){\n', '            _bonus = 10;\n', '        } else if(_ifxSold >= 320000000 * 10**18){\n', '            _bonus = 0;\n', '        }\n', '\n', '        // _rate === 2000\n', '        // _rate / 100 === 20\n', '        // (_bonus + 100) * _rate / 100 === _bonus * 20 + _rate\n', '        _rateCurrent = _bonus * 20 + 2000;\n', '    }\n', '}']
['pragma solidity ^0.5.8;\n', '\n', '/*\n', '    IdeaFeX Token crowdsale contract\n', '\n', '    Deployed to     : 0xa0f9783497969a160d640bc8a0f5d53838a39416\n', '    IFX token       : 0x2CF588136b15E47b555331d2f5258063AE6D01ed\n', '    Funds wallet    : 0x1bD99BA31f1056F962e017410c9514dD4d6da4c6\n', '    Supply for sale : 400,000,000.000000000000000000\n', '    Rate            : 2000 IFX = 1 ETH\n', '    Bonus           : 40% before 20% sold\n', '                      30% between 20% and 40% sold\n', '                      20% between 40% and 60% sold\n', '                      10% between 60% and 80% sold\n', '*/\n', '\n', '\n', '/* Safe maths */\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "Addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a, "Subtraction overflow");\n', '        uint c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a==0){\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, "Multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        require(b > 0,"Division by 0");\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint a, uint b) internal pure returns (uint) {\n', '        require(b != 0, "Modulo by 0");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/* ERC20 standard interface */\n', '\n', 'interface ERC20Interface {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '\n', '    event Transfer(address indexed sender, address indexed recipient, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/* Safe ERC20 */\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint;\n', '\n', '    function safeTransferFrom(ERC20Interface token, address from, address recipient, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, recipient, value));\n', '    }\n', '\n', '    function callOptionalReturn(ERC20Interface token, bytes memory data) private {\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/* No nested calls */\n', '\n', 'contract ReentrancyGuard {\n', '    uint private _guardCounter;\n', '\n', '    constructor () internal {\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', '\n', '/* IFX crowdsale */\n', '\n', 'contract IFXCrowdsale is ReentrancyGuard {\n', '    using SafeMath for uint;\n', '    using SafeERC20 for ERC20Interface;\n', '\n', '    // Addresses!!!\n', '    ERC20Interface private _IFX = ERC20Interface(0x2CF588136b15E47b555331d2f5258063AE6D01ed);\n', '    address payable private _fundingWallet = 0x1bD99BA31f1056F962e017410c9514dD4d6da4c6;\n', '    address payable private _tokenSaleWallet = 0x6924E015c192C0f1839a432B49e1e96e06571227;\n', '\n', '    uint private _rate = 2000;\n', '    uint private _weiRaised;\n', '    uint private _ifxSold;\n', '    uint private _bonus = 40;\n', '    uint private _rateCurrent = 2800;\n', '\n', '    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint ethValue, uint ifxAmount);\n', '\n', '\n', '    // Basics\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function token() public view returns (ERC20Interface) {\n', '        return _IFX;\n', '    }\n', '\n', '    function fundingWallet() public view returns (address payable) {\n', '        return _fundingWallet;\n', '    }\n', '\n', '    function rate() public view returns (uint) {\n', '        return _rate;\n', '    }\n', '\n', '    function rateWithBonus() public view returns (uint){\n', '        return _rateCurrent;\n', '    }\n', '\n', '    function bonus() public view returns (uint) {\n', '        return _bonus;\n', '    }\n', '\n', '    function weiRaised() public view returns (uint) {\n', '        return _weiRaised;\n', '    }\n', '\n', '    function ifxSold() public view returns (uint) {\n', '        return _ifxSold;\n', '    }\n', '\n', '\n', '    // Default when people send ETH to contract address\n', '\n', '    function buyTokens(address beneficiary) public nonReentrant payable {\n', '\n', '        // Ensures that the call is valid\n', '        require(beneficiary != address(0), "Beneficiary is zero address");\n', '        require(msg.value != 0, "Value is 0");\n', '\n', '        // Obtain token amount\n', '        uint tokenAmount = msg.value.mul(_rateCurrent);\n', '\n', '        // Ensures that the hard cap is not breached\n', '        require(_ifxSold + tokenAmount < 400000000 * 10**18, "Hard cap reached");\n', '\n', '        // Records the purchase internally\n', '        _weiRaised = _weiRaised.add(msg.value);\n', '        _ifxSold = _ifxSold.add(tokenAmount);\n', '\n', '        // Update the bonus after each purchase\n', '        _currentBonus();\n', '\n', '        // Process the purchase\n', '        _IFX.safeTransferFrom(_tokenSaleWallet, beneficiary, tokenAmount);\n', '        _fundingWallet.transfer(msg.value);\n', '\n', '        // Announce the purchase event\n', '        emit TokensPurchased(msg.sender, beneficiary, msg.value, tokenAmount);\n', '    }\n', '\n', '\n', '    // Bonus\n', '\n', '    function _currentBonus() internal {\n', '        if(_ifxSold < 80000000 * 10**18){\n', '            _bonus = 40;\n', '        } else if(_ifxSold >= 80000000 * 10**18 && _ifxSold < 160000000 * 10**18){\n', '            _bonus = 30;\n', '        } else if(_ifxSold >= 160000000 * 10**18 && _ifxSold < 240000000 * 10**18){\n', '            _bonus = 20;\n', '        } else if(_ifxSold >= 240000000 * 10**18 && _ifxSold < 320000000 * 10**18){\n', '            _bonus = 10;\n', '        } else if(_ifxSold >= 320000000 * 10**18){\n', '            _bonus = 0;\n', '        }\n', '\n', '        // _rate === 2000\n', '        // _rate / 100 === 20\n', '        // (_bonus + 100) * _rate / 100 === _bonus * 20 + _rate\n', '        _rateCurrent = _bonus * 20 + 2000;\n', '    }\n', '}']
