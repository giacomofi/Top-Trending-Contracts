['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' *\n', ' * Subtraction and addition only here.\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title A contract for generating unique identifiers for any requests.\n', ' * @dev Any contract that supports requesting inherits this contract to\n', ' * ensure request to be unique.\n', ' */\n', 'contract RequestUid {\n', '\n', '    /**\n', '     * MEMBER: counter for request.\n', '    */\n', '    uint256 public requestCount;\n', '\n', '    /**\n', '     * CONSTRUCTOR: initial counter with 0.\n', '     */\n', '    constructor() public {\n', '        requestCount = 0;\n', '    }\n', '    \n', '    /**\n', '     * METHOD: generate a new identifier.\n', '     * @dev 3 parameters as inputs:\n', '     * 1. blockhash of previous block;\n', '     * 2. the address of the initialized contract which is requested;\n', '     * 3. the value of counter.\n', '     * @return a 32-byte uid.\n', '     */\n', '    function generateRequestUid() internal returns (bytes32 uid) {\n', '        return keccak256(abi.encodePacked(blockhash(block.number - uint256(1)), address(this), ++requestCount));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev This contract makes the inheritor have the functionality if the\n', ' * inheritor authorize the admin.\n', ' */\n', 'contract AdminUpgradeable is RequestUid {\n', '    \n', '    /**\n', '     * Event\n', '     * @dev After requesting of admin change, emit an event.\n', '     */\n', '    event AdminChangeRequested(bytes32 _uid, address _msgSender, address _newAdmin);\n', '    \n', '    /**\n', '     * Event\n', '     * @dev After confirming a request of admin change, emit an event.\n', '     */\n', '    event AdminChangeConfirmed(bytes32 _uid, address _newAdmin);\n', '    \n', '    /**\n', '     * STRUCT: A struct defined to store an request of admin change.\n', '     */\n', '    struct AdminChangeRequest {\n', '        address newAdminAddress;\n', '    }\n', '    \n', '    /**\n', '     * MEMBER: admin address(account address or contract address) which\n', '     * is authorize by the inheritor.\n', '     */\n', '    address public admin;\n', '    \n', '    /**\n', '     * MEMBER: a list of requests submitted.\n', '     */\n', '    mapping (bytes32 => AdminChangeRequest) public adminChangeReqs;\n', '    \n', '    /**\n', '     * MODIFIER: The operations from admin is allowed only.\n', '     */\n', '    modifier adminOperations {\n', '        require(msg.sender == admin, "admin can call this method only");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * CONSTRUCTOR: Initialize with an admin address.\n', '     */\n', '    constructor (address _admin) public RequestUid() {\n', '        admin = _admin;\n', '    }\n', '    \n', '    /**\n', '     * METHOD: Upgrade the admin ---- request.\n', '     * @dev Request changing the admin address authorized.\n', '     * Anyone can call this method to submit a request to change\n', '     * the admin address. It will be pending until admin address\n', '     * comfirming the request, and the admin changes.\n', '     * @param _newAdmin The address of new admin, account or contract.\n', '     * @return uid The unique id of the request.\n', '     */\n', '    function requestAdminChange(address _newAdmin) public returns (bytes32 uid) {\n', '        require(_newAdmin != address(0), "admin is not 0 address");\n', '\n', '        uid = generateRequestUid();\n', '\n', '        adminChangeReqs[uid] = AdminChangeRequest({\n', '            newAdminAddress: _newAdmin\n', '            });\n', '\n', '        emit AdminChangeRequested(uid, msg.sender, _newAdmin);\n', '    }\n', '    \n', '    /**\n', '     * METHOD: Upgrade the admin ---- confirm.\n', '     * @dev Confirm a reqeust of admin change storing in the mapping\n', '     * of `adminChangeReqs`. The operation is authorized to the old\n', '     * admin only. The new admin will be authorized after the method\n', '     * called successfully.\n', '     * @param _uid The uid of request to change admin.\n', '     */\n', '    function confirmAdminChange(bytes32 _uid) public adminOperations {\n', '        admin = getAdminChangeReq(_uid);\n', '\n', '        delete adminChangeReqs[_uid];\n', '\n', '        emit AdminChangeConfirmed(_uid, admin);\n', '    }\n', '    \n', '    /**\n', '     * METHOD: Get the address of an admin request by uid.\n', '     * @dev It is a private method which gets address of an admin\n', '     * in the mapping `adminChangeReqs`\n', '     * @param _uid The uid of request to change admin.\n', '     * @return _newAdminAddress The address of new admin in the pending requests\n', '     */\n', '    function getAdminChangeReq(bytes32 _uid) private view returns (address _newAdminAddress) {\n', '        AdminChangeRequest storage changeRequest = adminChangeReqs[_uid];\n', '\n', '        require(changeRequest.newAdminAddress != address(0));\n', '\n', '        return changeRequest.newAdminAddress;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev This is a contract which will be inherited by BICAProxy and BICALedger.\n', ' */\n', 'contract BICALogicUpgradeable is AdminUpgradeable  {\n', '\n', '    /**\n', '     * Event\n', '     * @dev After requesting of logic contract address change, emit an event.\n', '     */\n', '    event LogicChangeRequested(bytes32 _uid, address _msgSender, address _newLogic);\n', '\n', '    /**\n', '     * Event\n', '     * @dev After confirming a request of logic contract address change, emit an event.\n', '     */\n', '    event LogicChangeConfirmed(bytes32 _uid, address _newLogic);\n', '\n', '    /**\n', '     * STRUCT: A struct defined to store an request of Logic contract address change.\n', '     */\n', '    struct LogicChangeRequest {\n', '        address newLogicAddress;\n', '    }\n', '\n', '    /**\n', '     * MEMBER: BICALogic address(a contract address) which implements logics of token.\n', '     */\n', '    BICALogic public bicaLogic;\n', '\n', '    /**\n', '     * MEMBER: a list of requests of logic change submitted\n', '     */\n', '    mapping (bytes32 => LogicChangeRequest) public logicChangeReqs;\n', '\n', '    /**\n', '     * MODIFIER: The call from bicaLogic is allowed only.\n', '     */\n', '    modifier onlyLogic {\n', '        require(msg.sender == address(bicaLogic), "only logic contract is authorized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * CONSTRUCTOR: Initialize with an admin address which is authorized to change\n', '     * the value of bicaLogic.\n', '     */\n', '    constructor (address _admin) public AdminUpgradeable(_admin) {\n', '        bicaLogic = BICALogic(0x0);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Upgrade the logic contract ---- request.\n', '     * @dev Request changing the logic contract address authorized.\n', '     * Anyone can call this method to submit a request to change\n', '     * the logic address. It will be pending until admin address\n', '     * comfirming the request, and the logic contract address changes, i.e.\n', '     * the value of bicaLogic changes.\n', '     * @param _newLogic The address of new logic contract.\n', '     * @return uid The unique id of the request.\n', '     */\n', '    function requestLogicChange(address _newLogic) public returns (bytes32 uid) {\n', '        require(_newLogic != address(0), "new logic address can not be 0");\n', '\n', '        uid = generateRequestUid();\n', '\n', '        logicChangeReqs[uid] = LogicChangeRequest({\n', '            newLogicAddress: _newLogic\n', '            });\n', '\n', '        emit LogicChangeRequested(uid, msg.sender, _newLogic);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Upgrade the logic contract ---- confirm.\n', '     * @dev Confirm a reqeust of logic contract change storing in the\n', '     * mapping of `logicChangeReqs`. The operation is authorized to\n', '     * the admin only.\n', '     * @param _uid The uid of request to change logic contract.\n', '     */\n', '    function confirmLogicChange(bytes32 _uid) public adminOperations {\n', '        bicaLogic = getLogicChangeReq(_uid);\n', '\n', '        delete logicChangeReqs[_uid];\n', '\n', '        emit LogicChangeConfirmed(_uid, address(bicaLogic));\n', '    }\n', '\n', '    /**\n', '     * METHOD: Get the address of an logic contract address request by uid.\n', '     * @dev It is a private method which gets address of an address\n', '     * in the mapping `adminChangeReqs`\n', '     * @param _uid The uid of request to change logic contract address.\n', '     * @return _newLogicAddress The address of new logic contract address\n', '     * in the pending requests\n', '     */\n', '    function getLogicChangeReq(bytes32 _uid) private view returns (BICALogic _newLogicAddress) {\n', '        LogicChangeRequest storage changeRequest = logicChangeReqs[_uid];\n', '\n', '        require(changeRequest.newLogicAddress != address(0));\n', '\n', '        return BICALogic(changeRequest.newLogicAddress);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev This contract is the core contract of all logic. It links `bicaProxy`\n', ' * and `bicaLedger`. It implements the issue of new amount of token, burn some\n', " * value of someone's token.\n", ' */\n', 'contract BICALogic is AdminUpgradeable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Event\n', '     * @dev After issuing an ammout of BICA, emit an event for the value of requester.\n', '     */\n', '    event Requester(address _supplyAddress, address _receiver, uint256 _valueRequested);\n', '\n', '    /**\n', '     * Event\n', '     * @dev After issuing an ammout of BICA, emit an event of paying margin.\n', '     */\n', '    event PayMargin(address _supplyAddress, address _marginAddress, uint256 _marginValue);\n', '\n', '\n', '    /**\n', '     * Event\n', '     * @dev After issuing an ammout of BICA, emit an event of paying interest.\n', '     */\n', '    event PayInterest(address _supplyAddress, address _interestAddress, uint256 _interestValue);\n', '\n', '\n', '    /**\n', '     * Event\n', '     * @dev After issuing an ammout of BICA, emit an event of paying multi fee.\n', '     */\n', '    event PayMultiFee(address _supplyAddress, address _feeAddress, uint256 _feeValue);\n', '\n', '    /**\n', '     * Event\n', '     * @dev After freezing a user address, emit an event in logic contract.\n', '     */\n', '    event AddressFrozenInLogic(address indexed addr);\n', '\n', '    /**\n', '     * Event\n', '     * @dev After unfreezing a user address, emit an event in logic contract.\n', '     */\n', '    event AddressUnfrozenInLogic(address indexed addr);\n', '\n', '    /**\n', '     * MEMBER: A reference to the proxy contract.\n', '     * It links the proxy contract in one direction.\n', '     */\n', '    BICAProxy public bicaProxy;\n', '\n', '    /**\n', '     * MEMBER: A reference to the ledger contract.\n', '     * It links the ledger contract in one direction.\n', '     */\n', '    BICALedger public bicaLedger;\n', '\n', '    /**\n', '     * MODIFIER: The call from bicaProxy is allowed only.\n', '     */\n', '    modifier onlyProxy {\n', '        require(msg.sender == address(bicaProxy), "only the proxy contract allowed only");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * CONSTRUCTOR: Initialize with the proxy contract address, the ledger\n', '     * contract and an admin address.\n', '     */\n', '    constructor (address _bicaProxy, address _bicaLedger, address _admin) public  AdminUpgradeable(_admin) {\n', '        bicaProxy = BICAProxy(_bicaProxy);\n', '        bicaLedger = BICALedger(_bicaLedger);\n', '    }\n', '    \n', '    /**\n', '     * METHOD: `approve` operation in logic contract.\n', '     * @dev Receive the call request of `approve` from proxy contract and\n', '     * request approve operation to ledger contract. Need to check the sender\n', '     * and spender are not frozen\n', '     * @param _sender The address initiating the approval in proxy.\n', '     * @return success or not.\n', '     */\n', '    function approveWithSender(address _sender, address _spender, uint256 _value) public onlyProxy returns (bool success){\n', '        require(_spender != address(0));\n', '\n', '        bool senderFrozen = bicaLedger.getFrozenByAddress(_sender);\n', '        require(!senderFrozen, "Sender is frozen");\n', '\n', '        bool spenderFrozen = bicaLedger.getFrozenByAddress(_spender);\n', '        require(!spenderFrozen, "Spender is frozen");\n', '\n', '        bicaLedger.setAllowance(_sender, _spender, _value);\n', '        bicaProxy.emitApproval(_sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Core logic of the `increaseApproval` method in proxy contract.\n', '     * @dev Receive the call request of `increaseApproval` from proxy contract\n', '     * and request increasing value of allownce to ledger contract. Need to\n', '     * check the sender\n', '     * and spender are not frozen\n', '     * @param _sender The address initiating the approval in proxy.\n', '     * @return success or not.\n', '     */\n', '    function increaseApprovalWithSender(address _sender, address _spender, uint256 _addedValue) public onlyProxy returns (bool success) {\n', '        require(_spender != address(0));\n', '\n', '        bool senderFrozen = bicaLedger.getFrozenByAddress(_sender);\n', '        require(!senderFrozen, "Sender is frozen");\n', '\n', '        bool spenderFrozen = bicaLedger.getFrozenByAddress(_spender);\n', '        require(!spenderFrozen, "Spender is frozen");\n', '\n', '        uint256 currentAllowance = bicaLedger.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance.add(_addedValue);\n', '\n', '        require(newAllowance >= currentAllowance);\n', '\n', '        bicaLedger.setAllowance(_sender, _spender, newAllowance);\n', '        bicaProxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * METHOD: Core logic of the `decreaseApproval` method in proxy contract.\n', '    * @dev Receive the call request of `decreaseApproval` from proxy contract\n', '    * and request decreasing value of allownce to ledger contract. Need to\n', '    * check the sender and spender are not frozen\n', '    * @param _sender The address initiating the approval in proxy.\n', '    * @return success or not.\n', '    */\n', '    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyProxy returns (bool success) {\n', '        require(_spender != address(0));\n', '\n', '        bool senderFrozen = bicaLedger.getFrozenByAddress(_sender);\n', '        require(!senderFrozen, "Sender is frozen");\n', '\n', '        bool spenderFrozen = bicaLedger.getFrozenByAddress(_spender);\n', '        require(!spenderFrozen, "Spender is frozen");\n', '        \n', '        uint256 currentAllowance = bicaLedger.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance.sub(_subtractedValue);\n', '\n', '        require(newAllowance <= currentAllowance);\n', '\n', '        bicaLedger.setAllowance(_sender, _spender, newAllowance);\n', '        bicaProxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * METHOD: Core logic of comfirming request of issuetoken to a specified receiver.\n', '     * @dev Admin can issue an ammout of BICA only.\n', '     * @param _requesterAccount The address of request account.\n', '     * @param _requestValue The value of requester.\n', '     * @param _marginAccount The address of margin account.\n', '     * @param _marginValue The value of token to pay to margin account.\n', '     * @param _interestAccount The address accepting interest.\n', '     * @param _interestValue The value of interest.\n', '     * @param _otherFeeAddress The address accepting multi fees.\n', '     * @param _otherFeeValue The value of other fees.\n', '     */\n', '    function issue(address _requesterAccount, uint256 _requestValue,\n', '        address _marginAccount, uint256 _marginValue,\n', '        address _interestAccount, uint256 _interestValue,\n', '        address _otherFeeAddress, uint256 _otherFeeValue) public adminOperations {\n', '\n', '        require(_requesterAccount != address(0));\n', '        require(_marginAccount != address(0));\n', '        require(_interestAccount != address(0));\n', '        require(_otherFeeAddress != address(0));\n', '\n', '        require(!bicaLedger.getFrozenByAddress(_requesterAccount), "Requester is frozen");\n', '        require(!bicaLedger.getFrozenByAddress(_marginAccount), "Margin account is frozen");\n', '        require(!bicaLedger.getFrozenByAddress(_interestAccount), "Interest account is frozen");\n', '        require(!bicaLedger.getFrozenByAddress(_otherFeeAddress), "Other fee account is frozen");\n', '\n', '        uint256 requestTotalValue = _marginValue.add(_interestValue).add(_otherFeeValue).add(_requestValue);\n', '\n', '        uint256 supply = bicaLedger.totalSupply();\n', '        uint256 newSupply = supply.add(requestTotalValue);\n', '\n', '        if (newSupply >= supply) {\n', '            bicaLedger.setTotalSupply(newSupply);\n', '            bicaLedger.addBalance(_marginAccount, _marginValue);\n', '            bicaLedger.addBalance(_interestAccount, _interestValue);\n', '            if ( _otherFeeValue > 0 ){\n', '                bicaLedger.addBalance(_otherFeeAddress, _otherFeeValue);\n', '            }\n', '            bicaLedger.addBalance(_requesterAccount, _requestValue);\n', '\n', '            emit Requester(msg.sender, _requesterAccount, _requestValue);\n', '            emit PayMargin(msg.sender, _marginAccount, _marginValue);\n', '            emit PayInterest(msg.sender, _interestAccount, _interestValue);\n', '            emit PayMultiFee(msg.sender, _otherFeeAddress, _otherFeeValue);\n', '\n', '            bicaProxy.emitTransfer(address(0), _marginAccount, _marginValue);\n', '            bicaProxy.emitTransfer(address(0), _interestAccount, _interestValue);\n', '            bicaProxy.emitTransfer(address(0), _otherFeeAddress, _otherFeeValue);\n', '            bicaProxy.emitTransfer(address(0), _requesterAccount, _requestValue);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * METHOD: Burn the specified value of the message sender's balance.\n", '     * @dev Admin can call this method to burn some amount of BICA.\n', '     * @param _value The amount of token to be burned.\n', '     * @return success or not.\n', '     */\n', '    function burn(uint256 _value) public adminOperations returns (bool success) {\n', '        bool burnerFrozen = bicaLedger.getFrozenByAddress(msg.sender);\n', '        require(!burnerFrozen, "Burner is frozen");\n', '\n', '        uint256 balanceOfSender = bicaLedger.balances(msg.sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        bicaLedger.setBalance(msg.sender, balanceOfSender.sub(_value));\n', '        bicaLedger.setTotalSupply(bicaLedger.totalSupply().sub(_value));\n', '\n', '        bicaProxy.emitTransfer(msg.sender, address(0), _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Freeze a user address.\n', '     * @dev Admin can call this method to freeze a user account.\n', '     * @param _user user address.\n', '     */\n', '    function freeze(address _user) public adminOperations {\n', '        require(_user != address(0), "the address to be frozen cannot be 0");\n', '        bicaLedger.freezeByAddress(_user);\n', '        emit AddressFrozenInLogic(_user);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Unfreeze a user address.\n', '     * @dev Admin can call this method to unfreeze a user account.\n', '     * @param _user user address.\n', '     */\n', '    function unfreeze(address _user) public adminOperations {\n', '        require(_user != address(0), "the address to be unfrozen cannot be 0");\n', '        bicaLedger.unfreezeByAddress(_user);\n', '        emit AddressUnfrozenInLogic(_user);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Core logic of `transferFrom` interface method in ERC20 token standard.\n', '     * @dev It can only be called by the `bicaProxy` contract.\n', '     * @param _sender The address initiating the approval in proxy.\n', '     * @return success or not.\n', '     */\n', '    function transferFromWithSender(address _sender, address _from, address _to, uint256 _value) public onlyProxy returns (bool success){\n', '        require(_to != address(0));\n', '\n', '        bool senderFrozen = bicaLedger.getFrozenByAddress(_sender);\n', '        require(!senderFrozen, "Sender is frozen");\n', '        bool fromFrozen = bicaLedger.getFrozenByAddress(_from);\n', '        require(!fromFrozen, "`from` is frozen");\n', '        bool toFrozen = bicaLedger.getFrozenByAddress(_to);\n', '        require(!toFrozen, "`to` is frozen");\n', '\n', '        uint256 balanceOfFrom = bicaLedger.balances(_from);\n', '        require(_value <= balanceOfFrom);\n', '\n', '        uint256 senderAllowance = bicaLedger.allowed(_from, _sender);\n', '        require(_value <= senderAllowance);\n', '\n', '        bicaLedger.setBalance(_from, balanceOfFrom.sub(_value));\n', '\n', '        bicaLedger.addBalance(_to, _value);\n', '\n', '        bicaLedger.setAllowance(_from, _sender, senderAllowance.sub(_value));\n', '\n', '        bicaProxy.emitTransfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * METHOD: Core logic of `transfer` interface method in ERC20 token standard.\n', '    * @dev It can only be called by the `bicaProxy` contract.\n', '    * @param _sender The address initiating the approval in proxy.\n', '    * @return success or not.\n', '    */\n', '    function transferWithSender(address _sender, address _to, uint256 _value) public onlyProxy returns (bool success){\n', '        require(_to != address(0));\n', '\n', '        bool senderFrozen = bicaLedger.getFrozenByAddress(_sender);\n', '        require(!senderFrozen, "sender is frozen");\n', '        bool toFrozen = bicaLedger.getFrozenByAddress(_to);\n', '        require(!toFrozen, "to is frozen");\n', '\n', '        uint256 balanceOfSender = bicaLedger.balances(_sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        bicaLedger.setBalance(_sender, balanceOfSender.sub(_value));\n', '\n', '        bicaLedger.addBalance(_to, _value);\n', '\n', '        bicaProxy.emitTransfer(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Core logic of `totalSupply` interface method in ERC20 token standard.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return bicaLedger.totalSupply();\n', '    }\n', '\n', '    /**\n', '     * METHOD: Core logic of `balanceOf` interface method in ERC20 token standard.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return bicaLedger.balances(_owner);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Core logic of `allowance` interface method in ERC20 token standard.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return bicaLedger.allowed(_owner, _spender);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev This contract is the core storage contract of ERC20 token ledger.\n', ' * It defines some operations of data in the storage.\n', ' */\n', 'contract BICALedger is BICALogicUpgradeable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * MEMBER: The total supply of the token.\n', '     */\n', '    uint256 public totalSupply;\n', '\n', '    /**\n', '     * MEMBER: The mapping of balance of users.\n', '     */\n', '    mapping (address => uint256) public balances;\n', '\n', '    /**\n', '     * MEMBER: The mapping of allowance of users.\n', '     */\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    /**\n', '     * MEMBER: The mapping of frozen addresses.\n', '     */\n', '    mapping(address => bool) public frozen;\n', '\n', '    /**\n', '     * Event\n', '     * @dev After freezing a user address, emit an event in ledger contract.\n', '     */\n', '    event AddressFrozen(address indexed addr);\n', '\n', '    /**\n', '     * Event\n', '     * @dev After unfreezing a user address, emit an event in ledger contract.\n', '     */\n', '    event AddressUnfrozen(address indexed addr);\n', '\n', '    /**\n', '     * CONSTRUCTOR: Initialize with an admin address.\n', '     */\n', '    constructor (address _admin) public BICALogicUpgradeable(_admin) {\n', '        totalSupply = 0;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Check an address is frozen or not.\n', '     * @dev check an address is frozen or not. It can be call by logic contract only.\n', '     * @param _user user addree.\n', '     */\n', '    function getFrozenByAddress(address _user) public view onlyLogic returns (bool frozenOrNot) {\n', '        // frozenOrNot = false;\n', '        return frozen[_user];\n', '    }\n', '\n', '    /**\n', '     * METHOD: Freeze an address.\n', '     * @dev Freeze an address. It can be called by logic contract only.\n', '     * @param _user user addree.\n', '     */\n', '    function freezeByAddress(address _user) public onlyLogic {\n', '        require(!frozen[_user], "user already frozen");\n', '        frozen[_user] = true;\n', '        emit AddressFrozen(_user);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Unfreeze an address.\n', '     * @dev Unfreeze an address. It can be called by logic contract only.\n', '     * @param _user user addree.\n', '     */\n', '    function unfreezeByAddress(address _user) public onlyLogic {\n', '        require(frozen[_user], "address already unfrozen");\n', '        frozen[_user] = false;\n', '        emit AddressUnfrozen(_user);\n', '    }\n', '\n', '\n', '    /**\n', '     * METHOD: Set `totalSupply` in the ledger contract.\n', '     * @dev It will be called when a new issue is confirmed. It can be called\n', '     * by logic contract only.\n', '     * @param _newTotalSupply The value of new total supply.\n', '     */\n', '    function setTotalSupply(uint256 _newTotalSupply) public onlyLogic {\n', '        totalSupply = _newTotalSupply;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Set allowance for owner to a spender in the ledger contract.\n', '     * @dev It will be called when the owner modify the allowance to the\n', '     * spender. It can be called by logic contract only.\n', '     * @param _owner The address allow spender to spend.\n', '     * @param _spender The address allowed to spend.\n', '     * @param _value The limit of how much can be spent by `_spender`.\n', '     */\n', '    function setAllowance(address _owner, address _spender, uint256 _value) public onlyLogic {\n', '        allowed[_owner][_spender] = _value;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Set balance of the owner in the ledger contract.\n', '     * @dev It will be called when the owner modify the balance of owner\n', '     * in logic. It can be called by logic contract only.\n', '     * @param _owner The address who owns the balance.\n', '     * @param _newBalance The balance to be set.\n', '     */\n', '    function setBalance(address _owner, uint256 _newBalance) public onlyLogic {\n', '        balances[_owner] = _newBalance;\n', '    }\n', '\n', '    /**\n', '     * METHOD: Add balance of the owner in the ledger contract.\n', '     * @dev It will be called when the balance of owner increases.\n', '     * It can be called by logic contract only.\n', '     * @param _owner The address who owns the balance.\n', '     * @param _balanceIncrease The balance to be add.\n', '     */\n', '    function addBalance(address _owner, uint256 _balanceIncrease) public onlyLogic {\n', '        balances[_owner] = balances[_owner].add(_balanceIncrease);\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @dev This contract is a viewer of ERC20 token standard.\n', ' * It includes no logic and data.\n', ' */\n', 'contract BICAProxy is ERC20Interface, BICALogicUpgradeable {\n', '\n', '    /**\n', '     * MEMBER: The name of the token.\n', '     */\n', '    string public name;\n', '\n', '    /**\n', '     * MEMBER: The symbol of the token.\n', '     */\n', '    string public symbol;\n', '\n', '    /**\n', '     * MEMBER: The number of decimals of the token.\n', '     */\n', '    uint public decimals;\n', '\n', '    /**\n', '     * CONSTRUCTOR: Initialize with an admin address.\n', '     */\n', '    constructor (address _admin) public BICALogicUpgradeable(_admin){\n', '        name = "BitCapital Coin";\n', "        symbol = 'BICA';\n", '        decimals = 2;\n', '    }\n', '    \n', '    /**\n', '     * METHOD: Get `totalSupply` of token.\n', '     * @dev It is the standard method of ERC20.\n', '     * @return The total token supply.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return bicaLogic.totalSupply();\n', '    }\n', '\n', '    /**\n', '     * METHOD: Get the balance of a owner.\n', '     * @dev It is the standard method of ERC20.\n', '     * @return The balance of a owner.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return bicaLogic.balanceOf(_owner);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Emit a Transfer event in proxy contract.\n', '     */\n', '    function emitTransfer(address _from, address _to, uint256 _value) public onlyLogic {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * METHOD: The message sender sends some amount of token to receiver.\n', '     * @dev It will call the logic contract to send some token to receiver.\n', '     * It is the standard method of ERC20.\n', '     * @return success or not\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return bicaLogic.transferWithSender(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Transfer amount of tokens from `_from` to `_to`.\n', '     * @dev It is the standard method of ERC20.\n', '     * @return success or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        return bicaLogic.transferFromWithSender(msg.sender, _from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Emit a Approval event in proxy contract.\n', '     */\n', '    function emitApproval(address _owner, address _spender, uint256 _value) public onlyLogic {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Allow `_spender` to be able to spend `_value` token.\n', '     * @dev It is the standard method of ERC20.\n', '     * @return success or not\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        return bicaLogic.approveWithSender(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Increase allowance value of message sender to `_spender`.\n', '     * @return success or not\n', '     */\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n', '        return bicaLogic.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Decrease allowance value of message sender to `_spender`.\n', '     * @return success or not\n', '     */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n', '        return bicaLogic.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\n', '    }\n', '\n', '    /**\n', '     * METHOD: Return the allowance value of `_owner` to `_spender`.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return bicaLogic.allowance(_owner, _spender);\n', '    }\n', '}']