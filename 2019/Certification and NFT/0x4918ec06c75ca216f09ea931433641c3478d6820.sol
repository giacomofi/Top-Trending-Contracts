['pragma solidity ^0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = _a * _b;\n', '        assert(c / _a == _b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '        return _a / _b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        assert(_b <= _a);\n', '        return _a - _b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '        c = _a + _b;\n', '        assert(c >= _a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeTransfer(\n', '        ERC20Basic _token,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    internal\n', '    {\n', '        require(_token.transfer(_to, _value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        ERC20 _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    internal\n', '    {\n', '        require(_token.transferFrom(_from, _to, _value));\n', '    }\n', '\n', '    function safeApprove(\n', '        ERC20 _token,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '    internal\n', '    {\n', '        require(_token.approve(_spender, _value));\n', '    }\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) internal balances;\n', '\n', '    uint256 internal totalSupply_;\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '}\n', '\n', 'contract MultiSigWallet {\n', '    uint constant public MAX_OWNER_COUNT = 50;\n', '\n', '    event Confirmation(address indexed sender, uint indexed transactionId);\n', '    event Revocation(address indexed sender, uint indexed transactionId);\n', '    event Submission(uint indexed transactionId);\n', '    event Execution(uint indexed transactionId);\n', '    event ExecutionFailure(uint indexed transactionId);\n', '    event Deposit(address indexed sender, uint value);\n', '    event OwnerAddition(address indexed owner);\n', '    event OwnerRemoval(address indexed owner);\n', '    event RequirementChange(uint required);\n', '\n', '    mapping(uint => Transaction) public transactions;\n', '    mapping(uint => mapping(address => bool)) public confirmations;\n', '    mapping(address => bool) public isOwner;\n', '\n', '    address[] public owners;\n', '    uint public required;\n', '    uint public transactionCount;\n', '\n', '    struct Transaction {\n', '        address destination;\n', '        uint value;\n', '        bytes data;\n', '        bool executed;\n', '    }\n', '\n', '    modifier onlyWallet() {\n', '        require(msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier ownerDoesNotExist(address owner) {\n', '        require(!isOwner[owner]);\n', '        _;\n', '    }\n', '\n', '    modifier ownerExists(address owner) {\n', '        require(isOwner[owner]);\n', '        _;\n', '    }\n', '\n', '    modifier transactionExists(uint transactionId) {\n', '        require(transactions[transactionId].destination != 0);\n', '        _;\n', '    }\n', '\n', '    modifier confirmed(uint transactionId, address owner) {\n', '        require(confirmations[transactionId][owner]);\n', '        _;\n', '    }\n', '\n', '    modifier notConfirmed(uint transactionId, address owner) {\n', '        require(!confirmations[transactionId][owner]);\n', '        _;\n', '    }\n', '\n', '    modifier notExecuted(uint transactionId) {\n', '        require(!transactions[transactionId].executed);\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier validRequirement(uint ownerCount, uint _required) {\n', '        bool ownerValid = ownerCount <= MAX_OWNER_COUNT;\n', '        bool ownerNotZero = ownerCount != 0;\n', '        bool requiredValid = _required <= ownerCount;\n', '        bool requiredNotZero = _required != 0;\n', '        require(ownerValid && ownerNotZero && requiredValid && requiredNotZero);\n', '        _;\n', '    }\n', '\n', '    /// @dev Fallback function allows to deposit ether.\n', '    function() payable public {\n', '        fallback();\n', '    }\n', '\n', '    function fallback() payable public {\n', '        if (msg.value > 0) {\n', '            emit Deposit(msg.sender, msg.value);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _required Number of required confirmations.\n', '    constructor(\n', '        address[] _owners,\n', '        uint _required\n', '    ) public validRequirement(_owners.length, _required)\n', '    {\n', '        for (uint i = 0; i < _owners.length; i++) {\n', '            require(!isOwner[_owners[i]] && _owners[i] != 0);\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        owners = _owners;\n', '        required = _required;\n', '    }\n', '\n', '    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of new owner.\n', '    function addOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerDoesNotExist(owner)\n', '    notNull(owner)\n', '    validRequirement(owners.length + 1, required)\n', '    {\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '        emit OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner.\n', '    function removeOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    {\n', '        isOwner[owner] = false;\n', '        for (uint i = 0; i < owners.length - 1; i++)\n', '            if (owners[i] == owner) {\n', '                owners[i] = owners[owners.length - 1];\n', '                break;\n', '            }\n', '        owners.length -= 1;\n', '        if (required > owners.length)\n', '            changeRequirement(owners.length);\n', '        emit OwnerRemoval(owner);\n', '    }\n', '\n', '    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner to be replaced.\n', '    /// @param newOwner Address of new owner.\n', '    function replaceOwner(address owner, address newOwner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    ownerDoesNotExist(newOwner)\n', '    {\n', '        for (uint i = 0; i < owners.length; i++)\n', '            if (owners[i] == owner) {\n', '                owners[i] = newOwner;\n', '                break;\n', '            }\n', '        isOwner[owner] = false;\n', '        isOwner[newOwner] = true;\n', '        emit OwnerRemoval(owner);\n', '        emit OwnerAddition(newOwner);\n', '    }\n', '\n', '    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '    /// @param _required Number of required confirmations.\n', '    function changeRequirement(uint _required)\n', '    public\n', '    onlyWallet\n', '    validRequirement(owners.length, _required)\n', '    {\n', '        required = _required;\n', '        emit RequirementChange(_required);\n', '    }\n', '\n', '    /// @dev Allows an owner to submit and confirm a transaction.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function submitTransaction(address destination, uint value, bytes data)\n', '    public\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = addTransaction(destination, value, data);\n', '        confirmTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function confirmTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    transactionExists(transactionId)\n', '    notConfirmed(transactionId, msg.sender)\n', '    {\n', '        confirmations[transactionId][msg.sender] = true;\n', '        emit Confirmation(msg.sender, transactionId);\n', '        executeTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function revokeConfirmation(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '    {\n', '        confirmations[transactionId][msg.sender] = false;\n', '        emit Revocation(msg.sender, transactionId);\n', '    }\n', '\n', '    /// @dev Allows anyone to execute a confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function executeTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '    {\n', '        if (isConfirmed(transactionId)) {\n', '            Transaction storage txn = transactions[transactionId];\n', '            txn.executed = true;\n', '            if (txn.destination.call.value(txn.value)(txn.data))\n', '                emit Execution(transactionId);\n', '            else {\n', '                emit ExecutionFailure(transactionId);\n', '                txn.executed = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the confirmation status of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Confirmation status.\n', '    function isConfirmed(uint transactionId) public view returns (bool) {\n', '        uint count = 0;\n', '        for (uint i = 0; i < owners.length; i++) {\n', '            if (confirmations[transactionId][owners[i]])\n', '                count += 1;\n', '            if (count == required)\n', '                return true;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Internal functions\n', '     */\n', '    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function addTransaction(address destination, uint value, bytes data)\n', '    internal\n', '    notNull(destination)\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = transactionCount;\n', '        transactions[transactionId] = Transaction({\n', '            destination : destination,\n', '            value : value,\n', '            data : data,\n', '            executed : false\n', '            });\n', '        transactionCount += 1;\n', '        emit Submission(transactionId);\n', '    }\n', '\n', '    /*\n', '     * Web3 call functions\n', '     */\n', '    /// @dev Returns number of confirmations of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Number of confirmations.\n', '    function getConfirmationCount(uint transactionId) public view returns (uint count) {\n', '        for (uint i = 0; i < owners.length; i++) {\n', '            if (confirmations[transactionId][owners[i]]) {\n', '                count += 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Returns total number of transactions after filers are applied.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Total number of transactions after filters are applied.\n', '    function getTransactionCount(\n', '        bool pending,\n', '        bool executed\n', '    ) public view returns (uint count) {\n', '        for (uint i = 0; i < transactionCount; i++) {\n', '            if (pending &&\n', '                !transactions[i].executed ||\n', '                executed &&\n', '                transactions[i].executed\n', '            ) {\n', '                count += 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners() public view returns (address[]) {\n', '        return owners;\n', '    }\n', '\n', '    /// @dev Returns array with owner addresses, which confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Returns array of owner addresses.\n', '    function getConfirmations(\n', '        uint transactionId\n', '    ) public view returns (address[] _confirmations) {\n', '        address[] memory confirmationsTemp = new address[](owners.length);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i = 0; i < owners.length; i++)\n', '            if (confirmations[transactionId][owners[i]]) {\n', '                confirmationsTemp[count] = owners[i];\n', '                count += 1;\n', '            }\n', '        _confirmations = new address[](count);\n', '        for (i = 0; i < count; i++)\n', '            _confirmations[i] = confirmationsTemp[i];\n', '    }\n', '\n', '    /// @dev Returns list of transaction IDs in defined range.\n', '    /// @param from Index start position of transaction array.\n', '    /// @param to Index end position of transaction array.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Returns array of transaction IDs.\n', '    function getTransactionIds(\n', '        uint from,\n', '        uint to,\n', '        bool pending,\n', '        bool executed\n', '    ) public view returns (uint[] _transactionIds) {\n', '        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i = 0; i < transactionCount; i++)\n', '            if (pending &&\n', '                !transactions[i].executed ||\n', '                executed &&\n', '                transactions[i].executed\n', '            ) {\n', '                transactionIdsTemp[count] = i;\n', '                count += 1;\n', '            }\n', '        _transactionIds = new uint[](to - from);\n', '        for (i = from; i < to; i++)\n', '            _transactionIds[i - from] = transactionIdsTemp[i];\n', '    }\n', '}\n', '\n', 'contract JavvyMultiSig is MultiSigWallet {\n', '    constructor(\n', '        address[] _owners,\n', '        uint _required\n', '    )\n', '    MultiSigWallet(_owners, _required)\n', '    public {}\n', '}\n', '\n', 'contract Config {\n', '    uint256 public constant jvySupply = 333333333333333;\n', '    uint256 public constant bonusSupply = 83333333333333;\n', '    uint256 public constant saleSupply = 250000000000000;\n', '    uint256 public constant hardCapUSD = 8000000;\n', '\n', '    uint256 public constant preIcoBonus = 25;\n', '    uint256 public constant minimalContributionAmount = 0.4 ether;\n', '\n', '    function getStartPreIco() public view returns (uint256) {\n', '        // solium-disable-next-line security/no-block-members\n', '        uint256 _preIcoStartTime = block.timestamp + 1 minutes;\n', '        return _preIcoStartTime;\n', '    }\n', '\n', '    function getStartIco() public view returns (uint256) {\n', '        // uint256 _icoStartTime = 1543554000;\n', '        // solium-disable-next-line security/no-block-members\n', '        uint256 _icoStartTime = block.timestamp + 2 minutes;\n', '        return _icoStartTime;\n', '    }\n', '\n', '    function getEndIco() public view returns (uint256) {\n', '        // solium-disable-next-line security/no-block-members\n', '        // uint256 _icoEndTime = block.timestamp + 50 days;\n', '        // uint256 _icoEndTime = 1551416400;\n', '        uint256 _icoEndTime = 1567209600;\n', '        return _icoEndTime;\n', '    }\n', '}\n', '\n', '\n', 'contract JavvyToken is DetailedERC20, StandardToken, Ownable, Config {\n', '    address public crowdsaleAddress;\n', '    address public bonusAddress;\n', '    address public multiSigAddress;\n', '\n', '    constructor(\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals\n', '    ) public\n', '    DetailedERC20(_name, _symbol, _decimals) {\n', '        require(\n', '            jvySupply == saleSupply + bonusSupply,\n', '            "Sum of provided supplies is not equal to declared total Javvy supply. Check config!"\n', '        );\n', '        totalSupply_ = tokenToDecimals(jvySupply);\n', '    }\n', '\n', '    function initializeBalances(\n', '        address _crowdsaleAddress,\n', '        address _bonusAddress,\n', '        address _multiSigAddress\n', '    ) public\n', '    onlyOwner() {\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '        bonusAddress = _bonusAddress;\n', '        multiSigAddress = _multiSigAddress;\n', '\n', '        _initializeBalance(_crowdsaleAddress, saleSupply);\n', '        _initializeBalance(_bonusAddress, bonusSupply);\n', '    }\n', '\n', '    function _initializeBalance(address _address, uint256 _supply) private {\n', '        require(_address != address(0), "Address cannot be equal to 0x0!");\n', '        require(_supply != 0, "Supply cannot be equal to 0!");\n', '        balances[_address] = tokenToDecimals(_supply);\n', '        emit Transfer(address(0), _address, _supply);\n', '    }\n', '\n', '    function tokenToDecimals(uint256 _amount) private pure returns (uint256){\n', "        // NOTE for additional accuracy, we're using 6 decimal places in supply\n", '        return _amount * (10 ** 12);\n', '    }\n', '\n', '    function getRemainingSaleTokens() external view returns (uint256) {\n', '        return balanceOf(crowdsaleAddress);\n', '    }\n', '\n', '}\n', '\n', 'contract Escrow is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposited(address indexed payee, uint256 weiAmount);\n', '    event Withdrawn(address indexed payee, uint256 weiAmount);\n', '\n', '    mapping(address => uint256) private deposits;\n', '\n', '    function depositsOf(address _payee) public view returns (uint256) {\n', '        return deposits[_payee];\n', '    }\n', '\n', '    /**\n', '    * @dev Stores the sent amount as credit to be withdrawn.\n', '    * @param _payee The destination address of the funds.\n', '    */\n', '    function deposit(address _payee) public onlyOwner payable {\n', '        uint256 amount = msg.value;\n', '        deposits[_payee] = deposits[_payee].add(amount);\n', '\n', '        emit Deposited(_payee, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw accumulated balance for a payee.\n', '    * @param _payee The address whose funds will be withdrawn and transferred to.\n', '    */\n', '    function withdraw(address _payee) public onlyOwner {\n', '        uint256 payment = deposits[_payee];\n', '        assert(address(this).balance >= payment);\n', '\n', '        deposits[_payee] = 0;\n', '\n', '        _payee.transfer(payment);\n', '\n', '        emit Withdrawn(_payee, payment);\n', '    }\n', '}\n', '\n', 'contract ConditionalEscrow is Escrow {\n', '    /**\n', '    * @dev Returns whether an address is allowed to withdraw their funds. To be\n', '    * implemented by derived contracts.\n', '    * @param _payee The destination address of the funds.\n', '    */\n', '    function withdrawalAllowed(address _payee) public view returns (bool);\n', '\n', '    function withdraw(address _payee) public {\n', '        require(withdrawalAllowed(_payee));\n', '        super.withdraw(_payee);\n', '    }\n', '}\n', '\n', 'contract RefundEscrow is Ownable, ConditionalEscrow {\n', '    enum State {Active, Refunding, Closed}\n', '\n', '    event Closed();\n', '    event RefundsEnabled();\n', '\n', '    State public state;\n', '    address public beneficiary;\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _beneficiary The beneficiary of the deposits.\n', '     */\n', '    constructor(address _beneficiary) public {\n', '        require(_beneficiary != address(0));\n', '        beneficiary = _beneficiary;\n', '        state = State.Active;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores funds that may later be refunded.\n', '     * @param _refundee The address funds will be sent to if a refund occurs.\n', '     */\n', '    function deposit(address _refundee) public payable {\n', '        require(state == State.Active);\n', '        super.deposit(_refundee);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows for the beneficiary to withdraw their funds, rejecting\n', '     * further deposits.\n', '     */\n', '    function close() public onlyOwner {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        emit Closed();\n', '    }\n', '\n', '    /**\n', '     * @dev Allows for refunds to take place, rejecting further deposits.\n', '     */\n', '    function enableRefunds() public onlyOwner {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        emit RefundsEnabled();\n', '    }\n', '\n', '    /**\n', "     * @dev Withdraws the beneficiary's funds.\n", '     */\n', '    function beneficiaryWithdraw() public {\n', '        require(state == State.Closed);\n', '        beneficiary.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether refundees can withdraw their deposits (be refunded).\n', '     */\n', '    function withdrawalAllowed(address _payee) public view returns (bool) {\n', '        return state == State.Refunding;\n', '    }\n', '}\n', '\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    // The token being sold\n', '    ERC20 public token;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // How many token units a buyer gets per wei.\n', '    // The rate is the conversion between wei and the smallest and indivisible token unit.\n', '    // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\n', '    // 1 wei will give you 1 unit, or 0.001 TOK.\n', '    uint256 public rate;\n', '\n', '    // Amount of wei raised\n', '    uint256 public weiRaised;\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(\n', '        address indexed purchaser,\n', '        address indexed beneficiary,\n', '        uint256 value,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '     * @param _rate Number of token units a buyer gets per wei\n', '     * @param _wallet Address where collected funds will be forwarded to\n', '     * @param _token Address of the token being sold\n', '     */\n', '    constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n', '        require(_rate > 0);\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '\n', '        rate = _rate;\n', '        wallet = _wallet;\n', '        token = _token;\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Crowdsale external interface\n', '    // -----------------------------------------\n', '\n', '    /**\n', '     * @dev fallback function ***DO NOT OVERRIDE***\n', '     */\n', '    function() external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev low level token purchase ***DO NOT OVERRIDE***\n', '     * @param _beneficiary Address performing the token purchase\n', '     */\n', '    function buyTokens(address _beneficiary) public payable {\n', '\n', '        uint256 weiAmount = msg.value;\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            tokens\n', '        );\n', '\n', '        _updatePurchasingState(_beneficiary, weiAmount);\n', '\n', '        _forwardFunds();\n', '        _postValidatePurchase(_beneficiary, weiAmount);\n', '    }\n', '\n', '    // -----------------------------------------\n', '    // Internal interface (extensible)\n', '    // -----------------------------------------\n', '\n', '    /**\n', '     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n', "     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\n", '     *   super._preValidatePurchase(_beneficiary, _weiAmount);\n', '     *   require(weiRaised.add(_weiAmount) <= cap);\n', '     * @param _beneficiary Address performing the token purchase\n', '     * @param _weiAmount Value in wei involved in the purchase\n', '     */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '    internal\n', '    {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount != 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n', '     * @param _beneficiary Address performing the token purchase\n', '     * @param _weiAmount Value in wei involved in the purchase\n', '     */\n', '    function _postValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '    internal\n', '    {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '     * @param _beneficiary Address performing the token purchase\n', '     * @param _tokenAmount Number of tokens to be emitted\n', '     */\n', '    function _deliverTokens(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '    internal\n', '    {\n', '        token.safeTransfer(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '     * @param _beneficiary Address receiving the tokens\n', '     * @param _tokenAmount Number of tokens to be purchased\n', '     */\n', '    function _processPurchase(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount\n', '    )\n', '    internal\n', '    {\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n', '     * @param _beneficiary Address receiving the tokens\n', '     * @param _weiAmount Value in wei involved in the purchase\n', '     */\n', '    function _updatePurchasingState(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '    internal\n', '    {\n', '        // optional override\n', '    }\n', '\n', '    /**\n', '     * @dev Override to extend the way in which ether is converted to tokens.\n', '     * @param _weiAmount Value in wei to be converted into tokens\n', '     * @return Number of tokens that can be purchased with the specified _weiAmount\n', '     */\n', '    function _getTokenAmount(uint256 _weiAmount)\n', '    internal view returns (uint256)\n', '    {\n', '        return _weiAmount.mul(rate);\n', '    }\n', '\n', '    /**\n', '     * @dev Determines how ETH is stored/forwarded on purchases.\n', '     */\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', 'contract CappedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public cap;\n', '\n', '    /**\n', '     * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n', '     * @param _cap Max amount of wei to be contributed\n', '     */\n', '    constructor(uint256 _cap) public {\n', '        require(_cap > 0);\n', '        cap = _cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether the cap has been reached.\n', '     * @return Whether the cap was reached\n', '     */\n', '    function capReached() public view returns (bool) {\n', '        return weiRaised >= cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Extend parent behavior requiring purchase to respect the funding cap.\n', '     * @param _beneficiary Token purchaser\n', '     * @param _weiAmount Amount of wei contributed\n', '     */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '    internal\n', '    {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount);\n', '        require(weiRaised.add(_weiAmount) <= cap);\n', '    }\n', '\n', '}\n', '\n', 'contract TimedCrowdsale is Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public openingTime;\n', '    uint256 public closingTime;\n', '\n', '    /**\n', '     * @dev Reverts if not in crowdsale time range.\n', '     */\n', '    modifier onlyWhileOpen {\n', '        // solium-disable-next-line security/no-block-members\n', '        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor, takes crowdsale opening and closing times.\n', '     * @param _openingTime Crowdsale opening time\n', '     * @param _closingTime Crowdsale closing time\n', '     */\n', '    constructor(uint256 _openingTime, uint256 _closingTime) public {\n', '        // solium-disable-next-line security/no-block-members\n', '        require(_openingTime >= block.timestamp);\n', '        require(_closingTime >= _openingTime);\n', '\n', '        openingTime = _openingTime;\n', '        closingTime = _closingTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n', '     * @return Whether crowdsale period has elapsed\n', '     */\n', '    function hasClosed() public view returns (bool) {\n', '        // solium-disable-next-line security/no-block-members\n', '        return block.timestamp > closingTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Extend parent behavior requiring to be within contributing period\n', '     * @param _beneficiary Token purchaser\n', '     * @param _weiAmount Amount of wei contributed\n', '     */\n', '    function _preValidatePurchase(\n', '        address _beneficiary,\n', '        uint256 _weiAmount\n', '    )\n', '    internal\n', '    onlyWhileOpen\n', '    {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount);\n', '    }\n', '\n', '}\n', '\n', 'contract FinalizableCrowdsale is Ownable, TimedCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', "     * work. Calls the contract's finalization function.\n", '     */\n', '    function finalize() public onlyOwner {\n', '        require(!isFinalized);\n', '        require(hasClosed());\n', '\n', '        finalization();\n', '        emit Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overridden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '\n', '}\n', '\n', 'contract RefundableCrowdsale is FinalizableCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // minimum amount of funds to be raised in weis\n', '    uint256 public goal;\n', '\n', '    // refund escrow used to hold funds while crowdsale is running\n', '    RefundEscrow private escrow;\n', '\n', '    /**\n', '     * @dev Constructor, creates RefundEscrow.\n', '     * @param _goal Funding goal\n', '     */\n', '    constructor(uint256 _goal) public {\n', '        require(_goal > 0);\n', '        escrow = new RefundEscrow(wallet);\n', '        goal = _goal;\n', '    }\n', '\n', '    /**\n', '     * @dev Investors can claim refunds here if crowdsale is unsuccessful\n', '     */\n', '    function claimRefund() public {\n', '        require(isFinalized);\n', '        require(!goalReached());\n', '\n', '        escrow.withdraw(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether funding goal was reached.\n', '     * @return Whether funding goal was reached\n', '     */\n', '    function goalReached() public view returns (bool) {\n', '        return weiRaised >= goal;\n', '    }\n', '\n', '    /**\n', '     * @dev escrow finalization task, called when owner calls finalize()\n', '     */\n', '    function finalization() internal {\n', '        if (goalReached()) {\n', '            escrow.close();\n', '            escrow.beneficiaryWithdraw();\n', '        } else {\n', '            escrow.enableRefunds();\n', '        }\n', '\n', '        super.finalization();\n', '    }\n', '\n', '    /**\n', '     * @dev Overrides Crowdsale fund forwarding, sending funds to escrow.\n', '     */\n', '    function _forwardFunds() internal {\n', '        escrow.deposit.value(msg.value)(msg.sender);\n', '    }\n', '\n', '}\n', '\n', 'contract JavvyCrowdsale is RefundableCrowdsale, CappedCrowdsale, Pausable, Config {\n', '    uint256 public icoStartTime;\n', '    address public transminingAddress;\n', '    address public bonusAddress;\n', '    uint256 private USDETHRate;\n', '\n', '    mapping(address => bool) public blacklisted;\n', '\n', '    JavvyToken token;\n', '\n', '    enum Stage {\n', '        NotStarted,\n', '        PreICO,\n', '        ICO,\n', '        AfterICO\n', '    }\n', '\n', '    function getStage() public view returns (Stage) {\n', '        // solium-disable-next-line security/no-block-members\n', '        uint256 blockTime = block.timestamp;\n', '        if (blockTime < openingTime) return Stage.NotStarted;\n', '        if (blockTime < icoStartTime) return Stage.PreICO;\n', '        if (blockTime < closingTime) return Stage.ICO;\n', '        else return Stage.AfterICO;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _rate,\n', '        JavvyMultiSig _wallet,\n', '        JavvyToken _token,\n', '    // Should be equal to cap = hardCapUSD * USDETHInitialRate;\n', '    // 8000000 * 7692307692307692 = 61538461538461536000000\n', '        uint256 _cap,\n', '        uint256 _goal,\n', '        address _bonusAddress,\n', '        address[] _blacklistAddresses,\n', '        uint256 _USDETHRate\n', '    )\n', '    Crowdsale(_rate, _wallet, _token)\n', '    CappedCrowdsale(_cap)\n', '    TimedCrowdsale(getStartPreIco(), getEndIco())\n', '    RefundableCrowdsale(_goal)\n', '    public {\n', '        // require(_cap == _USDETHRate.mul(hardCapUSD), "Hard cap is not equal to formula");\n', '        require(getStartIco() > block.timestamp, "ICO has to begin in the future");\n', '        require(getEndIco() > block.timestamp, "ICO has to end in the future");\n', '        require(_goal <= _cap, "Soft cap should be equal or smaller than hard cap");\n', '        icoStartTime = getStartIco();\n', '        bonusAddress = _bonusAddress;\n', '        token = _token;\n', '        for (uint256 i = 0; i < _blacklistAddresses.length; i++) {\n', '            blacklisted[_blacklistAddresses[i]] = true;\n', '        }\n', '        setUSDETHRate(_USDETHRate);\n', "        // TODO: Don't forgot about this when deploying\n", "        // TODO: It's set to continue old ICO\n", '        weiRaised = 46461161522138564065713;\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '        require(!blacklisted[msg.sender], "Sender is blacklisted");\n', '        bool preallocated = false;\n', '        uint256 preallocatedTokens = 0;\n', '\n', '        _buyTokens(\n', '            _beneficiary,\n', '            msg.sender,\n', '            msg.value,\n', '            preallocated,\n', '            preallocatedTokens\n', '        );\n', '    }\n', '\n', '    function bulkPreallocate(address[] _owners, uint256[] _tokens, uint256[] _paid)\n', '    public\n', '    onlyOwner() {\n', '        require(\n', '            _owners.length == _tokens.length,\n', '            "Lengths of parameter lists have to be equal"\n', '        );\n', '        require(\n', '            _owners.length == _paid.length,\n', '            "Lengths of parameter lists have to be equal"\n', '        );\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            preallocate(_owners[i], _tokens[i], _paid[i]);\n', '        }\n', '    }\n', '\n', '    function preallocate(address _owner, uint256 _tokens, uint256 _paid)\n', '    public\n', '    onlyOwner() {\n', '        require(!blacklisted[_owner], "Address where tokens will be sent is blacklisted");\n', '        bool preallocated = true;\n', '        uint256 preallocatedTokens = _tokens;\n', '\n', '        _buyTokens(\n', '            _owner,\n', '            _owner,\n', '            _paid,\n', '            preallocated,\n', '            preallocatedTokens\n', '        );\n', '    }\n', '\n', '    function setTransminingAddress(address _transminingAddress) public\n', '    onlyOwner() {\n', '        transminingAddress = _transminingAddress;\n', '    }\n', '\n', '    // Created for moving funds later to transmining address\n', '    function moveTokensToTransmining(uint256 _amount) public\n', '    onlyOwner() {\n', '        uint256 remainingTokens = token.getRemainingSaleTokens();\n', '        require(\n', '            transminingAddress != address(0),\n', '            "Transmining address must be set!"\n', '        );\n', '        require(\n', '            remainingTokens >= _amount,\n', '            "Balance of remaining tokens for sale is smaller than requested amount for trans-mining"\n', '        );\n', '        uint256 weiNeeded = cap - weiRaised;\n', '        uint256 tokensNeeded = weiNeeded * rate;\n', '\n', '        if (getStage() != Stage.AfterICO) {\n', '            require(remainingTokens - _amount > tokensNeeded, "You need to leave enough tokens to reach hard cap");\n', '        }\n', '        _deliverTokens(transminingAddress, _amount, this);\n', '    }\n', '\n', '    function _buyTokens(\n', '        address _beneficiary,\n', '        address _sender,\n', '        uint256 _value,\n', '        bool _preallocated,\n', '        uint256 _tokens\n', '    ) internal\n', '    whenNotPaused() {\n', '        uint256 tokens;\n', '\n', '        if (!_preallocated) {\n', '            // pre validate params\n', '            require(\n', '                _value >= minimalContributionAmount,\n', '                "Amount contributed should be greater than required minimal contribution"\n', '            );\n', '            require(_tokens == 0, "Not preallocated tokens should be zero");\n', '            _preValidatePurchase(_beneficiary, _value);\n', '        } else {\n', '            require(_tokens != 0, "Preallocated tokens should be greater than zero");\n', '            require(weiRaised.add(_value) <= cap, "Raised tokens should not exceed hard cap");\n', '        }\n', '\n', '        // calculate tokens\n', '        if (!_preallocated) {\n', '            tokens = _getTokenAmount(_value);\n', '        } else {\n', '            tokens = _tokens;\n', '        }\n', '\n', '        // increase wei\n', '        weiRaised = weiRaised.add(_value);\n', '\n', '        _processPurchase(_beneficiary, tokens, this);\n', '\n', '        emit TokenPurchase(\n', '            _sender,\n', '            _beneficiary,\n', '            _value,\n', '            tokens\n', '        );\n', '\n', '        // transfer payment\n', '        _updatePurchasingState(_beneficiary, _value);\n', '        _forwardFunds();\n', '\n', '        // post validate\n', '        if (!_preallocated) {\n', '            _postValidatePurchase(_beneficiary, _value);\n', '        }\n', '    }\n', '\n', '    function _getBaseTokens(uint256 _value) internal view returns (uint256) {\n', '        return _value.mul(rate);\n', '    }\n', '\n', '    function _getTokenAmount(uint256 _weiAmount)\n', '    internal view returns (uint256) {\n', '        uint256 baseTokens = _getBaseTokens(_weiAmount);\n', '        if (getStage() == Stage.PreICO) {\n', '            return baseTokens.mul(100 + preIcoBonus).div(100);\n', '        } else {\n', '            return baseTokens;\n', '        }\n', '    }\n', '\n', '    function _processPurchase(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount,\n', '        address _sourceAddress\n', '    ) internal {\n', '        _deliverTokens(_beneficiary, _tokenAmount, _sourceAddress);\n', '    }\n', '\n', '    function _deliverTokens(\n', '        address _beneficiary,\n', '        uint256 _tokenAmount,\n', '        address _sourceAddress\n', '    ) internal {\n', '        if (_sourceAddress == address(this)) {\n', '            token.transfer(_beneficiary, _tokenAmount);\n', '        } else {\n', '            token.transferFrom(_sourceAddress, _beneficiary, _tokenAmount);\n', '        }\n', '    }\n', '\n', '    function finalization() internal {\n', '        require(\n', '            transminingAddress != address(0),\n', '            "Transmining address must be set!"\n', '        );\n', '        super.finalization();\n', '\n', '        _deliverTokens(transminingAddress, token.getRemainingSaleTokens(), this);\n', '    }\n', '\n', '    function setUSDETHRate(uint256 _USDETHRate) public\n', '    onlyOwner() {\n', '        require(_USDETHRate > 0, "USDETH rate should not be zero");\n', '        USDETHRate = _USDETHRate;\n', '        cap = hardCapUSD.mul(USDETHRate);\n', '    }\n', '}']