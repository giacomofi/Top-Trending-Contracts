['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-07\n', '*/\n', '\n', 'pragma solidity ^0.5.10;\n', '\n', '/* MintHelper for BitcoinSoV (BSOV)\n', ' * Based off https://github.com/0xbitcoin/mint-helper\n', ' * 1% Burn fee comes from mining pool&#39;s fee, allowing miner payout contract to receive its full share.\n', ' * https://www.btcsov.com\n', ' */\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC918Interface {\n', '  function totalSupply() public view returns (uint);\n', '  function getMiningDifficulty() public view returns (uint);\n', '  function getMiningTarget() public view returns (uint);\n', '  function getMiningReward() public view returns (uint);\n', '  function balanceOf(address tokenOwner) public view returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '}\n', '\n', '/*\n', 'The owner (or anyone) will deposit tokens in here\n', 'The owner calls the multisend method to send out payments\n', '*/\n', 'contract MintHelper is Ownable {\n', '   using SafeMath for uint;\n', '\n', '    string public name;\n', '    address public mintableToken;\n', '    mapping(bytes32 => bool) successfulPayments;\n', '\n', '    constructor(address mToken, string memory mName)\n', '    public\n', '    {\n', '      mintableToken = mToken;\n', '      name = mName;\n', '    }\n', '\n', '    function setMintableToken(address mToken)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      mintableToken = mToken;\n', '      return true;\n', '    }\n', '\n', '    function paymentSuccessful(bytes32 paymentId) public view returns (bool){\n', '        return (successfulPayments[paymentId] == true);\n', '    }\n', '    \n', '    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n', '    public\n', '    returns (bool)\n', '    {\n', '      require(ERC918Interface(mintableToken).mint(nonce, challenge_digest), "Could not mint token");\n', '      return true;\n', '    }\n', '\n', '    //withdraw any eth inside\n', '    function withdraw()\n', '    public onlyOwner\n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    //send tokens out\n', '    function send(address _tokenAddr, address dest, uint value)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '     return ERC20Interface(_tokenAddr).transfer(dest, value);\n', '    }\n', '\n', '    //batch send tokens\n', '    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values)\n', '    public onlyOwner\n', '    returns (uint256)\n', '    {\n', '        require(dests.length > 0, "Must have more than 1 destination address");\n', '        require(values.length >= dests.length, "Address to Value array size mismatch");\n', '        require(successfulPayments[paymentId] != true, "Payment ID already exists and was successful");\n', '\n', '        uint256 i = 0;\n', '        while (i < dests.length) {\n', '           require(ERC20Interface(_tokenAddr).transfer(dests[i], values[i]));\n', '           i += 1;\n', '        }\n', '\n', '        successfulPayments[paymentId] = true;\n', '        return (i);\n', '    }\n', '}']
['pragma solidity ^0.5.10;\n', '\n', '/* MintHelper for BitcoinSoV (BSOV)\n', ' * Based off https://github.com/0xbitcoin/mint-helper\n', " * 1% Burn fee comes from mining pool's fee, allowing miner payout contract to receive its full share.\n", ' * https://www.btcsov.com\n', ' */\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC918Interface {\n', '  function totalSupply() public view returns (uint);\n', '  function getMiningDifficulty() public view returns (uint);\n', '  function getMiningTarget() public view returns (uint);\n', '  function getMiningReward() public view returns (uint);\n', '  function balanceOf(address tokenOwner) public view returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '}\n', '\n', '/*\n', 'The owner (or anyone) will deposit tokens in here\n', 'The owner calls the multisend method to send out payments\n', '*/\n', 'contract MintHelper is Ownable {\n', '   using SafeMath for uint;\n', '\n', '    string public name;\n', '    address public mintableToken;\n', '    mapping(bytes32 => bool) successfulPayments;\n', '\n', '    constructor(address mToken, string memory mName)\n', '    public\n', '    {\n', '      mintableToken = mToken;\n', '      name = mName;\n', '    }\n', '\n', '    function setMintableToken(address mToken)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      mintableToken = mToken;\n', '      return true;\n', '    }\n', '\n', '    function paymentSuccessful(bytes32 paymentId) public view returns (bool){\n', '        return (successfulPayments[paymentId] == true);\n', '    }\n', '    \n', '    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n', '    public\n', '    returns (bool)\n', '    {\n', '      require(ERC918Interface(mintableToken).mint(nonce, challenge_digest), "Could not mint token");\n', '      return true;\n', '    }\n', '\n', '    //withdraw any eth inside\n', '    function withdraw()\n', '    public onlyOwner\n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    //send tokens out\n', '    function send(address _tokenAddr, address dest, uint value)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '     return ERC20Interface(_tokenAddr).transfer(dest, value);\n', '    }\n', '\n', '    //batch send tokens\n', '    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values)\n', '    public onlyOwner\n', '    returns (uint256)\n', '    {\n', '        require(dests.length > 0, "Must have more than 1 destination address");\n', '        require(values.length >= dests.length, "Address to Value array size mismatch");\n', '        require(successfulPayments[paymentId] != true, "Payment ID already exists and was successful");\n', '\n', '        uint256 i = 0;\n', '        while (i < dests.length) {\n', '           require(ERC20Interface(_tokenAddr).transfer(dests[i], values[i]));\n', '           i += 1;\n', '        }\n', '\n', '        successfulPayments[paymentId] = true;\n', '        return (i);\n', '    }\n', '}']
