['pragma solidity >=0.5.4 <0.6.0;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t * @dev Multiplies two numbers, throws on overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tc = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Integer division of two numbers, truncating the quotient.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\t// uint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn a / b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Adds two numbers, throws on overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '\t\tc = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', 'interface INameTAOPosition {\n', '\tfunction senderIsAdvocate(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsListener(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsSpeaker(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsPosition(address _sender, address _id) external view returns (bool);\n', '\tfunction getAdvocate(address _id) external view returns (address);\n', '\tfunction nameIsAdvocate(address _nameId, address _id) external view returns (bool);\n', '\tfunction nameIsPosition(address _nameId, address _id) external view returns (bool);\n', '\tfunction initialize(address _id, address _advocateId, address _listenerId, address _speakerId) external returns (bool);\n', '\tfunction determinePosition(address _sender, address _id) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface INameAccountRecovery {\n', '\tfunction isCompromised(address _id) external view returns (bool);\n', '}\n', '\n', '\n', 'interface IAOSettingAttribute {\n', '\tfunction add(uint256 _settingId, address _creatorNameId, string calldata _settingName, address _creatorTAOId, address _associatedTAOId, string calldata _extraData) external returns (bytes32, bytes32);\n', '\n', '\tfunction getSettingData(uint256 _settingId) external view returns (uint256, address, address, address, string memory, bool, bool, bool, string memory);\n', '\n', '\tfunction approveAdd(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) external returns (bool);\n', '\n', '\tfunction finalizeAdd(uint256 _settingId, address _creatorTAOAdvocate) external returns (bool);\n', '\n', '\tfunction update(uint256 _settingId, address _associatedTAOAdvocate, address _proposalTAOId, string calldata _extraData) external returns (bool);\n', '\n', '\tfunction getSettingState(uint256 _settingId) external view returns (uint256, bool, address, address, address, string memory);\n', '\n', '\tfunction approveUpdate(uint256 _settingId, address _proposalTAOAdvocate, bool _approved) external returns (bool);\n', '\n', '\tfunction finalizeUpdate(uint256 _settingId, address _associatedTAOAdvocate) external returns (bool);\n', '\n', '\tfunction addDeprecation(uint256 _settingId, address _creatorNameId, address _creatorTAOId, address _associatedTAOId, uint256 _newSettingId, address _newSettingContractAddress) external returns (bytes32, bytes32);\n', '\n', '\tfunction getSettingDeprecation(uint256 _settingId) external view returns (uint256, address, address, address, bool, bool, bool, bool, uint256, uint256, address, address);\n', '\n', '\tfunction approveDeprecation(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) external returns (bool);\n', '\n', '\tfunction finalizeDeprecation(uint256 _settingId, address _creatorTAOAdvocate) external returns (bool);\n', '\n', '\tfunction settingExist(uint256 _settingId) external view returns (bool);\n', '\n', '\tfunction getLatestSettingId(uint256 _settingId) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface INameFactory {\n', '\tfunction nonces(address _nameId) external view returns (uint256);\n', '\tfunction incrementNonce(address _nameId) external returns (uint256);\n', '\tfunction ethAddressToNameId(address _ethAddress) external view returns (address);\n', '\tfunction setNameNewAddress(address _id, address _newAddress) external returns (bool);\n', '\tfunction nameIdToEthAddress(address _nameId) external view returns (address);\n', '}\n', '\n', '\n', 'interface IAOSetting {\n', '\tfunction getSettingValuesByTAOName(address _taoId, string calldata _settingName) external view returns (uint256, bool, address, bytes32, string memory);\n', '\tfunction getSettingTypes() external view returns (uint8, uint8, uint8, uint8, uint8);\n', '\n', '\tfunction settingTypeLookup(uint256 _settingId) external view returns (uint8);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenERC20 {\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals = 18;\n', '\t// 18 decimals is the strongly suggested default, avoid changing it\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\tmapping (address => uint256) public balanceOf;\n', '\tmapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply tokens to the creator of the contract\n', '\t */\n', '\tconstructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n', '\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '\t\tname = tokenName;                                   // Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\n', '\t}\n', '\n', '\t/**\n', '\t * Internal transfer, only can be called by this contract\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint _value) internal {\n', '\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_to != address(0));\n', '\t\t// Check if the sender has enough\n', '\t\trequire(balanceOf[_from] >= _value);\n', '\t\t// Check for overflows\n', '\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\n', '\t\t// Save this for an assertion in the future\n', '\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\t\t// Subtract from the sender\n', '\t\tbalanceOf[_from] -= _value;\n', '\t\t// Add the same to the recipient\n', '\t\tbalanceOf[_to] += _value;\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens\n', '\t *\n', '\t * Send `_value` tokens to `_to` from your account\n', '\t *\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens from other address\n', '\t *\n', '\t * Send `_value` tokens to `_to` in behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '\t\tallowance[_from][msg.sender] -= _value;\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address and notify\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t * @param _extraData some extra information to send to the approved contract\n', '\t */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly\n', '\t *\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '\t\ttotalSupply -= _value;                      // Updates totalSupply\n', '\t\temit Burn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens from other account\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '\t\ttotalSupply -= _value;                              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title TAO\n', ' */\n', 'contract TAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public vaultAddress;\n', '\tstring public name;\t\t\t\t// the name for this TAO\n', "\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\n", '\n', "\t// TAO's data\n", '\tstring public datHash;\n', '\tstring public database;\n', '\tstring public keyValue;\n', '\tbytes32 public contentId;\n', '\n', '\t/**\n', '\t * 0 = TAO\n', '\t * 1 = Name\n', '\t */\n', '\tuint8 public typeId;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _vaultAddress\n', '\t) public {\n', '\t\tname = _name;\n', '\t\toriginId = _originId;\n', '\t\tdatHash = _datHash;\n', '\t\tdatabase = _database;\n', '\t\tkeyValue = _keyValue;\n', '\t\tcontentId = _contentId;\n', '\n', '\t\t// Creating TAO\n', '\t\ttypeId = 0;\n', '\n', '\t\tvaultAddress = _vaultAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if calling address is Vault contract\n', '\t */\n', '\tmodifier onlyVault {\n', '\t\trequire (msg.sender == vaultAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Will receive any ETH sent\n', '\t */\n', '\tfunction () external payable {\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\t_recipient.transfer(_amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\n', '\t * @param _erc20TokenAddress The address of ERC20 Token\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\n', '\t\t_erc20.transfer(_recipient, _amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Name\n', ' */\n', 'contract Name is TAO {\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string memory _name, address _originId, string memory _datHash, string memory _database, string memory _keyValue, bytes32 _contentId, address _vaultAddress)\n', '\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\n', '\t\t// Creating Name\n', '\t\ttypeId = 1;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOLibrary\n', ' */\n', 'library AOLibrary {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\n', '\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given TAO ID is a TAO\n', '\t * @param _taoId The ID of the TAO\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isTAO(address _taoId) public view returns (bool) {\n', '\t\treturn (_taoId != address(0) && bytes(TAO(address(uint160(_taoId))).name()).length > 0 && TAO(address(uint160(_taoId))).originId() != address(0) && TAO(address(uint160(_taoId))).typeId() == 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given Name ID is a Name\n', '\t * @param _nameId The ID of the Name\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isName(address _nameId) public view returns (bool) {\n', '\t\treturn (_nameId != address(0) && bytes(TAO(address(uint160(_nameId))).name()).length > 0 && Name(address(uint160(_nameId))).originId() != address(0) && Name(address(uint160(_nameId))).typeId() == 1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_tokenAddress` is a valid ERC20 Token address\n', '\t * @param _tokenAddress The ERC20 Token address to check\n', '\t */\n', '\tfunction isValidERC20TokenAddress(address _tokenAddress) public view returns (bool) {\n', '\t\tif (_tokenAddress == address(0)) {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t\tTokenERC20 _erc20 = TokenERC20(_tokenAddress);\n', '\t\treturn (_erc20.totalSupply() >= 0 && bytes(_erc20.name()).length > 0 && bytes(_erc20.symbol()).length > 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t * @param _sender The address to check\n', '\t * @param _theAO The AO address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\n', '\t\treturn (_sender == _theAO ||\n', '\t\t\t(\n', '\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\n', '\t\t\t\t_nameTAOPositionAddress != address(0) &&\n', '\t\t\t\tINameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\n', '\t\t\t)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate percentage.\n', '\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\n', '\t *\t\tso 1% is 10000, 1.25% is 12500, etc\n', '\t */\n', '\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _PERCENTAGE_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate multiplier.\n', '\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\n', '\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\n', '\t */\n', '\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _MULTIPLIER_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev deploy a TAO\n', '\t * @param _name The name of the TAO\n', '\t * @param _originId The Name ID the creates the TAO\n', '\t * @param _datHash The datHash of this TAO\n', '\t * @param _database The database for this TAO\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this TAO\n', '\t * @param _nameTAOVaultAddress The address of NameTAOVault\n', '\t */\n', '\tfunction deployTAO(string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _nameTAOVaultAddress\n', '\t\t) public returns (TAO _tao) {\n', '\t\t_tao = new TAO(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev deploy a Name\n', '\t * @param _name The name of the Name\n', '\t * @param _originId The eth address the creates the Name\n', '\t * @param _datHash The datHash of this Name\n', '\t * @param _database The database for this Name\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this Name\n', '\t * @param _nameTAOVaultAddress The address of NameTAOVault\n', '\t */\n', '\tfunction deployName(string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _nameTAOVaultAddress\n', '\t\t) public returns (Name _myName) {\n', '\t\t_myName = new Name(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\n', "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", "\t * @param _currentPrimordialBalance Account's current primordial ion balance\n", '\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\n', '\t * @param _additionalPrimordialAmount The primordial ion amount to be added\n', '\t * @return the new primordial weighted multiplier\n', '\t */\n', '\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\n', '\t\tif (_currentWeightedMultiplier > 0) {\n', '\t\t\tuint256 _totalWeightedIons = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\n', '\t\t\tuint256 _totalIons = _currentPrimordialBalance.add(_additionalPrimordialAmount);\n', '\t\t\treturn _totalWeightedIons.div(_totalIons);\n', '\t\t} else {\n', '\t\t\treturn _additionalWeightedMultiplier;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the primordial ion multiplier on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Multiplier = S\n', '\t *\t\tEnding Multiplier = E\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion mintable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\n', '\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\n', '\t * @return The multiplier in (10 ** 6)\n', '\t */\n', '\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\n', '\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\n', '\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\n', '\t\t\t/**\n', '\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\n', '\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\n', '\t\t\t */\n', '\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus percentage of network ion on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Network Bonus Multiplier = Bs\n', '\t *\t\tEnding Network Bonus Multiplier = Be\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion intable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting Network ion bonus multiplier\n', '\t * @param _endingMultiplier The ending Network ion bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\n', '\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\n', '\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\n', '\t\t\t */\n', '\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\n', '\t\t\treturn bonusPercentage;\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus amount of network ion on a given lot\n', '\t *\t\tAO Bonus Amount = B% x P\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion intable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting Network ion bonus multiplier\n', '\t * @param _endingMultiplier The ending Network ion bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tuint256 bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\n', '\t\t/**\n', '\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\n', '\t\t * when calculating the network ion bonus amount\n', '\t\t */\n', '\t\tuint256 networkBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\n', '\t\treturn networkBonus;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the maximum amount of Primordial an account can burn\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_maximumMultiplier = S\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\tB = ((S x P) - (P x M)) / S\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _maximumMultiplier The maximum multiplier of this account\n', '\t * @return The maximum burn amount\n', '\t */\n', '\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\n', '\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after burning primordial ion\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P - B)\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _amountToBurn The amount of primordial ion to burn\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after converting network ion to primordial ion\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToConvert = C\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P + C)\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _amountToConvert The amount of network ion to convert\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev count num of digits\n', '\t * @param number uint256 of the nuumber to be checked\n', '\t * @return uint8 num of digits\n', '\t */\n', '\tfunction numDigits(uint256 number) public pure returns (uint8) {\n', '\t\tuint8 digits = 0;\n', '\t\twhile(number != 0) {\n', '\t\t\tnumber = number.div(10);\n', '\t\t\tdigits++;\n', '\t\t}\n', '\t\treturn digits;\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract TheAO {\n', '\taddress public theAO;\n', '\taddress public nameTAOPositionAddress;\n', '\n', '\t// Check whether an address is whitelisted and granted access to transact\n', '\t// on behalf of others\n', '\tmapping (address => bool) public whitelist;\n', '\n', '\tconstructor() public {\n', '\t\ttheAO = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if msg.sender is in whitelist.\n', '\t */\n', '\tmodifier inWhitelist() {\n', '\t\trequire (whitelist[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AOSettingDeprecation\n', ' *\n', ' * This contract responsible for adding setting deprecation\n', ' */\n', 'contract AOSettingDeprecation is TheAO {\n', '\taddress public nameFactoryAddress;\n', '\taddress public nameAccountRecoveryAddress;\n', '\taddress public aoSettingAttributeAddress;\n', '\taddress public aoSettingAddress;\n', '\n', '\tINameFactory internal _nameFactory;\n', '\tINameTAOPosition internal _nameTAOPosition;\n', '\tINameAccountRecovery internal _nameAccountRecovery;\n', '\tIAOSettingAttribute internal _aoSettingAttribute;\n', '\tIAOSetting internal _aoSetting;\n', '\n', '\t// Event to be broadcasted to public when a setting deprecation is created and waiting for approval\n', '\tevent SettingDeprecation(uint256 indexed settingId, address indexed creatorNameId, address creatorTAOId, address associatedTAOId, uint256 newSettingId, address newSettingContractAddress, bytes32 associatedTAOSettingDeprecationId, bytes32 creatorTAOSettingDeprecationId);\n', '\n', '\t// Event to be broadcasted to public when setting deprecation is approved/rejected by the advocate of associatedTAOId\n', '\tevent ApproveSettingDeprecation(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate, bool approved);\n', '\n', '\t// Event to be broadcasted to public when setting deprecation is finalized by the advocate of creatorTAOId\n', '\tevent FinalizeSettingDeprecation(uint256 indexed settingId, address creatorTAOId, address creatorTAOAdvocate);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress,\n', '\t\taddress _nameTAOPositionAddress,\n', '\t\taddress _nameAccountRecoveryAddress,\n', '\t\taddress _aoSettingAttributeAddress,\n', '\t\taddress _aoSettingAddress\n', '\t\t) public {\n', '\t\tsetNameFactoryAddress(_nameFactoryAddress);\n', '\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\n', '\t\tsetNameAccountRecoveryAddress(_nameAccountRecoveryAddress);\n', '\t\tsetAOSettingAttributeAddress(_aoSettingAttributeAddress);\n', '\t\tsetAOSettingAddress(_aoSettingAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of Name ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check is msg.sender address is a Name\n', '\t */\n', '\t modifier senderIsName() {\n', '\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\n', '\t\t_;\n', '\t }\n', '\n', '\t/**\n', "\t * @dev Only allowed if sender's Name is not compromised\n", '\t */\n', '\tmodifier senderNameNotCompromised() {\n', '\t\trequire (!_nameAccountRecovery.isCompromised(_nameFactory.ethAddressToNameId(msg.sender)));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets NameFactory address\n', '\t * @param _nameFactoryAddress The address of NameFactory\n', '\t */\n', '\tfunction setNameFactoryAddress(address _nameFactoryAddress) public onlyTheAO {\n', '\t\trequire (_nameFactoryAddress != address(0));\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\t\t_nameFactory = INameFactory(_nameFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets NameTAOPosition address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = INameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameAccountRecovery Address\n', '\t * @param _nameAccountRecoveryAddress The address of NameAccountRecovery\n', '\t */\n', '\tfunction setNameAccountRecoveryAddress(address _nameAccountRecoveryAddress) public onlyTheAO {\n', '\t\trequire (_nameAccountRecoveryAddress != address(0));\n', '\t\tnameAccountRecoveryAddress = _nameAccountRecoveryAddress;\n', '\t\t_nameAccountRecovery = INameAccountRecovery(nameAccountRecoveryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets AOSettingAttribute address\n', '\t * @param _aoSettingAttributeAddress The address of AOSettingAttribute\n', '\t */\n', '\tfunction setAOSettingAttributeAddress(address _aoSettingAttributeAddress) public onlyTheAO {\n', '\t\trequire (_aoSettingAttributeAddress != address(0));\n', '\t\taoSettingAttributeAddress = _aoSettingAttributeAddress;\n', '\t\t_aoSettingAttribute = IAOSettingAttribute(_aoSettingAttributeAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets AOSetting address\n', '\t * @param _aoSettingAddress The address of AOSetting\n', '\t */\n', '\tfunction setAOSettingAddress(address _aoSettingAddress) public onlyTheAO {\n', '\t\trequire (_aoSettingAddress != address(0));\n', '\t\taoSettingAddress = _aoSettingAddress;\n', '\t\t_aoSetting = IAOSetting(_aoSettingAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Advocate of _creatorTAOId adds a setting deprecation\n', '\t * @param _settingId The ID of the setting to be deprecated\n', '\t * @param _newSettingId The new setting ID to route\n', '\t * @param _newSettingContractAddress The new setting contract address to route\n', '\t * @param _creatorTAOId The taoId that created the setting\n', '\t * @param _associatedTAOId The taoId that the setting affects\n', '\t */\n', '\tfunction addSettingDeprecation(\n', '\t\tuint256 _settingId,\n', '\t\tuint256 _newSettingId,\n', '\t\taddress _newSettingContractAddress,\n', '\t\taddress _creatorTAOId,\n', '\t\taddress _associatedTAOId)\n', '\t\tpublic\n', '\t\tisTAO(_creatorTAOId)\n', '\t\tisTAO(_associatedTAOId)\n', '\t\tonlyAdvocate(_creatorTAOId)\n', '\t\tsenderNameNotCompromised {\n', '\t\t// Make sure the settings exist\n', '\t\trequire (_aoSetting.settingTypeLookup(_settingId) > 0 && _aoSetting.settingTypeLookup(_newSettingId) > 0);\n', '\n', "\t\t// Make sure it's the same type\n", '\t\trequire (_aoSetting.settingTypeLookup(_settingId) == _aoSetting.settingTypeLookup(_newSettingId));\n', '\n', '\t\t(bytes32 _associatedTAOSettingDeprecationId, bytes32 _creatorTAOSettingDeprecationId) = _aoSettingAttribute.addDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress);\n', '\n', '\t\temit SettingDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress, _associatedTAOSettingDeprecationId, _creatorTAOSettingDeprecationId);\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Advocate of SettingDeprecation's _associatedTAOId approves setting deprecation\n", '\t * @param _settingId The ID of the setting to approve\n', '\t * @param _approved Whether to approve or reject\n', '\t */\n', '\tfunction approveSettingDeprecation(uint256 _settingId, bool _approved) public senderIsName senderNameNotCompromised {\n', '\t\t// Make sure setting exist\n', '\t\trequire (_aoSetting.settingTypeLookup(_settingId) > 0);\n', '\n', '\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.approveDeprecation(_settingId, _associatedTAOAdvocate, _approved));\n', '\n', '\t\t(,,, address _associatedTAOId,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\n', '\t\temit ApproveSettingDeprecation(_settingId, _associatedTAOId, _associatedTAOAdvocate, _approved);\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Advocate of SettingDeprecation's _creatorTAOId finalizes the setting deprecation once the setting deprecation is approved\n", '\t * @param _settingId The ID of the setting to be finalized\n', '\t */\n', '\tfunction finalizeSettingDeprecation(uint256 _settingId) public senderIsName senderNameNotCompromised {\n', '\t\t// Make sure setting exist\n', '\t\trequire (_aoSetting.settingTypeLookup(_settingId) > 0);\n', '\n', '\t\taddress _creatorTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_aoSettingAttribute.finalizeDeprecation(_settingId, _creatorTAOAdvocate));\n', '\n', '\t\t(,, address _creatorTAOId,,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\n', '\t\temit FinalizeSettingDeprecation(_settingId, _creatorTAOId, _creatorTAOAdvocate);\n', '\t}\n', '}']