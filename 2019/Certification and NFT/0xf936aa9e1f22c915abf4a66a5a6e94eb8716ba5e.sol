['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * \n', ' * World War Goo - Competitive Idle Game\n', ' * \n', ' * https://ethergoo.io\n', ' * \n', ' */\n', '\n', '\n', 'contract Units {\n', '\n', '    GooToken constant goo = GooToken(0xdf0960778c6e6597f197ed9a25f12f5d971da86c);\n', '    Army army = Army(0x0);\n', '    Clans clans = Clans(0x0);\n', '    Factories constant factories = Factories(0xc81068cd335889736fc485592e4d73a82403d44b);\n', '\n', '    mapping(address => mapping(uint256 => UnitsOwned)) public unitsOwned;\n', '    mapping(address => mapping(uint256 => UnitExperience)) public unitExp;\n', '    mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\n', '\n', '    mapping(address => mapping(uint256 => UnitUpgrades)) private unitUpgrades;\n', '    mapping(address => mapping(uint256 => UpgradesOwned)) public upgradesOwned; // For each unitId, which upgrades owned (3 columns of uint64)\n', '\n', '    mapping(uint256 => Unit) public unitList;\n', '    mapping(uint256 => Upgrade) public upgradeList;\n', '    mapping(address => bool) operator;\n', '\n', '    address owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    struct UnitsOwned {\n', '        uint80 units;\n', '        uint8 factoryBuiltFlag; // Incase user sells units, we still want to keep factory\n', '    }\n', '\n', '    struct UnitExperience {\n', '        uint224 experience;\n', '        uint32 level;\n', '    }\n', '\n', '    struct UnitUpgrades {\n', '        uint32 prodIncrease;\n', '        uint32 prodMultiplier;\n', '\n', '        uint32 attackIncrease;\n', '        uint32 attackMultiplier;\n', '        uint32 defenseIncrease;\n', '        uint32 defenseMultiplier;\n', '        uint32 lootingIncrease;\n', '        uint32 lootingMultiplier;\n', '    }\n', '\n', '    struct UpgradesOwned {\n', '        uint64 column0;\n', '        uint64 column1;\n', '        uint64 column2;\n', '    }\n', '\n', '\n', '    // Unit & Upgrade data:\n', '    \n', '    struct Unit {\n', '        uint256 unitId;\n', '        uint224 gooCost;\n', '        uint256 baseProduction;\n', '        uint80 attack;\n', '        uint80 defense;\n', '        uint80 looting;\n', '    }\n', '\n', '    struct Upgrade {\n', '        uint256 upgradeId;\n', '        uint224 gooCost;\n', '        uint256 unitId;\n', '        uint256 column; // Columns of upgrades (1st & 2nd are unit specific, then 3rd is capacity)\n', '        uint256 prerequisiteUpgrade;\n', '\n', '        uint256 unitMaxCapacityGain;\n', '        uint32 prodIncrease;\n', '        uint32 prodMultiplier;\n', '        uint32 attackIncrease;\n', '        uint32 attackMultiplier;\n', '        uint32 defenseIncrease;\n', '        uint32 defenseMultiplier;\n', '        uint32 lootingIncrease;\n', '        uint32 lootingMultiplier;\n', '    }\n', '\n', '    function setArmy(address armyContract) external {\n', '        require(msg.sender == owner);\n', '        army = Army(armyContract);\n', '    }\n', '\n', '    function setClans(address clansContract) external {\n', '        require(msg.sender == owner);\n', '        clans = Clans(clansContract);\n', '    }\n', '\n', '    function setOperator(address gameContract, bool isOperator) external {\n', '        require(msg.sender == owner);\n', '        operator[gameContract] = isOperator;\n', '    }\n', '\n', '    function mintUnitExternal(uint256 unit, uint80 amount, address player, uint8 chosenPosition) external {\n', '        require(operator[msg.sender]);\n', '        mintUnit(unit, amount, player, chosenPosition);\n', '    }\n', '\n', '    function mintUnit(uint256 unit, uint80 amount, address player, uint8 chosenPosition) internal {\n', '        UnitsOwned storage existingUnits = unitsOwned[player][unit];\n', '        if (existingUnits.factoryBuiltFlag == 0) {\n', '            // Edge case to create factory for player (on empty tile) where it is their first unit\n', '            uint256[] memory existingFactories = factories.getFactories(player);\n', '            uint256 length = existingFactories.length;\n', '\n', '            // Provided position is not valid so find valid factory position\n', '            if (chosenPosition >= factories.MAX_SIZE() || (chosenPosition < length && existingFactories[chosenPosition] > 0)) {\n', '                chosenPosition = 0;\n', '                while (chosenPosition < length && existingFactories[chosenPosition] > 0) {\n', '                    chosenPosition++;\n', '                }\n', '            }\n', '\n', '            factories.addFactory(player, chosenPosition, unit);\n', '            unitsOwned[player][unit] = UnitsOwned(amount, 1); // 1 = Flag to say factory exists\n', '        } else {\n', '            existingUnits.units += amount;\n', '        }\n', '\n', '        (uint80 attackStats, uint80 defenseStats, uint80 lootingStats) = getUnitsCurrentBattleStats(player, unit);\n', '        if (attackStats > 0 || defenseStats > 0 || lootingStats > 0) {\n', '            army.increasePlayersArmyPowerTrio(player, attackStats * amount, defenseStats * amount, lootingStats * amount);\n', '        } else {\n', '            uint256 prodIncrease = getUnitsCurrentProduction(player, unit) * amount;\n', '            goo.increasePlayersGooProduction(player, prodIncrease / 100);\n', '        }\n', '    }\n', '\n', '\n', '    function deleteUnitExternal(uint80 amount, uint256 unit, address player) external {\n', '        require(operator[msg.sender]);\n', '        deleteUnit(amount, unit, player);\n', '    }\n', '\n', '    function deleteUnit(uint80 amount, uint256 unit, address player) internal {\n', '        (uint80 attackStats, uint80 defenseStats, uint80 lootingStats) = getUnitsCurrentBattleStats(player, unit);\n', '        if (attackStats > 0 || defenseStats > 0 || lootingStats > 0) {\n', '            army.decreasePlayersArmyPowerTrio(player, attackStats * amount, defenseStats * amount, lootingStats * amount);\n', '        } else {\n', '            uint256 prodDecrease = getUnitsCurrentProduction(player, unit) * amount;\n', '            goo.decreasePlayersGooProduction(player, prodDecrease / 100);\n', '        }\n', '        unitsOwned[player][unit].units -= amount;\n', '    }\n', '\n', '\n', '    function getUnitsCurrentBattleStats(address player, uint256 unitId) internal view returns (uint80 attack, uint80 defense, uint80 looting) {\n', '        Unit memory unit = unitList[unitId];\n', '        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '        attack = (unit.attack + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier);\n', '        defense = (unit.defense + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier);\n', '        looting = (unit.looting + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier);\n', '    }\n', '    \n', '    function getUnitsCurrentProduction(address player, uint256 unitId) public view returns (uint256) {\n', '        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '        return (unitList[unitId].baseProduction + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier);\n', '    }\n', '\n', '\n', '    function buyUnit(uint256 unitId, uint80 amount, uint8 position) external {\n', '        uint224 gooCost = SafeMath224.mul(unitList[unitId].gooCost, amount);\n', '        require(gooCost > 0); // Valid unit\n', '\n', '        uint80 newTotal = unitsOwned[msg.sender][unitId].units + amount;\n', '        if (newTotal > 99) {\n', '            require(newTotal < 99 + unitMaxCap[msg.sender][unitId]);\n', '        }\n', '\n', '        // Clan discount\n', '        uint224 unitDiscount = clans.getPlayersClanUpgrade(msg.sender, 1); // class 1 = unit discount\n', '        uint224 reducedGooCost = gooCost - ((gooCost * unitDiscount) / 100);\n', '        uint224 seventyFivePercentRefund = (gooCost * 3) / 4;\n', '\n', '        // Update players goo\n', '        goo.updatePlayersGooFromPurchase(msg.sender, reducedGooCost);\n', '        goo.mintGoo(seventyFivePercentRefund, this); // 75% refund is stored (in this contract) for when player sells unit\n', '        army.depositSpentGoo(reducedGooCost - seventyFivePercentRefund); // Upto 25% Goo spent goes to divs (Remaining is discount + 75% player gets back when selling unit)\n', '        mintUnit(unitId, amount, msg.sender, position);\n', '    }\n', '\n', '\n', '    function sellUnit(uint256 unitId, uint80 amount) external {\n', '        require(unitsOwned[msg.sender][unitId].units >= amount && amount > 0);\n', '\n', '        uint224 gooCost = unitList[unitId].gooCost;\n', '        require(gooCost > 0);\n', '\n', '        goo.updatePlayersGoo(msg.sender);\n', '        deleteUnit(amount, unitId, msg.sender);\n', '        goo.transfer(msg.sender, (gooCost * amount * 3) / 4); // Refund 75%\n', '    }\n', '\n', '\n', '    function grantArmyExp(address player, uint256 unitId, uint224 amount) external returns(bool) {\n', '        require(operator[msg.sender]);\n', '\n', '        UnitExperience memory existingExp = unitExp[player][unitId];\n', '        uint224 expRequirement = (existingExp.level + 1) * 80; // Lvl 1: 80; Lvl 2: 160, Lvl 3: 240 (480 in total) etc.\n', '\n', '        if (existingExp.experience + amount >= expRequirement) {\n', '            existingExp.experience = (existingExp.experience + amount) - expRequirement;\n', '            existingExp.level++;\n', '            unitExp[player][unitId] = existingExp;\n', '\n', '            // Grant buff to unit (5% additive multiplier)\n', '            UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '            existingUpgrades.attackMultiplier += 5;\n', '            existingUpgrades.defenseMultiplier += 5;\n', '            existingUpgrades.lootingMultiplier += 5;\n', '            unitUpgrades[player][unitId] = existingUpgrades;\n', '\n', "            // Increase player's army power\n", '            uint80 multiplierGain = unitsOwned[player][unitId].units * 5;\n', '\n', '            Unit memory unit = unitList[unitId];\n', '            uint80 attackGain = multiplierGain * (unit.attack + existingUpgrades.attackIncrease);\n', '            uint80 defenseGain = multiplierGain * (unit.defense + existingUpgrades.defenseIncrease);\n', '            uint80 lootingGain = multiplierGain * (unit.looting + existingUpgrades.lootingIncrease);\n', '            army.increasePlayersArmyPowerTrio(player, attackGain, defenseGain, lootingGain);\n', '            return true;\n', '        } else {\n', '            unitExp[player][unitId].experience += amount;\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function increaseUnitCapacity(address player, uint256 upgradeGain, uint256 unitId) external {\n', '        require(operator[msg.sender]);\n', '        unitMaxCap[player][unitId] += upgradeGain;\n', '    }\n', '\n', '    function decreaseUnitCapacity(address player, uint256 upgradeGain, uint256 unitId) external {\n', '        require(operator[msg.sender]);\n', '        unitMaxCap[player][unitId] -= upgradeGain;\n', '    }\n', '\n', '\n', '    function increaseUpgradesExternal(address player, uint256 unitId, uint32 prodIncrease, uint32 prodMultiplier, uint32 attackIncrease, uint32 attackMultiplier, uint32 defenseIncrease, uint32 defenseMultiplier, uint32 lootingIncrease, uint32 lootingMultiplier) external {\n', '        require(operator[msg.sender]);\n', '        Upgrade memory upgrade = Upgrade(0,0,0,0,0,0, prodIncrease, prodMultiplier, attackIncrease, attackMultiplier, defenseIncrease, defenseMultiplier, lootingIncrease, lootingMultiplier);\n', '        increaseUpgrades(player, upgrade, unitId);\n', '    }\n', '\n', '\n', '    function increaseUpgrades(address player, Upgrade upgrade, uint256 unitId) internal {\n', '        uint80 units = unitsOwned[player][unitId].units;\n', '        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '\n', '        Unit memory unit = unitList[unitId];\n', '        if (unit.baseProduction > 0) {\n', '            // Increase goo production\n', '            uint256 prodGain = units * upgrade.prodMultiplier * (unit.baseProduction + existingUpgrades.prodIncrease); // Multiplier gains\n', '            prodGain += units * upgrade.prodIncrease * (100 + existingUpgrades.prodMultiplier); // Base prod gains\n', '\n', '            goo.updatePlayersGoo(player);\n', '            goo.increasePlayersGooProduction(player, prodGain / 100);\n', '        } else {\n', '            // Increase army power\n', '            uint80 attackGain = units * upgrade.attackMultiplier * (unit.attack + existingUpgrades.attackIncrease); // Multiplier gains\n', '            uint80 defenseGain = units * upgrade.defenseMultiplier * (unit.defense + existingUpgrades.defenseIncrease); // Multiplier gains\n', '            uint80 lootingGain = units * upgrade.lootingMultiplier * (unit.looting + existingUpgrades.lootingIncrease); // Multiplier gains\n', '\n', '            attackGain += units * upgrade.attackIncrease * (100 + existingUpgrades.attackMultiplier); // + Base gains\n', '            defenseGain += units * upgrade.defenseIncrease * (100 + existingUpgrades.defenseMultiplier); // + Base gains\n', '            lootingGain += units * upgrade.lootingIncrease * (100 + existingUpgrades.lootingMultiplier); // + Base gains\n', '\n', '            army.increasePlayersArmyPowerTrio(player, attackGain, defenseGain, lootingGain);\n', '        }\n', '\n', '        existingUpgrades.prodIncrease += upgrade.prodIncrease;\n', '        existingUpgrades.prodMultiplier += upgrade.prodMultiplier;\n', '        existingUpgrades.attackIncrease += upgrade.attackIncrease;\n', '        existingUpgrades.attackMultiplier += upgrade.attackMultiplier;\n', '        existingUpgrades.defenseIncrease += upgrade.defenseIncrease;\n', '        existingUpgrades.defenseMultiplier += upgrade.defenseMultiplier;\n', '        existingUpgrades.lootingIncrease += upgrade.lootingIncrease;\n', '        existingUpgrades.lootingMultiplier += upgrade.lootingMultiplier;\n', '        unitUpgrades[player][unitId] = existingUpgrades;\n', '    }\n', '\n', '\n', '    function decreaseUpgradesExternal(address player, uint256 unitId, uint32 prodIncrease, uint32 prodMultiplier, uint32 attackIncrease, uint32 attackMultiplier, uint32 defenseIncrease, uint32 defenseMultiplier, uint32 lootingIncrease, uint32 lootingMultiplier) external {\n', '        require(operator[msg.sender]);\n', '        Upgrade memory upgrade = Upgrade(0,0,0,0,0,0, prodIncrease, prodMultiplier, attackIncrease, attackMultiplier, defenseIncrease, defenseMultiplier, lootingIncrease, lootingMultiplier);\n', '        decreaseUpgrades(player, upgrade, unitId);\n', '    }\n', '\n', '\n', '    function decreaseUpgrades(address player, Upgrade upgrade, uint256 unitId) internal {\n', '        uint80 units = unitsOwned[player][unitId].units;\n', '        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '\n', '        Unit memory unit = unitList[unitId];\n', '        if (unit.baseProduction > 0) {\n', '            // Decrease goo production\n', '            uint256 prodLoss = units * upgrade.prodMultiplier * (unit.baseProduction + existingUpgrades.prodIncrease); // Multiplier losses\n', '            prodLoss += units * upgrade.prodIncrease * (100 + existingUpgrades.prodMultiplier); // Base prod losses\n', '\n', '            goo.updatePlayersGoo(player);\n', '            goo.decreasePlayersGooProduction(player, prodLoss / 100);\n', '        } else {\n', '            // Decrease army power\n', '            uint80 attackLoss = units * upgrade.attackMultiplier * (unit.attack + existingUpgrades.attackIncrease); // Multiplier losses\n', '            uint80 defenseLoss = units * upgrade.defenseMultiplier * (unit.defense + existingUpgrades.defenseIncrease); // Multiplier losses\n', '            uint80 lootingLoss = units * upgrade.lootingMultiplier * (unit.looting + existingUpgrades.lootingIncrease); // Multiplier losses\n', '\n', '            attackLoss += units * upgrade.attackIncrease * (100 + existingUpgrades.attackMultiplier); // + Base losses\n', '            defenseLoss += units * upgrade.defenseIncrease * (100 + existingUpgrades.defenseMultiplier); // + Base losses\n', '            lootingLoss += units * upgrade.lootingIncrease * (100 + existingUpgrades.lootingMultiplier); // + Base losses\n', '            army.decreasePlayersArmyPowerTrio(player, attackLoss, defenseLoss, lootingLoss);\n', '        }\n', '\n', '        existingUpgrades.prodIncrease -= upgrade.prodIncrease;\n', '        existingUpgrades.prodMultiplier -= upgrade.prodMultiplier;\n', '        existingUpgrades.attackIncrease -= upgrade.attackIncrease;\n', '        existingUpgrades.attackMultiplier -= upgrade.attackMultiplier;\n', '        existingUpgrades.defenseIncrease -= upgrade.defenseIncrease;\n', '        existingUpgrades.defenseMultiplier -= upgrade.defenseMultiplier;\n', '        existingUpgrades.lootingIncrease -= upgrade.lootingIncrease;\n', '        existingUpgrades.lootingMultiplier -= upgrade.lootingMultiplier;\n', '        unitUpgrades[player][unitId] = existingUpgrades;\n', '    }\n', '\n', '    function swapUpgradesExternal(address player, uint256 unitId, uint32[8] upgradeGains, uint32[8] upgradeLosses) external {\n', '        require(operator[msg.sender]);\n', '\n', '        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\n', '        Unit memory unit = unitList[unitId];\n', '\n', '        if (unit.baseProduction > 0) {\n', '            // Change goo production\n', '            gooProductionChange(player, unitId, existingUpgrades, unit.baseProduction, upgradeGains, upgradeLosses);\n', '        } else {\n', '            // Change army power\n', '            armyPowerChange(player, existingUpgrades, unit, upgradeGains, upgradeLosses);\n', '        }\n', '    }\n', '    \n', '    function armyPowerChange(address player, UnitUpgrades existingUpgrades, Unit unit, uint32[8] upgradeGains, uint32[8] upgradeLosses) internal {\n', '        int256 existingAttack = int256((unit.attack + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier));\n', '        int256 existingDefense = int256((unit.defense + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier));\n', '        int256 existingLooting = int256((unit.looting + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier));\n', '    \n', '        existingUpgrades.attackIncrease = uint32(int(existingUpgrades.attackIncrease) + (int32(upgradeGains[2]) - int32(upgradeLosses[2])));\n', '        existingUpgrades.attackMultiplier = uint32(int(existingUpgrades.attackMultiplier) + (int32(upgradeGains[3]) - int32(upgradeLosses[3])));\n', '        existingUpgrades.defenseIncrease = uint32(int(existingUpgrades.defenseIncrease) + (int32(upgradeGains[4]) - int32(upgradeLosses[4])));\n', '        existingUpgrades.defenseMultiplier = uint32(int(existingUpgrades.defenseMultiplier) + (int32(upgradeGains[5]) - int32(upgradeLosses[5])));\n', '        existingUpgrades.lootingIncrease = uint32(int(existingUpgrades.lootingIncrease) + (int32(upgradeGains[6]) - int32(upgradeLosses[6])));\n', '        existingUpgrades.lootingMultiplier = uint32(int(existingUpgrades.lootingMultiplier) + (int32(upgradeGains[7]) - int32(upgradeLosses[7])));\n', '        \n', '        int256 attackChange = ((int256(unit.attack) + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier)) - existingAttack;\n', '        int256 defenseChange = ((int256(unit.defense) + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier)) - existingDefense;\n', '        int256 lootingChange = ((int256(unit.looting) + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier)) - existingLooting;\n', '        \n', '        uint256 unitId = unit.unitId;\n', '        int256 units = int256(unitsOwned[player][unitId].units);\n', '        \n', '        army.changePlayersArmyPowerTrio(player, units * attackChange, units * defenseChange, units * lootingChange);\n', '        unitUpgrades[player][unitId] = existingUpgrades;\n', '    }\n', '    \n', '    function gooProductionChange(address player, uint256 unitId, UnitUpgrades existingUpgrades, uint256 baseProduction, uint32[8] upgradeGains, uint32[8] upgradeLosses) internal {\n', '        goo.updatePlayersGoo(player);\n', '        \n', '        int256 existingProd = int256((baseProduction + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier));\n', '        existingUpgrades.prodIncrease = uint32(int(existingUpgrades.prodIncrease) + (int32(upgradeGains[0]) - int32(upgradeLosses[0])));\n', '        existingUpgrades.prodMultiplier = uint32(int(existingUpgrades.prodMultiplier) + (int32(upgradeGains[1]) - int32(upgradeLosses[1])));            \n', '        \n', '        int256 prodChange = ((int256(baseProduction) + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier)) - existingProd;\n', '        if (prodChange > 0) {\n', '            goo.increasePlayersGooProduction(player, (unitsOwned[player][unitId].units * uint256(prodChange)) / 100);\n', '        } else {\n', '            goo.decreasePlayersGooProduction(player, (unitsOwned[player][unitId].units * uint256(-prodChange)) / 100);\n', '        }\n', '        \n', '        unitUpgrades[player][unitId] = existingUpgrades;\n', '    }\n', '\n', '    function addUnit(uint256 id, uint224 baseGooCost, uint256 baseGooProduction, uint80 baseAttack, uint80 baseDefense, uint80 baseLooting) external {\n', '        require(operator[msg.sender]);\n', '        unitList[id] = Unit(id, baseGooCost, baseGooProduction, baseAttack, baseDefense, baseLooting);\n', '    }\n', '\n', '\n', '    function addUpgrade(uint256 id, uint224 gooCost, uint256 unit, uint256 column, uint256 prereq, uint256 unitMaxCapacityGain, uint32[8] upgradeGains) external {\n', '        require(operator[msg.sender]);\n', '        upgradeList[id] = Upgrade(id, gooCost, unit, column, prereq, unitMaxCapacityGain, upgradeGains[0], upgradeGains[1], upgradeGains[2], upgradeGains[3], upgradeGains[4], upgradeGains[5], upgradeGains[6], upgradeGains[7]);\n', '    }\n', '\n', '    function buyUpgrade(uint64 upgradeId) external {\n', '        Upgrade memory upgrade = upgradeList[upgradeId];\n', '        uint256 unitId = upgrade.unitId;\n', '        UpgradesOwned memory ownedUpgrades = upgradesOwned[msg.sender][unitId];\n', '\n', '        uint64 latestUpgradeOwnedForColumn;\n', '        if (upgrade.column == 0) {\n', '            latestUpgradeOwnedForColumn = ownedUpgrades.column0;\n', '            ownedUpgrades.column0 = upgradeId;  // Update upgradesOwned\n', '        } else if (upgrade.column == 1) {\n', '            latestUpgradeOwnedForColumn = ownedUpgrades.column1;\n', '            ownedUpgrades.column1 = upgradeId;  // Update upgradesOwned\n', '        } else if (upgrade.column == 2) {\n', '            latestUpgradeOwnedForColumn = ownedUpgrades.column2;\n', '            ownedUpgrades.column2 = upgradeId;  // Update upgradesOwned\n', '        }\n', '        upgradesOwned[msg.sender][unitId] = ownedUpgrades;\n', '\n', '        require(unitId > 0); // Valid upgrade\n', "        require(latestUpgradeOwnedForColumn < upgradeId); // Haven't already purchased\n", '        require(latestUpgradeOwnedForColumn >= upgrade.prerequisiteUpgrade); // Own prequisite\n', '\n', '        // Clan discount\n', '        uint224 upgradeDiscount = clans.getPlayersClanUpgrade(msg.sender, 0); // class 0 = upgrade discount\n', '        uint224 reducedUpgradeCost = upgrade.gooCost - ((upgrade.gooCost * upgradeDiscount) / 100);\n', '\n', '        // Update players goo\n', '        goo.updatePlayersGooFromPurchase(msg.sender, reducedUpgradeCost);\n', '        army.depositSpentGoo(reducedUpgradeCost); // Transfer to goo bankroll\n', '\n', '        // Update stats for upgrade\n', '        if (upgrade.column == 2) {\n', '            unitMaxCap[msg.sender][unitId] += upgrade.unitMaxCapacityGain;\n', '        } else if (upgrade.column == 1) {\n', '            increaseUpgrades(msg.sender, upgrade, unitId);\n', '        } else if (upgrade.column == 0) {\n', '            increaseUpgrades(msg.sender, upgrade, unitId);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract GooToken {\n', '    function transfer(address to, uint256 tokens) external returns (bool);\n', '    function increasePlayersGooProduction(address player, uint256 increase) external;\n', '    function decreasePlayersGooProduction(address player, uint256 decrease) external;\n', '    function updatePlayersGooFromPurchase(address player, uint224 purchaseCost) external;\n', '    function updatePlayersGoo(address player) external;\n', '    function mintGoo(uint224 amount, address player) external;\n', '}\n', '\n', 'contract Army {\n', '    function depositSpentGoo(uint224 gooSpent) external;\n', '    function increasePlayersArmyPowerTrio(address player, uint80 attackGain, uint80 defenseGain, uint80 lootingGain) public;\n', '    function decreasePlayersArmyPowerTrio(address player, uint80 attackLoss, uint80 defenseLoss, uint80 lootingLoss) public;\n', '    function changePlayersArmyPowerTrio(address player, int attackChange, int defenseChange, int lootingChange) public;\n', '\n', '}\n', '\n', 'contract Clans {\n', '    mapping(uint256 => uint256) public clanTotalArmyPower;\n', '    function totalSupply() external view returns (uint256);\n', '    function depositGoo(uint256 amount, uint256 clanId) external;\n', '    function getPlayerFees(address player) external view returns (uint224 clansFee, uint224 leadersFee, address leader, uint224 referalsFee, address referer);\n', '    function getPlayersClanUpgrade(address player, uint256 upgradeClass) external view returns (uint224 upgradeGain);\n', '    function mintGoo(address player, uint256 amount) external;\n', '    function increaseClanPower(address player, uint256 amount) external;\n', '    function decreaseClanPower(address player, uint256 amount) external;\n', '}\n', '\n', 'contract Factories {\n', '    uint256 public constant MAX_SIZE = 40;\n', '    function getFactories(address player) external returns (uint256[]);\n', '    function addFactory(address player, uint8 position, uint256 unitId) external;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint224 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath224 {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint224 a, uint224 b) internal pure returns (uint224) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint224 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint224 a, uint224 b) internal pure returns (uint224) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint224 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint224 a, uint224 b) internal pure returns (uint224) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint224 a, uint224 b) internal pure returns (uint224) {\n', '    uint224 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']