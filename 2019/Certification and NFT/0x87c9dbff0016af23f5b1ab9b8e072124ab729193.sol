['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-14\n', '*/\n', '\n', '// File: contracts/library/ERC20.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'interface ERC20 {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/library/Ownable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return owner == _address;\n', '    }\n', '}\n', '\n', '// File: contracts/library/SafeMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '// File: contracts/library/Pausable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/library/Whitelist.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * @dev This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable {\n', '  mapping(address => bool) public whitelist;\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    require(whitelist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (!whitelist[addr]) {\n', '      whitelist[addr] = true;\n', '      emit WhitelistedAddressAdded(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (addAddressToWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n', '    if (whitelist[addr]) {\n', '      whitelist[addr] = false;\n', '      emit WhitelistedAddressRemoved(addr);\n', '      success = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      if (removeAddressFromWhitelist(addrs[i])) {\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Staking.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Staking and voting contract.\n', ' * @author IoTeX Team\n', ' *\n', ' */\n', 'contract Staking is Pausable, Whitelist {\n', '    using SafeMath for uint256;\n', '\n', '    // Events to be emitted\n', '    event BucketCreated(uint256 bucketIndex, bytes12 canName, uint256 amount, uint256 stakeDuration, bool nonDecay, bytes data);\n', '    event BucketUpdated(uint256 bucketIndex, bytes12 canName, uint256 stakeDuration, uint256 stakeStartTime, bool nonDecay, address bucketOwner, bytes data);\n', '    event BucketUnstake(uint256 bucketIndex, bytes12 canName, uint256 amount, bytes data);\n', '    event BucketWithdraw(uint256 bucketIndex, bytes12 canName, uint256 amount, bytes data);\n', '    // TODO add change owner event which is not covered by BucketUpdated event\n', '\n', '    // IOTX used for staking\n', '    ERC20 stakingToken;\n', '\n', '    // Unit is epoch\n', '    uint256 public constant minStakeDuration = 0;\n', '    uint256 public constant maxStakeDuration = 350;\n', '    uint256 public constant minStakeAmount = 100 * 10 ** 18;\n', '    uint256 public constant unStakeDuration = 3;\n', '\n', '    uint256 public constant maxBucketsPerAddr = 500;\n', '    uint256 public constant secondsPerEpoch = 86400;\n', '\n', '    // Core data structure to track staking/voting status\n', '    struct Bucket {\n', '        bytes12 canName;            // Candidate name, which maps to public keys by NameRegistration.sol\n', '        uint256 stakedAmount;       // Number of tokens\n', '        uint256 stakeDuration;      // Stake duration, unit: second since epoch\n', '        uint256 stakeStartTime;     // Staking start time, unit: second since epoch\n', '        bool nonDecay;              // Nondecay staking -- staking for N epochs consistently without decaying\n', '        uint256 unstakeStartTime;   // unstake timestamp, unit: second since epoch\n', '        address bucketOwner;        // Owner of this bucket, usually the one who created it but can be someone else\n', '        uint256 createTime;         // bucket firstly create time\n', '        uint256 prev;               // Prev non-zero bucket index\n', '        uint256 next;               // Next non-zero bucket index\n', '    }\n', '    mapping(uint256 => Bucket) public buckets;\n', '    uint256 bucketCount; // number of total buckets. used to track the last used index for the bucket\n', '\n', '    // Map from owner address to array of bucket indexes.\n', '    mapping(address => uint256[]) public stakeholders;\n', '\n', '    /**\n', '     * @dev Modifier that checks that this given bucket can be updated/deleted by msg.sender\n', '     * @param _address address to transfer tokens from\n', '     * @param _bucketIndex uint256 the index of the bucket\n', '     */\n', '    modifier canTouchBucket(address _address, uint256 _bucketIndex) {\n', '        require(_address != address(0));\n', '        require(buckets[_bucketIndex].bucketOwner == msg.sender, "sender is not the owner.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier that check if a duration meets requirement\n', '     * @param _duration uint256 duration to check\n', '     */\n', '    modifier checkStakeDuration(uint256 _duration) {\n', '        require(_duration >= minStakeDuration && _duration <= maxStakeDuration, "The stake duration is too small or large");\n', '        require(_duration % 7 == 0, "The stake duration should be multiple of 7");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     * @param _stakingTokenAddr address The address of the token contract used for staking\n', '     */\n', '    constructor(address _stakingTokenAddr) public {\n', '        stakingToken = ERC20(_stakingTokenAddr);\n', '        // create one bucket to initialize the double linked list\n', '        buckets[0] = Bucket("", 1, 0, block.timestamp, true, 0, msg.sender, block.timestamp, 0, 0);\n', '        stakeholders[msg.sender].push(0);\n', '        bucketCount = 1;\n', '    }\n', '\n', '    function getActiveBucketIdxImpl(uint256 _prevIndex, uint256 _limit) internal returns(uint256 count, uint256[] indexes) {\n', '        require (_limit > 0 && _limit < 5000);\n', '        Bucket memory bucket = buckets[_prevIndex];\n', '        require(bucket.next > 0, "cannot find bucket based on input index.");\n', '\n', '        indexes = new uint256[](_limit);\n', '        uint256 i = 0;\n', '        for (i = 0; i < _limit; i++) {\n', '            while (bucket.next > 0 && buckets[bucket.next].unstakeStartTime > 0) { // unstaked.\n', '                bucket = buckets[bucket.next]; // skip\n', '            }\n', '            if (bucket.next == 0) { // no new bucket\n', '                break;\n', '            }\n', '            indexes[i] = bucket.next;\n', '            bucket = buckets[bucket.next];\n', '        }\n', '        return (i, indexes);\n', '    }\n', '\n', '    function getActiveBucketIdx(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count, uint256[] indexes) {\n', '        return getActiveBucketIdxImpl(_prevIndex, _limit);\n', '    }\n', '\n', '    /**\n', '     * @dev Get active buckets for a range of indexes\n', '     * @param _prevIndex uint256 the starting index. starting from 0, ending at the last. (putting 0,2 will return 1,2.)\n', '     * @param _limit uint256 the number of non zero buckets to fetch after the start index\n', '     * @return (uint256, uint256[], uint256[], uint256[], uint256[], bytes, address[])\n', '     *  count, index array, stakeStartTime array, duration array, decay array, stakedAmount array, concat stakedFor, ownerAddress array\n', '     */\n', '    function getActiveBuckets(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count,\n', '            uint256[] indexes, uint256[] stakeStartTimes, uint256[] stakeDurations, bool[] decays, uint256[] stakedAmounts, bytes12[] canNames, address[] owners) {\n', '\n', '        (count, indexes) = getActiveBucketIdxImpl(_prevIndex, _limit);\n', '        stakeStartTimes = new uint256[](count);\n', '        stakeDurations = new uint256[](count);\n', '        decays = new bool[](count);\n', '        stakedAmounts = new uint256[](count);\n', '        canNames = new bytes12[](count);\n', '        owners = new address[](count);\n', '\n', '        for (uint256 i = 0; i < count; i++) {\n', '            Bucket memory bucket = buckets[indexes[i]];\n', '            stakeStartTimes[i] = bucket.stakeStartTime;\n', '            stakeDurations[i] = bucket.stakeDuration;\n', '            decays[i] = !bucket.nonDecay;\n', '            stakedAmounts[i] = bucket.stakedAmount;\n', '            canNames[i] = bucket.canName;\n', '            owners[i] = bucket.bucketOwner;\n', '\n', '        }\n', '\n', '        return (count, indexes, stakeStartTimes, stakeDurations, decays, stakedAmounts, canNames, owners);\n', '    }\n', '\n', '\n', '    function getActiveBucketCreateTimes(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count,\n', '            uint256[] indexes, uint256[] createTimes) {\n', '        (count, indexes) = getActiveBucketIdxImpl(_prevIndex, _limit);\n', '        createTimes = new uint256[](count);\n', '        for (uint256 i = 0; i < count; i++) {\n', '            createTimes[i] = buckets[indexes[i]].createTime;\n', '        }\n', '        return (count, indexes, createTimes);\n', '    }\n', '\n', '    /**\n', '     * @dev Get bucket indexes from a given address\n', '     * @param _owner address onwer of the buckets\n', '     * @return (uint256[])\n', '     */\n', '    function getBucketIndexesByAddress(address _owner) external view returns(uint256[]) {\n', '        return stakeholders[_owner];\n', '    }\n', '\n', '    /**\n', '     * @notice Extend the stake to stakeDuration from current time and/or set nonDecay.\n', '     * @notice MUST trigger BucketUpdated event\n', '     * @param _bucketIndex uint256 the index of the bucket\n', '     * @param _stakeDuration uint256 the desired duration of staking.\n', '     * @param _nonDecay bool if auto restake\n', '     * @param _data bytes optional data to include in the emitted event\n', '     */\n', '    function restake(uint256 _bucketIndex, uint256 _stakeDuration, bool _nonDecay, bytes _data)\n', '            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) checkStakeDuration(_stakeDuration) {\n', '        require(block.timestamp.add(_stakeDuration * secondsPerEpoch) >=\n', '                buckets[_bucketIndex].stakeStartTime.add(buckets[_bucketIndex].stakeDuration * secondsPerEpoch),\n', '                "current stake duration not finished.");\n', '        if (buckets[_bucketIndex].nonDecay) {\n', '          require(_stakeDuration >= buckets[_bucketIndex].stakeDuration, "cannot reduce the stake duration.");\n', '        }\n', '        buckets[_bucketIndex].stakeDuration = _stakeDuration;\n', '        buckets[_bucketIndex].stakeStartTime = block.timestamp;\n', '        buckets[_bucketIndex].nonDecay = _nonDecay;\n', '        buckets[_bucketIndex].unstakeStartTime = 0;\n', '        emitBucketUpdated(_bucketIndex, _data);\n', '    }\n', '\n', '    /*\n', '     * @notice Vote for another candidate with the tokens that are already staked in the given bucket\n', '     * @notice MUST trigger BucketUpdated event\n', '     * @param _bucketIndex uint256 the index of the bucket\n', '     * @param canName bytes the IoTeX address of the candidate the tokens are staked for\n', '     * @param _data bytes optional data to include in the emitted event\n', '     */\n', '    function revote(uint256 _bucketIndex, bytes12 _canName, bytes _data)\n', '            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\n', '        require(buckets[_bucketIndex].unstakeStartTime == 0, "cannot revote during unstaking.");\n', '        buckets[_bucketIndex].canName = _canName;\n', '        emitBucketUpdated(_bucketIndex, _data);\n', '    }\n', '\n', '    /*\n', '     * @notice Set the new owner of a given bucket, the sender must be whitelisted to do so to avoid spam\n', '     * @notice MUST trigger BucketUpdated event\n', '     * @param _name bytes12 the name of the candidate the tokens are staked for\n', '     * @param _bucketIndex uint256 optional data to include in the Stake event\n', '     * @param _data bytes optional data to include in the emitted event\n', '     */\n', '    function setBucketOwner(uint256 _bucketIndex, address _newOwner, bytes _data)\n', '            external whenNotPaused onlyWhitelisted canTouchBucket(msg.sender, _bucketIndex) {\n', '        removeBucketIndex(_bucketIndex);\n', '        buckets[_bucketIndex].bucketOwner = _newOwner;\n', '        stakeholders[_newOwner].push(_bucketIndex);\n', '        // TODO split event.\n', '        emitBucketUpdated(_bucketIndex, _data);\n', '    }\n', '\n', '    /**\n', '     * @notice Unstake a certain amount of tokens from a given bucket.\n', '     * @notice MUST trigger BucketUnstake event\n', '     * @param _bucketIndex uint256 the index of the bucket\n', '     * @param _data bytes optional data to include in the emitted event\n', '     */\n', '    function unstake(uint256 _bucketIndex, bytes _data)\n', '            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\n', '        require(_bucketIndex > 0, "bucket 0 cannot be unstaked and withdrawn.");\n', '        require(!buckets[_bucketIndex].nonDecay, "Cannot unstake with nonDecay flag. Need to disable non-decay mode first.");\n', '        require(buckets[_bucketIndex].stakeStartTime.add(buckets[_bucketIndex].stakeDuration * secondsPerEpoch) <= block.timestamp,\n', '            "Staking time does not expire yet. Please wait until staking expires.");\n', '        require(buckets[_bucketIndex].unstakeStartTime == 0, "Unstaked already. No need to unstake again.");\n', '        buckets[_bucketIndex].unstakeStartTime = block.timestamp;\n', '        emit BucketUnstake(_bucketIndex, buckets[_bucketIndex].canName, buckets[_bucketIndex].stakedAmount, _data);\n', '    }\n', '\n', '    /**\n', '     * @notice this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert\n', '     * @notice MUST trigger BucketWithdraw event\n', '     * @param _bucketIndex uint256 the index of the bucket\n', '     * @param _data bytes optional data to include in the emitted event\n', '     */\n', '    function withdraw(uint256 _bucketIndex, bytes _data)\n', '            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\n', '        require(buckets[_bucketIndex].unstakeStartTime > 0, "Please unstake first before withdraw.");\n', '        require(\n', '            buckets[_bucketIndex].unstakeStartTime.add(unStakeDuration * secondsPerEpoch) <= block.timestamp,\n', '            "Stakeholder needs to wait for 3 days before withdrawing tokens.");\n', '\n', '        // fix double linked list\n', '        uint256 prev = buckets[_bucketIndex].prev;\n', '        uint256 next = buckets[_bucketIndex].next;\n', '        buckets[prev].next = next;\n', '        buckets[next].prev = prev;\n', '\n', '        uint256 amount = buckets[_bucketIndex].stakedAmount;\n', '        bytes12 canName = buckets[_bucketIndex].canName;\n', '        address bucketowner = buckets[_bucketIndex].bucketOwner;\n', '        buckets[_bucketIndex].stakedAmount = 0;\n', '        removeBucketIndex(_bucketIndex);\n', '        delete buckets[_bucketIndex];\n', '\n', '        require(stakingToken.transfer(bucketowner, amount), "Unable to withdraw stake");\n', '        emit BucketWithdraw(_bucketIndex, canName, amount, _data);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the total of tokens staked from all addresses\n', '     * @return uint256 The number of tokens staked from all addresses\n', '     */\n', '    function totalStaked() public view returns (uint256) {\n', '        return stakingToken.balanceOf(this);\n', '    }\n', '\n', '    /**\n', '     * @notice Address of the token being used by the staking interface\n', '     * @return address The address of the ERC20 token used for staking\n', '     */\n', '    function token() public view returns(address) {\n', '        return stakingToken;\n', '    }\n', '\n', '    /**\n', '     * @notice Emit BucketUpdated event\n', '     */\n', '    function emitBucketUpdated(uint256 _bucketIndex, bytes _data) internal {\n', '        Bucket memory b = buckets[_bucketIndex];\n', '        emit BucketUpdated(_bucketIndex, b.canName, b.stakeDuration, b.stakeStartTime, b.nonDecay, b.bucketOwner, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev  Create a bucket and vote for a given canName.\n', '     * @param _canName bytes The IoTeX address of the candidate the stake is being created for\n', '     * @param _amount uint256 The duration to lock the tokens for\n', '     * @param _stakeDuration bytes the desired duration of the staking\n', '     * @param _nonDecay bool if auto restake\n', '     * @param _data bytes optional data to include in the emitted event\n', '     * @return uint236 the index of new bucket\n', '     */\n', '    function createBucket(bytes12 _canName, uint256 _amount, uint256 _stakeDuration, bool _nonDecay, bytes _data)\n', '            external whenNotPaused checkStakeDuration(_stakeDuration) returns (uint256) {\n', '        require(_amount >= minStakeAmount, "amount should >= 100.");\n', '        require(stakeholders[msg.sender].length <= maxBucketsPerAddr, "One address can have up limited buckets");\n', '        require(stakingToken.transferFrom(msg.sender, this, _amount), "Stake required"); // transfer token to contract\n', '        // add a new bucket to the end of buckets array and fix the double linked list.\n', '        buckets[bucketCount] = Bucket(_canName, _amount, _stakeDuration, block.timestamp, _nonDecay, 0, msg.sender, block.timestamp, buckets[0].prev, 0);\n', '        buckets[buckets[0].prev].next = bucketCount;\n', '        buckets[0].prev = bucketCount;\n', '        stakeholders[msg.sender].push(bucketCount);\n', '        bucketCount++;\n', '        emit BucketCreated(bucketCount-1, _canName, _amount, _stakeDuration, _nonDecay, _data);\n', '        return bucketCount-1;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove the bucket index from stakeholders map\n', '     * @param _bucketidx uint256 the bucket index\n', '     */\n', '    function removeBucketIndex(uint256 _bucketidx) internal {\n', '        address owner = buckets[_bucketidx].bucketOwner;\n', '        require(stakeholders[owner].length > 0, "Expect the owner has at least one bucket index");\n', '\n', '        uint256 i = 0;\n', '        for (; i < stakeholders[owner].length; i++) {\n', '          if(stakeholders[owner][i] == _bucketidx) {\n', '                break;\n', '          }\n', '        }\n', '        for (; i < stakeholders[owner].length - 1; i++) {\n', '          stakeholders[owner][i] = stakeholders[owner][i + 1];\n', '        }\n', '        stakeholders[owner].length--;\n', '    }\n', '}']