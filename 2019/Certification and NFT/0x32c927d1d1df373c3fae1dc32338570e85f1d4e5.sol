['/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '    * @return the address of the owner.\n', '    */\n', '    function owner() public view returns(address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return true if `msg.sender` is the owner of the contract.\n', '    */\n', '    function isOwner() public view returns(bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    * @notice Renouncing to ownership will leave the contract without an owner.\n', '    * It will not be possible to call the functions with the `onlyOwner`\n', '    * modifier anymore.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that revert on error\n', '*/\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface HydroInterface {\n', '    function balances(address) external view returns (uint);\n', '    function allowed(address, address) external view returns (uint);\n', '    function transfer(address _to, uint256 _amount) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function approve(address _spender, uint256 _amount) external returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\n', '        external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function authenticate(uint _value, uint _challenge, uint _partnerId) external;\n', '}\n', '\n', 'interface SnowflakeResolverInterface {\n', '    function callOnAddition() external view returns (bool);\n', '    function callOnRemoval() external view returns (bool);\n', '    function onAddition(uint ein, uint allowance, bytes calldata extraData) external returns (bool);\n', '    function onRemoval(uint ein, bytes calldata extraData) external returns (bool);\n', '}\n', '\n', 'interface SnowflakeViaInterface {\n', '    function snowflakeCall(address resolver, uint einFrom, uint einTo, uint amount, bytes calldata snowflakeCallBytes)\n', '        external;\n', '    function snowflakeCall(\n', '        address resolver, uint einFrom, address payable to, uint amount, bytes calldata snowflakeCallBytes\n', '    ) external;\n', '    function snowflakeCall(address resolver, uint einTo, uint amount, bytes calldata snowflakeCallBytes) external;\n', '    function snowflakeCall(address resolver, address payable to, uint amount, bytes calldata snowflakeCallBytes)\n', '        external;\n', '}\n', '\n', 'interface IdentityRegistryInterface {\n', '    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n', '        external pure returns (bool);\n', '\n', '    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\n', '    function identityExists(uint ein) external view returns (bool);\n', '    function hasIdentity(address _address) external view returns (bool);\n', '    function getEIN(address _address) external view returns (uint ein);\n', '    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\n', '    function isProviderFor(uint ein, address provider) external view returns (bool);\n', '    function isResolverFor(uint ein, address resolver) external view returns (bool);\n', '    function getIdentity(uint ein) external view returns (\n', '        address recoveryAddress,\n', '        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\n', '    );\n', '\n', '    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\n', '    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\n', '        external returns (uint ein);\n', '    function createIdentityDelegated(\n', '        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) external returns (uint ein);\n', '    function addAssociatedAddress(\n', '        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) external;\n', '    function addAssociatedAddressDelegated(\n', '        address approvingAddress, address addressToAdd,\n', '        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\n', '    ) external;\n', '    function removeAssociatedAddress() external;\n', '    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\n', '        external;\n', '    function addProviders(address[] calldata providers) external;\n', '    function addProvidersFor(uint ein, address[] calldata providers) external;\n', '    function removeProviders(address[] calldata providers) external;\n', '    function removeProvidersFor(uint ein, address[] calldata providers) external;\n', '    function addResolvers(address[] calldata resolvers) external;\n', '    function addResolversFor(uint ein, address[] calldata resolvers) external;\n', '    function removeResolvers(address[] calldata resolvers) external;\n', '    function removeResolversFor(uint ein, address[] calldata resolvers) external;\n', '\n', '    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\n', '    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\n', '    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\n', '    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\n', '        external;\n', '    function triggerDestruction(\n', '        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\n', '    ) external;\n', '}\n', '\n', 'interface ClientRaindropInterface {\n', '    function hydroStakeUser() external returns (uint);\n', '    function hydroStakeDelegatedUser() external returns (uint);\n', '\n', '    function setSnowflakeAddress(address _snowflakeAddress) external;\n', '    function setStakes(uint _hydroStakeUser, uint _hydroStakeDelegatedUser) external;\n', '\n', '    function signUp(address _address, string calldata casedHydroId) external;\n', '\n', '    function hydroIDAvailable(string calldata uncasedHydroID) external view returns (bool available);\n', '    function hydroIDDestroyed(string calldata uncasedHydroID) external view returns (bool destroyed);\n', '    function hydroIDActive(string calldata uncasedHydroID) external view returns (bool active);\n', '\n', '    function getDetails(string calldata uncasedHydroID) external view\n', '        returns (uint ein, address _address, string memory casedHydroID);\n', '    function getDetails(uint ein) external view returns (address _address, string memory casedHydroID);\n', '    function getDetails(address _address) external view returns (uint ein, string memory casedHydroID);\n', '}\n', '\n', 'contract Snowflake is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    // mapping of EIN to hydro token deposits\n', '    mapping (uint => uint) public deposits;\n', '    // mapping from EIN to resolver to allowance\n', '    mapping (uint => mapping (address => uint)) public resolverAllowances;\n', '\n', '    // SC variables\n', '    address public identityRegistryAddress;\n', '    IdentityRegistryInterface private identityRegistry;\n', '    address public hydroTokenAddress;\n', '    HydroInterface private hydroToken;\n', '    address public clientRaindropAddress;\n', '    ClientRaindropInterface private clientRaindrop;\n', '\n', '    // signature variables\n', '    uint public signatureTimeout = 1 days;\n', '    mapping (uint => uint) public signatureNonce;\n', '\n', '    constructor (address _identityRegistryAddress, address _hydroTokenAddress) public {\n', '        setAddresses(_identityRegistryAddress, _hydroTokenAddress);\n', '    }\n', '\n', '    // enforces that a particular EIN exists\n', '    modifier identityExists(uint ein, bool check) {\n', '        require(identityRegistry.identityExists(ein) == check, "The EIN does not exist.");\n', '        _;\n', '    }\n', '\n', '    // enforces signature timeouts\n', '    modifier ensureSignatureTimeValid(uint timestamp) {\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp >= timestamp && block.timestamp < timestamp + signatureTimeout, "Timestamp is not valid."\n', '        );\n', '        _;\n', '    }\n', '\n', '\n', '    // set the hydro token and identity registry addresses\n', '    function setAddresses(address _identityRegistryAddress, address _hydroTokenAddress) public onlyOwner {\n', '        identityRegistryAddress = _identityRegistryAddress;\n', '        identityRegistry = IdentityRegistryInterface(identityRegistryAddress);\n', '\n', '        hydroTokenAddress = _hydroTokenAddress;\n', '        hydroToken = HydroInterface(hydroTokenAddress);\n', '    }\n', '\n', '    function setClientRaindropAddress(address _clientRaindropAddress) public onlyOwner {\n', '        clientRaindropAddress = _clientRaindropAddress;\n', '        clientRaindrop = ClientRaindropInterface(clientRaindropAddress);\n', '    }\n', '\n', '    // wrap createIdentityDelegated and initialize the client raindrop resolver\n', '    function createIdentityDelegated(\n', '        address recoveryAddress, address associatedAddress, address[] memory providers, string memory casedHydroId,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public returns (uint ein)\n', '    {\n', '        address[] memory _providers = new address[](providers.length + 1);\n', '        _providers[0] = address(this);\n', '        for (uint i; i < providers.length; i++) {\n', '            _providers[i + 1] = providers[i];\n', '        }\n', '\n', '        uint _ein = identityRegistry.createIdentityDelegated(\n', '            recoveryAddress, associatedAddress, _providers, new address[](0), v, r, s, timestamp\n', '        );\n', '\n', '        _addResolver(_ein, clientRaindropAddress, true, 0, abi.encode(associatedAddress, casedHydroId));\n', '\n', '        return _ein;\n', '    }\n', '\n', '    // permission addProvidersFor by signature\n', '    function addProvidersFor(\n', '        address approvingAddress, address[] memory providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp)\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize that these Providers be added to my Identity.",\n', '                        ein, providers, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        identityRegistry.addProvidersFor(ein, providers);\n', '    }\n', '\n', '    // permission removeProvidersFor by signature\n', '    function removeProvidersFor(\n', '        address approvingAddress, address[] memory providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp)\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize that these Providers be removed from my Identity.",\n', '                        ein, providers, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        identityRegistry.removeProvidersFor(ein, providers);\n', '    }\n', '\n', '    // permissioned addProvidersFor and removeProvidersFor by signature\n', '    function upgradeProvidersFor(\n', '        address approvingAddress, address[] memory newProviders, address[] memory oldProviders,\n', '        uint8[2] memory v, bytes32[2] memory r, bytes32[2] memory s, uint[2] memory timestamp\n', '    )\n', '        public\n', '    {\n', '        addProvidersFor(approvingAddress, newProviders, v[0], r[0], s[0], timestamp[0]);\n', '        removeProvidersFor(approvingAddress, oldProviders, v[1], r[1], s[1], timestamp[1]);\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '        emit SnowflakeProvidersUpgraded(ein, newProviders, oldProviders, approvingAddress);\n', '    }\n', '\n', '    // permission adding a resolver for identity of msg.sender\n', '    function addResolver(address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData) public {\n', '        _addResolver(identityRegistry.getEIN(msg.sender), resolver, isSnowflake, withdrawAllowance, extraData);\n', '    }\n', '\n', '    // permission adding a resolver for identity passed by a provider\n', '    function addResolverAsProvider(\n', '        uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData\n', '    )\n', '        public\n', '    {\n', '        require(identityRegistry.isProviderFor(ein, msg.sender), "The msg.sender is not a Provider for the passed EIN");\n', '        _addResolver(ein, resolver, isSnowflake, withdrawAllowance, extraData);\n', '    }\n', '\n', '    // permission addResolversFor by signature\n', '    function addResolverFor(\n', '        address approvingAddress, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '\n', '        validateAddResolverForSignature(\n', '            approvingAddress, ein, resolver, isSnowflake, withdrawAllowance, extraData, v, r, s, timestamp\n', '        );\n', '\n', '        _addResolver(ein, resolver, isSnowflake, withdrawAllowance, extraData);\n', '    }\n', '\n', '    function validateAddResolverForSignature(\n', '        address approvingAddress, uint ein,\n', '        address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        private view ensureSignatureTimeValid(timestamp)\n', '    {\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize that this resolver be added to my Identity.",\n', '                        ein, resolver, isSnowflake, withdrawAllowance, extraData, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '    }\n', '\n', '    // common logic for adding resolvers\n', '    function _addResolver(uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData)\n', '        private\n', '    {\n', '        require(!identityRegistry.isResolverFor(ein, resolver), "Identity has already set this resolver.");\n', '\n', '        address[] memory resolvers = new address[](1);\n', '        resolvers[0] = resolver;\n', '        identityRegistry.addResolversFor(ein, resolvers);\n', '\n', '        if (isSnowflake) {\n', '            resolverAllowances[ein][resolver] = withdrawAllowance;\n', '            SnowflakeResolverInterface snowflakeResolver = SnowflakeResolverInterface(resolver);\n', '            if (snowflakeResolver.callOnAddition())\n', '                require(snowflakeResolver.onAddition(ein, withdrawAllowance, extraData), "Sign up failure.");\n', '            emit SnowflakeResolverAdded(ein, resolver, withdrawAllowance);\n', '        }\n', '    }\n', '\n', '    // permission changing resolver allowances for identity of msg.sender\n', '    function changeResolverAllowances(address[] memory resolvers, uint[] memory withdrawAllowances) public {\n', '        changeResolverAllowances(identityRegistry.getEIN(msg.sender), resolvers, withdrawAllowances);\n', '    }\n', '\n', '    // change resolver allowances delegated\n', '    function changeResolverAllowancesDelegated(\n', '        address approvingAddress, address[] memory resolvers, uint[] memory withdrawAllowances,\n', '        uint8 v, bytes32 r, bytes32 s\n', '    )\n', '        public\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '\n', '        uint nonce = signatureNonce[ein]++;\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize this change in Resolver allowances.",\n', '                        ein, resolvers, withdrawAllowances, nonce\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        changeResolverAllowances(ein, resolvers, withdrawAllowances);\n', '    }\n', '\n', '    // common logic to change resolver allowances\n', '    function changeResolverAllowances(uint ein, address[] memory resolvers, uint[] memory withdrawAllowances) private {\n', '        require(resolvers.length == withdrawAllowances.length, "Malformed inputs.");\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(identityRegistry.isResolverFor(ein, resolvers[i]), "Identity has not set this resolver.");\n', '            resolverAllowances[ein][resolvers[i]] = withdrawAllowances[i];\n', '            emit SnowflakeResolverAllowanceChanged(ein, resolvers[i], withdrawAllowances[i]);\n', '        }\n', '    }\n', '\n', '    // permission removing a resolver for identity of msg.sender\n', '    function removeResolver(address resolver, bool isSnowflake, bytes memory extraData) public {\n', '        removeResolver(identityRegistry.getEIN(msg.sender), resolver, isSnowflake, extraData);\n', '    }\n', '\n', '    // permission removeResolverFor by signature\n', '    function removeResolverFor(\n', '        address approvingAddress, address resolver, bool isSnowflake, bytes memory extraData,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        public ensureSignatureTimeValid(timestamp)\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '\n', '        validateRemoveResolverForSignature(approvingAddress, ein, resolver, isSnowflake, extraData, v, r, s, timestamp);\n', '\n', '        removeResolver(ein, resolver, isSnowflake, extraData);\n', '    }\n', '\n', '    function validateRemoveResolverForSignature(\n', '        address approvingAddress, uint ein, address resolver, bool isSnowflake, bytes memory extraData,\n', '        uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    )\n', '        private view\n', '    {\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize that these Resolvers be removed from my Identity.",\n', '                        ein, resolver, isSnowflake, extraData, timestamp\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '    }\n', '\n', '    // common logic to remove resolvers\n', '    function removeResolver(uint ein, address resolver, bool isSnowflake, bytes memory extraData) private {\n', '        require(identityRegistry.isResolverFor(ein, resolver), "Identity has not yet set this resolver.");\n', '    \n', '        delete resolverAllowances[ein][resolver];\n', '    \n', '        if (isSnowflake) {\n', '            SnowflakeResolverInterface snowflakeResolver = SnowflakeResolverInterface(resolver);\n', '            if (snowflakeResolver.callOnRemoval())\n', '                require(snowflakeResolver.onRemoval(ein, extraData), "Removal failure.");\n', '            emit SnowflakeResolverRemoved(ein, resolver);\n', '        }\n', '\n', '        address[] memory resolvers = new address[](1);\n', '        resolvers[0] = resolver;\n', '        identityRegistry.removeResolversFor(ein, resolvers);\n', '    }\n', '\n', '    function triggerRecoveryAddressChangeFor(\n', '        address approvingAddress, address newRecoveryAddress, uint8 v, bytes32 r, bytes32 s\n', '    )\n', '        public\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '        uint nonce = signatureNonce[ein]++;\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize this change of Recovery Address.",\n', '                        ein, newRecoveryAddress, nonce\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        identityRegistry.triggerRecoveryAddressChangeFor(ein, newRecoveryAddress);\n', '    }\n', '\n', '    // allow contract to receive HYDRO tokens\n', '    function receiveApproval(address sender, uint amount, address _tokenAddress, bytes memory _bytes) public {\n', '        require(msg.sender == _tokenAddress, "Malformed inputs.");\n', '        require(_tokenAddress == hydroTokenAddress, "Sender is not the HYDRO token smart contract.");\n', '\n', '        // depositing to an EIN\n', '        if (_bytes.length <= 32) {\n', '            require(hydroToken.transferFrom(sender, address(this), amount), "Unable to transfer token ownership.");\n', '            uint recipient;\n', '            if (_bytes.length < 32) {\n', '                recipient = identityRegistry.getEIN(sender);\n', '            }\n', '            else {\n', '                recipient = abi.decode(_bytes, (uint));\n', '                require(identityRegistry.identityExists(recipient), "The recipient EIN does not exist.");\n', '            }\n', '            deposits[recipient] = deposits[recipient].add(amount);\n', '            emit SnowflakeDeposit(sender, recipient, amount);\n', '        }\n', '        // transferring to a via\n', '        else {\n', '            (\n', '                bool isTransfer, address resolver, address via, uint to, bytes memory snowflakeCallBytes\n', '            ) = abi.decode(_bytes, (bool, address, address, uint, bytes));\n', '            \n', '            require(hydroToken.transferFrom(sender, via, amount), "Unable to transfer token ownership.");\n', '\n', '            SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\n', '            if (isTransfer) {\n', '                viaContract.snowflakeCall(resolver, to, amount, snowflakeCallBytes);\n', '                emit SnowflakeTransferToVia(resolver, via, to, amount);\n', '            } else {\n', '                address payable payableTo = address(to);\n', '                viaContract.snowflakeCall(resolver, payableTo, amount, snowflakeCallBytes);\n', '                emit SnowflakeWithdrawToVia(resolver, via, address(to), amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    // transfer snowflake balance from one snowflake holder to another\n', '    function transferSnowflakeBalance(uint einTo, uint amount) public {\n', '        _transfer(identityRegistry.getEIN(msg.sender), einTo, amount);\n', '    }\n', '\n', '    // withdraw Snowflake balance to an external address\n', '    function withdrawSnowflakeBalance(address to, uint amount) public {\n', '        _withdraw(identityRegistry.getEIN(msg.sender), to, amount);\n', '    }\n', '\n', '    // allows resolvers to transfer allowance amounts to other snowflakes (throws if unsuccessful)\n', '    function transferSnowflakeBalanceFrom(uint einFrom, uint einTo, uint amount) public {\n', '        handleAllowance(einFrom, amount);\n', '        _transfer(einFrom, einTo, amount);\n', '        emit SnowflakeTransferFrom(msg.sender);\n', '    }\n', '\n', '    // allows resolvers to withdraw allowance amounts to external addresses (throws if unsuccessful)\n', '    function withdrawSnowflakeBalanceFrom(uint einFrom, address to, uint amount) public {\n', '        handleAllowance(einFrom, amount);\n', '        _withdraw(einFrom, to, amount);\n', '        emit SnowflakeWithdrawFrom(msg.sender);\n', '    }\n', '\n', "    // allows resolvers to send withdrawal amounts to arbitrary smart contracts 'to' identities (throws if unsuccessful)\n", '    function transferSnowflakeBalanceFromVia(uint einFrom, address via, uint einTo, uint amount, bytes memory _bytes)\n', '        public\n', '    {\n', '        handleAllowance(einFrom, amount);\n', '        _withdraw(einFrom, via, amount);\n', '        SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\n', '        viaContract.snowflakeCall(msg.sender, einFrom, einTo, amount, _bytes);\n', '        emit SnowflakeTransferFromVia(msg.sender, einTo);\n', '    }\n', '\n', "    // allows resolvers to send withdrawal amounts 'to' addresses via arbitrary smart contracts\n", '    function withdrawSnowflakeBalanceFromVia(\n', '        uint einFrom, address via, address payable to, uint amount, bytes memory _bytes\n', '    )\n', '        public\n', '    {\n', '        handleAllowance(einFrom, amount);\n', '        _withdraw(einFrom, via, amount);\n', '        SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\n', '        viaContract.snowflakeCall(msg.sender, einFrom, to, amount, _bytes);\n', '        emit SnowflakeWithdrawFromVia(msg.sender, to);\n', '    }\n', '\n', '    function _transfer(uint einFrom, uint einTo, uint amount) private identityExists(einTo, true) returns (bool) {\n', '        require(deposits[einFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[einFrom] = deposits[einFrom].sub(amount);\n', '        deposits[einTo] = deposits[einTo].add(amount);\n', '\n', '        emit SnowflakeTransfer(einFrom, einTo, amount);\n', '    }\n', '\n', '    function _withdraw(uint einFrom, address to, uint amount) internal {\n', '        require(to != address(this), "Cannot transfer to the Snowflake smart contract itself.");\n', '\n', '        require(deposits[einFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[einFrom] = deposits[einFrom].sub(amount);\n', '        require(hydroToken.transfer(to, amount), "Transfer was unsuccessful");\n', '\n', '        emit SnowflakeWithdraw(einFrom, to, amount);\n', '    }\n', '\n', '    function handleAllowance(uint einFrom, uint amount) internal {\n', '        // check that resolver-related details are correct\n', '        require(identityRegistry.isResolverFor(einFrom, msg.sender), "Resolver has not been set by from tokenholder.");\n', '\n', '        if (resolverAllowances[einFrom][msg.sender] < amount) {\n', '            emit SnowflakeInsufficientAllowance(einFrom, msg.sender, resolverAllowances[einFrom][msg.sender], amount);\n', '            revert("Insufficient Allowance");\n', '        }\n', '\n', '        resolverAllowances[einFrom][msg.sender] = resolverAllowances[einFrom][msg.sender].sub(amount);\n', '    }\n', '\n', '    // allowAndCall from msg.sender\n', '    function allowAndCall(address destination, uint amount, bytes memory data)\n', '        public returns (bytes memory returnData)\n', '    {\n', '        return allowAndCall(identityRegistry.getEIN(msg.sender), amount, destination, data);\n', '    }\n', '\n', '    // allowAndCall from approvingAddress with meta-transaction\n', '    function allowAndCallDelegated(\n', '        address destination, uint amount, bytes memory data, address approvingAddress, uint8 v, bytes32 r, bytes32 s\n', '    )\n', '        public returns (bytes memory returnData)\n', '    {\n', '        uint ein = identityRegistry.getEIN(approvingAddress);\n', '        uint nonce = signatureNonce[ein]++;\n', '        validateAllowAndCallDelegatedSignature(approvingAddress, ein, destination, amount, data, nonce, v, r, s);\n', '\n', '        return allowAndCall(ein, amount, destination, data);\n', '    }\n', '\n', '    function validateAllowAndCallDelegatedSignature(\n', '        address approvingAddress, uint ein, address destination, uint amount, bytes memory data, uint nonce,\n', '        uint8 v, bytes32 r, bytes32 s\n', '    )\n', '        private view\n', '    {\n', '        require(\n', '            identityRegistry.isSigned(\n', '                approvingAddress,\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        byte(0x19), byte(0), address(this),\n', '                        "I authorize this allow and call.", ein, destination, amount, data, nonce\n', '                    )\n', '                ),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '    }\n', '\n', '    // internal logic for allowAndCall\n', '    function allowAndCall(uint ein, uint amount, address destination, bytes memory data)\n', '        private returns (bytes memory returnData)\n', '    {\n', '        // check that resolver-related details are correct\n', '        require(identityRegistry.isResolverFor(ein, destination), "Destination has not been set by from tokenholder.");\n', '        if (amount != 0) {\n', '            resolverAllowances[ein][destination] = resolverAllowances[ein][destination].add(amount);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        (bool success, bytes memory _returnData) = destination.call(data);\n', '        require(success, "Call was not successful.");\n', '        return _returnData;\n', '    }\n', '\n', '    // events\n', '    event SnowflakeProvidersUpgraded(uint indexed ein, address[] newProviders, address[] oldProviders, address approvingAddress);\n', '\n', '    event SnowflakeResolverAdded(uint indexed ein, address indexed resolver, uint withdrawAllowance);\n', '    event SnowflakeResolverAllowanceChanged(uint indexed ein, address indexed resolver, uint withdrawAllowance);\n', '    event SnowflakeResolverRemoved(uint indexed ein, address indexed resolver);\n', '\n', '    event SnowflakeDeposit(address indexed from, uint indexed einTo, uint amount);\n', '    event SnowflakeTransfer(uint indexed einFrom, uint indexed einTo, uint amount);\n', '    event SnowflakeWithdraw(uint indexed einFrom, address indexed to, uint amount);\n', '\n', '    event SnowflakeTransferFrom(address indexed resolverFrom);\n', '    event SnowflakeWithdrawFrom(address indexed resolverFrom);\n', '    event SnowflakeTransferFromVia(address indexed resolverFrom, uint indexed einTo);\n', '    event SnowflakeWithdrawFromVia(address indexed resolverFrom, address indexed to);\n', '    event SnowflakeTransferToVia(address indexed resolverFrom, address indexed via, uint indexed einTo, uint amount);\n', '    event SnowflakeWithdrawToVia(address indexed resolverFrom, address indexed via, address indexed to, uint amount);\n', '\n', '    event SnowflakeInsufficientAllowance(\n', '        uint indexed ein, address indexed resolver, uint currentAllowance, uint requestedWithdraw\n', '    );\n', '}']