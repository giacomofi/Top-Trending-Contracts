['pragma solidity ^0.4.24;\n', '\n', 'contract MultiSend {\n', '\n', '  struct Receiver {\n', '    address addr;\n', '    uint amount;\n', '  }\n', '\n', '  event MultiTransfer (\n', '    address from,\n', '    uint total,\n', '    Receiver[] receivers\n', '  );\n', '\n', '  address owner;\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(owner == msg.sender, "msg sender is not owner!");\n', '    _;\n', '  }\n', '\n', '  function close() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function _safeTransfer(address _to, uint _amount) internal {\n', '      require(_to != 0);\n', '      _to.transfer(_amount);\n', '  }\n', '\n', '  function multiTransfer(address[] _addresses, uint[] _amounts)\n', '    payable public returns(bool)\n', '  {\n', '      require(_addresses.length == _amounts.length);\n', '      Receiver[] memory receivers = new Receiver[](_addresses.length);\n', '      uint toReturn = msg.value;\n', '      for (uint i = 0; i < _addresses.length; i++) {\n', '          _safeTransfer(_addresses[i], _amounts[i]);\n', '          toReturn = SafeMath.sub(toReturn, _amounts[i]);\n', '          receivers[i].addr = _addresses[i];\n', '          receivers[i].amount = _amounts[i]; \n', '      }\n', '      emit MultiTransfer(msg.sender, msg.value, receivers);\n', '      return true;\n', '  }\n', '}\n', '\n', 'library SafeMath\n', '{\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}']