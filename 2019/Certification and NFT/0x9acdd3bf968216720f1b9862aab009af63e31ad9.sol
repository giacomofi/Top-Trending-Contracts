['// File: contracts/lib/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '    constructor() public { owner = msg.sender; }\n', '\n', '    /// @dev Throws if called by any contract other than latest designated caller\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/token/FactoryTokenInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract FactoryTokenInterface is Ownable {\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function burnFrom(address _from, uint256 _value) public;\n', '}\n', '\n', '// File: contracts/lib/token/TokenFactoryInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract TokenFactoryInterface {\n', '    function create(string _name, string _symbol) public returns (FactoryTokenInterface);\n', '}\n', '\n', '// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract ZapCoordinatorInterface is Ownable {\n', '    function addImmutableContract(string contractName, address newAddress) external;\n', '    function updateContract(string contractName, address newAddress) external;\n', '    function getContractName(uint index) public view returns (string);\n', '    function getContract(string contractName) public view returns (address);\n', '    function updateAllDependencies() external;\n', '}\n', '\n', '// File: contracts/platform/bondage/BondageInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract BondageInterface {\n', '    function bond(address, bytes32, uint256) external returns(uint256);\n', '    function unbond(address, bytes32, uint256) external returns (uint256);\n', '    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\n', '    function escrowDots(address, address, bytes32, uint256) external returns (bool);\n', '    function releaseDots(address, address, bytes32, uint256) external returns (bool);\n', '    function returnDots(address, address, bytes32, uint256) external returns (bool success);\n', '    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\n', '    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\n', '    function getDotsIssued(address, bytes32) public view returns (uint256);\n', '    function getBoundDots(address, address, bytes32) public view returns (uint256);\n', '    function getZapBound(address, bytes32) public view returns (uint256);\n', '    function dotLimit( address, bytes32) public view returns (uint256);\n', '}\n', '\n', '// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract CurrentCostInterface {\n', '    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\n', '    function _dotLimit(address, bytes32) public view returns (uint256);\n', '    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\n', '}\n', '\n', '// File: contracts/platform/registry/RegistryInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract RegistryInterface {\n', '    function initiateProvider(uint256, bytes32) public returns (bool);\n', '    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\n', '    function setEndpointParams(bytes32, bytes32[]) public;\n', '    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\n', '    function getProviderPublicKey(address) public view returns (uint256);\n', '    function getProviderTitle(address) public view returns (bytes32);\n', '    function setProviderParameter(bytes32, bytes) public;\n', '    function setProviderTitle(bytes32) public;\n', '    function clearEndpoint(bytes32) public;\n', '    function getProviderParameter(address, bytes32) public view returns (bytes);\n', '    function getAllProviderParams(address) public view returns (bytes32[]);\n', '    function getProviderCurveLength(address, bytes32) public view returns (uint256);\n', '    function getProviderCurve(address, bytes32) public view returns (int[]);\n', '    function isProviderInitiated(address) public view returns (bool);\n', '    function getAllOracles() external view returns (address[]);\n', '    function getProviderEndpoints(address) public view returns (bytes32[]);\n', '    function getEndpointBroker(address, bytes32) public view returns (address);\n', '}\n', '\n', '// File: contracts/lib/platform/SampleContest.sol\n', '\n', '/*\n', 'Contest where users can bond to contestant curves which mint tokens( unbondabe*),\n', 'winner decided by oracle\n', 'contract unbonds from loser curves\n', 'holders of winning token allowed to take share of reserve token(zap) which was unbonded from loser curves\n', '\n', 'Starting Contest:\n', '\n', '    deploys with contest uninitialized: status = Uninitialized\n', '\n', '    anyone can initialize new token:backed curve\n', '\n', '    owner initializes contest with oracle: status = Initialized\n', '\n', 'Ending Contest:\n', '\n', '    owner calls close: status = ReadyToSettle\n', '\n', '    oracle calls judge to set winning curve: status = Judged\n', '\n', '    anyone calls settle, contest unbonds from losing curves: status = Settled\n', '\n', '    holders of winnning token call redeem to retrieve their share of reserve token\n', '    based on their holding of winning token\n', '\n', '    *holders of winning token can optionally unbond\n', '*/\n', '\n', 'contract SampleContest is Ownable {\n', '\n', '    CurrentCostInterface currentCost;\n', '    FactoryTokenInterface public reserveToken;\n', '    ZapCoordinatorInterface public coord;\n', '    TokenFactoryInterface public tokenFactory;\n', '    BondageInterface bondage;\n', '\n', '    enum ContestStatus {\n', '        Uninitialized,    //\n', '        Initialized,      // ready for buys\n', '        // ReadyToSettle,    // ready for judgement\n', '        Judged,           // winner determined\n', '        Settled,           // value of winning tokens determined\n', '        Canceled          // oracle did not respond in time\n', '    }\n', '\n', '    address public oracle;    // address of oracle who will choose the winner\n', '    uint256 public ttl;    // time allowed before, close and judge. if time expired, allow unbond from all curves\n', '    // uint256 public expired = 2**256 -1;    // time allowed before, close and judge. if time expired, allow unbond from all curves\n', '    bytes32 public winner;    // curve identifier of the winner\n', '    uint256 public winValue;  // final value of the winning token\n', '    ContestStatus public status; //state of contest\n', '\n', '    mapping(bytes32 => address) public curves; // map of endpoint specifier to token-backed dotaddress\n', '    bytes32[] public curves_list; // array of endpoint specifiers\n', '\n', '    mapping(address => uint8) public redeemed; // map of address redemption state\n', '    address[] public redeemed_list;\n', '\n', '    event DotTokenCreated(address tokenAddress);\n', '    event Bonded(bytes32 indexed endpoint, uint256 indexed numDots, address indexed sender);\n', '    event Unbonded(bytes32 indexed endpoint,uint256 indexed amount, address indexed sender);\n', '\n', '    event Initialized(address indexed oracle);\n', '    event Closed();\n', '    event Judged(bytes32 winner);\n', '    event Settled(uint256 winValue, uint256 winTokens);\n', '    event Reset();\n', '\n', '    constructor(\n', '        address coordinator,\n', '        address factory,\n', '        uint256 providerPubKey,\n', '        bytes32 providerTitle\n', '    ){\n', '        coord = ZapCoordinatorInterface(coordinator);\n', '        reserveToken = FactoryTokenInterface(coord.getContract("ZAP_TOKEN"));\n', '        //always allow bondage to transfer from wallet\n', '        reserveToken.approve(coord.getContract("BONDAGE"), ~uint256(0));\n', '        tokenFactory = TokenFactoryInterface(factory);\n', '\n', '        RegistryInterface registry = RegistryInterface(coord.getContract("REGISTRY"));\n', '        registry.initiateProvider(providerPubKey, providerTitle);\n', '        status = ContestStatus.Uninitialized;\n', '    }\n', '\n', '// contest lifecycle\n', '\n', '    function initializeContest(\n', '        address oracleAddress,\n', '        uint256 _ttl\n', '    ) onlyOwner public {\n', '        require( status == ContestStatus.Uninitialized, "Contest already initialized");\n', '        oracle = oracleAddress;\n', '        ttl = _ttl + block.number;\n', '        status = ContestStatus.Initialized;\n', '        emit Initialized(oracle);\n', '    }\n', '\n', '    // function close() onlyOwner {\n', '    //     status = ContestStatus.ReadyToSettle;\n', '    //     expired = block.number + ttl;\n', '    //     emit Closed();\n', '    // }\n', '\n', '    function judge(bytes32 endpoint) {\n', '        require( status == ContestStatus.Initialized, "Contest not initialized" );\n', '        require( msg.sender == oracle, "Only designated Oracle can judge");\n', '        require(block.number < ttl, "Contest expired, refund in process");\n', '        winner = endpoint;\n', '        status = ContestStatus.Judged;\n', '        emit Judged(winner);\n', '    }\n', '\n', '    function settle() public {\n', '        require( status == ContestStatus.Judged, "winner not determined");\n', '\n', '        bondage = BondageInterface(coord.getContract("BONDAGE"));\n', '        // how many winning dots\n', '        uint256 numWin =  bondage.getDotsIssued(address(this), winner);\n', '        // redeemable value of each dot token\n', '        uint256 dots;\n', '        for( uint256 i = 0; i < curves_list.length; i++) {\n', '          if(curves_list[i]!=winner){\n', '            dots =  bondage.getDotsIssued(address(this), curves_list[i]);\n', '            if( dots > 0) {\n', '                bondage.unbond(address(this), curves_list[i], dots);\n', '            }\n', '          }\n', '        }\n', '        winValue = reserveToken.balanceOf(address(this)) / numWin;\n', '\n', '        status = ContestStatus.Settled;\n', '        emit Settled(winValue, numWin);\n', '    }\n', '\n', '\n', '    //TODO ensure all has been redeemed or enough time has elasped\n', '    function reset() public {\n', '        require(msg.sender == oracle);\n', '        require(status == ContestStatus.Settled || status == ContestStatus.Canceled, "contest not settled");\n', '        if( status == ContestStatus.Canceled ) {\n', '            require(reserveToken.balanceOf(address(this)) == 0, "funds remain");\n', '        }\n', '\n', '        delete redeemed_list;\n', '        delete curves_list;\n', '        status = ContestStatus.Initialized;\n', '        emit Reset();\n', '    }\n', '\n', '/// TokenDotFactory methods\n', '\n', '    function initializeCurve(\n', '        bytes32 endpoint,\n', '        bytes32 symbol,\n', '        int256[] curve\n', '    ) public returns(address) {\n', '        // require(status==ContestStatus.Initialized,"Contest is not initalized")\n', '        require(curves[endpoint] == 0, "Curve endpoint already exists or used in the past. Please choose a new endpoint");\n', '\n', '        RegistryInterface registry = RegistryInterface(coord.getContract("REGISTRY"));\n', '        registry.initiateProviderCurve(endpoint, curve, address(this));\n', '\n', '        curves[endpoint] = newToken(bytes32ToString(endpoint), bytes32ToString(symbol));\n', '        curves_list.push(endpoint);\n', '        registry.setProviderParameter(endpoint, toBytes(curves[endpoint]));\n', '\n', '        DotTokenCreated(curves[endpoint]);\n', '        return curves[endpoint];\n', '    }\n', '\n', '    //whether this contract holds tokens or coming from msg.sender,etc\n', '    function bond(bytes32 endpoint, uint numDots) public  {\n', '        require( status == ContestStatus.Initialized, " contest is not initiated");\n', '\n', '        bondage = BondageInterface(coord.getContract("BONDAGE"));\n', '        uint256 issued = bondage.getDotsIssued(address(this), endpoint);\n', '\n', '        CurrentCostInterface cost = CurrentCostInterface(coord.getContract("CURRENT_COST"));\n', '        uint256 numReserve = cost._costOfNDots(address(this), endpoint, issued + 1, numDots - 1);\n', '\n', '        require(\n', '            reserveToken.transferFrom(msg.sender, address(this), numReserve),\n', '            "insufficient accepted token numDots approved for transfer"\n', '        );\n', '\n', '        reserveToken.approve(address(bondage), numReserve);\n', '        bondage.bond(address(this), endpoint, numDots);\n', '        FactoryTokenInterface(curves[endpoint]).mint(msg.sender, numDots);\n', '        emit Bonded(endpoint, numDots, msg.sender);\n', '    }\n', '\n', '    //whether this contract holds tokens or coming from msg.sender,etc\n', '    function unbond(bytes32 endpoint, uint numDots) public returns(uint256) {\n', '\n', '        require(status == ContestStatus.Settled, "not ready");\n', '\n', '        bondage = BondageInterface(coord.getContract("BONDAGE"));\n', '        uint issued = bondage.getDotsIssued(address(this), endpoint);\n', '\n', '        //unbond dots\n', '        bondage.unbond(address(this), winner, numDots);\n', '\n', '        currentCost = CurrentCostInterface(coord.getContract("CURRENT_COST"));\n', '        //get reserve value to send\n', '        uint reserveCost = currentCost._costOfNDots(address(this), endpoint, issued + 1 - numDots, numDots - 1);\n', '\n', '        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[endpoint]);\n', '\n', '        if( status == ContestStatus.Initialized || status == ContestStatus.Canceled) {\n', '            //oracle has taken too long to judge winner so unbonds will be allowed for all\n', '            require(block.number > ttl, "oracle query not expired.");\n', '            // require(status == ContestStatus.Settled, "contest not settled");\n', '            status = ContestStatus.Canceled;\n', '\n', '            //unbond dots\n', '            //TODO get bound dot then unbond the correct amount ? or unbond all in 1 call\n', '            // bondage.unbond(address(this), endpoint, numDots);\n', '\n', '            //burn dot backed token\n', '            //FIXME only burn the bound tokens ?\n', '            curveToken.burnFrom(msg.sender, numDots);\n', '\n', '            require(reserveToken.transfer(msg.sender, reserveCost), "transfer failed");\n', '            emit Unbonded(endpoint, reserveCost, msg.sender);\n', '            return reserveCost;\n', '        }\n', '\n', '        else {\n', '\n', '            require( status == ContestStatus.Settled, " contest not settled");\n', '            require(redeemed[msg.sender] == 0, "already redeeemed");\n', '            require(winner==endpoint, "only winners can unbond for rewards");\n', '\n', "            //reward user's winning tokens unbond value + share of losing curves reserve token proportional to winning token holdings\n", '            uint reward = ( winValue * FactoryTokenInterface(getTokenAddress(winner)).balanceOf(msg.sender) ) + reserveCost;\n', '\n', "            //burn user's unbonded tokens\n", '            // curveToken.approve(address(this),numDots);\n', '            curveToken.burnFrom(msg.sender, numDots);\n', '\n', '            reserveToken.transfer(msg.sender, reward);\n', '            redeemed[msg.sender] = 1;\n', '\n', '            // emit Unbonded(winner, reward, msg.sender);\n', '            return reward;\n', '        }\n', '    }\n', '\n', '    function newToken(\n', '        string name,\n', '        string symbol\n', '    )\n', '        internal\n', '        returns (address tokenAddress)\n', '    {\n', '        FactoryTokenInterface token = tokenFactory.create(name, symbol);\n', '        tokenAddress = address(token);\n', '        return tokenAddress;\n', '    }\n', '\n', '    function getTokenAddress(bytes32 endpoint) public view returns(address) {\n', '        RegistryInterface registry = RegistryInterface(coord.getContract("REGISTRY"));\n', '        return bytesToAddr(registry.getProviderParameter(address(this), endpoint));\n', '    }\n', '\n', '    function getEndpoints() public view returns(bytes32[]){\n', '      return curves_list;\n', '    }\n', '\n', '    function getStatus() public view returns(uint256){\n', '      return uint(status);\n', '    }\n', '\n', '    function isEndpointValid(bytes32 _endpoint) public view returns(bool){\n', '      for(uint256 i=0; i<curves_list.length;i++){\n', '        if(_endpoint == curves_list[i]){\n', '          return true;\n', '        }\n', '      }\n', '      return false;\n', '    }\n', '\n', '    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\n', '    function toBytes(address x) public pure returns (bytes b) {\n', '        b = new bytes(20);\n', '        for (uint i = 0; i < 20; i++)\n', '            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '    }\n', '\n', '    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\n', '    function bytes32ToString(bytes32 x) public pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        bytesString = abi.encodePacked(x);\n', '        return string(bytesString);\n', '    }\n', '\n', '    //https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity\n', '    function bytesToAddr (bytes b) public pure returns (address) {\n', '        uint result = 0;\n', '        for (uint i = b.length-1; i+1 > 0; i--) {\n', '            uint c = uint(b[i]);\n', '            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '            result += to_inc;\n', '        }\n', '        return address(result);\n', '    }\n', '}\n', '\n', '// File: contracts/platform/dispatch/DispatchInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'interface DispatchInterface {\n', '    function query(address, string, bytes32, bytes32[]) external returns (uint256);\n', '    function respond1(uint256, string) external returns (bool);\n', '    function respond2(uint256, string, string) external returns (bool);\n', '    function respond3(uint256, string, string, string) external returns (bool);\n', '    function respond4(uint256, string, string, string, string) external returns (bool);\n', '    function respondBytes32Array(uint256, bytes32[]) external returns (bool);\n', '    function respondIntArray(uint256,int[] ) external returns (bool);\n', '    function cancelQuery(uint256) external;\n', '    function getProvider(uint256 id) public view returns (address);\n', '    function getSubscriber(uint256 id) public view returns (address);\n', '    function getEndpoint(uint256 id) public view returns (bytes32);\n', '    function getStatus(uint256 id) public view returns (uint256);\n', '    function getCancel(uint256 id) public view returns (uint256);\n', '    function getUserQuery(uint256 id) public view returns (string);\n', '    function getSubscriberOnchain(uint256 id) public view returns (bool);\n', '}\n', '\n', '// File: contracts/lib/platform/Client.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract Client1 {\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response1 first provider-specified param\n', '    function callback(uint256 id, string response1) external;\n', '}\n', 'contract Client2 {\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response1 first provider-specified param\n', '    /// @param response2 second provider-specified param\n', '    function callback(uint256 id, string response1, string response2) external;\n', '}\n', 'contract Client3 {\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response1 first provider-specified param\n', '    /// @param response2 second provider-specified param\n', '    /// @param response3 third provider-specified param\n', '    function callback(uint256 id, string response1, string response2, string response3) external;\n', '}\n', 'contract Client4 {\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response1 first provider-specified param\n', '    /// @param response2 second provider-specified param\n', '    /// @param response3 third provider-specified param\n', '    /// @param response4 fourth provider-specified param\n', '    function callback(uint256 id, string response1, string response2, string response3, string response4) external;\n', '}\n', '\n', 'contract ClientBytes32Array {\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response bytes32 array\n', '    function callback(uint256 id, bytes32[] response) external;\n', '}\n', '\n', 'contract ClientIntArray{\n', '    /// @dev callback that provider will call after Dispatch.query() call\n', '    /// @param id request id\n', '    /// @param response int array\n', '    function callback(uint256 id, int[] response) external;\n', '}\n', '\n', '// File: contracts/lib/platform/BTCcontest.sol\n', '\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract BTCcontest is Ownable, ClientIntArray {\n', '  SampleContest public contest;\n', '  ZapCoordinatorInterface public coordinator;\n', '  address public oracle;\n', '  uint256 public query_id;\n', '  uint256 public startPrice;\n', '  bytes32 public upEndpoint;\n', '  bytes32 public downEndpoint;\n', '\n', '  constructor(\n', '    address _cord,\n', '    address _contest,\n', '    uint256 _startPrice,\n', '    bytes32 _upEndpoint,\n', '    bytes32 _downEndpoint\n', '  ){\n', '    oracle = msg.sender;\n', '    contest = SampleContest(_contest);\n', '    startPrice = _startPrice;\n', '    coordinator = ZapCoordinatorInterface(_cord);\n', '    require(contest.isEndpointValid(_upEndpoint) && contest.isEndpointValid(_downEndpoint),"Endpoints are not valid");\n', '    upEndpoint = _upEndpoint;\n', '    downEndpoint = _downEndpoint;\n', '    address bondageAddress = coordinator.getContract("BONDAGE");\n', '    BondageInterface bondage = BondageInterface(bondageAddress);\n', '    FactoryTokenInterface reserveToken = FactoryTokenInterface(coordinator.getContract("ZAP_TOKEN"));\n', '    //get reserve value to send\n', '    reserveToken.approve(address(bondageAddress),~uint256(0));\n', '\n', '  }\n', '\n', '  function bondToCoincap(address _coincap,bytes32 _endpoint,uint256 _numDots)public returns (bool){\n', '    address bondageAddress = coordinator.getContract("BONDAGE");\n', '    BondageInterface bondage = BondageInterface(bondageAddress);\n', '    FactoryTokenInterface reserveToken = FactoryTokenInterface(coordinator.getContract("ZAP_TOKEN"));\n', '    //get reserve value to send\n', '    bondage.bond(_coincap,_endpoint,_numDots);\n', '    return true;\n', '\n', '  }\n', '  function queryToSettle(address _coincap,bytes32 _endpoint) public returns(uint256){\n', '    require(msg.sender == oracle, "Only Oracle owner can call query to settle");\n', '    address dispatchAddress = coordinator.getContract("DISPATCH");\n', '    DispatchInterface dispatch = DispatchInterface(dispatchAddress);\n', '    bytes32[] memory params = new bytes32[](0);\n', '    return dispatch.query(_coincap,"BTC",_endpoint,params);\n', '  }\n', '\n', '  function callback(uint256 _id, int[] responses) external {\n', '    address dispatchAddress = coordinator.getContract("DISPATCH");\n', '    require(address(msg.sender)==address(dispatchAddress),"Only accept response from dispatch");\n', '    require(contest.getStatus()==1,"Contest is not in initialized state"); //2 is the ReadyToSettle enum value\n', '    uint256 price = uint256(responses[0]);\n', '    bytes32[] memory endpoints = contest.getEndpoints();\n', '    for(uint256 i=0;i<endpoints.length;i++){\n', '      if(endpoints[i]==upEndpoint && price > startPrice){\n', '        return contest.judge(endpoints[i]);\n', '      }\n', '      if(endpoints[i]==downEndpoint && price<startPrice){\n', '        return contest.judge(endpoints[i]);\n', '      }\n', '    }\n', '  }\n', '\n', '}']