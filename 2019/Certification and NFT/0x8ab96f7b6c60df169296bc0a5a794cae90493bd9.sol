['// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/v2/tools/SelfServiceEditionCuration.sol\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '\n', '\n', '\n', 'interface IKODAV2SelfServiceEditionCuration {\n', '\n', '  function createActiveEdition(\n', '    uint256 _editionNumber,\n', '    bytes32 _editionData,\n', '    uint256 _editionType,\n', '    uint256 _startDate,\n', '    uint256 _endDate,\n', '    address _artistAccount,\n', '    uint256 _artistCommission,\n', '    uint256 _priceInWei,\n', '    string _tokenUri,\n', '    uint256 _totalAvailable\n', '  ) external returns (bool);\n', '\n', '  function artistsEditions(address _artistsAccount) external returns (uint256[1] _editionNumbers);\n', '\n', '  function totalAvailableEdition(uint256 _editionNumber) external returns (uint256);\n', '\n', '  function highestEditionNumber() external returns (uint256);\n', '}\n', '\n', 'interface IKODAAuction {\n', '  function setArtistsControlAddressAndEnabledEdition(uint256 _editionNumber, address _address) external;\n', '}\n', '\n', 'contract SelfServiceEditionCuration is Ownable, Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  event SelfServiceEditionCreated(\n', '    uint256 indexed _editionNumber,\n', '    address indexed _creator,\n', '    uint256 _priceInWei,\n', '    uint256 _totalAvailable,\n', '    bool _enableAuction\n', '  );\n', '\n', '  // Calling address\n', '  IKODAV2SelfServiceEditionCuration public kodaV2;\n', '  IKODAAuction public auction;\n', '\n', '  // Default artist commission\n', '  uint256 public artistCommission = 85;\n', '\n', '  // When true any existing KO artist can mint their own editions\n', '  bool public openToAllArtist = false;\n', '\n', '  // Simple map to only allow certain artist create editions at first\n', '  mapping(address => bool) public allowedArtists;\n', '\n', '  // Config which enforces editions to not be over this size\n', '  uint256 public maxEditionSize = 100;\n', '\n', '  // When true this will skip the invocation in time period check\n', '  bool public disableInvocationCheck = false;\n', '\n', '  // Max number of editions to be created in the time period\n', '  uint256 public maxInvocations = 3;\n', '\n', '  // The rolling time period for max number of invocations\n', '  uint256 public maxInvocationsTimePeriod = 1 days;\n', '\n', '  // Number of invocations the caller has performed in the time period\n', '  mapping(address => uint256) public invocationsInTimePeriod;\n', '\n', '  // When the current time period started\n', '  mapping(address => uint256) public timeOfFirstInvocationInPeriod;\n', '\n', '  /**\n', '   * @dev Construct a new instance of the contract\n', '   */\n', '  constructor(IKODAV2SelfServiceEditionCuration _kodaV2, IKODAAuction _auction) public {\n', '    kodaV2 = _kodaV2;\n', '    auction = _auction;\n', '  }\n', '\n', '  /**\n', '   * @dev Called by artists, create new edition on the KODA platform\n', '   */\n', '  function createEdition(\n', '    uint256 _totalAvailable,\n', '    uint256 _priceInWei,\n', '    uint256 _startDate,\n', '    string _tokenUri,\n', '    bool _enableAuction\n', '  )\n', '  public\n', '  whenNotPaused\n', '  returns (uint256 _editionNumber)\n', '  {\n', '    validateInvocations();\n', '    return _createEdition(msg.sender, _totalAvailable, _priceInWei, _startDate, _tokenUri, _enableAuction);\n', '  }\n', '\n', '  /**\n', '   * @dev Caller by owner, can create editions for other artists\n', '   * @dev Only callable from owner regardless of pause state\n', '   */\n', '  function createEditionFor(\n', '    address _artist,\n', '    uint256 _totalAvailable,\n', '    uint256 _priceInWei,\n', '    uint256 _startDate,\n', '    string _tokenUri,\n', '    bool _enableAuction\n', '  )\n', '  public\n', '  onlyOwner\n', '  returns (uint256 _editionNumber)\n', '  {\n', '    return _createEdition(_artist, _totalAvailable, _priceInWei, _startDate, _tokenUri, _enableAuction);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function for edition creation\n', '   */\n', '  function _createEdition(\n', '    address _artist,\n', '    uint256 _totalAvailable,\n', '    uint256 _priceInWei,\n', '    uint256 _startDate,\n', '    string _tokenUri,\n', '    bool _enableAuction\n', '  )\n', '  internal\n', '  returns (uint256 _editionNumber){\n', '\n', '    // Enforce edition size\n', '    require(_totalAvailable > 0, "Must be at least one available in edition");\n', '    require(_totalAvailable <= maxEditionSize, "Must not exceed max edition size");\n', '\n', '\n', '    // If we are the owner, skip this artists check\n', '    if (msg.sender != owner) {\n', '\n', '      // Enforce who can call this\n', '      if (!openToAllArtist) {\n', '        require(allowedArtists[_artist], "Only allowed artists can create editions for now");\n', '      }\n', '    }\n', '\n', '    // Find the next edition number we can use\n', '    uint256 editionNumber = getNextAvailableEditionNumber();\n', '\n', '    // Attempt to create a new edition\n', '    require(\n', '      _createNewEdition(editionNumber, _artist, _totalAvailable, _priceInWei, _startDate, _tokenUri),\n', '      "Failed to create new edition"\n', '    );\n', '\n', '    // Enable the auction if desired\n', '    if (_enableAuction) {\n', '      auction.setArtistsControlAddressAndEnabledEdition(editionNumber, _artist);\n', '    }\n', '\n', '    // Trigger event\n', '    emit SelfServiceEditionCreated(editionNumber, _artist, _priceInWei, _totalAvailable, _enableAuction);\n', '\n', '    return editionNumber;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function for calling external create methods with some none configurable defaults\n', '   */\n', '  function _createNewEdition(\n', '    uint256 _editionNumber,\n', '    address _artist,\n', '    uint256 _totalAvailable,\n', '    uint256 _priceInWei,\n', '    uint256 _startDate,\n', '    string _tokenUri\n', '  )\n', '  internal\n', '  returns (bool) {\n', '    return kodaV2.createActiveEdition(\n', '      _editionNumber,\n', '      0x0, // _editionData - no edition data\n', '      1, // _editionType - KODA always type 1\n', '      _startDate,\n', '      0, // _endDate - 0 = MAX unit256\n', '      _artist,\n', '      artistCommission,\n', '      _priceInWei,\n', '      _tokenUri,\n', '      _totalAvailable\n', '    );\n', '  }\n', '\n', '  function validateInvocations() internal {\n', '    if (disableInvocationCheck) {\n', '      return;\n', '    }\n', '    uint256 invocationPeriodStart = timeOfFirstInvocationInPeriod[msg.sender];\n', '\n', '    // If we are new to this process or its been cleared, skip the check\n', '    if (invocationPeriodStart != 0) {\n', '\n', '      // Work out how much time has passed\n', '      uint256 timePassedInPeriod = block.timestamp - invocationPeriodStart;\n', '\n', '      // If we are still in this time period\n', '      if (timePassedInPeriod < maxInvocationsTimePeriod) {\n', '\n', '        uint256 invocations = invocationsInTimePeriod[msg.sender];\n', '\n', '        // Ensure the number of invocations does not exceed the max number of invocations allowed\n', '        require(invocations <= maxInvocations, "Exceeded max invocations for time period");\n', '\n', '        // Update the invocations for this period if passed validation check\n', '        invocationsInTimePeriod[msg.sender] = invocations + 1;\n', '\n', '      } else {\n', '        // if we have passed the time period simple clear out the fields and start the period again\n', '        invocationsInTimePeriod[msg.sender] = 1;\n', '        timeOfFirstInvocationInPeriod[msg.sender] = block.number;\n', '      }\n', '\n', '    } else {\n', '      // initial the counters if not used before\n', '      invocationsInTimePeriod[msg.sender] = 1;\n', '      timeOfFirstInvocationInPeriod[msg.sender] = block.number;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function for dynamically generating the next KODA edition number\n', '   */\n', '  function getNextAvailableEditionNumber()\n', '  internal\n', '  returns (uint256 editionNumber) {\n', '\n', '    // Get current highest edition and total in the edition\n', '    uint256 highestEditionNumber = kodaV2.highestEditionNumber();\n', '    uint256 totalAvailableEdition = kodaV2.totalAvailableEdition(highestEditionNumber);\n', '\n', '    // Add the current highest plus its total, plus 1 as tokens start at 1 not zero\n', '    uint256 nextAvailableEditionNumber = highestEditionNumber.add(totalAvailableEdition).add(1);\n', '\n', '    // Round up to next 100, 1000 etc based on max allowed size\n', '    return ((nextAvailableEditionNumber + maxEditionSize - 1) / maxEditionSize) * maxEditionSize;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the KODA address\n', '   * @dev Only callable from owner\n', '   */\n', '  function setKodavV2(IKODAV2SelfServiceEditionCuration _kodaV2) onlyOwner public {\n', '    kodaV2 = _kodaV2;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the KODA auction\n', '   * @dev Only callable from owner\n', '   */\n', '  function setAuction(IKODAAuction _auction) onlyOwner public {\n', '    auction = _auction;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the default commission for each edition\n', '   * @dev Only callable from owner\n', '   */\n', '  function setArtistCommission(uint256 _artistCommission) onlyOwner public {\n', '    artistCommission = _artistCommission;\n', '  }\n', '\n', '  /**\n', '   * @dev Controls is the contract is open to all\n', '   * @dev Only callable from owner\n', '   */\n', '  function setOpenToAllArtist(bool _openToAllArtist) onlyOwner public {\n', '    openToAllArtist = _openToAllArtist;\n', '  }\n', '\n', '  /**\n', '   * @dev Controls who can call this contract\n', '   * @dev Only callable from owner\n', '   */\n', '  function setAllowedArtist(address _artist, bool _allowed) onlyOwner public {\n', '    allowedArtists[_artist] = _allowed;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the max edition size\n', '   * @dev Only callable from owner\n', '   */\n', '  function setMaxEditionSize(uint256 _maxEditionSize) onlyOwner public {\n', '    maxEditionSize = _maxEditionSize;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the max invocations\n', '   * @dev Only callable from owner\n', '   */\n', '  function setMaxInvocations(uint256 _maxInvocations) onlyOwner public {\n', '    maxInvocations = _maxInvocations;\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the disable invocation check, when true the invocation in time period check is skipped\n', '   * @dev Only callable from owner\n', '   */\n', '  function setDisableInvocationCheck(bool _disableInvocationCheck) onlyOwner public {\n', '    disableInvocationCheck = _disableInvocationCheck;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks to see if the account can mint more assets\n', '   */\n', '  function canCreateAnotherEdition(address account) public view returns (bool) {\n', '    return isEnabledForAccount(account) && invocationsInTimePeriod[account] <= maxInvocations;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks to see if the account can create editions\n', '   */\n', '  function isEnabledForAccount(address account) public view returns (bool) {\n', '    if (openToAllArtist) {\n', '      return true;\n', '    }\n', '    return allowedArtists[account];\n', '  }\n', '\n', '  /**\n', '   * @dev Allows for the ability to extract stuck ether\n', '   * @dev Only callable from owner\n', '   */\n', '  function withdrawStuckEther(address _withdrawalAccount) onlyOwner public {\n', '    require(_withdrawalAccount != address(0), "Invalid address provided");\n', '    _withdrawalAccount.transfer(address(this).balance);\n', '  }\n', '}']