['pragma solidity ^0.4.25;\n', '\n', 'contract token {\n', '    function transfer(address receiver, uint256 amount) public;\n', '    function balanceOf(address _owner) public pure returns (uint256 balance);\n', '    function burnFrom(address from, uint256 value) public;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * To buy ADT user must be Whitelisted\n', ' * Add user address and value to Whitelist\n', ' * Remove user address from Whitelist\n', ' * Check if User is Whitelisted\n', ' * Check if User have equal or greater value than Whitelisted\n', ' */\n', ' \n', 'library Whitelist {\n', '    \n', '    struct List {\n', '        mapping(address => bool) registry;\n', '        mapping(address => uint256) amount;\n', '    }\n', '\n', '    function addUserWithValue(List storage list, address _addr, uint256 _value)\n', '        internal\n', '    {\n', '        list.registry[_addr] = true;\n', '        list.amount[_addr] = _value;\n', '    }\n', '    \n', '    function add(List storage list, address _addr)\n', '        internal\n', '    {\n', '        list.registry[_addr] = true;\n', '    }\n', '\n', '    function remove(List storage list, address _addr)\n', '        internal\n', '    {\n', '        list.registry[_addr] = false;\n', '        list.amount[_addr] = 0;\n', '    }\n', '\n', '    function check(List storage list, address _addr)\n', '        view\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return list.registry[_addr];\n', '    }\n', '\n', '    function checkValue(List storage list, address _addr, uint256 _value)\n', '        view\n', '        internal\n', '        returns (bool)\n', '    {\n', '        /** \n', '         * divided by  10^18 because ether decimal is 18\n', '         * and conversion to ether to uint256 is carried out \n', '        */\n', '         \n', '        return list.amount[_addr] <= _value;\n', '    }\n', '}\n', '\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = 0x91520dc19a9e103a849076a9dd860604ff7a6282;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Contract to whitelist User for buying token\n', ' */\n', 'contract Whitelisted is owned {\n', '\n', '    Whitelist.List private _list;\n', '    uint256 decimals = 100000000000000;\n', '    \n', '    modifier onlyWhitelisted() {\n', '        require(Whitelist.check(_list, msg.sender) == true);\n', '        _;\n', '    }\n', '\n', '    event AddressAdded(address _addr);\n', '    event AddressRemoved(address _addr);\n', '    event AddressReset(address _addr);\n', '    \n', '    /**\n', '     * Add User to Whitelist with ether amount\n', '     * @param _address User Wallet address\n', '     * @param amount The amount of ether user Whitelisted\n', '     */\n', '    function addWhiteListAddress(address _address, uint256 amount)\n', '    public {\n', '        \n', '        require(!isAddressWhiteListed(_address));\n', '        \n', '        uint256 val = SafeMath.mul(amount, decimals);\n', '        Whitelist.addUserWithValue(_list, _address, val);\n', '        \n', '        emit AddressAdded(_address);\n', '    }\n', '    \n', '    /**\n', '     * Set User&#39;s Whitelisted ether amount to 0 so that \n', '     * during second buy transaction user won&#39;t need to \n', '     * validate for Whitelisted amount\n', '     */\n', '    function resetUserWhiteListAmount()\n', '    internal {\n', '        \n', '        Whitelist.addUserWithValue(_list, msg.sender, 0);\n', '        emit AddressReset(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Disable User from Whitelist so user can&#39;t buy token\n', '     * @param _addr User Wallet address\n', '     */\n', '    function disableWhitelistAddress(address _addr)\n', '    public onlyOwner {\n', '        \n', '        Whitelist.remove(_list, _addr);\n', '        emit AddressRemoved(_addr);\n', '    }\n', '    \n', '    /**\n', '     * Check if User is Whitelisted\n', '     * @param _addr User Wallet address\n', '     */\n', '    function isAddressWhiteListed(address _addr)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return Whitelist.check(_list, _addr);\n', '    }\n', '\n', '\n', '    /**\n', '     * Check if User has enough ether amount in Whitelisted to buy token \n', '     * @param _addr User Wallet address\n', '     * @param amount The amount of ether user inputed\n', '     */\n', '    function isWhiteListedValueValid(address _addr, uint256 amount)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return Whitelist.checkValue(_list, _addr, amount);\n', '    }\n', '\n', '\n', '   /**\n', '     * Check if User is valid to buy token \n', '     * @param _addr User Wallet address\n', '     * @param amount The amount of ether user inputed\n', '     */\n', '    function isValidUser(address _addr, uint256 amount)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return isAddressWhiteListed(_addr) && isWhiteListedValueValid(_addr, amount);\n', '    }\n', '    \n', '    /**\n', '     * returns the total amount of the address hold by the user during white list\n', '     */\n', '    function getUserAmount(address _addr) public constant returns (uint256) {\n', '        \n', '        require(isAddressWhiteListed(_addr));\n', '        return _list.amount[_addr];\n', '    }\n', '    \n', '}\n', '\n', '\n', '\n', 'contract AccessCrowdsale is Whitelisted {\n', '    using SafeMath for uint256;\n', '    \n', '    address public beneficiary;\n', '    uint256 public SoftCap;\n', '    uint256 public HardCap;\n', '    uint256 public amountRaised;\n', '    uint256 public preSaleStartdate;\n', '    uint256 public preSaleDeadline;\n', '    uint256 public mainSaleStartdate;\n', '    uint256 public mainSaleDeadline;\n', '    uint256 public price;\n', '    uint256 public fundTransferred;\n', '    uint256 public tokenSold;\n', '    token public tokenReward;\n', '    mapping(address => uint256) public balanceOf;\n', '    bool crowdsaleClosed = false;\n', '    bool returnFunds = false;\n', '\t\n', '    event GoalReached(address recipient, uint totalAmountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor() public {\n', '        beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282;\n', '        SoftCap = 15000 ether;\n', '        HardCap = 150000 ether;\n', '        preSaleStartdate = 1550102400;\n', '        preSaleDeadline = 1552608000;\n', '        mainSaleStartdate = 1552611600;\n', '        mainSaleDeadline = 1560643200;\n', '        price = 0.0004 ether;\n', '        tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () payable public {\n', '        \n', '        uint256 bonus = 0;\n', '        uint256 amount;\n', '        uint256 ethamount = msg.value;\n', '        \n', '        require(!crowdsaleClosed);\n', '        // divide by price to get the actual adt token\n', '        uint256 onlyAdt = ethamount.div(price);\n', '        // multiply adt value with decimal of adt to get the wei adt\n', '        uint256 weiAdt = SafeMath.mul(onlyAdt, 100000000000000);\n', '    \n', '        require(isValidUser(msg.sender, weiAdt));\n', '\n', '\n', '        \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(ethamount);\n', '        amountRaised = amountRaised.add(ethamount);\n', '        \n', '        //add bonus for funders\n', '        if(now >= preSaleStartdate && now <= preSaleDeadline){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 33 / 100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate && now <= mainSaleStartdate + 30 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 25/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate + 30 days && now <= mainSaleStartdate + 45 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 15/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate + 45 days && now <= mainSaleStartdate + 60 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 10/100;\n', '            amount = amount.add(bonus);\n', '        } else {\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 7/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        \n', '        amount = amount.mul(100000000000000);\n', '        tokenReward.transfer(msg.sender, amount);\n', '        tokenSold = tokenSold.add(amount);\n', '        \n', '        resetUserWhiteListAmount();\n', '        emit FundTransfer(msg.sender, ethamount, true);\n', '    }\n', '\n', '    modifier afterDeadline() {if (now >= mainSaleDeadline) _; }\n', '\n', '    /**\n', '     *ends the campaign after deadline\n', '     */\n', '     \n', '    function endCrowdsale() public afterDeadline  onlyOwner {\n', '        crowdsaleClosed = true;\n', '    }\n', '    \n', '    function EnableReturnFunds() public onlyOwner {\n', '        returnFunds = true;\n', '    }\n', '    \n', '    function DisableReturnFunds() public onlyOwner {\n', '        returnFunds = false;\n', '    }\n', '\t\n', '    function ChangePrice(uint256 _price) public onlyOwner {\n', '        price = _price;\t\n', '    }\n', '\n', '    function ChangeBeneficiary(address _beneficiary) public onlyOwner {\n', '        beneficiary = _beneficiary;\t\n', '    }\n', '\t \n', '    function ChangePreSaleDates(uint256 _preSaleStartdate, uint256 _preSaleDeadline) onlyOwner public{\n', '        if(_preSaleStartdate != 0){\n', '            preSaleStartdate = _preSaleStartdate;\n', '        }\n', '        if(_preSaleDeadline != 0){\n', '            preSaleDeadline = _preSaleDeadline;\n', '        }\n', '        \n', '        if(crowdsaleClosed == true){\n', '            crowdsaleClosed = false;\n', '        }\n', '    }\n', '    \n', '    function ChangeMainSaleDates(uint256 _mainSaleStartdate, uint256 _mainSaleDeadline) onlyOwner public{\n', '        if(_mainSaleStartdate != 0){\n', '            mainSaleStartdate = _mainSaleStartdate;\n', '        }\n', '        if(_mainSaleDeadline != 0){\n', '            mainSaleDeadline = _mainSaleDeadline; \n', '        }\n', '        \n', '        if(crowdsaleClosed == true){\n', '            crowdsaleClosed = false;       \n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Get all the remaining token back from the contract\n', '     */\n', '    function getTokensBack() onlyOwner public{\n', '        \n', '        require(crowdsaleClosed);\n', '        \n', '        uint256 remaining = tokenReward.balanceOf(this);\n', '        tokenReward.transfer(beneficiary, remaining);\n', '    }\n', '    \n', '    /**\n', '     * User can get their ether back if crowdsale didn&#39;t meet it&#39;s requirement \n', '     */\n', '    function safeWithdrawal() public afterDeadline {\n', '        if (returnFunds) {\n', '            uint amount = balanceOf[msg.sender];\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundTransfer(msg.sender, amount, false);\n', '                    balanceOf[msg.sender] = 0;\n', '                    fundTransferred = fundTransferred.add(amount);\n', '                } \n', '            }\n', '        }\n', '\n', '        if (returnFunds == false && beneficiary == msg.sender) {\n', '            uint256 ethToSend = amountRaised - fundTransferred;\n', '            if (beneficiary.send(ethToSend)) {\n', '                fundTransferred = fundTransferred.add(ethToSend);\n', '            } \n', '        }\n', '    }\n', '    \n', '    function getResponse(uint256 val) public constant returns(uint256) {\n', '        uint256 adtDec = 100000000000000;\n', '        \n', '        uint256 onlyAdt = val.div(price);\n', '        // multiply adt value with decimal of adt to get the wei adt\n', '        uint256 weiAdt = SafeMath.mul(onlyAdt, adtDec);\n', '        \n', '        return weiAdt;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract token {\n', '    function transfer(address receiver, uint256 amount) public;\n', '    function balanceOf(address _owner) public pure returns (uint256 balance);\n', '    function burnFrom(address from, uint256 value) public;\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * To buy ADT user must be Whitelisted\n', ' * Add user address and value to Whitelist\n', ' * Remove user address from Whitelist\n', ' * Check if User is Whitelisted\n', ' * Check if User have equal or greater value than Whitelisted\n', ' */\n', ' \n', 'library Whitelist {\n', '    \n', '    struct List {\n', '        mapping(address => bool) registry;\n', '        mapping(address => uint256) amount;\n', '    }\n', '\n', '    function addUserWithValue(List storage list, address _addr, uint256 _value)\n', '        internal\n', '    {\n', '        list.registry[_addr] = true;\n', '        list.amount[_addr] = _value;\n', '    }\n', '    \n', '    function add(List storage list, address _addr)\n', '        internal\n', '    {\n', '        list.registry[_addr] = true;\n', '    }\n', '\n', '    function remove(List storage list, address _addr)\n', '        internal\n', '    {\n', '        list.registry[_addr] = false;\n', '        list.amount[_addr] = 0;\n', '    }\n', '\n', '    function check(List storage list, address _addr)\n', '        view\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return list.registry[_addr];\n', '    }\n', '\n', '    function checkValue(List storage list, address _addr, uint256 _value)\n', '        view\n', '        internal\n', '        returns (bool)\n', '    {\n', '        /** \n', '         * divided by  10^18 because ether decimal is 18\n', '         * and conversion to ether to uint256 is carried out \n', '        */\n', '         \n', '        return list.amount[_addr] <= _value;\n', '    }\n', '}\n', '\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = 0x91520dc19a9e103a849076a9dd860604ff7a6282;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Contract to whitelist User for buying token\n', ' */\n', 'contract Whitelisted is owned {\n', '\n', '    Whitelist.List private _list;\n', '    uint256 decimals = 100000000000000;\n', '    \n', '    modifier onlyWhitelisted() {\n', '        require(Whitelist.check(_list, msg.sender) == true);\n', '        _;\n', '    }\n', '\n', '    event AddressAdded(address _addr);\n', '    event AddressRemoved(address _addr);\n', '    event AddressReset(address _addr);\n', '    \n', '    /**\n', '     * Add User to Whitelist with ether amount\n', '     * @param _address User Wallet address\n', '     * @param amount The amount of ether user Whitelisted\n', '     */\n', '    function addWhiteListAddress(address _address, uint256 amount)\n', '    public {\n', '        \n', '        require(!isAddressWhiteListed(_address));\n', '        \n', '        uint256 val = SafeMath.mul(amount, decimals);\n', '        Whitelist.addUserWithValue(_list, _address, val);\n', '        \n', '        emit AddressAdded(_address);\n', '    }\n', '    \n', '    /**\n', "     * Set User's Whitelisted ether amount to 0 so that \n", "     * during second buy transaction user won't need to \n", '     * validate for Whitelisted amount\n', '     */\n', '    function resetUserWhiteListAmount()\n', '    internal {\n', '        \n', '        Whitelist.addUserWithValue(_list, msg.sender, 0);\n', '        emit AddressReset(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', "     * Disable User from Whitelist so user can't buy token\n", '     * @param _addr User Wallet address\n', '     */\n', '    function disableWhitelistAddress(address _addr)\n', '    public onlyOwner {\n', '        \n', '        Whitelist.remove(_list, _addr);\n', '        emit AddressRemoved(_addr);\n', '    }\n', '    \n', '    /**\n', '     * Check if User is Whitelisted\n', '     * @param _addr User Wallet address\n', '     */\n', '    function isAddressWhiteListed(address _addr)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return Whitelist.check(_list, _addr);\n', '    }\n', '\n', '\n', '    /**\n', '     * Check if User has enough ether amount in Whitelisted to buy token \n', '     * @param _addr User Wallet address\n', '     * @param amount The amount of ether user inputed\n', '     */\n', '    function isWhiteListedValueValid(address _addr, uint256 amount)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return Whitelist.checkValue(_list, _addr, amount);\n', '    }\n', '\n', '\n', '   /**\n', '     * Check if User is valid to buy token \n', '     * @param _addr User Wallet address\n', '     * @param amount The amount of ether user inputed\n', '     */\n', '    function isValidUser(address _addr, uint256 amount)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        \n', '        return isAddressWhiteListed(_addr) && isWhiteListedValueValid(_addr, amount);\n', '    }\n', '    \n', '    /**\n', '     * returns the total amount of the address hold by the user during white list\n', '     */\n', '    function getUserAmount(address _addr) public constant returns (uint256) {\n', '        \n', '        require(isAddressWhiteListed(_addr));\n', '        return _list.amount[_addr];\n', '    }\n', '    \n', '}\n', '\n', '\n', '\n', 'contract AccessCrowdsale is Whitelisted {\n', '    using SafeMath for uint256;\n', '    \n', '    address public beneficiary;\n', '    uint256 public SoftCap;\n', '    uint256 public HardCap;\n', '    uint256 public amountRaised;\n', '    uint256 public preSaleStartdate;\n', '    uint256 public preSaleDeadline;\n', '    uint256 public mainSaleStartdate;\n', '    uint256 public mainSaleDeadline;\n', '    uint256 public price;\n', '    uint256 public fundTransferred;\n', '    uint256 public tokenSold;\n', '    token public tokenReward;\n', '    mapping(address => uint256) public balanceOf;\n', '    bool crowdsaleClosed = false;\n', '    bool returnFunds = false;\n', '\t\n', '    event GoalReached(address recipient, uint totalAmountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor() public {\n', '        beneficiary = 0x91520dc19a9e103a849076a9dd860604ff7a6282;\n', '        SoftCap = 15000 ether;\n', '        HardCap = 150000 ether;\n', '        preSaleStartdate = 1550102400;\n', '        preSaleDeadline = 1552608000;\n', '        mainSaleStartdate = 1552611600;\n', '        mainSaleDeadline = 1560643200;\n', '        price = 0.0004 ether;\n', '        tokenReward = token(0x97e4017964bc43ec8b3ceadeae27d89bc5a33c7b);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () payable public {\n', '        \n', '        uint256 bonus = 0;\n', '        uint256 amount;\n', '        uint256 ethamount = msg.value;\n', '        \n', '        require(!crowdsaleClosed);\n', '        // divide by price to get the actual adt token\n', '        uint256 onlyAdt = ethamount.div(price);\n', '        // multiply adt value with decimal of adt to get the wei adt\n', '        uint256 weiAdt = SafeMath.mul(onlyAdt, 100000000000000);\n', '    \n', '        require(isValidUser(msg.sender, weiAdt));\n', '\n', '\n', '        \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(ethamount);\n', '        amountRaised = amountRaised.add(ethamount);\n', '        \n', '        //add bonus for funders\n', '        if(now >= preSaleStartdate && now <= preSaleDeadline){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 33 / 100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate && now <= mainSaleStartdate + 30 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 25/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate + 30 days && now <= mainSaleStartdate + 45 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 15/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        else if(now >= mainSaleStartdate + 45 days && now <= mainSaleStartdate + 60 days){\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 10/100;\n', '            amount = amount.add(bonus);\n', '        } else {\n', '            amount =  ethamount.div(price);\n', '            bonus = amount * 7/100;\n', '            amount = amount.add(bonus);\n', '        }\n', '        \n', '        amount = amount.mul(100000000000000);\n', '        tokenReward.transfer(msg.sender, amount);\n', '        tokenSold = tokenSold.add(amount);\n', '        \n', '        resetUserWhiteListAmount();\n', '        emit FundTransfer(msg.sender, ethamount, true);\n', '    }\n', '\n', '    modifier afterDeadline() {if (now >= mainSaleDeadline) _; }\n', '\n', '    /**\n', '     *ends the campaign after deadline\n', '     */\n', '     \n', '    function endCrowdsale() public afterDeadline  onlyOwner {\n', '        crowdsaleClosed = true;\n', '    }\n', '    \n', '    function EnableReturnFunds() public onlyOwner {\n', '        returnFunds = true;\n', '    }\n', '    \n', '    function DisableReturnFunds() public onlyOwner {\n', '        returnFunds = false;\n', '    }\n', '\t\n', '    function ChangePrice(uint256 _price) public onlyOwner {\n', '        price = _price;\t\n', '    }\n', '\n', '    function ChangeBeneficiary(address _beneficiary) public onlyOwner {\n', '        beneficiary = _beneficiary;\t\n', '    }\n', '\t \n', '    function ChangePreSaleDates(uint256 _preSaleStartdate, uint256 _preSaleDeadline) onlyOwner public{\n', '        if(_preSaleStartdate != 0){\n', '            preSaleStartdate = _preSaleStartdate;\n', '        }\n', '        if(_preSaleDeadline != 0){\n', '            preSaleDeadline = _preSaleDeadline;\n', '        }\n', '        \n', '        if(crowdsaleClosed == true){\n', '            crowdsaleClosed = false;\n', '        }\n', '    }\n', '    \n', '    function ChangeMainSaleDates(uint256 _mainSaleStartdate, uint256 _mainSaleDeadline) onlyOwner public{\n', '        if(_mainSaleStartdate != 0){\n', '            mainSaleStartdate = _mainSaleStartdate;\n', '        }\n', '        if(_mainSaleDeadline != 0){\n', '            mainSaleDeadline = _mainSaleDeadline; \n', '        }\n', '        \n', '        if(crowdsaleClosed == true){\n', '            crowdsaleClosed = false;       \n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Get all the remaining token back from the contract\n', '     */\n', '    function getTokensBack() onlyOwner public{\n', '        \n', '        require(crowdsaleClosed);\n', '        \n', '        uint256 remaining = tokenReward.balanceOf(this);\n', '        tokenReward.transfer(beneficiary, remaining);\n', '    }\n', '    \n', '    /**\n', "     * User can get their ether back if crowdsale didn't meet it's requirement \n", '     */\n', '    function safeWithdrawal() public afterDeadline {\n', '        if (returnFunds) {\n', '            uint amount = balanceOf[msg.sender];\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundTransfer(msg.sender, amount, false);\n', '                    balanceOf[msg.sender] = 0;\n', '                    fundTransferred = fundTransferred.add(amount);\n', '                } \n', '            }\n', '        }\n', '\n', '        if (returnFunds == false && beneficiary == msg.sender) {\n', '            uint256 ethToSend = amountRaised - fundTransferred;\n', '            if (beneficiary.send(ethToSend)) {\n', '                fundTransferred = fundTransferred.add(ethToSend);\n', '            } \n', '        }\n', '    }\n', '    \n', '    function getResponse(uint256 val) public constant returns(uint256) {\n', '        uint256 adtDec = 100000000000000;\n', '        \n', '        uint256 onlyAdt = val.div(price);\n', '        // multiply adt value with decimal of adt to get the wei adt\n', '        uint256 weiAdt = SafeMath.mul(onlyAdt, adtDec);\n', '        \n', '        return weiAdt;\n', '    }\n', '\n', '}']
