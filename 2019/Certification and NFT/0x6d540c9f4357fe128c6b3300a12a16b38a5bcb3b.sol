['pragma solidity 0.5.6;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    uint8 public decimals;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract DAIHardFactory {\n', '    event NewTrade(uint id, address tradeAddress, bool indexed initiatorIsPayer);\n', '\n', '    ERC20Interface public daiContract;\n', '    address payable public devFeeAddress;\n', '\n', '    constructor(ERC20Interface _daiContract, address payable _devFeeAddress)\n', '    public {\n', '        daiContract = _daiContract;\n', '        devFeeAddress = _devFeeAddress;\n', '    }\n', '\n', '    struct CreationInfo {\n', '        address address_;\n', '        uint blocknum;\n', '    }\n', '\n', '    CreationInfo[] public createdTrades;\n', '\n', '    function getBuyerDeposit(uint tradeAmount)\n', '    public\n', '    pure\n', '    returns (uint buyerDeposit) {\n', '        return tradeAmount / 3;\n', '    }\n', '\n', '    function getDevFee(uint tradeAmount)\n', '    public\n', '    pure\n', '    returns (uint devFee) {\n', '        return tradeAmount / 100;\n', '    }\n', '\n', '    function getExtraFees(uint tradeAmount)\n', '    public\n', '    pure\n', '    returns (uint buyerDeposit, uint devFee) {\n', '        return (getBuyerDeposit(tradeAmount), getDevFee(tradeAmount));\n', '    }\n', '\n', '    /*\n', "    The Solidity compiler can't handle much stack depth,\n", '    so we have to pack some args together in annoying ways...\n', "    Hence the 'uintArgs'. Here is its layout:\n", '    0 - daiAmount\n', '    1 - pokeReward\n', '    2 - autorecallInterval\n', '    3 - autoabortInterval\n', '    4 - autoreleaseInterval\n', '    */\n', '\n', '    function openDAIHardTrade(address payable _initiator, bool initiatorIsBuyer, uint[5] calldata uintArgs, string calldata _totalPrice, string calldata _fiatTransferMethods, string calldata _commPubkey)\n', '    external\n', '    returns (DAIHardTrade) {\n', '        uint transferAmount;\n', '        uint[6] memory newUintArgs; // Note that this structure is not the same as the above comment describes. See below in DAIHardTrade.open.\n', '\n', '        if (initiatorIsBuyer) {\n', '            transferAmount = getBuyerDeposit(uintArgs[0]) + uintArgs[1] + getDevFee(uintArgs[0]);\n', '            newUintArgs = [uintArgs[0], uintArgs[1], getDevFee(uintArgs[0]), uintArgs[2], uintArgs[3], uintArgs[4]];\n', '        }\n', '        else {\n', '            transferAmount = uintArgs[0] + uintArgs[1] + getDevFee(uintArgs[0]);\n', '            newUintArgs = [getBuyerDeposit(uintArgs[0]), uintArgs[1], getDevFee(uintArgs[0]), uintArgs[2], uintArgs[3], uintArgs[4]];\n', '        }\n', '\n', '        //create the new trade and add its creationInfo to createdTrades\n', '        DAIHardTrade newTrade = new DAIHardTrade(daiContract, devFeeAddress);\n', '        createdTrades.push(CreationInfo(address(newTrade), block.number));\n', '        emit NewTrade(createdTrades.length - 1, address(newTrade), initiatorIsBuyer);\n', '\n', '        //transfer DAI to the trade and open it\n', '        require(daiContract.transferFrom(msg.sender, address(newTrade), transferAmount), "Token transfer failed. Did you call approve() on the DAI contract?");\n', '        newTrade.open(_initiator, initiatorIsBuyer, newUintArgs, _totalPrice, _fiatTransferMethods, _commPubkey);\n', '    }\n', '\n', '    function getNumTrades()\n', '    external\n', '    view\n', '    returns (uint num) {\n', '        return createdTrades.length;\n', '    }\n', '}\n', '\n', 'contract DAIHardTrade {\n', '    enum Phase {Created, Open, Committed, Claimed, Closed}\n', '    Phase public phase;\n', '\n', '    modifier inPhase(Phase p) {\n', '        require(phase == p, "inPhase check failed.");\n', '        _;\n', '    }\n', '\n', '    uint[5] public phaseStartTimestamps;\n', '\n', '    function changePhase(Phase p)\n', '    internal {\n', '        phase = p;\n', '        phaseStartTimestamps[uint(p)] = block.timestamp;\n', '    }\n', '\n', '\n', '    address payable public initiator;\n', '    address payable public responder;\n', '\n', "    //The contract only has two parties, but depending on how it's opened,\n", '    //the initiator for example might be either the buyer OR the seller.\n', '\n', '    bool public initiatorIsBuyer;\n', '    address payable public buyer;\n', '    address payable public seller;\n', '\n', '    modifier onlyInitiator() {\n', '        require(msg.sender == initiator, "msg.sender is not Initiator.");\n', '        _;\n', '    }\n', '    modifier onlyResponder() {\n', '        require(msg.sender == responder, "msg.sender is not Responder.");\n', '        _;\n', '    }\n', '    modifier onlyBuyer() {\n', '        require (msg.sender == buyer, "msg.sender is not Buyer.");\n', '        _;\n', '    }\n', '    modifier onlySeller() {\n', '        require (msg.sender == seller, "msg.sender is not Seller.");\n', '        _;\n', '    }\n', '    modifier onlyContractParty() { // Must be one of the two parties involved in the contract\n', '        require(msg.sender == initiator || msg.sender == responder, "msg.sender is not a party in this contract.");\n', '        _;\n', '    }\n', '\n', '    ERC20Interface daiContract;\n', '    address payable devFeeAddress;\n', '\n', '    constructor(ERC20Interface _daiContract, address payable _devFeeAddress)\n', '    public {\n', '        changePhase(Phase.Created);\n', '\n', '        daiContract = _daiContract;\n', '        devFeeAddress = _devFeeAddress;\n', '\n', '        pokeRewardSent = false;\n', '    }\n', '\n', '    uint public daiAmount;\n', '    string public price;\n', '    uint public buyerDeposit;\n', '\n', '    uint public responderDeposit; // This will be equal to either daiAmount or buyerDeposit, depending on initiatorIsBuyer\n', '\n', '    uint public autorecallInterval;\n', '    uint public autoabortInterval;\n', '    uint public autoreleaseInterval;\n', '\n', '    uint public pokeReward;\n', '    uint public devFee;\n', '\n', '    bool public pokeRewardSent;\n', '\n', '    /*\n', '    uintArgs:\n', '    0 - responderDeposit\n', '    1 - pokeReward\n', '    2 - devFee\n', '    3 - autorecallInterval\n', '    4 - autoabortInterval\n', '    5 - autoreleaseInterval\n', '    */\n', '\n', '    event Opened(string fiatTransferMethods, string commPubkey);\n', '\n', '    function open(address payable _initiator, bool _initiatorIsBuyer, uint[6] memory uintArgs, string memory _price, string memory fiatTransferMethods, string memory commPubkey)\n', '    public {\n', '        require(getBalance() > 0, "You can\'t open a trade without first depositing DAI.");\n', '\n', '        responderDeposit = uintArgs[0];\n', '        pokeReward = uintArgs[1];\n', '        devFee = uintArgs[2];\n', '\n', '        autorecallInterval = uintArgs[3];\n', '        autoabortInterval = uintArgs[4];\n', '        autoreleaseInterval = uintArgs[5];\n', '\n', '        initiator = _initiator;\n', '        initiatorIsBuyer = _initiatorIsBuyer;\n', '        if (initiatorIsBuyer) {\n', '            buyer = initiator;\n', '            daiAmount = responderDeposit;\n', '            buyerDeposit = getBalance() - (pokeReward + devFee);\n', '        }\n', '        else {\n', '            seller = initiator;\n', '            daiAmount = getBalance() - (pokeReward + devFee);\n', '            buyerDeposit = responderDeposit;\n', '        }\n', '\n', '        price = _price;\n', '\n', '        changePhase(Phase.Open);\n', '        emit Opened(fiatTransferMethods, commPubkey);\n', '    }\n', '\n', '    /* ---------------------- OPEN PHASE --------------------------\n', '\n', '    In the Open phase, the Initiator waits for a Responder.\n', '    We move to the Commited phase once someone becomes the Responder\n', '    by executing commit() and including msg.value = responderDeposit.\n', '\n', '    At any time, the Initiator can cancel the whole thing by calling recall().\n', '\n', '    After autorecallInterval has passed, the only state change allowed is to recall(),\n', '    which can be triggered by anyone via poke().\n', '\n', '    ------------------------------------------------------------ */\n', '\n', '    event Recalled();\n', '    event Committed(address responder, string commPubkey);\n', '\n', '\n', '    function recall()\n', '    external\n', '    inPhase(Phase.Open)\n', '    onlyInitiator() {\n', '       internalRecall();\n', '    }\n', '\n', '    function internalRecall()\n', '    internal {\n', '        require(daiContract.transfer(initiator, getBalance()), "Recall of DAI to initiator failed!");\n', '\n', '        changePhase(Phase.Closed);\n', '        emit Recalled();\n', '    }\n', '\n', '    function autorecallAvailable()\n', '    public\n', '    view\n', '    inPhase(Phase.Open)\n', '    returns(bool available) {\n', '        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Open)] + autorecallInterval);\n', '    }\n', '\n', '    function commit(string calldata commPubkey)\n', '    external\n', '    inPhase(Phase.Open) {\n', '        require(daiContract.transferFrom(msg.sender, address(this), responderDeposit), "Can\'t transfer the required deposit from the DAI contract. Did you call approve first?");\n', '        require(!autorecallAvailable(), "autorecallInterval has passed; this offer has expired.");\n', '\n', '        responder = msg.sender;\n', '\n', '        if (initiatorIsBuyer) {\n', '            seller = responder;\n', '        }\n', '        else {\n', '            buyer = responder;\n', '        }\n', '\n', '        changePhase(Phase.Committed);\n', '        emit Committed(responder, commPubkey);\n', '    }\n', '\n', '    /* ---------------------- COMMITTED PHASE ---------------------\n', '\n', '    In the Committed phase, the Buyer is expected to deposit fiat for the DAI,\n', '    then call claim().\n', '\n', '    Otherwise, the Buyer can call abort(), which cancels the contract,\n', '    incurs a small penalty on both parties, and returns the remainder to each party.\n', '\n', '    After autoabortInterval has passed, the only state change allowed is to abort(),\n', '    which can be triggered by anyone via poke().\n', '\n', '    ------------------------------------------------------------ */\n', '\n', '    event Claimed();\n', '    event Aborted();\n', '\n', '    function abort()\n', '    external\n', '    inPhase(Phase.Committed)\n', '    onlyBuyer() {\n', '        internalAbort();\n', '    }\n', '\n', '    function internalAbort()\n', '    internal {\n', '        //Punishment amount is 1/4 the buyerDeposit for now,\n', '        //but in a future version this might be set by the Initiator.\n', '        uint burnAmount = buyerDeposit / 4;\n', '\n', '        //Punish both parties equally by burning burnAmount.\n', '        //Instead of burning burnAmount twice, just burn it all in one call (saves gas).\n', '        require(daiContract.transfer(address(0x0), burnAmount*2), "Token burn failed!");\n', '\n', '        //Send back deposits minus burned amounts.\n', '        require(daiContract.transfer(buyer, buyerDeposit - burnAmount), "Token transfer to Buyer failed!");\n', '        require(daiContract.transfer(seller, daiAmount - burnAmount), "Token transfer to Seller failed!");\n', '\n', '        uint sendBackToInitiator = devFee;\n', '        //If there was a pokeReward left, it should be sent back to the initiator\n', '        if (!pokeRewardSent) {\n', '            sendBackToInitiator += pokeReward;\n', '        }\n', '        \n', '        require(daiContract.transfer(initiator, sendBackToInitiator), "Token refund of devFee+pokeReward to Initiator failed!");\n', '        \n', '        //There may be a wei or two left over in the contract due to integer division. Not a big deal.\n', '\n', '        changePhase(Phase.Closed);\n', '        emit Aborted();\n', '    }\n', '\n', '    function autoabortAvailable()\n', '    public\n', '    view\n', '    inPhase(Phase.Committed)\n', '    returns(bool passed) {\n', '        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Committed)] + autoabortInterval);\n', '    }\n', '\n', '    function claim()\n', '    external\n', '    inPhase(Phase.Committed)\n', '    onlyBuyer() {\n', '        require(!autoabortAvailable(), "The deposit deadline has passed!");\n', '\n', '        changePhase(Phase.Claimed);\n', '        emit Claimed();\n', '    }\n', '\n', '    /* ---------------------- CLAIMED PHASE -----------------------\n', '\n', '    In the Claimed phase, the Seller can call release() or burn(),\n', '    and is expected to call burn() only if the Buyer did not transfer\n', '    the amount of money described in totalPrice.\n', '\n', '    After autoreleaseInterval has passed, the only state change allowed is to release,\n', '    which can be triggered by anyone via poke().\n', '\n', '    ------------------------------------------------------------ */\n', '\n', '    event Released();\n', '    event Burned();\n', '\n', '    function autoreleaseAvailable()\n', '    public\n', '    view\n', '    inPhase(Phase.Claimed)\n', '    returns(bool available) {\n', '        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Claimed)] + autoreleaseInterval);\n', '    }\n', '\n', '    function release()\n', '    external\n', '    inPhase(Phase.Claimed)\n', '    onlySeller() {\n', '        internalRelease();\n', '    }\n', '\n', '    function internalRelease()\n', '    internal {\n', '        //If the pokeReward has not been sent, refund it to the initiator\n', '        if (!pokeRewardSent) {\n', '            require(daiContract.transfer(initiator, pokeReward), "Refund of pokeReward to Initiator failed!");\n', '        }\n', '\n', '        //Upon successful resolution of trade, the devFee is sent to the developers of DAIHard.\n', '        require(daiContract.transfer(devFeeAddress, devFee), "Token transfer to devFeeAddress failed!");\n', '\n', '        //Release the remaining balance to the buyer.\n', '        require(daiContract.transfer(buyer, getBalance()), "Final release transfer to buyer failed!");\n', '\n', '        changePhase(Phase.Closed);\n', '        emit Released();\n', '    }\n', '\n', '    function burn()\n', '    external\n', '    inPhase(Phase.Claimed)\n', '    onlySeller() {\n', '        require(!autoreleaseAvailable());\n', '\n', '        internalBurn();\n', '    }\n', '\n', '    function internalBurn()\n', '    internal {\n', '        require(daiContract.transfer(address(0x0), getBalance()), "Final DAI burn failed!");\n', '\n', '        changePhase(Phase.Closed);\n', '        emit Burned();\n', '    }\n', '\n', '    /* ---------------------- OTHER METHODS ----------------------- */\n', '\n', '    function getState()\n', '    external\n', '    view\n', '    returns(uint balance, Phase phase, uint phaseStartTimestamp, address responder) {\n', '        return (getBalance(), this.phase(), phaseStartTimestamps[uint(this.phase())], this.responder());\n', '    }\n', '\n', '    function getBalance()\n', '    public\n', '    view\n', '    returns(uint) {\n', '        return daiContract.balanceOf(address(this));\n', '    }\n', '\n', '    function getParameters()\n', '    external\n', '    view\n', '    returns (address initiator, bool initiatorIsBuyer, uint daiAmount, string memory totalPrice, uint buyerDeposit, uint autorecallInterval, uint autoabortInterval, uint autoreleaseInterval, uint pokeReward)\n', '    {\n', '        return (this.initiator(), this.initiatorIsBuyer(), this.daiAmount(), this.price(), this.buyerDeposit(), this.autorecallInterval(), this.autoabortInterval(), this.autoreleaseInterval(), this.pokeReward());\n', '    }\n', '\n', '    // Poke function lets anyone move the contract along,\n', "    // if it's due for some state transition.\n", '\n', '    event Poke();\n', '\n', '    function pokeNeeded()\n', '    public\n', '    view\n', '    returns (bool needed) {\n', '        return (  (phase == Phase.Open      && autorecallAvailable() )\n', '               || (phase == Phase.Committed && autoabortAvailable()  )\n', '               || (phase == Phase.Claimed   && autoreleaseAvailable())\n', '               );\n', '    }\n', '\n', '    function poke()\n', '    external \n', '    returns (bool moved) {\n', '        if (pokeNeeded()) {\n', '            daiContract.transfer(msg.sender, pokeReward);\n', '            pokeRewardSent = true;\n', '            emit Poke();\n', '        }\n', '        else return false;\n', '\n', '        if (phase == Phase.Open) {\n', '            if (autorecallAvailable()) {\n', '                internalRecall();\n', '                return true;\n', '            }\n', '        }\n', '        else if (phase == Phase.Committed) {\n', '            if (autoabortAvailable()) {\n', '                internalAbort();\n', '                return true;\n', '            }\n', '        }\n', '        else if (phase == Phase.Claimed) {\n', '            if (autoreleaseAvailable()) {\n', '                internalRelease();\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '\n', '    // StatementLogs allow a starting point for any necessary communication,\n', '    // and can be used anytime by either party after a Responder commits (even in the Closed phase).\n', '\n', '\n', '    event InitiatorStatementLog(string encryptedForInitiator, string encryptedForResponder);\n', '    event ResponderStatementLog(string encryptedForInitiator, string encryptedForResponder);\n', '\n', '    function initiatorStatement(string memory encryptedForInitiator, string memory encryptedForResponder)\n', '    public\n', '    onlyInitiator() {\n', '        require(phase >= Phase.Committed);\n', '        emit InitiatorStatementLog(encryptedForInitiator, encryptedForResponder);\n', '    }\n', '\n', '    function responderStatement(string memory encryptedForInitiator, string memory encryptedForResponder)\n', '    public\n', '    onlyResponder() {\n', '        require(phase >= Phase.Committed);\n', '        emit ResponderStatementLog(encryptedForInitiator, encryptedForResponder);\n', '    }\n', '}']