['/*  \n', '    Subscrypto\n', '    Copyright (C) 2019 Subscrypto Team\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity 0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract Medianizer {\n', '    function read() public view returns (bytes32);\n', '}\n', '\n', '\n', 'contract Weth {\n', '    mapping(address => mapping(address => uint)) public allowance;\n', '    mapping(address => uint) public balanceOf;\n', '\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '}\n', '\n', '\n', '/// @author The Subscrypto Team\n', '/// @title Subscrypto recurring payments\n', 'contract Subscrypto {\n', '    using SafeMath for uint;\n', '    Medianizer public daiPriceContract;\n', '    Weth public wethContract;\n', '\n', '    /**\n', '     * Constructor\n', '     * @param daiMedianizerContract address\n', '     * @param wethContractAddress address\n', '     */\n', '    constructor(address daiMedianizerContract, address wethContractAddress) public {\n', '        daiPriceContract = Medianizer(daiMedianizerContract);\n', '        wethContract = Weth(wethContractAddress);\n', '    }\n', '\n', '    event NewSubscription(\n', '        address indexed subscriber,\n', '        address indexed receiver,\n', '        uint daiCents,\n', '        uint32 interval\n', '    );\n', '\n', '    event Unsubscribe(\n', '        address indexed subscriber, \n', '        address indexed receiver\n', '    );\n', '\n', '    event ReceiverPaymentsCollected(\n', '        address indexed receiver,\n', '        uint weiAmount,\n', '        uint startIndex,\n', '        uint endIndex\n', '    );\n', '\n', '    event SubscriptionPaid(\n', '        address indexed subscriber,\n', '        address indexed receiver,\n', '        uint weiAmount,\n', '        uint daiCents,\n', '        uint48 effectiveTimestamp\n', '    );\n', '\n', '    event UnfundedPayment(\n', '        address indexed subscriber,\n', '        address indexed receiver,\n', '        uint weiAmount,\n', '        uint daiCents\n', '    );\n', '\n', '    event StaleSubscription(\n', '        address indexed subscriber,\n', '        address indexed receiver\n', '    );\n', '\n', '    event SubscriptionDeactivated(\n', '        address indexed subscriber,\n', '        address indexed receiver\n', '    );\n', '\n', '    event SubscriptionReactivated(\n', '        address indexed subscriber,\n', '        address indexed receiver\n', '    );\n', '\n', '    // Conservative amount of gas used per loop in executeDebits()\n', '    uint constant MIN_GAS_PER_EXECUTE_DEBIT = 45000;\n', '    // Force subscribers to use multiple accounts when this limit is reached.\n', '    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\n', '    // Minimum payment of 1 DAI\n', '    uint constant MIN_SUBSCRIPTION_DAI_CENTS = 100;\n', '\n', '    struct Subscription {\n', '        bool    isActive;        //  1 byte\n', '        uint48  nextPaymentTime; //  6 bytes\n', '        uint32  interval;        //  4 bytes\n', '        address subscriber;      // 20 bytes\n', '        address receiver;        // 20 bytes\n', '        uint    daiCents;        // 32 bytes\n', '    }\n', '\n', '    // global counter for suscriptions\n', '    uint64 nextIndex = 1;\n', '\n', '    // source of truth for subscriptions\n', '    mapping(uint64 => Subscription) public subscriptions;\n', '\n', '    // subscriber => receiver => subsciptionIndex\n', '    mapping(address => mapping(address => uint64)) public subscriberReceiver;\n', '\n', '    // receiver => subs array\n', '    mapping(address => uint64[]) public receiverSubs;\n', '\n', '    // subscriber => subs array\n', '    mapping(address => uint64[]) public subscriberSubs;\n', '\n', '    /**\n', "     * Create a new subscription. Must be called by the subscriber's account.\n", '     * First payment of `daiCents` is paid on creation.\n', '     * Actual payment is made in Wrapped Ether (wETH) using currenct DAI-ETH conversion rate.\n', '     * @param receiver address\n', '     * @param daiCents subscription amount in hundredths of DAI\n', '     * @param interval seconds between payments\n', '     */\n', '    function subscribe(address receiver, uint daiCents, uint32 interval) external {\n', '        uint weiAmount = daiCentsToEthWei(daiCents, ethPriceInDaiWad());\n', '        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\n', '        require(subscriptions[existingIndex].daiCents == 0, "Subscription exists");\n', '        require(daiCents >= MIN_SUBSCRIPTION_DAI_CENTS, "Subsciption amount too low");\n', '        require(interval >= 86400, "Interval must be at least 1 day");\n', '        require(interval <= 31557600, "Interval must be at most 1 year");\n', '        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,"Subscription count limit reached");\n', '\n', '        // first payment\n', '        require(wethContract.transferFrom(msg.sender, receiver, weiAmount), "wETH transferFrom() failed");\n', '\n', '        // add to subscription mappings\n', '        subscriptions[nextIndex] = Subscription(\n', '            true,\n', '            uint48(now.add(interval)),\n', '            interval,\n', '            msg.sender,\n', '            receiver,\n', '            daiCents\n', '        );\n', '        subscriberReceiver[msg.sender][receiver] = nextIndex;\n', '        receiverSubs[receiver].push(nextIndex);\n', '        subscriberSubs[msg.sender].push(nextIndex);\n', '\n', '        emit NewSubscription(msg.sender, receiver, daiCents, interval);\n', '        emit SubscriptionPaid(msg.sender, receiver, weiAmount, daiCents, uint48(now));\n', '\n', '        nextIndex++;\n', '    }\n', '    \n', '    /**\n', "     * Deactivate a subscription. Must be called by the subscriber's account.\n", '     * Payments cannot be collected from deactivated subscriptons.\n', '     * @param receiver address used to identify the unique subscriber-receiver pair.\n', '     * @return success\n', '     */\n', '    function deactivateSubscription(address receiver) external returns (bool) {\n', '        uint64 index = subscriberReceiver[msg.sender][receiver];\n', '        require(index != 0, "Subscription does not exist");\n', '\n', '        Subscription storage sub = subscriptions[index];\n', '        require(sub.isActive, "Subscription is already disabled");\n', '        require(sub.daiCents > 0, "Subscription does not exist");\n', '\n', '        sub.isActive = false;\n', '        emit SubscriptionDeactivated(msg.sender, receiver);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Reactivate a subscription. Must be called by the subscriber's account.\n", '     * If less than one interval has passed since the last payment, no payment is collected now.\n', '     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\n', '     * No back-payments are collected.\n', '     * @param receiver addres used to identify the unique subscriber-receiver pair.\n', '     * @return success\n', '     */\n', '    function reactivateSubscription(address receiver) external returns (bool) {\n', '        uint64 index = subscriberReceiver[msg.sender][receiver];\n', '        require(index != 0, "Subscription does not exist");\n', '\n', '        Subscription storage sub = subscriptions[index];\n', '        require(!sub.isActive, "Subscription is already active");\n', '\n', '        sub.isActive = true;\n', '        emit SubscriptionReactivated(msg.sender, receiver);\n', '\n', '        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\n', '            // only make a payment if at least one interval has lapsed since the last payment\n', '            uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceInDaiWad());\n', '            require(wethContract.transferFrom(msg.sender, receiver, weiAmount), "Insufficient funds to reactivate subscription");\n', '            emit SubscriptionPaid(msg.sender, receiver, weiAmount, sub.daiCents, uint48(now));\n', '        }\n', '\n', '        sub.nextPaymentTime = uint48(now.add(sub.interval));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Delete a subscription. Must be called by the subscriber's account.\n", '     * @param receiver address used to identify the unique subscriber-receiver pair.\n', '     */\n', '    function unsubscribe(address receiver) external {\n', '        uint64 index = subscriberReceiver[msg.sender][receiver];\n', '        require(index != 0, "Subscription does not exist");\n', '        delete subscriptions[index];\n', '        delete subscriberReceiver[msg.sender][receiver];\n', '        deleteElement(subscriberSubs[msg.sender], index);\n', '        emit Unsubscribe(msg.sender, receiver);\n', '    }\n', '\n', '    /**\n', "     * Delete a subscription. Must be called by the receiver's account.\n", '     * @param subscriber address used to identify the unique subscriber-receiver pair.\n', '     */\n', '    function unsubscribeByReceiver(address subscriber) external {\n', '        uint64 index = subscriberReceiver[subscriber][msg.sender];\n', '        require(index != 0, "Subscription does not exist");\n', '        delete subscriptions[index];\n', '        delete subscriberReceiver[subscriber][msg.sender];\n', '        deleteElement(subscriberSubs[subscriber], index);\n', '        emit Unsubscribe(subscriber, msg.sender);\n', '    }\n', '\n', '    /**\n', "     * Collect all available *funded* payments for a receiver's account.\n", '     * Helper function that calls executeDebitsRange() with the full range.\n', '     * Will process as many payments as possible with the gas provided and exit gracefully.\n', '     * \n', '     * @param receiver address\n', '     */\n', '    function executeDebits(address receiver) external {\n', '        executeDebitsRange(receiver, 0, receiverSubs[receiver].length);\n', '    }\n', '\n', '    /**\n', '     * A read-only version of executeDebits()\n', '     * Calculates uncollected *funded* payments for a receiver.\n', '     * @param receiver address\n', '     * @return total unclaimed value in wei\n', '     */\n', '    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\n', '        uint totalPayment = 0;\n', '        uint ethPriceWad = ethPriceInDaiWad();\n', '\n', '        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\n', '            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\n', '\n', '            if (sub.isActive && sub.daiCents != 0) {\n', '                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n', '                if (wholeUnpaidIntervals > 0) {\n', '                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n', '                    uint authorizedBalance = allowedBalance(sub.subscriber);\n', '\n', '                    do {\n', '                        if (authorizedBalance >= weiAmount) {\n', '                            totalPayment = totalPayment.add(weiAmount);\n', '                            authorizedBalance = authorizedBalance.sub(weiAmount);\n', '                        }\n', '                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n', '                    } while (wholeUnpaidIntervals > 0);\n', '                }\n', '            }\n', '        }\n', '\n', '        return totalPayment;\n', '    }\n', '\n', '    /**\n', "     * Calculates a subscriber's total outstanding payments in daiCents\n", '     * @param subscriber address\n', '     * @param time in seconds. If `time` < `now`, then we simply use `now`\n', '     * @return total amount owed at `time` in daiCents\n', '     */\n', '    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\n', '        uint until = time <= now ? now : time;\n', '\n', '        uint64[] memory subs = subscriberSubs[subscriber];\n', '\n', '        uint totalDaiCents = 0;\n', '        for (uint64 i = 0; i < subs.length; i++) {\n', '            Subscription memory sub = subscriptions[subs[i]];\n', '            if (sub.isActive) {\n', '                totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until)));\n', '            }\n', '        }\n', '\n', '        return totalDaiCents;\n', '    }\n', '\n', '    /**\n', "     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\n", '     * Will process as many payments as possible with the gas provided and exit gracefully.\n', '     * \n', '     * @param receiver address\n', '     * @param start starting index of receiverSubs[receiver]\n', '     * @param end ending index of receiverSubs[receiver]\n', '     * @return last processed index\n', '     */\n', '    function executeDebitsRange(address receiver, uint start, uint end) public returns (uint) {\n', '        uint64[] storage subs = receiverSubs[receiver];\n', '        require(subs.length > 0, "receiver has no subscriptions");\n', '        require(start < end && end <= subs.length, "wrong arguments for range");\n', '        uint totalPayment = 0;\n', '        uint ethPriceWad = ethPriceInDaiWad();\n', '\n', '        uint last = end;\n', '        uint i = start;\n', '        while (i < last) {\n', '            if (gasleft() < MIN_GAS_PER_EXECUTE_DEBIT) {\n', '                break;\n', '            }\n', '            Subscription storage sub = subscriptions[subs[i]];\n', '\n', '            // delete empty subs\n', '            while (sub.daiCents == 0 && subs.length > 0) {\n', '                uint lastIndex = subs.length.sub(1);\n', '                subs[i] = subs[lastIndex];\n', '                delete(subs[lastIndex]);\n', '                subs.length = lastIndex;\n', '                if (last > lastIndex) {\n', '                    last = lastIndex;\n', '                }\n', '                if (lastIndex > 0) {\n', '                    sub = subscriptions[subs[i]];\n', '                }\n', '            }\n', '\n', '            if (sub.isActive && sub.daiCents != 0) {\n', '                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n', '                if (wholeUnpaidIntervals > 0) {\n', '                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n', '                    uint authorizedBalance = allowedBalance(sub.subscriber);\n', '\n', '                    do {\n', '                        if (authorizedBalance >= weiAmount) {\n', '                            assert(wethContract.transferFrom(sub.subscriber, receiver, weiAmount));\n', '                            sub.nextPaymentTime = calculateNextPaymentTime(sub);\n', '                            totalPayment = totalPayment.add(weiAmount);\n', '                            emit SubscriptionPaid(sub.subscriber, receiver, weiAmount, sub.daiCents, sub.nextPaymentTime);\n', '                        } else {\n', '                            emit UnfundedPayment(sub.subscriber, receiver, weiAmount, sub.daiCents);\n', '\n', '                            if (wholeUnpaidIntervals >= 2) {\n', '                                sub.isActive = false;\n', '                                emit SubscriptionDeactivated(sub.subscriber, receiver);\n', '                                emit StaleSubscription(sub.subscriber, receiver);\n', '                                break;\n', '                            }\n', '                        }\n', '                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n', '                    } while (wholeUnpaidIntervals > 0);\n', '                }\n', '            }\n', '\n', '            i++;\n', '        }\n', '\n', '        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\n', '        return i;\n', '    }\n', '\n', '    /**\n', '     * Calculates how much wETH balance Subscrypto is authorized to use on bealf of `payer`.\n', "     * Returns the minimum(payer's wETH balance, amount authorized to Subscrypto).\n", '     * @param payer address\n', '     * @return wad amount of wETH available for Subscrypto payments\n', '     */\n', '    function allowedBalance(address payer) public view returns (uint) {\n', '        uint balance = wethContract.balanceOf(payer);\n', '        uint allowance = wethContract.allowance(payer, address(this));\n', '\n', '        return balance > allowance ? allowance : balance;\n', '    }\n', '\n', '    /**\n', '     * Calls the DAI medianizer contract to get the current exchange rate for ETH-DAI\n', '     * @return current ETH price in DAI (wad format)\n', '     */\n', '    function ethPriceInDaiWad() public view returns (uint) {\n', '        uint price = uint(daiPriceContract.read());\n', '        require(price > 1, "Invalid price for DAI.");\n', '        return price;\n', '    }\n', '\n', '    /**\n', '     * Helper function to search for and delete an array element without leaving a gap.\n', '     * Array size is also decremented.\n', '     * DO NOT USE if ordering is important.\n', '     * @param array array to be modified\n', '     * @param element value to be removed\n', '     */\n', '    function deleteElement(uint64[] storage array, uint64 element) internal {\n', '        uint lastIndex = array.length.sub(1);\n', '        for (uint i = 0; i < array.length; i++) {\n', '            if (array[i] == element) {\n', '                array[i] = array[lastIndex];\n', '                delete(array[lastIndex]);\n', '                array.length = lastIndex;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\n', '     * DOES NOT check if subscriber account is funded.\n', '     * @param sub Subscription object\n', '     * @param time timestamp in seconds\n', '     * @return number of unpaid intervals\n', '     */\n', '    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\n', '        require(time >= now, "don\'t use a time before now");\n', '\n', '        if (time > sub.nextPaymentTime) {\n', '            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * Safely calculate the next payment timestamp for a Subscription\n', '     * @param sub Subscription object\n', '     * @return uint48 timestamp in seconds of the next payment\n', '     */\n', '    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\n', '        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\n', '        assert(nextPaymentTime > sub.nextPaymentTime);\n', '        return nextPaymentTime;\n', '    }\n', '\n', '    /**\n', '     * Converts DAI (cents) to ETH (wei) without losing precision\n', '     * @param daiCents one hundreth of a DAI\n', '     * @param ethPriceWad price from calling ethPriceInDaiWad()\n', '     * @return ETH value denominated in wei\n', '     */\n', '    function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) {\n', '        return centsToWad(daiCents).mul(10**18).div(ethPriceWad);\n', '    }\n', '\n', '    /**\n', '     * Converts amount in cents (hundredths of DAI) to amount in wad\n', '     * @param cents daiCents (hundredths of DAI)\n', '     * @return amount of dai in wad\n', '     */\n', '    function centsToWad(uint cents) internal pure returns (uint) {\n', '        return cents.mul(10**16);\n', '    }\n', '}']