['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', 'pragma solidity >=0.4.22 <0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @dev Wrappers over Solidity&#39;s arithmetic operations with added overflow\n', ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', ' * class of bugs, so it&#39;s recommended to use it always.\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `+` operator.\n', '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * Counterpart to Solidity&#39;s `-` operator.\n', '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `*` operator.\n', '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a\n', '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`\n', '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract LibMath {\n', '    using SafeMath for uint256;\n', '\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256 partialAmount)\n', '    {\n', '        partialAmount = numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    function getFeeAmount(\n', '        uint256 numerator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256 feeAmount)\n', '    {\n', '        feeAmount = numerator.mul(target).div(1 ether); // todo: constants\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibOrder {\n', '\n', '    struct Order {\n', '        uint256 makerSellAmount;\n', '        uint256 makerBuyAmount;\n', '        uint256 takerSellAmount;\n', '        uint256 salt;\n', '        uint256 expiration;\n', '        address taker;\n', '        address maker;\n', '        address makerSellToken;\n', '        address makerBuyToken;\n', '    }\n', '\n', '    struct OrderInfo {\n', '        uint256 filledAmount;\n', '        bytes32 hash;\n', '        uint8 status;\n', '    }\n', '\n', '    struct OrderFill {\n', '        uint256 makerFillAmount;\n', '        uint256 takerFillAmount;\n', '        uint256 takerFeePaid;\n', '        uint256 exchangeFeeReceived;\n', '        uint256 referralFeeReceived;\n', '        uint256 makerFeeReceived;\n', '    }\n', '\n', '    enum OrderStatus {\n', '        INVALID_SIGNER,\n', '        INVALID_TAKER_AMOUNT,\n', '        INVALID_MAKER_AMOUNT,\n', '        FILLABLE,\n', '        EXPIRED,\n', '        FULLY_FILLED,\n', '        CANCELLED\n', '    }\n', '\n', '    function getHash(Order memory order)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                order.maker,\n', '                order.makerSellToken,\n', '                order.makerSellAmount,\n', '                order.makerBuyToken,\n', '                order.makerBuyAmount,\n', '                order.salt,\n', '                order.expiration\n', '            )\n', '        );\n', '    }\n', '\n', '    function getPrefixedHash(Order memory order)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        bytes32 orderHash = getHash(order);\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibSignatureValidator   {\n', '\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(hash, v, r, s);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract IKyberNetworkProxy {\n', '    function getExpectedRate(address src, address dest, uint srcQty) public view\n', '        returns (uint expectedRate, uint slippageRate);\n', '\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    ) public payable returns(uint256);\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibKyberData {\n', '\n', '    struct KyberData {\n', '        uint256 rate;\n', '        uint256 value;\n', '        address givenToken;\n', '        address receivedToken;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract IExchangeUpgradability {\n', '\n', '    uint8 public VERSION;\n', '\n', '    event FundsMigrated(address indexed user, address indexed newExchange);\n', '    \n', '    function allowOrRestrictMigrations() external;\n', '\n', '    function migrateFunds(address[] calldata tokens) external;\n', '\n', '    function migrateEthers() private;\n', '\n', '    function migrateTokens(address[] memory tokens) private;\n', '\n', '    function importEthers(address user) external payable;\n', '\n', '    function importTokens(address tokenAddress, uint256 tokenAmount, address user) external;\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibCrowdsale {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Crowdsale {\n', '        uint256 startBlock;\n', '        uint256 endBlock;\n', '        uint256 hardCap;\n', '        uint256 leftAmount;\n', '        uint256 tokenRatio;\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 weiRaised;\n', '        address wallet;\n', '    }\n', '\n', '    enum ContributionStatus {\n', '        CROWDSALE_NOT_OPEN,\n', '        MIN_CONTRIBUTION,\n', '        MAX_CONTRIBUTION,\n', '        HARDCAP_REACHED,\n', '        VALID\n', '    }\n', '\n', '    enum CrowdsaleStatus {\n', '        INVALID_START_BLOCK,\n', '        INVALID_END_BLOCK,\n', '        INVALID_TOKEN_RATIO,\n', '        INVALID_LEFT_AMOUNT,\n', '        VALID\n', '    }\n', '\n', '    function getCrowdsaleStatus(Crowdsale memory crowdsale)\n', '        public\n', '        view\n', '        returns (CrowdsaleStatus)\n', '    {\n', '\n', '        if(crowdsale.startBlock < block.number) {\n', '            return CrowdsaleStatus.INVALID_START_BLOCK;\n', '        }\n', '\n', '        if(crowdsale.endBlock < crowdsale.startBlock) {\n', '            return CrowdsaleStatus.INVALID_END_BLOCK;\n', '        }\n', '\n', '        if(crowdsale.tokenRatio == 0) {\n', '            return CrowdsaleStatus.INVALID_TOKEN_RATIO;\n', '        }\n', '\n', '        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\n', '\n', '        if(tokenForSale != crowdsale.leftAmount) {\n', '            return CrowdsaleStatus.INVALID_LEFT_AMOUNT;\n', '        }\n', '\n', '        return CrowdsaleStatus.VALID;\n', '    }\n', '\n', '    function isOpened(uint256 startBlock, uint256 endBlock)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (block.number >= startBlock && block.number <= endBlock);\n', '    }\n', '\n', '\n', '    function isFinished(uint256 endBlock)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return block.number > endBlock;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', '     * condition is to first reduce the spender&#39;s allowance to 0 and set the\n', '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', '     * allowance mechanism. `amount` is then deducted from the caller&#39;s\n', '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type,\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', '     * execution of a contract&#39;s constructor, its address will be reported as\n', '     * not containing a contract.\n', '     *\n', '     * > It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeStorage is Ownable {\n', '\n', '    /**\n', '      * @dev The minimum fee rate that the maker will receive\n', '      * Note: 20% = 20 * 10^16\n', '      */\n', '    uint256 constant internal minMakerFeeRate = 200000000000000000;\n', '\n', '    /**\n', '      * @dev The maximum fee rate that the maker will receive\n', '      * Note: 90% = 90 * 10^16\n', '      */\n', '    uint256 constant internal maxMakerFeeRate = 900000000000000000;\n', '\n', '    /**\n', '      * @dev The minimum fee rate that the taker will pay\n', '      * Note: 0.1% = 0.1 * 10^16\n', '      */\n', '    uint256 constant internal minTakerFeeRate = 1000000000000000;\n', '\n', '    /**\n', '      * @dev The maximum fee rate that the taker will pay\n', '      * Note: 1% = 1 * 10^16\n', '      */\n', '    uint256 constant internal maxTakerFeeRate = 10000000000000000;\n', '\n', '    /**\n', '      * @dev The referrer will receive 10% from each taker fee.\n', '      * Note: 10% = 10 * 10^16\n', '      */\n', '    uint256 constant internal referralFeeRate = 100000000000000000;\n', '\n', '    /**\n', '      * @dev The amount of percentage the maker will receive from each taker fee.\n', '      * Note: Initially: 50% = 50 * 10^16\n', '      */\n', '    uint256 public makerFeeRate;\n', '\n', '    /**\n', '      * @dev The amount of percentage the will pay for taking an order.\n', '      * Note: Initially: 0.2% = 0.2 * 10^16\n', '      */\n', '    uint256 public takerFeeRate;\n', '\n', '    /**\n', '      * @dev 2-level map: tokenAddress -> userAddress -> balance\n', '      */\n', '    mapping(address => mapping(address => uint256)) internal balances;\n', '\n', '    /**\n', '      * @dev map: orderHash -> filled amount\n', '      */\n', '    mapping(bytes32 => uint256) internal filled;\n', '\n', '    /**\n', '      * @dev map: orderHash -> isCancelled\n', '      */\n', '    mapping(bytes32 => bool) internal cancelled;\n', '\n', '    /**\n', '      * @dev map: user -> userReferrer\n', '      */\n', '    mapping(address => address) internal referrals;\n', '\n', '    /**\n', '      * @dev The address where all exchange fees (0,08%) are kept.\n', '      * Node: multisig wallet\n', '      */\n', '    address public feeAccount;\n', '\n', '    /**\n', '      * @return return the balance of `token` for certain `user`\n', '      */\n', '    function getBalance(\n', '        address user,\n', '        address token\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balances[token][user];\n', '    }\n', '\n', '    /**\n', '      * @return return the balance of multiple tokens for certain `user`\n', '      */\n', '    function getBalances(\n', '        address user,\n', '        address[] memory token\n', '    )\n', '        public\n', '        view\n', '        returns(uint256[] memory balanceArray)\n', '    {\n', '        balanceArray = new uint256[](token.length);\n', '\n', '        for(uint256 index = 0; index < token.length; index++) {\n', '            balanceArray[index] = balances[token[index]][user];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return the filled amount of order specified by `orderHash`\n', '      */\n', '    function getFill(\n', '        bytes32 orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return filled[orderHash];\n', '    }\n', '\n', '    /**\n', '      * @return return the filled amount of multple orders specified by `orderHash` array\n', '      */\n', '    function getFills(\n', '        bytes32[] memory orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (uint256[] memory filledArray)\n', '    {\n', '        filledArray = new uint256[](orderHash.length);\n', '\n', '        for(uint256 index = 0; index < orderHash.length; index++) {\n', '            filledArray[index] = filled[orderHash[index]];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return true(false) if order specified by `orderHash` is(not) cancelled\n', '      */\n', '    function getCancel(\n', '        bytes32 orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return cancelled[orderHash];\n', '    }\n', '\n', '    /**\n', '      * @return return array of true(false) if orders specified by `orderHash` array are(not) cancelled\n', '      */\n', '    function getCancels(\n', '        bytes32[] memory orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (bool[]memory cancelledArray)\n', '    {\n', '        cancelledArray = new bool[](orderHash.length);\n', '\n', '        for(uint256 index = 0; index < orderHash.length; index++) {\n', '            cancelledArray[index] = cancelled[orderHash[index]];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return the referrer address of `user`\n', '      */\n', '    function getReferral(\n', '        address user\n', '    )\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return referrals[user];\n', '    }\n', '\n', '    /**\n', '      * @return set new rate for the maker fee received\n', '      */\n', '    function setMakerFeeRate(\n', '        uint256 newMakerFeeRate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newMakerFeeRate >= minMakerFeeRate &&\n', '            newMakerFeeRate <= maxMakerFeeRate,\n', '            "INVALID_MAKER_FEE_RATE"\n', '        );\n', '        makerFeeRate = newMakerFeeRate;\n', '    }\n', '\n', '    /**\n', '      * @return set new rate for the taker fee paid\n', '      */\n', '    function setTakerFeeRate(\n', '        uint256 newTakerFeeRate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newTakerFeeRate >= minTakerFeeRate &&\n', '            newTakerFeeRate <= maxTakerFeeRate,\n', '            "INVALID_TAKER_FEE_RATE"\n', '        );\n', '\n', '        takerFeeRate = newTakerFeeRate;\n', '    }\n', '\n', '    /**\n', '      * @return set new fee account\n', '      */\n', '    function setFeeAccount(\n', '        address newFeeAccount\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeAccount = newFeeAccount;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', '        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;\n', '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since\n', '        // we&#39;re implementing it ourselves.\n', '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Exchange is LibMath, LibOrder, LibSignatureValidator, ExchangeStorage {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev emitted when a trade is executed\n', '      */\n', '    event Trade(\n', '        address indexed makerAddress,        // Address that created the order\n', '        address indexed takerAddress,        // Address that filled the order\n', '        bytes32 indexed orderHash,           // Hash of the order\n', '        address makerFilledAsset,            // Address of assets filled for maker\n', '        address takerFilledAsset,            // Address of assets filled for taker\n', '        uint256 makerFilledAmount,           // Amount of assets filled for maker\n', '        uint256 takerFilledAmount,           // Amount of assets filled for taker\n', '        uint256 takerFeePaid,                // Amount of fee paid by the taker\n', '        uint256 makerFeeReceived,            // Amount of fee received by the maker\n', '        uint256 referralFeeReceived          // Amount of fee received by the referrer\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a cancel order is executed\n', '      */\n', '    event Cancel(\n', '        address indexed makerBuyToken,        // Address of asset being bought.\n', '        address makerSellToken,               // Address of asset being sold.\n', '        address indexed maker,                // Address that created the order\n', '        bytes32 indexed orderHash             // Hash of the order\n', '    );\n', '\n', '    /**\n', '      * @dev Compute the status of an order.\n', '      * Should be called before a contract execution is performet in order to not waste gas.\n', '      * @return OrderStatus.FILLABLE if the order is valid for taking.\n', '      * Note: See LibOrder.sol to see all statuses\n', '      */\n', '    function getOrderInfo(\n', '        uint256 partialAmount,\n', '        Order memory order\n', '    )\n', '        public\n', '        view\n', '        returns (OrderInfo memory orderInfo)\n', '    {\n', '        // Compute the order hash\n', '        orderInfo.hash = getPrefixedHash(order);\n', '\n', '        // Fetch filled amount\n', '        orderInfo.filledAmount = filled[orderInfo.hash];\n', '\n', '        // Check taker balance\n', '        if(balances[order.makerBuyToken][order.taker] < order.takerSellAmount) {\n', '            orderInfo.status = uint8(OrderStatus.INVALID_TAKER_AMOUNT);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check maker balance\n', '        if(balances[order.makerSellToken][order.maker] < partialAmount) {\n', '            orderInfo.status = uint8(OrderStatus.INVALID_MAKER_AMOUNT);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check if order is filled\n', '        if (orderInfo.filledAmount.add(order.takerSellAmount) > order.makerBuyAmount) {\n', '            orderInfo.status = uint8(OrderStatus.FULLY_FILLED);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check for expiration\n', '        if (block.number >= order.expiration) {\n', '            orderInfo.status = uint8(OrderStatus.EXPIRED);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check if order has been cancelled\n', '        if (cancelled[orderInfo.hash]) {\n', '            orderInfo.status = uint8(OrderStatus.CANCELLED);\n', '            return orderInfo;\n', '        }\n', '\n', '        orderInfo.status = uint8(OrderStatus.FILLABLE);\n', '        return orderInfo;\n', '    }\n', '\n', '    /**\n', '      * @dev Execute a trade based on the input order and signature.\n', '      * Reverts if order is not valid\n', '      */\n', '    function trade(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        public\n', '    {\n', '        bool result = _trade(order, signature);\n', '        require(result, "INVALID_TRADE");\n', '    }\n', '\n', '    /**\n', '      * @dev Execute a trade based on the input order and signature.\n', '      * If the order is valid returns true.\n', '      */\n', '    function _trade(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        internal\n', '        returns(bool)\n', '    {\n', '        order.taker = msg.sender;\n', '\n', '        uint256 takerReceivedAmount = getPartialAmount(\n', '            order.makerSellAmount,\n', '            order.makerBuyAmount,\n', '            order.takerSellAmount\n', '        );\n', '\n', '        OrderInfo memory orderInfo = getOrderInfo(takerReceivedAmount, order);\n', '\n', '        uint8 status = assertTakeOrder(orderInfo.hash, orderInfo.status, order.maker, signature);\n', '\n', '        if(status != uint8(OrderStatus.FILLABLE)) {\n', '            return false;\n', '        }\n', '\n', '        OrderFill memory orderFill = getOrderFillResult(takerReceivedAmount, order);\n', '\n', '        executeTrade(order, orderFill);\n', '\n', '        filled[orderInfo.hash] = filled[orderInfo.hash].add(order.takerSellAmount);\n', '\n', '        emit Trade(\n', '            order.maker,\n', '            order.taker,\n', '            orderInfo.hash,\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            orderFill.makerFillAmount,\n', '            orderFill.takerFillAmount,\n', '            orderFill.takerFeePaid,\n', '            orderFill.makerFeeReceived,\n', '            orderFill.referralFeeReceived\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @dev Cancel an order if msg.sender is the order signer.\n', '      */\n', '    function cancelSingleOrder(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        public\n', '    {\n', '        bytes32 orderHash = getPrefixedHash(order);\n', '\n', '        require(\n', '            recover(orderHash, signature) == msg.sender,\n', '            "INVALID_SIGNER"\n', '        );\n', '\n', '        require(\n', '            cancelled[orderHash] == false,\n', '            "ALREADY_CANCELLED"\n', '        );\n', '\n', '        cancelled[orderHash] = true;\n', '\n', '        emit Cancel(\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            msg.sender,\n', '            orderHash\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Computation of the following properties based on the order input:\n', '      * takerFillAmount -> amount of assets received by the taker\n', '      * makerFillAmount -> amount of assets received by the maker\n', '      * takerFeePaid -> amount of fee paid by the taker (0.2% of takerFillAmount)\n', '      * makerFeeReceived -> amount of fee received by the maker (50% of takerFeePaid)\n', '      * referralFeeReceived -> amount of fee received by the taker referrer (10% of takerFeePaid)\n', '      * exchangeFeeReceived -> amount of fee received by the exchange (40% of takerFeePaid)\n', '      */\n', '    function getOrderFillResult(\n', '        uint256 takerReceivedAmount,\n', '        Order memory order\n', '    )\n', '        internal\n', '        view\n', '        returns (OrderFill memory orderFill)\n', '    {\n', '        orderFill.takerFillAmount = takerReceivedAmount;\n', '\n', '        orderFill.makerFillAmount = order.takerSellAmount;\n', '\n', '        // 0.2% == 0.2*10^16\n', '        orderFill.takerFeePaid = getFeeAmount(\n', '            takerReceivedAmount,\n', '            takerFeeRate\n', '        );\n', '\n', '        // 50% of taker fee == 50*10^16\n', '        orderFill.makerFeeReceived = getFeeAmount(\n', '            orderFill.takerFeePaid,\n', '            makerFeeRate\n', '        );\n', '\n', '        // 10% of taker fee == 10*10^16\n', '        orderFill.referralFeeReceived = getFeeAmount(\n', '            orderFill.takerFeePaid,\n', '            referralFeeRate\n', '        );\n', '\n', '        // exchangeFee = (takerFeePaid - makerFeeReceived - referralFeeReceived)\n', '        orderFill.exchangeFeeReceived = orderFill.takerFeePaid.sub(\n', '            orderFill.makerFeeReceived).sub(\n', '                orderFill.referralFeeReceived);\n', '\n', '    }\n', '\n', '    /**\n', '      * @dev Throws when the order status is invalid or the signer is not valid.\n', '      */\n', '    function assertTakeOrder(\n', '        bytes32 orderHash,\n', '        uint8 status,\n', '        address signer,\n', '        bytes memory signature\n', '    )\n', '        internal\n', '        pure\n', '        returns(uint8)\n', '    {\n', '        uint8 result = uint8(OrderStatus.FILLABLE);\n', '\n', '        if(recover(orderHash, signature) != signer) {\n', '            result = uint8(OrderStatus.INVALID_SIGNER);\n', '        }\n', '\n', '        if(status != uint8(OrderStatus.FILLABLE)) {\n', '            result = status;\n', '        }\n', '\n', '        return status;\n', '    }\n', '\n', '    /**\n', '      * @dev Updates the contract state i.e. user balances\n', '      */\n', '    function executeTrade(\n', '        Order memory order,\n', '        OrderFill memory orderFill\n', '    )\n', '        private\n', '    {\n', '        uint256 makerGiveAmount = orderFill.takerFillAmount.sub(orderFill.makerFeeReceived);\n', '        uint256 takerFillAmount = orderFill.takerFillAmount.sub(orderFill.takerFeePaid);\n', '\n', '        address referrer = referrals[order.taker];\n', '        address feeAddress = feeAccount;\n', '\n', '        balances[order.makerSellToken][referrer] = balances[order.makerSellToken][referrer].add(orderFill.referralFeeReceived);\n', '        balances[order.makerSellToken][feeAddress] = balances[order.makerSellToken][feeAddress].add(orderFill.exchangeFeeReceived);\n', '\n', '        balances[order.makerBuyToken][order.taker] = balances[order.makerBuyToken][order.taker].sub(orderFill.makerFillAmount);\n', '        balances[order.makerBuyToken][order.maker] = balances[order.makerBuyToken][order.maker].add(orderFill.makerFillAmount);\n', '\n', '        balances[order.makerSellToken][order.taker] = balances[order.makerSellToken][order.taker].add(takerFillAmount);\n', '        balances[order.makerSellToken][order.maker] = balances[order.makerSellToken][order.maker].sub(makerGiveAmount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeKyberProxy is Exchange, LibKyberData {\n', '    using SafeERC20 for IERC20;\n', '\n', '    /**\n', '      * @dev The precision used for calculating the amounts - 10*18\n', '      */\n', '    uint256 constant internal PRECISION = 1000000000000000000;\n', '\n', '    /**\n', '      * @dev Max decimals allowed when calculating amounts.\n', '      */\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '\n', '    /**\n', '      * @dev Decimals of Ether.\n', '      */\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '\n', '    /**\n', '      * @dev The address that represents ETH in Kyber Network Contracts.\n', '      */\n', '    address constant internal KYBER_ETH_TOKEN_ADDRESS =\n', '        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    uint256 constant internal MAX_DEST_AMOUNT = 2**256 - 1;\n', '\n', '    /**\n', '      * @dev KyberNetworkProxy contract address\n', '      */\n', '    IKyberNetworkProxy constant internal kyberNetworkContract =\n', '        IKyberNetworkProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\n', '\n', '    /**\n', '      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using KyberNetwork reserves.\n', '      */\n', '    function kyberSwap(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        bytes32 hash\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        KyberData memory kyberData = getSwapInfo(\n', '            givenAmount,\n', '            givenToken,\n', '            receivedToken,\n', '            taker\n', '        );\n', '\n', '        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\n', '            kyberData.givenToken,\n', '            givenAmount,\n', '            kyberData.receivedToken,\n', '            taker,\n', '            MAX_DEST_AMOUNT,\n', '            kyberData.rate,\n', '            feeAccount\n', '        );\n', '\n', '        emit Trade(\n', '            address(kyberNetworkContract),\n', '            taker,\n', '            hash,\n', '            givenToken,\n', '            receivedToken,\n', '            givenAmount,\n', '            convertedAmount,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Exchange ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using the internal\n', '      * balance mapping that keeps track of user&#39;s balances. It requires user to first invoke deposit function.\n', '      * The function relies on KyberNetworkProxy contract.\n', '      */\n', '    function kyberTrade(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        bytes32 hash\n', '    )\n', '        public\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        KyberData memory kyberData = getTradeInfo(\n', '            givenAmount,\n', '            givenToken,\n', '            receivedToken\n', '        );\n', '\n', '        balances[givenToken][taker] = balances[givenToken][taker].sub(givenAmount);\n', '\n', '        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\n', '            kyberData.givenToken,\n', '            givenAmount,\n', '            kyberData.receivedToken,\n', '            address(this),\n', '            MAX_DEST_AMOUNT,\n', '            kyberData.rate,\n', '            feeAccount\n', '        );\n', '\n', '        balances[receivedToken][taker] = balances[receivedToken][taker].add(convertedAmount);\n', '\n', '        emit Trade(\n', '            address(kyberNetworkContract),\n', '            taker,\n', '            hash,\n', '            givenToken,\n', '            receivedToken,\n', '            givenAmount,\n', '            convertedAmount,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Helper function to determine what is being swapped.\n', '      */\n', '    function getSwapInfo(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        address taker\n', '    )\n', '        private\n', '        returns(KyberData memory)\n', '    {\n', '        KyberData memory kyberData;\n', '        uint256 givenTokenDecimals;\n', '        uint256 receivedTokenDecimals;\n', '\n', '        if(givenToken == address(0x0)) {\n', '            require(msg.value == givenAmount, "INVALID_ETH_VALUE");\n', '\n', '            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = givenAmount;\n', '\n', '            givenTokenDecimals = ETH_DECIMALS;\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '        } else if(receivedToken == address(0x0)) {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = ETH_DECIMALS;\n', '\n', '            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        } else {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '\n', '            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        }\n', '\n', '        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\n', '            kyberData.givenToken,\n', '            kyberData.receivedToken,\n', '            givenAmount\n', '        );\n', '\n', '        return kyberData;\n', '    }\n', '\n', '    /**\n', '      * @dev Helper function to determines what is being\n', '        swapped using the internal balance mapping.\n', '      */\n', '    function getTradeInfo(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken\n', '    )\n', '        private\n', '        returns(KyberData memory)\n', '    {\n', '        KyberData memory kyberData;\n', '        uint256 givenTokenDecimals;\n', '        uint256 receivedTokenDecimals;\n', '\n', '        if(givenToken == address(0x0)) {\n', '            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = givenAmount;\n', '\n', '            givenTokenDecimals = ETH_DECIMALS;\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '        } else if(receivedToken == address(0x0)) {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = ETH_DECIMALS;\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        } else {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        }\n', '\n', '        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\n', '            kyberData.givenToken,\n', '            kyberData.receivedToken,\n', '            givenAmount\n', '        );\n', '\n', '        return kyberData;\n', '    }\n', '\n', '    function getExpectedRateBatch(\n', '        address[] memory givenTokens,\n', '        address[] memory receivedTokens,\n', '        uint256[] memory givenAmounts\n', '    )\n', '        public\n', '        view\n', '        returns(uint256[] memory, uint256[] memory)\n', '    {\n', '        uint256 size = givenTokens.length;\n', '        uint256[] memory expectedRates = new uint256[](size);\n', '        uint256[] memory slippageRates = new uint256[](size);\n', '\n', '        for(uint256 index = 0; index < size; index++) {\n', '            (expectedRates[index], slippageRates[index]) = kyberNetworkContract.getExpectedRate(\n', '                givenTokens[index],\n', '                receivedTokens[index],\n', '                givenAmounts[index]\n', '            );\n', '        }\n', '\n', '       return (expectedRates, slippageRates);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeBatchTrade is Exchange {\n', '\n', '    /**\n', '      * @dev Cancel an array of orders if msg.sender is the order signer.\n', '      */\n', '    function cancelMultipleOrders(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            cancelSingleOrder(\n', '                orders[index],\n', '                signatures[index]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @dev Execute multiple trades based on the input orders and signatures.\n', '      * Note: reverts of one or more trades fail.\n', '      */\n', '    function takeAllOrRevert(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            bool result = _trade(orders[index], signatures[index]);\n', '            require(result, "INVALID_TAKEALL");\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @dev Execute multiple trades based on the input orders and signatures.\n', '      * Note: does not revert if one or more trades fail.\n', '      */\n', '    function takeAllPossible(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            _trade(orders[index], signatures[index]);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeMovements is ExchangeStorage {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev emitted when a deposit is received\n', '      */\n', '    event Deposit(\n', '        address indexed token,\n', '        address indexed user,\n', '        address indexed referral,\n', '        address beneficiary,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a withdraw is received\n', '      */\n', '    event Withdraw(\n', '        address indexed token,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a transfer is received\n', '      */\n', '    event Transfer(\n', '        address indexed token,\n', '        address indexed user,\n', '        address indexed beneficiary,\n', '        uint256 amount,\n', '        uint256 userBalance,\n', '        uint256 beneficiaryBalance\n', '    );\n', '\n', '    /**\n', '      * @dev Updates the level 2 map `balances` based on the input\n', '      *      Note: token address is (0x0) when the deposit is for ETH\n', '      */\n', '    function deposit(\n', '        address token,\n', '        uint256 amount,\n', '        address beneficiary,\n', '        address referral\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        uint256 value = amount;\n', '        address user = msg.sender;\n', '\n', '        if(token == address(0x0)) {\n', '            value = msg.value;\n', '        } else {\n', '            IERC20(token).safeTransferFrom(user, address(this), value);\n', '        }\n', '\n', '        balances[token][beneficiary] = balances[token][beneficiary].add(value);\n', '\n', '        if(referrals[user] == address(0x0)) {\n', '            referrals[user] = referral;\n', '        }\n', '\n', '        emit Deposit(\n', '            token,\n', '            user,\n', '            referrals[user],\n', '            beneficiary,\n', '            value,\n', '            balances[token][beneficiary]\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Updates the level 2 map `balances` based on the input\n', '      *      Note: token address is (0x0) when the deposit is for ETH\n', '      */\n', '    function withdraw(\n', '        address token,\n', '        uint amount\n', '    )\n', '        public\n', '    {\n', '        address payable user = msg.sender;\n', '\n', '        require(\n', '            balances[token][user] >= amount,\n', '            "INVALID_WITHDRAW"\n', '        );\n', '\n', '        balances[token][user] = balances[token][user].sub(amount);\n', '\n', '        if (token == address(0x0)) {\n', '            user.transfer(amount);\n', '        } else {\n', '            IERC20(token).safeTransfer(user, amount);\n', '        }\n', '\n', '        emit Withdraw(\n', '            token,\n', '            user,\n', '            amount,\n', '            balances[token][user]\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Transfer assets between two users inside the exchange. Updates the level 2 map `balances`\n', '      */\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[token][user] >= amount,\n', '            "INVALID_TRANSFER"\n', '        );\n', '\n', '        balances[token][user] = balances[token][user].sub(amount);\n', '\n', '        balances[token][to] = balances[token][to].add(amount);\n', '\n', '        emit Transfer(\n', '            token,\n', '            user,\n', '            to,\n', '            amount,\n', '            balances[token][user],\n', '            balances[token][to]\n', '        );\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeUpgradability is Ownable, ExchangeStorage {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev version of the exchange\n', '      */\n', '    uint8 constant public VERSION = 1;\n', '\n', '    /**\n', '      * @dev the address of the upgraded exchange contract\n', '      */\n', '    address public newExchange;\n', '\n', '    /**\n', '      * @dev flag to allow migrating to an upgraded contract\n', '      */\n', '    bool public migrationAllowed;\n', '\n', '    /**\n', '      * @dev emitted when funds are migrated\n', '      */\n', '    event FundsMigrated(address indexed user, address indexed newExchange);\n', '\n', '    /**\n', '    * @dev Owner can set the address of the new version of the exchange contract.\n', '    */\n', '    function setNewExchangeAddress(address exchange)\n', '        external\n', '        onlyOwner\n', '    {\n', '        newExchange = exchange;\n', '    }\n', '\n', '    /**\n', '    * @dev Enables/Disables the migrations. Can be called only by the owner.\n', '    */\n', '    function allowOrRestrictMigrations()\n', '        external\n', '        onlyOwner\n', '    {\n', '        migrationAllowed = !migrationAllowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Migrating assets of the caller to the new exchange contract\n', '    */\n', '    function migrateFunds(address[] calldata tokens) external {\n', '\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATIONS_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(newExchange).VERSION() > VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        migrateEthers();\n', '\n', '        migrateTokens(tokens);\n', '\n', '        emit FundsMigrated(msg.sender, newExchange);\n', '    }\n', '\n', '    /**\n', '    * @dev Helper function to migrate user&#39;s Ethers. Should be called in migrateFunds() function.\n', '    */\n', '    function migrateEthers() private {\n', '        address user = msg.sender;\n', '        uint256 etherAmount = balances[address(0x0)][user];\n', '        if (etherAmount > 0) {\n', '            balances[address(0x0)][user] = 0;\n', '            IExchangeUpgradability(newExchange).importEthers.value(etherAmount)(user);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Helper function to migrate user&#39;s tokens. Should be called in migrateFunds() function.\n', '    */\n', '    function migrateTokens(address[] memory tokens) private {\n', '        address user = msg.sender;\n', '        address exchange = newExchange;\n', '        for (uint256 index = 0; index < tokens.length; index++) {\n', '\n', '            address tokenAddress = tokens[index];\n', '\n', '            uint256 tokenAmount = balances[tokenAddress][user];\n', '\n', '            if (0 == tokenAmount) {\n', '                continue;\n', '            }\n', '\n', '            IERC20(tokenAddress).safeApprove(exchange, tokenAmount);\n', '\n', '            balances[tokenAddress][user] = 0;\n', '\n', '            IExchangeUpgradability(exchange).importTokens(tokenAddress, tokenAmount, user);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Helper function to migrate user&#39;s Ethers. Should be called only from the new exchange contract.\n', '    */\n', '    function importEthers(address user)\n', '        external\n', '        payable\n', '    {\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATION_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            user != address(0x0),\n', '            "INVALID_USER"\n', '        );\n', '\n', '        require(\n', '            msg.value > 0,\n', '            "INVALID_AMOUNT"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        balances[address(0x0)][user] = balances[address(0x0)][user].add(msg.value); // todo: constants\n', '    }\n', '    \n', '    /**\n', '    * @dev Helper function to migrate user&#39;s Tokens. Should be called only from the new exchange contract.\n', '    */\n', '    function importTokens(\n', '        address token,\n', '        uint256 amount,\n', '        address user\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATION_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            token != address(0x0),\n', '            "INVALID_TOKEN"\n', '        );\n', '\n', '        require(\n', '            user != address(0x0),\n', '            "INVALID_USER"\n', '        );\n', '\n', '        require(\n', '            amount > 0,\n', '            "INVALID_AMOUNT"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '        balances[token][user] = balances[token][user].add(amount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeOffering is ExchangeStorage, LibCrowdsale {\n', '\n', '    address constant internal BURN_ADDRESS = address(0x000000000000000000000000000000000000dEaD);\n', '    address constant internal ETH_ADDRESS = address(0x0);\n', '\n', '    using SafeERC20 for IERC20;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => Crowdsale) public crowdsales;\n', '\n', '    mapping(address => mapping(address => uint256)) public contributions;\n', '\n', '    event TokenPurchase(\n', '        address indexed token,\n', '        address indexed user,\n', '        uint256 tokenAmount,\n', '        uint256 weiAmount\n', '    );\n', '\n', '    event TokenBurned(\n', '        address indexed token,\n', '        uint256 tokenAmount\n', '    );\n', '\n', '    function registerCrowdsale(\n', '        Crowdsale memory crowdsale,\n', '        address token\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(\n', '            CrowdsaleStatus.VALID == getCrowdsaleStatus(crowdsale),\n', '            "INVALID_CROWDSALE"\n', '        );\n', '\n', '        require(\n', '            crowdsales[token].wallet == address(0),\n', '            "CROWDSALE_ALREADY_EXISTS"\n', '        );\n', '\n', '        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\n', '\n', '        IERC20(token).safeTransferFrom(crowdsale.wallet, address(this), tokenForSale);\n', '\n', '        crowdsales[token] = crowdsale;\n', '    }\n', '\n', '    function buyTokens(address token)\n', '       public\n', '       payable\n', '    {\n', '        require(msg.value != 0, "INVALID_MSG_VALUE");\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        address user = msg.sender;\n', '\n', '        Crowdsale memory crowdsale = crowdsales[token];\n', '\n', '        require(\n', '            ContributionStatus.VALID == validContribution(weiAmount, crowdsale, user, token),\n', '            "INVALID_CONTRIBUTION"\n', '        );\n', '\n', '        uint256 purchasedTokens = weiAmount.mul(crowdsale.tokenRatio);\n', '\n', '        crowdsale.leftAmount = crowdsale.leftAmount.sub(purchasedTokens);\n', '\n', '        crowdsale.weiRaised = crowdsale.weiRaised.add(weiAmount);\n', '\n', '        balances[ETH_ADDRESS][crowdsale.wallet] = balances[ETH_ADDRESS][crowdsale.wallet].add(weiAmount);\n', '\n', '        balances[token][user] = balances[token][user].add(purchasedTokens);\n', '\n', '        contributions[token][user] = contributions[token][user].add(weiAmount);\n', '\n', '        crowdsales[token] = crowdsale;\n', '\n', '        emit TokenPurchase(token, user, purchasedTokens, weiAmount);\n', '    }\n', '\n', '    function burnTokensWhenFinished(address token) public\n', '    {\n', '        require(\n', '            isFinished(crowdsales[token].endBlock),\n', '            "CROWDSALE_NOT_FINISHED_YET"\n', '        );\n', '\n', '        uint256 leftAmount = crowdsales[token].leftAmount;\n', '\n', '        crowdsales[token].leftAmount = 0;\n', '\n', '        IERC20(token).safeTransfer(BURN_ADDRESS, leftAmount);\n', '\n', '        emit TokenBurned(token, leftAmount);\n', '    }\n', '\n', '    function validContribution(\n', '        uint256 weiAmount,\n', '        Crowdsale memory crowdsale,\n', '        address user,\n', '        address token\n', '    )\n', '        public\n', '        view\n', '        returns(ContributionStatus)\n', '    {\n', '        if (!isOpened(crowdsale.startBlock, crowdsale.endBlock)) {\n', '            return ContributionStatus.CROWDSALE_NOT_OPEN;\n', '        }\n', '\n', '        if(weiAmount < crowdsale.minContribution) {\n', '            return ContributionStatus.MIN_CONTRIBUTION;\n', '        }\n', '\n', '        if (contributions[token][user].add(weiAmount) > crowdsale.maxContribution) {\n', '            return ContributionStatus.MAX_CONTRIBUTION;\n', '        }\n', '\n', '        if (crowdsale.hardCap < crowdsale.weiRaised.add(weiAmount)) {\n', '            return ContributionStatus.HARDCAP_REACHED;\n', '        }\n', '\n', '        return ContributionStatus.VALID;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeSwap is Exchange, ExchangeMovements  {\n', '\n', '    /**\n', '      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using off-chain signed messages.\n', '      * The flow of the function is Deposit -> Trade -> Withdraw to allow users to directly\n', '      * take liquidity without the need of deposit and withdraw.\n', '      */\n', '    function swapFill(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures,\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        address referral\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        uint256 balanceGivenBefore = balances[givenToken][taker];\n', '        uint256 balanceReceivedBefore = balances[receivedToken][taker];\n', '\n', '        deposit(givenToken, givenAmount, taker, referral);\n', '\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            require(orders[index].makerBuyToken == givenToken, "GIVEN_TOKEN");\n', '            require(orders[index].makerSellToken == receivedToken, "RECEIVED_TOKEN");\n', '\n', '            _trade(orders[index], signatures[index]);\n', '        }\n', '\n', '        uint256 balanceGivenAfter = balances[givenToken][taker];\n', '        uint256 balanceReceivedAfter = balances[receivedToken][taker];\n', '\n', '        uint256 balanceGivenDelta = balanceGivenAfter.sub(balanceGivenBefore);\n', '        uint256 balanceReceivedDelta = balanceReceivedAfter.sub(balanceReceivedBefore);\n', '\n', '        if(balanceGivenDelta > 0) {\n', '            withdraw(givenToken, balanceGivenDelta);\n', '        }\n', '\n', '        if(balanceReceivedDelta > 0) {\n', '            withdraw(receivedToken, balanceReceivedDelta);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract WeiDex is\n', '    Exchange,\n', '    ExchangeKyberProxy,\n', '    ExchangeBatchTrade,\n', '    ExchangeMovements,\n', '    ExchangeUpgradability,\n', '    ExchangeOffering,\n', '    ExchangeSwap\n', '{\n', '    function () external payable { }\n', '}']
['pragma solidity >=0.4.22 <0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract LibMath {\n', '    using SafeMath for uint256;\n', '\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256 partialAmount)\n', '    {\n', '        partialAmount = numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    function getFeeAmount(\n', '        uint256 numerator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256 feeAmount)\n', '    {\n', '        feeAmount = numerator.mul(target).div(1 ether); // todo: constants\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibOrder {\n', '\n', '    struct Order {\n', '        uint256 makerSellAmount;\n', '        uint256 makerBuyAmount;\n', '        uint256 takerSellAmount;\n', '        uint256 salt;\n', '        uint256 expiration;\n', '        address taker;\n', '        address maker;\n', '        address makerSellToken;\n', '        address makerBuyToken;\n', '    }\n', '\n', '    struct OrderInfo {\n', '        uint256 filledAmount;\n', '        bytes32 hash;\n', '        uint8 status;\n', '    }\n', '\n', '    struct OrderFill {\n', '        uint256 makerFillAmount;\n', '        uint256 takerFillAmount;\n', '        uint256 takerFeePaid;\n', '        uint256 exchangeFeeReceived;\n', '        uint256 referralFeeReceived;\n', '        uint256 makerFeeReceived;\n', '    }\n', '\n', '    enum OrderStatus {\n', '        INVALID_SIGNER,\n', '        INVALID_TAKER_AMOUNT,\n', '        INVALID_MAKER_AMOUNT,\n', '        FILLABLE,\n', '        EXPIRED,\n', '        FULLY_FILLED,\n', '        CANCELLED\n', '    }\n', '\n', '    function getHash(Order memory order)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                order.maker,\n', '                order.makerSellToken,\n', '                order.makerSellAmount,\n', '                order.makerBuyToken,\n', '                order.makerBuyAmount,\n', '                order.salt,\n', '                order.expiration\n', '            )\n', '        );\n', '    }\n', '\n', '    function getPrefixedHash(Order memory order)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        bytes32 orderHash = getHash(order);\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibSignatureValidator   {\n', '\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(hash, v, r, s);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract IKyberNetworkProxy {\n', '    function getExpectedRate(address src, address dest, uint srcQty) public view\n', '        returns (uint expectedRate, uint slippageRate);\n', '\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    ) public payable returns(uint256);\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibKyberData {\n', '\n', '    struct KyberData {\n', '        uint256 rate;\n', '        uint256 value;\n', '        address givenToken;\n', '        address receivedToken;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract IExchangeUpgradability {\n', '\n', '    uint8 public VERSION;\n', '\n', '    event FundsMigrated(address indexed user, address indexed newExchange);\n', '    \n', '    function allowOrRestrictMigrations() external;\n', '\n', '    function migrateFunds(address[] calldata tokens) external;\n', '\n', '    function migrateEthers() private;\n', '\n', '    function migrateTokens(address[] memory tokens) private;\n', '\n', '    function importEthers(address user) external payable;\n', '\n', '    function importTokens(address tokenAddress, uint256 tokenAmount, address user) external;\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract LibCrowdsale {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct Crowdsale {\n', '        uint256 startBlock;\n', '        uint256 endBlock;\n', '        uint256 hardCap;\n', '        uint256 leftAmount;\n', '        uint256 tokenRatio;\n', '        uint256 minContribution;\n', '        uint256 maxContribution;\n', '        uint256 weiRaised;\n', '        address wallet;\n', '    }\n', '\n', '    enum ContributionStatus {\n', '        CROWDSALE_NOT_OPEN,\n', '        MIN_CONTRIBUTION,\n', '        MAX_CONTRIBUTION,\n', '        HARDCAP_REACHED,\n', '        VALID\n', '    }\n', '\n', '    enum CrowdsaleStatus {\n', '        INVALID_START_BLOCK,\n', '        INVALID_END_BLOCK,\n', '        INVALID_TOKEN_RATIO,\n', '        INVALID_LEFT_AMOUNT,\n', '        VALID\n', '    }\n', '\n', '    function getCrowdsaleStatus(Crowdsale memory crowdsale)\n', '        public\n', '        view\n', '        returns (CrowdsaleStatus)\n', '    {\n', '\n', '        if(crowdsale.startBlock < block.number) {\n', '            return CrowdsaleStatus.INVALID_START_BLOCK;\n', '        }\n', '\n', '        if(crowdsale.endBlock < crowdsale.startBlock) {\n', '            return CrowdsaleStatus.INVALID_END_BLOCK;\n', '        }\n', '\n', '        if(crowdsale.tokenRatio == 0) {\n', '            return CrowdsaleStatus.INVALID_TOKEN_RATIO;\n', '        }\n', '\n', '        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\n', '\n', '        if(tokenForSale != crowdsale.leftAmount) {\n', '            return CrowdsaleStatus.INVALID_LEFT_AMOUNT;\n', '        }\n', '\n', '        return CrowdsaleStatus.VALID;\n', '    }\n', '\n', '    function isOpened(uint256 startBlock, uint256 endBlock)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (block.number >= startBlock && block.number <= endBlock);\n', '    }\n', '\n', '\n', '    function isFinished(uint256 endBlock)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return block.number > endBlock;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type,\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * > It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeStorage is Ownable {\n', '\n', '    /**\n', '      * @dev The minimum fee rate that the maker will receive\n', '      * Note: 20% = 20 * 10^16\n', '      */\n', '    uint256 constant internal minMakerFeeRate = 200000000000000000;\n', '\n', '    /**\n', '      * @dev The maximum fee rate that the maker will receive\n', '      * Note: 90% = 90 * 10^16\n', '      */\n', '    uint256 constant internal maxMakerFeeRate = 900000000000000000;\n', '\n', '    /**\n', '      * @dev The minimum fee rate that the taker will pay\n', '      * Note: 0.1% = 0.1 * 10^16\n', '      */\n', '    uint256 constant internal minTakerFeeRate = 1000000000000000;\n', '\n', '    /**\n', '      * @dev The maximum fee rate that the taker will pay\n', '      * Note: 1% = 1 * 10^16\n', '      */\n', '    uint256 constant internal maxTakerFeeRate = 10000000000000000;\n', '\n', '    /**\n', '      * @dev The referrer will receive 10% from each taker fee.\n', '      * Note: 10% = 10 * 10^16\n', '      */\n', '    uint256 constant internal referralFeeRate = 100000000000000000;\n', '\n', '    /**\n', '      * @dev The amount of percentage the maker will receive from each taker fee.\n', '      * Note: Initially: 50% = 50 * 10^16\n', '      */\n', '    uint256 public makerFeeRate;\n', '\n', '    /**\n', '      * @dev The amount of percentage the will pay for taking an order.\n', '      * Note: Initially: 0.2% = 0.2 * 10^16\n', '      */\n', '    uint256 public takerFeeRate;\n', '\n', '    /**\n', '      * @dev 2-level map: tokenAddress -> userAddress -> balance\n', '      */\n', '    mapping(address => mapping(address => uint256)) internal balances;\n', '\n', '    /**\n', '      * @dev map: orderHash -> filled amount\n', '      */\n', '    mapping(bytes32 => uint256) internal filled;\n', '\n', '    /**\n', '      * @dev map: orderHash -> isCancelled\n', '      */\n', '    mapping(bytes32 => bool) internal cancelled;\n', '\n', '    /**\n', '      * @dev map: user -> userReferrer\n', '      */\n', '    mapping(address => address) internal referrals;\n', '\n', '    /**\n', '      * @dev The address where all exchange fees (0,08%) are kept.\n', '      * Node: multisig wallet\n', '      */\n', '    address public feeAccount;\n', '\n', '    /**\n', '      * @return return the balance of `token` for certain `user`\n', '      */\n', '    function getBalance(\n', '        address user,\n', '        address token\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balances[token][user];\n', '    }\n', '\n', '    /**\n', '      * @return return the balance of multiple tokens for certain `user`\n', '      */\n', '    function getBalances(\n', '        address user,\n', '        address[] memory token\n', '    )\n', '        public\n', '        view\n', '        returns(uint256[] memory balanceArray)\n', '    {\n', '        balanceArray = new uint256[](token.length);\n', '\n', '        for(uint256 index = 0; index < token.length; index++) {\n', '            balanceArray[index] = balances[token[index]][user];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return the filled amount of order specified by `orderHash`\n', '      */\n', '    function getFill(\n', '        bytes32 orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return filled[orderHash];\n', '    }\n', '\n', '    /**\n', '      * @return return the filled amount of multple orders specified by `orderHash` array\n', '      */\n', '    function getFills(\n', '        bytes32[] memory orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (uint256[] memory filledArray)\n', '    {\n', '        filledArray = new uint256[](orderHash.length);\n', '\n', '        for(uint256 index = 0; index < orderHash.length; index++) {\n', '            filledArray[index] = filled[orderHash[index]];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return true(false) if order specified by `orderHash` is(not) cancelled\n', '      */\n', '    function getCancel(\n', '        bytes32 orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return cancelled[orderHash];\n', '    }\n', '\n', '    /**\n', '      * @return return array of true(false) if orders specified by `orderHash` array are(not) cancelled\n', '      */\n', '    function getCancels(\n', '        bytes32[] memory orderHash\n', '    )\n', '        public\n', '        view\n', '        returns (bool[]memory cancelledArray)\n', '    {\n', '        cancelledArray = new bool[](orderHash.length);\n', '\n', '        for(uint256 index = 0; index < orderHash.length; index++) {\n', '            cancelledArray[index] = cancelled[orderHash[index]];\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @return return the referrer address of `user`\n', '      */\n', '    function getReferral(\n', '        address user\n', '    )\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return referrals[user];\n', '    }\n', '\n', '    /**\n', '      * @return set new rate for the maker fee received\n', '      */\n', '    function setMakerFeeRate(\n', '        uint256 newMakerFeeRate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newMakerFeeRate >= minMakerFeeRate &&\n', '            newMakerFeeRate <= maxMakerFeeRate,\n', '            "INVALID_MAKER_FEE_RATE"\n', '        );\n', '        makerFeeRate = newMakerFeeRate;\n', '    }\n', '\n', '    /**\n', '      * @return set new rate for the taker fee paid\n', '      */\n', '    function setTakerFeeRate(\n', '        uint256 newTakerFeeRate\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newTakerFeeRate >= minTakerFeeRate &&\n', '            newTakerFeeRate <= maxTakerFeeRate,\n', '            "INVALID_TAKER_FEE_RATE"\n', '        );\n', '\n', '        takerFeeRate = newTakerFeeRate;\n', '    }\n', '\n', '    /**\n', '      * @return set new fee account\n', '      */\n', '    function setFeeAccount(\n', '        address newFeeAccount\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        feeAccount = newFeeAccount;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Exchange is LibMath, LibOrder, LibSignatureValidator, ExchangeStorage {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev emitted when a trade is executed\n', '      */\n', '    event Trade(\n', '        address indexed makerAddress,        // Address that created the order\n', '        address indexed takerAddress,        // Address that filled the order\n', '        bytes32 indexed orderHash,           // Hash of the order\n', '        address makerFilledAsset,            // Address of assets filled for maker\n', '        address takerFilledAsset,            // Address of assets filled for taker\n', '        uint256 makerFilledAmount,           // Amount of assets filled for maker\n', '        uint256 takerFilledAmount,           // Amount of assets filled for taker\n', '        uint256 takerFeePaid,                // Amount of fee paid by the taker\n', '        uint256 makerFeeReceived,            // Amount of fee received by the maker\n', '        uint256 referralFeeReceived          // Amount of fee received by the referrer\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a cancel order is executed\n', '      */\n', '    event Cancel(\n', '        address indexed makerBuyToken,        // Address of asset being bought.\n', '        address makerSellToken,               // Address of asset being sold.\n', '        address indexed maker,                // Address that created the order\n', '        bytes32 indexed orderHash             // Hash of the order\n', '    );\n', '\n', '    /**\n', '      * @dev Compute the status of an order.\n', '      * Should be called before a contract execution is performet in order to not waste gas.\n', '      * @return OrderStatus.FILLABLE if the order is valid for taking.\n', '      * Note: See LibOrder.sol to see all statuses\n', '      */\n', '    function getOrderInfo(\n', '        uint256 partialAmount,\n', '        Order memory order\n', '    )\n', '        public\n', '        view\n', '        returns (OrderInfo memory orderInfo)\n', '    {\n', '        // Compute the order hash\n', '        orderInfo.hash = getPrefixedHash(order);\n', '\n', '        // Fetch filled amount\n', '        orderInfo.filledAmount = filled[orderInfo.hash];\n', '\n', '        // Check taker balance\n', '        if(balances[order.makerBuyToken][order.taker] < order.takerSellAmount) {\n', '            orderInfo.status = uint8(OrderStatus.INVALID_TAKER_AMOUNT);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check maker balance\n', '        if(balances[order.makerSellToken][order.maker] < partialAmount) {\n', '            orderInfo.status = uint8(OrderStatus.INVALID_MAKER_AMOUNT);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check if order is filled\n', '        if (orderInfo.filledAmount.add(order.takerSellAmount) > order.makerBuyAmount) {\n', '            orderInfo.status = uint8(OrderStatus.FULLY_FILLED);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check for expiration\n', '        if (block.number >= order.expiration) {\n', '            orderInfo.status = uint8(OrderStatus.EXPIRED);\n', '            return orderInfo;\n', '        }\n', '\n', '        // Check if order has been cancelled\n', '        if (cancelled[orderInfo.hash]) {\n', '            orderInfo.status = uint8(OrderStatus.CANCELLED);\n', '            return orderInfo;\n', '        }\n', '\n', '        orderInfo.status = uint8(OrderStatus.FILLABLE);\n', '        return orderInfo;\n', '    }\n', '\n', '    /**\n', '      * @dev Execute a trade based on the input order and signature.\n', '      * Reverts if order is not valid\n', '      */\n', '    function trade(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        public\n', '    {\n', '        bool result = _trade(order, signature);\n', '        require(result, "INVALID_TRADE");\n', '    }\n', '\n', '    /**\n', '      * @dev Execute a trade based on the input order and signature.\n', '      * If the order is valid returns true.\n', '      */\n', '    function _trade(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        internal\n', '        returns(bool)\n', '    {\n', '        order.taker = msg.sender;\n', '\n', '        uint256 takerReceivedAmount = getPartialAmount(\n', '            order.makerSellAmount,\n', '            order.makerBuyAmount,\n', '            order.takerSellAmount\n', '        );\n', '\n', '        OrderInfo memory orderInfo = getOrderInfo(takerReceivedAmount, order);\n', '\n', '        uint8 status = assertTakeOrder(orderInfo.hash, orderInfo.status, order.maker, signature);\n', '\n', '        if(status != uint8(OrderStatus.FILLABLE)) {\n', '            return false;\n', '        }\n', '\n', '        OrderFill memory orderFill = getOrderFillResult(takerReceivedAmount, order);\n', '\n', '        executeTrade(order, orderFill);\n', '\n', '        filled[orderInfo.hash] = filled[orderInfo.hash].add(order.takerSellAmount);\n', '\n', '        emit Trade(\n', '            order.maker,\n', '            order.taker,\n', '            orderInfo.hash,\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            orderFill.makerFillAmount,\n', '            orderFill.takerFillAmount,\n', '            orderFill.takerFeePaid,\n', '            orderFill.makerFeeReceived,\n', '            orderFill.referralFeeReceived\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @dev Cancel an order if msg.sender is the order signer.\n', '      */\n', '    function cancelSingleOrder(\n', '        Order memory order,\n', '        bytes memory signature\n', '    )\n', '        public\n', '    {\n', '        bytes32 orderHash = getPrefixedHash(order);\n', '\n', '        require(\n', '            recover(orderHash, signature) == msg.sender,\n', '            "INVALID_SIGNER"\n', '        );\n', '\n', '        require(\n', '            cancelled[orderHash] == false,\n', '            "ALREADY_CANCELLED"\n', '        );\n', '\n', '        cancelled[orderHash] = true;\n', '\n', '        emit Cancel(\n', '            order.makerBuyToken,\n', '            order.makerSellToken,\n', '            msg.sender,\n', '            orderHash\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Computation of the following properties based on the order input:\n', '      * takerFillAmount -> amount of assets received by the taker\n', '      * makerFillAmount -> amount of assets received by the maker\n', '      * takerFeePaid -> amount of fee paid by the taker (0.2% of takerFillAmount)\n', '      * makerFeeReceived -> amount of fee received by the maker (50% of takerFeePaid)\n', '      * referralFeeReceived -> amount of fee received by the taker referrer (10% of takerFeePaid)\n', '      * exchangeFeeReceived -> amount of fee received by the exchange (40% of takerFeePaid)\n', '      */\n', '    function getOrderFillResult(\n', '        uint256 takerReceivedAmount,\n', '        Order memory order\n', '    )\n', '        internal\n', '        view\n', '        returns (OrderFill memory orderFill)\n', '    {\n', '        orderFill.takerFillAmount = takerReceivedAmount;\n', '\n', '        orderFill.makerFillAmount = order.takerSellAmount;\n', '\n', '        // 0.2% == 0.2*10^16\n', '        orderFill.takerFeePaid = getFeeAmount(\n', '            takerReceivedAmount,\n', '            takerFeeRate\n', '        );\n', '\n', '        // 50% of taker fee == 50*10^16\n', '        orderFill.makerFeeReceived = getFeeAmount(\n', '            orderFill.takerFeePaid,\n', '            makerFeeRate\n', '        );\n', '\n', '        // 10% of taker fee == 10*10^16\n', '        orderFill.referralFeeReceived = getFeeAmount(\n', '            orderFill.takerFeePaid,\n', '            referralFeeRate\n', '        );\n', '\n', '        // exchangeFee = (takerFeePaid - makerFeeReceived - referralFeeReceived)\n', '        orderFill.exchangeFeeReceived = orderFill.takerFeePaid.sub(\n', '            orderFill.makerFeeReceived).sub(\n', '                orderFill.referralFeeReceived);\n', '\n', '    }\n', '\n', '    /**\n', '      * @dev Throws when the order status is invalid or the signer is not valid.\n', '      */\n', '    function assertTakeOrder(\n', '        bytes32 orderHash,\n', '        uint8 status,\n', '        address signer,\n', '        bytes memory signature\n', '    )\n', '        internal\n', '        pure\n', '        returns(uint8)\n', '    {\n', '        uint8 result = uint8(OrderStatus.FILLABLE);\n', '\n', '        if(recover(orderHash, signature) != signer) {\n', '            result = uint8(OrderStatus.INVALID_SIGNER);\n', '        }\n', '\n', '        if(status != uint8(OrderStatus.FILLABLE)) {\n', '            result = status;\n', '        }\n', '\n', '        return status;\n', '    }\n', '\n', '    /**\n', '      * @dev Updates the contract state i.e. user balances\n', '      */\n', '    function executeTrade(\n', '        Order memory order,\n', '        OrderFill memory orderFill\n', '    )\n', '        private\n', '    {\n', '        uint256 makerGiveAmount = orderFill.takerFillAmount.sub(orderFill.makerFeeReceived);\n', '        uint256 takerFillAmount = orderFill.takerFillAmount.sub(orderFill.takerFeePaid);\n', '\n', '        address referrer = referrals[order.taker];\n', '        address feeAddress = feeAccount;\n', '\n', '        balances[order.makerSellToken][referrer] = balances[order.makerSellToken][referrer].add(orderFill.referralFeeReceived);\n', '        balances[order.makerSellToken][feeAddress] = balances[order.makerSellToken][feeAddress].add(orderFill.exchangeFeeReceived);\n', '\n', '        balances[order.makerBuyToken][order.taker] = balances[order.makerBuyToken][order.taker].sub(orderFill.makerFillAmount);\n', '        balances[order.makerBuyToken][order.maker] = balances[order.makerBuyToken][order.maker].add(orderFill.makerFillAmount);\n', '\n', '        balances[order.makerSellToken][order.taker] = balances[order.makerSellToken][order.taker].add(takerFillAmount);\n', '        balances[order.makerSellToken][order.maker] = balances[order.makerSellToken][order.maker].sub(makerGiveAmount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeKyberProxy is Exchange, LibKyberData {\n', '    using SafeERC20 for IERC20;\n', '\n', '    /**\n', '      * @dev The precision used for calculating the amounts - 10*18\n', '      */\n', '    uint256 constant internal PRECISION = 1000000000000000000;\n', '\n', '    /**\n', '      * @dev Max decimals allowed when calculating amounts.\n', '      */\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '\n', '    /**\n', '      * @dev Decimals of Ether.\n', '      */\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '\n', '    /**\n', '      * @dev The address that represents ETH in Kyber Network Contracts.\n', '      */\n', '    address constant internal KYBER_ETH_TOKEN_ADDRESS =\n', '        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    uint256 constant internal MAX_DEST_AMOUNT = 2**256 - 1;\n', '\n', '    /**\n', '      * @dev KyberNetworkProxy contract address\n', '      */\n', '    IKyberNetworkProxy constant internal kyberNetworkContract =\n', '        IKyberNetworkProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\n', '\n', '    /**\n', '      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using KyberNetwork reserves.\n', '      */\n', '    function kyberSwap(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        bytes32 hash\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        KyberData memory kyberData = getSwapInfo(\n', '            givenAmount,\n', '            givenToken,\n', '            receivedToken,\n', '            taker\n', '        );\n', '\n', '        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\n', '            kyberData.givenToken,\n', '            givenAmount,\n', '            kyberData.receivedToken,\n', '            taker,\n', '            MAX_DEST_AMOUNT,\n', '            kyberData.rate,\n', '            feeAccount\n', '        );\n', '\n', '        emit Trade(\n', '            address(kyberNetworkContract),\n', '            taker,\n', '            hash,\n', '            givenToken,\n', '            receivedToken,\n', '            givenAmount,\n', '            convertedAmount,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Exchange ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using the internal\n', "      * balance mapping that keeps track of user's balances. It requires user to first invoke deposit function.\n", '      * The function relies on KyberNetworkProxy contract.\n', '      */\n', '    function kyberTrade(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        bytes32 hash\n', '    )\n', '        public\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        KyberData memory kyberData = getTradeInfo(\n', '            givenAmount,\n', '            givenToken,\n', '            receivedToken\n', '        );\n', '\n', '        balances[givenToken][taker] = balances[givenToken][taker].sub(givenAmount);\n', '\n', '        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\n', '            kyberData.givenToken,\n', '            givenAmount,\n', '            kyberData.receivedToken,\n', '            address(this),\n', '            MAX_DEST_AMOUNT,\n', '            kyberData.rate,\n', '            feeAccount\n', '        );\n', '\n', '        balances[receivedToken][taker] = balances[receivedToken][taker].add(convertedAmount);\n', '\n', '        emit Trade(\n', '            address(kyberNetworkContract),\n', '            taker,\n', '            hash,\n', '            givenToken,\n', '            receivedToken,\n', '            givenAmount,\n', '            convertedAmount,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Helper function to determine what is being swapped.\n', '      */\n', '    function getSwapInfo(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        address taker\n', '    )\n', '        private\n', '        returns(KyberData memory)\n', '    {\n', '        KyberData memory kyberData;\n', '        uint256 givenTokenDecimals;\n', '        uint256 receivedTokenDecimals;\n', '\n', '        if(givenToken == address(0x0)) {\n', '            require(msg.value == givenAmount, "INVALID_ETH_VALUE");\n', '\n', '            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = givenAmount;\n', '\n', '            givenTokenDecimals = ETH_DECIMALS;\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '        } else if(receivedToken == address(0x0)) {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = ETH_DECIMALS;\n', '\n', '            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        } else {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '\n', '            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        }\n', '\n', '        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\n', '            kyberData.givenToken,\n', '            kyberData.receivedToken,\n', '            givenAmount\n', '        );\n', '\n', '        return kyberData;\n', '    }\n', '\n', '    /**\n', '      * @dev Helper function to determines what is being\n', '        swapped using the internal balance mapping.\n', '      */\n', '    function getTradeInfo(\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken\n', '    )\n', '        private\n', '        returns(KyberData memory)\n', '    {\n', '        KyberData memory kyberData;\n', '        uint256 givenTokenDecimals;\n', '        uint256 receivedTokenDecimals;\n', '\n', '        if(givenToken == address(0x0)) {\n', '            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = givenAmount;\n', '\n', '            givenTokenDecimals = ETH_DECIMALS;\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '        } else if(receivedToken == address(0x0)) {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = ETH_DECIMALS;\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        } else {\n', '            kyberData.givenToken = givenToken;\n', '            kyberData.receivedToken = receivedToken;\n', '            kyberData.value = 0;\n', '\n', '            givenTokenDecimals = IERC20(givenToken).decimals();\n', '            receivedTokenDecimals = IERC20(receivedToken).decimals();\n', '            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\n', '        }\n', '\n', '        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\n', '            kyberData.givenToken,\n', '            kyberData.receivedToken,\n', '            givenAmount\n', '        );\n', '\n', '        return kyberData;\n', '    }\n', '\n', '    function getExpectedRateBatch(\n', '        address[] memory givenTokens,\n', '        address[] memory receivedTokens,\n', '        uint256[] memory givenAmounts\n', '    )\n', '        public\n', '        view\n', '        returns(uint256[] memory, uint256[] memory)\n', '    {\n', '        uint256 size = givenTokens.length;\n', '        uint256[] memory expectedRates = new uint256[](size);\n', '        uint256[] memory slippageRates = new uint256[](size);\n', '\n', '        for(uint256 index = 0; index < size; index++) {\n', '            (expectedRates[index], slippageRates[index]) = kyberNetworkContract.getExpectedRate(\n', '                givenTokens[index],\n', '                receivedTokens[index],\n', '                givenAmounts[index]\n', '            );\n', '        }\n', '\n', '       return (expectedRates, slippageRates);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeBatchTrade is Exchange {\n', '\n', '    /**\n', '      * @dev Cancel an array of orders if msg.sender is the order signer.\n', '      */\n', '    function cancelMultipleOrders(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            cancelSingleOrder(\n', '                orders[index],\n', '                signatures[index]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @dev Execute multiple trades based on the input orders and signatures.\n', '      * Note: reverts of one or more trades fail.\n', '      */\n', '    function takeAllOrRevert(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            bool result = _trade(orders[index], signatures[index]);\n', '            require(result, "INVALID_TAKEALL");\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @dev Execute multiple trades based on the input orders and signatures.\n', '      * Note: does not revert if one or more trades fail.\n', '      */\n', '    function takeAllPossible(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '    {\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            _trade(orders[index], signatures[index]);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeMovements is ExchangeStorage {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev emitted when a deposit is received\n', '      */\n', '    event Deposit(\n', '        address indexed token,\n', '        address indexed user,\n', '        address indexed referral,\n', '        address beneficiary,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a withdraw is received\n', '      */\n', '    event Withdraw(\n', '        address indexed token,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 balance\n', '    );\n', '\n', '    /**\n', '      * @dev emitted when a transfer is received\n', '      */\n', '    event Transfer(\n', '        address indexed token,\n', '        address indexed user,\n', '        address indexed beneficiary,\n', '        uint256 amount,\n', '        uint256 userBalance,\n', '        uint256 beneficiaryBalance\n', '    );\n', '\n', '    /**\n', '      * @dev Updates the level 2 map `balances` based on the input\n', '      *      Note: token address is (0x0) when the deposit is for ETH\n', '      */\n', '    function deposit(\n', '        address token,\n', '        uint256 amount,\n', '        address beneficiary,\n', '        address referral\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        uint256 value = amount;\n', '        address user = msg.sender;\n', '\n', '        if(token == address(0x0)) {\n', '            value = msg.value;\n', '        } else {\n', '            IERC20(token).safeTransferFrom(user, address(this), value);\n', '        }\n', '\n', '        balances[token][beneficiary] = balances[token][beneficiary].add(value);\n', '\n', '        if(referrals[user] == address(0x0)) {\n', '            referrals[user] = referral;\n', '        }\n', '\n', '        emit Deposit(\n', '            token,\n', '            user,\n', '            referrals[user],\n', '            beneficiary,\n', '            value,\n', '            balances[token][beneficiary]\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Updates the level 2 map `balances` based on the input\n', '      *      Note: token address is (0x0) when the deposit is for ETH\n', '      */\n', '    function withdraw(\n', '        address token,\n', '        uint amount\n', '    )\n', '        public\n', '    {\n', '        address payable user = msg.sender;\n', '\n', '        require(\n', '            balances[token][user] >= amount,\n', '            "INVALID_WITHDRAW"\n', '        );\n', '\n', '        balances[token][user] = balances[token][user].sub(amount);\n', '\n', '        if (token == address(0x0)) {\n', '            user.transfer(amount);\n', '        } else {\n', '            IERC20(token).safeTransfer(user, amount);\n', '        }\n', '\n', '        emit Withdraw(\n', '            token,\n', '            user,\n', '            amount,\n', '            balances[token][user]\n', '        );\n', '    }\n', '\n', '    /**\n', '      * @dev Transfer assets between two users inside the exchange. Updates the level 2 map `balances`\n', '      */\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        address user = msg.sender;\n', '\n', '        require(\n', '            balances[token][user] >= amount,\n', '            "INVALID_TRANSFER"\n', '        );\n', '\n', '        balances[token][user] = balances[token][user].sub(amount);\n', '\n', '        balances[token][to] = balances[token][to].add(amount);\n', '\n', '        emit Transfer(\n', '            token,\n', '            user,\n', '            to,\n', '            amount,\n', '            balances[token][user],\n', '            balances[token][to]\n', '        );\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeUpgradability is Ownable, ExchangeStorage {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '      * @dev version of the exchange\n', '      */\n', '    uint8 constant public VERSION = 1;\n', '\n', '    /**\n', '      * @dev the address of the upgraded exchange contract\n', '      */\n', '    address public newExchange;\n', '\n', '    /**\n', '      * @dev flag to allow migrating to an upgraded contract\n', '      */\n', '    bool public migrationAllowed;\n', '\n', '    /**\n', '      * @dev emitted when funds are migrated\n', '      */\n', '    event FundsMigrated(address indexed user, address indexed newExchange);\n', '\n', '    /**\n', '    * @dev Owner can set the address of the new version of the exchange contract.\n', '    */\n', '    function setNewExchangeAddress(address exchange)\n', '        external\n', '        onlyOwner\n', '    {\n', '        newExchange = exchange;\n', '    }\n', '\n', '    /**\n', '    * @dev Enables/Disables the migrations. Can be called only by the owner.\n', '    */\n', '    function allowOrRestrictMigrations()\n', '        external\n', '        onlyOwner\n', '    {\n', '        migrationAllowed = !migrationAllowed;\n', '    }\n', '\n', '    /**\n', '    * @dev Migrating assets of the caller to the new exchange contract\n', '    */\n', '    function migrateFunds(address[] calldata tokens) external {\n', '\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATIONS_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(newExchange).VERSION() > VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        migrateEthers();\n', '\n', '        migrateTokens(tokens);\n', '\n', '        emit FundsMigrated(msg.sender, newExchange);\n', '    }\n', '\n', '    /**\n', "    * @dev Helper function to migrate user's Ethers. Should be called in migrateFunds() function.\n", '    */\n', '    function migrateEthers() private {\n', '        address user = msg.sender;\n', '        uint256 etherAmount = balances[address(0x0)][user];\n', '        if (etherAmount > 0) {\n', '            balances[address(0x0)][user] = 0;\n', '            IExchangeUpgradability(newExchange).importEthers.value(etherAmount)(user);\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @dev Helper function to migrate user's tokens. Should be called in migrateFunds() function.\n", '    */\n', '    function migrateTokens(address[] memory tokens) private {\n', '        address user = msg.sender;\n', '        address exchange = newExchange;\n', '        for (uint256 index = 0; index < tokens.length; index++) {\n', '\n', '            address tokenAddress = tokens[index];\n', '\n', '            uint256 tokenAmount = balances[tokenAddress][user];\n', '\n', '            if (0 == tokenAmount) {\n', '                continue;\n', '            }\n', '\n', '            IERC20(tokenAddress).safeApprove(exchange, tokenAmount);\n', '\n', '            balances[tokenAddress][user] = 0;\n', '\n', '            IExchangeUpgradability(exchange).importTokens(tokenAddress, tokenAmount, user);\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @dev Helper function to migrate user's Ethers. Should be called only from the new exchange contract.\n", '    */\n', '    function importEthers(address user)\n', '        external\n', '        payable\n', '    {\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATION_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            user != address(0x0),\n', '            "INVALID_USER"\n', '        );\n', '\n', '        require(\n', '            msg.value > 0,\n', '            "INVALID_AMOUNT"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        balances[address(0x0)][user] = balances[address(0x0)][user].add(msg.value); // todo: constants\n', '    }\n', '    \n', '    /**\n', "    * @dev Helper function to migrate user's Tokens. Should be called only from the new exchange contract.\n", '    */\n', '    function importTokens(\n', '        address token,\n', '        uint256 amount,\n', '        address user\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            false != migrationAllowed,\n', '            "MIGRATION_DISALLOWED"\n', '        );\n', '\n', '        require(\n', '            token != address(0x0),\n', '            "INVALID_TOKEN"\n', '        );\n', '\n', '        require(\n', '            user != address(0x0),\n', '            "INVALID_USER"\n', '        );\n', '\n', '        require(\n', '            amount > 0,\n', '            "INVALID_AMOUNT"\n', '        );\n', '\n', '        require(\n', '            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\n', '            "INVALID_VERSION"\n', '        );\n', '\n', '        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '        balances[token][user] = balances[token][user].add(amount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeOffering is ExchangeStorage, LibCrowdsale {\n', '\n', '    address constant internal BURN_ADDRESS = address(0x000000000000000000000000000000000000dEaD);\n', '    address constant internal ETH_ADDRESS = address(0x0);\n', '\n', '    using SafeERC20 for IERC20;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => Crowdsale) public crowdsales;\n', '\n', '    mapping(address => mapping(address => uint256)) public contributions;\n', '\n', '    event TokenPurchase(\n', '        address indexed token,\n', '        address indexed user,\n', '        uint256 tokenAmount,\n', '        uint256 weiAmount\n', '    );\n', '\n', '    event TokenBurned(\n', '        address indexed token,\n', '        uint256 tokenAmount\n', '    );\n', '\n', '    function registerCrowdsale(\n', '        Crowdsale memory crowdsale,\n', '        address token\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(\n', '            CrowdsaleStatus.VALID == getCrowdsaleStatus(crowdsale),\n', '            "INVALID_CROWDSALE"\n', '        );\n', '\n', '        require(\n', '            crowdsales[token].wallet == address(0),\n', '            "CROWDSALE_ALREADY_EXISTS"\n', '        );\n', '\n', '        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\n', '\n', '        IERC20(token).safeTransferFrom(crowdsale.wallet, address(this), tokenForSale);\n', '\n', '        crowdsales[token] = crowdsale;\n', '    }\n', '\n', '    function buyTokens(address token)\n', '       public\n', '       payable\n', '    {\n', '        require(msg.value != 0, "INVALID_MSG_VALUE");\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        address user = msg.sender;\n', '\n', '        Crowdsale memory crowdsale = crowdsales[token];\n', '\n', '        require(\n', '            ContributionStatus.VALID == validContribution(weiAmount, crowdsale, user, token),\n', '            "INVALID_CONTRIBUTION"\n', '        );\n', '\n', '        uint256 purchasedTokens = weiAmount.mul(crowdsale.tokenRatio);\n', '\n', '        crowdsale.leftAmount = crowdsale.leftAmount.sub(purchasedTokens);\n', '\n', '        crowdsale.weiRaised = crowdsale.weiRaised.add(weiAmount);\n', '\n', '        balances[ETH_ADDRESS][crowdsale.wallet] = balances[ETH_ADDRESS][crowdsale.wallet].add(weiAmount);\n', '\n', '        balances[token][user] = balances[token][user].add(purchasedTokens);\n', '\n', '        contributions[token][user] = contributions[token][user].add(weiAmount);\n', '\n', '        crowdsales[token] = crowdsale;\n', '\n', '        emit TokenPurchase(token, user, purchasedTokens, weiAmount);\n', '    }\n', '\n', '    function burnTokensWhenFinished(address token) public\n', '    {\n', '        require(\n', '            isFinished(crowdsales[token].endBlock),\n', '            "CROWDSALE_NOT_FINISHED_YET"\n', '        );\n', '\n', '        uint256 leftAmount = crowdsales[token].leftAmount;\n', '\n', '        crowdsales[token].leftAmount = 0;\n', '\n', '        IERC20(token).safeTransfer(BURN_ADDRESS, leftAmount);\n', '\n', '        emit TokenBurned(token, leftAmount);\n', '    }\n', '\n', '    function validContribution(\n', '        uint256 weiAmount,\n', '        Crowdsale memory crowdsale,\n', '        address user,\n', '        address token\n', '    )\n', '        public\n', '        view\n', '        returns(ContributionStatus)\n', '    {\n', '        if (!isOpened(crowdsale.startBlock, crowdsale.endBlock)) {\n', '            return ContributionStatus.CROWDSALE_NOT_OPEN;\n', '        }\n', '\n', '        if(weiAmount < crowdsale.minContribution) {\n', '            return ContributionStatus.MIN_CONTRIBUTION;\n', '        }\n', '\n', '        if (contributions[token][user].add(weiAmount) > crowdsale.maxContribution) {\n', '            return ContributionStatus.MAX_CONTRIBUTION;\n', '        }\n', '\n', '        if (crowdsale.hardCap < crowdsale.weiRaised.add(weiAmount)) {\n', '            return ContributionStatus.HARDCAP_REACHED;\n', '        }\n', '\n', '        return ContributionStatus.VALID;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract ExchangeSwap is Exchange, ExchangeMovements  {\n', '\n', '    /**\n', '      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using off-chain signed messages.\n', '      * The flow of the function is Deposit -> Trade -> Withdraw to allow users to directly\n', '      * take liquidity without the need of deposit and withdraw.\n', '      */\n', '    function swapFill(\n', '        Order[] memory orders,\n', '        bytes[] memory signatures,\n', '        uint256 givenAmount,\n', '        address givenToken,\n', '        address receivedToken,\n', '        address referral\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        address taker = msg.sender;\n', '\n', '        uint256 balanceGivenBefore = balances[givenToken][taker];\n', '        uint256 balanceReceivedBefore = balances[receivedToken][taker];\n', '\n', '        deposit(givenToken, givenAmount, taker, referral);\n', '\n', '        for (uint256 index = 0; index < orders.length; index++) {\n', '            require(orders[index].makerBuyToken == givenToken, "GIVEN_TOKEN");\n', '            require(orders[index].makerSellToken == receivedToken, "RECEIVED_TOKEN");\n', '\n', '            _trade(orders[index], signatures[index]);\n', '        }\n', '\n', '        uint256 balanceGivenAfter = balances[givenToken][taker];\n', '        uint256 balanceReceivedAfter = balances[receivedToken][taker];\n', '\n', '        uint256 balanceGivenDelta = balanceGivenAfter.sub(balanceGivenBefore);\n', '        uint256 balanceReceivedDelta = balanceReceivedAfter.sub(balanceReceivedBefore);\n', '\n', '        if(balanceGivenDelta > 0) {\n', '            withdraw(givenToken, balanceGivenDelta);\n', '        }\n', '\n', '        if(balanceReceivedDelta > 0) {\n', '            withdraw(receivedToken, balanceReceivedDelta);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract WeiDex is\n', '    Exchange,\n', '    ExchangeKyberProxy,\n', '    ExchangeBatchTrade,\n', '    ExchangeMovements,\n', '    ExchangeUpgradability,\n', '    ExchangeOffering,\n', '    ExchangeSwap\n', '{\n', '    function () external payable { }\n', '}']
