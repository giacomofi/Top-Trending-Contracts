['// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\LAND\\ILANDRegistry.sol\n', '\n', '// solium-disable linebreak-style\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface ILANDRegistry {\n', '\n', '  // LAND can be assigned by the owner\n', '  function assignNewParcel(int x, int y, address beneficiary) external;\n', '  function assignMultipleParcels(int[] calldata x, int[] calldata y, address beneficiary) external;\n', '\n', '  // After one year, LAND can be claimed from an inactive public key\n', '  function ping() external;\n', '\n', '  // LAND-centric getters\n', '  function encodeTokenId(int x, int y) external pure returns (uint256);\n', '  function decodeTokenId(uint value) external pure returns (int, int);\n', '  function exists(int x, int y) external view returns (bool);\n', '  function ownerOfLand(int x, int y) external view returns (address);\n', '  function ownerOfLandMany(int[] calldata x, int[] calldata y) external view returns (address[] memory);\n', '  function landOf(address owner) external view returns (int[] memory, int[] memory);\n', '  function landData(int x, int y) external view returns (string memory);\n', '\n', '  // Transfer LAND\n', '  function transferLand(int x, int y, address to) external;\n', '  function transferManyLand(int[] calldata x, int[] calldata y, address to) external;\n', '\n', '  // Update LAND\n', '  function updateLandData(int x, int y, string calldata data) external;\n', '  function updateManyLandData(int[] calldata x, int[] calldata y, string calldata data) external;\n', '\n', '  //operators\n', '  function setUpdateOperator(uint256 assetId, address operator) external;\n', '\n', '  // Events\n', '\n', '  event Update(\n', '    uint256 indexed assetId,\n', '    address indexed holder,\n', '    address indexed operator,\n', '    string data\n', '  );\n', '\n', '  event UpdateOperator(\n', '    uint256 indexed assetId,\n', '    address indexed operator\n', '  );\n', '\n', '  event DeployAuthorized(\n', '    address indexed _caller,\n', '    address indexed _deployer\n', '  );\n', '\n', '  event DeployForbidden(\n', '    address indexed _caller,\n', '    address indexed _deployer\n', '  );\n', '}\n', '\n', '// File: contracts\\AetheriaFirstStageProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', 'contract AetheriaFirstStageProxy is Ownable {\n', '    ILANDRegistry private landContract;\n', '\taddress private delegatedSigner;\n', '\tmapping(uint256 => uint) private replayProtection;\n', '\tuint public currentNonce;\n', '\n', '\tconstructor (address landContractAddress) public {\n', '        landContract = ILANDRegistry(landContractAddress);\n', '\t\tdelegatedSigner = owner();\n', '\t\tcurrentNonce = 1;\n', '    }\n', '\n', '\tfunction setDelegatedSigner(address newDelegate) external onlyOwner {\n', '\t\tdelegatedSigner = newDelegate;\n', '\t\temit DelegateChanged(delegatedSigner);\n', '\t}\n', '\n', '\tfunction getDelegatedSigner() public view returns (address ){\n', '\t\treturn delegatedSigner;\n', '\t}\n', '\n', '\tfunction getMessageHash(address userAddress, uint256[] memory plotIds, uint nonce) public pure returns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encode(userAddress, plotIds, nonce));\n', '\t}\n', '\n', '\tfunction buildPrefixedHash(bytes32 msgHash) public pure returns (bytes32)\n', '\t{\n', '\t\tbytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '\t\treturn keccak256(abi.encodePacked(prefix, msgHash));\n', '\t}\n', '\n', '\tfunction verifySender(bytes32 msgHash, uint8 _v, bytes32 _r, bytes32 _s) private view returns (bool)\n', '\t{\n', '\t\tbytes32 prefixedHash = buildPrefixedHash(msgHash);\n', '\t\treturn ecrecover(prefixedHash, _v, _r, _s) == delegatedSigner;\n', '\t}\n', '\n', '\tfunction updatePlot(address userAddress, uint256[] calldata plotIds, uint nonce, uint8 _v, bytes32 _r, bytes32 _s) external {\n', '\t\tbytes32 msgHash = getMessageHash(userAddress, plotIds, nonce);\n', '\t\trequire(verifySender(msgHash, _v, _r, _s), "Invalid Sig");\n', '        for (uint i = 0; i<plotIds.length; i++) {\n', '\t\t\tif(replayProtection[plotIds[i]] > nonce) {\n', '\t\t\t\tlandContract.setUpdateOperator(plotIds[i], userAddress);\n', '\t\t\t\treplayProtection[plotIds[i]]++;\n', '\t\t\t}\n', '        }\n', '        if (currentNonce <= nonce)\n', '        {\n', '            currentNonce = nonce+1;\n', '        }\n', '\t\temit PlotOwnerUpdate(\n', '\t\t\tuserAddress,\n', '\t\t\tplotIds\n', '\t\t);\n', '\t}\n', '\n', '\tevent DelegateChanged(\n', '\t\taddress newDelegatedAddress\n', '\t);\n', '\n', '\tevent PlotOwnerUpdate(\n', '\t\taddress newOperator,\n', '\t\tuint256[] plotIds\n', '\t);\n', '}']