['pragma solidity ^0.4.24;\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\math\\Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\ownership\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\math\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\payment\\Escrow.sol\n', '\n', '/**\n', ' * @title Escrow\n', ' * @dev Base escrow contract, holds funds destinated to a payee until they\n', ' * withdraw them. The contract that uses the escrow as its payment method\n', " * should be its owner, and provide public methods redirecting to the escrow's\n", ' * deposit and withdraw.\n', ' */\n', 'contract Escrow is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  event Deposited(address indexed payee, uint256 weiAmount);\n', '  event Withdrawn(address indexed payee, uint256 weiAmount);\n', '\n', '  mapping(address => uint256) private deposits;\n', '\n', '  function depositsOf(address _payee) public view returns (uint256) {\n', '    return deposits[_payee];\n', '  }\n', '\n', '  /**\n', '  * @dev Stores the sent amount as credit to be withdrawn.\n', '  * @param _payee The destination address of the funds.\n', '  */\n', '  function deposit(address _payee) public onlyOwner payable {\n', '    uint256 amount = msg.value;\n', '    deposits[_payee] = deposits[_payee].add(amount);\n', '\n', '    emit Deposited(_payee, amount);\n', '  }\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance for a payee.\n', '  * @param _payee The address whose funds will be withdrawn and transferred to.\n', '  */\n', '  function withdraw(address _payee) public onlyOwner {\n', '    uint256 payment = deposits[_payee];\n', '    assert(address(this).balance >= payment);\n', '\n', '    deposits[_payee] = 0;\n', '\n', '    _payee.transfer(payment);\n', '\n', '    emit Withdrawn(_payee, payment);\n', '  }\n', '}\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\payment\\ConditionalEscrow.sol\n', '\n', '/**\n', ' * @title ConditionalEscrow\n', ' * @dev Base abstract escrow to only allow withdrawal if a condition is met.\n', ' */\n', 'contract ConditionalEscrow is Escrow {\n', '  /**\n', '  * @dev Returns whether an address is allowed to withdraw their funds. To be\n', '  * implemented by derived contracts.\n', '  * @param _payee The destination address of the funds.\n', '  */\n', '  function withdrawalAllowed(address _payee) public view returns (bool);\n', '\n', '  function withdraw(address _payee) public {\n', '    require(withdrawalAllowed(_payee));\n', '    super.withdraw(_payee);\n', '  }\n', '}\n', '\n', '// File: node_modules\\zeppelin-solidity\\contracts\\payment\\RefundEscrow.sol\n', '\n', '/**\n', ' * @title RefundEscrow\n', ' * @dev Escrow that holds funds for a beneficiary, deposited from multiple parties.\n', ' * The contract owner may close the deposit period, and allow for either withdrawal\n', ' * by the beneficiary, or refunds to the depositors.\n', ' */\n', 'contract RefundEscrow is Ownable, ConditionalEscrow {\n', '  enum State { Active, Refunding, Closed }\n', '\n', '  event Closed();\n', '  event RefundsEnabled();\n', '\n', '  State public state;\n', '  address public beneficiary;\n', '\n', '  /**\n', '   * @dev Constructor.\n', '   * @param _beneficiary The beneficiary of the deposits.\n', '   */\n', '  constructor(address _beneficiary) public {\n', '    require(_beneficiary != address(0));\n', '    beneficiary = _beneficiary;\n', '    state = State.Active;\n', '  }\n', '\n', '  /**\n', '   * @dev Stores funds that may later be refunded.\n', '   * @param _refundee The address funds will be sent to if a refund occurs.\n', '   */\n', '  function deposit(address _refundee) public payable {\n', '    require(state == State.Active);\n', '    super.deposit(_refundee);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows for the beneficiary to withdraw their funds, rejecting\n', '   * further deposits.\n', '   */\n', '  function close() public onlyOwner {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '  }\n', '\n', '  /**\n', '   * @dev Allows for refunds to take place, rejecting further deposits.\n', '   */\n', '  function enableRefunds() public onlyOwner {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '\n', '  /**\n', "   * @dev Withdraws the beneficiary's funds.\n", '   */\n', '  function beneficiaryWithdraw() public {\n', '    require(state == State.Closed);\n', '    beneficiary.transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether refundees can withdraw their deposits (be refunded).\n', '   */\n', '  function withdrawalAllowed(address _payee) public view returns (bool) {\n', '    return state == State.Refunding;\n', '  }\n', '}\n', '\n', '// File: contracts\\ClinicAllRefundEscrow.sol\n', '\n', '/**\n', ' * @title ClinicAllRefundEscrow\n', ' * @dev Escrow that holds funds for a beneficiary, deposited from multiple parties.\n', ' * The contract owner may close the deposit period, and allow for either withdrawal\n', ' * by the beneficiary, or refunds to the depositors.\n', ' */\n', 'contract ClinicAllRefundEscrow is RefundEscrow {\n', '  using Math for uint256;\n', '\n', '  struct RefundeeRecord {\n', '    bool isRefunded;\n', '    uint256 index;\n', '  }\n', '\n', '  mapping(address => RefundeeRecord) public refundees;\n', '  address[] internal refundeesList;\n', '\n', '  event Deposited(address indexed payee, uint256 weiAmount);\n', '  event Withdrawn(address indexed payee, uint256 weiAmount);\n', '\n', '  mapping(address => uint256) private deposits;\n', '  mapping(address => uint256) private beneficiaryDeposits;\n', '\n', '  // Amount of wei deposited by beneficiary\n', '  uint256 public beneficiaryDepositedAmount;\n', '\n', '  // Amount of wei deposited by investors to CrowdSale\n', '  uint256 public investorsDepositedToCrowdSaleAmount;\n', '\n', '  /**\n', '   * @dev Constructor.\n', '   * @param _beneficiary The beneficiary of the deposits.\n', '   */\n', '  constructor(address _beneficiary)\n', '  RefundEscrow(_beneficiary)\n', '  public {\n', '  }\n', '\n', '  function depositsOf(address _payee) public view returns (uint256) {\n', '    return deposits[_payee];\n', '  }\n', '\n', '  function beneficiaryDepositsOf(address _payee) public view returns (uint256) {\n', '    return beneficiaryDeposits[_payee];\n', '  }\n', '\n', '\n', '\n', '  /**\n', '   * @dev Stores funds that may later be refunded.\n', '   * @param _refundee The address funds will be sent to if a refund occurs.\n', '   */\n', '  function deposit(address _refundee) public payable {\n', '    uint256 amount = msg.value;\n', '    beneficiaryDeposits[_refundee] = beneficiaryDeposits[_refundee].add(amount);\n', '    beneficiaryDepositedAmount = beneficiaryDepositedAmount.add(amount);\n', '  }\n', '\n', '  /**\n', ' * @dev Stores funds that may later be refunded.\n', ' * @param _refundee The address funds will be sent to if a refund occurs.\n', ' * @param _value The amount of funds will be sent to if a refund occurs.\n', ' */\n', '  function depositFunds(address _refundee, uint256 _value) public onlyOwner {\n', '    require(state == State.Active, "Funds deposition is possible only in the Active state.");\n', '\n', '    uint256 amount = _value;\n', '    deposits[_refundee] = deposits[_refundee].add(amount);\n', '    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.add(amount);\n', '\n', '    emit Deposited(_refundee, amount);\n', '\n', '    RefundeeRecord storage _data = refundees[_refundee];\n', '    _data.isRefunded = false;\n', '\n', '    if (_data.index == uint256(0)) {\n', '      refundeesList.push(_refundee);\n', '      _data.index = refundeesList.length.sub(1);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Allows for the beneficiary to withdraw their funds, rejecting\n', '  * further deposits.\n', '  */\n', '  function close() public onlyOwner {\n', '    super.close();\n', '  }\n', '\n', '  function withdraw(address _payee) public onlyOwner {\n', '    require(state == State.Refunding, "Funds withdrawal is possible only in the Refunding state.");\n', '    require(depositsOf(_payee) > 0, "An investor should have non-negative deposit for withdrawal.");\n', '\n', '    RefundeeRecord storage _data = refundees[_payee];\n', '    require(_data.isRefunded == false, "An investor should not be refunded.");\n', '\n', '    uint256 payment = deposits[_payee];\n', '    assert(address(this).balance >= payment);\n', '\n', '    deposits[_payee] = 0;\n', '\n', '    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.sub(payment);\n', '\n', '    _payee.transfer(payment);\n', '\n', '    emit Withdrawn(_payee, payment);\n', '\n', '    _data.isRefunded = true;\n', '\n', '    removeRefundeeByIndex(_data.index);\n', '  }\n', '\n', '  /**\n', '  @dev Owner can do manual refund here if investore has "BAD" money\n', '  @param _payee address of investor that needs to refund with next manual ETH sending\n', '  */\n', '  function manualRefund(address _payee) public onlyOwner {\n', '    require(depositsOf(_payee) > 0, "An investor should have non-negative deposit for withdrawal.");\n', '\n', '    RefundeeRecord storage _data = refundees[_payee];\n', '    require(_data.isRefunded == false, "An investor should not be refunded.");\n', '\n', '    deposits[_payee] = 0;\n', '    _data.isRefunded = true;\n', '\n', '    removeRefundeeByIndex(_data.index);\n', '  }\n', '\n', '  /**\n', '  * @dev Remove refundee referenced index from the internal list\n', '  * @param _indexToDelete An index in an array for deletion\n', '  */\n', '  function removeRefundeeByIndex(uint256 _indexToDelete) private {\n', '    if ((refundeesList.length > 0) && (_indexToDelete < refundeesList.length)) {\n', '      uint256 _lastIndex = refundeesList.length.sub(1);\n', '      refundeesList[_indexToDelete] = refundeesList[_lastIndex];\n', '      refundeesList.length--;\n', '    }\n', '  }\n', '  /**\n', '  * @dev Get refundee list length\n', '  */\n', '  function refundeesListLength() public onlyOwner view returns (uint256) {\n', '    return refundeesList.length;\n', '  }\n', '\n', '  /**\n', '  * @dev Auto refund\n', '  * @param _txFee The cost of executing refund code\n', '  */\n', '  function withdrawChunk(uint256 _txFee, uint256 _chunkLength) public onlyOwner returns (uint256, address[]) {\n', '    require(state == State.Refunding, "Funds withdrawal is possible only in the Refunding state.");\n', '\n', '    uint256 _refundeesCount = refundeesList.length;\n', '    require(_chunkLength >= _refundeesCount);\n', '    require(_txFee > 0, "Transaction fee should be above zero.");\n', '    require(_refundeesCount > 0, "List of investors should not be empty.");\n', '    uint256 _weiRefunded = 0;\n', '    require(address(this).balance > (_chunkLength.mul(_txFee)), "Account\'s ballance should allow to pay all tx fees.");\n', '    address[] memory _refundeesListCopy = new address[](_chunkLength);\n', '\n', '    uint256 i;\n', '    for (i = 0; i < _chunkLength; i++) {\n', '      address _refundee = refundeesList[i];\n', '      RefundeeRecord storage _data = refundees[_refundee];\n', '      if (_data.isRefunded == false) {\n', '        if (depositsOf(_refundee) > _txFee) {\n', '          uint256 _deposit = depositsOf(_refundee);\n', '          if (_deposit > _txFee) {\n', '            _weiRefunded = _weiRefunded.add(_deposit);\n', '            uint256 _paymentWithoutTxFee = _deposit.sub(_txFee);\n', '            _refundee.transfer(_paymentWithoutTxFee);\n', '            emit Withdrawn(_refundee, _paymentWithoutTxFee);\n', '            _data.isRefunded = true;\n', '            _refundeesListCopy[i] = _refundee;\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    for (i = 0; i < _chunkLength; i++) {\n', '      if (address(0) != _refundeesListCopy[i]) {\n', '        RefundeeRecord storage _dataCleanup = refundees[_refundeesListCopy[i]];\n', '        require(_dataCleanup.isRefunded == true, "Investors in this list should be refunded.");\n', '        removeRefundeeByIndex(_dataCleanup.index);\n', '      }\n', '    }\n', '\n', '    return (_weiRefunded, _refundeesListCopy);\n', '  }\n', '\n', '  /**\n', '  * @dev Auto refund\n', '  * @param _txFee The cost of executing refund code\n', '  */\n', '  function withdrawEverything(uint256 _txFee) public onlyOwner returns (uint256, address[]) {\n', '    require(state == State.Refunding, "Funds withdrawal is possible only in the Refunding state.");\n', '    return withdrawChunk(_txFee, refundeesList.length);\n', '  }\n', '\n', '  /**\n', "  * @dev Withdraws the part of beneficiary's funds.\n", '  */\n', '  function beneficiaryWithdrawChunk(uint256 _value) public onlyOwner {\n', '    require(_value <= address(this).balance, "Withdraw part can not be more than current balance");\n', '    beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value);\n', '    beneficiary.transfer(_value);\n', '  }\n', '\n', '  /**\n', "  * @dev Withdraws all beneficiary's funds.\n", '  */\n', '  function beneficiaryWithdrawAll() public onlyOwner {\n', '    uint256 _value = address(this).balance;\n', '    beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value);\n', '    beneficiary.transfer(_value);\n', '  }\n', '\n', '}']