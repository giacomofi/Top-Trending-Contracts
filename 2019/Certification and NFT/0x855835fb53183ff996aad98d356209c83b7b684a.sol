['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', '/**\n', ' * Allows EDG token holders to lend the Edgeless Casino tokens for the bankroll.\n', ' * Users may pay in their tokens at any time, but they will only be used for the bankroll\n', ' * begining from the next cycle. When the cycle is closed (at the end of the month), they may\n', ' * withdraw their stake of the bankroll. The casino may decide to limit the number of tokens\n', ' * used for the bankroll. The user will be able to withdraw the remaining tokens along with the\n', ' * bankroll tokens once per cycle.\n', ' * author: Julia Altenried\n', ' * */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Token {\n', '  function transfer(address receiver, uint amount) public returns(bool);\n', '  function transferFrom(address sender, address receiver, uint amount) public returns(bool);\n', '  function balanceOf(address holder) public view returns(uint);\n', '}\n', '\n', 'contract Casino {\n', '  mapping(address => bool) public authorized;\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function changeOwner(address newOwner) onlyOwner public {\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BankrollLending is Owned, SafeMath {\n', '  /** The set of lending contracts state phases **/\n', '  enum StatePhases { deposit, bankroll, update, withdraw }\n', '  /** The number of the current cycle. Increases by 1 each month.**/\n', '  uint public cycle;\n', '  /** The address of the casino contract.**/\n', '  Casino public casino;\n', '  /** The Edgeless casino token contract **/\n', '  Token public token;\n', '  /** Previuos staking contract **/\n', '  address public predecessor;\n', '  /** The sum of the initial stakes per cycle **/\n', '  mapping(uint => uint) public initialStakes;\n', '  /** The sum of the final stakes per cycle **/\n', '  mapping(uint => uint) public finalStakes;\n', '  /** The sum of the user stakes currently on the contract **/\n', '  uint public totalStakes; //note: uint is enough because the Edgeless Token Contract has 0 decimals and a total supply of 132,046,997 EDG\n', '  /** the number of stake holders **/\n', '  uint public numHolders;\n', '  /** List of all stakeholders **/\n', '  address[] public stakeholders;\n', '  /** Stake per user address **/\n', '  mapping(address => uint) public stakes;\n', '  /** the gas cost if the casino helps the user with the deposit in full EDG **/\n', '  uint8 public depositGasCost;\n', '  /** the gas cost if the casino helps the user with the withdrawal in full EDG **/\n', '  uint8 public withdrawGasCost;\n', '  /** the gas cost for balance update at the end of the cycle per user in EDG with 2 decimals\n', '  * (updates are made for all users at once, so it&#39;s possible to subtract all gas costs from the paid back tokens before\n', '  * setting the final stakes of the cycle.) **/\n', '  uint public updateGasCost;\n', '  /** The minimum staking amount required **/\n', '  uint public minStakingAmount;\n', '  /** The maximum number of addresses to process in one batch of stake updates **/\n', '  uint public maxUpdates; \n', '  /** The maximum number of addresses that can be assigned in one batch **/\n', '  uint public maxBatchAssignment;\n', '  /** remembers the last index updated per cycle **/\n', '  mapping(uint => uint) lastUpdateIndex;\n', '  /** notifies listeners about a stake update **/\n', '  event StakeUpdate(address holder, uint stake);\n', '\n', '  /**\n', '   * Constructor.\n', '   * @param tokenAddr the address of the edgeless token contract\n', '   *        casinoAddr the address of the edgeless casino contract\n', '   *        predecessorAdr the address of the previous bankroll lending contract.\n', '   * */\n', '  function BankrollLending(address tokenAddr, address casinoAddr, address predecessorAdr) public {\n', '    token = Token(tokenAddr);\n', '    casino = Casino(casinoAddr);\n', '    predecessor = predecessorAdr;\n', '    maxUpdates = 200;\n', '    maxBatchAssignment = 200;\n', '    cycle = 7;\n', '  }\n', '\n', '  /**\n', '   * Sets the casino contract address.\n', '   * @param casinoAddr the new casino contract address\n', '   * */\n', '  function setCasinoAddress(address casinoAddr) public onlyOwner {\n', '    casino = Casino(casinoAddr);\n', '  }\n', '\n', '  /**\n', '   * Sets the deposit gas cost.\n', '   * @param gasCost the new deposit gas cost\n', '   * */\n', '  function setDepositGasCost(uint8 gasCost) public onlyAuthorized {\n', '    depositGasCost = gasCost;\n', '  }\n', '\n', '  /**\n', '   * Sets the withdraw gas cost.\n', '   * @param gasCost the new withdraw gas cost\n', '   * */\n', '  function setWithdrawGasCost(uint8 gasCost) public onlyAuthorized {\n', '    withdrawGasCost = gasCost;\n', '  }\n', '\n', '  /**\n', '   * Sets the update gas cost.\n', '   * @param gasCost the new update gas cost\n', '   * */\n', '  function setUpdateGasCost(uint gasCost) public onlyAuthorized {\n', '    updateGasCost = gasCost;\n', '  }\n', '  \n', '  /**\n', '   * Sets the maximum number of user stakes to update at once\n', '   * @param newMax the new maximum\n', '   * */\n', '  function setMaxUpdates(uint newMax) public onlyAuthorized{\n', '    maxUpdates = newMax;\n', '  }\n', '  \n', '  /**\n', '   * Sets the minimum amount of user stakes\n', '   * @param amount the new minimum\n', '   * */\n', '  function setMinStakingAmount(uint amount) public onlyAuthorized {\n', '    minStakingAmount = amount;\n', '  }\n', '  \n', '  /**\n', '   * Sets the maximum number of addresses that can be assigned at once\n', '   * @param newMax the new maximum\n', '   * */\n', '  function setMaxBatchAssignment(uint newMax) public onlyAuthorized {\n', '    maxBatchAssignment = newMax;\n', '  }\n', '  \n', '  /**\n', '   * Allows the user to deposit funds, where the sender address and max allowed value have to be signed together with the cycle\n', '   * number by the casino. The method verifies the signature and makes sure, the deposit was made in time, before updating\n', '   * the storage variables.\n', '   * @param value the number of tokens to deposit\n', '   *        allowedMax the maximum deposit allowed this cycle\n', '   *        v, r, s the signature of an authorized casino wallet\n', '   * */\n', '  function deposit(uint value, uint allowedMax, uint8 v, bytes32 r, bytes32 s) public depositPhase {\n', '    require(verifySignature(msg.sender, allowedMax, v, r, s));\n', '    if (addDeposit(msg.sender, value, numHolders, allowedMax))\n', '      numHolders = safeAdd(numHolders, 1);\n', '    totalStakes = safeSub(safeAdd(totalStakes, value), depositGasCost);\n', '  }\n', '\n', '  /**\n', '   * Allows an authorized casino wallet to assign some tokens held by the lending contract to the given addresses.\n', '   * Only allows to assign token which do not already belong to any other user.\n', '   * Caller needs to make sure that the number of assignments can be processed in a single batch!\n', '   * @param to array containing the addresses of the holders\n', '   *        value array containing the number of tokens per address\n', '   * */\n', '  function batchAssignment(address[] to, uint[] value) public onlyAuthorized depositPhase {\n', '    require(to.length == value.length);\n', '    require(to.length <= maxBatchAssignment);\n', '    uint newTotalStakes = totalStakes;\n', '    uint numSH = numHolders;\n', '    for (uint8 i = 0; i < to.length; i++) {\n', '      newTotalStakes = safeSub(safeAdd(newTotalStakes, value[i]), depositGasCost);\n', '      if(addDeposit(to[i], value[i], numSH, 0))\n', '        numSH = safeAdd(numSH, 1);//save gas costs by increasing a memory variable instead of the storage variable per iteration\n', '    }\n', '    numHolders = numSH;\n', '    //rollback if more tokens have been assigned than the contract possesses\n', '    assert(newTotalStakes < tokenBalance());\n', '    totalStakes = newTotalStakes;\n', '  }\n', '  \n', '  /**\n', '   * updates the stake of an address.\n', '   * @param to the address\n', '   *        value the value to add to the stake\n', '   *        numSH the number of stakeholders\n', '   *        allowedMax the maximum amount a user may stake (0 in case the casino is making the assignment)\n', '   * */\n', '  function addDeposit(address to, uint value, uint numSH, uint allowedMax) internal returns (bool newHolder) {\n', '    require(value > 0);\n', '    uint newStake = safeSub(safeAdd(stakes[to], value), depositGasCost);\n', '    require(newStake >= minStakingAmount);\n', '    if(allowedMax > 0){//if allowedMax > 0 the caller is the user himself\n', '      require(newStake <= allowedMax);\n', '      assert(token.transferFrom(to, address(this), value));\n', '    }\n', '    if(stakes[to] == 0){\n', '      addHolder(to, numSH);\n', '      newHolder = true;\n', '    }\n', '    stakes[to] = newStake;\n', '    emit StakeUpdate(to, newStake);\n', '  }\n', '\n', '  /**\n', '   * Transfers the total stakes to the casino contract to be used as bankroll.\n', '   * Callabe only once per cycle and only after a cycle was started.\n', '   * */\n', '  function useAsBankroll() public onlyAuthorized depositPhase {\n', '    initialStakes[cycle] = totalStakes;\n', '    totalStakes = 0; //withdrawals are unlocked until this value is > 0 again and the final stakes have been set\n', '    assert(token.transfer(address(casino), initialStakes[cycle]));\n', '  }\n', '\n', '  /**\n', '   * Initiates the next cycle. Callabe only once per cycle and only after the last one was closed.\n', '   * */\n', '  function startNextCycle() public onlyAuthorized {\n', '    // make sure the last cycle was closed, can be called in update or withdraw phase\n', '    require(finalStakes[cycle] > 0);\n', '    cycle = safeAdd(cycle, 1);\n', '  }\n', '\n', '  /**\n', '   * Sets the final sum of user stakes for history and profit computation. Callable only once per cycle.\n', '   * The token balance of the contract may not be set as final stake, because there might have occurred unapproved deposits.\n', '   * @param value the number of EDG tokens that were transfered from the bankroll\n', '   * */\n', '  function closeCycle(uint value) public onlyAuthorized bankrollPhase {\n', '    require(tokenBalance() >= value);\n', '    finalStakes[cycle] = safeSub(value, safeMul(updateGasCost, numHolders)/100);//updateGasCost is using 2 decimals\n', '  }\n', '\n', '  /**\n', '   * Updates the user shares depending on the difference between final and initial stake.\n', '   * For doing so, it iterates over the array of stakeholders, while it processes max 500 addresses at once.\n', '   * If the array length is bigger than that, the contract remembers the position to start with on the next invocation.\n', '   * Therefore, this method might need to be called multiple times.\n', '   * It does consider the gas costs and subtracts them from the final stakes before computing the profit/loss.\n', '   * As soon as the last stake has been updated, withdrawals are unlocked by setting the totalStakes to the height of final stakes of the cycle.\n', '   * */\n', '  function updateUserShares() public onlyAuthorized updatePhase {\n', '    uint limit = safeAdd(lastUpdateIndex[cycle], maxUpdates);\n', '    if(limit >= numHolders) {\n', '      limit = numHolders;\n', '      totalStakes = finalStakes[cycle]; //enable withdrawals after this method call was processed\n', '      if (cycle > 1) {\n', '        lastUpdateIndex[cycle - 1] = 0;\n', '      }\n', '    }\n', '    address holder;\n', '    uint newStake;\n', '    for(uint i = lastUpdateIndex[cycle]; i < limit; i++){\n', '      holder = stakeholders[i];\n', '      newStake = computeFinalStake(stakes[holder]);\n', '      stakes[holder] = newStake;\n', '      emit StakeUpdate(holder, newStake);\n', '    }\n', '    lastUpdateIndex[cycle] = limit;\n', '  }\n', '\n', '  /**\n', '  * In case something goes wrong above, enable the users to withdraw their tokens.\n', '  * Should never be necessary.\n', '  * @param value the number of tokens to release\n', '  **/\n', '  function unlockWithdrawals(uint value) public onlyOwner {\n', '    require(value <= tokenBalance());\n', '    totalStakes = value;\n', '  }\n', '\n', '  /**\n', '   * If withdrawals are unlocked (final stakes of the cycle > 0 and totalStakes > 0), this function withdraws tokens from the sender’s balance to\n', '   * the specified address. If no balance remains, the user is removed from the stakeholder array.\n', '   * @param to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   * */\n', '  function withdraw(address to, uint value, uint index, uint share) public withdrawPhase{\n', '    makeWithdrawal(msg.sender, to, value, index, share);\n', '  }\n', '\n', '  /**\n', '   * An authorized casino wallet may use this function to make a withdrawal for the user.\n', '   * The value is subtracted from the signer’s balance and transferred to the specified address.\n', '   * If no balance remains, the signer is removed from the stakeholder array.\n', '   * @param to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the signer in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   *        v, r, s the signature of the stakeholder\n', '   * */\n', '  function withdrawFor(address to, uint value, uint index, uint share, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized withdrawPhase{\n', '    address from = ecrecover(keccak256(to, value, cycle), v, r, s);\n', '    makeWithdrawal(from, to, value, index, share);\n', '  }\n', '  \n', '  /**\n', '   * internal method for processing the withdrawal.\n', '   * @param from the stakeholder\n', '   *        to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   * */\n', '  function makeWithdrawal(address from, address to, uint value, uint index, uint share) internal{\n', '    if(value == stakes[from]){\n', '      stakes[from] = 0;\n', '      removeHolder(from, index);\n', '      emit StakeUpdate(from, 0);\n', '    }\n', '    else{\n', '      uint newStake = safeSub(stakes[from], value);\n', '      require(newStake >= minStakingAmount);\n', '      stakes[from] = newStake;\n', '      emit StakeUpdate(from, newStake);\n', '    }\n', '    totalStakes = safeSub(totalStakes, value);\n', '    uint receives = value;\n', '    uint bankroll = 0;\n', '    if (share < 1000) {\n', '        receives = safeMul(value, safeMul(1000, share));\n', '        bankroll = safeSub(value, receives);\n', '    }\n', '    assert(token.transfer(to, safeSub(receives, withdrawGasCost)));\n', '    if (bankroll > 0) {\n', '        assert(token.transfer(address(casino), bankroll));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Allows the casino to withdraw tokens which do not belong to any stakeholder.\n', '   * This is the case for gas-payback-tokens and if people send their tokens directly to the contract\n', '   * without the approval of the casino.\n', '   * */\n', '  function withdrawExcess() public onlyAuthorized {\n', '    uint value = safeSub(tokenBalance(), totalStakes);\n', '    token.transfer(owner, value);\n', '  }\n', '\n', '  /**\n', '   * Closes the contract in state of emergency or on contract update.\n', '   * Transfers all tokens held by the contract to the owner before doing so.\n', '   **/\n', '  function kill() public onlyOwner {\n', '    assert(token.transfer(owner, tokenBalance()));\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  /**\n', '   * @return the current token balance of the contract.\n', '   * */\n', '  function tokenBalance() public view returns(uint) {\n', '    return token.balanceOf(address(this));\n', '  }\n', '\n', '  /**\n', '  * Adds a new stakeholder to the list.\n', '  * @param holder the address of the stakeholder\n', '  *        numSH  the current number of stakeholders\n', '  **/\n', '  function addHolder(address holder, uint numSH) internal{\n', '    if(numSH < stakeholders.length)\n', '      stakeholders[numSH] = holder;\n', '    else\n', '      stakeholders.push(holder);\n', '  }\n', '  \n', '  /**\n', '  * Removes a stakeholder from the list.\n', '  * @param holder the address of the stakeholder\n', '  *        index  the index of the holder\n', '  **/\n', '  function removeHolder(address holder, uint index) internal{\n', '    require(stakeholders[index] == holder);\n', '    numHolders = safeSub(numHolders, 1);\n', '    stakeholders[index] = stakeholders[numHolders];\n', '  }\n', '\n', '  /**\n', '   * computes the final stake.\n', '   * @param initialStake the initial number of tokens the user invested\n', '   * @return finalStake  the final number of tokens the user receives\n', '   * */\n', '  function computeFinalStake(uint initialStake) internal view returns(uint) {\n', '    return safeMul(initialStake, finalStakes[cycle]) / initialStakes[cycle];\n', '  }\n', '\n', '  /**\n', '   * verifies if the withdrawal request was signed by an authorized wallet\n', '   * @param to      the receiver address\n', '   *        value   the number of tokens\n', '   *        v, r, s the signature of an authorized wallet\n', '   * */\n', '  function verifySignature(address to, uint value, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\n', '    address signer = ecrecover(keccak256(to, value, cycle), v, r, s);\n', '    return casino.authorized(signer);\n', '  }\n', '\n', '  /**\n', '   * computes state based on the initial, total and final stakes of the current cycle.\n', '   * @return current state phase\n', '   * */\n', '  function getPhase() public view returns (StatePhases) {\n', '    if (initialStakes[cycle] == 0) {\n', '      return StatePhases.deposit;\n', '    } else if (finalStakes[cycle] == 0) {\n', '      return StatePhases.bankroll;\n', '    } else if (totalStakes == 0) {\n', '      return StatePhases.update;\n', '    }\n', '    return StatePhases.withdraw;\n', '  }\n', '  \n', '  //check if the sender is an authorized casino wallet\n', '  modifier onlyAuthorized {\n', '    require(casino.authorized(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // deposit phase: initialStakes[cycle] == 0\n', '  modifier depositPhase {\n', '    require(getPhase() == StatePhases.deposit);\n', '    _;\n', '  }\n', '\n', '  // bankroll phase: initialStakes[cycle] > 0 and finalStakes[cycle] == 0\n', '  modifier bankrollPhase {\n', '    require(getPhase() == StatePhases.bankroll);\n', '    _;\n', '  }\n', '\n', '  // update phase: finalStakes[cycle] > 0 and totalStakes == 0\n', '  modifier updatePhase {\n', '    require(getPhase() == StatePhases.update);\n', '    _;\n', '  }\n', '\n', '  // withdraw phase: finalStakes[cycle] > 0 and totalStakes > 0\n', '  modifier withdrawPhase {\n', '    require(getPhase() == StatePhases.withdraw);\n', '    _;\n', '  }\n', '\n', '}']
['/**\n', ' * Allows EDG token holders to lend the Edgeless Casino tokens for the bankroll.\n', ' * Users may pay in their tokens at any time, but they will only be used for the bankroll\n', ' * begining from the next cycle. When the cycle is closed (at the end of the month), they may\n', ' * withdraw their stake of the bankroll. The casino may decide to limit the number of tokens\n', ' * used for the bankroll. The user will be able to withdraw the remaining tokens along with the\n', ' * bankroll tokens once per cycle.\n', ' * author: Julia Altenried\n', ' * */\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract Token {\n', '  function transfer(address receiver, uint amount) public returns(bool);\n', '  function transferFrom(address sender, address receiver, uint amount) public returns(bool);\n', '  function balanceOf(address holder) public view returns(uint);\n', '}\n', '\n', 'contract Casino {\n', '  mapping(address => bool) public authorized;\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function changeOwner(address newOwner) onlyOwner public {\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BankrollLending is Owned, SafeMath {\n', '  /** The set of lending contracts state phases **/\n', '  enum StatePhases { deposit, bankroll, update, withdraw }\n', '  /** The number of the current cycle. Increases by 1 each month.**/\n', '  uint public cycle;\n', '  /** The address of the casino contract.**/\n', '  Casino public casino;\n', '  /** The Edgeless casino token contract **/\n', '  Token public token;\n', '  /** Previuos staking contract **/\n', '  address public predecessor;\n', '  /** The sum of the initial stakes per cycle **/\n', '  mapping(uint => uint) public initialStakes;\n', '  /** The sum of the final stakes per cycle **/\n', '  mapping(uint => uint) public finalStakes;\n', '  /** The sum of the user stakes currently on the contract **/\n', '  uint public totalStakes; //note: uint is enough because the Edgeless Token Contract has 0 decimals and a total supply of 132,046,997 EDG\n', '  /** the number of stake holders **/\n', '  uint public numHolders;\n', '  /** List of all stakeholders **/\n', '  address[] public stakeholders;\n', '  /** Stake per user address **/\n', '  mapping(address => uint) public stakes;\n', '  /** the gas cost if the casino helps the user with the deposit in full EDG **/\n', '  uint8 public depositGasCost;\n', '  /** the gas cost if the casino helps the user with the withdrawal in full EDG **/\n', '  uint8 public withdrawGasCost;\n', '  /** the gas cost for balance update at the end of the cycle per user in EDG with 2 decimals\n', "  * (updates are made for all users at once, so it's possible to subtract all gas costs from the paid back tokens before\n", '  * setting the final stakes of the cycle.) **/\n', '  uint public updateGasCost;\n', '  /** The minimum staking amount required **/\n', '  uint public minStakingAmount;\n', '  /** The maximum number of addresses to process in one batch of stake updates **/\n', '  uint public maxUpdates; \n', '  /** The maximum number of addresses that can be assigned in one batch **/\n', '  uint public maxBatchAssignment;\n', '  /** remembers the last index updated per cycle **/\n', '  mapping(uint => uint) lastUpdateIndex;\n', '  /** notifies listeners about a stake update **/\n', '  event StakeUpdate(address holder, uint stake);\n', '\n', '  /**\n', '   * Constructor.\n', '   * @param tokenAddr the address of the edgeless token contract\n', '   *        casinoAddr the address of the edgeless casino contract\n', '   *        predecessorAdr the address of the previous bankroll lending contract.\n', '   * */\n', '  function BankrollLending(address tokenAddr, address casinoAddr, address predecessorAdr) public {\n', '    token = Token(tokenAddr);\n', '    casino = Casino(casinoAddr);\n', '    predecessor = predecessorAdr;\n', '    maxUpdates = 200;\n', '    maxBatchAssignment = 200;\n', '    cycle = 7;\n', '  }\n', '\n', '  /**\n', '   * Sets the casino contract address.\n', '   * @param casinoAddr the new casino contract address\n', '   * */\n', '  function setCasinoAddress(address casinoAddr) public onlyOwner {\n', '    casino = Casino(casinoAddr);\n', '  }\n', '\n', '  /**\n', '   * Sets the deposit gas cost.\n', '   * @param gasCost the new deposit gas cost\n', '   * */\n', '  function setDepositGasCost(uint8 gasCost) public onlyAuthorized {\n', '    depositGasCost = gasCost;\n', '  }\n', '\n', '  /**\n', '   * Sets the withdraw gas cost.\n', '   * @param gasCost the new withdraw gas cost\n', '   * */\n', '  function setWithdrawGasCost(uint8 gasCost) public onlyAuthorized {\n', '    withdrawGasCost = gasCost;\n', '  }\n', '\n', '  /**\n', '   * Sets the update gas cost.\n', '   * @param gasCost the new update gas cost\n', '   * */\n', '  function setUpdateGasCost(uint gasCost) public onlyAuthorized {\n', '    updateGasCost = gasCost;\n', '  }\n', '  \n', '  /**\n', '   * Sets the maximum number of user stakes to update at once\n', '   * @param newMax the new maximum\n', '   * */\n', '  function setMaxUpdates(uint newMax) public onlyAuthorized{\n', '    maxUpdates = newMax;\n', '  }\n', '  \n', '  /**\n', '   * Sets the minimum amount of user stakes\n', '   * @param amount the new minimum\n', '   * */\n', '  function setMinStakingAmount(uint amount) public onlyAuthorized {\n', '    minStakingAmount = amount;\n', '  }\n', '  \n', '  /**\n', '   * Sets the maximum number of addresses that can be assigned at once\n', '   * @param newMax the new maximum\n', '   * */\n', '  function setMaxBatchAssignment(uint newMax) public onlyAuthorized {\n', '    maxBatchAssignment = newMax;\n', '  }\n', '  \n', '  /**\n', '   * Allows the user to deposit funds, where the sender address and max allowed value have to be signed together with the cycle\n', '   * number by the casino. The method verifies the signature and makes sure, the deposit was made in time, before updating\n', '   * the storage variables.\n', '   * @param value the number of tokens to deposit\n', '   *        allowedMax the maximum deposit allowed this cycle\n', '   *        v, r, s the signature of an authorized casino wallet\n', '   * */\n', '  function deposit(uint value, uint allowedMax, uint8 v, bytes32 r, bytes32 s) public depositPhase {\n', '    require(verifySignature(msg.sender, allowedMax, v, r, s));\n', '    if (addDeposit(msg.sender, value, numHolders, allowedMax))\n', '      numHolders = safeAdd(numHolders, 1);\n', '    totalStakes = safeSub(safeAdd(totalStakes, value), depositGasCost);\n', '  }\n', '\n', '  /**\n', '   * Allows an authorized casino wallet to assign some tokens held by the lending contract to the given addresses.\n', '   * Only allows to assign token which do not already belong to any other user.\n', '   * Caller needs to make sure that the number of assignments can be processed in a single batch!\n', '   * @param to array containing the addresses of the holders\n', '   *        value array containing the number of tokens per address\n', '   * */\n', '  function batchAssignment(address[] to, uint[] value) public onlyAuthorized depositPhase {\n', '    require(to.length == value.length);\n', '    require(to.length <= maxBatchAssignment);\n', '    uint newTotalStakes = totalStakes;\n', '    uint numSH = numHolders;\n', '    for (uint8 i = 0; i < to.length; i++) {\n', '      newTotalStakes = safeSub(safeAdd(newTotalStakes, value[i]), depositGasCost);\n', '      if(addDeposit(to[i], value[i], numSH, 0))\n', '        numSH = safeAdd(numSH, 1);//save gas costs by increasing a memory variable instead of the storage variable per iteration\n', '    }\n', '    numHolders = numSH;\n', '    //rollback if more tokens have been assigned than the contract possesses\n', '    assert(newTotalStakes < tokenBalance());\n', '    totalStakes = newTotalStakes;\n', '  }\n', '  \n', '  /**\n', '   * updates the stake of an address.\n', '   * @param to the address\n', '   *        value the value to add to the stake\n', '   *        numSH the number of stakeholders\n', '   *        allowedMax the maximum amount a user may stake (0 in case the casino is making the assignment)\n', '   * */\n', '  function addDeposit(address to, uint value, uint numSH, uint allowedMax) internal returns (bool newHolder) {\n', '    require(value > 0);\n', '    uint newStake = safeSub(safeAdd(stakes[to], value), depositGasCost);\n', '    require(newStake >= minStakingAmount);\n', '    if(allowedMax > 0){//if allowedMax > 0 the caller is the user himself\n', '      require(newStake <= allowedMax);\n', '      assert(token.transferFrom(to, address(this), value));\n', '    }\n', '    if(stakes[to] == 0){\n', '      addHolder(to, numSH);\n', '      newHolder = true;\n', '    }\n', '    stakes[to] = newStake;\n', '    emit StakeUpdate(to, newStake);\n', '  }\n', '\n', '  /**\n', '   * Transfers the total stakes to the casino contract to be used as bankroll.\n', '   * Callabe only once per cycle and only after a cycle was started.\n', '   * */\n', '  function useAsBankroll() public onlyAuthorized depositPhase {\n', '    initialStakes[cycle] = totalStakes;\n', '    totalStakes = 0; //withdrawals are unlocked until this value is > 0 again and the final stakes have been set\n', '    assert(token.transfer(address(casino), initialStakes[cycle]));\n', '  }\n', '\n', '  /**\n', '   * Initiates the next cycle. Callabe only once per cycle and only after the last one was closed.\n', '   * */\n', '  function startNextCycle() public onlyAuthorized {\n', '    // make sure the last cycle was closed, can be called in update or withdraw phase\n', '    require(finalStakes[cycle] > 0);\n', '    cycle = safeAdd(cycle, 1);\n', '  }\n', '\n', '  /**\n', '   * Sets the final sum of user stakes for history and profit computation. Callable only once per cycle.\n', '   * The token balance of the contract may not be set as final stake, because there might have occurred unapproved deposits.\n', '   * @param value the number of EDG tokens that were transfered from the bankroll\n', '   * */\n', '  function closeCycle(uint value) public onlyAuthorized bankrollPhase {\n', '    require(tokenBalance() >= value);\n', '    finalStakes[cycle] = safeSub(value, safeMul(updateGasCost, numHolders)/100);//updateGasCost is using 2 decimals\n', '  }\n', '\n', '  /**\n', '   * Updates the user shares depending on the difference between final and initial stake.\n', '   * For doing so, it iterates over the array of stakeholders, while it processes max 500 addresses at once.\n', '   * If the array length is bigger than that, the contract remembers the position to start with on the next invocation.\n', '   * Therefore, this method might need to be called multiple times.\n', '   * It does consider the gas costs and subtracts them from the final stakes before computing the profit/loss.\n', '   * As soon as the last stake has been updated, withdrawals are unlocked by setting the totalStakes to the height of final stakes of the cycle.\n', '   * */\n', '  function updateUserShares() public onlyAuthorized updatePhase {\n', '    uint limit = safeAdd(lastUpdateIndex[cycle], maxUpdates);\n', '    if(limit >= numHolders) {\n', '      limit = numHolders;\n', '      totalStakes = finalStakes[cycle]; //enable withdrawals after this method call was processed\n', '      if (cycle > 1) {\n', '        lastUpdateIndex[cycle - 1] = 0;\n', '      }\n', '    }\n', '    address holder;\n', '    uint newStake;\n', '    for(uint i = lastUpdateIndex[cycle]; i < limit; i++){\n', '      holder = stakeholders[i];\n', '      newStake = computeFinalStake(stakes[holder]);\n', '      stakes[holder] = newStake;\n', '      emit StakeUpdate(holder, newStake);\n', '    }\n', '    lastUpdateIndex[cycle] = limit;\n', '  }\n', '\n', '  /**\n', '  * In case something goes wrong above, enable the users to withdraw their tokens.\n', '  * Should never be necessary.\n', '  * @param value the number of tokens to release\n', '  **/\n', '  function unlockWithdrawals(uint value) public onlyOwner {\n', '    require(value <= tokenBalance());\n', '    totalStakes = value;\n', '  }\n', '\n', '  /**\n', '   * If withdrawals are unlocked (final stakes of the cycle > 0 and totalStakes > 0), this function withdraws tokens from the sender’s balance to\n', '   * the specified address. If no balance remains, the user is removed from the stakeholder array.\n', '   * @param to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   * */\n', '  function withdraw(address to, uint value, uint index, uint share) public withdrawPhase{\n', '    makeWithdrawal(msg.sender, to, value, index, share);\n', '  }\n', '\n', '  /**\n', '   * An authorized casino wallet may use this function to make a withdrawal for the user.\n', '   * The value is subtracted from the signer’s balance and transferred to the specified address.\n', '   * If no balance remains, the signer is removed from the stakeholder array.\n', '   * @param to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the signer in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   *        v, r, s the signature of the stakeholder\n', '   * */\n', '  function withdrawFor(address to, uint value, uint index, uint share, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized withdrawPhase{\n', '    address from = ecrecover(keccak256(to, value, cycle), v, r, s);\n', '    makeWithdrawal(from, to, value, index, share);\n', '  }\n', '  \n', '  /**\n', '   * internal method for processing the withdrawal.\n', '   * @param from the stakeholder\n', '   *        to the receiver\n', '   *        value the number of tokens\n', '   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\n', '   *        share to send to staker 1000 is 100%\n', '   * */\n', '  function makeWithdrawal(address from, address to, uint value, uint index, uint share) internal{\n', '    if(value == stakes[from]){\n', '      stakes[from] = 0;\n', '      removeHolder(from, index);\n', '      emit StakeUpdate(from, 0);\n', '    }\n', '    else{\n', '      uint newStake = safeSub(stakes[from], value);\n', '      require(newStake >= minStakingAmount);\n', '      stakes[from] = newStake;\n', '      emit StakeUpdate(from, newStake);\n', '    }\n', '    totalStakes = safeSub(totalStakes, value);\n', '    uint receives = value;\n', '    uint bankroll = 0;\n', '    if (share < 1000) {\n', '        receives = safeMul(value, safeMul(1000, share));\n', '        bankroll = safeSub(value, receives);\n', '    }\n', '    assert(token.transfer(to, safeSub(receives, withdrawGasCost)));\n', '    if (bankroll > 0) {\n', '        assert(token.transfer(address(casino), bankroll));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Allows the casino to withdraw tokens which do not belong to any stakeholder.\n', '   * This is the case for gas-payback-tokens and if people send their tokens directly to the contract\n', '   * without the approval of the casino.\n', '   * */\n', '  function withdrawExcess() public onlyAuthorized {\n', '    uint value = safeSub(tokenBalance(), totalStakes);\n', '    token.transfer(owner, value);\n', '  }\n', '\n', '  /**\n', '   * Closes the contract in state of emergency or on contract update.\n', '   * Transfers all tokens held by the contract to the owner before doing so.\n', '   **/\n', '  function kill() public onlyOwner {\n', '    assert(token.transfer(owner, tokenBalance()));\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  /**\n', '   * @return the current token balance of the contract.\n', '   * */\n', '  function tokenBalance() public view returns(uint) {\n', '    return token.balanceOf(address(this));\n', '  }\n', '\n', '  /**\n', '  * Adds a new stakeholder to the list.\n', '  * @param holder the address of the stakeholder\n', '  *        numSH  the current number of stakeholders\n', '  **/\n', '  function addHolder(address holder, uint numSH) internal{\n', '    if(numSH < stakeholders.length)\n', '      stakeholders[numSH] = holder;\n', '    else\n', '      stakeholders.push(holder);\n', '  }\n', '  \n', '  /**\n', '  * Removes a stakeholder from the list.\n', '  * @param holder the address of the stakeholder\n', '  *        index  the index of the holder\n', '  **/\n', '  function removeHolder(address holder, uint index) internal{\n', '    require(stakeholders[index] == holder);\n', '    numHolders = safeSub(numHolders, 1);\n', '    stakeholders[index] = stakeholders[numHolders];\n', '  }\n', '\n', '  /**\n', '   * computes the final stake.\n', '   * @param initialStake the initial number of tokens the user invested\n', '   * @return finalStake  the final number of tokens the user receives\n', '   * */\n', '  function computeFinalStake(uint initialStake) internal view returns(uint) {\n', '    return safeMul(initialStake, finalStakes[cycle]) / initialStakes[cycle];\n', '  }\n', '\n', '  /**\n', '   * verifies if the withdrawal request was signed by an authorized wallet\n', '   * @param to      the receiver address\n', '   *        value   the number of tokens\n', '   *        v, r, s the signature of an authorized wallet\n', '   * */\n', '  function verifySignature(address to, uint value, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\n', '    address signer = ecrecover(keccak256(to, value, cycle), v, r, s);\n', '    return casino.authorized(signer);\n', '  }\n', '\n', '  /**\n', '   * computes state based on the initial, total and final stakes of the current cycle.\n', '   * @return current state phase\n', '   * */\n', '  function getPhase() public view returns (StatePhases) {\n', '    if (initialStakes[cycle] == 0) {\n', '      return StatePhases.deposit;\n', '    } else if (finalStakes[cycle] == 0) {\n', '      return StatePhases.bankroll;\n', '    } else if (totalStakes == 0) {\n', '      return StatePhases.update;\n', '    }\n', '    return StatePhases.withdraw;\n', '  }\n', '  \n', '  //check if the sender is an authorized casino wallet\n', '  modifier onlyAuthorized {\n', '    require(casino.authorized(msg.sender));\n', '    _;\n', '  }\n', '\n', '  // deposit phase: initialStakes[cycle] == 0\n', '  modifier depositPhase {\n', '    require(getPhase() == StatePhases.deposit);\n', '    _;\n', '  }\n', '\n', '  // bankroll phase: initialStakes[cycle] > 0 and finalStakes[cycle] == 0\n', '  modifier bankrollPhase {\n', '    require(getPhase() == StatePhases.bankroll);\n', '    _;\n', '  }\n', '\n', '  // update phase: finalStakes[cycle] > 0 and totalStakes == 0\n', '  modifier updatePhase {\n', '    require(getPhase() == StatePhases.update);\n', '    _;\n', '  }\n', '\n', '  // withdraw phase: finalStakes[cycle] > 0 and totalStakes > 0\n', '  modifier withdrawPhase {\n', '    require(getPhase() == StatePhases.withdraw);\n', '    _;\n', '  }\n', '\n', '}']
