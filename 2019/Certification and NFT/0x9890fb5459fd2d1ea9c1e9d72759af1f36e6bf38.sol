['pragma solidity ^0.4.24;\n', ' \n', '\n', '//\n', "//                       .#########'\n", '//                    .###############+\n', '//                  ,####################\n', '//                `#######################+\n', '//               ;##########################\n', '//              #############################.\n', '//             ###############################,\n', '//           +##################,    ###########`\n', '//          .###################     .###########\n', '//         ##############,          .###########+\n', '//         #############`            .############`\n', '//         ###########+                ############\n', '//        ###########;                  ###########\n', "//        ##########'                    ###########\n", "//       '##########    '#.        `,     ##########\n", "//       ##########    ####'      ####.   :#########;\n", "//      `#########'   :#####;    ######    ##########\n", '//      :#########    #######:  #######    :#########\n', '//      +#########    :#######.########     #########`\n', "//      #########;     ###############'     #########:\n", "//      #########       #############+      '########'\n", '//      #########        ############       :#########\n', '//      #########         ##########        ,#########\n', '//      #########         :########         ,#########\n', '//      #########        ,##########        ,#########\n', '//      #########       ,############       :########+\n', "//      #########      .#############+      '########'\n", "//      #########:    `###############'     #########,\n", '//      +########+    ;#######`;#######     #########\n', "//      ,#########    '######`  '######    :#########\n", "//       #########;   .#####`    '#####    ##########\n", "//       ##########    '###`      +###    :#########:\n", '//       ;#########+     `                ##########\n', '//        ##########,                    ###########\n', '//         ###########;                ############\n', '//         +############             .############`\n', '//          ###########+           ,#############;\n', '//          `###########     ;++#################\n', '//           :##########,    ###################\n', "//            '###########.'###################\n", '//             +##############################\n', "//              '############################`\n", '//               .##########################\n', '//                 #######################:\n', '//                   ###################+\n', '//                     +##############:\n', '//                        :#######+`\n', '//\n', '//\n', '//\n', '// Play0x.com (The ONLY gaming platform for all ERC20 Tokens)\n', '// -------------------------------------------------------------------------------------------------------\n', '// * Multiple types of game platforms\n', '// * Build your own game zone - Not only playing games, but also allowing other players to join your game.\n', '// * Support all ERC20 tokens.\n', '//\n', '//\n', '//\n', '// 0xC Token (Contract address : 0x60d8234a662651e586173c17eb45ca9833a7aa6c)\n', '// -------------------------------------------------------------------------------------------------------\n', '// * 0xC Token is an ERC20 Token specifically for digital entertainment.\n', '// * No ICO and private sales,fair access.\n', '// * There will be hundreds of games using 0xC as a game token.\n', "// * Token holders can permanently get ETH's profit sharing.\n", '//\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', '* @title ERC20 interface\n', '* @dev see https://github.com/ethereum/EIPs/issues/20\n', '*/\n', 'contract ERC20 {\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function balanceOf(address who) public constant returns  (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function transfer(address _to, uint256 _value) public;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Play0x_Gashapon {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint128;\n', '    using SafeMath for uint40;\n', '    using SafeMath for uint8;\n', '\n', '    uint public jackpotSize;\n', '    uint public tokenJackpotSize;\n', '\n', '    uint public MIN_BET;\n', '    uint public MAX_BET;\n', '    uint public MAX_AMOUNT;\n', '\n', '    //Adjustable max bet profit.\n', '    uint public maxProfit;\n', '    uint public maxTokenProfit;\n', '\n', '    //Fee percentage\n', '    uint8 public platformFeePercentage = 15;\n', '    uint8 public jackpotFeePercentage = 5;\n', '    uint8 public ERC20rewardMultiple = 5;\n', '\n', '    //Bets can be refunded via invoking refundBet.\n', '    uint constant BetExpirationBlocks = 250;\n', '\n', '\n', '\n', '    //Funds that are locked in potentially winning bets.\n', '    uint public lockedInBets;\n', '    uint public lockedTokenInBets;\n', '\n', '    bytes32 bitComparisonMask = 0xF;\n', '\n', '    //Standard contract ownership transfer.\n', '    address public owner;\n', '    address private nextOwner;\n', '    address public manager;\n', '    address private nextManager;\n', '\n', '    //The address corresponding to a private key used to sign placeBet commits.\n', '    address public secretSigner;\n', '    address public ERC20ContractAddres;\n', '    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    //Single bet.\n', '    struct Bet {\n', '        //Amount in wei.\n', '        uint amount;\n', '        //place tx Block number.\n', '        uint40 placeBlockNumber;\n', '        // Address of a gambler.\n', '        address gambler;\n', '    }\n', '\n', '    //Mapping from commits\n', '    mapping (uint => Bet) public bets;\n', '\n', '    //Withdrawal mode data.\n', '    uint32[] public withdrawalMode = [1,140770,2,75400,3,51600,4,39200,5,30700,6,25900,7,22300,8,19700,9,17200,10,15600,11,14200,12,13300,13,12000,14,11000,15,10400 ];\n', '\n', '    // Events that are issued to make statistic recovery easier.\n', '    event PlaceBetLog(address indexed player, uint amount,uint8 rotateTime);\n', '\n', '    //Admin Payment\n', '    event ToManagerPayment(address indexed beneficiary, uint amount);\n', '    event ToManagerFailedPayment(address indexed beneficiary, uint amount);\n', '    event ToOwnerPayment(address indexed beneficiary, uint amount);\n', '    event ToOwnerFailedPayment(address indexed beneficiary, uint amount);\n', '\n', '    //Bet Payment\n', '    event Payment(address indexed beneficiary, uint amount);\n', '    event FailedPayment(address indexed beneficiary, uint amount);\n', '    event TokenPayment(address indexed beneficiary, uint amount);\n', '    event FailedTokenPayment(address indexed beneficiary, uint amount);\n', '\n', '    //JACKPOT\n', '    event JackpotBouns(address indexed beneficiary, uint amount);\n', '    event TokenJackpotBouns(address indexed beneficiary, uint amount);\n', '\n', '    //Play0x_Gashapon_Event\n', '    event BetRelatedData(\n', '        address indexed player,\n', '        uint playerBetAmount,\n', '        uint playerGetAmount,\n', '        bytes32 entropy,\n', '        bytes32 entropy2,\n', '        uint8 Uplimit,\n', '        uint8 rotateTime\n', '    );\n', '\n', '    // Constructor. Deliberately does not take any parameters.\n', '    constructor () public {\n', '        owner = msg.sender;\n', '        manager = DUMMY_ADDRESS;\n', '        secretSigner = DUMMY_ADDRESS;\n', '        ERC20ContractAddres = DUMMY_ADDRESS;\n', '    }\n', '\n', '    // Standard modifier on methods invokable only by contract owner.\n', '    modifier onlyOwner {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager {\n', '        require (msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerManager {\n', '        require (msg.sender == owner || msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    modifier onlySigner {\n', '        require (msg.sender == secretSigner);\n', '        _;\n', '    }\n', '\n', '    //Init Parameter.\n', '    function initialParameter(address _manager,address _secretSigner,address _erc20tokenAddress ,uint _MIN_BET,uint _MAX_BET,uint _maxProfit,uint _maxTokenProfit, uint _MAX_AMOUNT, uint8 _platformFeePercentage,uint8 _jackpotFeePercentage,uint8 _ERC20rewardMultiple)external onlyOwner{\n', '        manager = _manager;\n', '        secretSigner = _secretSigner;\n', '        ERC20ContractAddres = _erc20tokenAddress;\n', '\n', '        MIN_BET = _MIN_BET;\n', '        MAX_BET = _MAX_BET;\n', '        maxProfit = _maxProfit;\n', '        maxTokenProfit = _maxTokenProfit;\n', '        MAX_AMOUNT = _MAX_AMOUNT;\n', '        platformFeePercentage = _platformFeePercentage;\n', '        jackpotFeePercentage = _jackpotFeePercentage;\n', '        ERC20rewardMultiple = _ERC20rewardMultiple;\n', '    }\n', '\n', '    // Standard contract ownership transfer implementation,\n', '    function approveNextOwner(address _nextOwner) external onlyOwner {\n', '        require (_nextOwner != owner);\n', '        nextOwner = _nextOwner;\n', '    }\n', '\n', '    function acceptNextOwner() external {\n', '        require (msg.sender == nextOwner);\n', '        owner = nextOwner;\n', '    }\n', '\n', '    // Standard contract ownership transfer implementation,\n', '    function approveNextManager(address _nextManager) external onlyManager {\n', '        require (_nextManager != manager);\n', '        nextManager = _nextManager;\n', '    }\n', '\n', '    function acceptNextManager() external {\n', '        require (msg.sender == nextManager);\n', '        manager = nextManager;\n', '    }\n', '\n', '    // Fallback function deliberately left empty.\n', '    function () public payable {\n', '    }\n', '\n', '    //Set signer.\n', '    function setSecretSigner(address newSecretSigner) external onlyOwner {\n', '        secretSigner = newSecretSigner;\n', '    }\n', '\n', '    //Set tokenAddress.\n', '    function setTokenAddress(address _tokenAddress) external onlyManager {\n', '        ERC20ContractAddres = _tokenAddress;\n', '    }\n', '\n', '\n', '    // Change max bet reward. Setting this to zero effectively disables betting.\n', '    function setMaxProfit(uint _maxProfit) public onlyOwner {\n', '        require (_maxProfit < MAX_AMOUNT);\n', '        maxProfit = _maxProfit;\n', '    }\n', '\n', '    // Funds withdrawal.\n', '    function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\n', '        require (withdrawAmount <= address(this).balance);\n', '\n', '        uint safetyAmount = jackpotSize.add(lockedInBets).add(withdrawAmount);\n', '        safetyAmount = safetyAmount.add(withdrawAmount);\n', '\n', '        require (safetyAmount <= address(this).balance);\n', '        sendFunds(beneficiary, withdrawAmount, withdrawAmount);\n', '    }\n', '\n', '    // Token withdrawal.\n', '    function withdrawToken(address beneficiary, uint withdrawAmount) external onlyOwner {\n', '        require (withdrawAmount <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\n', '\n', '        uint safetyAmount = tokenJackpotSize.add(lockedTokenInBets);\n', '        safetyAmount = safetyAmount.add(withdrawAmount);\n', '        require (safetyAmount <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\n', '\n', '         ERC20(ERC20ContractAddres).transfer(beneficiary, withdrawAmount);\n', '         emit TokenPayment(beneficiary, withdrawAmount);\n', '    }\n', '\n', '    //Recovery of funds\n', '    function withdrawAllFunds(address beneficiary) external onlyOwner {\n', '        if (beneficiary.send(address(this).balance)) {\n', '            lockedInBets = 0;\n', '            emit Payment(beneficiary, address(this).balance);\n', '        } else {\n', '            emit FailedPayment(beneficiary, address(this).balance);\n', '        }\n', '    }\n', '\n', '    //Recovery of Token funds\n', '    function withdrawAlltokenFunds(address beneficiary) external onlyOwner {\n', '        ERC20(ERC20ContractAddres).transfer(beneficiary, ERC20(ERC20ContractAddres).balanceOf(address(this)));\n', '        lockedTokenInBets = 0;\n', '        emit TokenPayment(beneficiary, ERC20(ERC20ContractAddres).balanceOf(address(this)));\n', '    }\n', '\n', '    // Contract may be destroyed only when there are no ongoing bets,\n', '    // either settled or refunded. All funds are transferred to contract owner.\n', '    function kill() external onlyOwner {\n', '        require (lockedInBets == 0);\n', '        require (lockedTokenInBets == 0);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function getContractInformation()public view returns(\n', '        uint _jackpotSize,\n', '        uint _tokenJackpotSize,\n', '        uint _MIN_BET,\n', '        uint _MAX_BET,\n', '        uint _MAX_AMOUNT,\n', '        uint8 _platformFeePercentage,\n', '        uint8 _jackpotFeePercentage,\n', '        uint _maxProfit,\n', '        uint _maxTokenProfit,\n', '        uint _lockedInBets,\n', '        uint _lockedTokenInBets,\n', '        uint32[] _withdrawalMode){\n', '\n', '        _jackpotSize = jackpotSize;\n', '        _tokenJackpotSize = tokenJackpotSize;\n', '        _MIN_BET = MIN_BET;\n', '        _MAX_BET = MAX_BET;\n', '        _MAX_AMOUNT = MAX_AMOUNT;\n', '        _platformFeePercentage = platformFeePercentage;\n', '        _jackpotFeePercentage = jackpotFeePercentage;\n', '        _maxProfit = maxProfit;\n', '        _maxTokenProfit = maxTokenProfit;\n', '        _lockedInBets = lockedInBets;\n', '        _lockedTokenInBets = lockedTokenInBets;\n', '        _withdrawalMode = withdrawalMode;\n', '    }\n', '\n', '    function getContractAddress()public view returns(\n', '        address _owner,\n', '        address _manager,\n', '        address _secretSigner,\n', '        address _ERC20ContractAddres ){\n', '\n', '        _owner = owner;\n', '        _manager= manager;\n', '        _secretSigner = secretSigner;\n', '        _ERC20ContractAddres = ERC20ContractAddres;\n', '    }\n', '\n', '    // Settlement transaction\n', '    enum PlaceParam {\n', '        RotateTime,\n', '        possibleWinAmount\n', '    }\n', '\n', '    //Bet by ether: Commits are signed with a block limit to ensure that they are used at most once.\n', '    function placeBet(uint[] placParameter, bytes32 _signatureHash , uint _commitLastBlock, uint _commit, bytes32 r, bytes32 s, uint8 v) external payable {\n', '        require (uint8(placParameter[uint8(PlaceParam.RotateTime)]) != 0);\n', '        require (block.number <= _commitLastBlock );\n', '        require (secretSigner == ecrecover(_signatureHash, v, r, s));\n', '\n', "        // Check that the bet is in 'clean' state.\n", '        Bet storage bet = bets[_commit];\n', '        require (bet.gambler == address(0));\n', '\n', '        //Ether balanceet\n', '        lockedInBets = lockedInBets.add(uint(placParameter[uint8(PlaceParam.possibleWinAmount)]));\n', '        require (uint(placParameter[uint8(PlaceParam.possibleWinAmount)]) <= msg.value.add(maxProfit));\n', '        require (lockedInBets <= address(this).balance);\n', '\n', '        // Store bet parameters on blockchain.\n', '        bet.amount = msg.value;\n', '        bet.placeBlockNumber = uint40(block.number);\n', '        bet.gambler = msg.sender;\n', '\n', '        emit PlaceBetLog(msg.sender, msg.value, uint8(placParameter[uint8(PlaceParam.RotateTime)]));\n', '    }\n', '\n', '    function placeTokenBet(uint[] placParameter,bytes32 _signatureHash , uint _commitLastBlock, uint _commit, bytes32 r, bytes32 s, uint8 v,uint _amount,address _playerAddress) external {\n', '        require (placParameter[uint8(PlaceParam.RotateTime)] != 0);\n', '        require (block.number <= _commitLastBlock );\n', '        require (secretSigner == ecrecover(_signatureHash, v, r, s));\n', '\n', "        // Check that the bet is in 'clean' state.\n", '        Bet storage bet = bets[_commit];\n', '        require (bet.gambler == address(0));\n', '\n', '        //Token bet\n', '        lockedTokenInBets = lockedTokenInBets.add(uint(placParameter[uint8(PlaceParam.possibleWinAmount)]));\n', '        require (uint(placParameter[uint8(PlaceParam.possibleWinAmount)]) <= _amount.add(maxTokenProfit));\n', '        require (lockedTokenInBets <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\n', '\n', '        // Store bet parameters on blockchain.\n', '        bet.amount = _amount;\n', '        bet.placeBlockNumber = uint40(block.number);\n', '        bet.gambler = _playerAddress;\n', '\n', '        emit PlaceBetLog(_playerAddress, _amount, uint8(placParameter[uint8(PlaceParam.RotateTime)]));\n', '    }\n', '\n', '    //Estimated maximum award amount\n', '     function getBonusPercentageByMachineMode(uint8 machineMode)public view returns( uint upperLimit,uint maxWithdrawalPercentage ){\n', '         uint limitIndex = machineMode.mul(2);\n', '         upperLimit = withdrawalMode[limitIndex];\n', '         maxWithdrawalPercentage = withdrawalMode[(limitIndex.add(1))];\n', '    }\n', '\n', '    // Settlement transaction\n', '     enum SettleParam {\n', '        Uplimit,\n', '        BonusPercentage,\n', '        RotateTime,\n', '        CurrencyType,\n', '        MachineMode,\n', '        PerWinAmount,\n', '        PerBetAmount,\n', '        PossibleWinAmount,\n', '        LuckySeed,\n', '        jackpotFee\n', '     }\n', '\n', '    function settleBet(uint[] combinationParameter, uint reveal) external {\n', '\n', '        // "commit" for bet settlement can only be obtained by hashing a "reveal".\n', '        uint commit = uint(keccak256(abi.encodePacked(reveal)));\n', '\n', '        // Fetch bet parameters into local variables (to save gas).\n', '        Bet storage bet = bets[commit];\n', '\n', "        // Check that bet is in 'active' state and check that bet has not expired yet.\n", '        require (bet.amount != 0);\n', '        require (block.number <= bet.placeBlockNumber.add(BetExpirationBlocks));\n', '\n', '        //The RNG - combine "reveal" and blockhash of LuckySeed using Keccak256.\n', '        bytes32 _entropy = keccak256(\n', '            abi.encodePacked(\n', '                uint(\n', '                    keccak256(\n', '                        abi.encodePacked(\n', '                            uint(\n', '                                keccak256(\n', '                                    abi.encodePacked(\n', '                                        reveal,\n', '                                        blockhash(combinationParameter[uint8(SettleParam.LuckySeed)])\n', '                                    )\n', '                                )\n', '                            ),\n', '                            blockhash(block.number)\n', '                        )\n', '                    )\n', '                ),\n', '                blockhash(block.timestamp)\n', '            )\n', '        );\n', '\n', '         uint totalAmount = 0;\n', '         uint totalTokenAmount = 0;\n', '         uint totalJackpotWin = 0;\n', '         (totalAmount,totalTokenAmount,totalJackpotWin) = runRotateTime(combinationParameter,_entropy,keccak256(abi.encodePacked(uint(_entropy), blockhash(combinationParameter[uint8(SettleParam.LuckySeed)]))));\n', '\n', '        // Add ether JackpotBouns\n', '        if (totalJackpotWin > 0 && combinationParameter[uint8(SettleParam.CurrencyType)] == 0) {\n', '              emit JackpotBouns(bet.gambler,totalJackpotWin);\n', '              totalAmount = totalAmount.add(totalJackpotWin);\n', '              jackpotSize = uint128(jackpotSize.sub(totalJackpotWin));\n', '        }else if (totalJackpotWin > 0 && combinationParameter[uint8(SettleParam.CurrencyType)] == 1) {\n', '              // Add token TokenJackpotBouns\n', '\n', '              emit TokenJackpotBouns(bet.gambler,totalJackpotWin);\n', '              totalAmount = totalAmount.add(totalJackpotWin);\n', '                tokenJackpotSize = uint128(tokenJackpotSize.sub(totalJackpotWin));\n', '        }\n', '\n', '        emit BetRelatedData(bet.gambler,bet.amount,totalAmount,_entropy,keccak256(abi.encodePacked(uint(_entropy), blockhash(combinationParameter[uint8(SettleParam.LuckySeed)]))),uint8(combinationParameter[uint8(SettleParam.Uplimit)]),uint8(combinationParameter[uint8(SettleParam.RotateTime)]));\n', '\n', '        if (combinationParameter[uint8(SettleParam.CurrencyType)] == 0) {\n', '              //Ether game\n', '            if (totalAmount != 0){\n', '                sendFunds(bet.gambler, totalAmount , totalAmount);\n', '            }\n', '\n', '            //Send ERC20 Token\n', '            if (totalTokenAmount != 0){\n', '\n', '                if(ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\n', '                    ERC20(ERC20ContractAddres).transfer(bet.gambler, totalTokenAmount);\n', '                    emit TokenPayment(bet.gambler, totalTokenAmount);\n', '                }\n', '            }\n', '        }else if(combinationParameter[uint8(SettleParam.CurrencyType)] == 1){\n', '              //ERC20 game\n', '\n', '            //Send ERC20 Token\n', '            if (totalAmount != 0){\n', '                if(ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\n', '                    ERC20(ERC20ContractAddres).transfer(bet.gambler, totalAmount);\n', '                    emit TokenPayment(bet.gambler, totalAmount);\n', '                }\n', '            }\n', '        }\n', '\n', '                // Unlock the bet amount, regardless of the outcome.\n', '        if (combinationParameter[uint8(SettleParam.CurrencyType)] == 0) {\n', '                lockedInBets = lockedInBets.sub(combinationParameter[uint8(SettleParam.PossibleWinAmount)]);\n', '        } else if (combinationParameter[uint8(SettleParam.CurrencyType)] == 1){\n', '                lockedTokenInBets = lockedTokenInBets.sub(combinationParameter[uint8(SettleParam.PossibleWinAmount)]);\n', '        }\n', '\n', "        //Move bet into 'processed' state already.\n", '        bet.amount = 0;\n', '\n', '        //Save jackpotSize\n', '         if (uint16(combinationParameter[uint8(SettleParam.CurrencyType)]) == 0) {\n', '            jackpotSize = jackpotSize.add(uint(combinationParameter[uint8(SettleParam.jackpotFee)]));\n', '        }else if (uint16(combinationParameter[uint8(SettleParam.CurrencyType)]) == 1) {\n', '            tokenJackpotSize = tokenJackpotSize.add(uint(combinationParameter[uint8(SettleParam.jackpotFee)]));\n', '        }\n', '    }\n', '\n', '\n', '    function runRotateTime ( uint[] combinationParameter, bytes32 _entropy ,bytes32 _entropy2)private view  returns(uint totalAmount,uint totalTokenAmount,uint totalJackpotWin) {\n', '\n', '        bytes32 resultMask = 0xF000000000000000000000000000000000000000000000000000000000000000;\n', '        bytes32 tmp_entropy;\n', '        bytes32 tmp_Mask = resultMask;\n', '\n', '        bool isGetJackpot = false;\n', '\n', '        for (uint8 i = 0; i < combinationParameter[uint8(SettleParam.RotateTime)]; i++) {\n', '            if (i < 64){\n', '                tmp_entropy = _entropy & tmp_Mask;\n', '                tmp_entropy = tmp_entropy >> (4*(64 - (i.add(1))));\n', '                tmp_Mask =  tmp_Mask >> 4;\n', '            }else{\n', '                if ( i == 64){\n', '                    tmp_Mask = resultMask;\n', '                }\n', '                tmp_entropy = _entropy2 & tmp_Mask;\n', '                tmp_entropy = tmp_entropy >> (4*( 64 - (i%63)));\n', '                tmp_Mask =  tmp_Mask >> 4;\n', '            }\n', '\n', '            if ( uint(tmp_entropy) < uint(combinationParameter[uint8(SettleParam.Uplimit)]) ){\n', '                //bet win\n', '                totalAmount = totalAmount.add(combinationParameter[uint8(SettleParam.PerWinAmount)]);\n', '\n', '                //Platform fee determination:Winning players must pay platform fees\n', '                uint platformFees = combinationParameter[uint8(SettleParam.PerBetAmount)].mul(platformFeePercentage);\n', '                platformFees = platformFees.div(1000);\n', '                totalAmount = totalAmount.sub(platformFees);\n', '            }else{\n', '                //bet lose\n', '                if (uint(combinationParameter[uint8(SettleParam.CurrencyType)]) == 0){\n', '\n', '                    if(ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\n', '                        //get token reward\n', '                        uint rewardAmount = uint(combinationParameter[uint8(SettleParam.PerBetAmount)]).mul(ERC20rewardMultiple);\n', '                        totalTokenAmount = totalTokenAmount.add(rewardAmount);\n', '                    }\n', '                }\n', '            }\n', '\n', '            //Get jackpotWin Result\n', '            if (isGetJackpot == false){\n', '                isGetJackpot = getJackpotWinBonus(i,_entropy,_entropy2);\n', '            }\n', '        }\n', '\n', '        if (isGetJackpot == true && combinationParameter[uint8(SettleParam.CurrencyType)] == 0) {\n', '            //gambler get ether bonus.\n', '            totalJackpotWin = jackpotSize;\n', '        }else if (isGetJackpot == true && combinationParameter[uint8(SettleParam.CurrencyType)] == 1) {\n', '            //gambler get token bonus.\n', '            totalJackpotWin = tokenJackpotSize;\n', '        }\n', '    }\n', '\n', '    function getJackpotWinBonus (uint8 i,bytes32 entropy,bytes32 entropy2) private pure returns (bool isGetJackpot) {\n', '        bytes32 one;\n', '        bytes32 two;\n', '        bytes32 three;\n', '        bytes32 four;\n', '\n', '        bytes32 resultMask = 0xF000000000000000000000000000000000000000000000000000000000000000;\n', '        bytes32 jackpo_Mask = resultMask;\n', '\n', '        if (i < 61){\n', '            one = (entropy & jackpo_Mask) >> 4*(64 - (i + 1));\n', '                jackpo_Mask =  jackpo_Mask >> 4;\n', '            two = (entropy & jackpo_Mask)  >> (4*(64 - (i + 2)));\n', '                jackpo_Mask =  jackpo_Mask >> 4;\n', '            three = (entropy & jackpo_Mask) >> (4*(64 - (i + 3)));\n', '                jackpo_Mask =  jackpo_Mask >> 4;\n', '            four = (entropy & jackpo_Mask) >> (4*(64 - (i + 4)));\n', '                jackpo_Mask =  jackpo_Mask << 8;\n', '        }\n', '        else if(i >= 61){\n', '            if(i == 61){\n', '                one = (entropy & jackpo_Mask) >> 4*(64 - (i + 1));\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                two = (entropy & jackpo_Mask)  >> (4*(64 - (i + 2)));\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                three = (entropy & jackpo_Mask) >> (4*(64 - (i + 3)));\n', '                    jackpo_Mask =  jackpo_Mask << 4;\n', '                four = (entropy2 & 0xF000000000000000000000000000000000000000000000000000000000000000) >> 4*63;\n', '            }\n', '            else if(i == 62){\n', '                one = (entropy & jackpo_Mask) >> 4*(64 - (i + 1));\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                two = (entropy & jackpo_Mask)  >> (4*(64 - (i + 2)));\n', '                three = (entropy2 & 0xF000000000000000000000000000000000000000000000000000000000000000) >> 4*63;\n', '                four =  (entropy2 & 0x0F00000000000000000000000000000000000000000000000000000000000000) >> 4*62;\n', '            }\n', '            else if(i == 63){\n', '                one = (entropy & jackpo_Mask) >> 4*(64 - (i + 1));\n', '                two = (entropy2 & 0xF000000000000000000000000000000000000000000000000000000000000000)  >> 4*63;\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                three = (entropy2 & 0x0F00000000000000000000000000000000000000000000000000000000000000) >> 4*62;\n', '                    jackpo_Mask =  jackpo_Mask << 4;\n', '                four = (entropy2 & 0x00F0000000000000000000000000000000000000000000000000000000000000) >> 4*61;\n', '\n', '                    jackpo_Mask = 0xF000000000000000000000000000000000000000000000000000000000000000;\n', '            }\n', '            else {\n', '                one = (entropy2 & jackpo_Mask) >>  (4*( 64 - (i%64 + 1)));\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                two = (entropy2 & jackpo_Mask)  >> (4*( 64 - (i%64 + 2)))   ;\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                three = (entropy2 & jackpo_Mask) >> (4*( 64 - (i%64 + 3))) ;\n', '                    jackpo_Mask =  jackpo_Mask >> 4;\n', '                four = (entropy2 & jackpo_Mask) >>(4*( 64 - (i%64 + 4)));\n', '                    jackpo_Mask =  jackpo_Mask << 8;\n', '            }\n', '        }\n', '\n', '        if ((one ^ 0xF) == 0 && (two ^ 0xF) == 0 && (three ^ 0xF) == 0 && (four ^ 0xF) == 0){\n', '            isGetJackpot = true;\n', '       }\n', '    }\n', '\n', '    //Get deductedBalance\n', '    function getPossibleWinAmount(uint bonusPercentage,uint senderValue)public view returns (uint platformFee,uint jackpotFee,uint possibleWinAmount) {\n', '\n', '        //Platform Fee\n', '        uint prePlatformFee = (senderValue).mul(platformFeePercentage);\n', '        platformFee = (prePlatformFee).div(1000);\n', '\n', '        //Get jackpotFee\n', '        uint preJackpotFee = (senderValue).mul(jackpotFeePercentage);\n', '        jackpotFee = (preJackpotFee).div(1000);\n', '\n', '        //Win Amount\n', '        uint preUserGetAmount = senderValue.mul(bonusPercentage);\n', '        possibleWinAmount = preUserGetAmount.div(10000);\n', '    }\n', '\n', '    // Refund transaction\n', '    function refundBet(uint commit,uint8 machineMode) external {\n', "        // Check that bet is in 'active' state.\n", '        Bet storage bet = bets[commit];\n', '        uint amount = bet.amount;\n', '\n', '        require (amount != 0, "Bet should be in an \'active\' state");\n', '\n', '        // Check that bet has already expired.\n', '        require (block.number > bet.placeBlockNumber.add(BetExpirationBlocks));\n', '\n', "        // Move bet into 'processed' state, release funds.\n", '        bet.amount = 0;\n', '\n', '        //Maximum amount to be confirmed\n', '        uint platformFee;\n', '        uint jackpotFee;\n', '        uint possibleWinAmount;\n', '        uint upperLimit;\n', '        uint maxWithdrawalPercentage;\n', '        (upperLimit,maxWithdrawalPercentage) = getBonusPercentageByMachineMode(machineMode);\n', '        (platformFee, jackpotFee, possibleWinAmount) = getPossibleWinAmount(maxWithdrawalPercentage,amount);\n', '\n', '        //Amount unlock\n', '        lockedInBets = lockedInBets.sub(possibleWinAmount);\n', '\n', '        //Refund\n', '        sendFunds(bet.gambler, amount, amount);\n', '    }\n', '\n', '    function refundTokenBet(uint commit,uint8 machineMode) external {\n', "        // Check that bet is in 'active' state.\n", '        Bet storage bet = bets[commit];\n', '        uint amount = bet.amount;\n', '\n', '        require (amount != 0, "Bet should be in an \'active\' state");\n', '\n', '        // Check that bet has already expired.\n', '        require (block.number > bet.placeBlockNumber.add(BetExpirationBlocks));\n', '\n', "        // Move bet into 'processed' state, release funds.\n", '        bet.amount = 0;\n', '\n', '        //Maximum amount to be confirmed\n', '        uint platformFee;\n', '        uint jackpotFee;\n', '        uint possibleWinAmount;\n', '        uint upperLimit;\n', '        uint maxWithdrawalPercentage;\n', '        (upperLimit,maxWithdrawalPercentage) = getBonusPercentageByMachineMode(machineMode);\n', '        (platformFee, jackpotFee, possibleWinAmount) = getPossibleWinAmount(maxWithdrawalPercentage,amount);\n', '\n', '        //Amount unlock\n', '        lockedTokenInBets = uint128(lockedTokenInBets.sub(possibleWinAmount));\n', '\n', '        //Refund\n', '        ERC20(ERC20ContractAddres).transfer(bet.gambler, amount);\n', '        emit TokenPayment(bet.gambler, amount);\n', '    }\n', '\n', '    // A helper routine to bulk clean the storage.\n', '    function clearStorage(uint[] cleanCommits) external {\n', '        uint length = cleanCommits.length;\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            clearProcessedBet(cleanCommits[i]);\n', '        }\n', '    }\n', '\n', "    // Helper routine to move 'processed' bets into 'clean' state.\n", '    function clearProcessedBet(uint commit) private {\n', '        Bet storage bet = bets[commit];\n', '\n', '        // Do not overwrite active bets with zeros\n', '        if (bet.amount != 0 || block.number <= bet.placeBlockNumber + BetExpirationBlocks) {\n', '            return;\n', '        }\n', '\n', '        // Zero out the remaining storage\n', '        bet.placeBlockNumber = 0;\n', '        bet.gambler = address(0);\n', '    }\n', '\n', '    // Helper routine to process the payment.\n', '    function sendFunds(address beneficiary, uint amount, uint successLogAmount) private {\n', '        if (beneficiary.send(amount)) {\n', '            emit Payment(beneficiary, successLogAmount);\n', '        } else {\n', '            emit FailedPayment(beneficiary, amount);\n', '        }\n', '    }\n', '\n', '     function sendFundsToManager(uint amount) external onlyOwner {\n', '        if (manager.send(amount)) {\n', '            emit ToManagerPayment(manager, amount);\n', '        } else {\n', '            emit ToManagerFailedPayment(manager, amount);\n', '        }\n', '    }\n', '\n', '    function sendTokenFundsToManager( uint amount) external onlyOwner {\n', '        ERC20(ERC20ContractAddres).transfer(manager, amount);\n', '        emit TokenPayment(manager, amount);\n', '    }\n', '\n', '    function sendFundsToOwner(address beneficiary, uint amount) external onlyOwner {\n', '        if (beneficiary.send(amount)) {\n', '            emit ToOwnerPayment(beneficiary, amount);\n', '        } else {\n', '            emit ToOwnerFailedPayment(beneficiary, amount);\n', '        }\n', '    }\n', '\n', '    //Update\n', '    function updateMIN_BET(uint _uintNumber)public onlyManager {\n', '         MIN_BET = _uintNumber;\n', '    }\n', '\n', '    function updateMAX_BET(uint _uintNumber)public onlyManager {\n', '         MAX_BET = _uintNumber;\n', '    }\n', '\n', '    function updateMAX_AMOUNT(uint _uintNumber)public onlyManager {\n', '         MAX_AMOUNT = _uintNumber;\n', '    }\n', '\n', '    function updateWithdrawalModeByIndex(uint8 _index, uint32 _value) public onlyManager{\n', '       withdrawalMode[_index]  = _value;\n', '    }\n', '\n', '    function updateWithdrawalMode( uint32[] _withdrawalMode) public onlyManager{\n', '       withdrawalMode  = _withdrawalMode;\n', '    }\n', '\n', '    function updateBitComparisonMask(bytes32 _newBitComparisonMask ) public onlyOwner{\n', '       bitComparisonMask = _newBitComparisonMask;\n', '    }\n', '\n', '    function updatePlatformFeePercentage(uint8 _platformFeePercentage ) public onlyOwner{\n', '       platformFeePercentage = _platformFeePercentage;\n', '    }\n', '\n', '    function updateJackpotFeePercentage(uint8 _jackpotFeePercentage ) public onlyOwner{\n', '       jackpotFeePercentage = _jackpotFeePercentage;\n', '    }\n', '\n', '    function updateERC20rewardMultiple(uint8 _ERC20rewardMultiple ) public onlyManager{\n', '       ERC20rewardMultiple = _ERC20rewardMultiple;\n', '    }\n', '}']