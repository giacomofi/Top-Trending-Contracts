['/**\n', ' * Copyright 2017-2019, bZeroX, LLC. All Rights Reserved.\n', ' * Licensed under the Apache License, Version 2.0.\n', ' */\n', ' \n', 'pragma solidity 0.5.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title EIP20/ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract EIP20 is ERC20 {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '}\n', '\n', 'contract WETHInterface is EIP20 {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 wad) external;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, rounding up and truncating the quotient\n', '  */\n', '  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    return ((_a - 1) / _b) + 1;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\n', '  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\n', '  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\n', '\n', '  /// @dev Constant for locked guard state\n', '  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one `nonReentrant` function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and an `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(reentrancyLock == REENTRANCY_GUARD_FREE, "nonReentrant");\n', '    reentrancyLock = REENTRANCY_GUARD_LOCKED;\n', '    _;\n', '    reentrancyLock = REENTRANCY_GUARD_FREE;\n', '  }\n', '\n', '}\n', '\n', 'contract LoanTokenization is ReentrancyGuard, Ownable {\n', '\n', '    uint256 internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    address public bZxContract;\n', '    address public bZxVault;\n', '    address public bZxOracle;\n', '    address public wethContract;\n', '\n', '    address public loanTokenAddress;\n', '\n', '    // price of token at last user checkpoint\n', '    mapping (address => uint256) internal checkpointPrices_;\n', '}\n', '\n', 'contract LoanTokenStorage is LoanTokenization {\n', '\n', '    struct ListIndex {\n', '        uint256 index;\n', '        bool isSet;\n', '    }\n', '\n', '    struct LoanData {\n', '        bytes32 loanOrderHash;\n', '        uint256 leverageAmount;\n', '        uint256 initialMarginAmount;\n', '        uint256 maintenanceMarginAmount;\n', '        uint256 maxDurationUnixTimestampSec;\n', '        uint256 index;\n', '    }\n', '\n', '    struct TokenReserves {\n', '        address lender;\n', '        uint256 amount;\n', '    }\n', '\n', '    event Borrow(\n', '        address indexed borrower,\n', '        uint256 borrowAmount,\n', '        uint256 interestRate,\n', '        address collateralTokenAddress,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen\n', '    );\n', '\n', '    event Claim(\n', '        address indexed claimant,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 remainingTokenAmount,\n', '        uint256 price\n', '    );\n', '\n', '    bool internal isInitialized_ = false;\n', '\n', '    address public tokenizedRegistry;\n', '\n', '    uint256 public baseRate = 1000000000000000000; // 1.0%\n', '    uint256 public rateMultiplier = 39000000000000000000; // 39%\n', '\n', '    // "fee percentage retained by the oracle" = SafeMath.sub(10**20, spreadMultiplier);\n', '    uint256 public spreadMultiplier;\n', '\n', '    mapping (uint256 => bytes32) public loanOrderHashes; // mapping of levergeAmount to loanOrderHash\n', '    mapping (bytes32 => LoanData) public loanOrderData; // mapping of loanOrderHash to LoanOrder\n', '    uint256[] public leverageList;\n', '\n', '    TokenReserves[] public burntTokenReserveList; // array of TokenReserves\n', '    mapping (address => ListIndex) public burntTokenReserveListIndex; // mapping of lender address to ListIndex objects\n', '    uint256 public burntTokenReserved; // total outstanding burnt token amount\n', '    address internal nextOwedLender_;\n', '\n', '    uint256 public totalAssetBorrow = 0; // current amount of loan token amount tied up in loans\n', '\n', '    uint256 internal checkpointSupply_;\n', '\n', '    uint256 internal lastSettleTime_;\n', '\n', '    uint256 public initialPrice;\n', '}\n', '\n', 'contract AdvancedTokenStorage is LoanTokenStorage {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Mint(\n', '        address indexed minter,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '    event Burn(\n', '        address indexed burner,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 internal totalSupply_;\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract AdvancedToken is AdvancedTokenStorage {\n', '    using SafeMath for uint256;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function _mint(\n', '        address _to,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '    {\n', '        require(_to != address(0), "invalid address");\n', '        totalSupply_ = totalSupply_.add(_tokenAmount);\n', '        balances[_to] = balances[_to].add(_tokenAmount);\n', '\n', '        emit Mint(_to, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(address(0), _to, _tokenAmount);\n', '    }\n', '\n', '    function _burn(\n', '        address _who,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '    {\n', '        require(_tokenAmount <= balances[_who], "burn value exceeds balance");\n', '        // no need to require value <= totalSupply, since that would imply the\n', "        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '        balances[_who] = balances[_who].sub(_tokenAmount);\n', "        if (balances[_who] <= 10) { // we can't leave such small balance quantities\n", '            _tokenAmount = _tokenAmount.add(balances[_who]);\n', '            balances[_who] = 0;\n', '        }\n', '\n', '        totalSupply_ = totalSupply_.sub(_tokenAmount);\n', '\n', '        emit Burn(_who, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(_who, address(0), _tokenAmount);\n', '    }\n', '}\n', '\n', 'contract BZxObjects {\n', '\n', '    struct LoanOrder {\n', '        address loanTokenAddress;\n', '        address interestTokenAddress;\n', '        address collateralTokenAddress;\n', '        address oracleAddress;\n', '        uint256 loanTokenAmount;\n', '        uint256 interestAmount;\n', '        uint256 initialMarginAmount;\n', '        uint256 maintenanceMarginAmount;\n', '        uint256 maxDurationUnixTimestampSec;\n', '        bytes32 loanOrderHash;\n', '    }\n', '\n', '    struct LoanPosition {\n', '        address trader;\n', '        address collateralTokenAddressFilled;\n', '        address positionTokenAddressFilled;\n', '        uint256 loanTokenAmountFilled;\n', '        uint256 loanTokenAmountUsed;\n', '        uint256 collateralTokenAmountFilled;\n', '        uint256 positionTokenAmountFilled;\n', '        uint256 loanStartUnixTimestampSec;\n', '        uint256 loanEndUnixTimestampSec;\n', '        bool active;\n', '        uint256 positionId;\n', '    }\n', '}\n', '\n', 'contract OracleNotifierInterface {\n', '\n', '    function closeLoanNotifier(\n', '        BZxObjects.LoanOrder memory loanOrder,\n', '        BZxObjects.LoanPosition memory loanPosition,\n', '        address loanCloser,\n', '        uint256 closeAmount,\n', '        bool isLiquidation)\n', '        public\n', '        returns (bool);\n', '}\n', '\n', 'interface IBZx {\n', '    function pushLoanOrderOnChain(\n', '        address[8] calldata orderAddresses,\n', '        uint256[11] calldata orderValues,\n', '        bytes calldata oracleData,\n', '        bytes calldata signature)\n', '        external\n', '        returns (bytes32); // loanOrderHash\n', '\n', '    function setLoanOrderDesc(\n', '        bytes32 loanOrderHash,\n', '        string calldata desc)\n', '        external\n', '        returns (bool);\n', '\n', '    function updateLoanAsLender(\n', '        bytes32 loanOrderHash,\n', '        uint256 increaseAmountForLoan,\n', '        uint256 newInterestRate,\n', '        uint256 newExpirationTimestamp)\n', '        external\n', '        returns (bool);\n', '\n', '    function takeLoanOrderOnChainAsTraderByDelegate(\n', '        address trader,\n', '        bytes32 loanOrderHash,\n', '        address collateralTokenFilled,\n', '        uint256 loanTokenAmountFilled,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen)\n', '        external\n', '        returns (uint256);\n', '\n', '    function getLenderInterestForOracle(\n', '        address lender,\n', '        address oracleAddress,\n', '        address interestTokenAddress)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,    // interestPaid\n', '            uint256,    // interestPaidDate\n', '            uint256,    // interestOwedPerDay\n', '            uint256);   // interestUnPaid\n', '\n', '    function oracleAddresses(\n', '        address oracleAddress)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'interface IBZxOracle {\n', '    function tradeUserAsset(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        address receiverAddress,\n', '        address returnToSenderAddress,\n', '        uint256 sourceTokenAmount,\n', '        uint256 maxDestTokenAmount,\n', '        uint256 minConversionRate)\n', '        external\n', '        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed);\n', '\n', '    function interestFeePercent()\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface iTokenizedRegistry {\n', '    function getTokenAsset(\n', '        address _token,\n', '        uint256 _tokenType)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'contract LoanTokenLogic is AdvancedToken, OracleNotifierInterface {\n', '    using SafeMath for uint256;\n', '\n', '    modifier onlyOracle() {\n', '        require(msg.sender == IBZx(bZxContract).oracleAddresses(bZxOracle), "unauthorized");\n', '        _;\n', '    }\n', '\n', '\n', '    function()\n', '        external\n', '        payable\n', '    {}\n', '\n', '\n', '    /* Public functions */\n', '\n', '    function mintWithEther(\n', '        address receiver)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        returns (uint256 mintAmount)\n', '    {\n', '        require(loanTokenAddress == wethContract, "no ether");\n', '        return _mintToken(\n', '            receiver,\n', '            msg.value\n', '        );\n', '    }\n', '\n', '    function mint(\n', '        address receiver,\n', '        uint256 depositAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256 mintAmount)\n', '    {\n', '        return _mintToken(\n', '            receiver,\n', '            depositAmount\n', '        );\n', '    }\n', '\n', '    function burnToEther(\n', '        address payable receiver,\n', '        uint256 burnAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        require(loanTokenAddress == wethContract, "no ether");\n', '        loanAmountPaid = _burnToken(\n', '            receiver,\n', '            burnAmount\n', '        );\n', '\n', '        if (loanAmountPaid > 0) {\n', '            WETHInterface(wethContract).withdraw(loanAmountPaid);\n', '            require(receiver.send(loanAmountPaid), "transfer failed");\n', '        }\n', '    }\n', '\n', '    function burn(\n', '        address receiver,\n', '        uint256 burnAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        loanAmountPaid = _burnToken(\n', '            receiver,\n', '            burnAmount\n', '        );\n', '\n', '        if (loanAmountPaid > 0) {\n', '            require(ERC20(loanTokenAddress).transfer(\n', '                receiver,\n', '                loanAmountPaid\n', '            ), "transfer failed");\n', '        }\n', '    }\n', '\n', '    // called by a borrower to open a loan\n', '    // loan can be collateralized using any supported token (collateralTokenAddress)\n', '    // interest collected is denominated the same as loanToken\n', '    // returns borrowAmount\n', '    function borrowToken(\n', '        uint256 borrowAmount,\n', '        uint256 leverageAmount,\n', '        address collateralTokenAddress,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen)\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        uint256 amount = _borrowToken(\n', '            msg.sender,\n', '            borrowAmount,\n', '            leverageAmount,\n', '            collateralTokenAddress,\n', '            tradeTokenToFillAddress,\n', '            withdrawOnOpen,\n', '            false // calcBorrow\n', '        );\n', '        require(amount > 0, "can\'t borrow");\n', '        return amount;\n', '    }\n', '\n', '    // called by a borrower to open a loan\n', '    // escrowAmount == total collateral + interest available to back the loan\n', '    // escrowAmount is denominated the same as loanToken\n', '    // returns borrowAmount\n', '    function borrowTokenFromEscrow(\n', '        uint256 escrowAmount,\n', '        uint256 leverageAmount,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen)\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        uint256 amount = _borrowToken(\n', '            msg.sender,\n', '            escrowAmount,\n', '            leverageAmount,\n', '            loanTokenAddress, // collateralTokenAddress\n', '            tradeTokenToFillAddress,\n', '            withdrawOnOpen,\n', '            true // calcBorrow\n', '        );\n', '        require(amount > 0, "can\'t borrow");\n', '        return amount;\n', '    }\n', '\n', '    function rolloverPosition(\n', '        address borrower,\n', '        uint256 leverageAmount,\n', '        uint256 escrowAmount,\n', '        address tradeTokenToFillAddress)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        require(msg.sender == address(this), "unauthorized");\n', '\n', '        return _borrowToken(\n', '            borrower,\n', '            escrowAmount,\n', '            leverageAmount,\n', '            loanTokenAddress, // collateralTokenAddress\n', '            tradeTokenToFillAddress,\n', '            false, // withdrawOnOpen\n', '            true // calcBorrow\n', '        );\n', '    }\n', '\n', '    // Claims owned loan token for the caller\n', '    // Also claims for user with the longest reserves\n', '    // returns amount claimed for the caller\n', '    function claimLoanToken()\n', '        external\n', '        nonReentrant\n', '        returns (uint256 claimedAmount)\n', '    {\n', '        claimedAmount = _claimLoanToken(msg.sender);\n', '\n', '        if (burntTokenReserveList.length > 0) {\n', '            _claimLoanToken(_getNextOwed());\n', '\n', '            if (burntTokenReserveListIndex[msg.sender].isSet && nextOwedLender_ != msg.sender) {\n', '                // ensure lender is paid next\n', '                nextOwedLender_ = msg.sender;\n', '            }\n', '        }\n', '    }\n', '\n', '    function settleInterest()\n', '        external\n', '        nonReentrant\n', '    {\n', '        _settleInterest();\n', '    }\n', '\n', '    function wrapEther()\n', '        public\n', '    {\n', '        if (address(this).balance > 0) {\n', '            WETHInterface(wethContract).deposit.value(address(this).balance)();\n', '        }\n', '    }\n', '\n', '    // Sends non-LoanToken assets to the Oracle fund\n', '    // These are assets that would otherwise be "stuck" due to a user accidently sending them to the contract\n', '    function donateAsset(\n', '        address tokenAddress)\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (tokenAddress == loanTokenAddress)\n', '            return false;\n', '\n', '        uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\n', '        if (balance == 0)\n', '            return false;\n', '\n', '        require(ERC20(tokenAddress).transfer(\n', '            IBZx(bZxContract).oracleAddresses(bZxOracle),\n', '            balance\n', '        ), "transfer failed");\n', '\n', '        return true;\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_value <= balances[msg.sender], "insufficient balance");\n', '        require(_to != address(0), "token burn not allowed");\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // handle checkpoint update\n', '        uint256 currentPrice = tokenPrice();\n', '        if (burntTokenReserveListIndex[msg.sender].isSet || balances[msg.sender] > 0) {\n', '            checkpointPrices_[msg.sender] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[msg.sender] = 0;\n', '        }\n', '        if (burntTokenReserveListIndex[_to].isSet || balances[_to] > 0) {\n', '            checkpointPrices_[_to] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_to] = 0;\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 allowanceAmount = allowed[_from][msg.sender];\n', '        require(_value <= balances[_from], "insufficient balance");\n', '        require(_value <= allowanceAmount, "insufficient allowance");\n', '        require(_to != address(0), "token burn not allowed");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        if (allowanceAmount < MAX_UINT) {\n', '            allowed[_from][msg.sender] = allowanceAmount.sub(_value);\n', '        }\n', '\n', '        // handle checkpoint update\n', '        uint256 currentPrice = tokenPrice();\n', '        if (burntTokenReserveListIndex[_from].isSet || balances[_from] > 0) {\n', '            checkpointPrices_[_from] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_from] = 0;\n', '        }\n', '        if (burntTokenReserveListIndex[_to].isSet || balances[_to] > 0) {\n', '            checkpointPrices_[_to] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[_to] = 0;\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* Public View functions */\n', '\n', '    function tokenPrice()\n', '        public\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        uint256 interestUnPaid = 0;\n', '        if (lastSettleTime_ != block.timestamp) {\n', '            (,,interestUnPaid) = _getAllInterest();\n', '\n', '            interestUnPaid = interestUnPaid\n', '                .mul(spreadMultiplier)\n', '                .div(10**20);\n', '        }\n', '\n', '        return _tokenPrice(_totalAssetSupply(interestUnPaid));\n', '    }\n', '\n', '    function checkpointPrice(\n', '        address _user)\n', '        public\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        return checkpointPrices_[_user];\n', '    }\n', '\n', '    function totalReservedSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return burntTokenReserved.mul(tokenPrice()).div(10**18);\n', '    }\n', '\n', '    function marketLiquidity()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalSupply = totalAssetSupply();\n', '        uint256 reservedSupply = totalReservedSupply();\n', '        if (totalSupply > reservedSupply) {\n', '            totalSupply = totalSupply.sub(reservedSupply);\n', '        } else {\n', '            return 0;\n', '        }\n', '\n', '        if (totalSupply > totalAssetBorrow) {\n', '            return totalSupply.sub(totalAssetBorrow);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // interest that borrowers are currently paying for open loans, prior to any fees\n', '    function borrowInterestRate()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (totalAssetBorrow > 0) {\n', '            return _protocolInterestRate(totalAssetSupply());\n', '        } else {\n', '            return baseRate;\n', '        }\n', '    }\n', '\n', '    // interest that lenders are currently receiving for open loans, prior to any fees\n', '    function supplyInterestRate()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 assetSupply = totalAssetSupply();\n', '        if (totalAssetBorrow > 0) {\n', '            return _protocolInterestRate(assetSupply)\n', '                .mul(_getUtilizationRate(assetSupply))\n', '                .div(10**40);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // the rate the next base protocol borrower will receive based on the amount being borrowed\n', '    function nextLoanInterestRate(\n', '        uint256 borrowAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (borrowAmount > 0) {\n', '            uint256 interestUnPaid = 0;\n', '            if (lastSettleTime_ != block.timestamp) {\n', '                (,,interestUnPaid) = _getAllInterest();\n', '\n', '                interestUnPaid = interestUnPaid\n', '                    .mul(spreadMultiplier)\n', '                    .div(10**20);\n', '            }\n', '\n', '            uint256 balance = ERC20(loanTokenAddress).balanceOf(address(this)).add(interestUnPaid);\n', '            if (borrowAmount > balance) {\n', '                borrowAmount = balance;\n', '            }\n', '        }\n', '\n', '        return _nextLoanInterestRate(borrowAmount);\n', '    }\n', '\n', '    // returns the total amount of interest earned for all active loans\n', '    function interestReceived()\n', '        public\n', '        view\n', '        returns (uint256 interestTotalAccrued)\n', '    {\n', '        (uint256 interestPaidSoFar,,uint256 interestUnPaid) = _getAllInterest();\n', '\n', '        return interestPaidSoFar\n', '            .add(interestUnPaid)\n', '            .mul(spreadMultiplier)\n', '            .div(10**20);\n', '    }\n', '\n', '    function totalAssetSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 interestUnPaid = 0;\n', '        if (lastSettleTime_ != block.timestamp) {\n', '            (,,interestUnPaid) = _getAllInterest();\n', '\n', '            interestUnPaid = interestUnPaid\n', '                .mul(spreadMultiplier)\n', '                .div(10**20);\n', '        }\n', '\n', '        return _totalAssetSupply(interestUnPaid);\n', '    }\n', '\n', '    function getMaxEscrowAmount(\n', '        uint256 leverageAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        LoanData memory loanData = loanOrderData[loanOrderHashes[leverageAmount]];\n', '        if (loanData.initialMarginAmount == 0)\n', '            return 0;\n', '\n', '        return marketLiquidity()\n', '            .mul(loanData.initialMarginAmount)\n', '            .div(_adjustValue(\n', '                10**20, // maximum possible interest (100%)\n', '                loanData.maxDurationUnixTimestampSec,\n', '                loanData.initialMarginAmount));\n', '    }\n', '\n', '    function getBorrowAmount(\n', '        uint256 escrowAmount,\n', '        uint256 leverageAmount,\n', '        bool withdrawOnOpen)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (escrowAmount == 0)\n', '            return 0;\n', '\n', '        LoanData memory loanData = loanOrderData[loanOrderHashes[leverageAmount]];\n', '        if (loanData.initialMarginAmount == 0)\n', '            return 0;\n', '\n', '        return _getBorrowAmount(\n', '            loanData.initialMarginAmount,\n', '            escrowAmount,\n', '            nextLoanInterestRate(\n', '                escrowAmount\n', '                    .mul(10**20)\n', '                    .div(loanData.initialMarginAmount)\n', '            ),\n', '            loanData.maxDurationUnixTimestampSec,\n', '            withdrawOnOpen\n', '        );\n', '    }\n', '\n', '    function getLoanData(\n', '        uint256 levergeAmount)\n', '        public\n', '        view\n', '        returns (LoanData memory)\n', '    {\n', '        return loanOrderData[loanOrderHashes[levergeAmount]];\n', '    }\n', '\n', '    function getLeverageList()\n', '        public\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        return leverageList;\n', '    }\n', '\n', "    // returns the user's balance of underlying token\n", '    function assetBalanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balanceOf(_owner)\n', '            .mul(tokenPrice())\n', '            .div(10**18);\n', '    }\n', '\n', '\n', '    /* Internal functions */\n', '\n', '    function _mintToken(\n', '        address receiver,\n', '        uint256 depositAmount)\n', '        internal\n', '        returns (uint256 mintAmount)\n', '    {\n', '        require (depositAmount > 0, "amount == 0");\n', '\n', '        if (burntTokenReserveList.length > 0) {\n', '            _claimLoanToken(_getNextOwed());\n', '            _claimLoanToken(receiver);\n', '            if (msg.sender != receiver)\n', '                _claimLoanToken(msg.sender);\n', '        } else {\n', '            _settleInterest();\n', '        }\n', '\n', '        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\n', '        mintAmount = depositAmount.mul(10**18).div(currentPrice);\n', '\n', '        if (msg.value == 0) {\n', '            require(ERC20(loanTokenAddress).transferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                depositAmount\n', '            ), "transfer failed");\n', '        } else {\n', '            WETHInterface(wethContract).deposit.value(depositAmount)();\n', '        }\n', '\n', '        _mint(receiver, mintAmount, depositAmount, currentPrice);\n', '\n', '        checkpointPrices_[receiver] = currentPrice;\n', '    }\n', '\n', '    function _burnToken(\n', '        address receiver,\n', '        uint256 burnAmount)\n', '        internal\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        require(burnAmount > 0, "amount == 0");\n', '\n', '        if (burnAmount > balanceOf(msg.sender)) {\n', '            burnAmount = balanceOf(msg.sender);\n', '        }\n', '\n', '        if (burntTokenReserveList.length > 0) {\n', '            _claimLoanToken(_getNextOwed());\n', '            _claimLoanToken(receiver);\n', '            if (msg.sender != receiver)\n', '                _claimLoanToken(msg.sender);\n', '        } else {\n', '            _settleInterest();\n', '        }\n', '\n', '        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\n', '\n', '        uint256 loanAmountOwed = burnAmount.mul(currentPrice).div(10**18);\n', '        uint256 loanAmountAvailableInContract = ERC20(loanTokenAddress).balanceOf(address(this));\n', '\n', '        loanAmountPaid = loanAmountOwed;\n', '        if (loanAmountPaid > loanAmountAvailableInContract) {\n', '            uint256 reserveAmount = loanAmountPaid.sub(loanAmountAvailableInContract);\n', '            uint256 reserveTokenAmount = reserveAmount.mul(10**18).div(currentPrice);\n', '\n', '            burntTokenReserved = burntTokenReserved.add(reserveTokenAmount);\n', '            if (burntTokenReserveListIndex[receiver].isSet) {\n', '                uint256 index = burntTokenReserveListIndex[receiver].index;\n', '                burntTokenReserveList[index].amount = burntTokenReserveList[index].amount.add(reserveTokenAmount);\n', '            } else {\n', '                burntTokenReserveList.push(TokenReserves({\n', '                    lender: receiver,\n', '                    amount: reserveTokenAmount\n', '                }));\n', '                burntTokenReserveListIndex[receiver] = ListIndex({\n', '                    index: burntTokenReserveList.length-1,\n', '                    isSet: true\n', '                });\n', '            }\n', '\n', '            loanAmountPaid = loanAmountAvailableInContract;\n', '        }\n', '\n', '        _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice);\n', '\n', '        if (burntTokenReserveListIndex[msg.sender].isSet || balances[msg.sender] > 0) {\n', '            checkpointPrices_[msg.sender] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[msg.sender] = 0;\n', '        }\n', '    }\n', '\n', '    function _settleInterest()\n', '        internal\n', '    {\n', '        if (lastSettleTime_ != block.timestamp) {\n', '            (bool success,) = bZxContract.call.gas(gasleft())(\n', '                abi.encodeWithSignature(\n', '                    "payInterestForOracle(address,address)",\n', '                    bZxOracle, // (leave as original value)\n', '                    loanTokenAddress // same as interestTokenAddress\n', '                )\n', '            );\n', '            success;\n', '            lastSettleTime_ = block.timestamp;\n', '        }\n', '    }\n', '\n', '    function _getNextOwed()\n', '        internal\n', '        view\n', '        returns (address)\n', '    {\n', '        if (nextOwedLender_ != address(0))\n', '            return nextOwedLender_;\n', '        else if (burntTokenReserveList.length > 0)\n', '            return burntTokenReserveList[0].lender;\n', '        else\n', '            return address(0);\n', '    }\n', '\n', '    function _claimLoanToken(\n', '        address lender)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        _settleInterest();\n', '\n', '        if (!burntTokenReserveListIndex[lender].isSet)\n', '            return 0;\n', '\n', '        uint256 index = burntTokenReserveListIndex[lender].index;\n', '        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\n', '\n', '        uint256 claimAmount = burntTokenReserveList[index].amount.mul(currentPrice).div(10**18);\n', '        if (claimAmount == 0)\n', '            return 0;\n', '\n', '        uint256 availableAmount = ERC20(loanTokenAddress).balanceOf(address(this));\n', '        if (availableAmount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 claimTokenAmount;\n', '        if (claimAmount <= availableAmount) {\n', '            claimTokenAmount = burntTokenReserveList[index].amount;\n', '            _removeFromList(lender, index);\n', '        } else {\n', '            claimAmount = availableAmount;\n', '            claimTokenAmount = claimAmount.mul(10**18).div(currentPrice);\n', '\n', '            // prevents less than 10 being left in burntTokenReserveList[index].amount\n', '            if (claimTokenAmount.add(10) < burntTokenReserveList[index].amount) {\n', '                burntTokenReserveList[index].amount = burntTokenReserveList[index].amount.sub(claimTokenAmount);\n', '            } else {\n', '                _removeFromList(lender, index);\n', '            }\n', '        }\n', '\n', '        require(ERC20(loanTokenAddress).transfer(\n', '            lender,\n', '            claimAmount\n', '        ), "transfer failed");\n', '\n', '        if (burntTokenReserveListIndex[lender].isSet || balances[lender] > 0) {\n', '            checkpointPrices_[lender] = currentPrice;\n', '        } else {\n', '            checkpointPrices_[lender] = 0;\n', '        }\n', '\n', '        burntTokenReserved = burntTokenReserved > claimTokenAmount ?\n', '            burntTokenReserved.sub(claimTokenAmount) :\n', '            0;\n', '\n', '        emit Claim(\n', '            lender,\n', '            claimTokenAmount,\n', '            claimAmount,\n', '            burntTokenReserveListIndex[lender].isSet ?\n', '                burntTokenReserveList[burntTokenReserveListIndex[lender].index].amount :\n', '                0,\n', '            currentPrice\n', '        );\n', '\n', '        return claimAmount;\n', '    }\n', '\n', '    function _borrowToken(\n', '        address msgsender,\n', '        uint256 borrowAmount,\n', '        uint256 leverageAmount,\n', '        address collateralTokenAddress,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen,\n', '        bool calcBorrow)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        if (borrowAmount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        bytes32 loanOrderHash = loanOrderHashes[leverageAmount];\n', '        LoanData memory loanData = loanOrderData[loanOrderHash];\n', '        require(loanData.initialMarginAmount != 0, "invalid leverage");\n', '\n', '        _settleInterest();\n', '\n', '        uint256 interestRate;\n', '        if (calcBorrow) {\n', '            interestRate = _nextLoanInterestRate(\n', '                borrowAmount // escrowAmount\n', '                    .mul(10**20)\n', '                    .div(loanData.initialMarginAmount)\n', '            );\n', '\n', '            borrowAmount = _getBorrowAmount(\n', '                loanData.initialMarginAmount,\n', '                borrowAmount, // escrowAmount,\n', '                interestRate,\n', '                loanData.maxDurationUnixTimestampSec,\n', '                withdrawOnOpen\n', '            );\n', '        } else {\n', '            interestRate = _nextLoanInterestRate(borrowAmount);\n', '        }\n', '\n', '        return _borrowTokenFinal(\n', '            msgsender,\n', '            loanOrderHash,\n', '            borrowAmount,\n', '            interestRate,\n', '            collateralTokenAddress,\n', '            tradeTokenToFillAddress,\n', '            withdrawOnOpen\n', '        );\n', '    }\n', '\n', '    // returns borrowAmount\n', '    function _borrowTokenFinal(\n', '        address msgsender,\n', '        bytes32 loanOrderHash,\n', '        uint256 borrowAmount,\n', '        uint256 interestRate,\n', '        address collateralTokenAddress,\n', '        address tradeTokenToFillAddress,\n', '        bool withdrawOnOpen)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        //require(ERC20(loanTokenAddress).balanceOf(address(this)) >= borrowAmount, "insufficient loan supply");\n', '        uint256 availableToBorrow = ERC20(loanTokenAddress).balanceOf(address(this));\n', '        if (availableToBorrow == 0)\n', '            return 0;\n', '\n', '        uint256 reservedSupply = totalReservedSupply();\n', '        if (availableToBorrow > reservedSupply) {\n', '            availableToBorrow = availableToBorrow.sub(reservedSupply);\n', '        } else {\n', '            return 0;\n', '        }\n', '\n', '        if (borrowAmount > availableToBorrow) {\n', '            borrowAmount = availableToBorrow;\n', '        }\n', '\n', '        // re-up the BZxVault spend approval if needed\n', '        uint256 tempAllowance = ERC20(loanTokenAddress).allowance(address(this), bZxVault);\n', '        if (tempAllowance < borrowAmount) {\n', '            if (tempAllowance > 0) {\n', '                // reset approval to 0\n', '                require(ERC20(loanTokenAddress).approve(bZxVault, 0), "approval failed");\n', '            }\n', '\n', '            require(ERC20(loanTokenAddress).approve(bZxVault, MAX_UINT), "approval failed");\n', '        }\n', '\n', '        require(IBZx(bZxContract).updateLoanAsLender(\n', '            loanOrderHash,\n', '            borrowAmount,\n', '            interestRate.div(365),\n', '            block.timestamp+1),\n', '            "updateLoan failed"\n', '        );\n', '\n', '        require (IBZx(bZxContract).takeLoanOrderOnChainAsTraderByDelegate(\n', '            msgsender,\n', '            loanOrderHash,\n', '            collateralTokenAddress,\n', '            borrowAmount,\n', '            tradeTokenToFillAddress,\n', '            withdrawOnOpen) == borrowAmount,\n', '            "takeLoan failed"\n', '        );\n', '\n', '        // update total borrowed amount outstanding in loans\n', '        totalAssetBorrow = totalAssetBorrow.add(borrowAmount);\n', '\n', '        // checkpoint supply since the base protocol borrow stats have changed\n', '        checkpointSupply_ = _totalAssetSupply(0);\n', '\n', '        if (burntTokenReserveList.length > 0) {\n', '            _claimLoanToken(_getNextOwed());\n', '            _claimLoanToken(msgsender);\n', '        }\n', '\n', '        emit Borrow(\n', '            msgsender,\n', '            borrowAmount,\n', '            interestRate,\n', '            collateralTokenAddress,\n', '            tradeTokenToFillAddress,\n', '            withdrawOnOpen\n', '        );\n', '\n', '        return borrowAmount;\n', '    }\n', '\n', '    function _removeFromList(\n', '        address lender,\n', '        uint256 index)\n', '        internal\n', '    {\n', '        // remove lender from burntToken list\n', '        if (burntTokenReserveList.length > 1) {\n', '            // replace item in list with last item in array\n', '            burntTokenReserveList[index] = burntTokenReserveList[burntTokenReserveList.length - 1];\n', '\n', '            // update the position of this replacement\n', '            burntTokenReserveListIndex[burntTokenReserveList[index].lender].index = index;\n', '        }\n', '\n', '        // trim array and clear storage\n', '        burntTokenReserveList.length--;\n', '        burntTokenReserveListIndex[lender].index = 0;\n', '        burntTokenReserveListIndex[lender].isSet = false;\n', '\n', '        if (lender == nextOwedLender_) {\n', '            nextOwedLender_ = address(0);\n', '        }\n', '    }\n', '\n', '\n', '    /* Internal View functions */\n', '\n', '    function _tokenPrice(\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalTokenSupply = totalSupply_.add(burntTokenReserved);\n', '\n', '        return totalTokenSupply > 0 ?\n', '            assetSupply\n', '                .mul(10**18)\n', '                .div(totalTokenSupply) : initialPrice;\n', '    }\n', '\n', '    function _protocolInterestRate(\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 interestRate;\n', '        if (totalAssetBorrow > 0) {\n', '            (,uint256 interestOwedPerDay,) = _getAllInterest();\n', '            interestRate = interestOwedPerDay\n', '                .mul(10**20)\n', '                .div(totalAssetBorrow)\n', '                .mul(365)\n', '                .mul(checkpointSupply_)\n', '                .div(assetSupply);\n', '        } else {\n', '            interestRate = baseRate;\n', '        }\n', '\n', '        return interestRate;\n', '    }\n', '\n', '    // next loan interest adjustment\n', '    function _nextLoanInterestRate(\n', '        uint256 newBorrowAmount)\n', '        internal\n', '        view\n', '        returns (uint256 nextRate)\n', '    {\n', '        uint256 assetSupply = totalAssetSupply();\n', '\n', '        uint256 utilizationRate = _getUtilizationRate(assetSupply)\n', '            .add(newBorrowAmount > 0 ?\n', '                newBorrowAmount\n', '                .mul(10**20)\n', '                .div(assetSupply) : 0);\n', '\n', '        uint256 minRate = baseRate;\n', '        uint256 maxRate = rateMultiplier.add(baseRate);\n', '\n', '        if (utilizationRate > 90 ether) {\n', '            // scale rate proportionally up to 100%\n', '\n', '            utilizationRate = utilizationRate.sub(90 ether);\n', '            if (utilizationRate > 10 ether)\n', '                utilizationRate = 10 ether;\n', '\n', '            maxRate = maxRate\n', '                .mul(90)\n', '                .div(100);\n', '\n', '            nextRate = utilizationRate\n', '                .mul(SafeMath.sub(100 ether, maxRate))\n', '                .div(10 ether)\n', '                .add(maxRate);\n', '        } else {\n', '            nextRate = utilizationRate\n', '                .mul(rateMultiplier)\n', '                .div(10**20)\n', '                .add(baseRate);\n', '\n', '            if (nextRate < minRate)\n', '                nextRate = minRate;\n', '            else if (nextRate > maxRate)\n', '                nextRate = maxRate;\n', '        }\n', '\n', '        return nextRate;\n', '    }\n', '\n', '    function _getAllInterest()\n', '        internal\n', '        view\n', '        returns (\n', '            uint256 interestPaidSoFar,\n', '            uint256 interestOwedPerDay,\n', '            uint256 interestUnPaid)\n', '    {\n', "        // these values don't account for any fees retained by the oracle, so we account for it elsewhere with spreadMultiplier\n", '        (interestPaidSoFar,,interestOwedPerDay,interestUnPaid) = IBZx(bZxContract).getLenderInterestForOracle(\n', '            address(this),\n', '            bZxOracle, // (leave as original value)\n', '            loanTokenAddress // same as interestTokenAddress\n', '        );\n', '    }\n', '\n', '    function _getBorrowAmount(\n', '        uint256 marginAmount,\n', '        uint256 escrowAmount,\n', '        uint256 interestRate,\n', '        uint256 maxDuration,\n', '        bool withdrawOnOpen)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (withdrawOnOpen) {\n', '            // adjust for over-collateralized loan (initial margin + 100% margin)\n', '            marginAmount = marginAmount.add(10**20);\n', '        }\n', '\n', '        // assumes that loan, collateral, and interest token are the same\n', '        return escrowAmount\n', '            .mul(10**40)\n', '            .div(_adjustValue(\n', '                interestRate,\n', '                maxDuration,\n', '                marginAmount))\n', '            .div(marginAmount);\n', '    }\n', '\n', '    function _adjustValue(\n', '        uint256 interestRate,\n', '        uint256 maxDuration,\n', '        uint256 marginAmount)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return maxDuration > 0 ?\n', '            interestRate\n', '                .mul(10**20)\n', '                .div(31536000) // 86400 * 365\n', '                .mul(maxDuration)\n', '                .div(marginAmount)\n', '                .add(10**20) :\n', '            10**20;\n', '    }\n', '\n', '    function _getUtilizationRate(\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (totalAssetBorrow > 0 && assetSupply > 0) {\n', '            // U = total_borrow / total_supply\n', '            return totalAssetBorrow\n', '                .mul(10**20)\n', '                .div(assetSupply);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function _totalAssetSupply(\n', '        uint256 interestUnPaid)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupply_.add(burntTokenReserved) > 0 ?\n', '            ERC20(loanTokenAddress).balanceOf(address(this))\n', '                .add(totalAssetBorrow)\n', '                .add(interestUnPaid) : 0;\n', '    }\n', '\n', '\n', '    /* Oracle-Only functions */\n', '\n', '    // called only by BZxOracle when a loan is partially or fully closed\n', '    function closeLoanNotifier(\n', '        BZxObjects.LoanOrder memory loanOrder,\n', '        BZxObjects.LoanPosition memory loanPosition,\n', '        address loanCloser,\n', '        uint256 closeAmount,\n', '        bool /* isLiquidation */)\n', '        public\n', '        onlyOracle\n', '        returns (bool)\n', '    {\n', '        LoanData memory loanData = loanOrderData[loanOrder.loanOrderHash];\n', '        if (loanData.loanOrderHash == loanOrder.loanOrderHash) {\n', '\n', '            totalAssetBorrow = totalAssetBorrow > closeAmount ?\n', '                totalAssetBorrow.sub(closeAmount) : 0;\n', '\n', '            if (burntTokenReserveList.length > 0) {\n', '                _claimLoanToken(_getNextOwed());\n', '            } else {\n', '                _settleInterest();\n', '            }\n', '\n', '            if (closeAmount == 0)\n', '                return true;\n', '\n', '            // checkpoint supply since the base protocol borrow stats have changed\n', '            checkpointSupply_ = _totalAssetSupply(0);\n', '\n', '            if (loanCloser != loanPosition.trader) {\n', '\n', '                address tradeTokenAddress = iTokenizedRegistry(tokenizedRegistry).getTokenAsset(\n', '                    loanPosition.trader,\n', '                    2 // tokenType=pToken\n', '                );\n', '\n', '                if (tradeTokenAddress != address(0)) {\n', '\n', '                    uint256 escrowAmount = ERC20(loanTokenAddress).balanceOf(loanPosition.trader);\n', '\n', '                    if (escrowAmount > 0) {\n', '                        (bool success,) = address(this).call.gas(gasleft())(\n', '                            abi.encodeWithSignature(\n', '                                "rolloverPosition(address,uint256,uint256,address)",\n', '                                loanPosition.trader,\n', '                                loanData.leverageAmount,\n', '                                escrowAmount,\n', '                                tradeTokenAddress\n', '                            )\n', '                        );\n', '                        success;\n', '                    }\n', '                }\n', '            }\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '\n', '    /* Owner-Only functions */\n', '\n', '    function initLeverage(\n', '        uint256[4] memory orderParams) // leverageAmount, initialMarginAmount, maintenanceMarginAmount, maxDurationUnixTimestampSec\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(loanOrderHashes[orderParams[0]] == 0);\n', '\n', '        address[8] memory orderAddresses = [\n', '            address(this), // makerAddress\n', '            loanTokenAddress, // loanTokenAddress\n', '            loanTokenAddress, // interestTokenAddress (same as loanToken)\n', '            address(0), // collateralTokenAddress\n', '            address(0), // feeRecipientAddress\n', '            bZxOracle, // (leave as original value)\n', '            address(0), // takerAddress\n', '            address(0) // tradeTokenToFillAddress\n', '        ];\n', '\n', '        uint256[11] memory orderValues = [\n', '            0, // loanTokenAmount\n', '            0, // interestAmountPerDay\n', '            orderParams[1], // initialMarginAmount,\n', '            orderParams[2], // maintenanceMarginAmount,\n', '            0, // lenderRelayFee\n', '            0, // traderRelayFee\n', '            orderParams[3], // maxDurationUnixTimestampSec,\n', '            0, // expirationUnixTimestampSec\n', '            0, // makerRole (0 = lender)\n', '            0, // withdrawOnOpen\n', '            uint(keccak256(abi.encodePacked(msg.sender, block.timestamp))) // salt\n', '        ];\n', '\n', '        bytes32 loanOrderHash = IBZx(bZxContract).pushLoanOrderOnChain(\n', '            orderAddresses,\n', '            orderValues,\n', '            abi.encodePacked(address(this)), // oracleData -> closeLoanNotifier\n', '            ""\n', '        );\n', '        IBZx(bZxContract).setLoanOrderDesc(\n', '            loanOrderHash,\n', '            name\n', '        );\n', '        loanOrderData[loanOrderHash] = LoanData({\n', '            loanOrderHash: loanOrderHash,\n', '            leverageAmount: orderParams[0],\n', '            initialMarginAmount: orderParams[1],\n', '            maintenanceMarginAmount: orderParams[2],\n', '            maxDurationUnixTimestampSec: orderParams[3],\n', '            index: leverageList.length\n', '        });\n', '        loanOrderHashes[orderParams[0]] = loanOrderHash;\n', '        leverageList.push(orderParams[0]);\n', '    }\n', '\n', '    function removeLeverage(\n', '        uint256 leverageAmount)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bytes32 loanOrderHash = loanOrderHashes[leverageAmount];\n', '        require(loanOrderHash != 0);\n', '\n', '        if (leverageList.length > 1) {\n', '            uint256 index = loanOrderData[loanOrderHash].index;\n', '            leverageList[index] = leverageList[leverageList.length - 1];\n', '            loanOrderData[loanOrderHashes[leverageList[index]]].index = index;\n', '        }\n', '        leverageList.length--;\n', '\n', '        delete loanOrderHashes[leverageAmount];\n', '        delete loanOrderData[loanOrderHash];\n', '    }\n', '\n', '    // These params should be percentages represented like so: 5% = 5000000000000000000\n', "    // rateMultiplier + baseRate can't exceed 100%\n", '    function setDemandCurve(\n', '        uint256 _baseRate,\n', '        uint256 _rateMultiplier)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(rateMultiplier.add(baseRate) <= 10**20);\n', '        baseRate = _baseRate;\n', '        rateMultiplier = _rateMultiplier;\n', '    }\n', '\n', '    function setInterestFeePercent(\n', '        uint256 _newRate)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_newRate <= 10**20);\n', '        spreadMultiplier = SafeMath.sub(10**20, _newRate);\n', '    }\n', '\n', '    function setBZxContract(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxContract = _addr;\n', '    }\n', '\n', '    function setBZxVault(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxVault = _addr;\n', '    }\n', '\n', '    function setBZxOracle(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bZxOracle = _addr;\n', '    }\n', '\n', '    function setTokenizedRegistry(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        tokenizedRegistry = _addr;\n', '    }\n', '\n', '    function setWETHContract(\n', '        address _addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        wethContract = _addr;\n', '    }\n', '\n', '    function setInitialPrice(\n', '        uint256 _value)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_value > 0);\n', '        initialPrice = _value;\n', '    }\n', '\n', '    function initialize(\n', '        address _bZxContract,\n', '        address _bZxVault,\n', '        address _bZxOracle,\n', '        address _wethContract,\n', '        address _loanTokenAddress,\n', '        address _tokenizedRegistry,\n', '        string memory _name,\n', '        string memory _symbol)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require (!isInitialized_);\n', '\n', '        bZxContract = _bZxContract;\n', '        bZxVault = _bZxVault;\n', '        bZxOracle = _bZxOracle;\n', '        wethContract = _wethContract;\n', '        loanTokenAddress = _loanTokenAddress;\n', '        tokenizedRegistry = _tokenizedRegistry;\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = EIP20(loanTokenAddress).decimals();\n', '\n', '        spreadMultiplier = SafeMath.sub(10**20, IBZxOracle(_bZxOracle).interestFeePercent());\n', '\n', '        initialPrice = 10**18; // starting price of 1\n', '\n', '        isInitialized_ = true;\n', '    }\n', '}']