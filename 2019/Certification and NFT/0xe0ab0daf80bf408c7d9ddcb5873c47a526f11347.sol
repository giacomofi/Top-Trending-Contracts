['pragma solidity ^0.4.25;\n', '\n', '\n', 'import "./BrightCoinTokenOwner_ICO.sol";\n', 'import "./BrightCoinERC20Contract_ICO.sol";\n', '\n', '\n', '//Rules for Accredited Investors\n', '/*\n', ' This is special BrightCoinToken that will allow User to invest to Token Only after Proper Checks and Validation as provide by US Regulatories Authorities\n', '*/\n', '\n', '/*\n', ' import all specific contract that will help in Validation \n', ' Accridetion\n', ' KYC\n', ' TokenDistribution Details\n', '*/\n', '\n', 'contract BrightCoinRegulatedToken  is BrightCoinERC20\n', '{\n', '\n', '//BrightCoinInvestorKYC InvestorKYCInfo;\n', '//BrightCoinInvestorCheck AccreditationInfo;\n', '\n', '\n', 'address public BrightCoinInvestorKYCAddress; \n', 'address public BrightCoinInvestorAccreditationAddress; \n', 'mapping (uint8 => uint256) private PeriodTokenAmount;\n', 'bool InvestorSecurity;\n', 'bool KYCSupport;\n', '\n', 'constructor() public \n', '{\n', ' InvestorSecurity = false;\n', ' KYCSupport = false;\n', '}\n', '\n', '\n', '\n', '\n', '  \n', '  function DistributeToken(address _addrOfInvestor, uint256 _currenttime,\n', '                    uint256 _tokens, uint8 _mainSalePeriodIndex) public onlyTokenOwner \n', '  {\n', '\n', '      require(_addrOfInvestor != 0x0);\n', '      require(_currenttime >0);\n', '   //   require(_tokenlockPeriod > 0);\n', '      require(_tokens > 0);\n', '\n', '   \n', '       \n', '        if((_mainSalePeriodIndex == 0) && (PreSaleOn == true))  //PreSale\n', '        {\n', '        \n', '       \n', '      \n', '            //Check if Period Hard cap achived \n', '\n', '            require(_tokens <= getMaxCoinSoldDuringPreSale());\n', '            \n', '            //Check if ICO Hardcap achived\n', '            require(CheckIfHardcapAchived(_tokens) == true);\n', '           // internaltransfer(msg.sender,_addrOfInvestor,_tokens);\n', '            require (internaltransfer(msg.sender, _addrOfInvestor,_tokens ) == true);\n', '            emit Transfer(msg.sender, _addrOfInvestor, _tokens);\n', '           // SetTokenLock(_addrOfInvestor,tokenTimeLock,_tokens);\n', '            updatepresalemaxTokenCount(_tokens);\n', '        }\n', '        else\n', '        {\n', '            //Calculate token amount\n', '            require(CheckIfMainSaleOn(_mainSalePeriodIndex) == true);\n', '            require(CheckTokenPeriodSale(_currenttime,_mainSalePeriodIndex) == true);\n', '    \n', '\n', '            require(CheckMainSaleLimit(_mainSalePeriodIndex,_tokens) == true, "Main Sale Limit Crossed");\n', '             \n', '            require(CheckIfHardcapAchived(_tokens) == true);\n', '            \n', '              \n', '            // internaltransfer(msg.sender,_addrOfInvestor,_tokens);\n', '            require(internaltransfer(msg.sender ,_addrOfInvestor,_tokens) == true);\n', '            \n', '             emit Transfer(msg.sender, _addrOfInvestor, _tokens);\n', '           //  SetTokenLock(_addrOfInvestor,tokenTimeLock,_tokens);\n', '             updateCurrentTokenCount(_mainSalePeriodIndex,_tokens);\n', '        }\n', '  }\n', '\n', ' function tranfertocustodian(address _to) public onlyTokenOwner returns(bool)\n', '{\n', '    //internaltransfer(msg.sender, _to, balances[msg.sender]);\n', '    require(internaltransfer(msg.sender, _to, balances[msg.sender]) == true);\n', '     //  require(internaltransfer(_from ,_to,_tokens) == true);\n', '    emit Transfer(msg.sender, _to, balances[_to]);\n', '    custodianaddress = _to;\n', '    return true;\n', '}\n', '\n', '  \n', '\n', 'function regulatedtransfer( address _from , address _to, uint256 _tokens) private returns(bool) \n', '{\n', '    //check if locking period is expired or not \n', '      uint256 currenttime = now;\n', '      \n', '      if (InvestorSecurity == true)\n', '      {\n', '          \n', '           if(isTokenLockExpire(_from,currenttime) == true)\n', '           {\n', '             //  internaltransfer(_from,_to,_tokens);\n', '               require(internaltransfer(_from, _to, _tokens) == true);\n', '               emit Transfer(_from, _to, _tokens);\n', '                return true;\n', '           }\n', '           \n', '           uint256 TokenLockExpiry = getTokenLockExpiry(_from); \n', '           require(TokenLockExpiry !=0);\n', '         \n', '         if( ICOType != uint8(BrightCoinICOType.Utility))\n', '         {\n', '        //    require(AccreditationInfo.checkBothInvestorValidity(_from,_to, ICOType) == true); \n', '            SetTokenLock(_to,TokenLockExpiry,_tokens);\n', '           // internaltransfer(_from,_to,_tokens);\n', '           require(internaltransfer(_from, _to, _tokens) == true);\n', '             emit Transfer(_from, _to, _tokens);\n', '            return true; \n', '         }\n', '         else\n', '         {\n', '          SetTokenLock(_to,TokenLockExpiry,_tokens);\n', '           internaltransfer(_from,_to,_tokens);\n', '           emit Transfer(_from, _to, _tokens);\n', '           return true;\n', '         }\n', '            \n', '      }\n', '      else\n', '      {\n', '        // require(isTokenLockExpire(msg.sender,currenttime) == true);\n', '        // internaltransfer(_from,_to,_tokens);\n', '        require(internaltransfer(_from, _to, _tokens) == true);\n', '         emit Transfer(_from, _to, _tokens);\n', '         return true;\n', '      }\n', '      \n', '}\n', '\n', 'function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) \n', '{\n', '      \n', '       require(pauseICO == false);  //if this flag is true the no operation is allowed.\n', '      require(_tokens > 0);\n', '      require(allowed[_from][msg.sender] >= _tokens);\n', '    \n', '     require(internaltransfer(_from ,_to,_tokens) == true);\n', '      emit Transfer(_from, _to, _tokens);\n', '      //If regulated transfer is true then only reduce allowed map\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);\n', '      return true;\n', '}\n', '    \n', '\n', 'function approve(address _spender, uint256 _value) public returns (bool success)\n', ' {\n', '     require(_spender != address(0));\n', '    //  require(checkCompliance(_spender) == true);\n', '      allowed[msg.sender][_spender] = _value;\n', '      emit Approval(msg.sender, _spender, _value);\n', '      \n', '      return true;\n', ' }\n', '  //This method will be called when investor  wants to tranfer token to other.  \n', 'function transfer(address _to, uint _tokens) public returns (bool) \n', ' {     \n', '    require(pauseICO == false);  //if this flag is true the no operation is allowed.\n', '    require(_to != address(0));\n', '    require (internaltransfer(msg.sender, _to,_tokens ) == true);\n', '   \n', '     emit Transfer(msg.sender, _to, _tokens);\n', '    return true;\n', '       \n', '      \n', '}\n', '      \n', '\n', '   function TransferCompanyHoldingTokens() public onlyTokenOwner     returns(bool)\n', '  { \n', '    \n', '   require(CompanyHoldingBalances[msg.sender] == CompanyHoldingValue) ; \n', '   //   uint256 Holdinglockexpiry = now.add(_lockExpiry);\n', '     \n', '     // balances[CompanyHoldingAddress] = CompanyHoldingBalances[msg.sender];\n', '      internaltransfer(msg.sender,CompanyHoldingAddress,CompanyHoldingValue);\n', '      CompanyHoldingBalances[msg.sender] = 0;\n', '     // SetTokenLock(CompanyHoldingAddress,Holdinglockexpiry,CompanyHoldingValue);\n', '      emit Transfer(msg.sender, CompanyHoldingAddress, CompanyHoldingValue);\n', '      return true;\n', '\n', ' } \n', ' \n', '\n', '\n', '}']