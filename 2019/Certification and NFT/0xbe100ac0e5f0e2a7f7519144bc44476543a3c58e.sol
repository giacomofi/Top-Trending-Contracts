['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '// File: contracts/ERC20Relay.sol\n', '\n', 'contract ERC20Relay is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    string public constant VERSION = "1.0.0";\n', '\n', '    /* Managers */\n', '    address public verifierManager;\n', '    address public feeManager;\n', '\n', '    event NewVerifierManager(\n', '        address indexed previousManager,\n', '        address indexed newManager\n', '    );\n', '    event NewFeeManager(\n', '        address indexed previousManager,\n', '        address indexed newManager\n', '    );\n', '\n', '    /* Verifiers */\n', '    uint256 constant MINIMUM_VERIFIERS = 3;\n', '    uint256 public requiredVerifiers;\n', '    address[] private verifiers;\n', '    mapping (address => uint256) private verifierAddressToIndex;\n', '\n', '    /* Withdrawals */\n', '    uint256 constant GAS_PRICE = 20 * 10 ** 9;\n', '    uint256 constant ESTIMATED_GAS_PER_VERIFIER = 54301;\n', '    uint256 constant ESTIMATED_GAS_PER_WITHDRAWAL= 73458;\n', '    uint256 public nctEthExchangeRate;\n', '    uint256 public fees;\n', '    address public feeWallet;\n', '\n', '    struct Withdrawal {\n', '        address destination;\n', '        uint256 amount;\n', '        bool processed;\n', '    }\n', '\n', '    mapping (bytes32 => Withdrawal) public withdrawals;\n', '    mapping (bytes32 => address[]) public withdrawalApprovals;\n', '\n', '    event WithdrawalProcessed(\n', '        address indexed destination,\n', '        uint256 amount,\n', '        bytes32 txHash,\n', '        bytes32 blockHash,\n', '        uint256 blockNumber\n', '    );\n', '\n', '    event FeesChanged(\n', '        uint256 newFees\n', '    );\n', '\n', '    /* Sidechain anchoring */\n', '    struct Anchor {\n', '        bytes32 blockHash;\n', '        uint256 blockNumber;\n', '        bool processed;\n', '    }\n', '\n', '    Anchor[] public anchors;\n', '    mapping (bytes32 => address[]) public anchorApprovals;\n', '\n', '    event AnchoredBlock(\n', '        bytes32 indexed blockHash,\n', '        uint256 indexed blockNumber\n', '    );\n', '\n', '    event ContestedBlock(\n', '        bytes32 indexed blockHash,\n', '        uint256 indexed blockNumber\n', '    );\n', '\n', '    ERC20 private token;\n', '\n', '    constructor(address _token, uint256 _nctEthExchangeRate, address _feeWallet, address[] _verifiers) public {\n', '        require(_token != address(0), "Invalid token address");\n', '        require(_verifiers.length >= MINIMUM_VERIFIERS, "Number of verifiers less than minimum");\n', '\n', '        // If set to address(0), onlyVerifierManager and onlyFeeManager are equivalent to onlyOwner\n', '        verifierManager = address(0);\n', '        feeManager = address(0);\n', '\n', '        // Dummy verifier at index 0\n', '        verifiers.push(address(0));\n', '\n', '        for (uint256 i = 0; i < _verifiers.length; i++) {\n', '            verifiers.push(_verifiers[i]);\n', '            verifierAddressToIndex[_verifiers[i]] = i.add(1);\n', '        }\n', '\n', '        requiredVerifiers = calculateRequiredVerifiers();\n', '\n', '        nctEthExchangeRate = _nctEthExchangeRate;\n', '        fees = calculateFees();\n', '\n', '        token = ERC20(_token);\n', '        feeWallet = _feeWallet;\n', '    }\n', '\n', '    /** Disable usage of the fallback function */\n', '    function () external payable {\n', '        revert("Do not allow sending Eth to this contract");\n', '    }\n', '\n', '    modifier onlyVerifierManager() {\n', '        if (verifierManager == address(0)) {\n', '            require(msg.sender == owner, "Not a verifier manager");\n', '        } else {\n', '            require(msg.sender == verifierManager, "Not a verifier manager");\n', '        }\n', '        _;\n', '    }\n', '\n', '    function setVerifierManager(address newVerifierManager) external onlyOwner {\n', '        emit NewVerifierManager(verifierManager, newVerifierManager);\n', '        verifierManager = newVerifierManager;\n', '    }\n', '\n', '    modifier onlyFeeManager() {\n', '        if (feeManager == address(0)) {\n', '            require(msg.sender == owner, "Not a fee manager");\n', '        } else {\n', '            require(msg.sender == feeManager, "Not a fee manager");\n', '        }\n', '        _;\n', '    }\n', '\n', '    function setFeeManager(address newFeeManager) external onlyOwner {\n', '        emit NewFeeManager(feeManager, newFeeManager);\n', '        feeManager = newFeeManager;\n', '    }\n', '\n', '    function addVerifier(address addr) external onlyVerifierManager {\n', '        require(addr != address(0), "Invalid verifier address");\n', '        require(verifierAddressToIndex[addr] == 0, "Address is already a verifier");\n', '\n', '        uint256 index = verifiers.push(addr);\n', '        verifierAddressToIndex[addr] = index.sub(1);\n', '\n', '        requiredVerifiers = calculateRequiredVerifiers();\n', '        fees = calculateFees();\n', '    }\n', '\n', '    function removeVerifier(address addr) external onlyVerifierManager {\n', '        require(addr != address(0), "Invalid verifier address");\n', '        require(verifierAddressToIndex[addr] != 0, "Address is not a verifier");\n', '        require(verifiers.length.sub(1) > MINIMUM_VERIFIERS, "Removing verifier would put number of verifiers below minimum");\n', '\n', '        uint256 index = verifierAddressToIndex[addr];\n', '        require(verifiers[index] == addr, "Verifier address not present in verifiers array");\n', '        verifiers[index] = verifiers[verifiers.length.sub(1)];\n', '        verifierAddressToIndex[verifiers[verifiers.length.sub(1)]] = index;\n', '        delete verifierAddressToIndex[addr];\n', '        verifiers.length = verifiers.length.sub(1);\n', '\n', '        requiredVerifiers = calculateRequiredVerifiers();\n', '        fees = calculateFees();\n', '    }\n', '\n', '    function activeVerifiers() public view returns (address[]) {\n', '        require(verifiers.length > 0, "Invalid number of verifiers");\n', '\n', '        address[] memory ret = new address[](verifiers.length.sub(1));\n', '\n', '        // Skip dummy verifier at index 0\n', '        for (uint256 i = 1; i < verifiers.length; i++) {\n', '            ret[i.sub(1)] = verifiers[i];\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    function numberOfVerifiers() public view returns (uint256) {\n', '        require(verifiers.length > 0, "Invalid number of verifiers");\n', '        return verifiers.length.sub(1);\n', '    }\n', '\n', '    function calculateRequiredVerifiers() internal view returns(uint256) {\n', '        return numberOfVerifiers().mul(2).div(3);\n', '    }\n', '\n', '    function isVerifier(address addr) public view returns (bool) {\n', '        return verifierAddressToIndex[addr] != 0 && verifiers[verifierAddressToIndex[addr]] == addr;\n', '    }\n', '\n', '    modifier onlyVerifier() {\n', '        require(isVerifier(msg.sender), "msg.sender is not verifier");\n', '        _;\n', '    }\n', '\n', '    function setNctEthExchangeRate(uint256 _nctEthExchangeRate) external onlyFeeManager {\n', '        nctEthExchangeRate = _nctEthExchangeRate;\n', '        fees = calculateFees();\n', '\n', '        emit FeesChanged(fees);\n', '    }\n', '\n', '    function calculateFees() internal view returns (uint256) {\n', '        uint256 estimatedGas = ESTIMATED_GAS_PER_VERIFIER.mul(numberOfVerifiers())\n', '            .add(ESTIMATED_GAS_PER_WITHDRAWAL);\n', '        return estimatedGas.mul(GAS_PRICE).mul(nctEthExchangeRate);\n', '    }\n', '\n', '    function approveWithdrawal(\n', '        address destination,\n', '        uint256 amount,\n', '        bytes32 txHash,\n', '        bytes32 blockHash,\n', '        uint256 blockNumber\n', '    )\n', '        external\n', '        onlyVerifier\n', '    {\n', '        require(amount > fees, "Withdrawal amount is less than or equal to fees");\n', '        require(destination != address(0), "Invalid destination address");\n', '\n', '        bytes32 hash = keccak256(abi.encodePacked(txHash, blockHash, blockNumber));\n', '        uint256 net = amount.sub(fees);\n', '\n', '        if (withdrawals[hash].destination == address(0)) {\n', '            withdrawals[hash] = Withdrawal(destination, net, false);\n', '        }\n', '\n', '        Withdrawal storage w = withdrawals[hash];\n', '        address[] storage approvals = withdrawalApprovals[hash];\n', '        require(w.destination == destination, "Destination mismatch");\n', '        require(w.amount == net, "Amount mismatch");\n', '\n', '\n', '        for (uint256 i = 0; i < approvals.length; i++) {\n', '            require(approvals[i] != msg.sender, "Already approved withdrawal");\n', '        }\n', '\n', '        approvals.push(msg.sender);\n', '\n', '        if (approvals.length >= requiredVerifiers && !w.processed) {\n', '            if (fees != 0 && feeWallet != address(0)) {\n', '                token.safeTransfer(feeWallet, fees);\n', '            }\n', '\n', '            // We require that amount > fees therefore net > 0\n', '            token.safeTransfer(destination, net);\n', '\n', '            w.processed = true;\n', '            emit WithdrawalProcessed(destination, net, txHash, blockHash, blockNumber);\n', '        }\n', '    }\n', '\n', '    // Allow verifiers to retract their withdrawals in the case of a chain\n', '    // reorganization. This shouldn&#39;t happen but is possible.\n', '    function unapproveWithdrawal(\n', '        bytes32 txHash,\n', '        bytes32 blockHash,\n', '        uint256 blockNumber\n', '    )\n', '        external\n', '        onlyVerifier\n', '    {\n', '        bytes32 hash = keccak256(abi.encodePacked(txHash, blockHash, blockNumber));\n', '        require(withdrawals[hash].destination != address(0), "No such withdrawal");\n', '\n', '        Withdrawal storage w = withdrawals[hash];\n', '        address[] storage approvals = withdrawalApprovals[hash];\n', '        require(!w.processed, "Withdrawal already processed");\n', '\n', '        uint256 length = approvals.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (approvals[i] == msg.sender) {\n', '                approvals[i] = approvals[length.sub(1)];\n', '                delete approvals[length.sub(1)];\n', '                approvals.length = approvals.length.sub(1);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function anchor(bytes32 blockHash, uint256 blockNumber) external onlyVerifier {\n', '        // solium-disable-next-line operator-whitespace\n', '        if (anchors.length == 0 ||\n', '            anchors[anchors.length.sub(1)].blockHash != blockHash ||\n', '            anchors[anchors.length.sub(1)].blockNumber != blockNumber) {\n', '            // Emit event to alert the last anchor was never confirmed\n', '\n', '            if (anchors.length > 0 && !anchors[anchors.length.sub(1)].processed) {\n', '                Anchor storage last = anchors[anchors.length.sub(1)];\n', '                emit ContestedBlock(last.blockHash, last.blockNumber);\n', '            }\n', '            anchors.push(Anchor(blockHash, blockNumber, false));\n', '        }\n', '\n', '        bytes32 hash = keccak256(abi.encodePacked(blockHash, blockNumber));\n', '        Anchor storage a = anchors[anchors.length.sub(1)];\n', '        address[] storage approvals = anchorApprovals[hash];\n', '        require(a.blockHash == blockHash, "Block hash mismatch");\n', '        require(a.blockNumber == blockNumber, "Block number mismatch");\n', '\n', '        for (uint256 i = 0; i < approvals.length; i++) {\n', '            require(approvals[i] != msg.sender, "Already approved anchor block");\n', '        }\n', '\n', '        approvals.push(msg.sender);\n', '        if (approvals.length >= requiredVerifiers && !a.processed) {\n', '            a.processed = true;\n', '            emit AnchoredBlock(blockHash, blockNumber);\n', '        }\n', '    }\n', '\n', '    function unanchor() external onlyVerifier {\n', '        Anchor storage a = anchors[anchors.length.sub(1)];\n', '        require(!a.processed, "Block anchor already processed");\n', '\n', '        bytes32 hash = keccak256(abi.encodePacked(a.blockHash, a.blockNumber));\n', '        address[] storage approvals = anchorApprovals[hash];\n', '\n', '        uint256 length = approvals.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (approvals[i] == msg.sender) {\n', '                approvals[i] = approvals[length.sub(1)];\n', '                delete approvals[length.sub(1)];\n', '                approvals.length = approvals.length.sub(1);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}']