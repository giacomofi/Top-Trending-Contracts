['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' *\n', ' * @author Alejandro Diaz <Alejandro.Diaz.666@protonmail.com>\n', ' *\n', ' * Overview:\n', ' * This is an implimentation of a dividend-paying token, with a special transfer from a holding address.\n', ' * A fixed number of tokens are minted in the constructor, with some amount initially owned by the contract\n', ' * owner; and some amount owned by a reserve address. The reserve address cannot transfer tokens to any\n', ' * other address, except as directed by a trusted partner-contract.\n', ' *\n', ' * Dividends are awarded token holders following the technique outlined by Nick Johnson in\n', ' *  https://medium.com/ @ weka/dividend-bearing-tokens-on-ethereum-42d01c710657\n', ' *\n', ' * The technique is:\n', ' *   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...\n', " *   where p(x) is the x'th income payment received by the contract\n", ' *         t(x) is the number of tokens held by the token-holder at the time of p(x)\n', ' *         N    is the total number of tokens, which never changes\n', ' *\n', ' * assume that t(x) takes on 3 values, t(a), t(b) and t(c), at times a, b, and c;\n', ' * and that there are multiple payments at times between a and b: x, x+1, x+2...\n', ' * and multiple payments at times between b and c: y, x+y, y+2...\n', ' * and multiple payments at times greater than c: z, z+y, z+2...\n', ' * then factoring:\n', ' *\n', ' *   current_due = { (t(a) * [p(x) + p(x+1)]) ... + (t(a) * [p(x) + p(y-1)]) ... +\n', ' *                   (t(b) * [p(y) + p(y+1)]) ... + (t(b) * [p(y) + p(z-1)]) ... +\n', ' *                   (t(c) * [p(z) + p(z+1)]) ... + (t(c) * [p(z) + p(now)]) } / N\n', ' *\n', ' * or\n', ' *\n', ' *   current_due = { (t(a) * period_a_income) +\n', ' *                   (t(b) * period_b_income) +\n', ' *                   (t(c) * period_c_income) } / N\n', ' *\n', ' * if we designate current_due * N as current-points, then\n', ' *\n', ' *   currentPoints = {  (t(a) * period_a_income) +\n', ' *                      (t(b) * period_b_income) +\n', ' *                      (t(c) * period_c_income) }\n', ' *\n', " * or more succictly, if we recompute current points before a token-holder's number of\n", ' * tokens, T, is about to change:\n', ' *\n', ' *   currentPoints = previous_points + (T * current-period-income)\n', ' *\n', " * when we want to do a payout, we'll calculate:\n", ' *  current_due = current-points / N\n', ' *\n', " * we'll keep track of a token-holder's current-period-points, which is:\n", ' *   T * current-period-income\n', ' * by taking a snapshot of income collected exactly when the current period began; that is, the when the\n', ' * number of tokens last changed. that is, we keep a running count of total income received\n', ' *\n', ' *   totalIncomeReceived = p(x) + p(x+1) + p(x+2)\n', ' *\n', ' * (which happily is the same for all token holders) then, before any token holder changes their number of\n', ' * tokens we compute (for that token holder):\n', ' *\n', ' *  function calcCurPointsForAcct(acct) {\n', ' *    currentPoints[acct] += (totalIncomeReceived - lastSnapshot[acct]) * T[acct]\n', ' *    lastSnapshot[acct] = totalIncomeReceived\n', ' *  }\n', ' *\n', ' * in the withdraw fcn, all we need is:\n', ' *\n', ' *  function withdraw(acct) {\n', ' *    calcCurPointsForAcct(acct);\n', ' *    current_amount_due = currentPoints[acct] / N\n', ' *    currentPoints[acct] = 0;\n', ' *    send(current_amount_due);\n', ' *  }\n', ' *\n', ' */\n', "//import './SafeMath.sol';\n", '/*\n', '    Overflow protected math functions\n', '*/\n', 'contract SafeMath {\n', '    /**\n', '        constructor\n', '    */\n', '    constructor() public {\n', '    }\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) pure internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) pure internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', "//import './iERC20Token.sol';\n", '// Token standard API\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract iERC20Token {\n', '  function balanceOf( address who ) public view returns (uint value);\n', '  function allowance( address owner, address spender ) public view returns (uint remaining);\n', '\n', '  function transfer( address to, uint value) public returns (bool ok);\n', '  function transferFrom( address from, address to, uint value) public returns (bool ok);\n', '  function approve( address spender, uint value ) public returns (bool ok);\n', '\n', '  event Transfer( address indexed from, address indexed to, uint value);\n', '  event Approval( address indexed owner, address indexed spender, uint value);\n', '\n', '  //these are implimented via automatic getters\n', '  //function name() public view returns (string _name);\n', '  //function symbol() public view returns (string _symbol);\n', '  //function decimals() public view returns (uint8 _decimals);\n', '  //function totalSupply() public view returns (uint256 _totalSupply);\n', '}\n', '\n', "//import './iDividendToken.sol';\n", '// simple interface for withdrawing dividends\n', 'contract iDividendToken {\n', '  function checkDividends(address _addr) view public returns(uint _ethAmount);\n', '  function withdrawDividends() public returns (uint _amount);\n', '}\n', '\n', "//import './iPlpPointsRedeemer.sol';\n", '// interface for redeeming PLP Points\n', 'contract iPlpPointsRedeemer {\n', '  function reserveTokens() public view returns (uint remaining);\n', '  function transferFromReserve(address _to, uint _value) public;\n', '}\n', '\n', 'contract PirateLotteryProfitToken is iERC20Token, iDividendToken, iPlpPointsRedeemer, SafeMath {\n', '\n', '  event PaymentEvent(address indexed from, uint amount);\n', '  event TransferEvent(address indexed from, address indexed to, uint amount);\n', '  event ApprovalEvent(address indexed from, address indexed to, uint amount);\n', '\n', '  struct tokenHolder {\n', '    uint tokens;           // num tokens currently held in this acct, aka balance\n', '    uint currentPoints;    // updated before token balance changes, or before a withdrawal. credit for owning tokens\n', "    uint lastSnapshot;     // snapshot of global TotalPoints, last time we updated this acct's currentPoints\n", '  }\n', '\n', '  bool    public isLocked;\n', '  uint8   public decimals;\n', '  string  public symbol;\n', '  string  public name;\n', '  address payable public owner;\n', '  address payable public reserve;            // reserve account\n', '  uint256 public  totalSupply;               // total token supply. never changes\n', '  uint256 public  holdoverBalance;           // funds received, but not yet distributed\n', '  uint256 public  totalReceived;\n', '\n', '  mapping (address => mapping (address => uint)) approvals;  //transfer approvals, from -> to\n', '  mapping (address => tokenHolder) public tokenHolders;\n', '  mapping (address => bool) public trusted;\n', '\n', '\n', '  //\n', '  // modifiers\n', '  //\n', '  modifier ownerOnly {\n', '    require(msg.sender == owner, "owner only");\n', '    _;\n', '  }\n', '  modifier unlockedOnly {\n', '    require(!isLocked, "unlocked only");\n', '    _;\n', '  }\n', '  modifier notReserve {\n', '    require(msg.sender != reserve, "reserve is barred");\n', '    _;\n', '  }\n', '  modifier trustedOnly {\n', '    require(trusted[msg.sender] == true, "trusted only");\n', '    _;\n', '  }\n', '  //this is to protect from short-address attack. use this to verify size of args, especially when an address arg preceeds\n', '  //a value arg. see: https://www.reddit.com/r/ethereum/comments/63s917/worrysome_bug_exploit_with_erc20_token/dfwmhc3/\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    assert(msg.data.length >= size + 4);\n', '    _;\n', '  }\n', '\n', '  //\n', '  //constructor\n', '  //\n', '  constructor(uint256 _totalSupply, uint256 _reserveSupply, address payable _reserve, uint8 _decimals, string memory _name, string memory _symbol) public {\n', '    totalSupply = _totalSupply;\n', '    reserve = _reserve;\n', '    decimals = _decimals;\n', '    name = _name;\n', '    symbol = _symbol;\n', '    owner = msg.sender;\n', '    tokenHolders[reserve].tokens = _reserveSupply;\n', '    tokenHolders[owner].tokens = safeSub(totalSupply, _reserveSupply);\n', '  }\n', '\n', '  function setTrust(address _trustedAddr, bool _trust) public ownerOnly unlockedOnly {\n', '    trusted[_trustedAddr] = _trust;\n', '  }\n', '\n', '  function lock() public ownerOnly {\n', '    isLocked = true;\n', '  }\n', '\n', '\n', '  //\n', '  // ERC-20\n', '  //\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2*32) notReserve returns (bool success) {\n', '    if (tokenHolders[msg.sender].tokens >= _value) {\n', '      //first credit sender with points accrued so far.. must do this before number of held tokens changes\n', '      calcCurPointsForAcct(msg.sender);\n', '      tokenHolders[msg.sender].tokens = safeSub(tokenHolders[msg.sender].tokens, _value);\n', '      //if destination is a new tokenholder then we are setting his "last" snapshot to the current totalPoints\n', '      if (tokenHolders[_to].lastSnapshot == 0)\n', '        tokenHolders[_to].lastSnapshot = totalReceived;\n', '      //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '      calcCurPointsForAcct(_to);\n', '      tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\n', '      emit TransferEvent(msg.sender, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '\n', '  // transfer from reserve is prevented by preventing reserve from generating approval\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3*32) public returns (bool success) {\n', '    //prevent wrap:\n', '    if (tokenHolders[_from].tokens >= _value && approvals[_from][msg.sender] >= _value) {\n', '      //first credit source acct with points accrued so far.. must do this before number of held tokens changes\n', '      calcCurPointsForAcct(_from);\n', '      tokenHolders[_from].tokens = safeSub(tokenHolders[_from].tokens, _value);\n', '      //if destination is a new tokenreserve then we are setting his "last" snapshot to the current totalPoints\n', '      if (tokenHolders[_to].lastSnapshot == 0)\n', '        tokenHolders[_to].lastSnapshot = totalReceived;\n', '      //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '      calcCurPointsForAcct(_to);\n', '      tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\n', '      approvals[_from][msg.sender] = safeSub(approvals[_from][msg.sender], _value);\n', '      emit TransferEvent(_from, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    balance = tokenHolders[_owner].tokens;\n', '  }\n', '\n', '\n', '  function approve(address _spender, uint _value) public onlyPayloadSize(2*32) notReserve returns (bool success) {\n', '    approvals[msg.sender][_spender] = _value;\n', '    emit ApprovalEvent(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '    return approvals[_owner][_spender];\n', '  }\n', '\n', '  //\n', '  // END ERC20\n', '  //\n', '\n', '\n', '  //\n', '  // iTransferPointsRedeemer\n', '  //\n', '  function reserveTokens() public view returns (uint remaining) {\n', '    return tokenHolders[reserve].tokens;\n', '  }\n', '\n', '\n', '  //\n', '  // transfer from reserve, initiated from a trusted partner-contract\n', '  //\n', '  function transferFromReserve(address _to, uint _value) onlyPayloadSize(2*32) public trustedOnly {\n', '    require(_value >= 10 || tokenHolders[reserve].tokens < 10, "minimum redmption is 10 tokens");\n', '    require(tokenHolders[reserve].tokens >= _value, "reserve has insufficient tokens");\n', '    //first credit source acct with points accrued so far.. must do this before number of held tokens changes\n', '    calcCurPointsForAcct(reserve);\n', '    tokenHolders[reserve].tokens = safeSub(tokenHolders[reserve].tokens, _value);\n', '    //if destination is a new tokenholder then we are setting his "last" snapshot to the current totalPoints\n', '    if (tokenHolders[_to].lastSnapshot == 0)\n', '      tokenHolders[_to].lastSnapshot = totalReceived;\n', '    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '    calcCurPointsForAcct(_to);\n', '    tokenHolders[_to].tokens = safeAdd(tokenHolders[_to].tokens, _value);\n', '    emit TransferEvent(reserve, _to, _value);\n', '  }\n', '\n', '\n', '  //\n', '  // calc current points for a token holder; that is, points that are due to this token holder for all dividends\n', '  // received by the contract during the current "period". the period began the last time this fcn was called, at which\n', "  // time we updated the account's snapshot of the running point count, totalReceived. during the period the account's\n", '  // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\n', '  //\n', '  function calcCurPointsForAcct(address _acct) internal {\n', '    uint256 _newPoints = safeMul(safeSub(totalReceived, tokenHolders[_acct].lastSnapshot), tokenHolders[_acct].tokens);\n', '    tokenHolders[_acct].currentPoints = safeAdd(tokenHolders[_acct].currentPoints, _newPoints);\n', '    tokenHolders[_acct].lastSnapshot = totalReceived;\n', '  }\n', '\n', '\n', '  //\n', '  // default payable function. funds receieved here become dividends.\n', '  //\n', '  function () external payable {\n', '    holdoverBalance = safeAdd(holdoverBalance, msg.value);\n', '    totalReceived = safeAdd(totalReceived, msg.value);\n', '  }\n', '\n', '\n', '  //\n', '  // check my dividends\n', '  //\n', '  function checkDividends(address _addr) view public returns(uint _amount) {\n', "    //don't call calcCurPointsForAcct here, cuz this is a constant fcn\n", '    uint _currentPoints = tokenHolders[_addr].currentPoints +\n', '      ((totalReceived - tokenHolders[_addr].lastSnapshot) * tokenHolders[_addr].tokens);\n', '    _amount = _currentPoints / totalSupply;\n', '  }\n', '\n', '\n', '  //\n', '  // withdraw my dividends\n', '  //\n', '  function withdrawDividends() public returns (uint _amount) {\n', '    calcCurPointsForAcct(msg.sender);\n', '    _amount = tokenHolders[msg.sender].currentPoints / totalSupply;\n', '    uint _pointsUsed = safeMul(_amount, totalSupply);\n', '    tokenHolders[msg.sender].currentPoints = safeSub(tokenHolders[msg.sender].currentPoints, _pointsUsed);\n', '    holdoverBalance = safeSub(holdoverBalance, _amount);\n', '    msg.sender.transfer(_amount);\n', '  }\n', '\n', '\n', '  //only available before the contract is locked\n', '  function killContract() public ownerOnly unlockedOnly {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']