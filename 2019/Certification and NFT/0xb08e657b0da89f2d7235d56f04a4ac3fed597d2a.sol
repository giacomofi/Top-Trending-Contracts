['pragma solidity ^0.4.24;\n', '// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfabaeb9aa8faea4a0a2adaee1aca0a2">[email&#160;protected]</a>\n', '// released under Apache 2.0 licence\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract Whitelist is Ownable, RBAC {\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', '   * @dev Throws if called by any account that&#39;s not whitelisted.\n', '   */\n', '  modifier onlyWhitelisted() {\n', '    checkRole(msg.sender, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressAdded(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(addr, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      addAddressToWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', '   * false if the address wasn&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressFromWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressRemoved(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', '   * false if all addresses weren&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressesFromWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      removeAddressFromWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract StartersProxy is Whitelist{\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public TX_PER_SIGNER_LIMIT = 5;          //limit of metatx per signer\n', '    uint256 public META_BET = 1 finney;              //wei, equal to 0.001 ETH\n', '    uint256 public DEBT_INCREASING_FACTOR = 3;       //increasing factor (times) applied on the bet\n', '\n', '    struct Record {\n', '        uint256 nonce;\n', '        uint256 debt;\n', '    }\n', '    mapping(address => Record) signersBacklog;\n', '    event Received (address indexed sender, uint value);\n', '    event Forwarded (address signer, address destination, uint value, bytes data);\n', '\n', '    function() public payable {\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '    constructor(address[] _senders) public {\n', '        addAddressToWhitelist(msg.sender);\n', '        addAddressesToWhitelist(_senders);\n', '    }\n', '\n', '    function forwardPlay(address signer, address destination, bytes data, bytes32 hash, bytes signature) onlyWhitelisted public {\n', '        require(signersBacklog[signer].nonce < TX_PER_SIGNER_LIMIT, "Signer has reached the tx limit");\n', '\n', '        signersBacklog[signer].nonce++;\n', '        //we increase the personal debt here\n', '        //it grows much (much) faster than the actual bet to compensate sender&#39;s and proxy&#39;s expenses\n', '        uint256 debtIncrease = META_BET.mul(DEBT_INCREASING_FACTOR);\n', '        signersBacklog[signer].debt = signersBacklog[signer].debt.add(debtIncrease);\n', '\n', '        forward(signer, destination, META_BET, data, hash, signature);\n', '    }\n', '\n', '    function forwardWin(address signer, address destination, bytes data, bytes32 hash, bytes signature) onlyWhitelisted public {\n', '        require(signersBacklog[signer].nonce > 0, &#39;Hm, no meta plays for this signer&#39;);\n', '\n', '        forward(signer, destination, 0, data, hash, signature);\n', '    }\n', '\n', '    function forward(address signer, address destination,  uint256 value, bytes data, bytes32 hash, bytes signature) internal {\n', '        require(recoverSigner(hash, signature) == signer);\n', '\n', '        //execute the transaction with all the given parameters\n', '        require(executeCall(destination, value, data));\n', '        emit Forwarded(signer, destination, value, data);\n', '    }\n', '\n', '    //borrowed from OpenZeppelin&#39;s ESDA stuff:\n', '    //https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/cryptography/ECDSA.sol\n', '    function recoverSigner(bytes32 _hash, bytes _signature) onlyWhitelisted public view returns (address){\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        // Check the signature length\n', '        require (_signature.length == 65);\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        assembly {\n', '            r := mload(add(_signature, 32))\n', '            s := mload(add(_signature, 64))\n', '            v := byte(0, mload(add(_signature, 96)))\n', '        }\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '        // If the version is correct return the signer address\n', '        require(v == 27 || v == 28);\n', '        return ecrecover(keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)\n', '            ), v, r, s);\n', '    }\n', '\n', '    // this originally was copied from GnosisSafe\n', '    // https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/GnosisSafe.sol\n', '    function executeCall(address to, uint256 value, bytes data) internal returns (bool success) {\n', '        assembly {\n', '            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n', '        }\n', '    }\n', '\n', '    function payDebt(address signer) public payable{\n', '        require(signersBacklog[signer].nonce > 0, "Provided address has no debt");\n', '        require(signersBacklog[signer].debt >= msg.value, "Address&#39;s debt is less than payed amount");\n', '\n', '        signersBacklog[signer].debt = signersBacklog[signer].debt.sub(msg.value);\n', '    }\n', '\n', '    function debt(address signer) public view returns (uint256) {\n', '        return signersBacklog[signer].debt;\n', '    }\n', '\n', '    function gamesLeft(address signer) public view returns (uint256) {\n', '        return TX_PER_SIGNER_LIMIT.sub(signersBacklog[signer].nonce);\n', '    }\n', '\n', '    function withdraw(uint256 amountWei) onlyWhitelisted public {\n', '        msg.sender.transfer(amountWei);\n', '    }\n', '\n', '    function setMetaBet(uint256 _newMetaBet) onlyWhitelisted public {\n', '        META_BET = _newMetaBet;\n', '    }\n', '\n', '    function setTxLimit(uint256 _newTxLimit) onlyWhitelisted public {\n', '        TX_PER_SIGNER_LIMIT = _newTxLimit;\n', '    }\n', '\n', '    function setDebtIncreasingFactor(uint256 _newFactor) onlyWhitelisted public {\n', '        DEBT_INCREASING_FACTOR = _newFactor;\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : dave@akomba.com\n', '// released under Apache 2.0 licence\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract Whitelist is Ownable, RBAC {\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not whitelisted.\n", '   */\n', '  modifier onlyWhitelisted() {\n', '    checkRole(msg.sender, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param addr address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressAdded(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(addr, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      addAddressToWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param addr address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address addr)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(addr, ROLE_WHITELISTED);\n', '    emit WhitelistedAddressRemoved(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param addrs addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] addrs)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < addrs.length; i++) {\n', '      removeAddressFromWhitelist(addrs[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract StartersProxy is Whitelist{\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public TX_PER_SIGNER_LIMIT = 5;          //limit of metatx per signer\n', '    uint256 public META_BET = 1 finney;              //wei, equal to 0.001 ETH\n', '    uint256 public DEBT_INCREASING_FACTOR = 3;       //increasing factor (times) applied on the bet\n', '\n', '    struct Record {\n', '        uint256 nonce;\n', '        uint256 debt;\n', '    }\n', '    mapping(address => Record) signersBacklog;\n', '    event Received (address indexed sender, uint value);\n', '    event Forwarded (address signer, address destination, uint value, bytes data);\n', '\n', '    function() public payable {\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '    constructor(address[] _senders) public {\n', '        addAddressToWhitelist(msg.sender);\n', '        addAddressesToWhitelist(_senders);\n', '    }\n', '\n', '    function forwardPlay(address signer, address destination, bytes data, bytes32 hash, bytes signature) onlyWhitelisted public {\n', '        require(signersBacklog[signer].nonce < TX_PER_SIGNER_LIMIT, "Signer has reached the tx limit");\n', '\n', '        signersBacklog[signer].nonce++;\n', '        //we increase the personal debt here\n', "        //it grows much (much) faster than the actual bet to compensate sender's and proxy's expenses\n", '        uint256 debtIncrease = META_BET.mul(DEBT_INCREASING_FACTOR);\n', '        signersBacklog[signer].debt = signersBacklog[signer].debt.add(debtIncrease);\n', '\n', '        forward(signer, destination, META_BET, data, hash, signature);\n', '    }\n', '\n', '    function forwardWin(address signer, address destination, bytes data, bytes32 hash, bytes signature) onlyWhitelisted public {\n', "        require(signersBacklog[signer].nonce > 0, 'Hm, no meta plays for this signer');\n", '\n', '        forward(signer, destination, 0, data, hash, signature);\n', '    }\n', '\n', '    function forward(address signer, address destination,  uint256 value, bytes data, bytes32 hash, bytes signature) internal {\n', '        require(recoverSigner(hash, signature) == signer);\n', '\n', '        //execute the transaction with all the given parameters\n', '        require(executeCall(destination, value, data));\n', '        emit Forwarded(signer, destination, value, data);\n', '    }\n', '\n', "    //borrowed from OpenZeppelin's ESDA stuff:\n", '    //https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/cryptography/ECDSA.sol\n', '    function recoverSigner(bytes32 _hash, bytes _signature) onlyWhitelisted public view returns (address){\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        // Check the signature length\n', '        require (_signature.length == 65);\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        assembly {\n', '            r := mload(add(_signature, 32))\n', '            s := mload(add(_signature, 64))\n', '            v := byte(0, mload(add(_signature, 96)))\n', '        }\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '        // If the version is correct return the signer address\n', '        require(v == 27 || v == 28);\n', '        return ecrecover(keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)\n', '            ), v, r, s);\n', '    }\n', '\n', '    // this originally was copied from GnosisSafe\n', '    // https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/GnosisSafe.sol\n', '    function executeCall(address to, uint256 value, bytes data) internal returns (bool success) {\n', '        assembly {\n', '            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n', '        }\n', '    }\n', '\n', '    function payDebt(address signer) public payable{\n', '        require(signersBacklog[signer].nonce > 0, "Provided address has no debt");\n', '        require(signersBacklog[signer].debt >= msg.value, "Address\'s debt is less than payed amount");\n', '\n', '        signersBacklog[signer].debt = signersBacklog[signer].debt.sub(msg.value);\n', '    }\n', '\n', '    function debt(address signer) public view returns (uint256) {\n', '        return signersBacklog[signer].debt;\n', '    }\n', '\n', '    function gamesLeft(address signer) public view returns (uint256) {\n', '        return TX_PER_SIGNER_LIMIT.sub(signersBacklog[signer].nonce);\n', '    }\n', '\n', '    function withdraw(uint256 amountWei) onlyWhitelisted public {\n', '        msg.sender.transfer(amountWei);\n', '    }\n', '\n', '    function setMetaBet(uint256 _newMetaBet) onlyWhitelisted public {\n', '        META_BET = _newMetaBet;\n', '    }\n', '\n', '    function setTxLimit(uint256 _newTxLimit) onlyWhitelisted public {\n', '        TX_PER_SIGNER_LIMIT = _newTxLimit;\n', '    }\n', '\n', '    function setDebtIncreasingFactor(uint256 _newFactor) onlyWhitelisted public {\n', '        DEBT_INCREASING_FACTOR = _newFactor;\n', '    }\n', '\n', '\n', '}']
