['pragma solidity ^0.5.2;\n', '\n', '// File: contracts/Oracle/DSMath.sol\n', '\n', 'contract DSMath {\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '\n', '    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '\n', '    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) internal pure returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Oracle/DSAuth.sol\n', '\n', 'contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n', '}\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority(address indexed authority);\n', '    event LogSetOwner(address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority public authority;\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) public auth {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_) public auth {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "It must be an authorized call");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/DSNote.sol\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4 indexed sig,\n', '        address indexed guy,\n', '        bytes32 indexed foo,\n', '        bytes32 bar,\n', '        uint wad,\n', '        bytes fax\n', '    );\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(\n', '            msg.sig,\n', '            msg.sender,\n', '            foo,\n', '            bar,\n', '            msg.value,\n', '            msg.data\n', '        );\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/DSThing.sol\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {}\n', '\n', '// File: contracts/Oracle/PriceFeed.sol\n', '\n', '/// price-feed.sol\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', '\n', 'contract PriceFeed is DSThing {\n', '    uint128 val;\n', '    uint32 public zzz;\n', '\n', '    function peek() public view returns (bytes32, bool) {\n', '        return (bytes32(uint256(val)), block.timestamp < zzz);\n', '    }\n', '\n', '    function read() public view returns (bytes32) {\n', '        assert(block.timestamp < zzz);\n', '        return bytes32(uint256(val));\n', '    }\n', '\n', '    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\n', '        val = val_;\n', '        zzz = zzz_;\n', '        (bool success, ) = med_.call(abi.encodeWithSignature("poke()"));\n', '        require(success, "The poke must succeed");\n', '    }\n', '\n', '    function void() public payable note auth {\n', '        zzz = 0;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Oracle/DSValue.sol\n', '\n', 'contract DSValue is DSThing {\n', '    bool has;\n', '    bytes32 val;\n', '    function peek() public view returns (bytes32, bool) {\n', '        return (val, has);\n', '    }\n', '\n', '    function read() public view returns (bytes32) {\n', '        (bytes32 wut, bool _has) = peek();\n', '        assert(_has);\n', '        return wut;\n', '    }\n', '\n', '    function poke(bytes32 wut) public payable note auth {\n', '        val = wut;\n', '        has = true;\n', '    }\n', '\n', '    function void() public payable note auth {\n', '        // unset the value\n', '        has = false;\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/Medianizer.sol\n', '\n', 'contract Medianizer is DSValue {\n', '    mapping(bytes12 => address) public values;\n', '    mapping(address => bytes12) public indexes;\n', '    bytes12 public next = bytes12(uint96(1));\n', '    uint96 public minimun = 0x1;\n', '\n', '    function set(address wat) public auth {\n', '        bytes12 nextId = bytes12(uint96(next) + 1);\n', '        assert(nextId != 0x0);\n', '        set(next, wat);\n', '        next = nextId;\n', '    }\n', '\n', '    function set(bytes12 pos, address wat) public payable note auth {\n', '        require(pos != 0x0, "pos cannot be 0x0");\n', '        require(wat == address(0) || indexes[wat] == 0, "wat is not defined or it has an index");\n', '\n', '        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\n', '\n', '        if (wat != address(0)) {\n', '            indexes[wat] = pos;\n', '        }\n', '\n', '        values[pos] = wat;\n', '    }\n', '\n', '    function setMin(uint96 min_) public payable note auth {\n', '        require(min_ != 0x0, "min cannot be 0x0");\n', '        minimun = min_;\n', '    }\n', '\n', '    function setNext(bytes12 next_) public payable note auth {\n', '        require(next_ != 0x0, "next cannot be 0x0");\n', '        next = next_;\n', '    }\n', '\n', '    function unset(bytes12 pos) public {\n', '        set(pos, address(0));\n', '    }\n', '\n', '    function unset(address wat) public {\n', '        set(indexes[wat], address(0));\n', '    }\n', '\n', '    function poke() public {\n', '        poke(0);\n', '    }\n', '\n', '    function poke(bytes32) public payable note {\n', '        (val, has) = compute();\n', '    }\n', '\n', '    function compute() public view returns (bytes32, bool) {\n', '        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n', '        uint96 ctr = 0;\n', '        for (uint96 i = 1; i < uint96(next); i++) {\n', '            if (values[bytes12(i)] != address(0)) {\n', '                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\n', '                if (wuz) {\n', '                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n', '                        wuts[ctr] = wut;\n', '                    } else {\n', '                        uint96 j = 0;\n', '                        while (wut >= wuts[j]) {\n', '                            j++;\n', '                        }\n', '                        for (uint96 k = ctr; k > j; k--) {\n', '                            wuts[k] = wuts[k - 1];\n', '                        }\n', '                        wuts[j] = wut;\n', '                    }\n', '                    ctr++;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (ctr < minimun)\n', '            return (val, false);\n', '\n', '        bytes32 value;\n', '        if (ctr % 2 == 0) {\n', '            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\n', '            uint128 val2 = uint128(uint(wuts[ctr / 2]));\n', '            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\n', '        } else {\n', '            value = wuts[(ctr - 1) / 2];\n', '        }\n', '\n', '        return (value, true);\n', '    }\n', '}\n', '\n', '// File: contracts/Oracle/PriceOracleInterface.sol\n', '\n', '/*\n', 'This contract is the interface between the MakerDAO priceFeed and our DX platform.\n', '*/\n', '\n', '\n', '\n', '\n', 'contract PriceOracleInterface {\n', '    address public priceFeedSource;\n', '    address public owner;\n', '    bool public emergencyMode;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Only the owner can do the operation");\n', '        _;\n', '    }\n', '\n', '    /// @dev constructor of the contract\n', '    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\n', '    constructor(address _owner, address _priceFeedSource) public {\n', '        owner = _owner;\n', '        priceFeedSource = _priceFeedSource;\n', '    }\n', '    \n', '    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\n', '    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\n', '    function raiseEmergency(bool _emergencyMode) public onlyOwner {\n', '        emergencyMode = _emergencyMode;\n', '    }\n', '\n', '    /// @dev updates the priceFeedSource\n', '    /// @param _owner address of owner\n', '    function updateCurator(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '\n', '    /// @dev returns the USDETH price\n', '    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\n', '        return Medianizer(priceFeedSource).peek();\n', '    }\n', '\n', '    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\n', '    function getUSDETHPrice() public view returns (uint256) {\n', '        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\n', '        if (emergencyMode) {\n', '            return 600;\n', '        }\n', '        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\n', '\n', '        // ensuring that there is no underflow or overflow possible,\n', '        // even if the price is compromised\n', '        uint priceUint = uint256(price)/(1 ether);\n', '        if (priceUint == 0) {\n', '            return 1;\n', '        }\n', '        if (priceUint > 1000000) {\n', '            return 1000000; \n', '        }\n', '        return priceUint;\n', '    }\n', '}']