['// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressArrayUtils.sol\n', '\n', '// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\n', '// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'library AddressArrayUtils {\n', '\n', '    /**\n', '     * Finds the index of the first occurrence of the given element.\n', '     * @param A The input array to search\n', '     * @param a The value to find\n', '     * @return Returns (index and isIn) for the first occurrence starting from index 0\n', '     */\n', '    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (A[i] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '    * Returns true if the value is present in the list. Uses indexOf internally.\n', '    * @param A The input array to search\n', '    * @param a The value to find\n', '    * @return Returns isIn for the first occurrence starting from index 0\n', '    */\n', '    function contains(address[] memory A, address a) internal pure returns (bool) {\n', '        bool isIn;\n', '        (, isIn) = indexOf(A, a);\n', '        return isIn;\n', '    }\n', '\n', '    /// @return Returns index and isIn for the first occurrence starting from\n', '    /// end\n', '    function indexOfFromEnd(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = length; i > 0; i--) {\n', '            if (A[i - 1] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (0, false);\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of the two arrays\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A extended by B\n', '     */\n', '    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 aLength = A.length;\n', '        uint256 bLength = B.length;\n', '        address[] memory newAddresses = new address[](aLength + bLength);\n', '        for (uint256 i = 0; i < aLength; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = 0; j < bLength; j++) {\n', '            newAddresses[aLength + j] = B[j];\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the array with a appended to A.\n', '     * @param A The first array\n', '     * @param a The value to append\n', '     * @return Returns A appended by a\n', '     */\n', '    function append(address[] memory A, address a) internal pure returns (address[] memory) {\n', '        address[] memory newAddresses = new address[](A.length + 1);\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        newAddresses[A.length] = a;\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of two storage arrays.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A appended by a\n', '     */\n', '    function sExtend(address[] storage A, address[] storage B) internal {\n', '        uint256 length = B.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            A.push(B[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The intersection of the two arrays\n', '     */\n', '    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 newLength = 0;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (contains(B, A[i])) {\n', '                includeMap[i] = true;\n', '                newLength++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](newLength);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Returns the union of the two arrays. Order is not guaranteed.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The union of the two arrays\n', '     */\n', '    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        address[] memory leftDifference = difference(A, B);\n', '        address[] memory rightDifference = difference(B, A);\n', '        address[] memory intersection = intersect(A, B);\n', '        return extend(leftDifference, extend(intersection, rightDifference));\n', '    }\n', '\n', '    /**\n', '     * Alternate implementation\n', '     * Assumes there are no duplicates\n', '     */\n', '    function unionB(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        bool[] memory includeMap = new bool[](A.length + B.length);\n', '        uint256 count = 0;\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            includeMap[i] = true;\n', '            count++;\n', '        }\n', '        for (uint256 j = 0; j < B.length; j++) {\n', '            if (!contains(A, B[j])) {\n', '                includeMap[A.length + j] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 k = 0;\n', '        for (uint256 m = 0; m < A.length; m++) {\n', '            if (includeMap[m]) {\n', '                newAddresses[k] = A[m];\n', '                k++;\n', '            }\n', '        }\n', '        for (uint256 n = 0; n < B.length; n++) {\n', '            if (includeMap[A.length + n]) {\n', '                newAddresses[k] = B[n];\n', '                k++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '     * Computes the difference of two arrays. Assumes there are no duplicates.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return The difference of the two arrays\n', '     */\n', '    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 length = A.length;\n', '        bool[] memory includeMap = new bool[](length);\n', '        uint256 count = 0;\n', "        // First count the new length because can't push for in-memory arrays\n", '        for (uint256 i = 0; i < length; i++) {\n', '            address e = A[i];\n', '            if (!contains(B, e)) {\n', '                includeMap[i] = true;\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory newAddresses = new address[](count);\n', '        uint256 j = 0;\n', '        for (uint256 k = 0; k < length; k++) {\n', '            if (includeMap[k]) {\n', '                newAddresses[j] = A[k];\n', '                j++;\n', '            }\n', '        }\n', '        return newAddresses;\n', '    }\n', '\n', '    /**\n', '    * @dev Reverses storage array in place\n', '    */\n', '    function sReverse(address[] storage A) internal {\n', '        address t;\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length / 2; i++) {\n', '            t = A[i];\n', '            A[i] = A[A.length - i - 1];\n', '            A[A.length - i - 1] = t;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Removes specified index from array\n', '    * Resulting ordering is not guaranteed\n', '    * @return Returns the new array and the removed entry\n', '    */\n', '    function pop(address[] memory A, uint256 index)\n', '        internal\n', '        pure\n', '        returns (address[] memory, address)\n', '    {\n', '        uint256 length = A.length;\n', '        address[] memory newAddresses = new address[](length - 1);\n', '        for (uint256 i = 0; i < index; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = index + 1; j < length; j++) {\n', '            newAddresses[j - 1] = A[j];\n', '        }\n', '        return (newAddresses, A[index]);\n', '    }\n', '\n', '    /**\n', '     * @return Returns the new array\n', '     */\n', '    function remove(address[] memory A, address a)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert();\n', '        } else {\n', '            (address[] memory _A,) = pop(A, index);\n', '            return _A;\n', '        }\n', '    }\n', '\n', '    function sPop(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        for (uint256 i = index; i < length - 1; i++) {\n', '            A[i] = A[i + 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '    * Deletes address at index and fills the spot with the last address.\n', '    * Order is not preserved.\n', '    * @return Returns the removed entry\n', '    */\n', '    function sPopCheap(address[] storage A, uint256 index) internal returns (address) {\n', '        uint256 length = A.length;\n', '        if (index >= length) {\n', '            revert("Error: index out of bounds");\n', '        }\n', '        address entry = A[index];\n', '        if (index != length - 1) {\n', '            A[index] = A[length - 1];\n', '            delete A[length - 1];\n', '        }\n', '        A.length--;\n', '        return entry;\n', '    }\n', '\n', '    /**\n', '     * Deletes address at index. Works by swapping it with the last address, then deleting.\n', '     * Order is not preserved\n', '     * @param A Storage array to remove from\n', '     */\n', '    function sRemoveCheap(address[] storage A, address a) internal {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert("Error: entry not found");\n', '        } else {\n', '            sPopCheap(A, index);\n', '            return;\n', '        }\n', '    }\n', '\n', '    /**\n', "     * Returns whether or not there's a duplicate. Runs in O(n^2).\n", '     * @param A Array to search\n', '     * @return Returns true if duplicate, false otherwise\n', '     */\n', '    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n', '        if (A.length == 0) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length - 1; i++) {\n', '            for (uint256 j = i + 1; j < A.length; j++) {\n', '                if (A[i] == A[j]) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Returns whether the two arrays are equal.\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return True is the arrays are equal, false if not.\n', '     */\n', '    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\n', '        if (A.length != B.length) {\n', '            return false;\n', '        }\n', '        for (uint256 i = 0; i < A.length; i++) {\n', '            if (A[i] != B[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns the elements indexed at indexArray.\n', '     * @param A The array to index\n', '     * @param indexArray The array to use to index\n', '     * @return Returns array containing elements indexed at indexArray\n', '     */\n', '    function argGet(address[] memory A, uint256[] memory indexArray)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory array = new address[](indexArray.length);\n', '        for (uint256 i = 0; i < indexArray.length; i++) {\n', '            array[i] = A[indexArray[i]];\n', '        }\n', '        return array;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lib/TimeLockUpgrade.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TimeLockUpgrade\n', ' * @author Set Protocol\n', ' *\n', ' * The TimeLockUpgrade contract contains a modifier for handling minimum time period updates\n', ' */\n', 'contract TimeLockUpgrade is\n', '    Ownable\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    // Timelock Upgrade Period in seconds\n', '    uint256 public timeLockPeriod;\n', '\n', '    // Mapping of upgradable units and initialized timelock\n', '    mapping(bytes32 => uint256) public timeLockedUpgrades;\n', '\n', '    /* ============ Events ============ */\n', '\n', '    event UpgradeRegistered(\n', '        bytes32 _upgradeHash,\n', '        uint256 _timestamp\n', '    );\n', '\n', '    /* ============ Modifiers ============ */\n', '\n', '    modifier timeLockUpgrade() {\n', '        // If the time lock period is 0, then allow non-timebound upgrades.\n', '        // This is useful for initialization of the protocol and for testing.\n', '        if (timeLockPeriod == 0) {\n', '            _;\n', '\n', '            return;\n', '        }\n', '\n', '        // The upgrade hash is defined by the hash of the transaction call data,\n', '        // which uniquely identifies the function as well as the passed in arguments.\n', '        bytes32 upgradeHash = keccak256(\n', '            abi.encodePacked(\n', '                msg.data\n', '            )\n', '        );\n', '\n', '        uint256 registrationTime = timeLockedUpgrades[upgradeHash];\n', '\n', "        // If the upgrade hasn't been registered, register with the current time.\n", '        if (registrationTime == 0) {\n', '            timeLockedUpgrades[upgradeHash] = block.timestamp;\n', '\n', '            emit UpgradeRegistered(\n', '                upgradeHash,\n', '                block.timestamp\n', '            );\n', '\n', '            return;\n', '        }\n', '\n', '        require(\n', '            block.timestamp >= registrationTime.add(timeLockPeriod),\n', '            "TimeLockUpgrade: Time lock period must have elapsed."\n', '        );\n', '\n', '        // Reset the timestamp to 0\n', '        timeLockedUpgrades[upgradeHash] = 0;\n', '\n', '        // Run the rest of the upgrades\n', '        _;\n', '    }\n', '\n', '    /* ============ Function ============ */\n', '\n', '    /**\n', '     * Change timeLockPeriod period. Generally called after initially settings have been set up.\n', '     *\n', '     * @param  _timeLockPeriod   Time in seconds that upgrades need to be evaluated before execution\n', '     */\n', '    function setTimeLockPeriod(\n', '        uint256 _timeLockPeriod\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        // Only allow setting of the timeLockPeriod if the period is greater than the existing\n', '        require(\n', '            _timeLockPeriod > timeLockPeriod,\n', '            "TimeLockUpgrade: New period must be greater than existing"\n', '        );\n', '\n', '        timeLockPeriod = _timeLockPeriod;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Authorizable.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Authorizable\n', ' * @author Set Protocol\n', ' *\n', ' * The Authorizable contract is an inherited contract that sets permissions on certain function calls\n', ' * through the onlyAuthorized modifier. Permissions can be managed only by the Owner of the contract.\n', ' */\n', 'contract Authorizable is\n', '    Ownable,\n', '    TimeLockUpgrade\n', '{\n', '    using SafeMath for uint256;\n', '    using AddressArrayUtils for address[];\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    // Mapping of addresses to bool indicator of authorization\n', '    mapping (address => bool) public authorized;\n', '\n', '    // Array of authorized addresses\n', '    address[] public authorities;\n', '\n', '    /* ============ Modifiers ============ */\n', '\n', '    // Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(\n', '            authorized[msg.sender],\n', '            "Authorizable.onlyAuthorized: Sender not included in authorities"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /* ============ Events ============ */\n', '\n', '    // Event emitted when new address is authorized.\n', '    event AddressAuthorized (\n', '        address indexed authAddress,\n', '        address authorizedBy\n', '    );\n', '\n', '    // Event emitted when address is deauthorized.\n', '    event AuthorizedAddressRemoved (\n', '        address indexed addressRemoved,\n', '        address authorizedBy\n', '    );\n', '\n', '    /* ============ Setters ============ */\n', '\n', '    /**\n', '     * Add authorized address to contract. Can only be set by owner.\n', '     *\n', '     * @param  _authTarget   The address of the new authorized contract\n', '     */\n', '\n', '    function addAuthorizedAddress(address _authTarget)\n', '        external\n', '        onlyOwner\n', '        timeLockUpgrade\n', '    {\n', '        // Require that address is not already authorized\n', '        require(\n', '            !authorized[_authTarget],\n', '            "Authorizable.addAuthorizedAddress: Address already registered"\n', '        );\n', '\n', '        // Set address authority to true\n', '        authorized[_authTarget] = true;\n', '\n', '        // Add address to authorities array\n', '        authorities.push(_authTarget);\n', '\n', '        // Emit authorized address event\n', '        emit AddressAuthorized(\n', '            _authTarget,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Remove authorized address from contract. Can only be set by owner.\n', '     *\n', '     * @param  _authTarget   The address to be de-permissioned\n', '     */\n', '\n', '    function removeAuthorizedAddress(address _authTarget)\n', '        external\n', '        onlyOwner\n', '    {\n', '        // Require address is authorized\n', '        require(\n', '            authorized[_authTarget],\n', '            "Authorizable.removeAuthorizedAddress: Address not authorized"\n', '        );\n', '\n', '        // Delete address from authorized mapping\n', '        authorized[_authTarget] = false;\n', '\n', '        authorities = authorities.remove(_authTarget);\n', '\n', '        // Emit AuthorizedAddressRemoved event.\n', '        emit AuthorizedAddressRemoved(\n', '            _authTarget,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /* ============ Getters ============ */\n', '\n', '    /**\n', '     * Get array of authorized addresses.\n', '     *\n', '     * @return address[]   Array of authorized addresses\n', '     */\n', '    function getAuthorizedAddresses()\n', '        external\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        // Return array of authorized addresses\n', '        return authorities;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/CommonMath.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'library CommonMath {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUInt256()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0);\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Checks for rounding errors and returns value of potential partial amounts of a principal\n', '     *\n', '     * @param  _principal       Number fractional amount is derived from\n', '     * @param  _numerator       Numerator of fraction\n', '     * @param  _denominator     Denominator of fraction\n', '     * @return uint256          Fractional amount of principal calculated\n', '     */\n', '    function getPartialAmount(\n', '        uint256 _principal,\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Get remainder of partial amount (if 0 not a partial amount)\n', '        uint256 remainder = mulmod(_principal, _numerator, _denominator);\n', '\n', '        // Return if not a partial amount\n', '        if (remainder == 0) {\n', '            return _principal.mul(_numerator).div(_denominator);\n', '        }\n', '\n', '        // Calculate error percentage\n', '        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\n', '\n', '        // Require error percentage is less than 0.1%.\n', '        require(\n', '            errPercentageTimes1000000 < 1000,\n', '            "CommonMath.getPartialAmount: Rounding error exceeds bounds"\n', '        );\n', '\n', '        return _principal.mul(_numerator).div(_denominator);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lib/IERC20.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IERC20\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for using ERC20 Tokens. This interface is needed to interact with tokens that are not\n', ' * fully ERC20 compliant and return something other than true on successful transfers.\n', ' */\n', 'interface IERC20 {\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC20Wrapper.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Wrapper\n', ' * @author Set Protocol\n', ' *\n', ' * This library contains functions for interacting wtih ERC20 tokens, even those not fully compliant.\n', ' * For all functions we will only accept tokens that return a null or true value, any other values will\n', ' * cause the operation to revert.\n', ' */\n', 'library ERC20Wrapper {\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    /**\n', "     * Check balance owner's balance of ERC20 token\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', "     * @param  _owner          The owner who's balance is being checked\n", "     * @return  uint256        The _owner's amount of tokens\n", '     */\n', '    function balanceOf(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).balanceOf(_owner);\n', '    }\n', '\n', '    /**\n', "     * Checks spender's allowance to use token's on owner's behalf.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The token owner address\n', '     * @param  _spender        The address the allowance is being checked on\n', "     * @return  uint256        The spender's allowance on behalf of owner\n", '     */\n', '    function allowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).allowance(_owner, _spender);\n', '    }\n', '\n', '    /**\n', "     * Transfers tokens from an address. Handle's tokens that return true or null.\n", '     * If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The amount of tokens to transfer\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transfer(_to, _quantity);\n', '\n', '        // Check that transfer returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transfer: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function transferFrom(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transferFrom(_from, _to, _quantity);\n', '\n', '        // Check that transferFrom returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transferFrom: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Grants spender ability to spend on owner's behalf.\n", "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _spender        The address to approve for transfer\n', '     * @param  _quantity       The amount of tokens to approve spender for\n', '     */\n', '    function approve(\n', '        address _token,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        IERC20(_token).approve(_spender, _quantity);\n', '\n', '        // Check that approve returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.approve: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Ensure's the owner has granted enough allowance for system to\n", '     * transfer tokens.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The address of the token owner\n', '     * @param  _spender        The address to grant/check allowance for\n', '     * @param  _quantity       The amount to see if allowed for\n', '     */\n', '    function ensureAllowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        uint256 currentAllowance = allowance(_token, _owner, _spender);\n', '        if (currentAllowance < _quantity) {\n', '            approve(\n', '                _token,\n', '                _spender,\n', '                CommonMath.maxUInt256()\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 1.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // default to failure\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        // check if returned value is one or nothing\n', '        return returnValue == 1;\n', '    }\n', '}\n', '\n', '// File: contracts/core/TransferProxy.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TransferProxy\n', ' * @author Set Protocol\n', ' *\n', ' * The transferProxy contract is responsible for moving tokens through the system to\n', ' * assist with issuance and usage from modules.\n', ' */\n', '\n', 'contract TransferProxy is\n', '    Authorizable\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by Core.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _quantity       The number of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        uint256 _quantity,\n', '        address _from,\n', '        address _to\n', '    )\n', '        public\n', '        onlyAuthorized\n', '    {\n', '        // Call specified ERC20 contract to transfer tokens (via proxy).\n', '        if (_quantity > 0) {\n', '            // Retrieve current balance of token for the receiver\n', '            uint256 existingBalance = ERC20Wrapper.balanceOf(\n', '                _token,\n', '                _to\n', '            );\n', '\n', '            ERC20Wrapper.transferFrom(\n', '                _token,\n', '                _from,\n', '                _to,\n', '                _quantity\n', '            );\n', '\n', '            // Get new balance of transferred token for receiver\n', '            uint256 newBalance = ERC20Wrapper.balanceOf(\n', '                _token,\n', '                _to\n', '            );\n', '\n', '            // Verify transfer quantity is reflected in balance\n', '            require(\n', '                newBalance == existingBalance.add(_quantity),\n', '                "TransferProxy.transfer: Invalid post transfer balance"\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', '     * Can only be called by Core.\n', '     *\n', '     * @param  _tokens         The addresses of the ERC20 token\n', '     * @param  _quantities     The numbers of tokens to transfer\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     */\n', '    function batchTransfer(\n', '        address[] calldata _tokens,\n', '        uint256[] calldata _quantities,\n', '        address _from,\n', '        address _to\n', '    )\n', '        external\n', '        onlyAuthorized\n', '    {\n', '        // Storing token count to local variable to save on invocation\n', '        uint256 tokenCount = _tokens.length;\n', '\n', '        // Confirm and empty _tokens array is not passed\n', '        require(\n', '            tokenCount > 0,\n', '            "TransferProxy.batchTransfer: Tokens must not be empty"\n', '        );\n', '\n', '        // Confirm there is one quantity for every token address\n', '        require(\n', '            tokenCount == _quantities.length,\n', '            "TransferProxy.batchTransfer: Tokens and quantities lengths mismatch"\n', '        );\n', '\n', '        for (uint256 i = 0; i < tokenCount; i++) {\n', '            if (_quantities[i] > 0) {\n', '                transfer(\n', '                    _tokens[i],\n', '                    _quantities[i],\n', '                    _from,\n', '                    _to\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '}']