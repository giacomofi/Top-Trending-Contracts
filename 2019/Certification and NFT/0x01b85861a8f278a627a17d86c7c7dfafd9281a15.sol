['pragma solidity ^0.5.0;\n', '//p3Dank.io\n', '//A never ending free for all strategy game\n', '//send 0.2 ETH to contract to play\n', '//you get 3 lives/plants/houses(it can be anything, you get 3)\n', '//you cant rebuy till your out\n', '//each life has a type\n', '//BLOCK smashes fork\n', '//FORK forks the chain\n', '//CHAIN adds the block\n', '//plants automatically grow over time \n', '//the older the plants get a bigger % bonus for selling\n', '//choose to sell 1 plant or attack at random every 7 hours \n', '//if your random attack wins the rock paper scissors...\n', '//you sell the targets plant for 50% its base value(no bonus)\n', '//sucessful attacks raise the value of every other plant, >>DONT MISS ATTACKS<<\n', '//sold plants have a bonus and reduce the value of every other plant. \n', '//Sell bonus is 2x after 42000 blocks, Max bonus of 4x after 69420 blocks\n', '//sell price = (total eth in contract) * (growth of plant being sold) / (total growth in game) + (big plant bonus)\n', '//1% dev cut 99% back to players.\n', '//If this works as intended the game expands and contracts to any amount of players and never ends\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '        }\n', '    }\n', '\n', '\n', '\n', '//import "browser/safemath.sol";\n', '\n', 'contract p3Dank  {\n', '    using SafeMath for uint;\n', '    uint256 public _totalhouses; // total number of houses in the game, used to calc divs\n', '    uint256 public blocksbeforeaction = 1680;// blocks between player action. 7 hours / 420 minutes / 3 moves per day\n', '    uint256 public nextFormation;// next spot in formation\n', '    mapping(address => uint256)public _playerhouses; // number of houses owned by player\n', '    mapping(address => uint256)public lastmove;//blocknumber lastMove\n', '    mapping(address => uint256) buyblock;// block that houses were purchased by a player\n', '    address payable happydev = 0xDC6dfe8040fc162Ab318De99c63Ec2cd0e203010; // dev cut\n', '\n', '   struct house { //houses for the battlefield\n', '       address owner; //who owns the house\n', '       uint8 rpstype; //what type of house is it 1=roc 2=pap 3=sis\n', '   }\n', '\n', '    mapping(uint256 => house)public formation;// the playing field\n', '\n', '    //modifiers\n', '\n', '    modifier ishuman() {//"real" players only\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '\n', '    modifier canmove() {\n', '          address sender = msg.sender;\n', '          require(_playerhouses[sender] > 0);\n', '          require(canimoveyet());\n', '          _;\n', '    }\n', '\n', '    //events\n', '\n', '    event sell (address seller, uint256 plantsize, uint256 cashout);\n', '    event battle(address attacker, uint8 ktype, address defender);\n', '    event win (uint256 position, uint256 sizesold, uint256 amountsent);    \n', '\n', '    function () external payable{}\n', '\n', '    function buyhouses() ishuman() public payable { // houses... plants... lives ... its all good\n', '        uint256 value = msg.value;\n', '        if(value == 200 finney){// buying 3 houses costs 0.2 eth\n', '            address sender = msg.sender;\n', '            if(_playerhouses[sender] == 0 ){ // check that user has no houses\n', '                _playerhouses[sender] = 3; // add houses to players count\n', '                uint256 next = nextFormation;\n', '                formation[next++] = house(sender, 1);// add houses to playing field\n', '                formation[next++] = house(sender, 2);// roc = 1, pap =2, sis = 3.\n', '                formation[next++] = house(sender, 3);\n', '                nextFormation = next;\n', '                lastmove[sender] = block.number; // reset lastMove to prevent people from attacking right away\n', '                buyblock[sender] = block.number; // log the buy block of the sender\n', '                _totalhouses += 3;// update totalSupply\n', '                happydev.transfer(2 finney);\n', '                totaldivpts += 3000;\n', '                } } }\n', '\n', '    bool gameon;\n', '\n', '    function startgame() public payable {\n', '        uint256 value = msg.value;\n', '        require(value == 200 finney);// buying 3 houses costs 0.2 eth\n', '        require (gameon == false);\n', '        address sender = msg.sender;\n', '        _playerhouses[sender] = _playerhouses[sender]+3;// add houses to players count\n', '        formation[nextFormation] = house(sender, 1);// add houses to playing field\n', '        nextFormation++;\n', '        formation[nextFormation] = house(sender, 2);// roc = 1, pap =2, sis = 3.\n', '        nextFormation++;\n', '        formation[nextFormation] = house(sender, 3);\n', '        nextFormation++;\n', '        lastmove[sender] = block.number; // reset lastMove to prevent people from attacking right away\n', '        buyblock[sender] = block.number; // log the buy block of the sender\n', '        _totalhouses = _totalhouses+3;// update totalSupply\n', '        happydev.transfer(2 finney);\n', '        lastupdateblock = block.number;\n', '        gameon = true;\n', '        totaldivpts += 3000;\n', '    }\n', '\n', '    //divsection\n', '    uint256 lastupdateblock;\n', '    uint256 totaldivpts;\n', '\n', '    function updateglobal() internal {                       \n', '        totaldivpts = gametotaldivs();\n', '        lastupdateblock = block.number;//updated\n', '        lastmove[msg.sender] = block.number; // reset lastmove of attacker\n', '    }\n', '\n', '    function rekt(uint8 typeToKill) internal {\n', '        updateglobal();\n', '        uint256 attacked = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, tx.origin))) % nextFormation;\n', '        uint256 _rpstype = formation[attacked].rpstype;\n', '        address killed = formation[attacked].owner;//set address of attacked player\n', '        address payable sender = msg.sender;\n', '        if(_rpstype == typeToKill) {\n', '            formation[attacked] = formation[--nextFormation];//reform playing field\n', '            delete formation[nextFormation];  //delete unused formation\n', '            uint256 playerdivpts = block.number.sub(buyblock[killed]).add(1000);//figure out how big robbed plant is\n', '            uint256 robbed = (address(this).balance).mul(playerdivpts).div(totaldivpts).div(2); //figure out how much was robbed\n', '            totaldivpts = totaldivpts.sub(playerdivpts); //adjust total div points\n', '            _totalhouses--;//update total houses in game\n', '            _playerhouses[killed]--;//update attacked players houses\n', '            sender.transfer(robbed);//pay the robber\n', '            emit win(attacked, playerdivpts, robbed);  \n', '        }\n', '        emit battle(sender, typeToKill, killed);\n', '        } \n', '  \n', '        \n', '\n', '    function rockattack() canmove() public { //rock attack function\n', '        rekt(3);\n', '        }\n', '\n', '    function sisattack() canmove() public { //sicssor attack function\n', '        rekt(1);\n', '        }\n', '\n', '    function papattack() canmove() public {//paper attack function\n', '        rekt(2);\n', '        }\n', '\n', '    function sellhouse (uint256 selling) canmove() public {// house sell function\n', '        address payable sender = msg.sender;\n', '        address beingsold = formation[selling].owner;\n', '        if (beingsold == sender){ // how to comfirm sender is owner\n', '            updateglobal();\n', '            uint256 next = --nextFormation;\n', '            formation[selling] = formation[next];\n', '            delete formation[next];\n', '            _totalhouses--;//update total houses in game\n', '            _playerhouses[sender]--;//update selling players houses\n', '            uint256 maxbuyblock = 69420;\n', '            uint256 playerdivpts = block.number.sub(buyblock[sender]).add(1000);\n', '            uint256 sold;\n', '            if (playerdivpts >= maxbuyblock) {\n', '                sold = (address(this).balance).mul(maxbuyblock * 4).div(totaldivpts);\n', '                }\n', '            else {\n', '                uint256 payoutmultiplier = playerdivpts.mul(playerdivpts).mul(10000).div(1953640000).add(10000);\n', '                sold = (address(this).balance).mul(playerdivpts).mul(payoutmultiplier).div(totaldivpts).div(10000);\n', '            }\n', '            totaldivpts = totaldivpts.sub(playerdivpts); //adjust total div points\n', '            sender.transfer(sold);//payout\n', '            emit sell(sender, playerdivpts, sold);\n', '            } }         \n', '\n', '\n', '    //view functions\n', '    function singleplantdivs ()public view returns(uint256){ //how big are are my plants?\n', '        return(block.number.sub(buyblock[msg.sender]).add(1000));\n', '    }\n', '    function howmanyplants ()public view returns(uint256){ //how many plants do I have?\n', '        return(_playerhouses[msg.sender]);\n', '    }\n', '    function whatblockmove ()public view returns(uint256){  // what block # can I make my next move at\n', '        return(lastmove[msg.sender]).add(blocksbeforeaction);\n', '    }\n', '    function canimoveyet ()public view returns(bool){ //can i move\n', '        if (blocksbeforeaction <= (block.number).sub(lastmove[msg.sender])) return true;\n', '    }\n', '    function howmucheth ()public view returns(uint256){//how much eth is in the contract\n', '        return address(this).balance;\n', '    }\n', '    function gametotaldivs ()public view returns(uint256){//how many div points are in the game right now\n', '        return (block.number).sub(lastupdateblock).mul(_totalhouses).add(totaldivpts);\n', '    }\n', '    function singleplantpayout ()public view returns(uint256){\n', '        uint256 playerdivpts = block.number.sub(buyblock[msg.sender]).add(1000);\n', '        uint256 maxbuyblock = 69420;\n', '        if (playerdivpts >= maxbuyblock) {\n', '            return (address(this).balance).mul(maxbuyblock * 4).div(totaldivpts);\n', '        }\n', '        else {\n', '            uint256 payoutmultiplier = playerdivpts.mul(playerdivpts).mul(10000).div(1953640000).add(10000);\n', '            return (address(this).balance).mul(playerdivpts).mul(payoutmultiplier).div(totaldivpts).div(10000);\n', '        }\n', '    }\n', '\n', '//thanks for playing\n', '}']