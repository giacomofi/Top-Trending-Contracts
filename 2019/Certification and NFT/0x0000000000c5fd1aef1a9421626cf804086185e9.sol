['pragma solidity 0.4.26; // optimization enabled, runs: 500\n', '\n', '\n', '/************** TPL Extended Jurisdiction - YES token integration *************\n', ' * This digital jurisdiction supports assigning YES token, or other contracts *\n', ' * with a similar validation mechanism, as additional attribute validators.   *\n', ' * https://github.com/TPL-protocol/tpl-contracts/tree/yes-token-integration   *\n', ' * Implements an Attribute Registry https://github.com/0age/AttributeRegistry *\n', ' *                                                                            *\n', ' * Source layout:                                    Line #                   *\n', ' *  - library ECDSA                                    41                     *\n', ' *  - library SafeMath                                108                     *\n', ' *  - library Roles                                   172                     *\n', ' *  - contract PauserRole                             212                     *\n', ' *    - using Roles for Roles.Role                                            *\n', ' *  - contract Pausable                               257                     *\n', ' *    - is PauserRole                                                         *\n', ' *  - contract Ownable                                313                     *\n', ' *  - interface AttributeRegistryInterface            386                     *\n', ' *  - interface BasicJurisdictionInterface            440                     *\n', ' *  - interface ExtendedJurisdictionInterface         658                     *\n', ' *  - interface IERC20 (partial)                      926                     *\n', ' *  - ExtendedJurisdiction                            934                     *\n', ' *    - is Ownable                                                            *\n', ' *    - is Pausable                                                           *\n', ' *    - is AttributeRegistryInterface                                         *\n', ' *    - is BasicJurisdictionInterface                                         *\n', ' *    - is ExtendedJurisdictionInterface                                      *\n', ' *    - using ECDSA for bytes32                                               *\n', ' *    - using SafeMath for uint256                                            *\n', ' *                                                                            *\n', ' *  https://github.com/TPL-protocol/tpl-contracts/blob/master/LICENSE.md      *\n', ' ******************************************************************************/\n', '\n', '\n', '/**\n', ' * @title Elliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', 'library ECDSA {\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes signature)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (signature.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(signature, 0x20))\n', '      s := mload(add(signature, 0x40))\n', '      v := byte(0, mload(add(signature, 0x60)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an account access to this role\n', '   */\n', '  function add(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(!has(role, account));\n', '\n', '    role.bearer[account] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an account's access to this role\n", '   */\n', '  function remove(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(has(role, account));\n', '\n', '    role.bearer[account] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an account has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address account)\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(account != address(0));\n', '    return role.bearer[account];\n', '  }\n', '}\n', '\n', '\n', 'contract PauserRole {\n', '  using Roles for Roles.Role;\n', '\n', '  event PauserAdded(address indexed account);\n', '  event PauserRemoved(address indexed account);\n', '\n', '  Roles.Role private pausers;\n', '\n', '  constructor() internal {\n', '    _addPauser(msg.sender);\n', '  }\n', '\n', '  modifier onlyPauser() {\n', '    require(isPauser(msg.sender));\n', '    _;\n', '  }\n', '\n', '  function isPauser(address account) public view returns (bool) {\n', '    return pausers.has(account);\n', '  }\n', '\n', '  function addPauser(address account) public onlyPauser {\n', '    _addPauser(account);\n', '  }\n', '\n', '  function renouncePauser() public {\n', '    _removePauser(msg.sender);\n', '  }\n', '\n', '  function _addPauser(address account) internal {\n', '    pausers.add(account);\n', '    emit PauserAdded(account);\n', '  }\n', '\n', '  function _removePauser(address account) internal {\n', '    pausers.remove(account);\n', '    emit PauserRemoved(account);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '  event Paused(address account);\n', '  event Unpaused(address account);\n', '\n', '  bool private _paused;\n', '\n', '  constructor() internal {\n', '    _paused = false;\n', '  }\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns(bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyPauser whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyPauser whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor(address owner) internal {\n', '    _owner = owner;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Attribute Registry interface. EIP-165 ID: 0x5f46473f\n', ' */\n', 'interface AttributeRegistryInterface {\n', '  /**\n', '   * @notice Check if an attribute of the type with ID `attributeTypeID` has\n', '   * been assigned to the account at `account` and is currently valid.\n', '   * @param account address The account to check for a valid attribute.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return True if the attribute is assigned and valid, false otherwise.\n', '   * @dev This function MUST return either true or false - i.e. calling this\n', '   * function MUST NOT cause the caller to revert.\n', '   */\n', '  function hasAttribute(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external view returns (bool);\n', '\n', '  /**\n', '   * @notice Retrieve the value of the attribute of the type with ID\n', '   * `attributeTypeID` on the account at `account`, assuming it is valid.\n', '   * @param account address The account to check for the given attribute value.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return The attribute value if the attribute is valid, reverts otherwise.\n', '   * @dev This function MUST revert if a directly preceding or subsequent\n', '   * function call to `hasAttribute` with identical `account` and\n', '   * `attributeTypeID` parameters would return false.\n', '   */\n', '  function getAttributeValue(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Count the number of attribute types defined by the registry.\n', '   * @return The number of available attribute types.\n', '   * @dev This function MUST return a positive integer value  - i.e. calling\n', '   * this function MUST NOT cause the caller to revert.\n', '   */\n', '  function countAttributeTypes() external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the ID of the attribute type at index `index`.\n', '   * @param index uint256 The index of the attribute type in question.\n', '   * @return The ID of the attribute type.\n', '   * @dev This function MUST revert if the provided `index` value falls outside\n', '   * of the range of the value returned from a directly preceding or subsequent\n', '   * function call to `countAttributeTypes`. It MUST NOT revert if the provided\n', '   * `index` value falls inside said range.\n', '   */\n', '  function getAttributeTypeID(uint256 index) external view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic TPL Jurisdiction Interface.\n', ' */\n', 'interface BasicJurisdictionInterface {\n', '  // declare events\n', '  event AttributeTypeAdded(uint256 indexed attributeTypeID, string description);\n', '  \n', '  event AttributeTypeRemoved(uint256 indexed attributeTypeID);\n', '  \n', '  event ValidatorAdded(address indexed validator, string description);\n', '  \n', '  event ValidatorRemoved(address indexed validator);\n', '  \n', '  event ValidatorApprovalAdded(\n', '    address validator,\n', '    uint256 indexed attributeTypeID\n', '  );\n', '\n', '  event ValidatorApprovalRemoved(\n', '    address validator,\n', '    uint256 indexed attributeTypeID\n', '  );\n', '\n', '  event AttributeAdded(\n', '    address validator,\n', '    address indexed attributee,\n', '    uint256 attributeTypeID,\n', '    uint256 attributeValue\n', '  );\n', '\n', '  event AttributeRemoved(\n', '    address validator,\n', '    address indexed attributee,\n', '    uint256 attributeTypeID\n', '  );\n', '\n', '  /**\n', '  * @notice Add an attribute type with ID `ID` and description `description` to\n', '  * the jurisdiction.\n', '  * @param ID uint256 The ID of the attribute type to add.\n', '  * @param description string A description of the attribute type.\n', '  * @dev Once an attribute type is added with a given ID, the description of the\n', '  * attribute type cannot be changed, even if the attribute type is removed and\n', '  * added back later.\n', '  */\n', '  function addAttributeType(uint256 ID, string description) external;\n', '\n', '  /**\n', '  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\n', '  * @param ID uint256 The ID of the attribute type to remove.\n', '  * @dev All issued attributes of the given type will become invalid upon\n', '  * removal, but will become valid again if the attribute is reinstated.\n', '  */\n', '  function removeAttributeType(uint256 ID) external;\n', '\n', '  /**\n', '  * @notice Add account `validator` as a validator with a description\n', '  * `description` who can be approved to set attributes of specific types.\n', '  * @param validator address The account to assign as the validator.\n', '  * @param description string A description of the validator.\n', '  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\n', '  */\n', '  function addValidator(address validator, string description) external;\n', '\n', '  /**\n', '  * @notice Remove the validator at address `validator` from the jurisdiction.\n', '  * @param validator address The account of the validator to remove.\n', '  * @dev Any attributes issued by the validator will become invalid upon their\n', '  * removal. If the validator is reinstated, those attributes will become valid\n', '  * again. Any approvals to issue attributes of a given type will need to be\n', '  * set from scratch in the event a validator is reinstated.\n', '  */\n', '  function removeValidator(address validator) external;\n', '\n', '  /**\n', '  * @notice Approve the validator at address `validator` to issue attributes of\n', '  * the type with ID `attributeTypeID`.\n', '  * @param validator address The account of the validator to approve.\n', '  * @param attributeTypeID uint256 The ID of the approved attribute type.\n', '  */\n', '  function addValidatorApproval(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external;\n', '\n', '  /**\n', '  * @notice Deny the validator at address `validator` the ability to continue to\n', '  * issue attributes of the type with ID `attributeTypeID`.\n', '  * @param validator address The account of the validator with removed approval.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\n', '  * @dev Any attributes of the specified type issued by the validator in\n', '  * question will become invalid once the approval is removed. If the approval\n', '  * is reinstated, those attributes will become valid again. The approval will\n', '  * also be removed if the approved validator is removed.\n', '  */\n', '  function removeValidatorApproval(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external;\n', '\n', '  /**\n', '  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\n', '  * of `value` to `account` if `message.caller.address()` is approved validator.\n', '  * @param account address The account to issue the attribute on.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to issue.\n', '  * @param value uint256 An optional value for the issued attribute.\n', '  * @dev Existing attributes of the given type on the address must be removed\n', '  * in order to set a new attribute. Be aware that ownership of the account to\n', '  * which the attribute is assigned may still be transferable - restricting\n', '  * assignment to externally-owned accounts may partially alleviate this issue.\n', '  */\n', '  function issueAttribute(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value\n', '  ) external payable;\n', '\n', '  /**\n', '  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\n', '  * `account` if `message.caller.address()` is the issuing validator.\n', '  * @param account address The account to issue the attribute on.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to issue.\n', '  * @dev Validators may still revoke issued attributes even after they have been\n', '  * removed or had their approval to issue the attribute type removed - this\n', '  * enables them to address any objectionable issuances before being reinstated.\n', '  */\n', '  function revokeAttribute(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external;\n', '\n', '  /**\n', '   * @notice Determine if a validator at account `validator` is able to issue\n', '   * attributes of the type with ID `attributeTypeID`.\n', '   * @param validator address The account of the validator.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check.\n', '   * @return True if the validator can issue attributes of the given type, false\n', '   * otherwise.\n', '   */\n', '  function canIssueAttributeType(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external view returns (bool);\n', '\n', '  /**\n', '   * @notice Get a description of the attribute type with ID `attributeTypeID`.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return A description of the attribute type.\n', '   */\n', '  function getAttributeTypeDescription(\n', '    uint256 attributeTypeID\n', '  ) external view returns (string description);\n', '  \n', '  /**\n', '   * @notice Get a description of the validator at account `validator`.\n', '   * @param validator address The account of the validator in question.\n', '   * @return A description of the validator.\n', '   */\n', '  function getValidatorDescription(\n', '    address validator\n', '  ) external view returns (string description);\n', '\n', '  /**\n', '   * @notice Find the validator that issued the attribute of the type with ID\n', '   * `attributeTypeID` on the account at `account` and determine if the\n', '   * validator is still valid.\n', '   * @param account address The account that contains the attribute be checked.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @return The validator and the current status of the validator as it\n', '   * pertains to the attribute type in question.\n', '   * @dev if no attribute of the given attribute type exists on the account, the\n', '   * function will return (address(0), false).\n', '   */\n', '  function getAttributeValidator(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external view returns (address validator, bool isStillValid);\n', '\n', '  /**\n', '   * @notice Count the number of attribute types defined by the jurisdiction.\n', '   * @return The number of available attribute types.\n', '   */\n', '  function countAttributeTypes() external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the ID of the attribute type at index `index`.\n', '   * @param index uint256 The index of the attribute type in question.\n', '   * @return The ID of the attribute type.\n', '   */\n', '  function getAttributeTypeID(uint256 index) external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the IDs of all available attribute types on the jurisdiction.\n', '   * @return A dynamic array containing all available attribute type IDs.\n', '   */\n', '  function getAttributeTypeIDs() external view returns (uint256[]);\n', '\n', '  /**\n', '   * @notice Count the number of validators defined by the jurisdiction.\n', '   * @return The number of defined validators.\n', '   */\n', '  function countValidators() external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the account of the validator at index `index`.\n', '   * @param index uint256 The index of the validator in question.\n', '   * @return The account of the validator.\n', '   */\n', '  function getValidator(uint256 index) external view returns (address);\n', '\n', '  /**\n', '   * @notice Get the accounts of all available validators on the jurisdiction.\n', '   * @return A dynamic array containing all available validator accounts.\n', '   */\n', '  function getValidators() external view returns (address[]);\n', '}\n', '\n', '/**\n', ' * @title Extended TPL Jurisdiction Interface.\n', ' * @dev this extends BasicJurisdictionInterface for additional functionality.\n', ' */\n', 'interface ExtendedJurisdictionInterface {\n', '  // declare events (NOTE: consider which fields should be indexed)\n', '  event ValidatorSigningKeyModified(\n', '    address indexed validator,\n', '    address newSigningKey\n', '  );\n', '\n', '  event StakeAllocated(\n', '    address indexed staker,\n', '    uint256 indexed attribute,\n', '    uint256 amount\n', '  );\n', '\n', '  event StakeRefunded(\n', '    address indexed staker,\n', '    uint256 indexed attribute,\n', '    uint256 amount\n', '  );\n', '\n', '  event FeePaid(\n', '    address indexed recipient,\n', '    address indexed payee,\n', '    uint256 indexed attribute,\n', '    uint256 amount\n', '  );\n', '  \n', '  event TransactionRebatePaid(\n', '    address indexed submitter,\n', '    address indexed payee,\n', '    uint256 indexed attribute,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '  * @notice Add a restricted attribute type with ID `ID` and description\n', '  * `description` to the jurisdiction. Restricted attribute types can only be\n', '  * removed by the issuing validator or the jurisdiction.\n', '  * @param ID uint256 The ID of the restricted attribute type to add.\n', '  * @param description string A description of the restricted attribute type.\n', '  * @dev Once an attribute type is added with a given ID, the description or the\n', '  * restricted status of the attribute type cannot be changed, even if the\n', '  * attribute type is removed and added back later.\n', '  */\n', '  function addRestrictedAttributeType(uint256 ID, string description) external;\n', '\n', '  /**\n', '  * @notice Enable or disable a restriction for a given attribute type ID `ID`\n', '  * that prevents attributes of the given type from being set by operators based\n', '  * on the provided value for `onlyPersonal`.\n', '  * @param ID uint256 The attribute type ID in question.\n', '  * @param onlyPersonal bool Whether the address may only be set personally.\n', '  */\n', '  function setAttributeTypeOnlyPersonal(uint256 ID, bool onlyPersonal) external;\n', '\n', '  /**\n', '  * @notice Set a secondary source for a given attribute type ID `ID`, with an\n', '  * address `registry` of the secondary source in question and a given\n', '  * `sourceAttributeTypeID` for attribute type ID to check on the secondary\n', '  * source. The secondary source will only be checked for the given attribute in\n', '  * cases where no attribute of the given attribute type ID is assigned locally.\n', '  * @param ID uint256 The attribute type ID to set the secondary source for.\n', '  * @param attributeRegistry address The secondary attribute registry account.\n', '  * @param sourceAttributeTypeID uint256 The attribute type ID on the secondary\n', '  * source to check.\n', '  * @dev To remove a secondary source on an attribute type, the registry address\n', '  * should be set to the null address.\n', '  */\n', '  function setAttributeTypeSecondarySource(\n', '    uint256 ID,\n', '    address attributeRegistry,\n', '    uint256 sourceAttributeTypeID\n', '  ) external;\n', '\n', '  /**\n', '  * @notice Set a minimum required stake for a given attribute type ID `ID` and\n', '  * an amount of `stake`, to be locked in the jurisdiction upon assignment of\n', '  * attributes of the given type. The stake will be applied toward a transaction\n', '  * rebate in the event the attribute is revoked, with the remainder returned to\n', '  * the staker.\n', '  * @param ID uint256 The attribute type ID to set a minimum required stake for.\n', '  * @param minimumRequiredStake uint256 The minimum required funds to lock up.\n', '  * @dev To remove a stake requirement from an attribute type, the stake amount\n', '  * should be set to 0.\n', '  */\n', '  function setAttributeTypeMinimumRequiredStake(\n', '    uint256 ID,\n', '    uint256 minimumRequiredStake\n', '  ) external;\n', '\n', '  /**\n', '  * @notice Set a required fee for a given attribute type ID `ID` and an amount\n', '  * of `fee`, to be paid to the owner of the jurisdiction upon assignment of\n', '  * attributes of the given type.\n', '  * @param ID uint256 The attribute type ID to set the required fee for.\n', '  * @param fee uint256 The required fee amount to be paid upon assignment.\n', '  * @dev To remove a fee requirement from an attribute type, the fee amount\n', '  * should be set to 0.\n', '  */\n', '  function setAttributeTypeJurisdictionFee(uint256 ID, uint256 fee) external;\n', '\n', '  /**\n', '  * @notice Set the public address associated with a validator signing key, used\n', '  * to sign off-chain attribute approvals, as `newSigningKey`.\n', '  * @param newSigningKey address The address associated with signing key to set.\n', '  */\n', '  function setValidatorSigningKey(address newSigningKey) external;\n', '\n', '  /**\n', '  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\n', '  * value of `value`, and an associated validator fee of `validatorFee` to\n', '  * account of `msg.sender` by passing in a signed attribute approval with\n', '  * signature `signature`.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to add.\n', '  * @param value uint256 The value for the attribute to add.\n', '  * @param validatorFee uint256 The fee to be paid to the issuing validator.\n', '  * @param signature bytes The signature from the validator attribute approval.\n', '  */\n', '  function addAttribute(\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external payable;\n', '\n', '  /**\n', '  * @notice Remove an attribute of the type with ID `attributeTypeID` from\n', '  * account of `msg.sender`.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to remove.\n', '  */\n', '  function removeAttribute(uint256 attributeTypeID) external;\n', '\n', '  /**\n', '  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\n', '  * value of `value`, and an associated validator fee of `validatorFee` to\n', '  * account `account` by passing in a signed attribute approval with signature\n', '  * `signature`.\n', '  * @param account address The account to add the attribute to.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to add.\n', '  * @param value uint256 The value for the attribute to add.\n', '  * @param validatorFee uint256 The fee to be paid to the issuing validator.\n', '  * @param signature bytes The signature from the validator attribute approval.\n', '  * @dev Restricted attribute types can only be removed by issuing validators or\n', '  * the jurisdiction itself.\n', '  */\n', '  function addAttributeFor(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external payable;\n', '\n', '  /**\n', '  * @notice Remove an attribute of the type with ID `attributeTypeID` from\n', '  * account of `account`.\n', '  * @param account address The account to remove the attribute from.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to remove.\n', '  * @dev Restricted attribute types can only be removed by issuing validators or\n', '  * the jurisdiction itself.\n', '  */\n', '  function removeAttributeFor(address account, uint256 attributeTypeID) external;\n', '\n', '  /**\n', '   * @notice Invalidate a signed attribute approval before it has been set by\n', '   * supplying the hash of the approval `hash` and the signature `signature`.\n', '   * @param hash bytes32 The hash of the attribute approval.\n', "   * @param signature bytes The hash's signature, resolving to the signing key.\n", '   * @dev Attribute approvals can only be removed by issuing validators or the\n', '   * jurisdiction itself.\n', '   */\n', '  function invalidateAttributeApproval(\n', '    bytes32 hash,\n', '    bytes signature\n', '  ) external;\n', '\n', '  /**\n', '   * @notice Get the hash of a given attribute approval.\n', '   * @param account address The account specified by the attribute approval.\n', '   * @param operator address An optional account permitted to submit approval.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @return The hash of the attribute approval.\n', '   */\n', '  function getAttributeApprovalHash(\n', '    address account,\n', '    address operator,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee\n', '  ) external view returns (bytes32 hash);\n', '\n', '  /**\n', '   * @notice Check if a given signed attribute approval is currently valid when\n', '   * submitted directly by `msg.sender`.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @param signature bytes The attribute approval signature, based on a hash of\n', '   * the other parameters and the submitting account.\n', '   * @return True if the approval is currently valid, false otherwise.\n', '   */\n', '  function canAddAttribute(\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external view returns (bool);\n', '\n', '  /**\n', '   * @notice Check if a given signed attribute approval is currently valid for a\n', '   * given account when submitted by the operator at `msg.sender`.\n', '   * @param account address The account specified by the attribute approval.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @param signature bytes The attribute approval signature, based on a hash of\n', '   * the other parameters and the submitting account.\n', '   * @return True if the approval is currently valid, false otherwise.\n', '   */\n', '  function canAddAttributeFor(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external view returns (bool);\n', '\n', '  /**\n', '   * @notice Get comprehensive information on an attribute type with ID\n', '   * `attributeTypeID`.\n', '   * @param attributeTypeID uint256 The attribute type ID in question.\n', '   * @return Information on the attribute type in question.\n', '   */\n', '  function getAttributeTypeInformation(\n', '    uint256 attributeTypeID\n', '  ) external view returns (\n', '    string description,\n', '    bool isRestricted,\n', '    bool isOnlyPersonal,\n', '    address secondarySource,\n', '    uint256 secondaryId,\n', '    uint256 minimumRequiredStake,\n', '    uint256 jurisdictionFee\n', '  );\n', '  \n', '  /**\n', "   * @notice Get a validator's signing key.\n", '   * @param validator address The account of the validator.\n', '   * @return The account referencing the public component of the signing key.\n', '   */\n', '  function getValidatorSigningKey(\n', '    address validator\n', '  ) external view returns (\n', '    address signingKey\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Interface for checking attribute assignment on YES token and for token\n', ' * recovery.\n', ' */\n', 'interface IERC20 {\n', '  function balanceOf(address) external view returns (uint256);\n', '  function transfer(address, uint256) external returns (bool);\n', '}\n', '\n', '/**\n', ' * @title An extended TPL jurisdiction for assigning attributes to addresses.\n', ' */\n', 'contract ExtendedJurisdiction is Ownable, Pausable, AttributeRegistryInterface, BasicJurisdictionInterface, ExtendedJurisdictionInterface {\n', '  using ECDSA for bytes32;\n', '  using SafeMath for uint256;\n', '\n', '  // validators are entities who can add or authorize addition of new attributes\n', '  struct Validator {\n', '    bool exists;\n', '    uint256 index; // NOTE: consider use of uint88 to pack struct\n', '    address signingKey;\n', '    string description;\n', '  }\n', '\n', '  // attributes are properties that validators associate with specific addresses\n', '  struct IssuedAttribute {\n', '    bool exists;\n', '    bool setPersonally;\n', '    address operator;\n', '    address validator;\n', '    uint256 value;\n', '    uint256 stake;\n', '  }\n', '\n', '  // attributes also have associated type - metadata common to each attribute\n', '  struct AttributeType {\n', '    bool exists;\n', '    bool restricted;\n', '    bool onlyPersonal;\n', '    uint256 index; // NOTE: consider use of uint72 to pack struct\n', '    address secondarySource;\n', '    uint256 secondaryAttributeTypeID;\n', '    uint256 minimumStake;\n', '    uint256 jurisdictionFee;\n', '    string description;\n', '    mapping(address => bool) approvedValidators;\n', '  }\n', '\n', '  // top-level information about attribute types is held in a mapping of structs\n', '  mapping(uint256 => AttributeType) private _attributeTypes;\n', '\n', '  // the jurisdiction retains a mapping of addresses with assigned attributes\n', '  mapping(address => mapping(uint256 => IssuedAttribute)) private _issuedAttributes;\n', '\n', '  // there is also a mapping to identify all approved validators and their keys\n', '  mapping(address => Validator) private _validators;\n', '\n', '  // each registered signing key maps back to a specific validator\n', '  mapping(address => address) private _signingKeys;\n', '\n', '  // once attribute types are assigned to an ID, they cannot be modified\n', '  mapping(uint256 => bytes32) private _attributeTypeHashes;\n', '\n', '  // submitted attribute approvals are retained to prevent reuse after removal \n', '  mapping(bytes32 => bool) private _invalidAttributeApprovalHashes;\n', '\n', '  // attribute approvals by validator are held in a mapping\n', '  mapping(address => uint256[]) private _validatorApprovals;\n', '\n', '   // attribute approval index by validator is tracked as well\n', '  mapping(address => mapping(uint256 => uint256)) private _validatorApprovalsIndex;\n', '\n', '  // IDs for all supplied attributes are held in an array (enables enumeration)\n', '  uint256[] private _attributeIDs;\n', '\n', '  // addresses for all designated validators are also held in an array\n', '  address[] private _validatorAccounts;\n', '\n', '  // track any recoverable funds locked in the contract \n', '  uint256 private _recoverableFunds;\n', '\n', '  /**\n', '  * @notice Set the original owner of the jurisdiction using a supplied\n', '  * constructor argument.\n', '  */\n', '  constructor(address owner) public Ownable(owner) {}\n', '\n', '  /**\n', '  * @notice Add an attribute type with ID `ID` and description `description` to\n', '  * the jurisdiction.\n', '  * @param ID uint256 The ID of the attribute type to add.\n', '  * @param description string A description of the attribute type.\n', '  * @dev Once an attribute type is added with a given ID, the description of the\n', '  * attribute type cannot be changed, even if the attribute type is removed and\n', '  * added back later.\n', '  */\n', '  function addAttributeType(\n', '    uint256 ID,\n', '    string description\n', '  ) external onlyOwner whenNotPaused {\n', '    // prevent existing attributes with the same id from being overwritten\n', '    require(\n', '      !isAttributeType(ID),\n', '      "an attribute type with the provided ID already exists"\n', '    );\n', '\n', "    // calculate a hash of the attribute type based on the type's properties\n", '    bytes32 hash = keccak256(\n', '      abi.encodePacked(\n', '        ID, false, description\n', '      )\n', '    );\n', '\n', '    // store hash if attribute type is the first one registered with provided ID\n', '    if (_attributeTypeHashes[ID] == bytes32(0)) {\n', '      _attributeTypeHashes[ID] = hash;\n', '    }\n', '\n', '    // prevent addition if different attribute type with the same ID has existed\n', '    require(\n', '      hash == _attributeTypeHashes[ID],\n', '      "attribute type properties must match initial properties assigned to ID"\n', '    );\n', '\n', '    // set the attribute mapping, assigning the index as the end of attributeID\n', '    _attributeTypes[ID] = AttributeType({\n', '      exists: true,\n', "      restricted: false, // when true: users can't remove attribute\n", "      onlyPersonal: false, // when true: operators can't add attribute\n", '      index: _attributeIDs.length,\n', '      secondarySource: address(0), // the address of a remote registry\n', '      secondaryAttributeTypeID: uint256(0), // the attribute type id to query\n', '      minimumStake: uint256(0), // when > 0: users must stake ether to set\n', '      jurisdictionFee: uint256(0),\n', '      description: description\n', '      // NOTE: no approvedValidators variable declaration - must be added later\n', '    });\n', '    \n', '    // add the attribute type id to the end of the attributeID array\n', '    _attributeIDs.push(ID);\n', '\n', '    // log the addition of the attribute type\n', '    emit AttributeTypeAdded(ID, description);\n', '  }\n', '\n', '  /**\n', '  * @notice Add a restricted attribute type with ID `ID` and description\n', '  * `description` to the jurisdiction. Restricted attribute types can only be\n', '  * removed by the issuing validator or the jurisdiction.\n', '  * @param ID uint256 The ID of the restricted attribute type to add.\n', '  * @param description string A description of the restricted attribute type.\n', '  * @dev Once an attribute type is added with a given ID, the description or the\n', '  * restricted status of the attribute type cannot be changed, even if the\n', '  * attribute type is removed and added back later.\n', '  */\n', '  function addRestrictedAttributeType(\n', '    uint256 ID,\n', '    string description\n', '  ) external onlyOwner whenNotPaused {\n', '    // prevent existing attributes with the same id from being overwritten\n', '    require(\n', '      !isAttributeType(ID),\n', '      "an attribute type with the provided ID already exists"\n', '    );\n', '\n', "    // calculate a hash of the attribute type based on the type's properties\n", '    bytes32 hash = keccak256(\n', '      abi.encodePacked(\n', '        ID, true, description\n', '      )\n', '    );\n', '\n', '    // store hash if attribute type is the first one registered with provided ID\n', '    if (_attributeTypeHashes[ID] == bytes32(0)) {\n', '      _attributeTypeHashes[ID] = hash;\n', '    }\n', '\n', '    // prevent addition if different attribute type with the same ID has existed\n', '    require(\n', '      hash == _attributeTypeHashes[ID],\n', '      "attribute type properties must match initial properties assigned to ID"\n', '    );\n', '\n', '    // set the attribute mapping, assigning the index as the end of attributeID\n', '    _attributeTypes[ID] = AttributeType({\n', '      exists: true,\n', "      restricted: true, // when true: users can't remove attribute\n", "      onlyPersonal: false, // when true: operators can't add attribute\n", '      index: _attributeIDs.length,\n', '      secondarySource: address(0), // the address of a remote registry\n', '      secondaryAttributeTypeID: uint256(0), // the attribute type id to query\n', '      minimumStake: uint256(0), // when > 0: users must stake ether to set\n', '      jurisdictionFee: uint256(0),\n', '      description: description\n', '      // NOTE: no approvedValidators variable declaration - must be added later\n', '    });\n', '    \n', '    // add the attribute type id to the end of the attributeID array\n', '    _attributeIDs.push(ID);\n', '\n', '    // log the addition of the attribute type\n', '    emit AttributeTypeAdded(ID, description);\n', '  }\n', '\n', '  /**\n', '  * @notice Enable or disable a restriction for a given attribute type ID `ID`\n', '  * that prevents attributes of the given type from being set by operators based\n', '  * on the provided value for `onlyPersonal`.\n', '  * @param ID uint256 The attribute type ID in question.\n', '  * @param onlyPersonal bool Whether the address may only be set personally.\n', '  */\n', '  function setAttributeTypeOnlyPersonal(uint256 ID, bool onlyPersonal) external {\n', '    // if the attribute type ID does not exist, there is nothing to remove\n', '    require(\n', '      isAttributeType(ID),\n', '      "unable to set to only personal, no attribute type with the provided ID"\n', '    );\n', '\n', '    // modify the attribute type in the mapping\n', '    _attributeTypes[ID].onlyPersonal = onlyPersonal;\n', '  }\n', '\n', '  /**\n', '  * @notice Set a secondary source for a given attribute type ID `ID`, with an\n', '  * address `registry` of the secondary source in question and a given\n', '  * `sourceAttributeTypeID` for attribute type ID to check on the secondary\n', '  * source. The secondary source will only be checked for the given attribute in\n', '  * cases where no attribute of the given attribute type ID is assigned locally.\n', '  * @param ID uint256 The attribute type ID to set the secondary source for.\n', '  * @param attributeRegistry address The secondary attribute registry account.\n', '  * @param sourceAttributeTypeID uint256 The attribute type ID on the secondary\n', '  * source to check.\n', '  * @dev To remove a secondary source on an attribute type, the registry address\n', '  * should be set to the null address.\n', '  */\n', '  function setAttributeTypeSecondarySource(\n', '    uint256 ID,\n', '    address attributeRegistry,\n', '    uint256 sourceAttributeTypeID\n', '  ) external {\n', '    // if the attribute type ID does not exist, there is nothing to remove\n', '    require(\n', '      isAttributeType(ID),\n', '      "unable to set secondary source, no attribute type with the provided ID"\n', '    );\n', '\n', '    // modify the attribute type in the mapping\n', '    _attributeTypes[ID].secondarySource = attributeRegistry;\n', '    _attributeTypes[ID].secondaryAttributeTypeID = sourceAttributeTypeID;\n', '  }\n', '\n', '  /**\n', '  * @notice Set a minimum required stake for a given attribute type ID `ID` and\n', '  * an amount of `stake`, to be locked in the jurisdiction upon assignment of\n', '  * attributes of the given type. The stake will be applied toward a transaction\n', '  * rebate in the event the attribute is revoked, with the remainder returned to\n', '  * the staker.\n', '  * @param ID uint256 The attribute type ID to set a minimum required stake for.\n', '  * @param minimumRequiredStake uint256 The minimum required funds to lock up.\n', '  * @dev To remove a stake requirement from an attribute type, the stake amount\n', '  * should be set to 0.\n', '  */\n', '  function setAttributeTypeMinimumRequiredStake(\n', '    uint256 ID,\n', '    uint256 minimumRequiredStake\n', '  ) external {\n', '    // if the attribute type ID does not exist, there is nothing to remove\n', '    require(\n', '      isAttributeType(ID),\n', '      "unable to set minimum stake, no attribute type with the provided ID"\n', '    );\n', '\n', '    // modify the attribute type in the mapping\n', '    _attributeTypes[ID].minimumStake = minimumRequiredStake;\n', '  }\n', '\n', '  /**\n', '  * @notice Set a required fee for a given attribute type ID `ID` and an amount\n', '  * of `fee`, to be paid to the owner of the jurisdiction upon assignment of\n', '  * attributes of the given type.\n', '  * @param ID uint256 The attribute type ID to set the required fee for.\n', '  * @param fee uint256 The required fee amount to be paid upon assignment.\n', '  * @dev To remove a fee requirement from an attribute type, the fee amount\n', '  * should be set to 0.\n', '  */\n', '  function setAttributeTypeJurisdictionFee(uint256 ID, uint256 fee) external {\n', '    // if the attribute type ID does not exist, there is nothing to remove\n', '    require(\n', '      isAttributeType(ID),\n', '      "unable to set fee, no attribute type with the provided ID"\n', '    );\n', '\n', '    // modify the attribute type in the mapping\n', '    _attributeTypes[ID].jurisdictionFee = fee;\n', '  }\n', '\n', '  /**\n', '  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\n', '  * @param ID uint256 The ID of the attribute type to remove.\n', '  * @dev All issued attributes of the given type will become invalid upon\n', '  * removal, but will become valid again if the attribute is reinstated.\n', '  */\n', '  function removeAttributeType(uint256 ID) external onlyOwner whenNotPaused {\n', '    // if the attribute type ID does not exist, there is nothing to remove\n', '    require(\n', '      isAttributeType(ID),\n', '      "unable to remove, no attribute type with the provided ID"\n', '    );\n', '\n', '    // get the attribute ID at the last index of the array\n', '    uint256 lastAttributeID = _attributeIDs[_attributeIDs.length.sub(1)];\n', '\n', '    // set the attributeID at attribute-to-delete.index to the last attribute ID\n', '    _attributeIDs[_attributeTypes[ID].index] = lastAttributeID;\n', '\n', '    // update the index of the attribute type that was moved\n', '    _attributeTypes[lastAttributeID].index = _attributeTypes[ID].index;\n', '    \n', '    // remove the (now duplicate) attribute ID at the end by trimming the array\n', '    _attributeIDs.length--;\n', '\n', "    // delete the attribute type's record from the mapping\n", '    delete _attributeTypes[ID];\n', '\n', '    // log the removal of the attribute type\n', '    emit AttributeTypeRemoved(ID);\n', '  }\n', '\n', '  /**\n', '  * @notice Add account `validator` as a validator with a description\n', '  * `description` who can be approved to set attributes of specific types.\n', '  * @param validator address The account to assign as the validator.\n', '  * @param description string A description of the validator.\n', '  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\n', '  */\n', '  function addValidator(\n', '    address validator,\n', '    string description\n', '  ) external onlyOwner whenNotPaused {\n', '    // check that an empty address was not provided by mistake\n', '    require(validator != address(0), "must supply a valid address");\n', '\n', '    // prevent existing validators from being overwritten\n', '    require(\n', '      !isValidator(validator),\n', '      "a validator with the provided address already exists"\n', '    );\n', '\n', '    // prevent duplicate signing keys from being created\n', '    require(\n', '      _signingKeys[validator] == address(0),\n', '      "a signing key matching the provided address already exists"\n', '    );\n', '    \n', '    // create a record for the validator\n', '    _validators[validator] = Validator({\n', '      exists: true,\n', '      index: _validatorAccounts.length,\n', '      signingKey: validator, // NOTE: this will be initially set to same address\n', '      description: description\n', '    });\n', '\n', "    // set the initial signing key (the validator's address) resolving to itself\n", '    _signingKeys[validator] = validator;\n', '\n', '    // add the validator to the end of the _validatorAccounts array\n', '    _validatorAccounts.push(validator);\n', '    \n', '    // log the addition of the new validator\n', '    emit ValidatorAdded(validator, description);\n', '  }\n', '\n', '  /**\n', '  * @notice Remove the validator at address `validator` from the jurisdiction.\n', '  * @param validator address The account of the validator to remove.\n', '  * @dev Any attributes issued by the validator will become invalid upon their\n', '  * removal. If the validator is reinstated, those attributes will become valid\n', '  * again. Any approvals to issue attributes of a given type will need to be\n', '  * set from scratch in the event a validator is reinstated.\n', '  */\n', '  function removeValidator(address validator) external onlyOwner whenNotPaused {\n', '    // check that a validator exists at the provided address\n', '    require(\n', '      isValidator(validator),\n', '      "unable to remove, no validator located at the provided address"\n', '    );\n', '\n', '    // first, start removing validator approvals until gas is exhausted\n', '    while (_validatorApprovals[validator].length > 0 && gasleft() > 25000) {\n', '      // locate the index of last attribute ID in the validator approval group\n', '      uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\n', '\n', '      // locate the validator approval to be removed\n', '      uint256 targetApproval = _validatorApprovals[validator][lastIndex];\n', '\n', '      // remove the record of the approval from the associated attribute type\n', '      delete _attributeTypes[targetApproval].approvedValidators[validator];\n', '\n', '      // remove the record of the index of the approval\n', '      delete _validatorApprovalsIndex[validator][targetApproval];\n', '\n', '      // drop the last attribute ID from the validator approval group\n', '      _validatorApprovals[validator].length--;\n', '    }\n', '\n', '    // require that all approvals were successfully removed\n', '    require(\n', '      _validatorApprovals[validator].length == 0,\n', '      "Cannot remove validator - first remove any existing validator approvals"\n', '    );\n', '\n', '    // get the validator address at the last index of the array\n', '    address lastAccount = _validatorAccounts[_validatorAccounts.length.sub(1)];\n', '\n', '    // set the address at validator-to-delete.index to last validator address\n', '    _validatorAccounts[_validators[validator].index] = lastAccount;\n', '\n', '    // update the index of the attribute type that was moved\n', '    _validators[lastAccount].index = _validators[validator].index;\n', '    \n', '    // remove (duplicate) validator address at the end by trimming the array\n', '    _validatorAccounts.length--;\n', '\n', "    // remove the validator's signing key from its mapping\n", '    delete _signingKeys[_validators[validator].signingKey];\n', '\n', '    // remove the validator record\n', '    delete _validators[validator];\n', '\n', '    // log the removal of the validator\n', '    emit ValidatorRemoved(validator);\n', '  }\n', '\n', '  /**\n', '  * @notice Approve the validator at address `validator` to issue attributes of\n', '  * the type with ID `attributeTypeID`.\n', '  * @param validator address The account of the validator to approve.\n', '  * @param attributeTypeID uint256 The ID of the approved attribute type.\n', '  */\n', '  function addValidatorApproval(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external onlyOwner whenNotPaused {\n', '    // check that the attribute is predefined and that the validator exists\n', '    require(\n', '      isValidator(validator) && isAttributeType(attributeTypeID),\n', '      "must specify both a valid attribute and an available validator"\n', '    );\n', '\n', '    // check that the validator is not already approved\n', '    require(\n', '      !_attributeTypes[attributeTypeID].approvedValidators[validator],\n', '      "validator is already approved on the provided attribute"\n', '    );\n', '\n', '    // set the validator approval status on the attribute\n', '    _attributeTypes[attributeTypeID].approvedValidators[validator] = true;\n', '\n', '    // add the record of the index of the validator approval to be added\n', '    uint256 index = _validatorApprovals[validator].length;\n', '    _validatorApprovalsIndex[validator][attributeTypeID] = index;\n', '\n', '    // include the attribute type in the validator approval mapping\n', '    _validatorApprovals[validator].push(attributeTypeID);\n', '\n', "    // log the addition of the validator's attribute type approval\n", '    emit ValidatorApprovalAdded(validator, attributeTypeID);\n', '  }\n', '\n', '  /**\n', '  * @notice Deny the validator at address `validator` the ability to continue to\n', '  * issue attributes of the type with ID `attributeTypeID`.\n', '  * @param validator address The account of the validator with removed approval.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\n', '  * @dev Any attributes of the specified type issued by the validator in\n', '  * question will become invalid once the approval is removed. If the approval\n', '  * is reinstated, those attributes will become valid again. The approval will\n', '  * also be removed if the approved validator is removed.\n', '  */\n', '  function removeValidatorApproval(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external onlyOwner whenNotPaused {\n', '    // check that the attribute is predefined and that the validator exists\n', '    require(\n', '      canValidate(validator, attributeTypeID),\n', '      "unable to remove validator approval, attribute is already unapproved"\n', '    );\n', '\n', '    // remove the validator approval status from the attribute\n', '    delete _attributeTypes[attributeTypeID].approvedValidators[validator];\n', '\n', '    // locate the index of the last validator approval\n', '    uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\n', '\n', '    // locate the last attribute ID in the validator approval group\n', '    uint256 lastAttributeID = _validatorApprovals[validator][lastIndex];\n', '\n', '    // locate the index of the validator approval to be removed\n', '    uint256 index = _validatorApprovalsIndex[validator][attributeTypeID];\n', '\n', '    // replace the validator approval with the last approval in the array\n', '    _validatorApprovals[validator][index] = lastAttributeID;\n', '\n', '    // drop the last attribute ID from the validator approval group\n', '    _validatorApprovals[validator].length--;\n', '\n', '    // update the record of the index of the swapped-in approval\n', '    _validatorApprovalsIndex[validator][lastAttributeID] = index;\n', '\n', '    // remove the record of the index of the removed approval\n', '    delete _validatorApprovalsIndex[validator][attributeTypeID];\n', '    \n', "    // log the removal of the validator's attribute type approval\n", '    emit ValidatorApprovalRemoved(validator, attributeTypeID);\n', '  }\n', '\n', '  /**\n', '  * @notice Set the public address associated with a validator signing key, used\n', '  * to sign off-chain attribute approvals, as `newSigningKey`.\n', '  * @param newSigningKey address The address associated with signing key to set.\n', '  * @dev Consider having the validator submit a signed proof demonstrating that\n', '  * the provided signing key is indeed a signing key in their control - this\n', '  * helps mitigate the fringe attack vector where a validator could set the\n', '  * address of another validator candidate (especially in the case of a deployed\n', '  * smart contract) as their "signing key" in order to block them from being\n', '  * added to the jurisdiction (due to the required property of signing keys\n', '  * being unique, coupled with the fact that new validators are set up with\n', '  * their address as the default initial signing key).\n', '  */\n', '  function setValidatorSigningKey(address newSigningKey) external {\n', '    require(\n', '      isValidator(msg.sender),\n', '      "only validators may modify validator signing keys");\n', ' \n', '    // prevent duplicate signing keys from being created\n', '    require(\n', '      _signingKeys[newSigningKey] == address(0),\n', '      "a signing key matching the provided address already exists"\n', '    );\n', '\n', '    // remove validator address as the resolved value for the old key\n', '    delete _signingKeys[_validators[msg.sender].signingKey];\n', '\n', '    // set the signing key to the new value\n', '    _validators[msg.sender].signingKey = newSigningKey;\n', '\n', '    // add validator address as the resolved value for the new key\n', '    _signingKeys[newSigningKey] = msg.sender;\n', '\n', '    // log the modification of the signing key\n', '    emit ValidatorSigningKeyModified(msg.sender, newSigningKey);\n', '  }\n', '\n', '  /**\n', '  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\n', '  * of `value` to `account` if `message.caller.address()` is approved validator.\n', '  * @param account address The account to issue the attribute on.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to issue.\n', '  * @param value uint256 An optional value for the issued attribute.\n', '  * @dev Existing attributes of the given type on the address must be removed\n', '  * in order to set a new attribute. Be aware that ownership of the account to\n', '  * which the attribute is assigned may still be transferable - restricting\n', '  * assignment to externally-owned accounts may partially alleviate this issue.\n', '  */\n', '  function issueAttribute(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value\n', '  ) external payable whenNotPaused {\n', '    require(\n', '      canValidate(msg.sender, attributeTypeID),\n', '      "only approved validators may assign attributes of this type"\n', '    );\n', '\n', '    require(\n', '      !_issuedAttributes[account][attributeTypeID].exists,\n', '      "duplicate attributes are not supported, remove existing attribute first"\n', '    );\n', '\n', '    // retrieve required minimum stake and jurisdiction fees on attribute type\n', '    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\n', '    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\n', '    uint256 stake = msg.value.sub(jurisdictionFee);\n', '\n', '    require(\n', '      stake >= minimumStake,\n', '      "attribute requires a greater value than is currently provided"\n', '    );\n', '\n', '    // store attribute value and amount of ether staked in correct scope\n', '    _issuedAttributes[account][attributeTypeID] = IssuedAttribute({\n', '      exists: true,\n', '      setPersonally: false,\n', '      operator: address(0),\n', '      validator: msg.sender,\n', '      value: value,\n', '      stake: stake\n', '    });\n', '\n', '    // log the addition of the attribute\n', '    emit AttributeAdded(msg.sender, account, attributeTypeID, value);\n', '\n', '    // log allocation of staked funds to the attribute if applicable\n', '    if (stake > 0) {\n', '      emit StakeAllocated(msg.sender, attributeTypeID, stake);\n', '    }\n', '\n', '    // pay jurisdiction fee to the owner of the jurisdiction if applicable\n', '    if (jurisdictionFee > 0) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a improperly\n', '      // configured fallback function could block addition of an attribute\n', '      if (owner().send(jurisdictionFee)) {\n', '        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(jurisdictionFee);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\n', '  * `account` if `message.caller.address()` is the issuing validator.\n', '  * @param account address The account to issue the attribute on.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to issue.\n', '  * @dev Validators may still revoke issued attributes even after they have been\n', '  * removed or had their approval to issue the attribute type removed - this\n', '  * enables them to address any objectionable issuances before being reinstated.\n', '  */\n', '  function revokeAttribute(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external whenNotPaused {\n', '    // ensure that an attribute with the given account and attribute exists\n', '    require(\n', '      _issuedAttributes[account][attributeTypeID].exists,\n', '      "only existing attributes may be removed"\n', '    );\n', '\n', '    // determine the assigned validator on the user attribute\n', '    address validator = _issuedAttributes[account][attributeTypeID].validator;\n', '    \n', '    // caller must be either the jurisdiction owner or the assigning validator\n', '    require(\n', '      msg.sender == validator || msg.sender == owner(),\n', '      "only jurisdiction or issuing validators may revoke arbitrary attributes"\n', '    );\n', '\n', '    // determine if attribute has any stake in order to refund transaction fee\n', '    uint256 stake = _issuedAttributes[account][attributeTypeID].stake;\n', '\n', '    // determine the correct address to refund the staked amount to\n', '    address refundAddress;\n', '    if (_issuedAttributes[account][attributeTypeID].setPersonally) {\n', '      refundAddress = account;\n', '    } else {\n', '      address operator = _issuedAttributes[account][attributeTypeID].operator;\n', '      if (operator == address(0)) {\n', '        refundAddress = validator;\n', '      } else {\n', '        refundAddress = operator;\n', '      }\n', '    }\n', '\n', '    // remove the attribute from the designated user account\n', '    delete _issuedAttributes[account][attributeTypeID];\n', '\n', '    // log the removal of the attribute\n', '    emit AttributeRemoved(validator, account, attributeTypeID);\n', '\n', '    // pay out any refunds and return the excess stake to the user\n', '    if (stake > 0 && address(this).balance >= stake) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a malicious\n', "      // fallback function could forcibly block an attribute's removal. Another\n", '      // option is to allow a user to pull the staked amount after the removal.\n', '      // NOTE: refine transaction rebate gas calculation! Setting this value too\n', '      // high gives validators the incentive to revoke valid attributes. Simply\n', "      // checking against gasLeft() & adding the final gas usage won't give the\n", '      // correct transaction cost, as freeing space refunds gas upon completion.\n', '      uint256 transactionGas = 37700; // <--- WARNING: THIS IS APPROXIMATE\n', '      uint256 transactionCost = transactionGas.mul(tx.gasprice);\n', '\n', '      // if stake exceeds allocated transaction cost, refund user the difference\n', '      if (stake > transactionCost) {\n', '        // refund the excess stake to the address that contributed the funds\n', '        if (refundAddress.send(stake.sub(transactionCost))) {\n', '          emit StakeRefunded(\n', '            refundAddress,\n', '            attributeTypeID,\n', '            stake.sub(transactionCost)\n', '          );\n', '        } else {\n', '          _recoverableFunds = _recoverableFunds.add(stake.sub(transactionCost));\n', '        }\n', '\n', '        // emit an event for the payment of the transaction rebate\n', '        emit TransactionRebatePaid(\n', '          tx.origin,\n', '          refundAddress,\n', '          attributeTypeID,\n', '          transactionCost\n', '        );\n', '\n', '        // refund the cost of the transaction to the trasaction submitter\n', '        tx.origin.transfer(transactionCost);\n', '\n', '      // otherwise, allocate entire stake to partially refunding the transaction\n', '      } else {\n', '        // emit an event for the payment of the partial transaction rebate\n', '        emit TransactionRebatePaid(\n', '          tx.origin,\n', '          refundAddress,\n', '          attributeTypeID,\n', '          stake\n', '        );\n', '\n', '        // refund the partial cost of the transaction to trasaction submitter\n', '        tx.origin.transfer(stake);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\n', '  * value of `value`, and an associated validator fee of `validatorFee` to\n', '  * account of `msg.sender` by passing in a signed attribute approval with\n', '  * signature `signature`.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to add.\n', '  * @param value uint256 The value for the attribute to add.\n', '  * @param validatorFee uint256 The fee to be paid to the issuing validator.\n', '  * @param signature bytes The signature from the validator attribute approval.\n', '  */\n', '  function addAttribute(\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external payable {\n', '    // NOTE: determine best course of action when the attribute already exists\n', '    // NOTE: consider utilizing bytes32 type for attributes and values\n', '    // NOTE: does not currently support an extraData parameter, consider adding\n', '    // NOTE: if msg.sender is a proxy contract, its ownership may be transferred\n', '    // at will, circumventing any token transfer restrictions. Restricting usage\n', '    // to only externally owned accounts may partially alleviate this concern.\n', '    // NOTE: cosider including a salt (or better, nonce) parameter so that when\n', '    // a user adds an attribute, then it gets revoked, the user can get a new\n', '    // signature from the validator and renew the attribute using that. The main\n', '    // downside is that everyone will have to keep track of the extra parameter.\n', '    // Another solution is to just modifiy the required stake or fee amount.\n', '\n', '    require(\n', '      !_issuedAttributes[msg.sender][attributeTypeID].exists,\n', '      "duplicate attributes are not supported, remove existing attribute first"\n', '    );\n', '\n', '    // retrieve required minimum stake and jurisdiction fees on attribute type\n', '    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\n', '    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\n', '    uint256 stake = msg.value.sub(validatorFee).sub(jurisdictionFee);\n', '\n', '    require(\n', '      stake >= minimumStake,\n', '      "attribute requires a greater value than is currently provided"\n', '    );\n', '\n', '    // signed data hash constructed according to EIP-191-0x45 to prevent replays\n', '    bytes32 hash = keccak256(\n', '      abi.encodePacked(\n', '        address(this),\n', '        msg.sender,\n', '        address(0),\n', '        msg.value,\n', '        validatorFee,\n', '        attributeTypeID,\n', '        value\n', '      )\n', '    );\n', '\n', '    require(\n', '      !_invalidAttributeApprovalHashes[hash],\n', '      "signed attribute approvals from validators may not be reused"\n', '    );\n', '\n', '    // extract the key used to sign the message hash\n', '    address signingKey = hash.toEthSignedMessageHash().recover(signature);\n', '\n', '    // retrieve the validator who controls the extracted key\n', '    address validator = _signingKeys[signingKey];\n', '\n', '    require(\n', '      canValidate(validator, attributeTypeID),\n', '      "signature does not match an approved validator for given attribute type"\n', '    );\n', '\n', '    // store attribute value and amount of ether staked in correct scope\n', '    _issuedAttributes[msg.sender][attributeTypeID] = IssuedAttribute({\n', '      exists: true,\n', '      setPersonally: true,\n', '      operator: address(0),\n', '      validator: validator,\n', '      value: value,\n', '      stake: stake\n', '      // NOTE: no extraData included\n', '    });\n', '\n', "    // flag the signed approval as invalid once it's been used to set attribute\n", '    _invalidAttributeApprovalHashes[hash] = true;\n', '\n', '    // log the addition of the attribute\n', '    emit AttributeAdded(validator, msg.sender, attributeTypeID, value);\n', '\n', '    // log allocation of staked funds to the attribute if applicable\n', '    if (stake > 0) {\n', '      emit StakeAllocated(msg.sender, attributeTypeID, stake);\n', '    }\n', '\n', '    // pay jurisdiction fee to the owner of the jurisdiction if applicable\n', '    if (jurisdictionFee > 0) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a improperly\n', '      // configured fallback function could block addition of an attribute\n', '      if (owner().send(jurisdictionFee)) {\n', '        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(jurisdictionFee);\n', '      }\n', '    }\n', '\n', "    // pay validator fee to the issuing validator's address if applicable\n", '    if (validatorFee > 0) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a improperly\n', '      // configured fallback function could block addition of an attribute\n', '      if (validator.send(validatorFee)) {\n', '        emit FeePaid(validator, msg.sender, attributeTypeID, validatorFee);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(validatorFee);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Remove an attribute of the type with ID `attributeTypeID` from\n', '  * account of `msg.sender`.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to remove.\n', '  */\n', '  function removeAttribute(uint256 attributeTypeID) external {\n', '    // attributes may only be removed by the user if they are not restricted\n', '    require(\n', '      !_attributeTypes[attributeTypeID].restricted,\n', '      "only jurisdiction or issuing validator may remove a restricted attribute"\n', '    );\n', '\n', '    require(\n', '      _issuedAttributes[msg.sender][attributeTypeID].exists,\n', '      "only existing attributes may be removed"\n', '    );\n', '\n', '    // determine the assigned validator on the user attribute\n', '    address validator = _issuedAttributes[msg.sender][attributeTypeID].validator;\n', '\n', '    // determine if the attribute has a staked value\n', '    uint256 stake = _issuedAttributes[msg.sender][attributeTypeID].stake;\n', '\n', '    // determine the correct address to refund the staked amount to\n', '    address refundAddress;\n', '    if (_issuedAttributes[msg.sender][attributeTypeID].setPersonally) {\n', '      refundAddress = msg.sender;\n', '    } else {\n', '      address operator = _issuedAttributes[msg.sender][attributeTypeID].operator;\n', '      if (operator == address(0)) {\n', '        refundAddress = validator;\n', '      } else {\n', '        refundAddress = operator;\n', '      }\n', '    }    \n', '\n', '    // remove the attribute from the user address\n', '    delete _issuedAttributes[msg.sender][attributeTypeID];\n', '\n', '    // log the removal of the attribute\n', '    emit AttributeRemoved(validator, msg.sender, attributeTypeID);\n', '\n', '    // if the attribute has any staked balance, refund it to the user\n', '    if (stake > 0 && address(this).balance >= stake) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a malicious\n', "      // fallback function could forcibly block an attribute's removal\n", '      if (refundAddress.send(stake)) {\n', '        emit StakeRefunded(refundAddress, attributeTypeID, stake);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(stake);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\n', '  * value of `value`, and an associated validator fee of `validatorFee` to\n', '  * account `account` by passing in a signed attribute approval with signature\n', '  * `signature`.\n', '  * @param account address The account to add the attribute to.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to add.\n', '  * @param value uint256 The value for the attribute to add.\n', '  * @param validatorFee uint256 The fee to be paid to the issuing validator.\n', '  * @param signature bytes The signature from the validator attribute approval.\n', '  * @dev Restricted attribute types can only be removed by issuing validators or\n', '  * the jurisdiction itself.\n', '  */\n', '  function addAttributeFor(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external payable {\n', '    // NOTE: determine best course of action when the attribute already exists\n', '    // NOTE: consider utilizing bytes32 type for attributes and values\n', '    // NOTE: does not currently support an extraData parameter, consider adding\n', '    // NOTE: if msg.sender is a proxy contract, its ownership may be transferred\n', '    // at will, circumventing any token transfer restrictions. Restricting usage\n', '    // to only externally owned accounts may partially alleviate this concern.\n', '    // NOTE: consider including a salt (or better, nonce) parameter so that when\n', '    // a user adds an attribute, then it gets revoked, the user can get a new\n', '    // signature from the validator and renew the attribute using that. The main\n', '    // downside is that everyone will have to keep track of the extra parameter.\n', '    // Another solution is to just modifiy the required stake or fee amount.\n', '\n', '    // attributes may only be added by a third party if onlyPersonal is false\n', '    require(\n', '      !_attributeTypes[attributeTypeID].onlyPersonal,\n', '      "only operatable attributes may be added on behalf of another address"\n', '    );\n', '\n', '    require(\n', '      !_issuedAttributes[account][attributeTypeID].exists,\n', '      "duplicate attributes are not supported, remove existing attribute first"\n', '    );\n', '\n', '    // retrieve required minimum stake and jurisdiction fees on attribute type\n', '    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\n', '    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\n', '    uint256 stake = msg.value.sub(validatorFee).sub(jurisdictionFee);\n', '\n', '    require(\n', '      stake >= minimumStake,\n', '      "attribute requires a greater value than is currently provided"\n', '    );\n', '\n', '    // signed data hash constructed according to EIP-191-0x45 to prevent replays\n', '    bytes32 hash = keccak256(\n', '      abi.encodePacked(\n', '        address(this),\n', '        account,\n', '        msg.sender,\n', '        msg.value,\n', '        validatorFee,\n', '        attributeTypeID,\n', '        value\n', '      )\n', '    );\n', '\n', '    require(\n', '      !_invalidAttributeApprovalHashes[hash],\n', '      "signed attribute approvals from validators may not be reused"\n', '    );\n', '\n', '    // extract the key used to sign the message hash\n', '    address signingKey = hash.toEthSignedMessageHash().recover(signature);\n', '\n', '    // retrieve the validator who controls the extracted key\n', '    address validator = _signingKeys[signingKey];\n', '\n', '    require(\n', '      canValidate(validator, attributeTypeID),\n', '      "signature does not match an approved validator for provided attribute"\n', '    );\n', '\n', '    // store attribute value and amount of ether staked in correct scope\n', '    _issuedAttributes[account][attributeTypeID] = IssuedAttribute({\n', '      exists: true,\n', '      setPersonally: false,\n', '      operator: msg.sender,\n', '      validator: validator,\n', '      value: value,\n', '      stake: stake\n', '      // NOTE: no extraData included\n', '    });\n', '\n', "    // flag the signed approval as invalid once it's been used to set attribute\n", '    _invalidAttributeApprovalHashes[hash] = true;\n', '\n', '    // log the addition of the attribute\n', '    emit AttributeAdded(validator, account, attributeTypeID, value);\n', '\n', '    // log allocation of staked funds to the attribute if applicable\n', '    // NOTE: the staker is the entity that pays the fee here!\n', '    if (stake > 0) {\n', '      emit StakeAllocated(msg.sender, attributeTypeID, stake);\n', '    }\n', '\n', '    // pay jurisdiction fee to the owner of the jurisdiction if applicable\n', '    if (jurisdictionFee > 0) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a improperly\n', '      // configured fallback function could block addition of an attribute\n', '      if (owner().send(jurisdictionFee)) {\n', '        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(jurisdictionFee);\n', '      }\n', '    }\n', '\n', "    // pay validator fee to the issuing validator's address if applicable\n", '    if (validatorFee > 0) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a improperly\n', '      // configured fallback function could block addition of an attribute\n', '      if (validator.send(validatorFee)) {\n', '        emit FeePaid(validator, msg.sender, attributeTypeID, validatorFee);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(validatorFee);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Remove an attribute of the type with ID `attributeTypeID` from\n', '  * account of `account`.\n', '  * @param account address The account to remove the attribute from.\n', '  * @param attributeTypeID uint256 The ID of the attribute type to remove.\n', '  * @dev Restricted attribute types can only be removed by issuing validators or\n', '  * the jurisdiction itself.\n', '  */\n', '  function removeAttributeFor(address account, uint256 attributeTypeID) external {\n', '    // attributes may only be removed by the user if they are not restricted\n', '    require(\n', '      !_attributeTypes[attributeTypeID].restricted,\n', '      "only jurisdiction or issuing validator may remove a restricted attribute"\n', '    );\n', '\n', '    require(\n', '      _issuedAttributes[account][attributeTypeID].exists,\n', '      "only existing attributes may be removed"\n', '    );\n', '\n', '    require(\n', '      _issuedAttributes[account][attributeTypeID].operator == msg.sender,\n', '      "only an assigning operator may remove attribute on behalf of an address"\n', '    );\n', '\n', '    // determine the assigned validator on the user attribute\n', '    address validator = _issuedAttributes[account][attributeTypeID].validator;\n', '\n', '    // determine if the attribute has a staked value\n', '    uint256 stake = _issuedAttributes[account][attributeTypeID].stake;\n', '\n', '    // remove the attribute from the user address\n', '    delete _issuedAttributes[account][attributeTypeID];\n', '\n', '    // log the removal of the attribute\n', '    emit AttributeRemoved(validator, account, attributeTypeID);\n', '\n', '    // if the attribute has any staked balance, refund it to the user\n', '    if (stake > 0 && address(this).balance >= stake) {\n', '      // NOTE: send is chosen over transfer to prevent cases where a malicious\n', "      // fallback function could forcibly block an attribute's removal\n", '      if (msg.sender.send(stake)) {\n', '        emit StakeRefunded(msg.sender, attributeTypeID, stake);\n', '      } else {\n', '        _recoverableFunds = _recoverableFunds.add(stake);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Invalidate a signed attribute approval before it has been set by\n', '   * supplying the hash of the approval `hash` and the signature `signature`.\n', '   * @param hash bytes32 The hash of the attribute approval.\n', "   * @param signature bytes The hash's signature, resolving to the signing key.\n", '   * @dev Attribute approvals can only be removed by issuing validators or the\n', '   * jurisdiction itself.\n', '   */\n', '  function invalidateAttributeApproval(\n', '    bytes32 hash,\n', '    bytes signature\n', '  ) external {\n', '    // determine the assigned validator on the signed attribute approval\n', '    address validator = _signingKeys[\n', '      hash.toEthSignedMessageHash().recover(signature) // signingKey\n', '    ];\n', '    \n', '    // caller must be either the jurisdiction owner or the assigning validator\n', '    require(\n', '      msg.sender == validator || msg.sender == owner(),\n', '      "only jurisdiction or issuing validator may invalidate attribute approval"\n', '    );\n', '\n', '    // add the hash to the set of invalid attribute approval hashes\n', '    _invalidAttributeApprovalHashes[hash] = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Check if an attribute of the type with ID `attributeTypeID` has\n', '   * been assigned to the account at `account` and is currently valid.\n', '   * @param account address The account to check for a valid attribute.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return True if the attribute is assigned and valid, false otherwise.\n', '   * @dev This function MUST return either true or false - i.e. calling this\n', '   * function MUST NOT cause the caller to revert.\n', '   */\n', '  function hasAttribute(\n', '    address account, \n', '    uint256 attributeTypeID\n', '  ) external view returns (bool) {\n', '    address validator = _issuedAttributes[account][attributeTypeID].validator;\n', '    return (\n', '      (\n', '        _validators[validator].exists &&   // isValidator(validator)\n', '        _attributeTypes[attributeTypeID].approvedValidators[validator] &&\n', '        _attributeTypes[attributeTypeID].exists //isAttributeType(attributeTypeID)\n', '      ) || (\n', '        _attributeTypes[attributeTypeID].secondarySource != address(0) &&\n', '        secondaryHasAttribute(\n', '          _attributeTypes[attributeTypeID].secondarySource,\n', '          account,\n', '          _attributeTypes[attributeTypeID].secondaryAttributeTypeID\n', '        )\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Retrieve the value of the attribute of the type with ID\n', '   * `attributeTypeID` on the account at `account`, assuming it is valid.\n', '   * @param account address The account to check for the given attribute value.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return The attribute value if the attribute is valid, reverts otherwise.\n', '   * @dev This function MUST revert if a directly preceding or subsequent\n', '   * function call to `hasAttribute` with identical `account` and\n', '   * `attributeTypeID` parameters would return false.\n', '   */\n', '  function getAttributeValue(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external view returns (uint256 value) {\n', '    // gas optimization: get validator & call canValidate function body directly\n', '    address validator = _issuedAttributes[account][attributeTypeID].validator;\n', '    if (\n', '      _validators[validator].exists &&   // isValidator(validator)\n', '      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\n', '      _attributeTypes[attributeTypeID].exists //isAttributeType(attributeTypeID)\n', '    ) {\n', '      return _issuedAttributes[account][attributeTypeID].value;\n', '    } else if (\n', '      _attributeTypes[attributeTypeID].secondarySource != address(0)\n', '    ) {\n', "      // if attributeTypeID = uint256 of 'wyre-yes-token', use special handling\n", '      if (_attributeTypes[attributeTypeID].secondaryAttributeTypeID == 2423228754106148037712574142965102) {\n', '        require(\n', '          IERC20(\n', '            _attributeTypes[attributeTypeID].secondarySource\n', '          ).balanceOf(account) >= 1,\n', '          "no Yes Token has been issued to the provided account"\n', '        );\n', "        return 1; // this could also return a specific yes token's country code?\n", '      }\n', '\n', '      // first ensure hasAttribute on the secondary source returns true\n', '      require(\n', '        AttributeRegistryInterface(\n', '          _attributeTypes[attributeTypeID].secondarySource\n', '        ).hasAttribute(\n', '          account, _attributeTypes[attributeTypeID].secondaryAttributeTypeID\n', '        ),\n', '        "attribute of the provided type is not assigned to the provided account"\n', '      );\n', '\n', '      return (\n', '        AttributeRegistryInterface(\n', '          _attributeTypes[attributeTypeID].secondarySource\n', '        ).getAttributeValue(\n', '          account, _attributeTypes[attributeTypeID].secondaryAttributeTypeID\n', '        )\n', '      );\n', '    }\n', '\n', '    // NOTE: checking for values of invalid attributes will revert\n', '    revert("could not find an attribute value at the provided account and ID");\n', '  }\n', '\n', '  /**\n', '   * @notice Determine if a validator at account `validator` is able to issue\n', '   * attributes of the type with ID `attributeTypeID`.\n', '   * @param validator address The account of the validator.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check.\n', '   * @return True if the validator can issue attributes of the given type, false\n', '   * otherwise.\n', '   */\n', '  function canIssueAttributeType(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) external view returns (bool) {\n', '    return canValidate(validator, attributeTypeID);\n', '  }\n', '\n', '  /**\n', '   * @notice Get a description of the attribute type with ID `attributeTypeID`.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check for.\n', '   * @return A description of the attribute type.\n', '   */\n', '  function getAttributeTypeDescription(\n', '    uint256 attributeTypeID\n', '  ) external view returns (\n', '    string description\n', '  ) {\n', '    return _attributeTypes[attributeTypeID].description;\n', '  }\n', '\n', '  /**\n', '   * @notice Get comprehensive information on an attribute type with ID\n', '   * `attributeTypeID`.\n', '   * @param attributeTypeID uint256 The attribute type ID in question.\n', '   * @return Information on the attribute type in question.\n', '   */\n', '  function getAttributeTypeInformation(\n', '    uint256 attributeTypeID\n', '  ) external view returns (\n', '    string description,\n', '    bool isRestricted,\n', '    bool isOnlyPersonal,\n', '    address secondarySource,\n', '    uint256 secondaryAttributeTypeID,\n', '    uint256 minimumRequiredStake,\n', '    uint256 jurisdictionFee\n', '  ) {\n', '    return (\n', '      _attributeTypes[attributeTypeID].description,\n', '      _attributeTypes[attributeTypeID].restricted,\n', '      _attributeTypes[attributeTypeID].onlyPersonal,\n', '      _attributeTypes[attributeTypeID].secondarySource,\n', '      _attributeTypes[attributeTypeID].secondaryAttributeTypeID,\n', '      _attributeTypes[attributeTypeID].minimumStake,\n', '      _attributeTypes[attributeTypeID].jurisdictionFee\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Get a description of the validator at account `validator`.\n', '   * @param validator address The account of the validator in question.\n', '   * @return A description of the validator.\n', '   */\n', '  function getValidatorDescription(\n', '    address validator\n', '  ) external view returns (\n', '    string description\n', '  ) {\n', '    return _validators[validator].description;\n', '  }\n', '\n', '  /**\n', '   * @notice Get the signing key of the validator at account `validator`.\n', '   * @param validator address The account of the validator in question.\n', '   * @return The signing key of the validator.\n', '   */\n', '  function getValidatorSigningKey(\n', '    address validator\n', '  ) external view returns (\n', '    address signingKey\n', '  ) {\n', '    return _validators[validator].signingKey;\n', '  }\n', '\n', '  /**\n', '   * @notice Find the validator that issued the attribute of the type with ID\n', '   * `attributeTypeID` on the account at `account` and determine if the\n', '   * validator is still valid.\n', '   * @param account address The account that contains the attribute be checked.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @return The validator and the current status of the validator as it\n', '   * pertains to the attribute type in question.\n', '   * @dev if no attribute of the given attribute type exists on the account, the\n', '   * function will return (address(0), false).\n', '   */\n', '  function getAttributeValidator(\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) external view returns (\n', '    address validator,\n', '    bool isStillValid\n', '  ) {\n', '    address issuer = _issuedAttributes[account][attributeTypeID].validator;\n', '    return (issuer, canValidate(issuer, attributeTypeID));\n', '  }\n', '\n', '  /**\n', '   * @notice Count the number of attribute types defined by the registry.\n', '   * @return The number of available attribute types.\n', '   * @dev This function MUST return a positive integer value  - i.e. calling\n', '   * this function MUST NOT cause the caller to revert.\n', '   */\n', '  function countAttributeTypes() external view returns (uint256) {\n', '    return _attributeIDs.length;\n', '  }\n', '\n', '  /**\n', '   * @notice Get the ID of the attribute type at index `index`.\n', '   * @param index uint256 The index of the attribute type in question.\n', '   * @return The ID of the attribute type.\n', '   * @dev This function MUST revert if the provided `index` value falls outside\n', '   * of the range of the value returned from a directly preceding or subsequent\n', '   * function call to `countAttributeTypes`. It MUST NOT revert if the provided\n', '   * `index` value falls inside said range.\n', '   */\n', '  function getAttributeTypeID(uint256 index) external view returns (uint256) {\n', '    require(\n', '      index < _attributeIDs.length,\n', '      "provided index is outside of the range of defined attribute type IDs"\n', '    );\n', '\n', '    return _attributeIDs[index];\n', '  }\n', '\n', '  /**\n', '   * @notice Get the IDs of all available attribute types on the jurisdiction.\n', '   * @return A dynamic array containing all available attribute type IDs.\n', '   */\n', '  function getAttributeTypeIDs() external view returns (uint256[]) {\n', '    return _attributeIDs;\n', '  }\n', '\n', '  /**\n', '   * @notice Count the number of validators defined by the jurisdiction.\n', '   * @return The number of defined validators.\n', '   */\n', '  function countValidators() external view returns (uint256) {\n', '    return _validatorAccounts.length;\n', '  }\n', '\n', '  /**\n', '   * @notice Get the account of the validator at index `index`.\n', '   * @param index uint256 The index of the validator in question.\n', '   * @return The account of the validator.\n', '   */\n', '  function getValidator(\n', '    uint256 index\n', '  ) external view returns (address) {\n', '    return _validatorAccounts[index];\n', '  }\n', '\n', '  /**\n', '   * @notice Get the accounts of all available validators on the jurisdiction.\n', '   * @return A dynamic array containing all available validator accounts.\n', '   */\n', '  function getValidators() external view returns (address[]) {\n', '    return _validatorAccounts;\n', '  }\n', '\n', '  /**\n', '   * @notice Determine if the interface ID `interfaceID` is supported (ERC-165)\n', '   * @param interfaceID bytes4 The interface ID in question.\n', '   * @return True if the interface is supported, false otherwise.\n', '   * @dev this function will produce a compiler warning recommending that the\n', '   * visibility be set to pure, but the interface expects a view function.\n', '   * Supported interfaces include ERC-165 (0x01ffc9a7) and the attribute\n', '   * registry interface (0x5f46473f).\n', '   */\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '    return (\n', '      interfaceID == this.supportsInterface.selector || // ERC165\n', '      interfaceID == (\n', '        this.hasAttribute.selector \n', '        ^ this.getAttributeValue.selector\n', '        ^ this.countAttributeTypes.selector\n', '        ^ this.getAttributeTypeID.selector\n', '      ) // AttributeRegistryInterface\n', '    ); // 0x01ffc9a7 || 0x5f46473f\n', '  }\n', '\n', '  /**\n', '   * @notice Get the hash of a given attribute approval.\n', '   * @param account address The account specified by the attribute approval.\n', '   * @param operator address An optional account permitted to submit approval.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @return The hash of the attribute approval.\n', '   */\n', '  function getAttributeApprovalHash(\n', '    address account,\n', '    address operator,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee\n', '  ) external view returns (\n', '    bytes32 hash\n', '  ) {\n', '    return calculateAttributeApprovalHash(\n', '      account,\n', '      operator,\n', '      attributeTypeID,\n', '      value,\n', '      fundsRequired,\n', '      validatorFee\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Check if a given signed attribute approval is currently valid when\n', '   * submitted directly by `msg.sender`.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @param signature bytes The attribute approval signature, based on a hash of\n', '   * the other parameters and the submitting account.\n', '   * @return True if the approval is currently valid, false otherwise.\n', '   */\n', '  function canAddAttribute(\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external view returns (bool) {\n', '    // signed data hash constructed according to EIP-191-0x45 to prevent replays\n', '    bytes32 hash = calculateAttributeApprovalHash(\n', '      msg.sender,\n', '      address(0),\n', '      attributeTypeID,\n', '      value,\n', '      fundsRequired,\n', '      validatorFee\n', '    );\n', '\n', '    // recover the address associated with the signature of the message hash\n', '    address signingKey = hash.toEthSignedMessageHash().recover(signature);\n', '    \n', '    // retrieve variables necessary to perform checks\n', '    address validator = _signingKeys[signingKey];\n', '    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\n', '    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\n', '\n', '    // determine if the attribute can currently be added.\n', '    // NOTE: consider returning an error code along with the boolean.\n', '    return (\n', '      fundsRequired >= minimumStake.add(jurisdictionFee).add(validatorFee) &&\n', '      !_invalidAttributeApprovalHashes[hash] &&\n', '      canValidate(validator, attributeTypeID) &&\n', '      !_issuedAttributes[msg.sender][attributeTypeID].exists\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Check if a given signed attribute approval is currently valid for a\n', '   * given account when submitted by the operator at `msg.sender`.\n', '   * @param account address The account specified by the attribute approval.\n', '   * @param attributeTypeID uint256 The ID of the attribute type in question.\n', '   * @param value uint256 The value of the attribute in the approval.\n', '   * @param fundsRequired uint256 The amount to be included with the approval.\n', '   * @param validatorFee uint256 The required fee to be paid to the validator.\n', '   * @param signature bytes The attribute approval signature, based on a hash of\n', '   * the other parameters and the submitting account.\n', '   * @return True if the approval is currently valid, false otherwise.\n', '   */\n', '  function canAddAttributeFor(\n', '    address account,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee,\n', '    bytes signature\n', '  ) external view returns (bool) {\n', '    // signed data hash constructed according to EIP-191-0x45 to prevent replays\n', '    bytes32 hash = calculateAttributeApprovalHash(\n', '      account,\n', '      msg.sender,\n', '      attributeTypeID,\n', '      value,\n', '      fundsRequired,\n', '      validatorFee\n', '    );\n', '\n', '    // recover the address associated with the signature of the message hash\n', '    address signingKey = hash.toEthSignedMessageHash().recover(signature);\n', '    \n', '    // retrieve variables necessary to perform checks\n', '    address validator = _signingKeys[signingKey];\n', '    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\n', '    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\n', '\n', '    // determine if the attribute can currently be added.\n', '    // NOTE: consider returning an error code along with the boolean.\n', '    return (\n', '      fundsRequired >= minimumStake.add(jurisdictionFee).add(validatorFee) &&\n', '      !_invalidAttributeApprovalHashes[hash] &&\n', '      canValidate(validator, attributeTypeID) &&\n', '      !_issuedAttributes[account][attributeTypeID].exists\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Determine if an attribute type with ID `attributeTypeID` is\n', '   * currently defined on the jurisdiction.\n', '   * @param attributeTypeID uint256 The attribute type ID in question.\n', '   * @return True if the attribute type is defined, false otherwise.\n', '   */\n', '  function isAttributeType(uint256 attributeTypeID) public view returns (bool) {\n', '    return _attributeTypes[attributeTypeID].exists;\n', '  }\n', '\n', '  /**\n', '   * @notice Determine if the account `account` is currently assigned as a\n', '   * validator on the jurisdiction.\n', '   * @param account address The account to check for validator status.\n', '   * @return True if the account is assigned as a validator, false otherwise.\n', '   */\n', '  function isValidator(address account) public view returns (bool) {\n', '    return _validators[account].exists;\n', '  }\n', '\n', '  /**\n', '   * @notice Check for recoverable funds that have become locked in the\n', '   * jurisdiction as a result of improperly configured receivers for payments of\n', '   * fees or remaining stake. Note that funds sent into the jurisdiction as a \n', '   * result of coinbase assignment or as the recipient of a selfdestruct will\n', '   * not be recoverable.\n', '   * @return The total tracked recoverable funds.\n', '   */\n', '  function recoverableFunds() public view returns (uint256) {\n', '    // return the total tracked recoverable funds.\n', '    return _recoverableFunds;\n', '  }\n', '\n', '  /**\n', '   * @notice Check for recoverable tokens that are owned by the jurisdiction at\n', '   * the token contract address of `token`.\n', '   * @param token address The account where token contract is located.\n', '   * @return The total recoverable tokens.\n', '   */\n', '  function recoverableTokens(address token) public view returns (uint256) {\n', '    // return the total tracked recoverable tokens.\n', '    return IERC20(token).balanceOf(address(this));\n', '  }\n', '\n', '  /**\n', '   * @notice Recover funds that have become locked in the jurisdiction as a\n', '   * result of improperly configured receivers for payments of fees or remaining\n', '   * stake by transferring an amount of `value` to the address at `account`.\n', '   * Note that funds sent into the jurisdiction as a result of coinbase\n', '   * assignment or as the recipient of a selfdestruct will not be recoverable.\n', '   * @param account address The account to send recovered tokens.\n', '   * @param value uint256 The amount of tokens to be sent.\n', '   */\n', '  function recoverFunds(address account, uint256 value) public onlyOwner {    \n', '    // safely deduct the value from the total tracked recoverable funds.\n', '    _recoverableFunds = _recoverableFunds.sub(value);\n', '    \n', '    // transfer the value to the specified account & revert if any error occurs.\n', '    account.transfer(value);\n', '  }\n', '\n', '  /**\n', '   * @notice Recover tokens that are owned by the jurisdiction at the token\n', '   * contract address of `token`, transferring an amount of `value` to the\n', '   * address at `account`.\n', '   * @param token address The account where token contract is located.\n', '   * @param account address The account to send recovered funds.\n', '   * @param value uint256 The amount of ether to be sent.\n', '   */\n', '  function recoverTokens(\n', '    address token,\n', '    address account,\n', '    uint256 value\n', '  ) public onlyOwner {\n', '    // transfer the value to the specified account & revert if any error occurs.\n', '    require(IERC20(token).transfer(account, value));\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to determine if a validator at account\n', '   * `validator` can issue attributes of the type with ID `attributeTypeID`.\n', '   * @param validator address The account of the validator.\n', '   * @param attributeTypeID uint256 The ID of the attribute type to check.\n', '   * @return True if the validator can issue attributes of the given type, false\n', '   * otherwise.\n', '   */\n', '  function canValidate(\n', '    address validator,\n', '    uint256 attributeTypeID\n', '  ) internal view returns (bool) {\n', '    return (\n', '      _validators[validator].exists &&   // isValidator(validator)\n', '      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\n', '      _attributeTypes[attributeTypeID].exists // isAttributeType(attributeTypeID)\n', '    );\n', '  }\n', '\n', '  // internal helper function for getting the hash of an attribute approval\n', '  function calculateAttributeApprovalHash(\n', '    address account,\n', '    address operator,\n', '    uint256 attributeTypeID,\n', '    uint256 value,\n', '    uint256 fundsRequired,\n', '    uint256 validatorFee\n', '  ) internal view returns (bytes32 hash) {\n', '    return keccak256(\n', '      abi.encodePacked(\n', '        address(this),\n', '        account,\n', '        operator,\n', '        fundsRequired,\n', '        validatorFee,\n', '        attributeTypeID,\n', '        value\n', '      )\n', '    );\n', '  }\n', '\n', "  // helper function, won't revert calling hasAttribute on secondary registries\n", '  function secondaryHasAttribute(\n', '    address source,\n', '    address account,\n', '    uint256 attributeTypeID\n', '  ) internal view returns (bool result) {\n', "    // if attributeTypeID = uint256 of 'wyre-yes-token', use special handling\n", '    if (attributeTypeID == 2423228754106148037712574142965102) {\n', '      return (IERC20(source).balanceOf(account) >= 1);\n', '    }\n', '\n', '    uint256 maxGas = gasleft() > 20000 ? 20000 : gasleft();\n', '    bytes memory encodedParams = abi.encodeWithSelector(\n', '      this.hasAttribute.selector,\n', '      account,\n', '      attributeTypeID\n', '    );\n', '\n', '    assembly {\n', '      let encodedParams_data := add(0x20, encodedParams)\n', '      let encodedParams_size := mload(encodedParams)\n', '      \n', '      let output := mload(0x40) // get storage start from free memory pointer\n', '      mstore(output, 0x0)       // set up the location for output of staticcall\n', '\n', '      let success := staticcall(\n', '        maxGas,                 // maximum of 20k gas can be forwarded\n', '        source,                 // address of attribute registry to call\n', '        encodedParams_data,     // inputs are stored at pointer location\n', '        encodedParams_size,     // inputs are 68 bytes (4 + 32 * 2)\n', '        output,                 // return to designated free space\n', '        0x20                    // output is one word, or 32 bytes\n', '      )\n', '\n', '      switch success            // instrumentation bug: use switch instead of if\n', '      case 1 {                  // only recognize successful staticcall output \n', '        result := mload(output) // set the output to the return value\n', '      }\n', '    }\n', '  }\n', '}']