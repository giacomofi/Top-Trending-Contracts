['pragma solidity ^0.4.15;\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() {\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/**\n', '    ERC20 Standard Token implementation\n', '*/\n', 'contract ERC20Token is IERC20Token, Utils {\n', '    string public standard = "Token 0.1";\n', '    string public name = "";\n', '    string public symbol = "";\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _name        token name\n', '        @param _symbol      token symbol\n', '        @param _decimals    decimal points, for display purposes\n', '    */\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '        @dev send coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', "        @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev an account/contract attempts to get the coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        @param _from    source address\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', "        @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    /**\n', '        @dev allow another account/contract to spend some tokens on your behalf\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        also, to minimize the risk of the approve/transferFrom attack vector\n', '        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n', '        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n', '\n', '        @param _spender approved address\n', '        @param _value   allowance amount\n', '\n', "        @return true if the approval was successful, false if it wasn't\n", '    */\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', "        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n", '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public constant returns (address) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '\n', 'contract TokenHolder is ITokenHolder, Owned, Utils {\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function TokenHolder() {\n', '    }\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '\n', 'contract CLRSToken is ERC20Token, TokenHolder {\n', '\n', '///////////////////////////////////////// VARIABLE INITIALIZATION /////////////////////////////////////////\n', '\n', '    uint256 constant public CLRS_UNIT = 10 ** 18;\n', '    uint256 public totalSupply = 86374977 * CLRS_UNIT;\n', '\n', '    //  Constants\n', '    uint256 constant public maxIcoSupply = 48369987 * CLRS_UNIT;           // ICO pool allocation\n', '    uint256 constant public Company = 7773748 * CLRS_UNIT;     //  Company pool allocation\n', '    uint256 constant public Bonus = 16411245 * CLRS_UNIT;  // Bonus Allocation\n', '    uint256 constant public Bounty = 1727500 * CLRS_UNIT;  // Bounty Allocation\n', '    uint256 constant public advisorsAllocation = 4318748 * CLRS_UNIT;          // Advisors Allocation\n', '    uint256 constant public CLRSinTeamAllocation = 7773748 * CLRS_UNIT;    // CLRSin Team allocation\n', '\n', '   // Addresses of Patrons\n', '   address public constant ICOSTAKE = 0xd82896Ea0B5848dc3b75bbECc747947F64077b7c;\n', '   address public constant COMPANY_STAKE_1 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant COMPANY_STAKE_2 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '     address public constant COMPANY_STAKE_3 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '      address public constant COMPANY_STAKE_4 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '       address public constant COMPANY_STAKE_5 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant ADVISOR_1 = 0xf0eB71d3b31fEe5D15220A2ac418A784c962Eb53;\n', '    address public constant ADVISOR_2 = 0xFd6b0691Cd486B4124fFD9FBe9e013463868E2B4;\n', '    address public constant ADVISOR_3 = 0xCFb32aFA7752170043aaC32794397C8673778765;\n', '    address public constant ADVISOR_4 = 0x08441513c0Fc653a739F34A97eF6B2B05609a4E4;\n', '    address public constant ADVISOR_5 = 0xFd6b0691Cd486B4124fFD9FBe9e013463868E2B4;\n', '    address public constant TEAM_1 = 0xc4896CB7486ed8821B525D858c85D4321e8e5685;\n', '    address public constant TEAM_2 = 0x304765b9c3072E54b7397E2F55D1463BD62802C3;\n', '    address public constant TEAM_3 = 0x46abC1d38573E8726c6C0568CC01f35fE5FF4765;\n', '    address public constant TEAM_4 = 0x36Bf4b1DDd796eaf1f962cB0E0327C15096fae41;\n', '    address public constant TEAM_5 = 0xc4896CB7486ed8821B525D858c85D4321e8e5685;\n', '    address public constant BONUS_1 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BONUS_2 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BONUS_3 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BONUS_4 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BONUS_5 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BOUNTY_1 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BOUNTY_2 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BOUNTY_3 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BOUNTY_4 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '    address public constant BOUNTY_5 = 0x19333A742dcd220683C2231c0FAaCcb9c810C0B5;\n', '\n', '\n', '\n', '\n', '\n', '\n', '    // Stakes of COMPANY\n', 'uint256 constant public COMPANY_1 = 7773744 * CLRS_UNIT; //token allocated to  company1\n', 'uint256 constant public COMPANY_2 = 1 * CLRS_UNIT; //token allocated to  company1\n', 'uint256 constant public COMPANY_3 = 1 * CLRS_UNIT; //token allocated to  company1\n', 'uint256 constant public COMPANY_4 = 1 * CLRS_UNIT; //token allocated to  company1\n', 'uint256 constant public COMPANY_5 = 1 * CLRS_UNIT; //token allocated to  company1\n', '\n', '// Stakes of ADVISORS\n', 'uint256 constant public ADVISOR1 = 863750 * CLRS_UNIT; //token allocated to adv1\n', 'uint256 constant public ADVISOR2 = 863750 * CLRS_UNIT; //token allocated to  adv2\n', 'uint256 constant public ADVISOR3 = 431875 * CLRS_UNIT; //token allocated to  adv3\n', 'uint256 constant public ADVISOR4 = 431875 * CLRS_UNIT; //token allocated to  adv4\n', 'uint256 constant public ADVISOR5 = 863750 * CLRS_UNIT; //token allocated to adv5\n', '\n', '\n', '// Stakes of TEAM\n', 'uint256 constant public TEAM1 = 3876873 * CLRS_UNIT; //token allocated to  team1\n', 'uint256 constant public TEAM2 = 3876874 * CLRS_UNIT; //token allocated to  team2\n', 'uint256 constant public TEAM3 = 10000 * CLRS_UNIT; //token allocated to  team3\n', 'uint256 constant public TEAM4 = 10000 * CLRS_UNIT; //token allocated to  team4\n', 'uint256 constant public TEAM5 = 1 * CLRS_UNIT; //token allocated to  team5\n', '\n', '\n', '// Stakes of BONUS\n', 'uint256 constant public BONUS1 = 16411241 * CLRS_UNIT; //token allocated to bonus1\n', 'uint256 constant public BONUS2 = 1 * CLRS_UNIT; //token allocated to bonus2\n', 'uint256 constant public BONUS3 = 1 * CLRS_UNIT; //token allocated to bonus3\n', 'uint256 constant public BONUS4 = 1 * CLRS_UNIT; //token allocated to bonus4\n', 'uint256 constant public BONUS5 = 1 * CLRS_UNIT; //token allocated to bonus5\n', '\n', '// Stakes of BOUNTY\n', 'uint256 constant public BOUNTY1 = 1727400 * CLRS_UNIT; //token allocated to bounty1\n', 'uint256 constant public BOUNTY2 = 1 * CLRS_UNIT; //token allocated to bounty2\n', 'uint256 constant public BOUNTY3 = 1 * CLRS_UNIT; //token allocated bounty3\n', 'uint256 constant public BOUNTY4 = 1 * CLRS_UNIT; //token allocated bounty4\n', 'uint256 constant public BOUNTY5 = 1 * CLRS_UNIT; //token allocated bounty5\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '    //  Variables\n', '\n', 'uint256 public totalAllocatedToCompany = 0;     // Counter to keep track of comapny token allocation\n', 'uint256 public totalAllocatedToAdvisor = 0;        // Counter to keep track of advisor token allocation\n', 'uint256 public totalAllocatedToTEAM = 0;     // Counter to keep track of team token allocation\n', 'uint256 public totalAllocatedToBONUS = 0;        // Counter to keep track of bonus token allocation\n', 'uint256 public totalAllocatedToBOUNTY = 0;      // Counter to keep track of bounty token allocation\n', '\n', 'uint256 public remaintokensteam=0;\n', 'uint256 public remaintokensadvisors=0;\n', 'uint256 public remaintokensbounty=0;\n', 'uint256 public remaintokensbonus=0;\n', 'uint256 public remaintokenscompany=0;\n', 'uint256 public totremains=0;\n', '\n', '\n', 'uint256 public totalAllocated = 0;             // Counter to keep track of overall token allocation\n', '    uint256 public endTime;                                     // timestamp\n', '\n', '    bool internal isReleasedToPublic = false; // Flag to allow transfer/transferFrom\n', '\n', '    bool public isReleasedToadv = false;\n', '    bool public isReleasedToteam = false;\n', '///////////////////////////////////////// MODIFIERS /////////////////////////////////////////\n', '\n', '    // CLRSin Team timelock\n', '   /* modifier safeTimelock() {\n', '        require(now >= endTime + 52 weeks);\n', '        _;\n', '    }\n', '\n', '    // Advisor Team timelock\n', '    modifier advisorTimelock() {\n', '        require(now >= endTime + 26 weeks);\n', '        _;\n', '    }*/\n', '\n', '\n', '\n', '    ///////////////////////////////////////// CONSTRUCTOR /////////////////////////////////////////\n', '\n', '\n', '    function CLRSToken()\n', '    ERC20Token("CLRS", "CLRS", 18)\n', '     {\n', '\n', '\n', '        balanceOf[ICOSTAKE] = maxIcoSupply; // ico CLRS tokens\n', '        balanceOf[COMPANY_STAKE_1] = COMPANY_1; // Company1 CLRS tokens\n', '         balanceOf[COMPANY_STAKE_2] = COMPANY_2; // Company2 CLRS tokens\n', '          balanceOf[COMPANY_STAKE_3] = COMPANY_3; // Company3 CLRS tokens\n', '           balanceOf[COMPANY_STAKE_4] = COMPANY_4; // Company4 CLRS tokens\n', '            balanceOf[COMPANY_STAKE_5] = COMPANY_5; // Company5 CLRS tokens\n', '            totalAllocatedToCompany = safeAdd(totalAllocatedToCompany, COMPANY_1);\n', 'totalAllocatedToCompany = safeAdd(totalAllocatedToCompany, COMPANY_2);\n', 'totalAllocatedToCompany = safeAdd(totalAllocatedToCompany, COMPANY_3);\n', 'totalAllocatedToCompany = safeAdd(totalAllocatedToCompany, COMPANY_4);\n', 'totalAllocatedToCompany = safeAdd(totalAllocatedToCompany, COMPANY_5);\n', '\n', 'remaintokenscompany=safeSub(Company,totalAllocatedToCompany);\n', '\n', 'balanceOf[ICOSTAKE]=safeAdd(balanceOf[ICOSTAKE],remaintokenscompany);\n', '\n', '        balanceOf[BONUS_1] = BONUS1;       // bonus1 CLRS tokens\n', '        balanceOf[BONUS_2] = BONUS2;       // bonus2 CLRS tokens\n', '        balanceOf[BONUS_3] = BONUS3;       // bonus3 CLRS tokens\n', '        balanceOf[BONUS_4] = BONUS4;       // bonus4 CLRS tokens\n', '        balanceOf[BONUS_5] = BONUS5;       // bonus5 CLRS tokens\n', '        totalAllocatedToBONUS = safeAdd(totalAllocatedToBONUS, BONUS1);\n', 'totalAllocatedToBONUS = safeAdd(totalAllocatedToBONUS, BONUS2);\n', 'totalAllocatedToBONUS = safeAdd(totalAllocatedToBONUS, BONUS3);\n', 'totalAllocatedToBONUS = safeAdd(totalAllocatedToBONUS, BONUS4);\n', 'totalAllocatedToBONUS = safeAdd(totalAllocatedToBONUS, BONUS5);\n', '\n', 'remaintokensbonus=safeSub(Bonus,totalAllocatedToBONUS);\n', '\n', 'balanceOf[ICOSTAKE]=safeAdd(balanceOf[ICOSTAKE],remaintokensbonus);\n', '\n', '        balanceOf[BOUNTY_1] = BOUNTY1;       // BOUNTY1 CLRS tokens\n', '        balanceOf[BOUNTY_2] = BOUNTY2;       // BOUNTY2 CLRS tokens\n', '        balanceOf[BOUNTY_3] = BOUNTY3;       // BOUNTY3 CLRS tokens\n', '        balanceOf[BOUNTY_4] = BOUNTY4;       // BOUNTY4 CLRS tokens\n', '        balanceOf[BOUNTY_5] = BOUNTY5;       // BOUNTY5 CLRS tokens\n', '\n', 'totalAllocatedToBOUNTY = safeAdd(totalAllocatedToBOUNTY, BOUNTY1);\n', 'totalAllocatedToBOUNTY = safeAdd(totalAllocatedToBOUNTY, BOUNTY2);\n', 'totalAllocatedToBOUNTY = safeAdd(totalAllocatedToBOUNTY, BOUNTY3);\n', 'totalAllocatedToBOUNTY = safeAdd(totalAllocatedToBOUNTY, BOUNTY4);\n', 'totalAllocatedToBOUNTY = safeAdd(totalAllocatedToBOUNTY, BOUNTY5);\n', '\n', 'remaintokensbounty=safeSub(Bounty,totalAllocatedToBOUNTY);\n', 'balanceOf[ICOSTAKE]=safeAdd(balanceOf[ICOSTAKE],remaintokensbounty);\n', '\n', '\n', '        allocateAdvisorTokens() ;\n', '        allocateCLRSinTeamTokens();\n', '\n', '\n', '        totremains=safeAdd(totremains,remaintokenscompany);\n', '        totremains=safeAdd(totremains,remaintokensbounty);\n', '        totremains=safeAdd(totremains,remaintokensbonus);\n', '        totremains=safeAdd(totremains,remaintokensteam);\n', '        totremains=safeAdd(totremains,remaintokensadvisors);\n', '\n', '\n', '\n', '  burnTokens(totremains);\n', '\n', 'totalAllocated += maxIcoSupply+ totalAllocatedToCompany+ totalAllocatedToBONUS + totalAllocatedToBOUNTY;  // Add to total Allocated funds\n', '    }\n', '\n', '///////////////////////////////////////// ERC20 OVERRIDE /////////////////////////////////////////\n', '\n', '    /**\n', '        @dev send coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '        in addition to the standard checks, the function throws if transfers are disabled\n', '\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', "        @return true if the transfer was successful, throws if it wasn't\n", '    */\n', '    /*function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (isTransferAllowed() == true) {\n', '            assert(super.transfer(_to, _value));\n', '            return true;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    /**\n', '        @dev an account/contract attempts to get the coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '        in addition to the standard checks, the function throws if transfers are disabled\n', '\n', '        @param _from    source address\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', "        @return true if the transfer was successful, throws if it wasn't\n", '    */\n', '   /* function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (isTransferAllowed() == true ) {\n', '            assert(super.transferFrom(_from, _to, _value));\n', '            return true;\n', '        }\n', '\n', '        revert();\n', '    }*/\n', '\n', '\n', '     /**\n', '     * Allow transfer only after finished\n', '     */\n', '        //allows to dissable transfers while minting and in case of emergency\n', '\n', '\n', '\n', '    modifier canTransfer() {\n', '        require( isTransferAllowedteam()==true );\n', '        _;\n', '    }\n', '\n', '   modifier canTransferadv() {\n', '        require( isTransferAllowedadv()==true );\n', '        _;\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) canTransfer canTransferadv public returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) canTransfer canTransferadv public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '///////////////////////////////////////// ALLOCATION FUNCTIONS /////////////////////////////////////////\n', '\n', '\n', '    function allocateCLRSinTeamTokens() public returns(bool success) {\n', '        require(totalAllocatedToTEAM < CLRSinTeamAllocation);\n', '\n', '        balanceOf[TEAM_1] = safeAdd(balanceOf[TEAM_1], TEAM1);       // TEAM1 CLRS tokens\n', '        balanceOf[TEAM_2] = safeAdd(balanceOf[TEAM_2], TEAM2);       // TEAM2 CLRS tokens\n', '        balanceOf[TEAM_3] = safeAdd(balanceOf[TEAM_3], TEAM3);        // TEAM3 CLRS tokens\n', '        balanceOf[TEAM_4] = safeAdd(balanceOf[TEAM_4], TEAM4);        // TEAM4 CLRS tokens\n', '        balanceOf[TEAM_5] = safeAdd(balanceOf[TEAM_5], TEAM5);       // TEAM5 CLRS tokens\n', '       /*Transfer(0x0, TEAM_1, TEAM1);\n', '       Transfer(0x0, TEAM_2, TEAM2);\n', '       Transfer(0x0, TEAM_3, TEAM3);\n', '       Transfer(0x0, TEAM_4, TEAM4);\n', '       Transfer(0x0, TEAM_5, TEAM5);*/\n', '\n', '       totalAllocatedToTEAM = safeAdd(totalAllocatedToTEAM, TEAM1);\n', 'totalAllocatedToTEAM = safeAdd(totalAllocatedToTEAM, TEAM2);\n', 'totalAllocatedToTEAM = safeAdd(totalAllocatedToTEAM, TEAM3);\n', 'totalAllocatedToTEAM = safeAdd(totalAllocatedToTEAM, TEAM4);\n', 'totalAllocatedToTEAM = safeAdd(totalAllocatedToTEAM, TEAM5);\n', '\n', 'totalAllocated +=  totalAllocatedToTEAM;\n', '\n', '\n', ' remaintokensteam=safeSub(CLRSinTeamAllocation,totalAllocatedToTEAM);\n', '\n', 'balanceOf[ICOSTAKE]=safeAdd(balanceOf[ICOSTAKE],remaintokensteam);\n', '\n', '            return true;\n', '\n', '\n', '    }\n', '\n', '\n', '    function allocateAdvisorTokens() public returns(bool success) {\n', '        require(totalAllocatedToAdvisor < advisorsAllocation);\n', '\n', '        balanceOf[ADVISOR_1] = safeAdd(balanceOf[ADVISOR_1], ADVISOR1);\n', '        balanceOf[ADVISOR_2] = safeAdd(balanceOf[ADVISOR_2], ADVISOR2);\n', '        balanceOf[ADVISOR_3] = safeAdd(balanceOf[ADVISOR_3], ADVISOR3);\n', '        balanceOf[ADVISOR_4] = safeAdd(balanceOf[ADVISOR_4], ADVISOR4);\n', '        balanceOf[ADVISOR_5] = safeAdd(balanceOf[ADVISOR_5], ADVISOR5);\n', '       /*Transfer(0x0, ADVISOR_1, ADVISOR1);\n', '       Transfer(0x0, ADVISOR_2, ADVISOR2);\n', '       Transfer(0x0, ADVISOR_3, ADVISOR3);\n', '       Transfer(0x0, ADVISOR_4, ADVISOR4);\n', '       Transfer(0x0, ADVISOR_5, ADVISOR5);*/\n', '\n', '       totalAllocatedToAdvisor = safeAdd(totalAllocatedToAdvisor, ADVISOR1);\n', 'totalAllocatedToAdvisor = safeAdd(totalAllocatedToAdvisor, ADVISOR2);\n', 'totalAllocatedToAdvisor = safeAdd(totalAllocatedToAdvisor, ADVISOR3);\n', 'totalAllocatedToAdvisor = safeAdd(totalAllocatedToAdvisor, ADVISOR4);\n', 'totalAllocatedToAdvisor = safeAdd(totalAllocatedToAdvisor, ADVISOR5);\n', '\n', 'totalAllocated +=  totalAllocatedToAdvisor;\n', '\n', '\n', 'remaintokensadvisors=safeSub(advisorsAllocation,totalAllocatedToAdvisor);\n', '\n', 'balanceOf[ICOSTAKE]=safeAdd(balanceOf[ICOSTAKE],remaintokensadvisors);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function releaseAdvisorTokens() ownerOnly {\n', '\n', '         isReleasedToadv = true;\n', '\n', '\n', '    }\n', '\n', '     function releaseCLRSinTeamTokens() ownerOnly  {\n', '\n', '         isReleasedToteam = true;\n', '\n', '\n', '\n', '\n', '\n', '    }\n', '\n', '\n', '\n', '    function burnTokens(uint256 _value) ownerOnly returns(bool success) {\n', '        uint256 amountOfTokens = _value;\n', '\n', '        balanceOf[msg.sender]=safeSub(balanceOf[msg.sender], amountOfTokens);\n', '        totalSupply=safeSub(totalSupply, amountOfTokens);\n', '        Transfer(msg.sender, 0x0, amountOfTokens);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    /**\n', '        @dev Function to allow transfers\n', '        can only be called by the owner of the contract\n', '        Transfers will be allowed regardless after the crowdfund end time.\n', '    */\n', '    function allowTransfers() ownerOnly {\n', '        isReleasedToPublic = true;\n', '\n', '    }\n', '\n', '    function starttime() ownerOnly {\n', 'endTime =  now;\n', '\t}\n', '\n', '\n', '    /**\n', '        @dev User transfers are allowed/rejected\n', '        Transfers are forbidden before the end of the crowdfund\n', '    */\n', '    function isTransferAllowedteam() public returns(bool)\n', '    {\n', '\n', '        if (isReleasedToteam==true)\n', '        return true;\n', '\n', '        if(now < endTime + 52 weeks)\n', '\n', '{\n', 'if(msg.sender==TEAM_1 || msg.sender==TEAM_2 || msg.sender==TEAM_3 || msg.sender==TEAM_4 || msg.sender==TEAM_5)\n', '\n', 'return false;\n', '\n', '\n', '}\n', '\n', '\n', 'return true;\n', '    }\n', '\n', '\n', ' function isTransferAllowedadv() public returns(bool)\n', '    {\n', '        if (isReleasedToadv==true)\n', '        return true;\n', '\n', '\n', '\n', '\n', '        if(now < endTime + 26 weeks)\n', '\n', '{\n', 'if(msg.sender==ADVISOR_1 || msg.sender==ADVISOR_2 || msg.sender==ADVISOR_3 || msg.sender==ADVISOR_4 || msg.sender==ADVISOR_5)\n', '\n', 'return false;\n', '\n', '\n', '}\n', '\n', 'return true;\n', '    }\n', '\n', '\n', '\n', '\n', '}']