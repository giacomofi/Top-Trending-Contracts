['pragma solidity 0.5.7;\n', 'contract DCN {\n', '  event UserCreated(address indexed creator, uint64 user_id);\n', '  event UserTradeAddressUpdated(uint64 user_id);\n', '  event SessionUpdated(uint64 user_id, uint64 exchange_id);\n', '  event ExchangeDeposit(uint64 user_id, uint64 exchange_id, uint32 asset_id);\n', '  uint256 creator;\n', '  uint256 creator_recovery;\n', '  uint256 creator_recovery_proposed;\n', '  uint256 user_count;\n', '  uint256 exchange_count;\n', '  uint256 asset_count;\n', '  uint256 security_locked_features;\n', '  uint256 security_locked_features_proposed;\n', '  uint256 security_proposed_unlock_timestamp;\n', '  struct Exchange {\n', '    uint88 name;\n', '    uint8 locked;\n', '    address owner;\n', '    uint256 withdraw_address;\n', '    uint256 recovery_address;\n', '    uint256 recovery_address_proposed;\n', '    uint256[4294967296] balances;\n', '  }\n', '  struct Asset {\n', '    uint64 symbol;\n', '    uint192 unit_scale;\n', '    uint256 contract_address;\n', '  }\n', '  struct MarketState {\n', '    int64 quote_qty;\n', '    int64 base_qty;\n', '    uint64 fee_used;\n', '    uint64 fee_limit;\n', '    int64 min_quote_qty;\n', '    int64 min_base_qty;\n', '    uint64 long_max_price;\n', '    uint64 short_min_price;\n', '    uint64 limit_version;\n', '    int96 quote_shift;\n', '    int96 base_shift;\n', '  }\n', '  struct SessionBalance {\n', '    uint128 total_deposit;\n', '    uint64 unsettled_withdraw_total;\n', '    uint64 asset_balance;\n', '  }\n', '  struct ExchangeSession {\n', '    uint256 unlock_at;\n', '    uint256 trade_address;\n', '    SessionBalance[4294967296] balances;\n', '    MarketState[18446744073709551616] market_states;\n', '  }\n', '  struct User {\n', '    uint256 trade_address;\n', '    uint256 withdraw_address;\n', '    uint256 recovery_address;\n', '    uint256 recovery_address_proposed;\n', '    uint256[4294967296] balances;\n', '    ExchangeSession[4294967296] exchange_sessions;\n', '  }\n', '  User[18446744073709551616] users;\n', '  Asset[4294967296] assets;\n', '  Exchange[4294967296] exchanges;\n', '  \n', '  constructor() public  {\n', '    assembly {\n', '      sstore(creator_slot, caller)\n', '      sstore(creator_recovery_slot, caller)\n', '    }\n', '  }\n', '  \n', '  function get_security_state() public view \n', '  returns (uint256 locked_features, uint256 locked_features_proposed, uint256 proposed_unlock_timestamp) {\n', '    \n', '    uint256[3] memory return_value_mem;\n', '    assembly {\n', '      mstore(return_value_mem, sload(security_locked_features_slot))\n', '      mstore(add(return_value_mem, 32), sload(security_locked_features_proposed_slot))\n', '      mstore(add(return_value_mem, 64), sload(security_proposed_unlock_timestamp_slot))\n', '      return(return_value_mem, 96)\n', '    }\n', '  }\n', '  \n', '  function get_creator() public view \n', '  returns (address dcn_creator, address dcn_creator_recovery, address dcn_creator_recovery_proposed) {\n', '    \n', '    uint256[3] memory return_value_mem;\n', '    assembly {\n', '      mstore(return_value_mem, sload(creator_slot))\n', '      mstore(add(return_value_mem, 32), sload(creator_recovery_slot))\n', '      mstore(add(return_value_mem, 64), sload(creator_recovery_proposed_slot))\n', '      return(return_value_mem, 96)\n', '    }\n', '  }\n', '  \n', '  function get_asset(uint32 asset_id) public view \n', '  returns (string memory symbol, uint192 unit_scale, address contract_address) {\n', '    \n', '    uint256[5] memory return_value_mem;\n', '    assembly {\n', '      let asset_count := sload(asset_count_slot)\n', '      if iszero(lt(asset_id, asset_count)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let asset_0 := sload(asset_ptr)\n', '      let asset_1 := sload(add(asset_ptr, 1))\n', '      mstore(return_value_mem, 96)\n', '      mstore(add(return_value_mem, 96), 8)\n', '      mstore(add(return_value_mem, 128), asset_0)\n', '      mstore(add(return_value_mem, 32), and(asset_0, 0xffffffffffffffffffffffffffffffffffffffffffffffff))\n', '      mstore(add(return_value_mem, 64), asset_1)\n', '      return(return_value_mem, 136)\n', '    }\n', '  }\n', '  \n', '  function get_exchange(uint32 exchange_id) public view \n', '  returns (\n', '    string memory name, bool locked, address owner,\n', '    address withdraw_address, address recovery_address, address recovery_address_proposed\n', '  ) {\n', '    \n', '    uint256[8] memory return_value_mem;\n', '    assembly {\n', '      let exchange_count := sload(exchange_count_slot)\n', '      if iszero(lt(exchange_id, exchange_count)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_0 := sload(exchange_ptr)\n', '      let exchange_1 := sload(add(exchange_ptr, 1))\n', '      let exchange_2 := sload(add(exchange_ptr, 2))\n', '      let exchange_3 := sload(add(exchange_ptr, 3))\n', '      mstore(return_value_mem, 192)\n', '      mstore(add(return_value_mem, 192), 11)\n', '      mstore(add(return_value_mem, 224), exchange_0)\n', '      mstore(add(return_value_mem, 32), and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff))\n', '      mstore(add(return_value_mem, 64), and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff))\n', '      mstore(add(return_value_mem, 96), exchange_1)\n', '      mstore(add(return_value_mem, 128), exchange_2)\n', '      mstore(add(return_value_mem, 160), exchange_3)\n', '      return(return_value_mem, 236)\n', '    }\n', '  }\n', '  \n', '  function get_exchange_balance(uint32 exchange_id, uint32 asset_id) public view \n', '  returns (uint256 exchange_balance) {\n', '    \n', '    uint256[1] memory return_value_mem;\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_balance_ptr := add(add(exchange_ptr, 4), asset_id)\n', '      mstore(return_value_mem, sload(exchange_balance_ptr))\n', '      return(return_value_mem, 32)\n', '    }\n', '  }\n', '  \n', '  function get_exchange_count() public view \n', '  returns (uint32 count) {\n', '    \n', '    uint256[1] memory return_value_mem;\n', '    assembly {\n', '      mstore(return_value_mem, sload(exchange_count_slot))\n', '      return(return_value_mem, 32)\n', '    }\n', '  }\n', '  \n', '  function get_asset_count() public view \n', '  returns (uint32 count) {\n', '    \n', '    uint256[1] memory return_value_mem;\n', '    assembly {\n', '      mstore(return_value_mem, sload(asset_count_slot))\n', '      return(return_value_mem, 32)\n', '    }\n', '  }\n', '  \n', '  function get_user_count() public view \n', '  returns (uint32 count) {\n', '    \n', '    uint256[1] memory return_value_mem;\n', '    assembly {\n', '      mstore(return_value_mem, sload(user_count_slot))\n', '      return(return_value_mem, 32)\n', '    }\n', '  }\n', '  \n', '  function get_user(uint64 user_id) public view \n', '  returns (\n', '    address trade_address,\n', '    address withdraw_address, address recovery_address, address recovery_address_proposed\n', '  ) {\n', '    \n', '    uint256[4] memory return_value_mem;\n', '    assembly {\n', '      let user_count := sload(user_count_slot)\n', '      if iszero(lt(user_id, user_count)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      mstore(return_value_mem, sload(add(user_ptr, 0)))\n', '      mstore(add(return_value_mem, 32), sload(add(user_ptr, 1)))\n', '      mstore(add(return_value_mem, 64), sload(add(user_ptr, 2)))\n', '      mstore(add(return_value_mem, 96), sload(add(user_ptr, 3)))\n', '      return(return_value_mem, 128)\n', '    }\n', '  }\n', '  \n', '  function get_balance(uint64 user_id, uint32 asset_id) public view \n', '  returns (uint256 return_balance) {\n', '    \n', '    uint256[1] memory return_value_mem;\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\n', '      mstore(return_value_mem, sload(user_balance_ptr))\n', '      return(return_value_mem, 32)\n', '    }\n', '  }\n', '  \n', '  function get_session(uint64 user_id, uint32 exchange_id) public view \n', '  returns (uint256 unlock_at, address trade_address) {\n', '    \n', '    uint256[2] memory return_value_mem;\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      mstore(return_value_mem, sload(add(session_ptr, 0)))\n', '      mstore(add(return_value_mem, 32), sload(add(session_ptr, 1)))\n', '      return(return_value_mem, 64)\n', '    }\n', '  }\n', '  \n', '  function get_session_balance(uint64 user_id, uint32 exchange_id, uint32 asset_id) public view \n', '  returns (uint128 total_deposit, uint64 unsettled_withdraw_total, uint64 asset_balance) {\n', '    \n', '    uint256[3] memory return_value_mem;\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      let session_balance_ptr := add(add(session_ptr, 2), asset_id)\n', '      let session_balance_0 := sload(session_balance_ptr)\n', '      mstore(return_value_mem, and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff))\n', '      mstore(add(return_value_mem, 32), and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff))\n', '      mstore(add(return_value_mem, 64), and(session_balance_0, 0xffffffffffffffff))\n', '      return(return_value_mem, 96)\n', '    }\n', '  }\n', '  \n', '  function get_market_state(\n', '    uint64 user_id, uint32 exchange_id,\n', '    uint32 quote_asset_id, uint32 base_asset_id\n', '  ) public view \n', '  returns (\n', '    int64 quote_qty, int64 base_qty, uint64 fee_used, uint64 fee_limit,\n', '    int64 min_quote_qty, int64 min_base_qty, uint64 long_max_price, uint64 short_min_price,\n', '    uint64 limit_version, int96 quote_shift, int96 base_shift\n', '  ) {\n', '    \n', '    uint256[11] memory return_value_mem;\n', '    assembly {\n', '      base_shift := base_asset_id\n', '      quote_shift := quote_asset_id\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let exchange_session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      let exchange_state_ptr := add(add(exchange_session_ptr, 4294967298), mul(3, or(mul(quote_shift, 4294967296), base_shift)))\n', '      let state_data_0 := sload(exchange_state_ptr)\n', '      let state_data_1 := sload(add(exchange_state_ptr, 1))\n', '      let state_data_2 := sload(add(exchange_state_ptr, 2))\n', '      {\n', '        let tmp := and(div(state_data_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '        tmp := signextend(7, tmp)\n', '        mstore(add(return_value_mem, 0), tmp)\n', '      }\n', '      {\n', '        let tmp := and(div(state_data_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '        tmp := signextend(7, tmp)\n', '        mstore(add(return_value_mem, 32), tmp)\n', '      }\n', '      mstore(add(return_value_mem, 64), and(div(state_data_0, 0x10000000000000000), 0xffffffffffffffff))\n', '      mstore(add(return_value_mem, 96), and(state_data_0, 0xffffffffffffffff))\n', '      {\n', '        let tmp := and(div(state_data_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '        tmp := signextend(7, tmp)\n', '        mstore(add(return_value_mem, 128), tmp)\n', '      }\n', '      {\n', '        let tmp := and(div(state_data_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '        tmp := signextend(7, tmp)\n', '        mstore(add(return_value_mem, 160), tmp)\n', '      }\n', '      mstore(add(return_value_mem, 192), and(div(state_data_1, 0x10000000000000000), 0xffffffffffffffff))\n', '      mstore(add(return_value_mem, 224), and(state_data_1, 0xffffffffffffffff))\n', '      mstore(add(return_value_mem, 256), and(div(state_data_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff))\n', '      {\n', '        let tmp := and(div(state_data_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\n', '        tmp := signextend(11, tmp)\n', '        mstore(add(return_value_mem, 288), tmp)\n', '      }\n', '      {\n', '        let tmp := and(state_data_2, 0xffffffffffffffffffffffff)\n', '        tmp := signextend(11, tmp)\n', '        mstore(add(return_value_mem, 320), tmp)\n', '      }\n', '      return(return_value_mem, 352)\n', '    }\n', '  }\n', '  \n', '  function security_lock(uint256 lock_features) public  {\n', '    assembly {\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let locked_features := sload(security_locked_features_slot)\n', '      sstore(security_locked_features_slot, or(locked_features, lock_features))\n', '      sstore(security_locked_features_proposed_slot, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '    }\n', '  }\n', '  \n', '  function security_propose(uint256 proposed_locked_features) public  {\n', '    assembly {\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let current_proposal := sload(security_locked_features_proposed_slot)\n', '      let proposed_differences := xor(current_proposal, proposed_locked_features)\n', '      let does_unlocks_features := and(proposed_differences, not(proposed_locked_features))\n', '      if does_unlocks_features {\n', '        sstore(security_proposed_unlock_timestamp_slot, add(timestamp, 172800))\n', '      }\n', '      sstore(security_locked_features_proposed_slot, proposed_locked_features)\n', '    }\n', '  }\n', '  \n', '  function security_set_proposed() public  {\n', '    assembly {\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let unlock_timestamp := sload(security_proposed_unlock_timestamp_slot)\n', '      if gt(unlock_timestamp, timestamp) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      sstore(security_locked_features_slot, sload(security_locked_features_proposed_slot))\n', '    }\n', '  }\n', '  \n', '  function creator_update(address new_creator) public  {\n', '    assembly {\n', '      let creator_recovery := sload(creator_recovery_slot)\n', '      if iszero(eq(caller, creator_recovery)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(creator_slot, new_creator)\n', '    }\n', '  }\n', '  \n', '  function creator_propose_recovery(address recovery) public  {\n', '    assembly {\n', '      let creator_recovery := sload(creator_recovery_slot)\n', '      if iszero(eq(caller, creator_recovery)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(creator_recovery_proposed_slot, recovery)\n', '    }\n', '  }\n', '  \n', '  function creator_set_recovery() public  {\n', '    assembly {\n', '      let creator_recovery_proposed := sload(creator_recovery_proposed_slot)\n', '      if or(iszero(eq(caller, creator_recovery_proposed)), iszero(caller)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(creator_recovery_slot, caller)\n', '      sstore(creator_recovery_proposed_slot, 0)\n', '    }\n', '  }\n', '  \n', '  function set_exchange_locked(uint32 exchange_id, bool locked) public  {\n', '    assembly {\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_0 := sload(exchange_ptr)\n', '      sstore(exchange_ptr, or(and(0xffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff, exchange_0), \n', '        /* locked */ mul(locked, 0x10000000000000000000000000000000000000000)))\n', '    }\n', '  }\n', '  \n', '  function user_create() public \n', '  returns (uint64 user_id) {\n', '    \n', '    uint256[2] memory log_data_mem;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x4) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      user_id := sload(user_count_slot)\n', '      if iszero(lt(user_id, 18446744073709551616)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(user_count_slot, add(user_id, 1))\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      sstore(add(user_ptr, 0), caller)\n', '      sstore(add(user_ptr, 1), caller)\n', '      sstore(add(user_ptr, 2), caller)\n', '      \n', '      /* Log event: UserCreated */\n', '      mstore(log_data_mem, user_id)\n', '      log2(log_data_mem, 32, /* UserCreated */ 0x49d7af0c8ce0d26f4490c17a316a59a7a5d28599a2208862554b648ebdf193f4, caller)\n', '    }\n', '  }\n', '  \n', '  function user_set_trade_address(uint64 user_id, address trade_address) public  {\n', '    \n', '    uint256[1] memory log_data_mem;\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let recovery_address := sload(add(user_ptr, 2))\n', '      if iszero(eq(caller, recovery_address)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(user_ptr, 0), trade_address)\n', '      \n', '      /* Log event: UserTradeAddressUpdated */\n', '      mstore(log_data_mem, user_id)\n', '      log1(log_data_mem, 32, /* UserTradeAddressUpdated */ 0x0dcac7e45506b3812319ae528c780b9035570ee3b3557272431dce5b397d880a)\n', '    }\n', '  }\n', '  \n', '  function user_set_withdraw_address(uint64 user_id, address withdraw_address) public  {\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let recovery_address := sload(add(user_ptr, 2))\n', '      if iszero(eq(caller, recovery_address)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(user_ptr, 1), withdraw_address)\n', '    }\n', '  }\n', '  \n', '  function user_propose_recovery_address(uint64 user_id, address proposed) public  {\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let recovery_address := sload(add(user_ptr, 2))\n', '      if iszero(eq(caller, recovery_address)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(user_ptr, 3), proposed)\n', '    }\n', '  }\n', '  \n', '  function user_set_recovery_address(uint64 user_id) public  {\n', '    assembly {\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let proposed_ptr := add(user_ptr, 3)\n', '      let recovery_address_proposed := sload(proposed_ptr)\n', '      if iszero(eq(caller, recovery_address_proposed)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(proposed_ptr, 0)\n', '      sstore(add(user_ptr, 2), recovery_address_proposed)\n', '    }\n', '  }\n', '  \n', '  function exchange_set_owner(uint32 exchange_id, address new_owner) public  {\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_recovery := sload(add(exchange_ptr, 2))\n', '      if iszero(eq(caller, exchange_recovery)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_0 := sload(exchange_ptr)\n', '      sstore(exchange_ptr, or(and(exchange_0, 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), \n', '        /* owner */ new_owner))\n', '    }\n', '  }\n', '  \n', '  function exchange_set_withdraw(uint32 exchange_id, address new_withdraw) public  {\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_recovery := sload(add(exchange_ptr, 2))\n', '      if iszero(eq(caller, exchange_recovery)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(exchange_ptr, 1), new_withdraw)\n', '    }\n', '  }\n', '  \n', '  function exchange_propose_recovery(uint32 exchange_id, address proposed) public  {\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_recovery := sload(add(exchange_ptr, 2))\n', '      if iszero(eq(caller, exchange_recovery)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(exchange_ptr, 3), proposed)\n', '    }\n', '  }\n', '  \n', '  function exchange_set_recovery(uint32 exchange_id) public  {\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let exchange_recovery_proposed := sload(add(exchange_ptr, 3))\n', '      if or(iszero(eq(caller, exchange_recovery_proposed)), iszero(caller)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      sstore(add(exchange_ptr, 2), caller)\n', '    }\n', '  }\n', '  \n', '  function add_asset(string memory symbol, uint192 unit_scale, address contract_address) public \n', '  returns (uint64 asset_id) {\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x1) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      asset_id := sload(asset_count_slot)\n', '      if iszero(lt(asset_id, 4294967296)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      let symbol_len := mload(symbol)\n', '      if iszero(eq(symbol_len, 8)) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      if iszero(unit_scale) {\n', '        mstore(32, 4)\n', '        revert(63, 1)\n', '      }\n', '      if iszero(contract_address) {\n', '        mstore(32, 5)\n', '        revert(63, 1)\n', '      }\n', '      let asset_symbol := mload(add(symbol, 32))\n', '      let asset_data_0 := or(asset_symbol, \n', '        /* unit_scale */ unit_scale)\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      sstore(asset_ptr, asset_data_0)\n', '      sstore(add(asset_ptr, 1), contract_address)\n', '      sstore(asset_count_slot, add(asset_id, 1))\n', '    }\n', '  }\n', '  \n', '  function add_exchange(string memory name, address addr) public \n', '  returns (uint64 exchange_id) {\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x2) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let creator := sload(creator_slot)\n', '        if iszero(eq(caller, creator)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let name_len := mload(name)\n', '      if iszero(eq(name_len, 11)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      exchange_id := sload(exchange_count_slot)\n', '      if iszero(lt(exchange_id, 4294967296)) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let name_data := mload(add(name, 32))\n', '      let exchange_0 := or(name_data, \n', '        /* owner */ addr)\n', '      sstore(exchange_ptr, exchange_0)\n', '      sstore(add(exchange_ptr, 1), addr)\n', '      sstore(add(exchange_ptr, 2), addr)\n', '      sstore(exchange_count_slot, add(exchange_id, 1))\n', '    }\n', '  }\n', '  \n', '  function exchange_withdraw(uint32 exchange_id, uint32 asset_id,\n', '                             address destination, uint64 quantity) public  {\n', '    \n', '    uint256[3] memory transfer_in_mem;\n', '    \n', '    uint256[1] memory transfer_out_mem;\n', '    assembly {\n', '      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '      let withdraw_address := sload(add(exchange_ptr, 1))\n', '      if iszero(eq(caller, withdraw_address)) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_balance_ptr := add(add(exchange_ptr, 4), asset_id)\n', '      let exchange_balance := sload(exchange_balance_ptr)\n', '      if gt(quantity, exchange_balance) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      sstore(exchange_balance_ptr, sub(exchange_balance, quantity))\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '      let asset_address := sload(add(asset_ptr, 1))\n', '      let withdraw := mul(quantity, unit_scale)\n', '      mstore(transfer_in_mem, /* fn_hash("transfer(address,uint256)") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n', '      mstore(add(transfer_in_mem, 4), destination)\n', '      mstore(add(transfer_in_mem, 36), withdraw)\n', '      {\n', '        let success := call(gas, asset_address, 0, transfer_in_mem, 68, transfer_out_mem, 32)\n', '        if iszero(success) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '        switch returndatasize\n', '          case 0 {}\n', '          case 32 {\n', '            let result := mload(transfer_out_mem)\n', '            if iszero(result) {\n', '              mstore(32, 4)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          default {\n', '            mstore(32, 4)\n', '            revert(63, 1)\n', '          }\n', '      }\n', '    }\n', '  }\n', '  \n', '  function exchange_deposit(uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\n', '    \n', '    uint256[3] memory transfer_in_mem;\n', '    \n', '    uint256[1] memory transfer_out_mem;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x8) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\n', '      let exchange_balance := sload(exchange_balance_ptr)\n', '      let updated_balance := add(exchange_balance, quantity)\n', '      if gt(updated_balance, 0xFFFFFFFFFFFFFFFF) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '      let asset_address := sload(add(asset_ptr, 1))\n', '      let deposit := mul(quantity, unit_scale)\n', '      sstore(exchange_balance_ptr, updated_balance)\n', '      mstore(transfer_in_mem, /* fn_hash("transferFrom(address,address,uint256)") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n', '      mstore(add(transfer_in_mem, 4), caller)\n', '      mstore(add(transfer_in_mem, 36), address)\n', '      mstore(add(transfer_in_mem, 68), deposit)\n', '      {\n', '        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\n', '        if iszero(success) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '        switch returndatasize\n', '          case 0 {}\n', '          case 32 {\n', '            let result := mload(transfer_out_mem)\n', '            if iszero(result) {\n', '              mstore(32, 5)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          default {\n', '            mstore(32, 5)\n', '            revert(63, 1)\n', '          }\n', '      }\n', '    }\n', '  }\n', '  \n', '  function user_deposit(uint64 user_id, uint32 asset_id, uint256 amount) public  {\n', '    \n', '    uint256[4] memory transfer_in_mem;\n', '    \n', '    uint256[1] memory transfer_out_mem;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x10) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let user_count := sload(user_count_slot)\n', '        if iszero(lt(user_id, user_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      if iszero(amount) {\n', '        stop()\n', '      }\n', '      let balance_ptr := add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4), asset_id)\n', '      let current_balance := sload(balance_ptr)\n', '      let proposed_balance := add(current_balance, amount)\n', '      if lt(proposed_balance, current_balance) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      let asset_address := sload(add(add(assets_slot, mul(2, asset_id)), 1))\n', '      sstore(balance_ptr, proposed_balance)\n', '      mstore(transfer_in_mem, /* fn_hash("transferFrom(address,address,uint256)") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n', '      mstore(add(transfer_in_mem, 4), caller)\n', '      mstore(add(transfer_in_mem, 36), address)\n', '      mstore(add(transfer_in_mem, 68), amount)\n', '      {\n', '        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\n', '        if iszero(success) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '        switch returndatasize\n', '          case 0 {}\n', '          case 32 {\n', '            let result := mload(transfer_out_mem)\n', '            if iszero(result) {\n', '              mstore(32, 5)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          default {\n', '            mstore(32, 5)\n', '            revert(63, 1)\n', '          }\n', '      }\n', '    }\n', '  }\n', '  \n', '  function user_withdraw(uint64 user_id, uint32 asset_id, address destination, uint256 amount) public  {\n', '    \n', '    uint256[3] memory transfer_in_mem;\n', '    \n', '    uint256[1] memory transfer_out_mem;\n', '    assembly {\n', '      if iszero(amount) {\n', '        stop()\n', '      }\n', '      {\n', '        let user_count := sload(user_count_slot)\n', '        if iszero(lt(user_id, user_count)) {\n', '          mstore(32, 6)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let withdraw_address := sload(add(user_ptr, 1))\n', '      if iszero(eq(caller, withdraw_address)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      let balance_ptr := add(add(user_ptr, 4), asset_id)\n', '      let current_balance := sload(balance_ptr)\n', '      if lt(current_balance, amount) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      sstore(balance_ptr, sub(current_balance, amount))\n', '      let asset_address := sload(add(add(assets_slot, mul(2, asset_id)), 1))\n', '      mstore(transfer_in_mem, /* fn_hash("transfer(address,uint256)") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n', '      mstore(add(transfer_in_mem, 4), destination)\n', '      mstore(add(transfer_in_mem, 36), amount)\n', '      {\n', '        let success := call(gas, asset_address, 0, transfer_in_mem, 68, transfer_out_mem, 32)\n', '        if iszero(success) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '        switch returndatasize\n', '          case 0 {}\n', '          case 32 {\n', '            let result := mload(transfer_out_mem)\n', '            if iszero(result) {\n', '              mstore(32, 5)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          default {\n', '            mstore(32, 5)\n', '            revert(63, 1)\n', '          }\n', '      }\n', '    }\n', '  }\n', '  \n', '  function user_session_set_unlock_at(uint64 user_id, uint32 exchange_id, uint256 unlock_at) public  {\n', '    \n', '    uint256[3] memory log_data_mem;\n', '    assembly {\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let trade_address := sload(add(user_ptr, 0))\n', '      if iszero(eq(caller, trade_address)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      {\n', '        let fails_min_time := lt(unlock_at, add(timestamp, 28800))\n', '        let fails_max_time := gt(unlock_at, add(timestamp, 1209600))\n', '        if or(fails_min_time, fails_max_time) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      let unlock_at_ptr := add(session_ptr, 0)\n', '      if lt(sload(unlock_at_ptr), timestamp) {\n', '        sstore(add(session_ptr, 1), caller)\n', '      }\n', '      sstore(unlock_at_ptr, unlock_at)\n', '      \n', '      /* Log event: SessionUpdated */\n', '      mstore(log_data_mem, user_id)\n', '      mstore(add(log_data_mem, 32), exchange_id)\n', '      log1(log_data_mem, 64, /* SessionUpdated */ 0x1b0c381a98d9352dd527280acefa9a69d2c111b6a9d3aa3063aac6c2ec7f3163)\n', '    }\n', '  }\n', '  \n', '  function user_market_reset(uint64 user_id, uint32 exchange_id,\n', '                             uint32 quote_asset_id, uint32 base_asset_id) public  {\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x400) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      let trade_address := sload(add(user_ptr, 0))\n', '      if iszero(eq(caller, trade_address)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      let unlock_at := sload(add(session_ptr, 0))\n', '      if gt(unlock_at, timestamp) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(quote_asset_id, 4294967296), base_asset_id)))\n', '      sstore(market_state_ptr, 0)\n', '      sstore(add(market_state_ptr, 1), 0)\n', '      let market_state_2_ptr := add(market_state_ptr, 2)\n', '      let market_state_2 := sload(market_state_2_ptr)\n', '      let limit_version := add(and(div(market_state_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff), 1)\n', '      sstore(market_state_2_ptr, \n', '        /* limit_version */ mul(limit_version, 0x1000000000000000000000000000000000000000000000000))\n', '    }\n', '  }\n', '  \n', '  function transfer_to_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\n', '    \n', '    uint256[4] memory log_data_mem;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x20) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      if iszero(quantity) {\n', '        stop()\n', '      }\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '      let scaled_quantity := mul(quantity, unit_scale)\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      {\n', '        let withdraw_address := sload(add(user_ptr, 1))\n', '        if iszero(eq(caller, withdraw_address)) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\n', '      let user_balance := sload(user_balance_ptr)\n', '      if lt(user_balance, scaled_quantity) {\n', '        mstore(32, 4)\n', '        revert(63, 1)\n', '      }\n', '      let session_balance_ptr := add(add(add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\n', '      let session_balance_0 := sload(session_balance_ptr)\n', '      let updated_exchange_balance := add(and(session_balance_0, 0xffffffffffffffff), quantity)\n', '      if gt(updated_exchange_balance, 0xFFFFFFFFFFFFFFFF) {\n', '        mstore(32, 5)\n', '        revert(63, 1)\n', '      }\n', '      let updated_total_deposit := add(and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff), quantity)\n', '      sstore(user_balance_ptr, sub(user_balance, scaled_quantity))\n', '      sstore(session_balance_ptr, or(and(0xffffffffffffffff0000000000000000, session_balance_0), or(\n', '        /* total_deposit */ mul(updated_total_deposit, 0x100000000000000000000000000000000), \n', '        /* asset_balance */ updated_exchange_balance)))\n', '      \n', '      /* Log event: ExchangeDeposit */\n', '      mstore(log_data_mem, user_id)\n', '      mstore(add(log_data_mem, 32), exchange_id)\n', '      mstore(add(log_data_mem, 64), asset_id)\n', '      log1(log_data_mem, 96, /* ExchangeDeposit */ 0x7a2923ebfa019dc20de0ae2be0c8639b07e068b143e98ed7f7a74dc4d4f5ab45)\n', '    }\n', '  }\n', '  \n', '  function transfer_from_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\n', '    \n', '    uint256[4] memory log_data_mem;\n', '    assembly {\n', '      if iszero(quantity) {\n', '        stop()\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\n', '      {\n', '        let trade_address := sload(add(user_ptr, 0))\n', '        if iszero(eq(caller, trade_address)) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '      {\n', '        let session_0 := sload(session_ptr)\n', '        let unlock_at := session_0\n', '        if gt(unlock_at, timestamp) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let session_balance_ptr := add(add(session_ptr, 2), asset_id)\n', '      let session_balance_0 := sload(session_balance_ptr)\n', '      let session_balance := and(session_balance_0, 0xffffffffffffffff)\n', '      if gt(quantity, session_balance) {\n', '        mstore(32, 5)\n', '        revert(63, 1)\n', '      }\n', '      let updated_exchange_balance := sub(session_balance, quantity)\n', '      let unsettled_withdraw_total := and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff)\n', '      if lt(updated_exchange_balance, unsettled_withdraw_total) {\n', '        mstore(32, 6)\n', '        revert(63, 1)\n', '      }\n', '      sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, session_balance_0), \n', '        /* asset_balance */ updated_exchange_balance))\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '      let scaled_quantity := mul(quantity, unit_scale)\n', '      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\n', '      let user_balance := sload(user_balance_ptr)\n', '      let updated_user_balance := add(user_balance, scaled_quantity)\n', '      if lt(updated_user_balance, user_balance) {\n', '        mstore(32, 7)\n', '        revert(63, 1)\n', '      }\n', '      sstore(user_balance_ptr, updated_user_balance)\n', '    }\n', '  }\n', '  \n', '  function user_deposit_to_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\n', '    \n', '    uint256[4] memory transfer_in_mem;\n', '    \n', '    uint256[1] memory transfer_out_mem;\n', '    \n', '    uint256[3] memory log_data_mem;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x40) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let asset_count := sload(asset_count_slot)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      if iszero(quantity) {\n', '        stop()\n', '      }\n', '      let session_balance_ptr := add(add(add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\n', '      let session_balance_0 := sload(session_balance_ptr)\n', '      let updated_exchange_balance := add(and(session_balance_0, 0xffffffffffffffff), quantity)\n', '      if gt(updated_exchange_balance, 0xFFFFFFFFFFFFFFFF) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '      let asset_ptr := add(assets_slot, mul(2, asset_id))\n', '      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '      let asset_address := sload(add(asset_ptr, 1))\n', '      let scaled_quantity := mul(quantity, unit_scale)\n', '      let updated_total_deposit := add(and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff), quantity)\n', '      sstore(session_balance_ptr, or(and(0xffffffffffffffff0000000000000000, session_balance_0), or(\n', '        /* total_deposit */ mul(updated_total_deposit, 0x100000000000000000000000000000000), \n', '        /* asset_balance */ updated_exchange_balance)))\n', '      mstore(transfer_in_mem, /* fn_hash("transferFrom(address,address,uint256)") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n', '      mstore(add(transfer_in_mem, 4), caller)\n', '      mstore(add(transfer_in_mem, 36), address)\n', '      mstore(add(transfer_in_mem, 68), scaled_quantity)\n', '      {\n', '        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\n', '        if iszero(success) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '        switch returndatasize\n', '          case 0 {}\n', '          case 32 {\n', '            let result := mload(transfer_out_mem)\n', '            if iszero(result) {\n', '              mstore(32, 5)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          default {\n', '            mstore(32, 5)\n', '            revert(63, 1)\n', '          }\n', '      }\n', '      \n', '      /* Log event: ExchangeDeposit */\n', '      mstore(log_data_mem, user_id)\n', '      mstore(add(log_data_mem, 32), exchange_id)\n', '      mstore(add(log_data_mem, 64), asset_id)\n', '      log1(log_data_mem, 96, /* ExchangeDeposit */ 0x7a2923ebfa019dc20de0ae2be0c8639b07e068b143e98ed7f7a74dc4d4f5ab45)\n', '    }\n', '  }\n', '  struct UnsettledWithdrawHeader {\n', '    uint32 exchange_id;\n', '    uint32 asset_id;\n', '    uint32 user_count;\n', '  }\n', '  struct UnsettledWithdrawUser {\n', '    uint64 user_id;\n', '  }\n', '  \n', '  function recover_unsettled_withdraws(bytes memory data) public  {\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x800) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let data_len := mload(data)\n', '      let cursor := add(data, 32)\n', '      let cursor_end := add(cursor, data_len)\n', '      for {} lt(cursor, cursor_end) {} {\n', '        let unsettled_withdraw_header_0 := mload(cursor)\n', '        let exchange_id := and(div(unsettled_withdraw_header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '        let asset_id := and(div(unsettled_withdraw_header_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffff)\n', '        let user_count := and(div(unsettled_withdraw_header_0, 0x10000000000000000000000000000000000000000), 0xffffffff)\n', '        let group_end := add(cursor, add(12, mul(user_count, 8)))\n', '        if gt(group_end, cursor_end) {\n', '          mstore(32, 1)\n', '          revert(63, 1)\n', '        }\n', '        let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\n', '        let exchange_balance := sload(exchange_balance_ptr)\n', '        let start_exchange_balance := exchange_balance\n', '        for {} lt(cursor, group_end) {\n', '          cursor := add(cursor, 8)\n', '        } {\n', '          let user_id := and(div(mload(cursor), 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '          let session_balance_ptr := add(add(add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\n', '          let session_balance_0 := sload(session_balance_ptr)\n', '          let asset_balance := and(session_balance_0, 0xffffffffffffffff)\n', '          let unsettled_balance := and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff)\n', '          let to_recover := unsettled_balance\n', '          if gt(to_recover, asset_balance) {\n', '            to_recover := asset_balance\n', '          }\n', '          if to_recover {\n', '            exchange_balance := add(exchange_balance, to_recover)\n', '            asset_balance := sub(asset_balance, to_recover)\n', '            unsettled_balance := sub(unsettled_balance, to_recover)\n', '            if gt(start_exchange_balance, exchange_balance) {\n', '              mstore(32, 2)\n', '              revert(63, 1)\n', '            }\n', '            sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffff00000000000000000000000000000000, session_balance_0), or(\n', '              /* unsettled_withdraw_total */ mul(unsettled_balance, 0x10000000000000000), \n', '              /* asset_balance */ asset_balance)))\n', '          }\n', '        }\n', '        sstore(exchange_balance_ptr, exchange_balance)\n', '      }\n', '    }\n', '  }\n', '  struct ExchangeTransfersHeader {\n', '    uint32 exchange_id;\n', '  }\n', '  struct ExchangeTransferGroup {\n', '    uint32 asset_id;\n', '    uint8 allow_overdraft;\n', '    uint8 transfer_count;\n', '  }\n', '  struct ExchangeTransfer {\n', '    uint64 user_id;\n', '    uint64 quantity;\n', '  }\n', '  \n', '  function exchange_transfer_from(bytes memory data) public  {\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x80) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let data_len := mload(data)\n', '      let cursor := add(data, 32)\n', '      let cursor_end := add(cursor, data_len)\n', '      let header_0 := mload(cursor)\n', '      cursor := add(cursor, 4)\n', '      if gt(cursor, cursor_end) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_id := and(div(header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_data := sload(add(exchanges_slot, mul(4294967300, exchange_id)))\n', '        if iszero(eq(caller, and(exchange_data, 0xffffffffffffffffffffffffffffffffffffffff))) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '        if and(div(exchange_data, 0x10000000000000000000000000000000000000000), 0xff) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let asset_count := sload(asset_count_slot)\n', '      for {} lt(cursor, cursor_end) {} {\n', '        let group_0 := mload(cursor)\n', '        cursor := add(cursor, 6)\n', '        if gt(cursor, cursor_end) {\n', '          mstore(32, 5)\n', '          revert(63, 1)\n', '        }\n', '        let asset_id := and(div(group_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '        if iszero(lt(asset_id, asset_count)) {\n', '          mstore(32, 6)\n', '          revert(63, 1)\n', '        }\n', '        let disallow_overdraft := iszero(and(div(group_0, 0x1000000000000000000000000000000000000000000000000000000), 0xff))\n', '        let cursor_group_end := add(cursor, mul(and(div(group_0, 0x10000000000000000000000000000000000000000000000000000), 0xff), 16))\n', '        if gt(cursor_group_end, cursor_end) {\n', '          mstore(32, 7)\n', '          revert(63, 1)\n', '        }\n', '        let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\n', '        let exchange_balance_remaining := sload(exchange_balance_ptr)\n', '        let unit_scale := and(sload(add(assets_slot, mul(2, asset_id))), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\n', '        for {} lt(cursor, cursor_group_end) {\n', '          cursor := add(cursor, 16)\n', '        } {\n', '          let transfer_0 := mload(cursor)\n', '          let user_ptr := add(users_slot, mul(237684487561239756867226304516, and(div(transfer_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)))\n', '          let quantity := and(div(transfer_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '          let exchange_balance_used := 0\n', '          let session_balance_ptr := add(add(add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\n', '          let session_balance_0 := sload(session_balance_ptr)\n', '          let session_balance := and(session_balance_0, 0xffffffffffffffff)\n', '          let session_balance_updated := sub(session_balance, quantity)\n', '          if gt(session_balance_updated, session_balance) {\n', '            if disallow_overdraft {\n', '              mstore(32, 8)\n', '              revert(63, 1)\n', '            }\n', '            exchange_balance_used := sub(quantity, session_balance)\n', '            session_balance_updated := 0\n', '            if gt(exchange_balance_used, exchange_balance_remaining) {\n', '              mstore(32, 9)\n', '              revert(63, 1)\n', '            }\n', '            exchange_balance_remaining := sub(exchange_balance_remaining, exchange_balance_used)\n', '          }\n', '          let quantity_scaled := mul(quantity, unit_scale)\n', '          let user_balance_ptr := add(add(user_ptr, 4), asset_id)\n', '          let user_balance := sload(user_balance_ptr)\n', '          let updated_user_balance := add(user_balance, quantity_scaled)\n', '          if gt(user_balance, updated_user_balance) {\n', '            mstore(32, 10)\n', '            revert(63, 1)\n', '          }\n', '          let unsettled_withdraw_total_updated := add(and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff), exchange_balance_used)\n', '          if gt(unsettled_withdraw_total_updated, 0xFFFFFFFFFFFFFFFF) {\n', '            mstore(32, 11)\n', '            revert(63, 1)\n', '          }\n', '          sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffff00000000000000000000000000000000, session_balance_0), or(\n', '            /* unsettled_withdraw_total */ mul(unsettled_withdraw_total_updated, 0x10000000000000000), \n', '            /* asset_balance */ session_balance_updated)))\n', '          sstore(user_balance_ptr, updated_user_balance)\n', '        }\n', '        sstore(exchange_balance_ptr, exchange_balance_remaining)\n', '      }\n', '    }\n', '  }\n', '  struct SetLimitsHeader {\n', '    uint32 exchange_id;\n', '  }\n', '  struct Signature {\n', '    uint256 sig_r;\n', '    uint256 sig_s;\n', '    uint8 sig_v;\n', '  }\n', '  struct UpdateLimit {\n', '    uint32 dcn_id;\n', '    uint64 user_id;\n', '    uint32 exchange_id;\n', '    uint32 quote_asset_id;\n', '    uint32 base_asset_id;\n', '    uint64 fee_limit;\n', '    int64 min_quote_qty;\n', '    int64 min_base_qty;\n', '    uint64 long_max_price;\n', '    uint64 short_min_price;\n', '    uint64 limit_version;\n', '    uint96 quote_shift;\n', '    uint96 base_shift;\n', '  }\n', '  struct SetLimitMemory {\n', '    uint256 user_id;\n', '    uint256 exchange_id;\n', '    uint256 quote_asset_id;\n', '    uint256 base_asset_id;\n', '    uint256 limit_version;\n', '    uint256 quote_shift;\n', '    uint256 base_shift;\n', '  }\n', '  \n', '  function exchange_set_limits(bytes memory data) public  {\n', '    \n', '    uint256[14] memory to_hash_mem;\n', '    uint256 cursor;\n', '    uint256 cursor_end;\n', '    uint256 exchange_id;\n', '    \n', '    uint256[224] memory set_limit_memory_space;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x100) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let data_size := mload(data)\n', '      cursor := add(data, 32)\n', '      cursor_end := add(cursor, data_size)\n', '      let set_limits_header_0 := mload(cursor)\n', '      cursor := add(cursor, 4)\n', '      if gt(cursor, cursor_end) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      exchange_id := and(div(set_limits_header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '      let exchange_0 := sload(add(exchanges_slot, mul(4294967300, exchange_id)))\n', '      let exchange_owner := and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff)\n', '      if iszero(eq(caller, exchange_owner)) {\n', '        mstore(32, 2)\n', '        revert(63, 1)\n', '      }\n', '      if and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff) {\n', '        mstore(32, 3)\n', '        revert(63, 1)\n', '      }\n', '    }\n', '    while (true)\n', '    {\n', '        uint256 update_limit_0;\n', '        uint256 update_limit_1;\n', '        uint256 update_limit_2;\n', '        bytes32 limit_hash;\n', '        assembly {\n', '          if eq(cursor, cursor_end) {\n', '            return(0, 0)\n', '          }\n', '          update_limit_0 := mload(cursor)\n', '          update_limit_1 := mload(add(cursor, 32))\n', '          update_limit_2 := mload(add(cursor, 64))\n', '          cursor := add(cursor, 96)\n', '          if gt(cursor, cursor_end) {\n', '            mstore(32, 4)\n', '            revert(63, 1)\n', '          }\n', '          {\n', '            mstore(to_hash_mem, 0xbe6b685e53075dd48bdabc4949b848400d5a7e53705df48e04ace664c3946ad2)\n', '            let temp_var := 0\n', '            temp_var := and(div(update_limit_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '            mstore(add(to_hash_mem, 32), temp_var)\n', '            temp_var := and(div(update_limit_0, 0x10000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '            mstore(add(to_hash_mem, 64), temp_var)\n', '            mstore(add(set_limit_memory_space, 0), temp_var)\n', '            temp_var := and(div(update_limit_0, 0x100000000000000000000000000000000), 0xffffffff)\n', '            mstore(add(to_hash_mem, 96), temp_var)\n', '            temp_var := and(div(update_limit_0, 0x1000000000000000000000000), 0xffffffff)\n', '            mstore(add(to_hash_mem, 128), temp_var)\n', '            mstore(add(set_limit_memory_space, 64), temp_var)\n', '            temp_var := and(div(update_limit_0, 0x10000000000000000), 0xffffffff)\n', '            mstore(add(to_hash_mem, 160), temp_var)\n', '            mstore(add(set_limit_memory_space, 96), temp_var)\n', '            temp_var := and(update_limit_0, 0xffffffffffffffff)\n', '            mstore(add(to_hash_mem, 192), temp_var)\n', '            temp_var := and(div(update_limit_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '            temp_var := signextend(7, temp_var)\n', '            mstore(add(to_hash_mem, 224), temp_var)\n', '            temp_var := and(div(update_limit_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '            temp_var := signextend(7, temp_var)\n', '            mstore(add(to_hash_mem, 256), temp_var)\n', '            temp_var := and(div(update_limit_1, 0x10000000000000000), 0xffffffffffffffff)\n', '            mstore(add(to_hash_mem, 288), temp_var)\n', '            temp_var := and(update_limit_1, 0xffffffffffffffff)\n', '            mstore(add(to_hash_mem, 320), temp_var)\n', '            temp_var := and(div(update_limit_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '            mstore(add(to_hash_mem, 352), temp_var)\n', '            mstore(add(set_limit_memory_space, 128), temp_var)\n', '            temp_var := and(div(update_limit_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\n', '            temp_var := signextend(11, temp_var)\n', '            mstore(add(to_hash_mem, 384), temp_var)\n', '            mstore(add(set_limit_memory_space, 160), temp_var)\n', '            temp_var := and(update_limit_2, 0xffffffffffffffffffffffff)\n', '            temp_var := signextend(11, temp_var)\n', '            mstore(add(to_hash_mem, 416), temp_var)\n', '            mstore(add(set_limit_memory_space, 192), temp_var)\n', '          }\n', '          limit_hash := keccak256(to_hash_mem, 448)\n', '          mstore(to_hash_mem, 0x1901000000000000000000000000000000000000000000000000000000000000)\n', '          mstore(add(to_hash_mem, 2), 0xe3d3073cc59e3a3126c17585a7e516a048e61a9a1c82144af982d1c194b18710)\n', '          mstore(add(to_hash_mem, 34), limit_hash)\n', '          limit_hash := keccak256(to_hash_mem, 66)\n', '        }\n', '        {\n', '          bytes32 sig_r;\n', '          bytes32 sig_s;\n', '          uint8 sig_v;\n', '          assembly {\n', '            sig_r := mload(cursor)\n', '            sig_s := mload(add(cursor, 32))\n', '            sig_v := and(div(mload(add(cursor, 64)), 0x100000000000000000000000000000000000000000000000000000000000000), 0xff)\n', '            cursor := add(cursor, 65)\n', '            if gt(cursor, cursor_end) {\n', '              mstore(32, 5)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          uint256 recovered_address = uint256(ecrecover(\n', '                     limit_hash,\n', '                  sig_v,\n', '                  sig_r,\n', '                  sig_s\n', '        ));\n', '          assembly {\n', '            let user_ptr := add(users_slot, mul(237684487561239756867226304516, mload(add(set_limit_memory_space, 0))))\n', '            let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '            let trade_address := sload(add(session_ptr, 1))\n', '            if iszero(eq(recovered_address, trade_address)) {\n', '              mstore(32, 6)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '        }\n', '        assembly {\n', '          {\n', '            if iszero(eq(mload(add(set_limit_memory_space, 32)), exchange_id)) {\n', '              mstore(32, 7)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          let user_ptr := add(users_slot, mul(237684487561239756867226304516, mload(add(set_limit_memory_space, 0))))\n', '          let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '          let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(mload(add(set_limit_memory_space, 64)), 4294967296), mload(add(set_limit_memory_space, 96)))))\n', '          let market_state_0 := sload(market_state_ptr)\n', '          let market_state_1 := sload(add(market_state_ptr, 1))\n', '          let market_state_2 := sload(add(market_state_ptr, 2))\n', '          {\n', '            let current_limit_version := and(div(market_state_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '            if iszero(gt(mload(add(set_limit_memory_space, 128)), current_limit_version)) {\n', '              mstore(32, 8)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          let quote_qty := and(div(market_state_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '          quote_qty := signextend(7, quote_qty)\n', '          let base_qty := and(div(market_state_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '          base_qty := signextend(7, base_qty)\n', '          {\n', '            let current_shift := and(div(market_state_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\n', '            current_shift := signextend(11, current_shift)\n', '            let new_shift := mload(add(set_limit_memory_space, 160))\n', '            quote_qty := add(quote_qty, sub(new_shift, current_shift))\n', '            if or(slt(quote_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(quote_qty, 0x7FFFFFFFFFFFFFFF)) {\n', '              mstore(32, 9)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          {\n', '            let current_shift := and(market_state_2, 0xffffffffffffffffffffffff)\n', '            current_shift := signextend(11, current_shift)\n', '            let new_shift := mload(add(set_limit_memory_space, 192))\n', '            base_qty := add(base_qty, sub(new_shift, current_shift))\n', '            if or(slt(base_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(base_qty, 0x7FFFFFFFFFFFFFFF)) {\n', '              mstore(32, 10)\n', '              revert(63, 1)\n', '            }\n', '          }\n', '          let new_market_state_0 := or(or(or(\n', '            /* quote_qty */ mul(and(quote_qty, 0xffffffffffffffff), 0x1000000000000000000000000000000000000000000000000), \n', '            /* base_qty */ mul(and(base_qty, 0xffffffffffffffff), 0x100000000000000000000000000000000)), \n', '            /* fee_limit */ and(update_limit_0, 0xffffffffffffffff)), and(0xffffffffffffffff0000000000000000, market_state_0))\n', '          sstore(market_state_ptr, new_market_state_0)\n', '          sstore(add(market_state_ptr, 1), update_limit_1)\n', '          sstore(add(market_state_ptr, 2), update_limit_2)\n', '        }\n', '      }\n', '  }\n', '  struct ExchangeId {\n', '    uint32 exchange_id;\n', '  }\n', '  struct GroupHeader {\n', '    uint32 quote_asset_id;\n', '    uint32 base_asset_id;\n', '    uint8 user_count;\n', '  }\n', '  struct Settlement {\n', '    uint64 user_id;\n', '    int64 quote_delta;\n', '    int64 base_delta;\n', '    uint64 fees;\n', '  }\n', '  \n', '  function exchange_apply_settlement_groups(bytes memory data) public  {\n', '    \n', '    uint256[6] memory variables;\n', '    assembly {\n', '      {\n', '        let locked_features := sload(security_locked_features_slot)\n', '        if and(locked_features, 0x200) {\n', '          mstore(32, 0)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      let data_len := mload(data)\n', '      let cursor := add(data, 32)\n', '      let cursor_end := add(cursor, data_len)\n', '      let exchange_id_0 := mload(cursor)\n', '      cursor := add(cursor, 4)\n', '      if gt(cursor, cursor_end) {\n', '        mstore(32, 1)\n', '        revert(63, 1)\n', '      }\n', '      let exchange_id := and(div(exchange_id_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '      {\n', '        let exchange_count := sload(exchange_count_slot)\n', '        if iszero(lt(exchange_id, exchange_count)) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      {\n', '        let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '        let exchange_0 := sload(exchange_ptr)\n', '        if iszero(eq(caller, and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff))) {\n', '          mstore(32, 2)\n', '          revert(63, 1)\n', '        }\n', '        if and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff) {\n', '          mstore(32, 3)\n', '          revert(63, 1)\n', '        }\n', '      }\n', '      for {} lt(cursor, cursor_end) {} {\n', '        let header_0 := mload(cursor)\n', '        cursor := add(cursor, 9)\n', '        if gt(cursor, cursor_end) {\n', '          mstore(32, 4)\n', '          revert(63, 1)\n', '        }\n', '        let quote_asset_id := and(div(header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\n', '        let base_asset_id := and(div(header_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffff)\n', '        if eq(quote_asset_id, base_asset_id) {\n', '          mstore(32, 16)\n', '          revert(63, 1)\n', '        }\n', '        let group_end := add(cursor, mul(and(div(header_0, 0x10000000000000000000000000000000000000000000000), 0xff), 32))\n', '        {\n', '          let asset_count := sload(asset_count_slot)\n', '          if iszero(and(lt(quote_asset_id, asset_count), lt(base_asset_id, asset_count))) {\n', '            mstore(32, 5)\n', '            revert(63, 1)\n', '          }\n', '        }\n', '        if gt(group_end, cursor_end) {\n', '          mstore(32, 6)\n', '          revert(63, 1)\n', '        }\n', '        let quote_net := 0\n', '        let base_net := 0\n', '        let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\n', '        let exchange_balance_ptr := add(add(exchange_ptr, 4), quote_asset_id)\n', '        let exchange_balance := sload(exchange_balance_ptr)\n', '        for {} lt(cursor, group_end) {\n', '          cursor := add(cursor, 32)\n', '        } {\n', '          let settlement_0 := mload(cursor)\n', '          let user_ptr := add(users_slot, mul(237684487561239756867226304516, and(div(settlement_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)))\n', '          let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\n', '          let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(quote_asset_id, 4294967296), base_asset_id)))\n', '          let quote_delta := and(div(settlement_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '          quote_delta := signextend(7, quote_delta)\n', '          let base_delta := and(div(settlement_0, 0x10000000000000000), 0xffffffffffffffff)\n', '          base_delta := signextend(7, base_delta)\n', '          quote_net := add(quote_net, quote_delta)\n', '          base_net := add(base_net, base_delta)\n', '          let fees := and(settlement_0, 0xffffffffffffffff)\n', '          exchange_balance := add(exchange_balance, fees)\n', '          let market_state_0 := sload(market_state_ptr)\n', '          {\n', '            let quote_qty := and(div(market_state_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '            quote_qty := signextend(7, quote_qty)\n', '            let base_qty := and(div(market_state_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '            base_qty := signextend(7, base_qty)\n', '            quote_qty := add(quote_qty, quote_delta)\n', '            base_qty := add(base_qty, base_delta)\n', '            if or(or(slt(quote_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(quote_qty, 0x7FFFFFFFFFFFFFFF)), or(slt(base_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(base_qty, 0x7FFFFFFFFFFFFFFF))) {\n', '              mstore(32, 7)\n', '              revert(63, 1)\n', '            }\n', '            let fee_used := add(and(div(market_state_0, 0x10000000000000000), 0xffffffffffffffff), fees)\n', '            let fee_limit := and(market_state_0, 0xffffffffffffffff)\n', '            if gt(fee_used, fee_limit) {\n', '              mstore(32, 8)\n', '              revert(63, 1)\n', '            }\n', '            market_state_0 := or(or(or(\n', '              /* quote_qty */ mul(quote_qty, 0x1000000000000000000000000000000000000000000000000), \n', '              /* base_qty */ mul(and(base_qty, 0xFFFFFFFFFFFFFFFF), 0x100000000000000000000000000000000)), \n', '              /* fee_used */ mul(fee_used, 0x10000000000000000)), \n', '              /* fee_limit */ fee_limit)\n', '            let market_state_1 := sload(add(market_state_ptr, 1))\n', '            {\n', '              let min_quote_qty := and(div(market_state_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\n', '              min_quote_qty := signextend(7, min_quote_qty)\n', '              let min_base_qty := and(div(market_state_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\n', '              min_base_qty := signextend(7, min_base_qty)\n', '              if or(slt(quote_qty, min_quote_qty), slt(base_qty, min_base_qty)) {\n', '                mstore(32, 9)\n', '                revert(63, 1)\n', '              }\n', '            }\n', '            {\n', '              let negatives := add(slt(quote_qty, 1), mul(slt(base_qty, 1), 2))\n', '              switch negatives\n', '                case 3 {\n', '                  if or(quote_qty, base_qty) {\n', '                    mstore(32, 10)\n', '                    revert(63, 1)\n', '                  }\n', '                }\n', '                case 1 {\n', '                  let current_price := div(mul(sub(0, quote_qty), 100000000), base_qty)\n', '                  let long_max_price := and(div(market_state_1, 0x10000000000000000), 0xffffffffffffffff)\n', '                  if gt(current_price, long_max_price) {\n', '                    mstore(32, 11)\n', '                    revert(63, 1)\n', '                  }\n', '                }\n', '                case 2 {\n', '                  if base_qty {\n', '                    let current_price := div(mul(quote_qty, 100000000), sub(0, base_qty))\n', '                    let short_min_price := and(market_state_1, 0xffffffffffffffff)\n', '                    if lt(current_price, short_min_price) {\n', '                      mstore(32, 12)\n', '                      revert(63, 1)\n', '                    }\n', '                  }\n', '                }\n', '            }\n', '          }\n', '          let quote_session_balance_ptr := add(add(session_ptr, 2), quote_asset_id)\n', '          let base_session_balance_ptr := add(add(session_ptr, 2), base_asset_id)\n', '          let quote_session_balance_0 := sload(quote_session_balance_ptr)\n', '          let base_session_balance_0 := sload(base_session_balance_ptr)\n', '          let quote_balance := and(quote_session_balance_0, 0xffffffffffffffff)\n', '          quote_balance := add(quote_balance, quote_delta)\n', '          quote_balance := sub(quote_balance, fees)\n', '          if gt(quote_balance, 0xFFFFFFFFFFFFFFFF) {\n', '            mstore(32, 13)\n', '            revert(63, 1)\n', '          }\n', '          let base_balance := and(base_session_balance_0, 0xffffffffffffffff)\n', '          base_balance := add(base_balance, base_delta)\n', '          if gt(base_balance, 0xFFFFFFFFFFFFFFFF) {\n', '            mstore(32, 14)\n', '            revert(63, 1)\n', '          }\n', '          sstore(market_state_ptr, market_state_0)\n', '          sstore(quote_session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, quote_session_balance_0), \n', '            /* asset_balance */ quote_balance))\n', '          sstore(base_session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, base_session_balance_0), \n', '            /* asset_balance */ base_balance))\n', '        }\n', '        if or(quote_net, base_net) {\n', '          mstore(32, 15)\n', '          revert(63, 1)\n', '        }\n', '        sstore(exchange_balance_ptr, exchange_balance)\n', '      }\n', '    }\n', '  }\n', '}']