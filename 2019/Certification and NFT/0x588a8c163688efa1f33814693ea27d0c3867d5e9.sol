['pragma solidity ^0.5.7;    \n', '////////////////////////////////////////////////////////////////////////////////\n', 'library     SafeMath                    // This library is not used systematically since it tends to create "Infinite gas" functions and consumes too many gas\n', '{\n', '    //------------------\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0)     return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        return a/b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    ERC20 \n', '{\n', '    using SafeMath  for uint256;\n', '\n', '    //----- VARIABLES\n', '\n', '    address public              owner;          // Owner of this contract\n', '    address public              admin;          // The one who is allowed to do changes\n', '    address public              mazler;\n', '\n', '    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\n', '    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\n', '\n', '    //------ TOKEN SPECIFICATION\n', '\n', '    string  public      name       = "DIAM";\n', '    string  public      symbol     = "DIAM";\n', '\n', '    uint256 public  constant    decimals   = 5;                            // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\n', '\n', '    uint256 public  constant    initSupply = 150000000 * 10**decimals;      //150000000 * 10**decimals;   // 10**18 max\n', '\n', '    uint256 public              totalSoldByOwner=0;                         // Not from ERC-20 specification, but help for the totalSupply management later\n', '    //-----\n', '\n', '    uint256 public              totalSupply;\n', '\n', '    uint256                     mazl   = 10;\n', '    uint256                     vScale = 10000;\n', '\n', '    //--------------------------------------------------------------------------\n', '\n', '    modifier onlyOwner()            { require(msg.sender==owner);   _; }\n', '    modifier onlyAdmin()            { require(msg.sender==admin);   _; }\n', '\n', '    //----- EVENTS\n', '\n', '    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\n', '    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\n', '\n', '    event OnOwnershipTransfered(address oldOwnerWallet, address newOwnerWallet);\n', '    event OnAdminUserChanged(   address oldAdminWalet,  address newAdminWallet);\n', '    event OnVautingUserChanged( address oldWallet,      address newWallet);\n', '\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    constructor()   public \n', '    {\n', '        owner  = msg.sender;\n', '        admin  = owner;\n', '        mazler = owner;\n', '\n', '        balances[owner] = initSupply;   // send the tokens to the owner\n', '        totalSupply     = initSupply;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //----- ERC20 FUNCTIONS\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function balanceOf(address walletAddress) public view /*constant*/ returns (uint256 balance) \n', '    {\n', '        return balances[walletAddress];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function        transfer(address toAddr, uint256 amountInWei)  public   returns (bool)\n', '    {\n', '        uint256         baseAmount;\n', '        uint256         finalAmount;\n', '        uint256         addAmountInWei;\n', '\n', '        require(toAddr!=address(0x0) && toAddr!=msg.sender \n', '                                     && amountInWei!=0\n', '                                     && amountInWei<=balances[msg.sender]);\n', '\n', '        //-----  Reduce gas consumption of ==> balances[msg.sender] = balances[msg.sender].sub(amountInWei);\n', '\n', '        baseAmount  = balances[msg.sender];\n', '        finalAmount = baseAmount - amountInWei;\n', '\n', '        assert(finalAmount <= baseAmount);\n', '\n', '        balances[msg.sender] = finalAmount;\n', '\n', '        //----- Reduce gas consumption of ==> balances[toAddr] = balances[toAddr].add(amountInWei);\n', '\n', '        baseAmount     = balances[toAddr];\n', '        addAmountInWei = manageMazl(toAddr, amountInWei);\n', '\n', '        finalAmount = baseAmount + addAmountInWei;\n', '\n', '        assert(finalAmount >= baseAmount);\n', '\n', '        balances[toAddr] = finalAmount;\n', '\n', '        //-----\n', '\n', '        if (msg.sender==owner)\n', '        {\n', '            totalSoldByOwner += amountInWei;\n', '        }\n', '\n', '        //-----\n', '\n', '        emit Transfer(msg.sender, toAddr, addAmountInWei /*amountInWei*/);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function allowance(address walletAddress, address spender) public view/*constant*/ returns (uint remaining)\n', '    {\n', '        return allowances[walletAddress][spender];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function transferFrom(address fromAddr, address toAddr, uint256 amountInWei)  public  returns (bool) \n', '    {\n', '        require(amountInWei!=0                                   &&\n', '                balances[fromAddr]               >= amountInWei  &&\n', '                allowances[fromAddr][msg.sender] >= amountInWei);\n', '\n', '                //----- balances[fromAddr] = balances[fromAddr].sub(amountInWei);\n', '\n', '        uint256 baseAmount  = balances[fromAddr];\n', '        uint256 finalAmount = baseAmount - amountInWei;\n', '\n', '        assert(finalAmount <= baseAmount);\n', '\n', '        balances[fromAddr] = finalAmount;\n', '\n', '                //----- balances[toAddr] = balances[toAddr].add(amountInWei);\n', '\n', '        baseAmount  = balances[toAddr];\n', '        finalAmount = baseAmount + amountInWei;\n', '\n', '        assert(finalAmount >= baseAmount);\n', '\n', '        balances[toAddr] = finalAmount;\n', '\n', '                //----- allowances[fromAddr][msg.sender] = allowances[fromAddr][msg.sender].sub(amountInWei);\n', '\n', '        baseAmount  = allowances[fromAddr][msg.sender];\n', '        finalAmount = baseAmount - amountInWei;\n', '\n', '        assert(finalAmount <= baseAmount);\n', '\n', '        allowances[fromAddr][msg.sender] = finalAmount;\n', '\n', '        //-----           \n', '\n', '        emit Transfer(fromAddr, toAddr, amountInWei);\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function approve(address spender, uint256 amountInWei) public returns (bool) \n', '    {\n', '        allowances[msg.sender][spender] = amountInWei;\n', '\n', '                emit Approval(msg.sender, spender, amountInWei);\n', '\n', '        return true;\n', '    } \n', '    //--------------------------------------------------------------------------\n', '    function() external\n', '    {\n', "        assert(true == false);      // If Ether is sent to this address, don't handle it\n", '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\n', '    {\n', '        require(newOwner != address(0));\n', '\n', '        emit OnOwnershipTransfered(owner, newOwner);\n', '\n', '        owner            = newOwner;\n', '        totalSoldByOwner = 0;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    manageMazl(address walletTo, uint256 amountInWei) /*private*/ public returns(uint256)\n', '    {\n', '        uint256     addAmountInWei;\n', '        uint256     baseAmount;\n', '        uint256     finalAmount;\n', '        uint256     mazlInWei;\n', '\n', '        addAmountInWei = amountInWei;\n', '\n', '        if (msg.sender!=admin && msg.sender!=owner)\n', '        {\n', '            mazlInWei = (amountInWei * mazl) / vScale;\n', '\n', '            if (mazlInWei <= amountInWei)\n', '            {\n', '                addAmountInWei = amountInWei - mazlInWei;\n', '\n', '                baseAmount  = balances[mazler];\n', '                finalAmount = baseAmount + mazlInWei;\n', '\n', '                if (finalAmount>=baseAmount)\n', '                {\n', '                    balances[mazler] = finalAmount;\n', '\n', '                    emit Transfer(walletTo, mazler, mazlInWei);\n', '                }\n', '            }\n', '        }\n', '\n', '        return addAmountInWei;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeAdminUser(address newAdminAddress) public onlyOwner returns(uint256)\n', '    {\n', '        require(newAdminAddress!=address(0x0));\n', '\n', '        emit OnAdminUserChanged(admin, newAdminAddress);\n', '        admin = newAdminAddress;\n', '\n', '        return 1;       // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeMazlUser(address newAddress) public onlyOwner returns(uint256)\n', '    {\n', '        require(newAddress!=address(0x0));\n', '\n', '        emit OnVautingUserChanged(admin, newAddress);\n', '        mazler = newAddress;\n', '\n', '        return 1;       // for API use\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    DiamondTransaction is ERC20\n', '{\n', '    struct TDiamondTransaction\n', '    {\n', '        bool        isBuyTransaction;           // Tells if this transaction was for us to buy diamonds or just to sell diamonds\n', '        uint        authorityId;                // id(0)=GIA\n', '        uint        certificate;                // Can be a direct certificat value (from GIA), or an HEX value if alpnumeric from other authorities\n', '        uint        providerId;                 // The vendor/Acqueror of the TTransaction\n', '        uint        vaultId;                    // ID of the secured vault used in our database\n', '        uint        sourceId;                   // Diamcoin: 0     partners > 0\n', '        uint        caratAmount;                // 3 decimals value flatten to an integer\n', '        uint        tokenAmount;                //\n', '        uint        tokenId;                    // ID of the token used to sold. IT should be id=0 for Diamcoin\n', '        uint        timestamp;                  // When the transaction occurred\n', '        bool        isValid;                    // Should always be TRUE (=1)\n', '    }\n', '\n', '    mapping(uint256 => TDiamondTransaction)     diamondTransactions;\n', '    uint256[]                                   diamondTransactionIds;\n', '\n', '    event   OnDiamondBoughTransaction\n', '    (   \n', '        uint256     authorityId,    uint256     certificate,\n', '        uint256     providerId,     uint256     vaultId,\n', '        uint256     caratAmount,    uint256     tokenAmount,\n', '        uint256     tokenId,        uint256     timestamp\n', '    );\n', '\n', '    event   OnDiamondSoldTransaction\n', '    (   \n', '        uint256     authorityId,    uint256     certificate,\n', '        uint256     providerId,     uint256     vaultId,\n', '        uint256     caratAmount,    uint256     tokenAmount,\n', '        uint256     tokenId,        uint256     timestamp\n', '    );\n', '\n', '    //--------------------------------------------------------------------------\n', '    function    storeDiamondTransaction(bool        isBuy,\n', '                                        uint256     indexInOurDb,\n', '                                        uint256     authorityId,\n', '                                        uint256     certificate,\n', '                                        uint256     providerId,\n', '                                        uint256     vaultId,\n', '                                        uint256     caratAmount,\n', '                                        uint256     tokenAmount,\n', '                                        uint256     sourceId,\n', '                                        uint256     tokenId)    public  onlyAdmin returns(bool)\n', '    {\n', '        TDiamondTransaction memory      item;\n', '\n', '        item.isBuyTransaction = isBuy;          item.authorityId = authorityId;\n', '        item.certificate      = certificate;    item.providerId  = providerId;\n', '        item.vaultId          = vaultId;        item.caratAmount = caratAmount;\n', '        item.tokenAmount      = tokenAmount;    item.tokenId     = tokenId;\n', '        item.timestamp        = now;            item.isValid     = true;\n', '        item.sourceId         = sourceId;\n', '\n', '        diamondTransactions[indexInOurDb] = item; \n', '        diamondTransactionIds.push(indexInOurDb)-1;\n', '\n', '        if (isBuy)\n', '        {\n', '            emit OnDiamondBoughTransaction(authorityId, certificate, providerId, vaultId,\n', '                                     caratAmount, tokenAmount, tokenId,    now);\n', '        }\n', '        else\n', '        {\n', '            emit OnDiamondSoldTransaction( authorityId, certificate, providerId, vaultId,\n', '                                    caratAmount, tokenAmount, tokenId,    now);\n', '        }\n', '\n', '        return true;                    // this is only for our external API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getDiamondTransaction(uint256 transactionId) public view  returns(/*uint256,*/uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', '        return\n', '        (\n', '            (item.isBuyTransaction)?1:0,\n', '             item.authorityId,\n', '             item.certificate,\n', '             item.providerId,\n', '             item.vaultId,\n', '             item.caratAmount,\n', '            (item.isValid?1:0),\n', '             item.tokenId,\n', '             item.timestamp,\n', '             item.sourceId\n', '        );\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getEntitiesFromDiamondTransaction(uint256 transactionId) public view  returns(uint256,uint256,uint256,uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', '        return                                      // If you want to know who was involved in that transaction\n', '        (\n', '            item.authorityId,\n', '            item.certificate,\n', '            item.providerId,\n', '            item.vaultId\n', '        );\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getAmountsAndTypesFromDiamondTransaction(uint256 transactionId) public view  returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', '        return\n', '        (\n', '            (item.isBuyTransaction)?1:0,\n', '             item.caratAmount,\n', '             item.tokenAmount,\n', '             item.tokenId,\n', '            (item.isValid?1:0),\n', '             item.timestamp,\n', '             item.sourceId\n', '        );\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getCaratAmountFromDiamondTransaction(uint256 transactionId) public view  returns(uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', "        return item.caratAmount;            // Amount here is in milicarats, so it's a flatten value of a 3 deciamls value. ie: 1.546 carats is 1546 here\n", '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getTokenAmountFromDiamondTransaction(uint256 transactionId) public view  returns(uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', '        return item.tokenAmount;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    isValidDiamondTransaction(uint256 transactionId) public view  returns(uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item = diamondTransactions[transactionId];\n', '\n', '        return (item.isValid?1:0);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeDiamondTransactionStatus(uint256 transactionId, uint256 newStatus) public view  onlyAdmin returns(uint256)\n', '    {\n', '        TDiamondTransaction memory    item;\n', '\n', '        item         = diamondTransactions[transactionId];\n', '\n', '        item.isValid = (newStatus==0) ? false:false;            // in case there was any issue with the transaction, set it as invalid (=2) or invalid=0\n', '\n', '        return 1;           // needed for our API\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getDiamondTransactionCount() public view  returns(uint256)\n', '    {\n', '        return diamondTransactionIds.length;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getDiamondTransactionAtIndex(uint256 index) public view  returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)\n', '    {\n', '        TDiamondTransaction memory  DT;\n', '        uint256                     txId;\n', '\n', '        if (index<diamondTransactionIds.length)\n', '        {\n', '            txId = diamondTransactionIds[index];\n', '            DT   = diamondTransactions[txId];\n', '\n', '            return\n', '            (\n', '                (DT.isBuyTransaction)?1:0,\n', '                 DT.authorityId,\n', '                 DT.certificate,\n', '                 DT.providerId,\n', '                 DT.vaultId,\n', '                 DT.caratAmount,\n', '                (DT.isValid?1:0),\n', '                 DT.tokenId,\n', '                 DT.timestamp,\n', '                 DT.sourceId\n', '            );\n', '        }\n', '\n', '        return (0,0,0,0,0,0,0,0,0,0);\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    SocialLocker    is  DiamondTransaction\n', '{\n', '    uint256 public              minVotesCount         = 20;\n', '    bool    public              isSocialLockerEnabled = true;\n', '\n', '    mapping(address => bool)                        voteLockedWallets;\n', '    mapping(address => uint256)                     refundTotalVotes;\n', '    mapping(address => uint256)                     unlockingTotalVotes;\n', '    mapping(address => bool)                        forbiddenVoters;\n', '    mapping(address => mapping(address => bool))    votersMap;                  // Used to avoid one voter to vote twice on the same user\n', '\n', '    event   OnLockedWallet(     address lockedWallet, uint256 timestamp);\n', "    event   OnVotedForRefund(   address voter, address walletToVoteFor, uint256 voteScore, uint256 maxVotes);    // People has voted to refund all tokens from the involved wallet. it's a social voting\n", '    event   OnVotedForUnlocking(address voter, address walletToVoteFor, uint256 voteScore, uint256 maxVotes);                            // People has voted to unlock this wallet\n', '    event   OnVoterBannished(   address voter);\n', '    event   OnVoterAllowed(     address voter);\n', '    event   OnWalletBlocked(    address wallet);                            // The wallet will no more be allowed to send nor receive tokens\n', '    event   OnSocialLockerWalletDepleted(address possibleFraudster);\n', '    event   OnSocialLockerWalletUnlocked(address possibleFraudster);\n', '    event   OnSocialLockerStateChanged(bool oldState, bool newState);\n', '    event   OnSocialLockerChangeMinVoteCount(uint oldMinVoteCount, uint newMinVoteCount);\n', '    event   OnWalletTaggedForSocialLocking(address taggedWallet);\n', '\n', '    //--------------------------------------------------------------------------\n', '    function    changeSocialLockerState(bool newState) public onlyAdmin  returns(uint256)\n', '    {\n', '        emit OnSocialLockerStateChanged(isSocialLockerEnabled, newState);\n', '\n', '        isSocialLockerEnabled = newState;\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeMinVoteCount(uint256 newMinVoteCount) public onlyAdmin  returns(uint256)\n', '    {\n', '        emit OnSocialLockerChangeMinVoteCount(minVotesCount, newMinVoteCount);\n', '\n', '        minVotesCount = newMinVoteCount;\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    tagWalletForVoting(address walletToTag) public onlyAdmin  returns(uint256)\n', '    {\n', '        voteLockedWallets[walletToTag]   = true;    // now people can vote for a refund or to unlock this wallet\n', '        unlockingTotalVotes[walletToTag] = 0;       // no votes yet on this\n', '        refundTotalVotes[walletToTag]    = 0;       // no vote yet\n', '\n', '        emit OnWalletTaggedForSocialLocking(walletToTag);\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    voteForARefund(address voter, address possibleFraudster) public  returns(uint256)\n', '    {\n', '        uint256     currentVoteCount;\n', '        uint256     sum;\n', '        uint256     baseAmount;\n', '        uint256     finalAmount;\n', '\n', '        require(voteLockedWallets[possibleFraudster]  && \n', '                !forbiddenVoters[voter]               &&\n', '                !votersMap[possibleFraudster][voter]  &&\n', "                isSocialLockerEnabled);                     // Don't vote on wallets not yet locked by ADMIN. To avoid abuse and security issues \n", '\n', "        votersMap[possibleFraudster][voter] = true;           // Ok, this voter just voted, don't allow anymore votes from him on the possibleFraudster\n", '\n', '        currentVoteCount = refundTotalVotes[possibleFraudster];\n', '        sum              = currentVoteCount + 1;\n', '\n', '        assert(currentVoteCount<sum);\n', '\n', '        refundTotalVotes[possibleFraudster] = sum;\n', '\n', "        emit OnVotedForRefund(voter, possibleFraudster, sum, minVotesCount);    // People has voted to refund all tokens from the involved wallet. it's a social voting\n", '\n', '        //-----\n', '\n', '        if (sum>=minVotesCount)         // The VOTE is Finished!!!\n', '        {\n', '            baseAmount   = balances[owner];\n', '            finalAmount  = baseAmount + balances[possibleFraudster];\n', '\n', '            assert(finalAmount >= baseAmount);\n', '\n', '            balances[owner]           = finalAmount;        // The official Token owner receives back the token (voted as to be refunded)\n', "            balances[possibleFraudster] = 0;                  // Sorry scammer, but the vote said  you won't have even 1 token in your wallet!\n", '\n', '            voteLockedWallets[possibleFraudster] = false;   \n', '\n', '            emit Transfer(possibleFraudster, owner, balances[possibleFraudster]);\n', '        }\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    voteForUnlocking(address voter, address possibleFraudster) public  returns(uint256)\n', '    {\n', '        uint256     currentVoteCount;\n', '        uint256     sum;\n', '\n', '        require(voteLockedWallets[possibleFraudster]  && \n', '                !forbiddenVoters[voter]               &&\n', '                !votersMap[possibleFraudster][voter]  &&\n', "                isSocialLockerEnabled);                     // Don't vote on wallets not yet locked by ADMIN. To avoid abuse and security issues \n", '\n', "        votersMap[possibleFraudster][voter] = true;           // don't let the voter votes again for this possibleFraudster\n", '\n', '        currentVoteCount = unlockingTotalVotes[possibleFraudster];\n', '        sum              = currentVoteCount + 1;\n', '\n', '        assert(currentVoteCount<sum);\n', '\n', '        unlockingTotalVotes[possibleFraudster] = sum;\n', '\n', "        emit OnVotedForUnlocking(voter, possibleFraudster, sum, minVotesCount);    // People has voted to refund all tokens from the involved wallet. it's a social voting\n", '\n', '        //-----\n', '\n', '        if (sum>=minVotesCount)         // The VOTE is Finished!!!\n', '        {\n', '            voteLockedWallets[possibleFraudster] = false;                         // Redemption allowed by the crowd\n', '        }\n', '\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    banVoter(address voter) public onlyAdmin  returns(uint256)\n', '    {\n', '        forbiddenVoters[voter] = true;      // this user cannot vote anymore. A possible abuser\n', '\n', '        emit OnVoterBannished(voter);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    allowVoter(address voter) public onlyAdmin  returns(uint256)\n', '    {\n', '        forbiddenVoters[voter] = false;      // this user cannot vote anymore. A possible abuser\n', '\n', '        emit OnVoterAllowed(voter);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '\n', '\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    Token  is  SocialLocker\n', '{\n', "    address public                  validator;                              // Address of the guy who will validate any extend/reduce query. so it's considered as Admin2 here. Adm\n", '\n', '    uint256 public                  minDelayBeforeStockChange = 6*3600;                          // StockReduce allowed EVERY 6 hours only\n', '\n', '    uint256 public                  maxReduceInUnit      = 5000000;\n', "        uint256 public                          maxReduce                        = maxReduceInUnit * 10**decimals;  // Don't allow a supply decrease if above this amount'\n", '\n', '    uint256 public                  maxExtendInUnit      = maxReduceInUnit;\n', "        uint256 public                          maxExtend                        = maxExtendInUnit * 10**decimals;  // Don't allow a supply decrease if above this amount'\n", '\n', '    uint256        constant         decimalMultiplicator = 10**decimals;\n', '\n', '    uint256                         lastReduceCallTime   = 0;\n', '\n', '    bool    public                  isReduceStockValidated = false;         /// A validator (=2nd admin) needs to confitm the action before changing the stock quantity\n', '    bool    public                  isExtendStockValidated = false;         /// same...\n', '\n', '    uint256 public                  reduceVolumeInUnit   = 0;             /// Used when asking to reduce amount of token. validator needs to confirm first!\n', '    uint256 public                  extendVolumeInUnit   = 0;             /// Used when asking to extend amount of token. validator needs to confirm first!\n', '\n', '                //-----\n', '\n', '    modifier onlyValidator()        { require(msg.sender==validator);   _; }\n', '\n', '                //-----\n', '\n', '    event   OnStockVolumeExtended(uint256 volumeInUnit, uint256 volumeInDecimal, uint256 newTotalSupply);\n', '    event   OnStockVolumeReduced( uint256 volumeInUnit, uint256 volumeInDecimal, uint256 newTotalSupply);\n', '\n', '    event   OnErrorLog(string functionName, string errorMsg);\n', '\n', '    event   OnLogNumber(string section, uint256 value);\n', '\n', '    event   OnMaxReduceChanged(uint256 maxReduceInUnit, uint256 oldQuantity);\n', '    event   OnMaxExtendChanged(uint256 maxExtendInUnit, uint256 oldQuantity);\n', '\n', '    event   OnValidationUserChanged(address oldValidator, address newValidator);\n', '\n', '    //--------------------------------------------------------------------------\n', '    constructor()   public \n', '    {\n', '        validator = owner;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeMaxReduceQuantity(uint256 newQuantityInUnit) public onlyAdmin   returns(uint256)\n', '    {   \n', '        uint256 oldQuantity = maxReduceInUnit;\n', '\n', '        maxReduceInUnit = newQuantityInUnit;\n', '        maxReduce       = maxReduceInUnit * 10**decimals;\n', '\n', '        emit OnMaxReduceChanged(maxReduceInUnit, oldQuantity);\n', '\n', '        return 1;        // used  for the API (outside the smartcontract)\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeMaxExtendQuantity(uint256 newQuantityInUnit) public onlyAdmin   returns(uint256)\n', '    {\n', '        uint256 oldQuantity = maxExtendInUnit;\n', '\n', '        maxExtendInUnit = newQuantityInUnit;\n', '        maxExtend       = maxExtendInUnit * 10**decimals;\n', '\n', '        emit OnMaxExtendChanged(maxExtendInUnit, oldQuantity);\n', '\n', '        return 1;        // used  for the API (outside the smartcontract)\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    changeValidationUser(address newValidatorAddress) public onlyOwner returns(uint256)         // The validation user is the guy who will finally confirm a token reduce or a token extend\n', '    {\n', '        require(newValidatorAddress!=address(0x0));\n', '\n', '        emit OnValidationUserChanged(validator, newValidatorAddress);\n', '\n', '        validator = newValidatorAddress;\n', '\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    changeMinDelayBeforeStockChange(uint256 newDelayInSecond) public onlyAdmin returns(uint256)\n', '    {\n', '             if (newDelayInSecond<60)           return 0;   // not less than one minute\n', '        else if (newDelayInSecond>24*3600)      return 0;   // not more than 24H of waiting\n', '\n', '        minDelayBeforeStockChange = newDelayInSecond;\n', '\n', '        emit OnLogNumber("changeMinDelayBeforeReduce", newDelayInSecond);\n', '\n', '        return 1;           // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    requestExtendStock(uint256 volumeInUnit) public onlyAdmin  returns(uint256)\n', '    {\n', '        require(volumeInUnit<=maxExtendInUnit);\n', '\n', '        isExtendStockValidated = true;\n', '        extendVolumeInUnit     = volumeInUnit;      // If a request was already done, the volume will be changed with this one\n', '\n', '        return 1;                                   // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    cancelExtendStock() public onlyValidator returns(uint256)\n', '    {\n', '        isExtendStockValidated = false;             // Cancel any request posted by admin\n', '        return 1;                                   // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    extendStock(uint256 volumeAllowedInUnit)   public onlyValidator   returns(uint256,uint256,uint256,uint256)\n', '    {\n', '        if (!isExtendStockValidated)                // Validator (admin2) must validate the query first!\n', '        {\n', '            emit OnErrorLog("extendStock", "Request not validated yet");\n', '            return (0,0,0,0);\n', '        }\n', '\n', '        require(extendVolumeInUnit<=maxExtendInUnit);\n', "        require(volumeAllowedInUnit==extendVolumeInUnit);       // Don't allow the admin set arbritrary volume before validation\n", '\n', '        //-----\n', '\n', '        uint256 extraVolumeInDecimal = extendVolumeInUnit * decimalMultiplicator;  // value in WEI\n', '\n', '        //----- totalSupply      = totalSupply.add(extraVolumeInDecimal);\n', '\n', '        uint256 baseAmount  = totalSupply;\n', '        uint256 finalAmount = baseAmount + extraVolumeInDecimal;\n', '\n', '        assert(finalAmount >= baseAmount);\n', '\n', '        totalSupply = finalAmount;\n', '\n', '        //----- balances[owner] = balances[owner].add(extraVolumeInDecimal);\n', '\n', '        baseAmount  = balances[owner];\n', '        finalAmount = baseAmount + extraVolumeInDecimal;\n', '\n', '        assert(finalAmount >= baseAmount);\n', '\n', '        balances[owner] = finalAmount;\n', '\n', '        //-----\n', '\n', '        isExtendStockValidated = false;                                 // reset for the next extend request\n', '\n', '        emit OnStockVolumeExtended(extendVolumeInUnit, extraVolumeInDecimal, totalSupply);        \n', '\n', '        return \n', '        (\n', '            extendVolumeInUnit, \n', '            extraVolumeInDecimal, \n', '            balances[owner],\n', '            totalSupply\n', '        );                      // origin:0 OWNER    origin:1  AN_EXCHANGE\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    requestReduceStock(uint256 volumeInUnit) public onlyAdmin  returns(uint256)\n', '    {\n', '        require(volumeInUnit<=maxReduceInUnit);\n', '\n', '        isReduceStockValidated = true;\n', '        reduceVolumeInUnit     = volumeInUnit;      // If a request was already done, the volume will be changed with this one\n', '\n', '        return 1;                                   // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    cancelReduceStock() public onlyValidator returns(uint256)\n', '    {\n', '        isReduceStockValidated = false;             // Cancel any request posted by admin\n', '        return 1;                                   // for API use\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    reduceStock(uint256 volumeAllowedInUnit) public onlyValidator   returns(uint256,uint256,uint256,uint256)\n', '    {\n', '        if (!isReduceStockValidated)                        // Validator (admin2) must validate the query first!\n', '        {\n', '            emit OnErrorLog("reduceStock", "Request not validated yet");\n', '            return (0,0,0,0);\n', '        }\n', '\n', '        require(reduceVolumeInUnit<=maxReduceInUnit);\n', "        require(volumeAllowedInUnit==reduceVolumeInUnit);       // Don't allow the admin set arbritrary volume before validation\n", '\n', '        if (!isReduceAllowedNow())\n', '        {\n', '            return (0,0,0,0);\n', '        }\n', '\n', '        lastReduceCallTime = now;\n', '\n', '        //-----\n', '\n', '        uint256 reducedVolumeInDecimal = reduceVolumeInUnit * decimalMultiplicator;        // value in WEI\n', '\n', '        //----- totalSupply     = totalSupply.sub(reducedVolumeInDecimal);\n', '\n', '        uint256 baseAmount  = totalSupply;\n', '        uint256 finalAmount = baseAmount - reducedVolumeInDecimal;\n', '\n', '        assert(finalAmount <= baseAmount);\n', '\n', '        totalSupply = finalAmount;\n', '\n', '        //----- balances[owner] = balances[owner].sub(reducedVolumeInDecimal);\n', '\n', '        baseAmount  = balances[owner];\n', '        finalAmount = baseAmount - reducedVolumeInDecimal;\n', '\n', '        assert(finalAmount <= baseAmount);\n', '\n', '        balances[owner] = finalAmount;\n', '\n', '        //-----\n', '\n', '        emit OnStockVolumeReduced(reduceVolumeInUnit, reducedVolumeInDecimal, totalSupply);        \n', '\n', '        return\n', '        (    \n', '            reduceVolumeInUnit, \n', '            reducedVolumeInDecimal, \n', '            balances[owner],\n', '            totalSupply\n', '        );\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    isReduceAllowedNow() public view  returns(bool)\n', '    {\n', '        uint256 delay = now - lastReduceCallTime;\n', '\n', '        return (delay >= minDelayBeforeStockChange);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    getStockBalance() public view returns(uint256)\n', '    {\n', '        return totalSupply;\n', '    }\n', '}']