['pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface DSFeed {\n', '    function read()\n', '    external\n', '    view\n', '    returns (bytes32);\n', '}\n', '\n', 'contract OracleRegistry is Ownable {\n', '\n', '\n', '    address payable private _networkWallet;\n', '    address private _networkExecutor;\n', '\n', '    // 0.005 ETH as Wei(.5%)\n', '    uint256 public baseFee = uint256(0x0000000000000000000000000000000000000000000000000011c37937e08000);\n', '\n', '    mapping(address => bool) public isWhitelisted;\n', '    mapping(uint256 => address) public oracles;\n', '    mapping(address => mapping(address => uint256)) public splitterToFee;\n', '\n', '\n', '    event OracleActivated(address oracleFeed, uint256 currencyPair);\n', '    event FeeChanged(address merchantModule, address asset, uint256 newFee);\n', '\n', '    /// @dev Setup function sets initial storage of contract.\n', '    /// @param _oracles List of whitelisted oracles.\n', '    function setup(\n', '        address[] memory _oracles,\n', '        uint256[] memory _currencyPair,\n', '        address payable[] memory _networkSettings\n', '    )\n', '    public\n', '    onlyOwner\n', '    {\n', '        require(_oracles.length == _currencyPair.length);\n', '\n', '        for (uint256 i = 0; i < _oracles.length; i++) {\n', '            addToWhitelist(_oracles[i], _currencyPair[i]);\n', '        }\n', '\n', '        require(_networkSettings.length == 2, "OracleResigstry::setup INVALID_DATA: NETWORK_SETTINGS_LENGTH");\n', '\n', '        require(_networkWallet == address(0), "OracleResigstry::setup INVALID_STATE: NETWORK_WALLET_SET");\n', '\n', '        _networkWallet = _networkSettings[0];\n', '\n', '        require(_networkExecutor == address(0), "OracleResigstry::setup INVALID_STATE: NETWORK_EXECUTOR_SET");\n', '\n', '        _networkExecutor = _networkSettings[1];\n', '    }\n', '\n', '    function setFee(\n', '        address[] memory merchantModule,\n', '        address[] memory assetOfExchange,\n', '        uint256[] memory newFee\n', '    )\n', '    public\n', '    onlyOwner\n', '    returns\n', '    (bool) {\n', '\n', '        for (uint256 i = 0; i < merchantModule.length; i++) {\n', '            address merchant = merchantModule[i];\n', '            address asset = assetOfExchange[i];\n', '            uint256 assetFee = newFee[i];\n', '            require(merchant != address(0), "OracleRegistry::setup INVALID_DATA: MERCHANT_MODULE_ADDR");\n', '            require(asset != address(0), "OracleRegistry::setup INVALID_DATA: ASSET_ADDR");\n', '\n', '            splitterToFee[merchant][asset] = assetFee;\n', '\n', '            emit FeeChanged(merchant, asset, assetFee);\n', '        }\n', '    }\n', '\n', '    function read(\n', '        uint256 currencyPair\n', '    ) public view returns (bytes32) {\n', '        address orl = oracles[currencyPair];\n', '        require(isWhitelisted[orl], "INVALID_DATA: CURRENCY_PAIR");\n', '        return DSFeed(orl).read();\n', '    }\n', '\n', '    /// @dev Allows to add destination to whitelist. This can only be done via a Safe transaction.\n', '    /// @param oracle Destination address.\n', '    function addToWhitelist(address oracle, uint256 currencyPair)\n', '    public\n', '    onlyOwner\n', '    {\n', '        require(!isWhitelisted[oracle], "OracleResigstry::addToWhitelist INVALID_STATE: ORACLE_WHITELIST");\n', '        require(oracle != address(0), "OracleResigstry::addToWhitelist INVALID_DATA: ORACLE_ADDRESS");\n', '        require(currencyPair != uint256(0), "OracleResigstry::addToWhitelist INVALID_DATA: ORACLE_CURRENCY_PAIR");\n', '        oracles[currencyPair] = oracle;\n', '        isWhitelisted[oracle] = true;\n', '        emit OracleActivated(oracle, currencyPair);\n', '    }\n', '\n', '    /// @dev Allows to remove destination from whitelist. This can only be done via a Safe transaction.\n', '    /// @param oracle Destination address.\n', '    function removeFromWhitelist(address oracle)\n', '    public\n', '    onlyOwner\n', '    {\n', '        require(isWhitelisted[oracle], "Address is not whitelisted");\n', '        isWhitelisted[oracle] = false;\n', '    }\n', '\n', '    function getNetworkExecutor()\n', '    public\n', '    returns (address) {\n', '        return _networkExecutor;\n', '    }\n', '\n', '    function getNetworkWallet()\n', '    public\n', '    returns (address payable) {\n', '        return _networkWallet;\n', '    }\n', '\n', '    function getNetworkFee(address asset)\n', '    public\n', '    returns (uint256 fee) {\n', '        fee = splitterToFee[msg.sender][asset];\n', '        if (fee == uint256(0)) {\n', '            fee = baseFee;\n', '        }\n', '    }\n', '\n', '}']