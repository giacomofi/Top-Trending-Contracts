['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', 'pragma solidity ^0.5.10;\n', '\n', '/**\n', ' * @title CheckpointOracle\n', ' * @author Gary Rong<<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d7b0b6a5aea5b8b9b097b2a3bfb2a5b2a2baf9b8a5b0">[email&#160;protected]</a>>, Martin Swende <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a9c4c8dbddc0c787dadeccc7cdcce9ccddc1ccdbccdcc487c6dbce">[email&#160;protected]</a>>\n', ' * @dev Implementation of the blockchain checkpoint registrar.\n', ' */\n', 'contract CheckpointOracle {\n', '    /*\n', '        Events\n', '    */\n', '\n', '    // NewCheckpointVote is emitted when a new checkpoint proposal receives a vote.\n', '    event NewCheckpointVote(uint64 indexed index, bytes32 checkpointHash, uint8 v, bytes32 r, bytes32 s);\n', '\n', '    /*\n', '        Public Functions\n', '    */\n', '    constructor(address[] memory _adminlist, uint _sectionSize, uint _processConfirms, uint _threshold) public {\n', '        for (uint i = 0; i < _adminlist.length; i++) {\n', '            admins[_adminlist[i]] = true;\n', '            adminList.push(_adminlist[i]);\n', '        }\n', '        sectionSize = _sectionSize;\n', '        processConfirms = _processConfirms;\n', '        threshold = _threshold;\n', '    }\n', '\n', '    /**\n', '     * @dev Get latest stable checkpoint information.\n', '     * @return section index\n', '     * @return checkpoint hash\n', '     * @return block height associated with checkpoint\n', '     */\n', '    function GetLatestCheckpoint()\n', '    view\n', '    public\n', '    returns(uint64, bytes32, uint) {\n', '        return (sectionIndex, hash, height);\n', '    }\n', '\n', '    // SetCheckpoint sets  a new checkpoint. It accepts a list of signatures\n', '    // @_recentNumber: a recent blocknumber, for replay protection\n', '    // @_recentHash : the hash of `_recentNumber`\n', '    // @_hash : the hash to set at _sectionIndex\n', '    // @_sectionIndex : the section index to set\n', '    // @v : the list of v-values\n', '    // @r : the list or r-values\n', '    // @s : the list of s-values\n', '    function SetCheckpoint(\n', '        uint _recentNumber,\n', '        bytes32 _recentHash,\n', '        bytes32 _hash,\n', '        uint64 _sectionIndex,\n', '        uint8[] memory v,\n', '        bytes32[] memory r,\n', '        bytes32[] memory s)\n', '        public\n', '        returns (bool)\n', '    {\n', '        // Ensure the sender is authorized.\n', '        require(admins[msg.sender]);\n', '\n', '        // These checks replay protection, so it cannot be replayed on forks,\n', '        // accidentally or intentionally\n', '        require(blockhash(_recentNumber) == _recentHash);\n', '\n', '        // Ensure the batch of signatures are valid.\n', '        require(v.length == r.length);\n', '        require(v.length == s.length);\n', '\n', '        // Filter out "future" checkpoint.\n', '        if (block.number < (_sectionIndex+1)*sectionSize+processConfirms) {\n', '            return false;\n', '        }\n', '        // Filter out "old" announcement\n', '        if (_sectionIndex < sectionIndex) {\n', '            return false;\n', '        }\n', '        // Filter out "stale" announcement\n', '        if (_sectionIndex == sectionIndex && (_sectionIndex != 0 || height != 0)) {\n', '            return false;\n', '        }\n', '        // Filter out "invalid" announcement\n', '        if (_hash == ""){\n', '            return false;\n', '        }\n', '\n', '        // EIP 191 style signatures\n', '        //\n', '        // Arguments when calculating hash to validate\n', '        // 1: byte(0x19) - the initial 0x19 byte\n', '        // 2: byte(0) - the version byte (data with intended validator)\n', '        // 3: this - the validator address\n', '        // --  Application specific data\n', '        // 4 : checkpoint section_index(uint64)\n', '        // 5 : checkpoint hash (bytes32)\n', '        //     hash = keccak256(checkpoint_index, section_head, cht_root, bloom_root)\n', '        bytes32 signedHash = keccak256(abi.encodePacked(byte(0x19), byte(0), this, _sectionIndex, _hash));\n', '\n', '        address lastVoter = address(0);\n', '\n', '        // In order for us not to have to maintain a mapping of who has already\n', '        // voted, and we don&#39;t want to count a vote twice, the signatures must\n', '        // be submitted in strict ordering.\n', '        for (uint idx = 0; idx < v.length; idx++){\n', '            address signer = ecrecover(signedHash, v[idx], r[idx], s[idx]);\n', '            require(admins[signer]);\n', '            require(uint256(signer) > uint256(lastVoter));\n', '            lastVoter = signer;\n', '            emit NewCheckpointVote(_sectionIndex, _hash, v[idx], r[idx], s[idx]);\n', '\n', '            // Sufficient signatures present, update latest checkpoint.\n', '            if (idx+1 >= threshold){\n', '                hash = _hash;\n', '                height = block.number;\n', '                sectionIndex = _sectionIndex;\n', '                return true;\n', '            }\n', '        }\n', '        // We shouldn&#39;t wind up here, reverting un-emits the events\n', '        revert();\n', '    }\n', '\n', '    /**\n', '     * @dev Get all admin addresses\n', '     * @return address list\n', '     */\n', '    function GetAllAdmin()\n', '    public\n', '    view\n', '    returns(address[] memory)\n', '    {\n', '        address[] memory ret = new address[](adminList.length);\n', '        for (uint i = 0; i < adminList.length; i++) {\n', '            ret[i] = adminList[i];\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '        Fields\n', '    */\n', '    // A map of admin users who have the permission to update CHT and bloom Trie root\n', '    mapping(address => bool) admins;\n', '\n', '    // A list of admin users so that we can obtain all admin users.\n', '    address[] adminList;\n', '\n', '    // Latest stored section id\n', '    uint64 sectionIndex;\n', '\n', '    // The block height associated with latest registered checkpoint.\n', '    uint height;\n', '\n', '    // The hash of latest registered checkpoint.\n', '    bytes32 hash;\n', '\n', '    // The frequency for creating a checkpoint\n', '    //\n', '    // The default value should be the same as the checkpoint size(32768) in the ethereum.\n', '    uint sectionSize;\n', '\n', '    // The number of confirmations needed before a checkpoint can be registered.\n', '    // We have to make sure the checkpoint registered will not be invalid due to\n', '    // chain reorg.\n', '    //\n', '    // The default value should be the same as the checkpoint process confirmations(256)\n', '    // in the ethereum.\n', '    uint processConfirms;\n', '\n', '    // The required signatures to finalize a stable checkpoint.\n', '    uint threshold;\n', '}']