['pragma solidity 0.5.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @dev Standard interface for a dex proxy contract.\n', ' */\n', 'interface Proxy {\n', '\n', '  /**\n', '   * @dev Executes an action.\n', '   * @param _target Target of execution.\n', '   * @param _a Address usually represention from.\n', '   * @param _b Address usually representing to.\n', '   * @param _c Integer usually repersenting amount/value/id.\n', '   */\n', '  function execute(\n', '    address _target,\n', '    address _a,\n', '    address _b,\n', '    uint256 _c\n', '  )\n', '    external;\n', '    \n', '}\n', '\n', '/**\n', ' * @dev Xcert interface.\n', ' */\n', 'interface Xcert // is ERC721 metadata enumerable\n', '{\n', '\n', '  /**\n', '   * @dev Creates a new Xcert.\n', '   * @param _to The address that will own the created Xcert.\n', '   * @param _id The Xcert to be created by the msg.sender.\n', '   * @param _imprint Cryptographic asset imprint.\n', '   */\n', '  function create(\n', '    address _to,\n', '    uint256 _id,\n', '    bytes32 _imprint\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Change URI base.\n', '   * @param _uriBase New uriBase.\n', '   */\n', '  function setUriBase(\n', '    string calldata _uriBase\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert Protocol convention.\n', '   * @return Schema id.\n', '   */\n', '  function schemaId()\n', '    external\n', '    view\n', '    returns (bytes32 _schemaId);\n', '\n', '  /**\n', '   * @dev Returns imprint for Xcert.\n', '   * @param _tokenId Id of the Xcert.\n', '   * @return Token imprint.\n', '   */\n', '  function tokenImprint(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns(bytes32 imprint);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error. This contract is based on the \n', ' * source code at: \n', ' * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\n', ' */\n', 'library SafeMath\n', '{\n', '\n', '  /**\n', '   * @dev Error constants.\n', '   */\n', '  string constant OVERFLOW = "008001";\n', '  string constant SUBTRAHEND_GREATER_THEN_MINUEND = "008002";\n', '  string constant DIVISION_BY_ZERO = "008003";\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, reverts on overflow.\n', '   * @param _factor1 Factor number.\n', '   * @param _factor2 Factor number.\n', '   * @return The product of the two factors.\n', '   */\n', '  function mul(\n', '    uint256 _factor1,\n', '    uint256 _factor2\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 product)\n', '  {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_factor1 == 0)\n', '    {\n', '      return 0;\n', '    }\n', '\n', '    product = _factor1 * _factor2;\n', '    require(product / _factor1 == _factor2, OVERFLOW);\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\n', '   * @param _dividend Dividend number.\n', '   * @param _divisor Divisor number.\n', '   * @return The quotient.\n', '   */\n', '  function div(\n', '    uint256 _dividend,\n', '    uint256 _divisor\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 quotient)\n', '  {\n', '    // Solidity automatically asserts when dividing by 0, using all gas.\n', '    require(_divisor > 0, DIVISION_BY_ZERO);\n', '    quotient = _dividend / _divisor;\n', "    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\n", '  }\n', '\n', '  /**\n', '   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '   * @param _minuend Minuend number.\n', '   * @param _subtrahend Subtrahend number.\n', '   * @return Difference.\n', '   */\n', '  function sub(\n', '    uint256 _minuend,\n', '    uint256 _subtrahend\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 difference)\n', '  {\n', '    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n', '    difference = _minuend - _subtrahend;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two numbers, reverts on overflow.\n', '   * @param _addend1 Number.\n', '   * @param _addend2 Number.\n', '   * @return Sum.\n', '   */\n', '  function add(\n', '    uint256 _addend1,\n', '    uint256 _addend2\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 sum)\n', '  {\n', '    sum = _addend1 + _addend2;\n', '    require(sum >= _addend1, OVERFLOW);\n', '  }\n', '\n', '  /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\n', '    * dividing by zero.\n', '    * @param _dividend Number.\n', '    * @param _divisor Number.\n', '    * @return Remainder.\n', '    */\n', '  function mod(\n', '    uint256 _dividend,\n', '    uint256 _divisor\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 remainder) \n', '  {\n', '    require(_divisor != 0, DIVISION_BY_ZERO);\n', '    remainder = _dividend % _divisor;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Contract for setting abilities.\n', ' * @dev For optimization purposes the abilities are represented as a bitfield. Maximum number of\n', ' * abilities is therefore 256. This is an example(for simplicity is made for max 8 abilities) of how\n', ' * this works. \n', ' * 00000001 Ability A - number representation 1\n', ' * 00000010 Ability B - number representation 2\n', ' * 00000100 Ability C - number representation 4\n', ' * 00001000 Ability D - number representation 8\n', ' * 00010000 Ability E - number representation 16\n', ' * etc ... \n', ' * To grant abilities B and C, we would need a bitfield of 00000110 which is represented by number\n', ' * 6, in other words, the sum of abilities B and C. The same concept works for revoking abilities\n', ' * and checking if someone has multiple abilities.\n', ' */\n', 'contract Abilitable\n', '{\n', '  using SafeMath for uint;\n', '\n', '  /**\n', '   * @dev Error constants.\n', '   */\n', '  string constant NOT_AUTHORIZED = "017001";\n', '  string constant ONE_ZERO_ABILITY_HAS_TO_EXIST = "017002";\n', '  string constant INVALID_INPUT = "017003";\n', '\n', '  /**\n', '   * @dev Ability 1 is a reserved ability. It is an ability to grant or revoke abilities. \n', '   * There can be minimum of 1 address with ability 1.\n', '   * Other abilities are determined by implementing contract.\n', '   */\n', '  uint8 constant ABILITY_TO_MANAGE_ABILITIES = 1;\n', '\n', '  /**\n', '   * @dev Maps address to ability ids.\n', '   */\n', '  mapping(address => uint256) public addressToAbility;\n', '\n', '  /**\n', '   * @dev Count of zero ability addresses.\n', '   */\n', '  uint256 private zeroAbilityCount;\n', '\n', '  /**\n', '   * @dev Emits when an address is granted an ability.\n', '   * @param _target Address to which we are granting abilities.\n', '   * @param _abilities Number representing bitfield of abilities we are granting.\n', '   */\n', '  event GrantAbilities(\n', '    address indexed _target,\n', '    uint256 indexed _abilities\n', '  );\n', '\n', '  /**\n', '   * @dev Emits when an address gets an ability revoked.\n', '   * @param _target Address of which we are revoking an ability.\n', '   * @param _abilities Number representing bitfield of abilities we are revoking.\n', '   */\n', '  event RevokeAbilities(\n', '    address indexed _target,\n', '    uint256 indexed _abilities\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that msg.sender has certain abilities.\n', '   */\n', '  modifier hasAbilities(\n', '    uint256 _abilities\n', '  ) \n', '  {\n', '    require(_abilities > 0, INVALID_INPUT);\n', '    require(\n', '      (addressToAbility[msg.sender] & _abilities) == _abilities,\n', '      NOT_AUTHORIZED\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * Sets ABILITY_TO_MANAGE_ABILITIES ability to the sender account.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    addressToAbility[msg.sender] = ABILITY_TO_MANAGE_ABILITIES;\n', '    zeroAbilityCount = 1;\n', '    emit GrantAbilities(msg.sender, ABILITY_TO_MANAGE_ABILITIES);\n', '  }\n', '\n', '  /**\n', '   * @dev Grants specific abilities to specified address.\n', '   * @param _target Address to grant abilities to.\n', '   * @param _abilities Number representing bitfield of abilities we are granting.\n', '   */\n', '  function grantAbilities(\n', '    address _target,\n', '    uint256 _abilities\n', '  )\n', '    external\n', '    hasAbilities(ABILITY_TO_MANAGE_ABILITIES)\n', '  {\n', '    addressToAbility[_target] |= _abilities;\n', '\n', '    if((_abilities & ABILITY_TO_MANAGE_ABILITIES) == ABILITY_TO_MANAGE_ABILITIES)\n', '    {\n', '      zeroAbilityCount = zeroAbilityCount.add(1);\n', '    }\n', '    emit GrantAbilities(_target, _abilities);\n', '  }\n', '\n', '  /**\n', '   * @dev Unassigns specific abilities from specified address.\n', '   * @param _target Address of which we revoke abilites.\n', '   * @param _abilities Number representing bitfield of abilities we are revoking.\n', '   */\n', '  function revokeAbilities(\n', '    address _target,\n', '    uint256 _abilities\n', '  )\n', '    external\n', '    hasAbilities(ABILITY_TO_MANAGE_ABILITIES)\n', '  {\n', '    addressToAbility[_target] &= ~_abilities;\n', '    if((_abilities & 1) == 1)\n', '    {\n', '      require(zeroAbilityCount > 1, ONE_ZERO_ABILITY_HAS_TO_EXIST);\n', '      zeroAbilityCount--;\n', '    }\n', '    emit RevokeAbilities(_target, _abilities);\n', '  }\n', '\n', '  /**\n', '   * @dev Check if an address has a specific ability. Throws if checking for 0.\n', '   * @param _target Address for which we want to check if it has a specific abilities.\n', '   * @param _abilities Number representing bitfield of abilities we are checking.\n', '   */\n', '  function isAble(\n', '    address _target,\n', '    uint256 _abilities\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_abilities > 0, INVALID_INPUT);\n', '    return (addressToAbility[_target] & _abilities) == _abilities;\n', '  }\n', '  \n', '}\n', '\n', '/**\n', ' * @title XcertCreateProxy - creates a token on behalf of contracts that have been approved via\n', ' * decentralized governance.\n', ' */\n', 'contract XcertCreateProxy is \n', '  Abilitable \n', '{\n', '\n', '  /**\n', '   * @dev List of abilities:\n', '   * 2 - Ability to execute create. \n', '   */\n', '  uint8 constant ABILITY_TO_EXECUTE = 2;\n', '\n', '  /**\n', '   * @dev Creates a new NFT.\n', '   * @param _xcert Address of the Xcert contract on which the creation will be perfomed.\n', '   * @param _to The address that will own the created NFT.\n', '   * @param _id The NFT to be created by the msg.sender.\n', '   * @param _imprint Cryptographic asset imprint.\n', '   */\n', '  function create(\n', '    address _xcert,\n', '    address _to,\n', '    uint256 _id,\n', '    bytes32 _imprint\n', '  )\n', '    external\n', '    hasAbilities(ABILITY_TO_EXECUTE)\n', '  {\n', '    Xcert(_xcert).create(_to, _id, _imprint);\n', '  }\n', '  \n', '}\n', '\n', '/**\n', ' * @dev Decentralize exchange, creating, updating and other actions for fundgible and non-fundgible \n', ' * tokens powered by atomic swaps. \n', ' */\n', 'contract OrderGateway is\n', '  Abilitable\n', '{\n', '\n', '  /**\n', '   * @dev List of abilities:\n', '   * 1 - Ability to set proxies.\n', '   */\n', '  uint8 constant ABILITY_TO_SET_PROXIES = 2;\n', '\n', '  /**\n', '   * @dev Xcert abilities.\n', '   */\n', '  uint8 constant ABILITY_ALLOW_CREATE_ASSET = 32;\n', '\n', '  /**\n', '   * @dev Error constants.\n', '   */\n', '  string constant INVALID_SIGNATURE_KIND = "015001";\n', '  string constant INVALID_PROXY = "015002";\n', '  string constant TAKER_NOT_EQUAL_TO_SENDER = "015003";\n', '  string constant SENDER_NOT_TAKER_OR_MAKER = "015004";\n', '  string constant CLAIM_EXPIRED = "015005";\n', '  string constant INVALID_SIGNATURE = "015006";\n', '  string constant ORDER_CANCELED = "015007";\n', '  string constant ORDER_ALREADY_PERFORMED = "015008";\n', '  string constant MAKER_NOT_EQUAL_TO_SENDER = "015009";\n', '  string constant SIGNER_NOT_AUTHORIZED = "015010";\n', '\n', '  /**\n', '   * @dev Enum of available signature kinds.\n', '   * @param eth_sign Signature using eth sign.\n', '   * @param trezor Signature from Trezor hardware wallet.\n', '   * It differs from web3.eth_sign in the encoding of message length\n', '   * (Bitcoin varint encoding vs ascii-decimal, the latter is not\n', '   * self-terminating which leads to ambiguities).\n', '   * See also:\n', '   * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n', '   * https://github.com/trezor/trezor-mcu/blob/master/firmware/ethereum.c#L602\n', '   * https://github.com/trezor/trezor-mcu/blob/master/firmware/crypto.c#L36 \n', '   * @param eip721 Signature using eip721.\n', '   */\n', '  enum SignatureKind\n', '  {\n', '    eth_sign,\n', '    trezor,\n', '    eip712\n', '  }\n', '\n', '  /**\n', '   * Enum of available action kinds.\n', '   */\n', '  enum ActionKind\n', '  {\n', '    create,\n', '    transfer\n', '  }\n', '\n', '  /**\n', '   * @dev Structure representing what to send and where.\n', '   * @param token Address of the token we are sending.\n', '   * @param proxy Id representing approved proxy address.\n', '   * @param param1 Address of the sender or imprint.\n', '   * @param to Address of the receiver.\n', '   * @param value Amount of ERC20 or ID of ERC721.\n', '   */\n', '  struct ActionData \n', '  {\n', '    ActionKind kind;\n', '    uint32 proxy;\n', '    address token;\n', '    bytes32 param1;\n', '    address to;\n', '    uint256 value;\n', '  }\n', '\n', '  /**\n', '   * @dev Structure representing the signature parts.\n', '   * @param r ECDSA signature parameter r.\n', '   * @param s ECDSA signature parameter s.\n', '   * @param v ECDSA signature parameter v.\n', '   * @param kind Type of signature. \n', '   */\n', '  struct SignatureData\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '    SignatureKind kind;\n', '  }\n', '\n', '  /**\n', '   * @dev Structure representing the data needed to do the order.\n', '   * @param maker Address of the one that made the claim.\n', '   * @param taker Address of the one that is executing the claim.\n', '   * @param actions Data of all the actions that should accure it this order.\n', '   * @param signature Data from the signed claim.\n', "   * @param seed Arbitrary number to facilitate uniqueness of the order's hash. Usually timestamp.\n", '   * @param expiration Timestamp of when the claim expires. 0 if indefinet. \n', '   */\n', '  struct OrderData \n', '  {\n', '    address maker;\n', '    address taker;\n', '    ActionData[] actions;\n', '    uint256 seed;\n', '    uint256 expiration;\n', '  }\n', '\n', '  /** \n', '   * @dev Valid proxy contract addresses.\n', '   */\n', '  mapping(uint32 => address) public idToProxy;\n', '\n', '  /**\n', '   * @dev Mapping of all cancelled orders.\n', '   */\n', '  mapping(bytes32 => bool) public orderCancelled;\n', '\n', '  /**\n', '   * @dev Mapping of all performed orders.\n', '   */\n', '  mapping(bytes32 => bool) public orderPerformed;\n', '\n', '  /**\n', '   * @dev This event emmits when tokens change ownership.\n', '   */\n', '  event Perform(\n', '    address indexed _maker,\n', '    address indexed _taker,\n', '    bytes32 _claim\n', '  );\n', '\n', '  /**\n', '   * @dev This event emmits when transfer order is cancelled.\n', '   */\n', '  event Cancel(\n', '    address indexed _maker,\n', '    address indexed _taker,\n', '    bytes32 _claim\n', '  );\n', '\n', '  /**\n', '   * @dev This event emmits when proxy address is changed..\n', '   */\n', '  event ProxyChange(\n', '    uint32 indexed _id,\n', '    address _proxy\n', '  );\n', '\n', '  /**\n', '   * @dev Sets a verified proxy address. \n', '   * @notice Can be done through a multisig wallet in the future.\n', '   * @param _id Id of the proxy.\n', '   * @param _proxy Proxy address.\n', '   */\n', '  function setProxy(\n', '    uint32 _id,\n', '    address _proxy\n', '  )\n', '    external\n', '    hasAbilities(ABILITY_TO_SET_PROXIES)\n', '  {\n', '    idToProxy[_id] = _proxy;\n', '    emit ProxyChange(_id, _proxy);\n', '  }\n', '\n', '  /**\n', '   * @dev Performs the ERC721/ERC20 atomic swap.\n', '   * @param _data Data required to make the order.\n', '   * @param _signature Data from the signature. \n', '   */\n', '  function perform(\n', '    OrderData memory _data,\n', '    SignatureData memory _signature\n', '  )\n', '    public \n', '  {\n', '    require(_data.taker == msg.sender, TAKER_NOT_EQUAL_TO_SENDER);\n', '    require(_data.expiration >= now, CLAIM_EXPIRED);\n', '\n', '    bytes32 claim = getOrderDataClaim(_data);\n', '    require(\n', '      isValidSignature(\n', '        _data.maker,\n', '        claim,\n', '        _signature\n', '      ), \n', '      INVALID_SIGNATURE\n', '    );\n', '\n', '    require(!orderCancelled[claim], ORDER_CANCELED);\n', '    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\n', '\n', '    orderPerformed[claim] = true;\n', '\n', '    _doActions(_data);\n', '\n', '    emit Perform(\n', '      _data.maker,\n', '      _data.taker,\n', '      claim\n', '    );\n', '  }\n', '\n', '  /** \n', '   * @dev Cancels order\n', '   * @param _data Data of order to cancel.\n', '   */\n', '  function cancel(\n', '    OrderData memory _data\n', '  )\n', '    public\n', '  {\n', '    require(_data.maker == msg.sender, MAKER_NOT_EQUAL_TO_SENDER);\n', '\n', '    bytes32 claim = getOrderDataClaim(_data);\n', '    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\n', '\n', '    orderCancelled[claim] = true;\n', '    emit Cancel(\n', '      _data.maker,\n', '      _data.taker,\n', '      claim\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates keccak-256 hash of OrderData from parameters.\n', '   * @param _orderData Data needed for atomic swap.\n', '   * @return keccak-hash of order data.\n', '   */\n', '  function getOrderDataClaim(\n', '    OrderData memory _orderData\n', '  )\n', '    public\n', '    view\n', '    returns (bytes32)\n', '  {\n', '    bytes32 temp = 0x0;\n', '\n', '    for(uint256 i = 0; i < _orderData.actions.length; i++)\n', '    {\n', '      temp = keccak256(\n', '        abi.encodePacked(\n', '          temp,\n', '          _orderData.actions[i].kind,\n', '          _orderData.actions[i].proxy,\n', '          _orderData.actions[i].token,\n', '          _orderData.actions[i].param1,\n', '          _orderData.actions[i].to,\n', '          _orderData.actions[i].value\n', '        )\n', '      );\n', '    }\n', '\n', '    return keccak256(\n', '      abi.encodePacked(\n', '        address(this),\n', '        _orderData.maker,\n', '        _orderData.taker,\n', '        temp,\n', '        _orderData.seed,\n', '        _orderData.expiration\n', '      )\n', '    );\n', '  }\n', '  \n', '  /**\n', '   * @dev Verifies if claim signature is valid.\n', '   * @param _signer address of signer.\n', '   * @param _claim Signed Keccak-256 hash.\n', '   * @param _signature Signature data.\n', '   */\n', '  function isValidSignature(\n', '    address _signer,\n', '    bytes32 _claim,\n', '    SignatureData memory _signature\n', '  )\n', '    public\n', '    pure\n', '    returns (bool)\n', '  {\n', '    if(_signature.kind == SignatureKind.eth_sign)\n', '    {\n', '      return _signer == ecrecover(\n', '        keccak256(\n', '          abi.encodePacked(\n', '            "\\x19Ethereum Signed Message:\\n32",\n', '            _claim\n', '          )\n', '        ),\n', '        _signature.v,\n', '        _signature.r,\n', '        _signature.s\n', '      );\n', '    } else if (_signature.kind == SignatureKind.trezor)\n', '    {\n', '      return _signer == ecrecover(\n', '        keccak256(\n', '          abi.encodePacked(\n', '            "\\x19Ethereum Signed Message:\\n\\x20",\n', '            _claim\n', '          )\n', '        ),\n', '        _signature.v,\n', '        _signature.r,\n', '        _signature.s\n', '      );\n', '    } else if (_signature.kind == SignatureKind.eip712)\n', '    {\n', '      return _signer == ecrecover(\n', '        _claim,\n', '        _signature.v,\n', '        _signature.r,\n', '        _signature.s\n', '      );\n', '    }\n', '\n', '    revert(INVALID_SIGNATURE_KIND);\n', '  }\n', '\n', '  /**\n', '   * @dev Helper function that makes transfes.\n', '   * @param _order Data needed for order.\n', '   */\n', '  function _doActions(\n', '    OrderData memory _order\n', '  )\n', '    private\n', '  {\n', '    for(uint256 i = 0; i < _order.actions.length; i++)\n', '    {\n', '      require(\n', '        idToProxy[_order.actions[i].proxy] != address(0),\n', '        INVALID_PROXY\n', '      );\n', '\n', '      if(_order.actions[i].kind == ActionKind.create)\n', '      {\n', '        require(\n', '          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_CREATE_ASSET),\n', '          SIGNER_NOT_AUTHORIZED\n', '        );\n', '        \n', '        XcertCreateProxy(idToProxy[_order.actions[i].proxy]).create(\n', '          _order.actions[i].token,\n', '          _order.actions[i].to,\n', '          _order.actions[i].value,\n', '          _order.actions[i].param1\n', '        );\n', '      } \n', '      else if (_order.actions[i].kind == ActionKind.transfer)\n', '      {\n', '        address from = address(uint160(bytes20(_order.actions[i].param1)));\n', '        require(\n', '          from == _order.maker\n', '          || from == _order.taker,\n', '          SENDER_NOT_TAKER_OR_MAKER\n', '        );\n', '        \n', '        Proxy(idToProxy[_order.actions[i].proxy]).execute(\n', '          _order.actions[i].token,\n', '          from,\n', '          _order.actions[i].to,\n', '          _order.actions[i].value\n', '        );\n', '      }\n', '    }\n', '  }\n', '  \n', '}']