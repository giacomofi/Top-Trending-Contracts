['pragma solidity ^0.4.24;\n', '\n', '// File: Multiownable/contracts/Multiownable.sol\n', '\n', 'contract Multiownable {\n', '\n', '    // VARIABLES\n', '\n', '    uint256 public ownersGeneration;\n', '    uint256 public howManyOwnersDecide;\n', '    address[] public owners;\n', '    bytes32[] public allOperations;\n', '    address internal insideCallSender;\n', '    uint256 internal insideCallCount;\n', '\n', '    // Reverse lookup tables for owners and allOperations\n', '    mapping(address => uint) public ownersIndices; // Starts from 1\n', '    mapping(bytes32 => uint) public allOperationsIndicies;\n', '\n', '    // Owners voting mask per operations\n', '    mapping(bytes32 => uint256) public votesMaskByOperation;\n', '    mapping(bytes32 => uint256) public votesCountByOperation;\n', '\n', '    // EVENTS\n', '\n', '    event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide);\n', '    event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer);\n', '    event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter);\n', '    event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer);\n', '    event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter);\n', '    event OperationCancelled(bytes32 operation, address lastCanceller);\n', '    \n', '    // ACCESSORS\n', '\n', '    function isOwner(address wallet) public constant returns(bool) {\n', '        return ownersIndices[wallet] > 0;\n', '    }\n', '\n', '    function ownersCount() public constant returns(uint) {\n', '        return owners.length;\n', '    }\n', '\n', '    function allOperationsCount() public constant returns(uint) {\n', '        return allOperations.length;\n', '    }\n', '\n', '    // MODIFIERS\n', '\n', '    /**\n', '    * @dev Allows to perform method by any of the owners\n', '    */\n', '    modifier onlyAnyOwner {\n', '        if (checkHowManyOwners(1)) {\n', '            bool update = (insideCallSender == address(0));\n', '            if (update) {\n', '                insideCallSender = msg.sender;\n', '                insideCallCount = 1;\n', '            }\n', '            _;\n', '            if (update) {\n', '                insideCallSender = address(0);\n', '                insideCallCount = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows to perform method only after many owners call it with the same arguments\n', '    */\n', '    modifier onlyManyOwners {\n', '        if (checkHowManyOwners(howManyOwnersDecide)) {\n', '            bool update = (insideCallSender == address(0));\n', '            if (update) {\n', '                insideCallSender = msg.sender;\n', '                insideCallCount = howManyOwnersDecide;\n', '            }\n', '            _;\n', '            if (update) {\n', '                insideCallSender = address(0);\n', '                insideCallCount = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows to perform method only after all owners call it with the same arguments\n', '    */\n', '    modifier onlyAllOwners {\n', '        if (checkHowManyOwners(owners.length)) {\n', '            bool update = (insideCallSender == address(0));\n', '            if (update) {\n', '                insideCallSender = msg.sender;\n', '                insideCallCount = owners.length;\n', '            }\n', '            _;\n', '            if (update) {\n', '                insideCallSender = address(0);\n', '                insideCallCount = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows to perform method only after some owners call it with the same arguments\n', '    */\n', '    modifier onlySomeOwners(uint howMany) {\n', '        require(howMany > 0, "onlySomeOwners: howMany argument is zero");\n', '        require(howMany <= owners.length, "onlySomeOwners: howMany argument exceeds the number of owners");\n', '        \n', '        if (checkHowManyOwners(howMany)) {\n', '            bool update = (insideCallSender == address(0));\n', '            if (update) {\n', '                insideCallSender = msg.sender;\n', '                insideCallCount = howMany;\n', '            }\n', '            _;\n', '            if (update) {\n', '                insideCallSender = address(0);\n', '                insideCallCount = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    // CONSTRUCTOR\n', '\n', '    constructor() public {\n', '        owners.push(msg.sender);\n', '        ownersIndices[msg.sender] = 1;\n', '        howManyOwnersDecide = 1;\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '\n', '    /**\n', '     * @dev onlyManyOwners modifier helper\n', '     */\n', '    function checkHowManyOwners(uint howMany) internal returns(bool) {\n', '        if (insideCallSender == msg.sender) {\n', '            require(howMany <= insideCallCount, "checkHowManyOwners: nested owners modifier check require more owners");\n', '            return true;\n', '        }\n', '\n', '        uint ownerIndex = ownersIndices[msg.sender] - 1;\n', '        require(ownerIndex < owners.length, "checkHowManyOwners: msg.sender is not an owner");\n', '        bytes32 operation = keccak256(msg.data, ownersGeneration);\n', '\n', '        require((votesMaskByOperation[operation] & (2 ** ownerIndex)) == 0, "checkHowManyOwners: owner already voted for the operation");\n', '        votesMaskByOperation[operation] |= (2 ** ownerIndex);\n', '        uint operationVotesCount = votesCountByOperation[operation] + 1;\n', '        votesCountByOperation[operation] = operationVotesCount;\n', '        if (operationVotesCount == 1) {\n', '            allOperationsIndicies[operation] = allOperations.length;\n', '            allOperations.push(operation);\n', '            emit OperationCreated(operation, howMany, owners.length, msg.sender);\n', '        }\n', '        emit OperationUpvoted(operation, operationVotesCount, howMany, owners.length, msg.sender);\n', '\n', '        // If enough owners confirmed the same operation\n', '        if (votesCountByOperation[operation] == howMany) {\n', '            deleteOperation(operation);\n', '            emit OperationPerformed(operation, howMany, owners.length, msg.sender);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '    * @dev Used to delete cancelled or performed operation\n', '    * @param operation defines which operation to delete\n', '    */\n', '    function deleteOperation(bytes32 operation) internal {\n', '        uint index = allOperationsIndicies[operation];\n', '        if (index < allOperations.length - 1) { // Not last\n', '            allOperations[index] = allOperations[allOperations.length - 1];\n', '            allOperationsIndicies[allOperations[index]] = index;\n', '        }\n', '        allOperations.length--;\n', '\n', '        delete votesMaskByOperation[operation];\n', '        delete votesCountByOperation[operation];\n', '        delete allOperationsIndicies[operation];\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '    * @dev Allows owners to change their mind by cacnelling votesMaskByOperation operations\n', '    * @param operation defines which operation to delete\n', '    */\n', '    function cancelPending(bytes32 operation) public onlyAnyOwner {\n', '        uint ownerIndex = ownersIndices[msg.sender] - 1;\n', '        require((votesMaskByOperation[operation] & (2 ** ownerIndex)) != 0, "cancelPending: operation not found for this user");\n', '        votesMaskByOperation[operation] &= ~(2 ** ownerIndex);\n', '        uint operationVotesCount = votesCountByOperation[operation] - 1;\n', '        votesCountByOperation[operation] = operationVotesCount;\n', '        emit OperationDownvoted(operation, operationVotesCount, owners.length, msg.sender);\n', '        if (operationVotesCount == 0) {\n', '            deleteOperation(operation);\n', '            emit OperationCancelled(operation, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows owners to change ownership\n', '    * @param newOwners defines array of addresses of new owners\n', '    */\n', '    function transferOwnership(address[] newOwners) public {\n', '        transferOwnershipWithHowMany(newOwners, newOwners.length);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows owners to change ownership\n', '    * @param newOwners defines array of addresses of new owners\n', '    * @param newHowManyOwnersDecide defines how many owners can decide\n', '    */\n', '    function transferOwnershipWithHowMany(address[] newOwners, uint256 newHowManyOwnersDecide) public onlyManyOwners {\n', '        require(newOwners.length > 0, "transferOwnershipWithHowMany: owners array is empty");\n', '        require(newOwners.length <= 256, "transferOwnershipWithHowMany: owners count is greater then 256");\n', '        require(newHowManyOwnersDecide > 0, "transferOwnershipWithHowMany: newHowManyOwnersDecide equal to 0");\n', '        require(newHowManyOwnersDecide <= newOwners.length, "transferOwnershipWithHowMany: newHowManyOwnersDecide exceeds the number of owners");\n', '\n', '        // Reset owners reverse lookup table\n', '        for (uint j = 0; j < owners.length; j++) {\n', '            delete ownersIndices[owners[j]];\n', '        }\n', '        for (uint i = 0; i < newOwners.length; i++) {\n', '            require(newOwners[i] != address(0), "transferOwnershipWithHowMany: owners array contains zero");\n', '            require(ownersIndices[newOwners[i]] == 0, "transferOwnershipWithHowMany: owners array contains duplicates");\n', '            ownersIndices[newOwners[i]] = i + 1;\n', '        }\n', '        \n', '        emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide);\n', '        owners = newOwners;\n', '        howManyOwnersDecide = newHowManyOwnersDecide;\n', '        allOperations.length = 0;\n', '        ownersGeneration++;\n', '    }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/BadERC20Aware.sol\n', '\n', 'library BadERC20Aware {\n', '    using SafeMath for uint;\n', '\n', '    function isContract(address addr) internal view returns(bool result) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            result := gt(extcodesize(addr), 0)\n', '        }\n', '    }\n', '\n', '    function handleReturnBool() internal pure returns(bool result) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 { // not a std erc20\n', '                result := 1\n', '            }\n', '            case 32 { // std erc20\n', '                returndatacopy(0, 0, 32)\n', '                result := mload(0)\n', '            }\n', '            default { // anything else, should revert for safety\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '    function asmTransfer(ERC20 _token, address _to, uint256 _value) internal returns(bool) {\n', '        require(isContract(_token));\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        require(address(_token).call(bytes4(keccak256("transfer(address,uint256)")), _to, _value));\n', '        return handleReturnBool();\n', '    }\n', '\n', '    function safeTransfer(ERC20 _token, address _to, uint256 _value) internal {\n', '        require(asmTransfer(_token, _to, _value));\n', '    }\n', '}\n', '\n', '// File: contracts/TokenSwap.sol\n', '\n', '/**\n', ' * @title TokenSwap\n', ' * This product is protected under license.  Any unauthorized copy, modification, or use without\n', ' * express written consent from the creators is prohibited.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenSwap is Ownable, Multiownable {\n', '\n', '    // LIBRARIES\n', '\n', '    using BadERC20Aware for ERC20;\n', '    using SafeMath for uint256;\n', '\n', '    // TYPES\n', '\n', '    enum Status {AddParties, WaitingDeposits, SwapConfirmed, SwapCanceled}\n', '\n', '    struct SwapOffer {\n', '        address participant;\n', '        ERC20 token;\n', '\n', '        uint256 tokensTotal;\n', '        uint256 withdrawnTokensTotal;\n', '    }\n', '\n', '    struct LockupStage {\n', '        uint256 secondsSinceLockupStart;\n', '        uint8 unlockedTokensPercentage;\n', '    }\n', '\n', '    // VARIABLES\n', '    Status public status = Status.AddParties;\n', '\n', '    address[] internal participants;\n', '    mapping(address => bool) internal isParticipant;\n', '    mapping(address => address) internal tokenByParticipant;\n', '    mapping(address => SwapOffer) internal offerByToken;\n', '\n', '    uint256 internal startLockupAt;\n', '    mapping(address => LockupStage[]) internal lockupStagesByToken;\n', '\n', '    address[] internal receivers;\n', '    mapping(address => bool) internal isReceiver;\n', '    mapping(address => bool) internal isTokenAllocated;\n', '    mapping(address => mapping(address => uint256)) internal allocatedTokens;\n', '    mapping(address => mapping(address => uint256)) internal withdrawnTokens;\n', '\n', '    // EVENTS\n', '    event StatusUpdate(Status oldStatus, Status newStatus);\n', '    event AddParty(address participant, ERC20 token, uint256 tokensTotal);\n', '    event AddTokenAllocation(ERC20 token, address receiver, uint256 amount);\n', '    event AddLockupStage(\n', '        ERC20 token,\n', '        uint256 secondsSinceLockupStart,\n', '        uint8 unlockedTokensPercentage\n', '    );\n', '    event ConfirmParties();\n', '    event CancelSwap();\n', '    event ConfirmSwap();\n', '    event StartLockup(uint256 startLockupAt);\n', '    event Withdraw(address participant, ERC20 token, uint256 amount);\n', '    event WithdrawFee(ERC20 token, uint256 amount);\n', '    event Reclaim(address participant, ERC20 token, uint256 amount);\n', '    event SoftEmergency(ERC20 token, address receiver, uint256 amount);\n', '    event HardEmergency(ERC20 token, address receiver, uint256 amount);\n', '\n', '    // MODIFIERS\n', '    modifier onlyParticipant {\n', '        require(\n', '            isParticipant[msg.sender] == true,\n', '            "Only swap participants allowed to call the method"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyReceiver {\n', '        require(\n', '            isReceiver[msg.sender] == true,\n', '            "Only token receivers allowed to call the method"\n', '        );\n', '       _;\n', '    }\n', '\n', '    modifier canTransferOwnership {\n', '        require(status == Status.AddParties, "Unable to transfer ownership in the current status");\n', '        _;\n', '    }\n', '\n', '    modifier canAddParty {\n', '        require(status == Status.AddParties, "Unable to add new parties in the current status");\n', '        _;\n', '    }\n', '\n', '    modifier canAddLockupPeriod {\n', '        require(status == Status.AddParties, "Unable to add lockup period in the current status");\n', '        _;\n', '    }\n', '\n', '    modifier canAddTokenAllocation {\n', '        require(\n', '            status == Status.AddParties,\n', '            "Unable to add token allocation in the current status"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier canConfirmParties {\n', '        require(\n', '            status == Status.AddParties,\n', '            "Unable to confirm parties in the current status"\n', '        );\n', '        require(participants.length > 1, "Need at least two participants");\n', '        require(_doesEveryTokenHaveLockupPeriod(), "Each token must have lockup period");\n', '        require(_isEveryTokenFullyAllocated(), "Each token must be fully allocated");\n', '        _;\n', '    }\n', '\n', '    modifier canCancelSwap {\n', '        require(\n', '            status == Status.WaitingDeposits,\n', '            "Unable to cancel swap in the current status"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier canConfirmSwap {\n', '        require(status == Status.WaitingDeposits, "Unable to confirm in the current status");\n', '        require(\n', '            _haveEveryoneDeposited(),\n', '            "Unable to confirm swap before all parties have deposited tokens"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier canWithdraw {\n', '        require(status == Status.SwapConfirmed, "Unable to withdraw tokens in the current status");\n', '        require(startLockupAt != 0, "Lockup has not been started");\n', '        _;\n', '    }\n', '\n', '    modifier canReclaim {\n', '        require(\n', '            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n', '            "Unable to reclaim in the current status"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // EXTERNAL METHODS\n', '    /**\n', '     * @dev Add new party to the swap.\n', '     * @param _participant Address of the participant.\n', '     * @param _token An ERC20-compliant token which participant is offering to swap.\n', '     * @param _tokensTotal How much tokens the participant is offering.\n', '     */\n', '    function addParty(\n', '        address _participant,\n', '        ERC20 _token,\n', '        uint256 _tokensTotal\n', '    )\n', '        external\n', '        onlyOwner\n', '        canAddParty\n', '    {\n', '        require(_participant != address(0), "_participant is invalid address");\n', '        require(_token != address(0), "_token is invalid address");\n', '        require(_tokensTotal > 0, "Positive amount of tokens is required");\n', '        require(\n', '            isParticipant[_participant] == false,\n', '            "Unable to add the same party multiple times"\n', '        );\n', '\n', '        isParticipant[_participant] = true;\n', '        SwapOffer memory offer = SwapOffer({\n', '            participant: _participant,\n', '            token: _token,\n', '            tokensTotal: _tokensTotal,\n', '            withdrawnTokensTotal: 0\n', '        });\n', '        participants.push(offer.participant);\n', '        offerByToken[offer.token] = offer;\n', '        tokenByParticipant[offer.participant] = offer.token;\n', '\n', '        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n', '    }\n', '\n', '    /**\n', '     * @dev Add lockup period stages for one of the tokens.\n', '     * @param _token A token previously added via addParty.\n', '     * @param _secondsSinceLockupStart Array of starts of the stages of the lockup period.\n', '     * @param _unlockedTokensPercentages Array of percentages of the unlocked tokens.\n', '     */\n', '    function addLockupPeriod(\n', '        ERC20 _token,\n', '        uint256[] _secondsSinceLockupStart,\n', '        uint8[] _unlockedTokensPercentages\n', '    )\n', '        external\n', '        onlyOwner\n', '        canAddLockupPeriod\n', '    {\n', '        require(_token != address(0), "Invalid token");\n', '        require(\n', '            _secondsSinceLockupStart.length == _unlockedTokensPercentages.length,\n', '            "Invalid lockup period"\n', '        );\n', '        require(\n', '            lockupStagesByToken[_token].length == 0,\n', '            "Lockup period for this token has been added already"\n', '        );\n', '        require(\n', '            offerByToken[_token].token != address(0),\n', '            "There is no swap offer with this token"\n', '        );\n', '\n', '        for (uint256 i = 0; i < _secondsSinceLockupStart.length; i++) {\n', '            LockupStage memory stage = LockupStage(\n', '                _secondsSinceLockupStart[i], _unlockedTokensPercentages[i]\n', '            );\n', '            lockupStagesByToken[_token].push(stage);\n', '\n', '            emit AddLockupStage(\n', '                _token, stage.secondsSinceLockupStart, stage.unlockedTokensPercentage\n', '            );\n', '        }\n', '\n', '        _validateLockupStages(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev Add token allocation.\n', '     * @param _token A token previously added via addParty.\n', '     * @param _receivers Who receives tokens.\n', '     * @param _amounts How much tokens will each receiver get.\n', '     */\n', '    function addTokenAllocation(\n', '        ERC20 _token,\n', '        address[] _receivers,\n', '        uint256[] _amounts\n', '    )\n', '        external\n', '        onlyOwner\n', '        canAddTokenAllocation\n', '    {\n', '        require(_token != address(0), "Invalid token");\n', '        require(_receivers.length == _amounts.length, "Invalid arguments\' lengths");\n', '        require(offerByToken[_token].token != address(0), "There is no swap offer with this token");\n', '        require(!isTokenAllocated[_token], "Token has been allocated already");\n', '\n', '        uint256 totalAllocation = 0;\n', '        uint256 i;\n', '\n', '        for (i = 0; i < _receivers.length; i++) {\n', '            require(_receivers[i] != address(0), "Invalid receiver");\n', '            require(_amounts[i] > 0, "Positive amount is required");\n', '            require(\n', '                allocatedTokens[_token][_receivers[i]] == 0,\n', '                "Tokens for this receiver have been allocated already"\n', '            );\n', '\n', '            if (!isReceiver[_receivers[i]]) {\n', '                receivers.push(_receivers[i]);\n', '                isReceiver[_receivers[i]] = true;\n', '            }\n', '\n', '            allocatedTokens[_token][_receivers[i]] = _amounts[i];\n', '            totalAllocation = totalAllocation.add(_amounts[i]);\n', '\n', '            emit AddTokenAllocation(_token, _receivers[i], _amounts[i]);\n', '        }\n', '\n', '        require(totalAllocation == offerByToken[_token].tokensTotal, "Invalid allocation");\n', '        require(isReceiver[owner], "Swap fee hasn\'t been allocated");\n', '\n', '        for (i = 0; i < participants.length; i++) {\n', '            if (tokenByParticipant[participants[i]] == address(_token)) {\n', '                continue;\n', '            }\n', '            require(isReceiver[participants[i]], "Tokens for a participant haven\'t been allocated");\n', '        }\n', '\n', '        isTokenAllocated[_token] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Confirm swap parties\n', '     */\n', '    function confirmParties() external onlyOwner canConfirmParties {\n', '        address[] memory newOwners = new address[](participants.length + 1);\n', '\n', '        for (uint256 i = 0; i < participants.length; i++) {\n', '            newOwners[i] = participants[i];\n', '        }\n', '\n', '        newOwners[newOwners.length - 1] = owner;\n', '        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n', '        _changeStatus(Status.WaitingDeposits);\n', '        emit ConfirmParties();\n', '    }\n', '\n', '    /**\n', '     * @dev Confirm swap.\n', '     */\n', '    function confirmSwap() external canConfirmSwap onlyManyOwners {\n', '        emit ConfirmSwap();\n', '        _changeStatus(Status.SwapConfirmed);\n', '        _startLockup();\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel swap.\n', '     */\n', '    function cancelSwap() external canCancelSwap onlyManyOwners {\n', '        emit CancelSwap();\n', '        _changeStatus(Status.SwapCanceled);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw tokens\n', '     */\n', '    function withdraw() external onlyReceiver canWithdraw {\n', '        for (uint i = 0; i < participants.length; i++) {\n', '            address token = tokenByParticipant[participants[i]];\n', '            SwapOffer storage offer = offerByToken[token];\n', '\n', '            if (offer.participant == msg.sender) {\n', '                continue;\n', '            }\n', '\n', '            uint256 tokensAmount = _withdrawableAmount(offer.token, msg.sender);\n', '\n', '            if (tokensAmount > 0) {\n', '                withdrawnTokens[offer.token][msg.sender] =\n', '                    withdrawnTokens[offer.token][msg.sender].add(tokensAmount);\n', '                offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n', '                offer.token.safeTransfer(msg.sender, tokensAmount);\n', '                emit Withdraw(msg.sender, offer.token, tokensAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n', '     */\n', '    function reclaim() external onlyParticipant canReclaim {\n', '        address token = tokenByParticipant[msg.sender];\n', '\n', '        SwapOffer storage offer = offerByToken[token];\n', '        uint256 currentBalance = offer.token.balanceOf(address(this));\n', '        uint256 availableForReclaim = currentBalance;\n', '\n', '        if (status != Status.SwapCanceled) {\n', '            uint256 lockedTokens = offer.tokensTotal.sub(offer.withdrawnTokensTotal);\n', '            availableForReclaim = currentBalance.sub(lockedTokens);\n', '        }\n', '\n', '        if (availableForReclaim > 0) {\n', '            offer.token.safeTransfer(offer.participant, availableForReclaim);\n', '        }\n', '\n', '        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens back to owners.\n', '     */\n', '    function softEmergency() external onlyOwner {\n', '        for (uint i = 0; i < participants.length; i++) {\n', '            address token = tokenByParticipant[participants[i]];\n', '            SwapOffer storage offer = offerByToken[token];\n', '            uint256 tokensAmount = offer.token.balanceOf(address(this));\n', '\n', '            require(offer.withdrawnTokensTotal == 0, "Unavailable after the first withdrawal.");\n', '\n', '            if (tokensAmount > 0) {\n', '                offer.token.safeTransfer(offer.participant, tokensAmount);\n', '                emit SoftEmergency(offer.token, offer.participant, tokensAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev A way out if nothing else is working.\n', '     */\n', '    function hardEmergency(\n', '        ERC20[] _tokens,\n', '        address[] _receivers,\n', '        uint256[] _values\n', '    )\n', '        external\n', '        onlyAllOwners\n', '    {\n', '        require(_tokens.length == _receivers.length, "Invalid lengths.");\n', '        require(_receivers.length == _values.length, "Invalid lengths.");\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            _tokens[i].safeTransfer(_receivers[i], _values[i]);\n', '            emit HardEmergency(_tokens[i], _receivers[i], _values[i]);\n', '        }\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '    /**\n', '     * @dev Standard ERC223 function that will handle incoming token transfers.\n', '     *\n', '     * @param _from  Token sender address.\n', '     * @param _value Amount of tokens.\n', '     * @param _data  Transaction metadata.\n', '     */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer ownership.\n', '     * @param _newOwner Address of the new owner.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner canTransferOwnership {\n', '        require(_newOwner != address(0), "_newOwner is invalid address");\n', '        require(owners.length == 1, "Unable to transfer ownership in presence of multiowners");\n', '        require(owners[0] == owner, "Unexpected multiowners state");\n', '\n', '        address[] memory newOwners = new address[](1);\n', '        newOwners[0] = _newOwner;\n', '\n', '        Ownable.transferOwnership(_newOwner);\n', '        Multiownable.transferOwnership(newOwners);\n', '    }\n', '\n', '    // INTERNAL METHODS\n', '    /**\n', '     * @dev Validate lock-up period configuration.\n', '     */\n', '    function _validateLockupStages(ERC20 _token) internal view {\n', '        LockupStage[] storage lockupStages = lockupStagesByToken[_token];\n', '\n', '        for (uint i = 0; i < lockupStages.length; i++) {\n', '            LockupStage memory stage = lockupStages[i];\n', '\n', '            require(\n', '                stage.unlockedTokensPercentage >= 0,\n', '                "LockupStage.unlockedTokensPercentage must not be negative"\n', '            );\n', '            require(\n', '                stage.unlockedTokensPercentage <= 100,\n', '                "LockupStage.unlockedTokensPercentage must not be greater than 100"\n', '            );\n', '\n', '            if (i == 0) {\n', '                continue;\n', '            }\n', '\n', '            LockupStage memory previousStage = lockupStages[i - 1];\n', '            require(\n', '                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n', '                "LockupStage.secondsSinceLockupStart must increase monotonically"\n', '            );\n', '            require(\n', '                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n', '                "LockupStage.unlockedTokensPercentage must increase monotonically"\n', '            );\n', '        }\n', '\n', '        require(\n', '            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n', '            "The last lockup stage must unlock 100% of tokens"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Change swap status.\n', '     */\n', '    function _changeStatus(Status _newStatus) internal {\n', '        emit StatusUpdate(status, _newStatus);\n', '        status = _newStatus;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if every token has lockup period.\n', '     */\n', '    function _doesEveryTokenHaveLockupPeriod() internal view returns(bool) {\n', '        for (uint256 i = 0; i < participants.length; i++) {\n', '            address token = tokenByParticipant[participants[i]];\n', '\n', '            if (lockupStagesByToken[token].length == 0) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if every token has been fully allocated.\n', '     */\n', '    function _isEveryTokenFullyAllocated() internal view returns(bool) {\n', '        for (uint256 i = 0; i < participants.length; i++) {\n', '            if (!isTokenAllocated[tokenByParticipant[participants[i]]]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n', '     */\n', '    function _haveEveryoneDeposited() internal view returns(bool) {\n', '        for (uint i = 0; i < participants.length; i++) {\n', '            address token = tokenByParticipant[participants[i]];\n', '            SwapOffer memory offer = offerByToken[token];\n', '\n', '            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Start lockup period\n', '     */\n', '    function _startLockup() internal {\n', '        startLockupAt = now;\n', '        emit StartLockup(startLockupAt);\n', '    }\n', '\n', '    /**\n', '     * @dev Find amount of tokens ready to be withdrawn.\n', '     */\n', '    function _withdrawableAmount(\n', '        ERC20 _token,\n', '        address _receiver\n', '    )\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 allocated = allocatedTokens[_token][_receiver];\n', '        uint256 withdrawn = withdrawnTokens[_token][_receiver];\n', '        uint256 unlockedPercentage = _getUnlockedTokensPercentage(_token);\n', '        uint256 unlockedAmount = allocated.mul(unlockedPercentage).div(100);\n', '\n', '        return unlockedAmount.sub(withdrawn);\n', '    }\n', '\n', '    /**\n', '     * @dev Get percent of unlocked tokens\n', '     */\n', '    function _getUnlockedTokensPercentage(ERC20 _token) internal view returns(uint256) {\n', '        for (uint256 i = lockupStagesByToken[_token].length; i > 0; i--) {\n', '            LockupStage storage stage = lockupStagesByToken[_token][i - 1];\n', '            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n', '\n', '            if (now < stageBecomesActiveAt) {\n', '                continue;\n', '            }\n', '\n', '            return stage.unlockedTokensPercentage;\n', '        }\n', '    }\n', '}']