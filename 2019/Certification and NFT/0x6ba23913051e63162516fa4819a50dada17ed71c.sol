['pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'contract ThreeLeeks {\n', '    struct STR_NODE\n', '        {\n', '            address payable addr;\n', '            uint32 ID;\n', '            uint32 faNode;//Parent node\n', '            uint32 brNode;//Brother Node\n', '            uint32 chNode;//Subnode\n', '            uint256 Income;//Income earned\n', '            uint32 Subordinate;//Total lower series\n', '        }\n', '    struct PRIZE_RECORD\n', '    {\n', '        address addr;//Award-winning user address\u3000\n', '        uint32 NodeNumber;//Node Number of Award-winning User Address\n', '        uint256 EthGained;//The amount of bonus awarded\n', '    }\n', '    //Someone joins the referee who created the event / the number of the person who joined / the time of joining\n', '    event HaveAdd(uint32 Recommender,uint32 Number,uint64 Add_Time);\n', '    //Execution Award Winner Number/Award Amount/Award Number\n', '    event OnReward(uint32 Awardee,uint256 PrizeMoney,uint32 PrizeNumber);\n', '    \n', '    mapping (uint32 => STR_NODE) private Node;//\n', '    mapping (uint32 => PRIZE_RECORD)private PrizeRecord;\n', '    \n', '    uint32 NodeIndex;//Current node\n', '    uint64 NodeAddTime;//Last time to join\n', '    \n', '    address  ContractAddress;\n', '    uint160 Random;\n', '    uint64 PrizeTime1;\n', '    uint64 PrizeTime2;\n', '   //////////////////////////////////////////////////////////////\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    constructor  (address first_addr) public {\n', '        NodeIndex=0;\n', '\n', '        Node[0]=STR_NODE(msg.sender,0,0,0,0,0,0);\n', '        Node[1]=STR_NODE(address(uint160(first_addr)),0,0,0,0,0,0);\n', '        \n', '        Random=uint160(Node[0].addr);\n', '        NodeIndex=100;\n', '        ContractAddress=address(uint160(address(this)));\n', '    }\n', '    //The top 100 leeks are sales teams. This function is called by contract deployer to increase or decrease sales staff.\n', '    function SetFreeRender(address addr,uint32 Number)public\n', '    {\n', '        require(msg.sender==Node[0].addr,"Can only be invoked by the deployer");\n', '        require(Number>1 && Number <=100,"Even in deployment, only the top 100 data can be modified. The top 100 are sales teams, real players from 101, and the data can not be modified.");\n', '        if(Node[Number].addr==address(0))\n', '            {\n', '                Node[Number].addr=address(uint160(addr));\n', '            }\n', '        else\n', '            {\n', '                Node[Number]=STR_NODE(address(uint160(addr)),0,0,0,0,0,0);\n', '            }\n', '        Node[Number].addr=address(uint160(addr));\n', '        \n', '    }\n', '    /*  This function injects capital. Recommender is the recommender number of the investor.*/\n', '    function CapitalInjection(uint32 Recommender_Number)public payable\n', '    {\n', '        uint32 index;\n', '        uint32 Recommender=unEncryption(Recommender_Number);\n', '        require(Recommender>=0 && Recommender<=NodeIndex,"Recommenders do not exist");\n', '        if(msg.value!=0.999 ether)\n', '        {\n', '            msg.sender.transfer(msg.value);\n', '            emit HaveAdd(0,0,uint64(now));\n', '            return ;\n', '        }\n', '        NodeAddTime=uint64(now);\n', '        NodeIndex+=1;\n', '\n', '        //Setting Recommenders Up to the Line of Current Investors\n', '        Node[NodeIndex]=STR_NODE(msg.sender,NodeIndex,Recommender,0,0,0,0);\n', '            \n', '        if(Node[Recommender].chNode<=0)//If the referee is not offline\n', '        {//Offline current investors as referees\n', '            Node[Recommender].chNode=NodeIndex;\n', '        }\n', '        else//If the referee has already been offline\n', '        {\n', '            index=Node[Recommender].chNode;\n', "            while (Node[index].brNode>0)//Lookup until the recommender's child nodes have no siblings\n", '            {\n', '                index=Node[index].brNode;\n', '            }\n', '            Node[index].brNode=NodeIndex;//Brothers who set current investors as referees\n', '        }\n', '\n', '        //Up to this point, the connection between the node and the downline has been realized and the transfer has started.\n', '        index=Node[NodeIndex].faNode;\n', '        if(index<=1)\n', '        {\n', '            Node[0].addr.transfer(0.44955 ether);\n', '            Node[0].Subordinate+=1;\n', '            Node[0].Income+=0.44955 ether;\n', '            Node[1].addr.transfer(0.44955 ether);\n', '            Node[1].Income+=0.44955 ether;\n', '            Node[1].Subordinate+=1;\n', '        }\n', '        else\n', '        {\n', '            Node[index].addr.transfer(0.34965 ether);//Direct superior extraction 0.999*35%\n', '            Node[index].Income+=0.34965 ether;\n', '            Node[index].Subordinate+=1;\n', '            index=Node[index].faNode;\n', '            for (uint8 i=0;i<10;i++)\n', '            {\n', '                if(index<=1)\n', '                {\n', '                    Node[0].addr.transfer((10-i)*0.0495 ether/2);\n', '                    Node[0].Subordinate+=1;\n', '                    Node[0].Income+=(10-i)*0.0495 ether/2;\n', '                    Node[1].addr.transfer((10-i)*0.0495 ether/2);\n', '                    Node[1].Subordinate+=1;\n', '                    Node[1].Income+=(10-i)*0.0495 ether/2;\n', '                    break;\n', '                }\n', '                else\n', '                {\n', '                    Node[index].addr.transfer(0.04995 ether);//Indirect superior extraction 0.999*5%\n', '                    Node[index].Income+=0.04995 ether;\n', '                    Node[index].Subordinate+=1;\n', '                    index=Node[index].faNode;//Index points to the parent node\n', '                }\n', '            }\n', '            Node[0].addr.transfer(0.024975 ether);\n', '            Node[1].addr.transfer(0.024975 ether);\n', '        }\n', '        \n', '        //Incidents involving people\n', '        emit HaveAdd(Recommender_Number,NodeIndex,NodeAddTime);\n', '        \n', '        //Generating the cardinality of random numbers\n', '        Random=Random/2+uint160(msg.sender)/2;\n', '        \n', '        //Every two hundred people will be awarded a prize, with 9999 Finney as the prize and one first prize.\n', '        //4995 Finney, 2 first prize, 2997 Finney, 4 third prize, each 1998 Finney\n', '        if(NodeIndex > 1 && NodeIndex % 200 ==0)\n', '        {\n', '            PrizeTime1=uint64(now);\n', '            SendPrize(NodeIndex-uint32(Random % 200),4.995 ether,0);\n', '            SendPrize(NodeIndex-uint32(Random/3 % 200),1.4985 ether,1);\n', '            SendPrize(NodeIndex-uint32(Random/5 % 200),1.4985 ether,2);\n', '            SendPrize(NodeIndex-uint32(Random/7 % 200),0.4995 ether,3);\n', '            SendPrize(NodeIndex-uint32(Random/11 % 200),0.4995 ether,4);\n', '            SendPrize(NodeIndex-uint32(Random/13 % 200),0.4995 ether,5);\n', '            SendPrize(NodeIndex-uint32(Random/17 % 200),0.4995 ether,6);\n', '            \n', '        }\n', '        if(NodeIndex>1 && NodeIndex % 20000 ==0)  \n', '        {\n', '            uint256 mon=ContractAddress.balance;\n', '            \n', '            SendPrize(NodeIndex-uint32(Random/19 % 20000),mon/1000*250,7);\n', '            SendPrize(NodeIndex-uint32(Random/23 % 20000),mon/1000*75,8);\n', '            SendPrize(NodeIndex-uint32(Random/29 % 20000),mon/1000*75,9);\n', '            SendPrize(NodeIndex-uint32(Random/31 % 20000),mon/1000*25,10);\n', '            SendPrize(NodeIndex-uint32(Random/37 % 20000),mon/1000*25,11);\n', '            SendPrize(NodeIndex-uint32(Random/41 % 20000),mon/1000*25 ,12);\n', '            SendPrize(NodeIndex-uint32(Random/43 % 20000),mon/1000*25 ,13);\n', '            \n', '        }\n', '    }\n', '    //This function is responsible for awarding prizes.\n', '    function SendPrize(uint32 index,uint256 money,uint32 prize_index) private \n', '    {\n', '        require(index>=0 && index<=NodeIndex);\n', '        require(money>0 && money<ContractAddress.balance);\n', '        require(prize_index>=0 && prize_index<=13);\n', '        \n', '        Node[index].addr.transfer(money);\n', '        \n', '        PrizeRecord[prize_index].addr=Node[index].addr;\n', '        PrizeRecord[prize_index].NodeNumber=index;\n', '        PrizeRecord[prize_index].EthGained=money;\n', '\n', '    }\n', '    \n', '    //This function returns the total amount of money in the prize pool\n', '    function GetPoolOfFunds()public view returns(uint256)\n', '    {\n', '        return ContractAddress.balance;\n', '    }\n', '    //This function returns its recommended address\n', '    function GetMyIndex(address my_addr) public view returns(uint32)\n', '    {\n', '        for(uint32 i=0 ;i<=NodeIndex;i++)\n', '        {    if(my_addr==Node[i].addr)\n', '            {\n', '                return Encryption(i);\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '    //Return my total income\n', '    function GetMyIncome(uint32 my_num) public view returns(uint256)\n', '    {\n', '        uint32 index=unEncryption(my_num);\n', '        require(index>=0 && index<NodeIndex,"Incorrect recommended address entered");\n', '        return Node[index].Income;\n', '    }\n', '    //Return to my referee\n', '    function GetMyRecommend(uint32 my_num) public view returns(uint32)\n', '    {\n', '        uint32 index=unEncryption(my_num);\n', '        require(index>=0 && index<NodeIndex);\n', '        return Encryption(Node[index].faNode);\n', '    }\n', '    //Return to the total number of my subordinates\n', '    function GetMySubordinateNumber(uint32 my_num)public view returns(uint32)\n', '    {\n', '        uint32 index=unEncryption(my_num);\n', '        require(index>=0 && index<NodeIndex);\n', '        return Node[index].Subordinate;\n', '    }\n', '    //Return direct lower series\n', '    function GetMyRecommendNumber(uint32 my_number)public view returns(uint32)\n', '    {\n', '        uint32 index;\n', '        uint32 my_num=unEncryption(my_number);\n', '        require(my_num>=0 && my_num<NodeIndex);\n', '        index=my_num;\n', '        uint32 Number;\n', '        if(Node[index].chNode>0)\n', '        {\n', '            Number=1;\n', '            index=Node[index].chNode;\n', '            while (Node[index].brNode>0)\n', '            {\n', '                Number++;\n', '                index=Node[index].brNode;\n', '            }\n', '        }\n', '    return Number;\n', '    }\n', '    //Return the total number of players\n', '    function GetAllPeopleNumber()public view returns(uint32)\n', '    {\n', '        return NodeIndex;\n', '    }\n', '    //Deployers can choose to destroy contracts, and eth in all pools of funds is evenly allocated to all players after the contract is destroyed.\n', '    function DeleteContract() public \n', '    {\n', '        require(msg.sender==Node[0].addr,"This function can only be called by the deployer");\n', '        uint256 AverageMoney=ContractAddress.balance/NodeIndex;\n', '        for (uint32 i=0;i<NodeIndex;i++)\n', '        {\n', '            Node[i].addr.transfer(AverageMoney);\n', '        }\n', '        selfdestruct(Node[0].addr);\n', '        \n', '    }\n', '    //Return to the last person joining time\n', '    function GetLastAddTime()public view returns(uint64)\n', '    {\n', '        return NodeAddTime;\n', '    }\n', '    \n', '    function GetPrizeTime()public view returns(uint64,uint64)\n', '    {\n', '        return(PrizeTime1,PrizeTime2);\n', '    }\n', '    //This function returns the winning information\n', '    function GetPrizeText(uint8 prize_index)public view returns(\n', '            address addr0,\n', '            uint32 ID0,\n', '            uint256 money0\n', '            )\n', '    {\n', '        return (\n', '                \n', '                PrizeRecord[prize_index].addr,\n', '                Encryption(PrizeRecord[prize_index].NodeNumber),\n', '                PrizeRecord[prize_index].EthGained\n', '            );\n', '\n', '    }\n', '    ///////////////////////////////////////////////////////////\n', '//Coded as recommended address\n', '    function Encryption(uint32 num) private pure returns(uint32 com_num)\n', '   {\n', '       require(num<=8388607,"Maximum ID should not exceed 8388607");\n', '       uint32 flags;\n', '       uint32 p=num;\n', '       uint32 ret;\n', '       if(num<4)\n', '        {\n', '            flags=2;\n', '        }\n', '       else\n', '       {\n', '          if(num<=15)flags=7;\n', '          else if(num<=255)flags=6;\n', '          else if(num<=4095)flags=5;\n', '          else if(num<=65535)flags=4;\n', '          else if(num<=1048575)flags=3;\n', '          else flags=2;\n', '       }\n', '       ret=flags<<23;\n', '       if(flags==2)\n', '        {\n', '            p=num; \n', '        }\n', '        else\n', '        {\n', '            p=num<<((flags-2)*4-1);\n', '        }\n', '        ret=ret | p;\n', '        return (ret);\n', '   }\n', '//Decode to ID\n', '   function unEncryption(uint32 num)private pure returns(uint32 number)\n', '   {\n', '       uint32 p;\n', '       uint32 flags;\n', '       flags=num>>23;\n', '       p=num<<9;\n', '       if(flags==2)\n', '       {\n', '           if(num==16777216)return(0);\n', '           else if(num==16777217)return(1);\n', '           else if(num==16777218)return(2);\n', '           else if(num==16777219)return(3);\n', '           else \n', '            {\n', '                require(num>= 25690112 && num<66584576 ,"Illegal parameter, parameter position must be greater than 10 bits");\n', '                p=p>>9;\n', '            }\n', '       }\n', '       else \n', '       {\n', '            p=p>>(9+(flags-2)*4-1);\n', '       }\n', '     return (p);\n', '   }\n', '}']