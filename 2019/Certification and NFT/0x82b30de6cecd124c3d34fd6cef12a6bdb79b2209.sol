['pragma solidity 0.4.24;\n', '\n', '// File: contracts/FreeDnaCardRepositoryInterface.sol\n', '\n', 'interface FreeDnaCardRepositoryInterface {\n', '    function airdrop(address to, uint256 animalId) external;\n', '\n', '    function giveaway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Restricted.sol\n', '\n', 'contract Restricted is Ownable {\n', '    mapping(address => bool) private addressIsAdmin;\n', '    bool private isActive = true;\n', '\n', '    modifier onlyAdmin() {\n', '        require(addressIsAdmin[msg.sender] || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier contractIsActive() {\n', '        require(isActive);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address adminAddress) public onlyOwner {\n', '        addressIsAdmin[adminAddress] = true;\n', '    }\n', '\n', '    function removeAdmin(address adminAddress) public onlyOwner {\n', '        addressIsAdmin[adminAddress] = false;\n', '    }\n', '\n', '    function pauseContract() public onlyOwner {\n', '        isActive = false;\n', '    }\n', '\n', '    function activateContract() public onlyOwner {\n', '        isActive = true;\n', '    }\n', '}\n', '\n', '// File: contracts/GameData.sol\n', '\n', 'contract GameData {\n', '    struct Country {       \n', '        bytes2 isoCode;\n', '        uint8 animalsCount;\n', '        uint256[3] animalIds;\n', '    }\n', '\n', '    struct Animal {\n', '        bool isSold;\n', '        uint256 currentValue;\n', '        uint8 rarity; // 0-4, rarity = stat range, higher rarity = better stats\n', '\n', '        bytes32 name;         \n', '        uint256 countryId; // country of origin\n', '\n', '    }\n', '\n', '    struct Dna {\n', '        uint256 animalId; \n', '        uint8 effectiveness; //  1 - 100, 100 = same stats as a wild card\n', '    }    \n', '}\n', '\n', '// File: contracts/FreeDnaCardRepository.sol\n', '\n', 'contract FreeDnaCardRepository is FreeDnaCardRepositoryInterface, GameData, Restricted {\n', '    event NewAirdrop(\n', '        address to,\n', '        uint256 animalId\n', '    );\n', '\n', '    event NewGiveway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    );\n', '\n', '    uint8 private constant AIRDROP_EFFECTIVENESS = 10;\n', '\n', '    uint256 private pendingGivewayCardCount;\n', '    uint256 private airdropEndTimestamp;\n', '\n', '    bool private migrated = false;\n', '\n', '    mapping (address => uint256[]) private addressDnaIds;\n', '    mapping (address => bool) public addressIsDonator;\n', '    mapping (uint => address) private dnaIdToOwnerAddress;\n', '\n', '    Dna[] private dnas;\n', '\n', '    constructor(\n', '        uint256 _pendingGivewayCardCount,\n', '        uint256 _airdropEndTimestamp\n', '    ) public {\n', '        pendingGivewayCardCount = _pendingGivewayCardCount;\n', '        airdropEndTimestamp = _airdropEndTimestamp;\n', '    }\n', '\n', '    function getDna(uint dnaId) external view returns (\n', '       uint256 animalId,\n', '       address ownerAddress,\n', '       uint8 effectiveness,\n', '       uint256 id\n', '    ) {\n', '        Dna storage dna = dnas[dnaId];\n', '\n', '        return (\n', '            dna.animalId,\n', '            dnaIdToOwnerAddress[dnaId],\n', '            dna.effectiveness,\n', '            dnaId\n', '        );\n', '    }\n', '\n', '    function migrateData(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external\n', '    onlyOwner\n', '    {\n', '        require(migrated == false);\n', '        donateDna(to, animalId, effectiveness);\n', '    }\n', '\n', '    function setMigrated() external onlyOwner {\n', '        migrated = true;\n', '    }\n', '\n', '    function addDonator(address donatorAddress) external onlyAdmin {\n', '        addressIsDonator[donatorAddress] = true;\n', '    }\n', '\n', '    function deleteDonator(address donatorAddress) external onlyAdmin {\n', '        delete addressIsDonator[donatorAddress];\n', '    }\n', '\n', '    function airdrop(address to, uint256 animalId) external contractIsActive {\n', '        require(now <= airdropEndTimestamp, "airdrop ended");\n', '        donateDnaFromContract(to, animalId, AIRDROP_EFFECTIVENESS);\n', '        emit NewAirdrop(to, animalId);\n', '    }\n', '\n', '    function giveaway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external\n', '    contractIsActive\n', '    {\n', '        require(pendingGivewayCardCount > 0);\n', '\n', '        donateDnaFromContract(to, animalId, effectiveness);\n', '        pendingGivewayCardCount--;\n', '        emit NewGiveway(to, animalId, effectiveness);\n', '    }\n', '\n', '    function getAddressDnaIds(address owner) external view returns(uint256[])\n', '    {\n', '        return addressDnaIds[owner];\n', '    }\n', '\n', '    function donateDnaFromContract(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    private\n', '    contractIsActive\n', '    {\n', '        require(migrated);\n', '        require(addressIsDonator[msg.sender], "donator not registered");\n', '        donateDna(to, animalId, effectiveness);\n', '    }\n', '\n', '    function donateDna(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    private\n', '    {\n', '        uint256 id = dnas.length; // id is assigned before push\n', '        Dna memory dna = Dna(animalId, effectiveness);\n', '\n', '        // Donate the card\n', '        dnas.push(dna);\n', '        dnaIdToOwnerAddress[id] = to;\n', '        addressDnaIds[to].push(id);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '// File: contracts/FreeDnaCardRepositoryInterface.sol\n', '\n', 'interface FreeDnaCardRepositoryInterface {\n', '    function airdrop(address to, uint256 animalId) external;\n', '\n', '    function giveaway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Restricted.sol\n', '\n', 'contract Restricted is Ownable {\n', '    mapping(address => bool) private addressIsAdmin;\n', '    bool private isActive = true;\n', '\n', '    modifier onlyAdmin() {\n', '        require(addressIsAdmin[msg.sender] || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier contractIsActive() {\n', '        require(isActive);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address adminAddress) public onlyOwner {\n', '        addressIsAdmin[adminAddress] = true;\n', '    }\n', '\n', '    function removeAdmin(address adminAddress) public onlyOwner {\n', '        addressIsAdmin[adminAddress] = false;\n', '    }\n', '\n', '    function pauseContract() public onlyOwner {\n', '        isActive = false;\n', '    }\n', '\n', '    function activateContract() public onlyOwner {\n', '        isActive = true;\n', '    }\n', '}\n', '\n', '// File: contracts/GameData.sol\n', '\n', 'contract GameData {\n', '    struct Country {       \n', '        bytes2 isoCode;\n', '        uint8 animalsCount;\n', '        uint256[3] animalIds;\n', '    }\n', '\n', '    struct Animal {\n', '        bool isSold;\n', '        uint256 currentValue;\n', '        uint8 rarity; // 0-4, rarity = stat range, higher rarity = better stats\n', '\n', '        bytes32 name;         \n', '        uint256 countryId; // country of origin\n', '\n', '    }\n', '\n', '    struct Dna {\n', '        uint256 animalId; \n', '        uint8 effectiveness; //  1 - 100, 100 = same stats as a wild card\n', '    }    \n', '}\n', '\n', '// File: contracts/FreeDnaCardRepository.sol\n', '\n', 'contract FreeDnaCardRepository is FreeDnaCardRepositoryInterface, GameData, Restricted {\n', '    event NewAirdrop(\n', '        address to,\n', '        uint256 animalId\n', '    );\n', '\n', '    event NewGiveway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    );\n', '\n', '    uint8 private constant AIRDROP_EFFECTIVENESS = 10;\n', '\n', '    uint256 private pendingGivewayCardCount;\n', '    uint256 private airdropEndTimestamp;\n', '\n', '    bool private migrated = false;\n', '\n', '    mapping (address => uint256[]) private addressDnaIds;\n', '    mapping (address => bool) public addressIsDonator;\n', '    mapping (uint => address) private dnaIdToOwnerAddress;\n', '\n', '    Dna[] private dnas;\n', '\n', '    constructor(\n', '        uint256 _pendingGivewayCardCount,\n', '        uint256 _airdropEndTimestamp\n', '    ) public {\n', '        pendingGivewayCardCount = _pendingGivewayCardCount;\n', '        airdropEndTimestamp = _airdropEndTimestamp;\n', '    }\n', '\n', '    function getDna(uint dnaId) external view returns (\n', '       uint256 animalId,\n', '       address ownerAddress,\n', '       uint8 effectiveness,\n', '       uint256 id\n', '    ) {\n', '        Dna storage dna = dnas[dnaId];\n', '\n', '        return (\n', '            dna.animalId,\n', '            dnaIdToOwnerAddress[dnaId],\n', '            dna.effectiveness,\n', '            dnaId\n', '        );\n', '    }\n', '\n', '    function migrateData(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external\n', '    onlyOwner\n', '    {\n', '        require(migrated == false);\n', '        donateDna(to, animalId, effectiveness);\n', '    }\n', '\n', '    function setMigrated() external onlyOwner {\n', '        migrated = true;\n', '    }\n', '\n', '    function addDonator(address donatorAddress) external onlyAdmin {\n', '        addressIsDonator[donatorAddress] = true;\n', '    }\n', '\n', '    function deleteDonator(address donatorAddress) external onlyAdmin {\n', '        delete addressIsDonator[donatorAddress];\n', '    }\n', '\n', '    function airdrop(address to, uint256 animalId) external contractIsActive {\n', '        require(now <= airdropEndTimestamp, "airdrop ended");\n', '        donateDnaFromContract(to, animalId, AIRDROP_EFFECTIVENESS);\n', '        emit NewAirdrop(to, animalId);\n', '    }\n', '\n', '    function giveaway(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    external\n', '    contractIsActive\n', '    {\n', '        require(pendingGivewayCardCount > 0);\n', '\n', '        donateDnaFromContract(to, animalId, effectiveness);\n', '        pendingGivewayCardCount--;\n', '        emit NewGiveway(to, animalId, effectiveness);\n', '    }\n', '\n', '    function getAddressDnaIds(address owner) external view returns(uint256[])\n', '    {\n', '        return addressDnaIds[owner];\n', '    }\n', '\n', '    function donateDnaFromContract(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    private\n', '    contractIsActive\n', '    {\n', '        require(migrated);\n', '        require(addressIsDonator[msg.sender], "donator not registered");\n', '        donateDna(to, animalId, effectiveness);\n', '    }\n', '\n', '    function donateDna(\n', '        address to,\n', '        uint256 animalId,\n', '        uint8 effectiveness\n', '    )\n', '    private\n', '    {\n', '        uint256 id = dnas.length; // id is assigned before push\n', '        Dna memory dna = Dna(animalId, effectiveness);\n', '\n', '        // Donate the card\n', '        dnas.push(dna);\n', '        dnaIdToOwnerAddress[id] = to;\n', '        addressDnaIds[to].push(id);\n', '    }\n', '}']
