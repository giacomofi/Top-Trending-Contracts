['// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : dave@akomba.com\n', '// released under Apache 2.0 licence\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract EthBattle is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant TOKEN_USE_BONUS = 15; //%, adds weight of win on top of the market price\n', '    uint256 constant REFERRAL_REWARD = 2 ether; // GTA, 10*19\n', '    uint256 public MIN_PLAY_AMOUNT = 50 finney; //wei, equal 0.05 ETH\n', '\n', '    uint256 public META_BET_WEIGHT = 10 finney; //wei, equal to 0.01 ETH\n', '\n', '    uint256 public roundIndex = 0;\n', '    mapping(uint256 => address) public rounds;\n', '\n', '    address[] private currentRewardingAddresses;\n', '\n', '    PlaySeedInterface private playSeedGenerator;\n', '    GTAInterface public token;\n', '    AMUStoreInterface public store;\n', '\n', '    address public startersProxyAddress;\n', '\n', '    mapping(address => address) public referralBacklog; //backlog of players and their referrals\n', '\n', '    mapping(address => uint256) public tokens; //map of deposited tokens\n', '\n', '    event RoundCreated(address createdAddress, uint256 index);\n', '    event Deposit(address user, uint amount, uint balance);\n', '    event Withdraw(address user, uint amount, uint balance);\n', '\n', '    /**\n', '    * @dev Default fallback function, just deposits funds to the pot\n', '    */\n', '    function () public payable {\n', '        getLastRound().getDevWallet().transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '    * @dev The EthBattle constructor\n', '    * @param _playSeedAddress address of the play seed generator\n', '    * @param _tokenAddress GTA address\n', '    * @param _storeAddress store contract address\n', '    */\n', '    constructor (address _playSeedAddress, address _tokenAddress, address _storeAddress, address _proxyAddress) public {\n', '        playSeedGenerator = PlaySeedInterface(_playSeedAddress);\n', '        token = GTAInterface(_tokenAddress);\n', '        store = AMUStoreInterface(_storeAddress);\n', '        startersProxyAddress = _proxyAddress;\n', '    }\n', '\n', '    modifier onlyProxy() {\n', '        require(msg.sender == startersProxyAddress);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Try (must be allowed by the seed generator itself) to claim ownership of the seed generator\n', '    */\n', '    function claimSeedOwnership() onlyOwner public {\n', '        playSeedGenerator.claimOwnership();\n', '    }\n', '\n', '    /**\n', '    * @dev Inject the new round contract, and sets the round with a new index\n', '    * NOTE! Injected round must have had transferred ownership to this EthBattle already\n', '    * @param _roundAddress address of the new round to use\n', '    */\n', '    function startRound(address _roundAddress) onlyOwner public {\n', '        RoundInterface round = RoundInterface(_roundAddress);\n', '\n', '        round.claimOwnership();\n', '\n', '        roundIndex++;\n', '        rounds[roundIndex] = round;\n', '        emit RoundCreated(round, roundIndex);\n', '    }\n', '\n', '    /**\n', '    * @dev Player starts a new play providing\n', '    * @param _referral (Optional) referral address is any\n', '    * @param _gtaBet (Optional) additional bet in GTA\n', '    */\n', '    function play(address _referral, uint256 _gtaBet) public payable {\n', '        address player = msg.sender;\n', '        uint256 weiAmount = msg.value;\n', '\n', '        require(player != address(0), "Player\'s address is missing");\n', '        require(weiAmount >= MIN_PLAY_AMOUNT, "The bet is too low");\n', '        require(_gtaBet <= balanceOf(player), "Player\'s got not enough GTA");\n', '\n', '        uint256 _bet = aggregateBet(weiAmount, _gtaBet);\n', '\n', '        playInternal(player, weiAmount, _bet, _referral, _gtaBet);\n', '    }\n', '\n', '    /**\n', '    * @dev Etherless player starts a new play, when actually the gas fee is payed\n', '    * by the sender and the bet is set by the proxy\n', '    * @param _player The actual player\n', '    * @param _referral (Optional) referral address is any\n', '    * @param _gtaBet (Optional) additional bet in GTA\n', '    */\n', '    function playMeta(address _player, address _referral, uint256 _gtaBet) onlyProxy public payable {\n', '        uint256 weiAmount = msg.value;\n', '\n', '        require(_player != address(0), "Player\'s address is missing");\n', '        require(_gtaBet <= balanceOf(_player), "Player\'s got not enough GTA");\n', '\n', "        //Important! For meta plays the 'weight' is not connected the the actual bet (since the bet comes from proxy)\n", '        //but static and equals META_BET_WEIGHT\n', '        uint256 _bet = aggregateBet(META_BET_WEIGHT, _gtaBet);\n', '\n', '        playInternal(_player, weiAmount, _bet, _referral, _gtaBet);\n', '    }\n', '\n', '    function playInternal(address _player, uint256 _weiBet, uint256 _betWeight, address _referral, uint256 _gtaBet) internal {\n', '        if (_referral != address(0) && referralBacklog[_player] == address(0)) {\n', '            //new referral for this _player\n', '            referralBacklog[_player] = _referral;\n', '            //reward the referral. Tokens remains in this contract\n', '            //but become available for withdrawal by _referral\n', '            transferInternally(owner, _referral, REFERRAL_REWARD);\n', '        }\n', '\n', '        playSeedGenerator.newPlaySeed(_player);\n', '\n', '        if (_gtaBet > 0) {\n', "            //player's using GTA\n", '            transferInternally(_player, owner, _gtaBet);\n', '        }\n', '\n', '        if (referralBacklog[_player] != address(0)) {\n', '            //ongoing round might not know about the _referral\n', '            //delegate the knowledge of the referral to the ongoing round\n', '            getLastRound().setReferral(_player, referralBacklog[_player]);\n', '        }\n', '        getLastRound().playRound.value(_weiBet)(_player, _betWeight);\n', '    }\n', '\n', '    /**\n', '    * @dev Player claims a win\n', '    * @param _seed secret seed\n', '    */\n', '    function win(bytes32 _seed) public {\n', '        address player = msg.sender;\n', '        winInternal(player, _seed);\n', '    }\n', '\n', '    /**\n', '    * @dev Player claims a win\n', '    * @param _player etherless player claims\n', '    * @param _seed secret seed\n', '    */\n', '    function winMeta(address _player, bytes32 _seed) onlyProxy public {\n', '        winInternal(_player, _seed);\n', '    }\n', '\n', '    function winInternal(address _player, bytes32 _seed) internal {\n', '        require(_player != address(0), "Winner\'s address is missing");\n', '        require(playSeedGenerator.findSeed(_player) == _seed, "Wrong seed!");\n', '        playSeedGenerator.cleanSeedUp(_player);\n', '\n', '        getLastRound().win(_player);\n', '    }\n', '\n', '    function findSeedAuthorized(address player) onlyOwner public view returns (bytes32){\n', '        return playSeedGenerator.findSeed(player);\n', '    }\n', '\n', '    function aggregateBet(uint256 _bet, uint256 _gtaBet) internal view returns (uint256) {\n', '        //get market price of the GTA, multiply by bet, and apply a bonus on it.\n', "        //since both 'price' and 'bet' are in 'wei', we need to drop 10*18 decimals at the end\n", '        uint256 _gtaValueWei = store.getTokenBuyPrice().mul(_gtaBet).div(1 ether).mul(100 + TOKEN_USE_BONUS).div(100);\n', '\n', '        //sum up with ETH bet\n', '        uint256 _resultBet = _bet.add(_gtaValueWei);\n', '\n', '        return _resultBet;\n', '    }\n', '\n', '    /**\n', '    * @dev Calculates the prize amount for this player by now\n', '    * Note: the result is not the final one and a subject to change once more plays/wins occur\n', '    * @return The prize in wei\n', '    */\n', '    function prizeByNow() public view returns (uint256) {\n', '        return getLastRound().currentPrize(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Calculates the prediction on the prize amount for this player and this bet\n', '    * Note: the result is not the final one and a subject to change once more plays/wins occur\n', '    * @param _bet hypothetical bet in wei\n', '    * @param _gtaBet hypothetical bet in GTA\n', '    * @return The prediction in wei\n', '    */\n', '    function prizeProjection(uint256 _bet, uint256 _gtaBet) public view returns (uint256) {\n', '        return getLastRound().projectedPrizeForPlayer(msg.sender, aggregateBet(_bet, _gtaBet));\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Deposit GTA to the EthBattle contract so it can be spent (used) immediately\n', '    * Note: this call must follow the approve() call on the token itself\n', '    * @param _amount amount to deposit\n', '    */\n', '    function depositGTA(uint256 _amount) public {\n', '        require(token.transferFrom(msg.sender, this, _amount), "Insufficient funds");\n', '        tokens[msg.sender] = tokens[msg.sender].add(_amount);\n', '        emit Deposit(msg.sender, _amount, tokens[msg.sender]);\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw GTA from this contract to the own (caller) address\n', '    * @param _amount amount to withdraw\n', '    */\n', '    function withdrawGTA(uint256 _amount) public {\n', '        require(tokens[msg.sender] >= _amount, "Amount exceeds the available balance");\n', '        tokens[msg.sender] = tokens[msg.sender].sub(_amount);\n', '        require(token.transfer(msg.sender, _amount), "Amount exceeds the available balance");\n', '        emit Withdraw(msg.sender, _amount, tokens[msg.sender]);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal transfer of the token.\n', '    * Funds remain in this contract but become available for withdrawal\n', '    */\n', '    function transferInternally(address _from, address _to, uint256 _amount) internal {\n', '        require(tokens[_from] >= _amount, "Too much to transfer");\n', '        tokens[_from] = tokens[_from].sub(_amount);\n', '        tokens[_to] = tokens[_to].add(_amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Interrupts the round to enable participants to claim funds back\n', '    */\n', '    function interruptLastRound() onlyOwner public {\n', '        getLastRound().enableRefunds();\n', '    }\n', '\n', '    /**\n', '    * @dev End last round so no new plays is possible, but ongoing plays are fine to win\n', '    */\n', '    function finishLastRound() onlyOwner public {\n', '        getLastRound().coolDown();\n', '    }\n', '\n', '    function getLastRound() public view returns (RoundInterface){\n', '        return RoundInterface(rounds[roundIndex]);\n', '    }\n', '\n', '    function getLastRoundAddress() external view returns (address){\n', '        return rounds[roundIndex];\n', '    }\n', '\n', '    function balanceOf(address _user) public view returns (uint256) {\n', '        return tokens[_user];\n', '    }\n', '\n', '    function setPlaySeed(address _playSeedAddress) onlyOwner public {\n', '        playSeedGenerator = PlaySeedInterface(_playSeedAddress);\n', '    }\n', '\n', '    function setStore(address _storeAddress) onlyOwner public {\n', '        store = AMUStoreInterface(_storeAddress);\n', '    }\n', '\n', '    function getTokenBuyPrice() public view returns (uint256) {\n', '        return store.getTokenBuyPrice();\n', '    }\n', '\n', '    function getTokenSellPrice() public view returns (uint256) {\n', '        return store.getTokenSellPrice();\n', '    }\n', '\n', '    /**\n', '    * @dev Recover the history of referrals in case of the contract migration.\n', '    */\n', '    function setReferralsMap(address[] _players, address[] _referrals) onlyOwner public {\n', '        require(_players.length == _referrals.length, "Size of players must be equal to the size of referrals");\n', '        for (uint i = 0; i < _players.length; ++i) {\n', '            referralBacklog[_players[i]] = _referrals[i];\n', '        }\n', '    }\n', '\n', '    function getStartersProxyAddress() external view returns (address) {\n', '        return startersProxyAddress;\n', '    }\n', '\n', '    function setStartersProxyAddress(address _newProxyAddress) onlyOwner public  {\n', '        startersProxyAddress = _newProxyAddress;\n', '    }\n', '\n', '    function setMetaBetWeight(uint256 _newMetaBet) onlyOwner public {\n', '        META_BET_WEIGHT = _newMetaBet;\n', '    }\n', '\n', '    function setMinBet(uint256 _newMinBet) onlyOwner public {\n', '        MIN_PLAY_AMOUNT = _newMinBet;\n', '    }\n', '\n', '}\n', '/**\n', ' * @title PlaySeed contract interface\n', ' */\n', 'interface PlaySeedInterface {\n', '\n', '    function newPlaySeed(address _player) external;\n', '\n', '    function findSeed(address _player) external view returns (bytes32);\n', '\n', '    function cleanSeedUp(address _player) external;\n', '\n', '    function claimOwnership() external;\n', '\n', '}\n', '\n', '/**\n', ' * @title GTA contract interface\n', ' */\n', 'interface GTAInterface {\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title EthBattleRound contract interface\n', ' */\n', 'interface RoundInterface {\n', '\n', '    function claimOwnership() external;\n', '\n', '    function setReferral(address _player, address _referral) external;\n', '\n', '    function playRound(address _player, uint256 _bet) external payable;\n', '\n', '    function enableRefunds() external;\n', '\n', '    function coolDown() external;\n', '\n', '    function currentPrize(address _player) external view returns (uint256);\n', '\n', '    function projectedPrizeForPlayer(address _player, uint256 _bet) external view returns (uint256);\n', '\n', '    function win(address _player) external;\n', '\n', '    function getDevWallet() external view returns (address);\n', '\n', '}\n', '\n', '/**\n', ' * @title Ammu-Nation contract interface\n', ' */\n', 'interface AMUStoreInterface {\n', '\n', '    function getTokenBuyPrice() external view returns (uint256);\n', '\n', '    function getTokenSellPrice() external view returns (uint256);\n', '\n', '}']