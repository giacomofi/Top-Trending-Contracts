['pragma solidity ^0.4.23;\n', '/**\n', ' * @title WinEtherPot10 ver 1.0 Prod\n', ' * @dev The WinEtherPot contract is an ETH lottery contract\n', ' * that allows unlimited entries at the cost of 0.1 ETH per entry.\n', ' * Winners are rewarded the pot.\n', ' */\n', 'contract WinEtherPot10 {\n', ' \n', '     \n', '    address public owner; \t\t\t\t\t// Contract Creator\n', '    uint private latestBlockNumber;         // Latest Block Number on BlockChain\n', '    bytes32 private cumulativeHash;\t\t\t\n', '    address[] private bets;\t\t\t\t\t// address list of people applied\n', '    mapping(address => uint256) winners;    // Winners\n', '\t\n', '\tuint256 ownerShare = 5;\n', '\tuint256 winnerShare = 95;\n', '\tbool splitAllowed = true;\n', '\t\n', '\tuint256 public minEntriesRequiredPerGame = 3;\n', '\tuint256 playerCount = 0;\n', '\tuint256 public potSize;\n', '\t\n', '\tbool autoDistributeWinning = true;   // when manual withdraw happens, distribute winnings also\n', '\t\n', '\tbool autoWithdrawWinner = true;   // autoWithdrawWinner and distribute winnings also\n', '\t\t\n', '\tbool public isRunning = true;\n', '\t\n', '\tuint256 public minEntryInWei = (1/10) * 1e18; // 0.1 Ether\n', ' \t\n', '    \n', '\t// Bet placing events\n', '    event betPlaced(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\n', '    event betStarted(address thePersonWhoBet, uint moneyInWei );\n', '    event betAccepted(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\n', '\tevent betNotPlaced(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\n', '      \n', '\t// winner draw events\n', '    event startWinnerDraw(uint256 randomInt, address winner, uint blockNumber , uint256 amountWonByThisWinner );\t\n', '\t\n', '\t// amount won\n', '\tevent amountWonByOwner(address ownerWithdrawer,  uint256 amount);\n', '\tevent amountWonByWinner(address winnerWithdrawer,  uint256 amount);\n', '\t\n', '\t// withdraw events\n', '    event startWithDraw(address withdrawer,  uint256 amount);\n', '\tevent successWithDraw(address withdrawer,  uint256 amount);\n', '\tevent rollbackWithDraw(address withdrawer,  uint256 amount);\n', '\t\n', '    event showParticipants(address[] thePersons);\n', '    event showBetNumber(uint256 betNumber, address better);\n', '    \n', '    event calledConstructor(uint block, address owner);\n', '\t\n', '\tevent successDrawWinner(bool successFlag ); \n', '\tevent notReadyDrawWinner(bool errorFlag ); \n', ' \n', '    /**\n', '\t*    @dev Constructor only called once\n', '\t**/ \n', '\tconstructor() public {\n', '        owner = msg.sender;\n', '        latestBlockNumber = block.number;\n', '        cumulativeHash = bytes32(0);\n', '        \n', '        emit calledConstructor(latestBlockNumber, owner);\n', '    }\n', ' \n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', ' \n', '    /**\n', '     * @dev Send 0.1 ETHER Per Bet.\n', '     */\n', '    function placeBet() public payable returns (bool) {\n', '        \n', '\t\tif( isRunning == true ) {\n', '\t\t\n', '\t\t\tuint _wei = msg.value;\n', '\t\t\t\t   \n', '\t\t\temit betStarted(msg.sender , msg.value);\n', '\t\t\t//require(_wei >= 0.1 ether);\n', '\t\t\tassert(_wei >= minEntryInWei);\n', '\t\t\tcumulativeHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber), cumulativeHash));\n', '\t\t\t\n', '\t\t\temit betPlaced(msg.sender , msg.value , block.number);\n', '\t\t\t\n', '\t\t\tlatestBlockNumber = block.number;\n', '\t\t\tbets.push(msg.sender);\n', '\t\t\t\n', '\t\t\temit betAccepted(msg.sender , msg.value , block.number);\n', '\t\t\t\n', '\t\t\tpotSize = potSize + msg.value;\n', '\t\t}else {\n', '\t\t\t\n', '\t\t\temit betNotPlaced(msg.sender , msg.value , block.number);\n', '\t\t}\n', '\t\t\n', '\t\tif( autoWithdrawWinner == true ) {\n', '\t\t\t\n', '\t\t\tif( bets.length >= minEntriesRequiredPerGame ) {\n', '\t\t\t\tbool successDrawWinnerFlag = drawAutoWinner();\n', '\t\t\t\temit successDrawWinner(successDrawWinnerFlag);\n', '\t\t\t}else {\n', '\t\t\t    emit notReadyDrawWinner(false);\n', '\t\t\t}\n', '\t\t}\n', '        return true;\n', '    }\n', ' \n', '    function drawAutoWinner() private returns (bool) {\n', '        \n', '\t\tbool boolSuccessFlag = false;\n', '\t\t\n', '\t\tassert( bets.length >= minEntriesRequiredPerGame );\n', '        \n', '\t\tlatestBlockNumber = block.number;\n', '        \n', '\t\tbytes32 _finalHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber-1), cumulativeHash));\n', '        \n', '\t\tuint256 _randomInt = uint256(_finalHash) % bets.length;\n', '        \n', '\t\taddress _winner = bets[_randomInt];\n', '\t\t\n', '\t\tuint256 amountWon = potSize ;\n', '        \n', '\t\tuint256 ownerAmt = amountWon * ownerShare /100 ;\n', '\t\t\n', '\t\tuint256 winnerAmt = amountWon * winnerShare / 100 ;\n', '\t\t\n', '\t\t\n', '\t\t\n', '\t\t\n', '\t\tif( splitAllowed == true ) {\n', '\t\t\n', '\t\t    emit startWinnerDraw(_randomInt, _winner, latestBlockNumber , winnerAmt );\n', '\t\t\twinners[_winner] = winnerAmt;\n', '\t\t\towner.transfer(ownerAmt);\n', '\t\t\temit amountWonByOwner(owner, ownerAmt);\n', '\t\t\t\n', '\t\t\tif( autoDistributeWinning == true ) {\n', '\t\t\t   \n', '\t\t\t\twinners[_winner] = 0;\n', '\t\t\t\t\n', '\t\t\t\tif( _winner.send(winnerAmt)) {\n', '\t\t\t\t   emit successWithDraw(_winner, winnerAmt);\n', '\t\t\t\t   emit amountWonByWinner(_winner, winnerAmt);\n', '\t\t\t\t   \n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t  winners[_winner] = winnerAmt;\n', '\t\t\t\t  emit rollbackWithDraw(_winner, winnerAmt);\n', '\t\t\t\t  \n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t\n', '\t\t} else {\n', '\t\t\n', '\t\t    emit startWinnerDraw(_randomInt, _winner, latestBlockNumber , amountWon );\n', '\t\t\twinners[_winner] = amountWon;\n', '\t\t\t\n', '\t\t\tif( autoDistributeWinning == true ) {\n', '\t\t\t   \n', '\t\t\t\twinners[_winner] = 0;\n', '\t\t\t\t\n', '\t\t\t\tif( _winner.send(amountWon)) {\n', '\t\t\t\t   emit successWithDraw(_winner, amountWon);\n', '\t\t\t\t   emit amountWonByWinner(_winner, amountWon);\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t  winners[_winner] = amountWon;\n', '\t\t\t\t  emit rollbackWithDraw(_winner, amountWon);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\t\t\n', '        cumulativeHash = bytes32(0);\n', '        delete bets;\n', '\t\t\n', '\t\tpotSize = 0;\n', '\t\t\n', '\t\t\n', '\t\tboolSuccessFlag = true;\n', '\t\t\n', '        return boolSuccessFlag;\n', '    }\n', '\t\n', '\t\n', '\tfunction drawWinner() public onlyOwner returns (address) {\n', '        \n', '\t\tassert( bets.length >= minEntriesRequiredPerGame );\n', '        \n', '\t\tlatestBlockNumber = block.number;\n', '        \n', '\t\tbytes32 _finalHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber-1), cumulativeHash));\n', '        \n', '\t\tuint256 _randomInt = uint256(_finalHash) % bets.length;\n', '        \n', '\t\taddress _winner = bets[_randomInt];\n', '\t\t\n', '\t\tuint256 amountWon = potSize ;\n', '        \n', '\t\tuint256 ownerAmt = amountWon * ownerShare /100 ;\n', '\t\t\n', '\t\tuint256 winnerAmt = amountWon * winnerShare / 100 ;\n', '\t\t\n', '\t\tif( splitAllowed == true ) {\n', '\t\t\twinners[_winner] = winnerAmt;\n', '\t\t\towner.transfer(ownerAmt);\n', '\t\t\temit amountWonByOwner(owner, ownerAmt);\n', '\t\t\t\n', '\t\t\tif( autoDistributeWinning == true ) {\n', '\t\t\t   \n', '\t\t\t\twinners[_winner] = 0;\n', '\t\t\t\t\n', '\t\t\t\tif( _winner.send(winnerAmt)) {\n', '\t\t\t\t   emit successWithDraw(_winner, winnerAmt);\n', '\t\t\t\t   emit amountWonByWinner(_winner, winnerAmt);\n', '\t\t\t\t   \n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t  winners[_winner] = winnerAmt;\n', '\t\t\t\t  emit rollbackWithDraw(_winner, winnerAmt);\n', '\t\t\t\t  \n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t\n', '\t\t} else {\n', '\t\t\twinners[_winner] = amountWon;\n', '\t\t\t\n', '\t\t\tif( autoDistributeWinning == true ) {\n', '\t\t\t   \n', '\t\t\t\twinners[_winner] = 0;\n', '\t\t\t\t\n', '\t\t\t\tif( _winner.send(amountWon)) {\n', '\t\t\t\t   emit successWithDraw(_winner, amountWon);\n', '\t\t\t\t   emit amountWonByWinner(_winner, amountWon);\n', '\t\t\t\t}\n', '\t\t\t\telse {\n', '\t\t\t\t  winners[_winner] = amountWon;\n', '\t\t\t\t  emit rollbackWithDraw(_winner, amountWon);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\t\t\n', '        cumulativeHash = bytes32(0);\n', '        delete bets;\n', '\t\t\n', '\t\tpotSize = 0;\n', '\t\t\n', '\t\temit startWinnerDraw(_randomInt, _winner, latestBlockNumber , winners[_winner] );\n', '\t\t\n', '        return _winner;\n', '    }\n', '\t\n', ' \n', '\t\n', '\t/**\n', '     * @dev Withdraw your winnings yourself\n', '     */\n', '    function withdraw() public returns (bool) {\n', '        uint256 amount = winners[msg.sender];\n', '\t\t\n', '\t\temit startWithDraw(msg.sender, amount);\n', '\t\t\t\n', '        winners[msg.sender] = 0;\n', '\t\t\n', '        if (msg.sender.send(amount)) {\n', '\t\t\n', '\t\t    emit successWithDraw(msg.sender, amount);\n', '            return true;\n', '        } else {\n', '            winners[msg.sender] = amount;\n', '\t\t\t\n', '\t\t\temit rollbackWithDraw(msg.sender, amount);\n', '\t\t\t\n', '            return false;\n', '        }\n', '    }\n', ' \n', '\t/**\n', '     * @dev List of Participants\n', '     */\n', '    function getParticipants() public onlyOwner returns (address[]) {\n', '       emit showParticipants(bets);\n', '       return bets;\n', '    }\n', '\t\n', '\t/**\n', '     * @dev Start / Stop the game\n', '     */\n', '\tfunction startTheGame() public onlyOwner returns (bool) {\n', '        \n', '       if( isRunning == false ) {\n', '\t\t\tisRunning = true;\n', '\t   }else {\n', '\t\t\tisRunning = false;\n', '\t   }\n', '\t   \n', '       return isRunning;\n', '    }\n', ' \n', '    /**\n', '     * @dev Set min number of enteried - dupe entried allowed\n', '     */\n', '    function setMinEntriesRequiredPerGame(uint256 entries) public onlyOwner returns (bool) {\n', '        \n', '        minEntriesRequiredPerGame = entries;\n', '        return true;\n', '    }\n', '\t\n', '\t\n', '\t/**\n', '     * @dev Set Min bet in wei\n', '     */\n', '    function setMinBetAmountInWei(uint256 amount) public onlyOwner returns (bool) {\n', '        \n', '        minEntryInWei = amount ;\n', '        return true;\n', '    }\n', '\t\n', '\t\n', '\t\n', '     /**\n', '     * @dev Get address for Bet\n', '     */\n', '    function getBet(uint256 betNumber) public returns (address) {\n', '        \n', '        emit showBetNumber(betNumber,bets[betNumber]);\n', '        return bets[betNumber];\n', '    }\n', ' \n', '\n', '    /**\n', '     * @dev Get no of Entries in Contract\n', '     */\n', '    function getNumberOfBets() public view returns (uint256) {\n', '        return bets.length;\n', '    }\n', '\t\n', '\n', '\t/**\n', '     * @dev Get min Entries required to start the draw\n', '     */\n', '    function minEntriesRequiredPerGame() public view returns (uint256) {\n', '        return minEntriesRequiredPerGame;\n', '    }\n', '\t\n', '\t/**\n', '     * @dev owner share\n', '     */\n', '    function contractOwnerSharePercentage() public view returns (uint256) {\n', '        return ownerShare;\n', '    }\n', '\t\n', '\t\n', '\t\n', '\t\n', '\t/**\n', '     * @dev winner share\n', '     */\n', '    function winnerSharePercentage() public view returns (uint256) {\n', '        return winnerShare;\n', '    }\n', '\t\n', '\t\n', '\t/**\n', '     * @dev pot size in wei\n', '     */\n', '    function potSizeInWei() public view returns (uint256) {\n', '        return potSize;\n', '    }\n', '\t\n', '\t\n', '\t/**\n', '     * @dev Destroy Contract\n', '     */\n', '\tfunction destroy() onlyOwner public { \n', '\t\tuint256 potAmount =  potSize;\n', '\t\towner.transfer(potAmount);\n', '\t\tselfdestruct(owner);  \n', '\t}\n', '}']