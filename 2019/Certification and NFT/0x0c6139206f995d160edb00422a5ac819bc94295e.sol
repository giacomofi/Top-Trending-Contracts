['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-11\n', '*/\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `+` operator.\n', '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * Counterpart to Solidity&#39;s `-` operator.\n', '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', '     * Counterpart to Solidity&#39;s `*` operator.\n', '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a\n', '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', '     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`\n', '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function transferFrom(address src, address dst, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function approve(address guy, uint wad) public returns (bool);\n', '}\n', '\n', 'contract UniswapInterface {\n', '    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256 eth_bought);\n', '    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256 eth_sold);\n', '    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256 tokens_bought);\n', '}\n', '\n', 'contract ChainBot3000 is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    ERC20Interface DaiContract;\n', '    UniswapInterface UniswapContract;\n', '    \n', '    event Deposit(address indexed _address, bytes32 indexed _steamid, uint256 _amount);\n', '    event Deposit(address indexed _address, bytes32 indexed _steamid, uint256 _amount, uint256 _value);\n', '    event Purchase(address indexed _address, bytes32 indexed _steamid, bytes32 _offerid, uint256 _amount);\n', '    event Purchase(address indexed _address, bytes32 indexed _steamid, bytes32 _offerid, uint256 _amount, uint256 _value);\n', '\n', '    mapping(bytes32 => uint256) public deposits;\n', '    \n', '    constructor(address _daiAddress, address _uniswapAddress) public {\n', '        initDai(_daiAddress);\n', '        initUniswap(_uniswapAddress);\n', '        setAllowance(_uniswapAddress, uint256(-1));\n', '    }\n', '    \n', '    function initDai(address _address) public onlyOwner {\n', '        DaiContract = ERC20Interface(_address);\n', '    }\n', '    \n', '    function initUniswap(address _address) public onlyOwner {\n', '        UniswapContract = UniswapInterface(_address);\n', '    }\n', '    \n', '\tfunction setAllowance(address _address, uint256 _amount) public onlyOwner returns (bool){\n', '\t    return DaiContract.approve(_address, _amount);\n', '\t}\n', '\t\n', '    function depositOutput(bytes32 _steamid, uint256 _tokens_bought, uint256 _deadline) external payable {\n', '        uint256 eth_sold = UniswapContract.ethToTokenTransferOutput.value(msg.value)(_tokens_bought, _deadline, address(this));\n', '        uint256 refund = msg.value - eth_sold;\n', '        if(refund > 0){\n', '            msg.sender.transfer(refund);\n', '        }\n', '        deposits[_steamid] = deposits[_steamid].add(_tokens_bought);\n', '        emit Deposit(msg.sender, _steamid, _tokens_bought, eth_sold);\n', '    }\n', '    \n', '    function depositInput(bytes32 _steamid, uint256 _min_tokens, uint256 _deadline) external payable {\n', '        uint256 tokens_bought = UniswapContract.ethToTokenTransferInput.value(msg.value)(_min_tokens, _deadline, address(this));\n', '        deposits[_steamid] = deposits[_steamid].add(tokens_bought);\n', '        emit Deposit(msg.sender, _steamid, tokens_bought, msg.value);\n', '    }\n', '    \n', '    function depositDai(bytes32 _steamid, uint _amount) external {\n', '        assert(DaiContract.transferFrom(msg.sender, address(this), _amount));\n', '        deposits[_steamid] = deposits[_steamid].add(_amount);\n', '        emit Deposit(msg.sender, _steamid, _amount);\n', '\t}\n', '\t\n', '    function sendEth(uint256 _tokens_sold, uint256 _min_eth, uint256 _deadline, address _recipient, bytes32 _steamid, bytes32 _offerid) external onlyOwner {\n', '\t    uint256 eth_bought = UniswapContract.tokenToEthTransferInput(_tokens_sold, _min_eth, _deadline, _recipient);\n', '\t    emit Purchase(_recipient, _steamid, _offerid, _tokens_sold, eth_bought);\n', '\t}\n', '\t\n', '\tfunction sendDai(address _address, uint256 _amount, bytes32 _steamid, bytes32 _offerid) external onlyOwner {\n', '    \tassert(DaiContract.transfer(_address, _amount));\n', '    \temit Purchase(_address, _steamid, _offerid, _amount);\n', '\t}\n', '\t\n', '\tfunction() external payable { require(msg.data.length == 0); }\n', '\t\n', '\tfunction cashOut() external onlyOwner {\n', '\t    msg.sender.transfer(address(this).balance);\n', '\t}\n', '}']