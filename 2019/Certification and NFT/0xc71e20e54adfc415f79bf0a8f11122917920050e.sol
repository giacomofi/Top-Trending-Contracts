['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-11\n', '*/\n', '\n', 'pragma solidity ^0.5.2;\n', '// tested in solidity 0.5.8\n', '// using openzeppelin-solidity-2.2.0\n', '\n', '// import "../../utils/Address.sol";\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', '// import "../../math/SafeMath.sol";\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '\n', '// import "./IERC20.sol";\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', '        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0));\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must equal true).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since\n', '        // we&#39;re implementing it ourselves.\n', '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '\n', '        require(address(token).isContract());\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success);\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            require(abi.decode(returndata, (bool)));\n', '        }\n', '    }\n', '}\n', '/////////////////////////////////////////////////////////////////////////\n', '// ownership/Ownable.sol\n', '///////////////////////////////////////////////////////////////////////\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve an address to spend another addresses&#39; tokens.\n', '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account, deducting from the sender&#39;s allowance for said account. Uses the\n', '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '/////////////////////////////////////////////////////////////////////////\n', '// ERC20Detailed\n', '///////////////////////////////////////////////////////////////////////\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @return the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @return the symbol of the token.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @return the number of decimals of the token.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '/////////////////////////////////////////////////////////////////////////\n', '// ownership/Ownable.sol\n', '///////////////////////////////////////////////////////////////////////\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor (address Owner) internal {\n', '        _owner = Owner;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    // function renounceOwnership() public onlyOwner {\n', '    //     emit OwnershipTransferred(_owner, address(0));\n', '    //     _owner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    // function transferOwnership(address newOwner) public onlyOwner {\n', '    //     _transferOwnership(newOwner);\n', '    // }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    // function _transferOwnership(address newOwner) internal {\n', '    //     require(newOwner != address(0));\n', '    //     emit OwnershipTransferred(_owner, newOwner);\n', '    //     _owner = newOwner;\n', '    // }\n', '}\n', '\n', '/////////////////////////////////////////////////////////////////////////\n', '// LockerPool Contract\n', '/////////////////////////////////////////////////////////////////////////\n', 'contract LockerPool is Ownable {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 public token;\n', '    uint256 public lockMonths;\n', '\n', '    uint256 public INITIAL_LOCK_AMOUNT;\n', '\n', '    uint256 public lockDays;\n', '    uint256 public lockDaysTime;\n', '\n', '    modifier checkBeneficiaryExist(address _addr) {\n', '        require(beneficiaryList.length-1 != 0);\n', '        require(userBeneficiaryMap[_addr] != 0);\n', '        require(beneficiaryList[userBeneficiaryMap[_addr]].beneficiaryAddr == _addr);\n', '        _;\n', '    }\n', '\n', '    function balanceOfPool() public view returns (uint256){\n', '        return token.balanceOf(address(this));\n', '    }\n', '\n', '    function getRemainAmount() public view returns (uint256) {\n', '        return INITIAL_LOCK_AMOUNT.sub(getAllocatedAmount());\n', '    }\n', '\n', '    function totalBeneficiaryCount() public view returns (uint256) {\n', '        return beneficiaryList.length-1;\n', '    }\n', '\n', '    function getAllocatedAmount() public view returns (uint256){\n', '        uint256 _beneficiaryCount = beneficiaryList.length;\n', '        uint256 totalValue;\n', '        for (uint256 i=1; i < _beneficiaryCount; i++) { // start from 1, for using 0 as null\n', '            totalValue = totalValue.add(beneficiaryList[i].initialAmount);\n', '        }\n', '        return totalValue;\n', '    }\n', '\n', '    function _checkIsReleasable(address addr, uint256 releasingPointId) internal view returns(bool){\n', '        if (beneficiaryList[userBeneficiaryMap[addr]].releasingPointStateList[releasingPointId] == false &&\n', '            now >= beneficiaryList[userBeneficiaryMap[addr]].releasingPointDateList[releasingPointId]) {\n', '                return true;\n', '        }\n', '        else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function checkIsReleasableById(uint256 id, uint256 releasingPointId) internal view returns(bool){\n', '        if (beneficiaryList[id].releasingPointStateList[releasingPointId] == false &&\n', '            now >= beneficiaryList[id].releasingPointDateList[releasingPointId]) {\n', '                return true;\n', '        }\n', '        else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function getUnlockedAmountPocket(address addr) public checkBeneficiaryExist(addr) view returns (uint256) {\n', '\n', '        uint256 totalValue;\n', '        for (uint256 i=0; i < lockMonths; i++) {\n', '\n', '            if (_checkIsReleasable(addr, i)){\n', '                totalValue = totalValue.add(beneficiaryList[userBeneficiaryMap[addr]].releasingPointValueList[i]);\n', '            }\n', '        }\n', '        return totalValue;\n', '    }\n', '\n', '    function getTransferCompletedAmount() public view returns (uint256) {\n', '        uint256 _beneficiaryCount = beneficiaryList.length;\n', '        uint256 totalValue;\n', '        for (uint256 i=1; i < _beneficiaryCount; i++) { // start from 1, for using 0 as null\n', '            totalValue = totalValue.add(beneficiaryList[i].transferCompletedAmount);\n', '        }\n', '        return totalValue;\n', '    }\n', '\n', '    function getReleasingPoint(uint256 beneficiaryId, uint256 index) public view returns (uint256 _now, uint256 date, uint256 value, bool state, bool releasable){\n', '        return (now, beneficiaryList[beneficiaryId].releasingPointDateList[index], beneficiaryList[beneficiaryId].releasingPointValueList[index], beneficiaryList[beneficiaryId].releasingPointStateList[index], checkIsReleasableById(beneficiaryId, index));\n', '    }\n', '\n', '    event AllocateLockupToken(address indexed beneficiaryAddr, uint256 initialAmount, uint256 lockupPeriodStartDate, uint256 releaseStartDate, uint256 releaseEndDate, uint256 id);\n', '\n', '    struct Beneficiary {\n', '        uint256 id;\n', '        address beneficiaryAddr;\n', '        uint256 initialAmount;\n', '        uint256 transferCompletedAmount;\n', '        uint256 lockupPeriodStartDate;  // ownerGivedDate\n', '        uint256 releaseStartDate; // lockupPeriodEnxDate\n', '        uint256[] releasingPointDateList;\n', '        uint256[] releasingPointValueList;\n', '        bool[] releasingPointStateList;\n', '        uint256 releaseEndDate;\n', '        uint8 bType;\n', '    }\n', '\n', '    Beneficiary[] public beneficiaryList;\n', '    mapping (address => uint256) public userBeneficiaryMap;\n', '    /**\n', '     * @dev Constructor that gives msg.sender all of existing tokens.\n', '     */\n', '    constructor (uint256 _lockMonths, uint256 _lockAmount, address poolOwner, address tokenAddr) public Ownable(poolOwner){\n', '        require(36 >= _lockMonths); // optional\n', '        token = IERC20(tokenAddr);\n', '        lockMonths = _lockMonths;\n', '        INITIAL_LOCK_AMOUNT = _lockAmount;\n', '        lockDays = lockMonths * 30;  // 1 mounth ~= 30 days\n', '        lockDaysTime = lockDays * 60 * 60 * 24; // 1 day == 86400 sec\n', '        beneficiaryList.length = beneficiaryList.length.add(1); // start from 1, for using 0 as null\n', '    }\n', '\n', '    function allocateLockupToken(address _beneficiaryAddr, uint256 amount, uint8 _type) onlyOwner public returns (uint256 _beneficiaryId) {\n', '        require(userBeneficiaryMap[_beneficiaryAddr] == 0);  // already check\n', '        require(getRemainAmount() >= amount);\n', '        Beneficiary memory beneficiary = Beneficiary({\n', '            id: beneficiaryList.length,\n', '            beneficiaryAddr: _beneficiaryAddr,\n', '            initialAmount: amount,\n', '            transferCompletedAmount: 0,\n', '            lockupPeriodStartDate: uint256(now), // now == block.timestamp\n', '            releaseStartDate: uint256(now).add(lockDaysTime),\n', '            releasingPointDateList: new uint256[](lockMonths), // not return in ABCI v1\n', '            releasingPointValueList: new uint256[](lockMonths),\n', '            releasingPointStateList: new bool[](lockMonths),\n', '            releaseEndDate: 0,\n', '            bType: _type\n', '            });\n', '\n', '        beneficiary.releaseEndDate = beneficiary.releaseStartDate.add(lockDaysTime);\n', '        uint256 remainAmount = beneficiary.initialAmount;\n', '        for (uint256 i=0; i < lockMonths; i++) {\n', '            beneficiary.releasingPointDateList[i] = beneficiary.releaseStartDate.add(lockDaysTime.div(lockMonths).mul(i.add(1)));\n', '            beneficiary.releasingPointStateList[i] = false;\n', '            if (i.add(1) != lockMonths){\n', '                beneficiary.releasingPointValueList[i] = uint256(beneficiary.initialAmount.div(lockMonths));\n', '                remainAmount = remainAmount.sub(beneficiary.releasingPointValueList[i]);\n', '            }\n', '            else{\n', '                beneficiary.releasingPointValueList[i] = remainAmount;\n', '            }\n', '        }\n', '\n', '        beneficiaryList.push(beneficiary);\n', '        userBeneficiaryMap[_beneficiaryAddr] = beneficiary.id;\n', '\n', '        emit AllocateLockupToken(beneficiary.beneficiaryAddr, beneficiary.initialAmount, beneficiary.lockupPeriodStartDate, beneficiary.releaseStartDate, beneficiary.releaseEndDate, beneficiary.id);\n', '        return beneficiary.id;\n', '    }\n', '    event Claim(address indexed beneficiaryAddr, uint256 indexed beneficiaryId, uint256 value);\n', '    function claim () public checkBeneficiaryExist(msg.sender) returns (uint256) {\n', '        uint256 unlockedAmount = getUnlockedAmountPocket(msg.sender);\n', '        require(unlockedAmount > 0);\n', '\n', '        uint256 totalValue;\n', '        for (uint256 i=0; i < lockMonths; i++) {\n', '            if (_checkIsReleasable(msg.sender, i)){\n', '                beneficiaryList[userBeneficiaryMap[msg.sender]].releasingPointStateList[i] = true;\n', '                totalValue = totalValue.add(beneficiaryList[userBeneficiaryMap[msg.sender]].releasingPointValueList[i]);\n', '            }\n', '        }\n', '        require(unlockedAmount == totalValue);\n', '        token.safeTransfer(msg.sender, totalValue);\n', '        beneficiaryList[userBeneficiaryMap[msg.sender]].transferCompletedAmount = beneficiaryList[userBeneficiaryMap[msg.sender]].transferCompletedAmount.add(totalValue);\n', '        emit Claim(beneficiaryList[userBeneficiaryMap[msg.sender]].beneficiaryAddr, beneficiaryList[userBeneficiaryMap[msg.sender]].id, totalValue);\n', '        return totalValue;\n', '    }\n', '}\n', '\n', '/////////////////////////////////////////////////////////////////////////\n', '// ToriToken Contract\n', '/////////////////////////////////////////////////////////////////////////\n', 'contract ToriToken is ERC20, ERC20Detailed {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '    uint8 public constant DECIMALS = 18;\n', '    uint256 public constant INITIAL_SUPPLY = 4000000000 * (10 ** uint256(DECIMALS));\n', '\n', '    uint256 public remainReleased = INITIAL_SUPPLY;\n', '\n', '    address private _owner;\n', '\n', '    // no lockup ( with addresses )\n', '    address public initialSale = 0x4dEF0A02D30cdf62AB6e513e978dB8A58ed86B53;\n', '    address public saleCPool = 0xF3963A437E0e156e8102414DE3a9CC6E38829ea1;\n', '    address public ecoPool = 0xf6e25f35C3c5cF40035B7afD1e9F5198594f600e;\n', '    address public reservedPool = 0x557e4529D5784D978fCF7A5a20a184a78AF597D5;\n', '    address public marketingPool = 0xEeE05AfD6E1e02b6f86Dd1664689cC46Ab0D7B20;\n', '\n', '    uint256 public initialSaleAmount = 600000000 ether;\n', '    uint256 public saleCPoolAmount = 360000000 ether;\n', '    uint256 public ecoPoolAmount = 580000000 ether;\n', '    uint256 public reservedPoolAmount = 600000000 ether;\n', '    uint256 public marketingPoolAmount = 80000000 ether;\n', '\n', '    // with lockup ( with addresses )\n', '    address public saleBPoolOwner = 0xB7F1ea2af2a9Af419F093f62bDD67Df914b0ff2E;\n', '    address public airDropPoolOwner = 0x590d6d6817ed53142BF69F16725D596dAaE9a6Ce;\n', '    address public companyPoolOwner = 0x1b0E91D484eb69424100A48c74Bfb450ea494445;\n', '    address public productionPartnerPoolOwner = 0x0c0CD85EA55Ea1B6210ca89827FA15f9F10D56F6;\n', '    address public advisorPoolOwner = 0x68F0D15D17Aa71afB14d72C97634977495dF4d0E;\n', '    address public teamPoolOwner = 0x5A353e276F68558bEA884b13017026A6F1067951;\n', '\n', '    uint256 public saleBPoolAmount = 420000000 ether;\n', '    uint256 public airDropPoolAmount = 200000000 ether;\n', '    uint256 public companyPoolAmount = 440000000 ether;\n', '    uint256 public productionPartnerPoolAmount = 200000000 ether;\n', '    uint256 public advisorPoolAmount = 120000000 ether;\n', '    uint256 public teamPoolAmount = 400000000 ether;\n', '\n', '    uint8 public saleBPoolLockupPeriod = 12;\n', '    uint8 public airDropPoolLockupPeriod = 3;\n', '    uint8 public companyPoolLockupPeriod = 12;\n', '    uint8 public productionPartnerPoolLockupPeriod = 6;\n', '    uint8 public advisorPoolLockupPeriod = 12;\n', '    uint8 public teamPoolLockupPeriod = 24;\n', '\n', '    LockerPool public saleBPool;\n', '    LockerPool public airDropPool;\n', '    LockerPool public companyPool;\n', '    LockerPool public productionPartnerPool;\n', '    LockerPool public advisorPool;\n', '    LockerPool public teamPool;\n', '\n', '    bool private _deployedOuter;\n', '    bool private _deployedInner;\n', '\n', '    function deployLockersOuter() public {\n', '        require(!_deployedOuter);\n', '        saleBPool = new LockerPool(saleBPoolLockupPeriod, saleBPoolAmount, saleBPoolOwner, address(this));\n', '        airDropPool = new LockerPool(airDropPoolLockupPeriod, airDropPoolAmount, airDropPoolOwner, address(this));\n', '        productionPartnerPool = new LockerPool(productionPartnerPoolLockupPeriod, productionPartnerPoolAmount, productionPartnerPoolOwner, address(this));\n', '        _deployedOuter = true;\n', '        _mint(address(saleBPool), saleBPoolAmount);\n', '        _mint(address(airDropPool), airDropPoolAmount);\n', '        _mint(address(productionPartnerPool), productionPartnerPoolAmount);\n', '    }\n', '\n', '    function deployLockersInner() public {\n', '        require(!_deployedInner);\n', '        companyPool = new LockerPool(companyPoolLockupPeriod, companyPoolAmount, companyPoolOwner, address(this));\n', '        advisorPool = new LockerPool(advisorPoolLockupPeriod, advisorPoolAmount, advisorPoolOwner, address(this));\n', '        teamPool = new LockerPool(teamPoolLockupPeriod, teamPoolAmount, teamPoolOwner, address(this));\n', '        _deployedInner = true;\n', '        _mint(address(companyPool), companyPoolAmount);\n', '        _mint(address(advisorPool), advisorPoolAmount);\n', '        _mint(address(teamPool), teamPoolAmount);\n', '    }\n', '\n', '    constructor () public ERC20Detailed("Storichain", "TORI", DECIMALS) {\n', '        _mint(address(initialSale), initialSaleAmount);\n', '        _mint(address(saleCPool), saleCPoolAmount);\n', '        _mint(address(ecoPool), ecoPoolAmount);\n', '        _mint(address(reservedPool), reservedPoolAmount);\n', '        _mint(address(marketingPool), marketingPoolAmount);\n', '        _deployedOuter = false;\n', '        _deployedInner = false;\n', '    }\n', '}']