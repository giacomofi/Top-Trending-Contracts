['pragma solidity ^0.5.7;\n', '/**\n', '    INSTRUCTION:\n', '    Send more then or equal to [minPayment] or 0.01 ETH to one of Wallet Contract address\n', '    [wallet_0, wallet_1, wallet_2], after round end send to This contract 0 ETH\n', '    transaction and if you choise won, take your winnings.\n', '\n', '    DAPP:     https://smartlottery.clab\n', '    BOT:      http://t.me/SmartLotteryGame_bot\n', '    LICENSE:  Under proprietary rights. All rights reserved.\n', '              Except <lib.SafeMath, cont.Ownable, lib.Address> under The MIT License (MIT)\n', '    AUTHOR:   http://t.me/pironmind\n', '\n', '*/\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) external pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) external pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) external pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) external pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * Interface of Secure contract\n', ' */\n', 'interface ISecure {\n', '    function getRandomNumber(uint8 _limit, uint8 _totalPlayers, uint _games, uint _countTxs)\n', '    external\n', '    view\n', '    returns(uint);\n', '\n', '    function checkTrasted() external payable returns(bool);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Wallet\n', ' * @dev The Wallet contract is the payable contract with a term of life in a single round.\n', ' */\n', 'contract Wallet {\n', '    using Address for address;\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint8;\n', '\n', '    SmartLotteryGame public slg;\n', '\n', '    uint256 private _totalRised;\n', '    uint8 private _players;\n', '    bool closedOut = false;\n', '    uint public gameId;\n', '    uint256 public minPaymnent;\n', '\n', '    struct bet {\n', '        address wallet;\n', '        uint256 balance;\n', '    }\n', '\n', '    mapping(uint8 => bet) public bets;\n', '\n', '    modifier canAcceptPayment {\n', '        require(msg.value >= minPaymnent);\n', '        _;\n', '    }\n', '\n', '    modifier canDoTrx() {\n', '        require(Address.isContract(msg.sender) != true);\n', '        _;\n', '    }\n', '\n', '    modifier isClosedOut {\n', '        require(!closedOut);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCreator() {\n', '        require(msg.sender == address(slg));\n', '        _;\n', '    }\n', '\n', '    constructor(uint _gameId, uint256 _minPayment) public {\n', '        slg = SmartLotteryGame(msg.sender);\n', '        gameId = _gameId;\n', '        minPaymnent = _minPayment;\n', '    }\n', '\n', '    function totalPlayers() public view returns(uint8) {\n', '        return _players;\n', '    }\n', '\n', '    function totalBets() public view returns(uint256) {\n', '        return _totalRised;\n', '    }\n', '\n', '    function finishDay() external onlyCreator returns(uint256) {\n', '        uint256 balance = address(this).balance;\n', '        if (balance >= minPaymnent) {\n', '            slg.getFunds.value(balance)();\n', '            return balance;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function closeContract() external onlyCreator returns(bool) {\n', '        return closedOut = true;\n', '    }\n', '\n', '    function addPlayer(uint8 _id, address _player, uint256 _amount)\n', '    internal\n', '    returns(bool) {\n', '        bets[_id].wallet = _player;\n', '        bets[_id].balance = _amount;\n', '        return true;\n', '    }\n', '\n', '    function()\n', '    payable\n', '    canAcceptPayment\n', '    canDoTrx\n', '    isClosedOut\n', '    external {\n', '        _totalRised = _totalRised.add(msg.value);\n', '        _players = uint8((_players).add(1));\n', '        addPlayer(_players, msg.sender, msg.value);\n', '        slg.participate();\n', '    }\n', '}\n', '\n', 'contract SmartLotteryGame is Ownable {\n', '    using SafeMath for *;\n', '\n', '    event Withdrawn(address indexed requestor, uint256 weiAmount);\n', '    event Deposited(address indexed payee, uint256 weiAmount);\n', '    event WinnerWallet(address indexed wallet, uint256 bank);\n', '\n', '    address public secure;\n', '\n', '    uint public games = 1;\n', '    uint256 public minPayment = 10**16;\n', '\n', '    Wallet public wallet_0 = new Wallet(games, minPayment);\n', '    Wallet public wallet_1 = new Wallet(games, minPayment);\n', '    Wallet public wallet_2 = new Wallet(games, minPayment);\n', '\n', '    uint256 public finishTime;\n', '    uint256 constant roundDuration = 86400;\n', '\n', '    uint internal _nonceId = 0;\n', '    uint internal _maxPlayers = 100;\n', '    uint internal _tp = 0;\n', '    uint internal _winner;\n', '    uint8[] internal _particWallets = new uint8[](0);\n', '    uint256 internal _fund;\n', '    uint256 internal _commission;\n', '    uint256 internal _totalBetsWithoutCommission;\n', '\n', '    mapping(uint => Wallet) public wallets;\n', '    mapping(address => uint256) private _deposits;\n', '\n', '    struct wins{\n', '        address winner;\n', '        uint256 time;\n', '        address w0;\n', '        address w1;\n', '        address w2;\n', '    }\n', '\n', '    struct bet {\n', '        address wallet;\n', '        uint256 balance;\n', '    }\n', '\n', '    mapping(uint => wins) public gamesLog;\n', '\n', '    modifier isReady() {\n', '        require(secure != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyWallets() {\n', '        require(\n', '            msg.sender == address(wallet_0) ||\n', '            msg.sender == address(wallet_1) ||\n', '            msg.sender == address(wallet_2)\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        wallets[0] = wallet_0;\n', '        wallets[1] = wallet_1;\n', '        wallets[2] = wallet_2;\n', '        finishTime = now.add(roundDuration);\n', '    }\n', '\n', '    function _deposit(address payee, uint256 amount) internal {\n', '        _deposits[payee] = _deposits[payee].add(amount);\n', '        emit Deposited(payee, amount);\n', '    }\n', '\n', '    function _raiseFunds() internal returns (uint256) {\n', '        _fund = _fund.add(wallet_0.finishDay());\n', '        _fund = _fund.add(wallet_1.finishDay());\n', '        return _fund.add(wallet_2.finishDay());\n', '    }\n', '\n', '    function _winnerSelection() internal {\n', '        uint8 winner;\n', '        for(uint8 i=0; i<3; i++) {\n', '            if(wallets[i].totalPlayers() > 0) {\n', '                _particWallets.push(i);\n', '            }\n', '        }\n', '        // random choose one of three wallets\n', '        winner = uint8(ISecure(secure)\n', '            .getRandomNumber(\n', '                uint8(_particWallets.length),\n', '                uint8(_tp),\n', '                uint(games),\n', '                _nonceId\n', '            ));\n', '\n', '        _winner = _particWallets[winner];\n', '    }\n', '\n', '    function _distribute() internal {\n', '        bet memory p;\n', '\n', '        _tp = wallets[_winner].totalPlayers();\n', '        uint256 accommulDeposit = 0;\n', '        uint256 percents = 0;\n', '        uint256 onDeposit = 0;\n', '\n', '        _commission = _fund.mul(15).div(100);\n', '        _totalBetsWithoutCommission = _fund.sub(_commission);\n', '\n', '        for (uint8 i = 1; i <= _tp; i++) {\n', '            (p.wallet, p.balance) = wallets[_winner].bets(i);\n', '            percents = (p.balance)\n', '            .mul(10000)\n', '            .div(wallets[_winner].totalBets());\n', '            onDeposit = _totalBetsWithoutCommission\n', '            .mul(percents)\n', '            .div(10000);\n', '            accommulDeposit = accommulDeposit.add(onDeposit);\n', '            _deposit(p.wallet, onDeposit);\n', '        }\n', '        _deposit(owner(), _fund.sub(accommulDeposit));\n', '    }\n', '\n', '    function _cleanState() internal {\n', '        _fund = 0;\n', '        _particWallets = new uint8[](0);\n', '    }\n', '\n', '    function _log(address winner, uint256 fund) internal {\n', '        gamesLog[games].winner = winner;\n', '        gamesLog[games].time = now;\n', '        gamesLog[games].w0 = address(wallet_0);\n', '        gamesLog[games].w1 = address(wallet_1);\n', '        gamesLog[games].w2 = address(wallet_2);\n', '        emit WinnerWallet(winner, fund);\n', '    }\n', '\n', '    function _paymentValidator(address _payee, uint256 _amount) internal {\n', '        if(_payee != address(wallet_0) &&\n', '        _payee != address(wallet_1) &&\n', '        _payee != address(wallet_2))\n', '        {\n', '            if(_amount == uint(0)) {\n', '                if(depositOf(_payee) != uint(0)) {\n', '                    withdraw();\n', '                } else {\n', '                    revert("You have zero balance");\n', '                }\n', '            } else {\n', '                revert("You can\'t do nonzero transaction");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _closeWallets() internal returns (bool) {\n', '        wallets[0].closeContract();\n', '        wallets[1].closeContract();\n', '        return wallets[2].closeContract();\n', '    }\n', '\n', '    function _issueWallets() internal returns (bool) {\n', '        wallets[0] = wallet_0 = new Wallet(games, minPayment);\n', '        wallets[1] = wallet_1 = new Wallet(games, minPayment);\n', '        wallets[2] = wallet_2 = new Wallet(games, minPayment);\n', '        return true;\n', '    }\n', '\n', '    function _switchWallets() internal {\n', '        if(_closeWallets()) {\n', '            _issueWallets();\n', '        } else { revert("break on switch");}\n', '    }\n', '\n', '    function _totalPlayers() internal view returns(uint) {\n', '        return wallets[0].totalPlayers()\n', '        .add(wallets[1].totalPlayers())\n', '        .add(wallets[2].totalPlayers());\n', '    }\n', '\n', '    function depositOf(address payee) public view returns (uint256) {\n', '        return _deposits[payee];\n', '    }\n', '\n', '    function lastWinner() public view returns(address) {\n', '        return gamesLog[games].winner;\n', '    }\n', '\n', '    function participate()\n', '    external\n', '    onlyWallets\n', '    isReady\n', '    {\n', '        _nonceId = _nonceId.add(1);\n', '        _tp = _totalPlayers();\n', '\n', '        if (now >= finishTime && 1 == _tp) {\n', '            finishTime = now.add(roundDuration);\n', '            return;\n', '        }\n', '\n', '        if (now >= finishTime || _tp >= _maxPlayers) {\n', '            // send all funds to this wallet\n', '            _fund = _raiseFunds();\n', '            // if it has participators\n', '            if(_fund > 0) {\n', '                // get winner\n', '                _winnerSelection();\n', '                // do distribute\n', '                _distribute();\n', '                // log data\n', '                _log(address(wallets[_winner]), _fund);\n', '                // clear state\n', '                _cleanState();\n', '                // update round\n', '                finishTime = now.add(roundDuration);\n', '                // set next game\n', '                games = games.add(1);\n', '                // issue new wallets\n', '                return _switchWallets();\n', '            }\n', '        }\n', '    }\n', '\n', '    function setMinPayment(uint256 _value) public onlyOwner {\n', '        minPayment = _value;\n', '    }\n', '\n', '    function setSecure(address _address) public onlyOwner returns (bool) {\n', '        secure = _address;\n', '        return true;\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint256 payment = _deposits[msg.sender];\n', '        _deposits[msg.sender] = 0;\n', '        msg.sender.transfer(payment);\n', '        emit Withdrawn(msg.sender, payment);\n', '    }\n', '\n', '    function getFunds() public payable onlyWallets {}\n', '\n', '    function() external payable {\n', '        _paymentValidator(msg.sender, msg.value);\n', '    }\n', '}']