['pragma solidity ^0.4.21;\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract LockRequestable {\n', '\n', '    uint256 public lockRequestCount;\n', '\n', '    function LockRequestable() public {\n', '        lockRequestCount = 0;\n', '    }\n', '\n', '    function generateLockId() internal returns (bytes32 lockId) {\n', '        return keccak256(block.blockhash(block.number - 1), address(this), ++lockRequestCount);\n', '    }\n', '}\n', '\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract CustodianUpgradeable is LockRequestable {\n', '\n', '    struct CustodianChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '    address public custodian;\n', '\n', '    mapping (bytes32 => CustodianChangeRequest) public custodianChangeReqs;\n', '\n', '    function CustodianUpgradeable(\n', '        address _custodian\n', '    )\n', '      LockRequestable()\n', '      public\n', '    {\n', '        custodian = _custodian;\n', '    }\n', '\n', '    modifier onlyCustodian {\n', '        require(msg.sender == custodian);\n', '        _;\n', '    }\n', '\n', '    function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n', '        require(_proposedCustodian != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        custodianChangeReqs[lockId] = CustodianChangeRequest({\n', '            proposedNew: _proposedCustodian\n', '        });\n', '\n', '        emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n', '    }\n', '\n', '    function confirmCustodianChange(bytes32 _lockId) public onlyCustodian {\n', '        custodian = getCustodianChangeReq(_lockId);\n', '\n', '        delete custodianChangeReqs[_lockId];\n', '\n', '        emit CustodianChangeConfirmed(_lockId, custodian);\n', '    }\n', '\n', '    function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\n', '        CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\n', '\n', '        require(changeRequest.proposedNew != 0);\n', '\n', '        return changeRequest.proposedNew;\n', '    }\n', '\n', '    event CustodianChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedCustodian\n', '    );\n', '\n', '    event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\n', '}\n', '\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract ERC20ImplUpgradeable is CustodianUpgradeable  {\n', '\n', '    struct ImplChangeRequest {\n', '        address proposedNew;\n', '    }\n', '\n', '    ERC20Impl public erc20Impl;\n', '\n', '    mapping (bytes32 => ImplChangeRequest) public implChangeReqs;\n', '\n', '    function ERC20ImplUpgradeable(address _custodian) CustodianUpgradeable(_custodian) public {\n', '        erc20Impl = ERC20Impl(0x0);\n', '    }\n', '\n', '    modifier onlyImpl {\n', '        require(msg.sender == address(erc20Impl));\n', '        _;\n', '    }\n', '\n', '    function requestImplChange(address _proposedImpl) public returns (bytes32 lockId) {\n', '        require(_proposedImpl != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        implChangeReqs[lockId] = ImplChangeRequest({\n', '            proposedNew: _proposedImpl\n', '        });\n', '\n', '        emit ImplChangeRequested(lockId, msg.sender, _proposedImpl);\n', '    }\n', '\n', '    function confirmImplChange(bytes32 _lockId) public onlyCustodian {\n', '        erc20Impl = getImplChangeReq(_lockId);\n', '\n', '        delete implChangeReqs[_lockId];\n', '\n', '        emit ImplChangeConfirmed(_lockId, address(erc20Impl));\n', '    }\n', '\n', '    function getImplChangeReq(bytes32 _lockId) private view returns (ERC20Impl _proposedNew) {\n', '        ImplChangeRequest storage changeRequest = implChangeReqs[_lockId];\n', '\n', '        require(changeRequest.proposedNew != address(0));\n', '\n', '        return ERC20Impl(changeRequest.proposedNew);\n', '    }\n', '\n', '    event ImplChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _proposedImpl\n', '    );\n', '\n', '    event ImplChangeConfirmed(bytes32 _lockId, address _newImpl);\n', '}\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract ERC20Interface {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract ERC20Proxy is ERC20Interface, ERC20ImplUpgradeable {\n', '\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint8 public decimals;\n', '\n', '    function ERC20Proxy(\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        address _custodian\n', '    )\n', '        ERC20ImplUpgradeable(_custodian)\n', '        public\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Impl.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Impl.balanceOf(_owner);\n', '    }\n', '\n', '    function emitTransfer(address _from, address _to, uint256 _value) public onlyImpl {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferWithSender(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);\n', '    }\n', '\n', '    function emitApproval(address _owner, address _spender, uint256 _value) public onlyImpl {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        return erc20Impl.approveWithSender(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n', '        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n', '        return erc20Impl.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Impl.allowance(_owner, _spender);\n', '    }\n', '}\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract ERC20Impl is CustodianUpgradeable {\n', '\n', '    struct PendingPrint {\n', '        address receiver;\n', '        uint256 value;\n', '    }\n', '\n', '    ERC20Proxy public erc20Proxy;\n', '\n', '    ERC20Store public erc20Store;\n', '\n', '    address public sweeper;\n', '\n', '    bytes32 public sweepMsg;\n', '\n', '    mapping (address => bool) public sweptSet;\n', '\n', '    mapping (bytes32 => PendingPrint) public pendingPrintMap;\n', '\n', '    function ERC20Impl(\n', '          address _erc20Proxy,\n', '          address _erc20Store,\n', '          address _custodian,\n', '          address _sweeper\n', '    )\n', '        CustodianUpgradeable(_custodian)\n', '        public\n', '    {\n', '        require(_sweeper != 0);\n', '        erc20Proxy = ERC20Proxy(_erc20Proxy);\n', '        erc20Store = ERC20Store(_erc20Store);\n', '\n', '        sweeper = _sweeper;\n', '        sweepMsg = keccak256(address(this), "sweep");\n', '    }\n', '\n', '    modifier onlyProxy {\n', '        require(msg.sender == address(erc20Proxy));\n', '        _;\n', '    }\n', '    modifier onlySweeper {\n', '        require(msg.sender == sweeper);\n', '        _;\n', '    }\n', '\n', '\n', '    function approveWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        erc20Store.setAllowance(_sender, _spender, _value);\n', '        erc20Proxy.emitApproval(_sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance + _addedValue;\n', '\n', '        require(newAllowance >= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApprovalWithSender(\n', '        address _sender,\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_spender != address(0));\n', '        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n', '        uint256 newAllowance = currentAllowance - _subtractedValue;\n', '\n', '        require(newAllowance <= currentAllowance);\n', '\n', '        erc20Store.setAllowance(_sender, _spender, newAllowance);\n', '        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    function requestPrint(address _receiver, uint256 _value) public returns (bytes32 lockId) {\n', '        require(_receiver != address(0));\n', '\n', '        lockId = generateLockId();\n', '\n', '        pendingPrintMap[lockId] = PendingPrint({\n', '            receiver: _receiver,\n', '            value: _value\n', '        });\n', '\n', '        emit PrintingLocked(lockId, _receiver, _value);\n', '    }\n', '\n', '    function confirmPrint(bytes32 _lockId) public onlyCustodian {\n', '        PendingPrint storage print = pendingPrintMap[_lockId];\n', '\n', '        address receiver = print.receiver;\n', '        require (receiver != address(0));\n', '        uint256 value = print.value;\n', '\n', '        delete pendingPrintMap[_lockId];\n', '\n', '        uint256 supply = erc20Store.totalSupply();\n', '        uint256 newSupply = supply + value;\n', '        if (newSupply >= supply) {\n', '          erc20Store.setTotalSupply(newSupply);\n', '          erc20Store.addBalance(receiver, value);\n', '\n', '          emit PrintingConfirmed(_lockId, receiver, value);\n', '          erc20Proxy.emitTransfer(address(0), receiver, value);\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        uint256 balanceOfSender = erc20Store.balances(msg.sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        erc20Store.setBalance(msg.sender, balanceOfSender - _value);\n', '        erc20Store.setTotalSupply(erc20Store.totalSupply() - _value);\n', '\n', '        erc20Proxy.emitTransfer(msg.sender, address(0), _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function batchTransfer(address[] _tos, uint256[] _values) public returns (bool success) {\n', '        require(_tos.length == _values.length);\n', '\n', '        uint256 numTransfers = _tos.length;\n', '        uint256 senderBalance = erc20Store.balances(msg.sender);\n', '\n', '        for (uint256 i = 0; i < numTransfers; i++) {\n', '          address to = _tos[i];\n', '          require(to != address(0));\n', '          uint256 v = _values[i];\n', '          require(senderBalance >= v);\n', '\n', '          if (msg.sender != to) {\n', '            senderBalance -= v;\n', '            erc20Store.addBalance(to, v);\n', '          }\n', '          erc20Proxy.emitTransfer(msg.sender, to, v);\n', '        }\n', '\n', '        erc20Store.setBalance(msg.sender, senderBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    function enableSweep(uint8[] _vs, bytes32[] _rs, bytes32[] _ss, address _to) public onlySweeper {\n', '        require(_to != address(0));\n', '        require((_vs.length == _rs.length) && (_vs.length == _ss.length));\n', '\n', '        uint256 numSignatures = _vs.length;\n', '        uint256 sweptBalance = 0;\n', '\n', '        for (uint256 i=0; i<numSignatures; ++i) {\n', '          address from = ecrecover(sweepMsg, _vs[i], _rs[i], _ss[i]);\n', '\n', '          if (from != address(0)) {\n', '            sweptSet[from] = true;\n', '\n', '            uint256 fromBalance = erc20Store.balances(from);\n', '\n', '            if (fromBalance > 0) {\n', '              sweptBalance += fromBalance;\n', '\n', '              erc20Store.setBalance(from, 0);\n', '\n', '              erc20Proxy.emitTransfer(from, _to, fromBalance);\n', '            }\n', '          }\n', '        }\n', '\n', '        if (sweptBalance > 0) {\n', '          erc20Store.addBalance(_to, sweptBalance);\n', '        }\n', '    }\n', '\n', '    function replaySweep(address[] _froms, address _to) public onlySweeper {\n', '        require(_to != address(0));\n', '        uint256 lenFroms = _froms.length;\n', '        uint256 sweptBalance = 0;\n', '\n', '        for (uint256 i=0; i<lenFroms; ++i) {\n', '            address from = _froms[i];\n', '\n', '            if (sweptSet[from]) {\n', '                uint256 fromBalance = erc20Store.balances(from);\n', '\n', '                if (fromBalance > 0) {\n', '                    sweptBalance += fromBalance;\n', '\n', '                    erc20Store.setBalance(from, 0);\n', '\n', '                    erc20Proxy.emitTransfer(from, _to, fromBalance);\n', '                }\n', '            }\n', '        }\n', '\n', '        if (sweptBalance > 0) {\n', '            erc20Store.addBalance(_to, sweptBalance);\n', '        }\n', '    }\n', '\n', '    function transferFromWithSender(\n', '        address _sender,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '\n', '        uint256 balanceOfFrom = erc20Store.balances(_from);\n', '        require(_value <= balanceOfFrom);\n', '\n', '        uint256 senderAllowance = erc20Store.allowed(_from, _sender);\n', '        require(_value <= senderAllowance);\n', '\n', '        erc20Store.setBalance(_from, balanceOfFrom - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Store.setAllowance(_from, _sender, senderAllowance - _value);\n', '\n', '        erc20Proxy.emitTransfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferWithSender(\n', '        address _sender,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyProxy\n', '        returns (bool success)\n', '    {\n', '        require(_to != address(0));\n', '\n', '        uint256 balanceOfSender = erc20Store.balances(_sender);\n', '        require(_value <= balanceOfSender);\n', '\n', '        erc20Store.setBalance(_sender, balanceOfSender - _value);\n', '        erc20Store.addBalance(_to, _value);\n', '\n', '        erc20Proxy.emitTransfer(_sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return erc20Store.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return erc20Store.balances(_owner);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return erc20Store.allowed(_owner, _spender);\n', '    }\n', '\n', '    event PrintingLocked(bytes32 _lockId, address _receiver, uint256 _value);\n', '    event PrintingConfirmed(bytes32 _lockId, address _receiver, uint256 _value);\n', '}\n', '\n', '\n', '/** @title  KRWT contract\n', '  *\n', '  * @author  Hansung Future Co.,Ltd\n', '  */\n', 'contract ERC20Store is ERC20ImplUpgradeable {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    mapping (address => uint256) public balances;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    function ERC20Store(address _custodian) ERC20ImplUpgradeable(_custodian) public {\n', '        totalSupply = 0;\n', '    }\n', '\n', '    function setTotalSupply(\n', '        uint256 _newTotalSupply\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        totalSupply = _newTotalSupply;\n', '    }\n', '\n', '    function setAllowance(\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        allowed[_owner][_spender] = _value;\n', '    }\n', '\n', '    function setBalance(\n', '        address _owner,\n', '        uint256 _newBalance\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        balances[_owner] = _newBalance;\n', '    }\n', '\n', '    function addBalance(\n', '        address _owner,\n', '        uint256 _balanceIncrease\n', '    )\n', '        public\n', '        onlyImpl\n', '    {\n', '        balances[_owner] = balances[_owner] + _balanceIncrease;\n', '    }\n', '}']