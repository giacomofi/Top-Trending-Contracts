['pragma solidity ^0.5.8;\n', '\n', '/**\n', " * @title Opyns's FactoryStorage Contract\n", ' * @notice Stores contract, user, exchange, and token data. Deploys FactoryLogic.\n', ' * @author Opyn, Aparna Krishnan and Zubin Koticha\n', ' */\n', 'contract FactoryStorage {\n', '\n', '    //TODO: add more events\n', '\n', '    event NewPositionContract(\n', '        address userAddress,\n', '        address newPositionContractAddress,\n', '        address factoryLogicAddress\n', '    );\n', '\n', '    event NewTokenAddedToPositionContract(\n', '        string ticker,\n', '        address tokenAddr,\n', '        address cTokenAddr,\n', '        address exchangeAddr\n', '    );\n', '\n', '    event UserAdded(\n', '        address userAddr\n', '    );\n', '\n', '    event TickerAdded(\n', '        string ticker\n', '    );\n', '\n', '    event FactoryLogicChanged(\n', '        address factoryLogicAddr\n', '    );\n', '\n', '    //maybe the name positionContractAddresses is better?!\n', '    //ticker => userAddr => positionContractAddr\n', "    //e.g. ticker = 'REP'\n", '    mapping (string => mapping (address => address)) public positionContracts;\n', '\n', '    /**\n', '    * @notice the following give the ERC20 token address, ctoken, and Uniswap Exchange for a given token ticker symbol.\n', "    * e.g tokenAddresses('REP') => 0x1a...\n", "    * e.g ctokenAddresses('REP') => 0x51...\n", "    * e.g exchangeAddresses('REP') => 0x9a...\n", '    */\n', '    mapping (string => address) public tokenAddresses;\n', '    mapping (string => address) public ctokenAddresses;\n', '    mapping (string => address) public exchangeAddresses;\n', '\n', '    //TODO: think about - using CarefulMath for uint;\n', '\n', '    address public factoryLogicAddress;\n', '\n', '    /**\n', '    * @notice The array of owners with write privileges.\n', '    */\n', '    address[3] public ownerAddresses;\n', '\n', '    /**\n', '    * @notice The array of all users with contracts.\n', '    */\n', '    address[] public userAddresses;\n', '    string[] public tickers;\n', '\n', '    /**\n', '    * @notice These mappings act as sets to see if a key is in string[] public tokens or address[] public userAddresses\n', '    */\n', '    mapping (address => bool) public userAddressesSet;\n', '    mapping (string => bool) public tickerSet;\n', '\n', '    /**\n', '    * @notice Constructs a new FactoryStorage\n', '    * @param owner1 The second owner (after msg.sender)\n', '    * @param owner2 The third owner (after msg.sender)\n', '    */\n', '    constructor(address owner1, address owner2) public {\n', '        //TODO: deal with keys and ownership\n', '        ownerAddresses[0] = msg.sender;\n', '        ownerAddresses[1] = owner1;\n', '        ownerAddresses[2] = owner2;\n', '\n', "        tickers = ['DAI','ZRX','BAT','ETH'];\n", "        tickerSet['DAI'] = true;\n", "        tickerSet['ZRX'] = true;\n", "        tickerSet['BAT'] = true;\n", "        tickerSet['ETH'] = true;\n", '\n', '        //TODO: ensure all the following are accurate for mainnet.\n', "        tokenAddresses['DAI'] = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n", "        tokenAddresses['BAT'] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n", "        tokenAddresses['ZRX'] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n", "        tokenAddresses['REP'] = 0x1985365e9f78359a9B6AD760e32412f4a445E862;\n", '\n', "        ctokenAddresses['DAI'] = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\n", "        ctokenAddresses['BAT'] = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E;\n", "        ctokenAddresses['ZRX'] = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407;\n", "        ctokenAddresses['REP'] = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1;\n", "        ctokenAddresses['ETH'] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n", '\n', "        exchangeAddresses['DAI'] = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\n", "        exchangeAddresses['BAT'] = 0x2E642b8D59B45a1D8c5aEf716A84FF44ea665914;\n", "        exchangeAddresses['ZRX'] = 0xaE76c84C9262Cdb9abc0C2c8888e62Db8E22A0bF;\n", "        exchangeAddresses['REP'] = 0x48B04d2A05B6B604d8d5223Fd1984f191DED51af;\n", '    }\n', '\n', '    /**\n', '    * @notice Sets a FactoryLogic contract that this contract interacts with, this clause is responsibility for upgradeability.\n', '    * @param newAddress the address of the new FactoryLogic contract\n', '    */\n', '    function setFactoryLogicAddress(address newAddress) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        //TODO: better security practices required than the above\n', '        factoryLogicAddress = newAddress;\n', '        emit FactoryLogicChanged(newAddress);\n', '    }\n', '\n', '    /**\n', '    * @notice Adds a new user to the userAddresses array.\n', '    * @param newAddress the address of the new user\n', '    */\n', '    function addUser(address newAddress) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        //TODO: ensure that this is how it works.\n', '        if (!userAddressesSet[newAddress]) {\n', '            userAddresses.push(newAddress);\n', '            userAddressesSet[newAddress] = true;\n', '            emit UserAdded(newAddress);\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @notice Adds a new token to the tokens array.\n', '   * @param ticker ticker symbol of the new token\n', '   */\n', '    function addTicker(string memory ticker) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        //TODO: ensure that this is how it works.\n', '        if (!tickerSet[ticker]) {\n', '            tickers.push(ticker);\n', '            tickerSet[ticker] = true;\n', '            emit TickerAdded(ticker);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the newAddress of a ticker in the tokenAddresses array.\n', '    * @param ticker string ticker symbol of the new token being added\n', '    * @param newAddress the new address of the token\n', '    */\n', '    function updateTokenAddress(string memory ticker, address newAddress) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        tokenAddresses[ticker] = newAddress;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the newAddress of a ticker in the ctokenAddresses array.\n', '    * @param newAddress the address of the ctoken\n', '    */\n', '    function updatecTokenAddress(string memory ticker, address newAddress) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        ctokenAddresses[ticker] = newAddress;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the newAddress of a position contract, this clause is responsibility for upgradeability.\n', '    * @param newAddress the address of the new FactoryLogic contract\n', '    */\n', '    function updateExchangeAddress(string memory ticker, address newAddress) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        exchangeAddresses[ticker] = newAddress;\n', '    }\n', '\n', '    //  TODO: proper solidity style for following function\n', '    /**\n', '    * @notice Sets the newAddress of a position contract, this clause is responsibility for upgradeability.\n', '    * @param ticker the ticker symbol for this new token\n', '    * @param tokenAddr the address of the token\n', '    * @param cTokenAddr the address of the cToken\n', '    * @param exchangeAddr the address of the particular DEX pair\n', '    */\n', '    function addNewTokenToPositionContracts(string memory ticker, address tokenAddr, address cTokenAddr, address exchangeAddr) public {\n', '        require(factoryLogicAddress == msg.sender|| ownerAddresses[0] == msg.sender || ownerAddresses[1] == msg.sender || ownerAddresses[2] == msg.sender);\n', '        //TODO: do we want to first ensure ticker not already there?!\n', '        tokenAddresses[ticker] = tokenAddr;\n', '        ctokenAddresses[ticker] = cTokenAddr;\n', '        exchangeAddresses[ticker] = exchangeAddr;\n', '        emit NewTokenAddedToPositionContract(ticker, tokenAddr, cTokenAddr, exchangeAddr);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the newAddress of a position contract, this clause is responsibility for upgradeability.\n', '    * @param ticker the ticker symbol that this PositionContract corresponds to\n', '    * @param userAddress the address of the user creating this PositionContract\n', '    * @param newContractAddress the address of the new position contract\n', '    */\n', '    function addNewPositionContract(string memory ticker, address userAddress, address newContractAddress) public {\n', '        //TODO: ensure userAddress has been added and ticker is valid.\n', '        require(factoryLogicAddress == msg.sender);\n', '        positionContracts[ticker][userAddress] = newContractAddress;\n', '        addUser(userAddress);\n', "        //TODO: shouldn't the following event include the ticker?\n", '        emit NewPositionContract(userAddress, newContractAddress, msg.sender);\n', '    }\n', '    \n', '    function updateRootAddr(address newAddress) public{\n', '        if(ownerAddresses[0] == msg.sender){\n', '            ownerAddresses[0] = newAddress;\n', '        } else if (ownerAddresses[1] == msg.sender) {\n', '            ownerAddresses[1] = newAddress;\n', '        } else if (ownerAddresses[2] == msg.sender) {\n', '            ownerAddresses[2] = newAddress;\n', '        }\n', '    }\n', '}']