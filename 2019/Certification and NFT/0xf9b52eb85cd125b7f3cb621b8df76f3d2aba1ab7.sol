['pragma solidity ^0.4.4;\n', '\n', 'contract BlockSpeech {\n', '\n', '    event Keynote(address indexed _from, uint _speech_id, string _speech_title);\n', '    event Like(address indexed _from, address _addr, uint _speech_id);\n', '    event Reward(address indexed _from, address _addr, uint _speech_id, uint _value);\n', '\n', '    struct Speech {\n', '        uint speech_id;\n', '        uint speech_type; // 1, for TA; 2, for the world\n', '        string speech_title;\n', '        string speech_content;\n', '        uint likes;\n', '        uint reward;\n', '        mapping(address=>uint) reward_detail;\n', '        mapping(address=>bool) is_like;\n', '    }\n', '\n', '    mapping (address => mapping (uint => Speech)) _speeches;\n', '    mapping (address => uint[]) _speech_list;\n', '    address[] _writers;\n', '    mapping(address=>uint) _writer_num;\n', '    uint[] _speech_num;\n', '    uint _speech_total_likes;\n', '    mapping(address=>uint) _total_likes;\n', '    mapping(address=>uint) _total_reward;\n', '\n', '    mapping(uint=>address[]) _like_addrs;\n', '    mapping(uint=>address[]) _reward_addrs;\n', '\n', '    uint public DEV_TAX_DIVISOR;\n', '    address public blockAppAddr;\n', '\n', '    function BlockSpeech(uint _tax_rate) public {\n', '        blockAppAddr = msg.sender;\n', '        DEV_TAX_DIVISOR = _tax_rate;\n', '    }\n', '\n', '    function keynote(uint _speech_id, uint _speech_type, string _speech_title, string _speech_content) public returns(bool) {\n', '\n', '        require(_speech_id > 0);\n', '        require(bytes(_speech_title).length > 0);\n', '        require(bytes(_speech_content).length > 0);\n', '\n', '        if(_writer_num[msg.sender] == 0) {\n', '            uint num = _writers.length++;\n', '            _writers[num] = msg.sender;\n', '            _writer_num[msg.sender] = num;\n', '        }\n', '\n', '        Speech memory speech = Speech(_speech_id, _speech_type, _speech_title, _speech_content, 0, 0);\n', '\n', '        _speeches[msg.sender][_speech_id] = speech;\n', '        _speech_list[msg.sender][_speech_list[msg.sender].length++] = _speech_id;\n', '\n', '        _speech_num[_speech_num.length++] = _speech_num.length++;\n', '\n', '        emit Keynote(msg.sender, _speech_id, _speech_title);\n', '        return true;\n', '    }\n', '\n', '    function like(address _addr, uint _speech_id) public returns(bool) {\n', '        require(_speech_id > 0);\n', '        require(_addr != address(0));\n', '\n', '        Speech storage speech = _speeches[_addr][_speech_id];\n', '        require(speech.speech_id > 0);\n', '        require(!speech.is_like[msg.sender]);\n', '\n', '        speech.is_like[msg.sender] = true;\n', '        speech.likes++;\n', '\n', '        _like_addrs[_speech_id][_like_addrs[_speech_id].length++] = msg.sender;\n', '        _total_likes[_addr] = SafeMath.add(_total_likes[_addr], 1);\n', '        _speech_total_likes = SafeMath.add(_speech_total_likes, 1);\n', '\n', '        emit Like(msg.sender, _addr, _speech_id);\n', '        return true;\n', '    }\n', '\n', '    function reward(address _addr, uint _speech_id) public payable returns(bool) {\n', '        require(_speech_id > 0);\n', '        require(_addr != address(0));\n', '        require(msg.value > 0);\n', '\n', '        Speech storage speech = _speeches[_addr][_speech_id];\n', '        require(speech.speech_id > 0);\n', '\n', '        speech.reward = SafeMath.add(speech.reward, msg.value);\n', '        _reward_addrs[_speech_id][_reward_addrs[_speech_id].length++] = msg.sender;\n', '        _total_reward[_addr] = SafeMath.add(_total_reward[_addr], msg.value);\n', '\n', '        uint devTax = SafeMath.div(msg.value, DEV_TAX_DIVISOR);\n', '        uint finalValue = SafeMath.sub(msg.value, devTax);\n', '\n', '        assert(finalValue>0 && devTax>0);\n', '\n', '        blockAppAddr.transfer(devTax);\n', '        _addr.transfer(finalValue);\n', '\n', '        emit Reward(msg.sender, _addr, _speech_id, msg.value);\n', '        return true;\n', '    }\n', '\n', '    function getMySpeechList() public constant returns (uint[] speech_list, uint[] speech_rewards, uint[] speech_likes, bool[] is_likes){\n', '\n', '        speech_rewards = new uint[](_speech_list[msg.sender].length);\n', '        speech_likes = new uint[](_speech_list[msg.sender].length);\n', '        is_likes = new bool[](_speech_list[msg.sender].length);\n', '\n', '        for(uint i=0; i<_speech_list[msg.sender].length; i++) {\n', '            Speech storage speech = _speeches[msg.sender][_speech_list[msg.sender][i]];\n', '            speech_rewards[i] = speech.reward;\n', '            speech_likes[i] = speech.likes;\n', '            is_likes[i] = speech.is_like[msg.sender];\n', '        }\n', '\n', '        return (_speech_list[msg.sender], speech_rewards, speech_likes, is_likes);\n', '    }\n', '\n', '    function getMySpeechList(address _addr) public constant returns (uint[] speech_list, uint[] speech_rewards, uint[] speech_likes, bool[] is_likes, uint[] speech_types){\n', '        require(_addr != address(0));\n', '\n', '        speech_types = new uint[](_speech_list[_addr].length);\n', '        speech_rewards = new uint[](_speech_list[_addr].length);\n', '        speech_likes = new uint[](_speech_list[_addr].length);\n', '        is_likes = new bool[](_speech_list[_addr].length);\n', '\n', '        for(uint i=0; i<_speech_list[_addr].length; i++) {\n', '            Speech storage speech = _speeches[_addr][_speech_list[_addr][i]];\n', '            speech_types[i] = speech.speech_type;\n', '            speech_rewards[i] = speech.reward;\n', '            speech_likes[i] = speech.likes;\n', '            is_likes[i] = speech.is_like[_addr];\n', '        }\n', '\n', '        return (_speech_list[_addr], speech_rewards, speech_likes, is_likes, speech_types);\n', '    }\n', '\n', '    function getMySpeech(uint _speech_id) public constant returns (uint speech_type, string speech_title, string speech_content, uint likes, uint rewards){\n', '        require(_speech_id > 0);\n', '\n', '        Speech storage speech = _speeches[msg.sender][_speech_id];\n', '        assert(speech.speech_id > 0);\n', '\n', '        return (speech.speech_type, speech.speech_title, speech.speech_content, speech.likes, speech.reward);\n', '    }\n', '\n', '    function getMySpeech(uint _speech_id, address _addr) public constant returns (uint speech_type, string speech_title, string speech_content, uint likes, uint rewards){\n', '        require(_speech_id > 0);\n', '\n', '        Speech storage speech = _speeches[_addr][_speech_id];\n', '        assert(speech.speech_id > 0);\n', '\n', '        return (speech.speech_type, speech.speech_title, speech.speech_content, speech.likes, speech.reward);\n', '    }\n', '\n', '    function getMe() public constant returns (uint num_writer, uint num_speech, uint total_likes, uint total_reward) {\n', '        return (_writer_num[msg.sender], _speech_list[msg.sender].length, _total_likes[msg.sender], _total_reward[msg.sender]);\n', '    }\n', '\n', '    function getWriter(address _addr) public constant returns (uint num_writer, uint num_speech, uint total_likes, uint total_reward) {\n', '        require(_addr != address(0));\n', '        return (_writer_num[_addr], _speech_list[_addr].length, _total_likes[_addr], _total_reward[_addr]);\n', '    }\n', '\n', '    function getWriter(address[] _addrs) public constant returns (uint[] num_writer, uint[] num_speech, uint[] total_likes, uint[] total_reward) {\n', '\n', '        for(uint i=0; i<_addrs.length; i++) {\n', '            num_writer[i] = _writer_num[_addrs[i]];\n', '            num_speech[i] = _speech_list[_addrs[i]].length;\n', '            total_likes[i] = _total_likes[_addrs[i]];\n', '            total_reward[i] = _total_reward[_addrs[i]];\n', '        }\n', '        return (num_writer, num_speech, total_likes, total_reward);\n', '    }\n', '\n', '    function getBlockSpeech() public constant returns (uint num_writers, uint num_speechs, uint speech_total_likes) {\n', '        return (_writers.length, _speech_num.length, _speech_total_likes);\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function isInArray(uint a, uint[] b) internal pure returns (bool) {\n', '\n', '        for(uint i = 0; i < b.length; i++) {\n', '            if(b[i] == a) return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '}']