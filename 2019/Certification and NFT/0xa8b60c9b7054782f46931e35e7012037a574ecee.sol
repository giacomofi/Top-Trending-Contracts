['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Transfer Manager module for core transfer validation functionality\n', ' */\n', 'contract GeneralTransferManagerStorage {\n', '\n', '    //Address from which issuances come\n', '    address public issuanceAddress = address(0);\n', '\n', '    //Address which can sign whitelist changes\n', '    address public signingAddress = address(0);\n', '\n', '    bytes32 public constant WHITELIST = "WHITELIST";\n', '    bytes32 public constant FLAGS = "FLAGS";\n', '\n', '    //from and to timestamps that an investor can send / receive tokens respectively\n', '    struct TimeRestriction {\n', '        //the moment when the sale lockup period ends and the investor can freely sell or transfer away their tokens\n', '        uint64 canSendAfter;\n', '        //the moment when the purchase lockup period ends and the investor can freely purchase or receive from others\n', '        uint64 canReceiveAfter;\n', '        uint64 expiryTime;\n', '        uint8 canBuyFromSTO;\n', '        uint8 added;\n', '    }\n', '\n', '    // Allows all TimeRestrictions to be offset\n', '    struct Defaults {\n', '        uint64 canSendAfter;\n', '        uint64 canReceiveAfter;\n', '    }\n', '\n', '    // Offset to be applied to all timings (except KYC expiry)\n', '    Defaults public defaults;\n', '\n', '    // List of all addresses that have been added to the GTM at some point\n', '    address[] public investors;\n', '\n', '    // An address can only send / receive tokens once their corresponding uint256 > block.number\n', '    // (unless allowAllTransfers == true or allowAllWhitelistTransfers == true)\n', '    mapping (address => TimeRestriction) public whitelist;\n', '    // Map of used nonces by customer\n', '    mapping(address => mapping(uint256 => bool)) public nonceMap;\n', '\n', '    //If true, there are no transfer restrictions, for any addresses\n', '    bool public allowAllTransfers = false;\n', '    //If true, time lock is ignored for transfers (address must still be on whitelist)\n', '    bool public allowAllWhitelistTransfers = false;\n', '    //If true, time lock is ignored for issuances (address must still be on whitelist)\n', '    bool public allowAllWhitelistIssuances = true;\n', '    //If true, time lock is ignored for burn transactions\n', '    bool public allowAllBurnTransfers = false;\n', '\n', '}\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function _implementation() internal view returns (address);\n', '\n', '    /**\n', '    * @dev Fallback function.\n', '    * Implemented entirely in `_fallback`.\n', '    */\n', '    function _fallback() internal {\n', '        _delegate(_implementation());\n', '    }\n', '\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function _delegate(address implementation) internal {\n', '        /*solium-disable-next-line security/no-inline-assembly*/\n', '        assembly {\n', '            // Copy msg.data. We take full control of memory in this inline assembly\n', '            // block because it will not return to Solidity code. We overwrite the\n', '            // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '            // Call the implementation.\n', "            // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 { revert(0, returndatasize) }\n', '            default { return(0, returndatasize) }\n', '        }\n', '    }\n', '\n', '    function () public payable {\n', '        _fallback();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title OwnedProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedProxy is Proxy {\n', '\n', '    // Owner of the contract\n', '    address private __owner;\n', '\n', '    // Address of the current implementation\n', '    address internal __implementation;\n', '\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param _previousOwner representing the address of the previous owner\n', '    * @param _newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier ifOwner() {\n', '        if (msg.sender == _owner()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor() public {\n', '        _setOwner(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function _owner() internal view returns (address) {\n', '        return __owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the owner\n', '    */\n', '    function _setOwner(address _newOwner) internal {\n', '        require(_newOwner != address(0), "Address should not be 0x");\n', '        __owner = _newOwner;\n', '    }\n', '\n', '    /**\n', '    * @notice Internal function to provide the address of the implementation contract\n', '    */\n', '    function _implementation() internal view returns (address) {\n', '        return __implementation;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the proxy owner\n', '    * @return the address of the proxy owner\n', '    */\n', '    function proxyOwner() external ifOwner returns (address) {\n', '        return _owner();\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() external ifOwner returns (address) {\n', '        return _implementation();\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) external ifOwner {\n', '        require(_newOwner != address(0), "Address should not be 0x");\n', '        emit ProxyOwnershipTransferred(_owner(), _newOwner);\n', '        _setOwner(_newOwner);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused, "Contract is not paused");\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice Called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal whenNotPaused {\n', '        paused = true;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice Called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal whenPaused {\n', '        paused = false;\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Storage for Module contract\n', ' * @notice Contract is abstract\n', ' */\n', 'contract ModuleStorage {\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _securityToken Address of the security token\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _securityToken, address _polyAddress) public {\n', '        securityToken = _securityToken;\n', '        factory = msg.sender;\n', '        polyToken = IERC20(_polyAddress);\n', '    }\n', '    \n', '    address public factory;\n', '\n', '    address public securityToken;\n', '\n', '    bytes32 public constant FEE_ADMIN = "FEE_ADMIN";\n', '\n', '    IERC20 public polyToken;\n', '\n', '}\n', '\n', '/**\n', ' * @title Transfer Manager module for core transfer validation functionality\n', ' */\n', 'contract GeneralTransferManagerProxy is GeneralTransferManagerStorage, ModuleStorage, Pausable, OwnedProxy {\n', '\n', '    /**\n', '    * @notice Constructor\n', '    * @param _securityToken Address of the security token\n', '    * @param _polyAddress Address of the polytoken\n', '    * @param _implementation representing the address of the new implementation to be set\n', '    */\n', '    constructor (address _securityToken, address _polyAddress, address _implementation)\n', '    public\n', '    ModuleStorage(_securityToken, _polyAddress)\n', '    {\n', '        require(\n', '            _implementation != address(0),\n', '            "Implementation address should not be 0x"\n', '        );\n', '        __implementation = _implementation;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface that every module factory contract should implement\n', ' */\n', 'interface IModuleFactory {\n', '\n', '    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\n', '    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n', '    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n', '    event GenerateModuleFromFactory(\n', '        address _module,\n', '        bytes32 indexed _moduleName,\n', '        address indexed _moduleFactory,\n', '        address _creator,\n', '        uint256 _setupCost,\n', '        uint256 _timestamp\n', '    );\n', '    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n', '\n', '    //Should create an instance of the Module, or throw\n', '    function deploy(bytes _data) external returns(address);\n', '\n', '    /**\n', '     * @notice Type of the Module factory\n', '     */\n', '    function getTypes() external view returns(uint8[]);\n', '\n', '    /**\n', '     * @notice Get the name of the Module\n', '     */\n', '    function getName() external view returns(bytes32);\n', '\n', '    /**\n', '     * @notice Returns the instructions associated with the module\n', '     */\n', '    function getInstructions() external view returns (string);\n', '\n', '    /**\n', '     * @notice Get the tags related to the module factory\n', '     */\n', '    function getTags() external view returns (bytes32[]);\n', '\n', '    /**\n', '     * @notice Used to change the setup fee\n', '     * @param _newSetupCost New setup fee\n', '     */\n', '    function changeFactorySetupFee(uint256 _newSetupCost) external;\n', '\n', '    /**\n', '     * @notice Used to change the usage fee\n', '     * @param _newUsageCost New usage fee\n', '     */\n', '    function changeFactoryUsageFee(uint256 _newUsageCost) external;\n', '\n', '    /**\n', '     * @notice Used to change the subscription fee\n', '     * @param _newSubscriptionCost New subscription fee\n', '     */\n', '    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;\n', '\n', '    /**\n', '     * @notice Function use to change the lower and upper bound of the compatible version st\n', '     * @param _boundType Type of bound\n', '     * @param _newVersion New version array\n', '     */\n', '    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;\n', '\n', '   /**\n', '     * @notice Get the setup cost of the module\n', '     */\n', '    function getSetupCost() external view returns (uint256);\n', '\n', '    /**\n', '     * @notice Used to get the lower bound\n', '     * @return Lower bound\n', '     */\n', '    function getLowerSTVersionBounds() external view returns(uint8[]);\n', '\n', '     /**\n', '     * @notice Used to get the upper bound\n', '     * @return Upper bound\n', '     */\n', '    function getUpperSTVersionBounds() external view returns(uint8[]);\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helper library use to compare or validate the semantic versions\n', ' */\n', '\n', 'library VersionUtils {\n', '\n', '    /**\n', '     * @notice This function is used to validate the version submitted\n', '     * @param _current Array holds the present version of ST\n', '     * @param _new Array holds the latest version of the ST\n', '     * @return bool\n', '     */\n', '    function isValidVersion(uint8[] _current, uint8[] _new) internal pure returns(bool) {\n', '        bool[] memory _temp = new bool[](_current.length);\n', '        uint8 counter = 0;\n', '        for (uint8 i = 0; i < _current.length; i++) {\n', '            if (_current[i] < _new[i])\n', '                _temp[i] = true;\n', '            else\n', '                _temp[i] = false;\n', '        }\n', '\n', '        for (i = 0; i < _current.length; i++) {\n', '            if (i == 0) {\n', '                if (_current[i] <= _new[i])\n', '                    if(_temp[0]) {\n', '                        counter = counter + 3;\n', '                        break;\n', '                    } else\n', '                        counter++;\n', '                else\n', '                    return false;\n', '            } else {\n', '                if (_temp[i-1])\n', '                    counter++;\n', '                else if (_current[i] <= _new[i])\n', '                    counter++;\n', '                else\n', '                    return false;\n', '            }\n', '        }\n', '        if (counter == _current.length)\n', '            return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Used to compare the lower bound with the latest version\n', '     * @param _version1 Array holds the lower bound of the version\n', '     * @param _version2 Array holds the latest version of the ST\n', '     * @return bool\n', '     */\n', '    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\n', '        require(_version1.length == _version2.length, "Input length mismatch");\n', '        uint counter = 0;\n', '        for (uint8 j = 0; j < _version1.length; j++) {\n', '            if (_version1[j] == 0)\n', '                counter ++;\n', '        }\n', '        if (counter != _version1.length) {\n', '            counter = 0;\n', '            for (uint8 i = 0; i < _version1.length; i++) {\n', '                if (_version2[i] > _version1[i])\n', '                    return true;\n', '                else if (_version2[i] < _version1[i])\n', '                    return false;\n', '                else\n', '                    counter++;\n', '            }\n', '            if (counter == _version1.length - 1)\n', '                return true;\n', '            else\n', '                return false;\n', '        } else\n', '            return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Used to compare the upper bound with the latest version\n', '     * @param _version1 Array holds the upper bound of the version\n', '     * @param _version2 Array holds the latest version of the ST\n', '     * @return bool\n', '     */\n', '    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\n', '        require(_version1.length == _version2.length, "Input length mismatch");\n', '        uint counter = 0;\n', '        for (uint8 j = 0; j < _version1.length; j++) {\n', '            if (_version1[j] == 0)\n', '                counter ++;\n', '        }\n', '        if (counter != _version1.length) {\n', '            counter = 0;\n', '            for (uint8 i = 0; i < _version1.length; i++) {\n', '                if (_version1[i] > _version2[i])\n', '                    return true;\n', '                else if (_version1[i] < _version2[i])\n', '                    return false;\n', '                else\n', '                    counter++;\n', '            }\n', '            if (counter == _version1.length - 1)\n', '                return true;\n', '            else\n', '                return false;\n', '        } else\n', '            return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Used to pack the uint8[] array data into uint24 value\n', '     * @param _major Major version\n', '     * @param _minor Minor version\n', '     * @param _patch Patch version\n', '     */\n', '    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\n', '        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\n', '    }\n', '\n', '    /**\n', '     * @notice Used to convert packed data into uint8 array\n', '     * @param _packedVersion Packed data\n', '     */\n', '    function unpack(uint24 _packedVersion) internal pure returns (uint8[]) {\n', '        uint8[] memory _unpackVersion = new uint8[](3);\n', '        _unpackVersion[0] = uint8(_packedVersion >> 16);\n', '        _unpackVersion[1] = uint8(_packedVersion >> 8);\n', '        _unpackVersion[2] = uint8(_packedVersion);\n', '        return _unpackVersion;\n', '    }\n', '\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface that any module factory contract should implement\n', ' * @notice Contract is abstract\n', ' */\n', 'contract ModuleFactory is IModuleFactory, Ownable {\n', '\n', '    IERC20 public polyToken;\n', '    uint256 public usageCost;\n', '    uint256 public monthlySubscriptionCost;\n', '\n', '    uint256 public setupCost;\n', '    string public description;\n', '    string public version;\n', '    bytes32 public name;\n', '    string public title;\n', '\n', '    // @notice Allow only two variables to be stored\n', '    // 1. lowerBound \n', '    // 2. upperBound\n', '    // @dev (0.0.0 will act as the wildcard) \n', '    // @dev uint24 consists packed value of uint8 _major, uint8 _minor, uint8 _patch\n', '    mapping(string => uint24) compatibleSTVersionRange;\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\n', '        polyToken = IERC20(_polyAddress);\n', '        setupCost = _setupCost;\n', '        usageCost = _usageCost;\n', '        monthlySubscriptionCost = _subscriptionCost;\n', '    }\n', '\n', '    /**\n', '     * @notice Used to change the fee of the setup cost\n', '     * @param _newSetupCost new setup cost\n', '     */\n', '    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\n', '        emit ChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\n', '        setupCost = _newSetupCost;\n', '    }\n', '\n', '    /**\n', '     * @notice Used to change the fee of the usage cost\n', '     * @param _newUsageCost new usage cost\n', '     */\n', '    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\n', '        emit ChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\n', '        usageCost = _newUsageCost;\n', '    }\n', '\n', '    /**\n', '     * @notice Used to change the fee of the subscription cost\n', '     * @param _newSubscriptionCost new subscription cost\n', '     */\n', '    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\n', '        emit ChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\n', '        monthlySubscriptionCost = _newSubscriptionCost;\n', '\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the title of the ModuleFactory\n', '     * @param _newTitle New Title that will replace the old one.\n', '     */\n', '    function changeTitle(string _newTitle) public onlyOwner {\n', '        require(bytes(_newTitle).length > 0, "Invalid title");\n', '        title = _newTitle;\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the description of the ModuleFactory\n', '     * @param _newDesc New description that will replace the old one.\n', '     */\n', '    function changeDescription(string _newDesc) public onlyOwner {\n', '        require(bytes(_newDesc).length > 0, "Invalid description");\n', '        description = _newDesc;\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the name of the ModuleFactory\n', '     * @param _newName New name that will replace the old one.\n', '     */\n', '    function changeName(bytes32 _newName) public onlyOwner {\n', '        require(_newName != bytes32(0),"Invalid name");\n', '        name = _newName;\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the version of the ModuleFactory\n', '     * @param _newVersion New name that will replace the old one.\n', '     */\n', '    function changeVersion(string _newVersion) public onlyOwner {\n', '        require(bytes(_newVersion).length > 0, "Invalid version");\n', '        version = _newVersion;\n', '    }\n', '\n', '    /**\n', '     * @notice Function use to change the lower and upper bound of the compatible version st\n', '     * @param _boundType Type of bound\n', '     * @param _newVersion new version array\n', '     */\n', '    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external onlyOwner {\n', '        require(\n', '            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked("lowerBound")) ||\n', '            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked("upperBound")),\n', '            "Must be a valid bound type"\n', '        );\n', '        require(_newVersion.length == 3);\n', '        if (compatibleSTVersionRange[_boundType] != uint24(0)) { \n', '            uint8[] memory _currentVersion = VersionUtils.unpack(compatibleSTVersionRange[_boundType]);\n', '            require(VersionUtils.isValidVersion(_currentVersion, _newVersion), "Failed because of in-valid version");\n', '        }\n', '        compatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);\n', '        emit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);\n', '    }\n', '\n', '    /**\n', '     * @notice Used to get the lower bound\n', '     * @return lower bound\n', '     */\n', '    function getLowerSTVersionBounds() external view returns(uint8[]) {\n', '        return VersionUtils.unpack(compatibleSTVersionRange["lowerBound"]);\n', '    }\n', '\n', '    /**\n', '     * @notice Used to get the upper bound\n', '     * @return upper bound\n', '     */\n', '    function getUpperSTVersionBounds() external view returns(uint8[]) {\n', '        return VersionUtils.unpack(compatibleSTVersionRange["upperBound"]);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the setup cost of the module\n', '     */\n', '    function getSetupCost() external view returns (uint256) {\n', '        return setupCost;\n', '    }\n', '\n', '   /**\n', '    * @notice Get the name of the Module\n', '    */\n', '    function getName() public view returns(bytes32) {\n', '        return name;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Factory for deploying GeneralTransferManager module\n', ' */\n', 'contract GeneralTransferManagerFactory is ModuleFactory {\n', '\n', '    address public logicContract;\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _polyAddress Address of the polytoken\n', '     * @param _setupCost Setup cost of the module\n', '     * @param _usageCost Usage cost of the module\n', '     * @param _subscriptionCost Subscription cost of the module\n', '     * @param _logicContract Contract address that contains the logic related to `description`\n', '     */\n', '    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n', '    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n', '    {\n', '        require(_logicContract != address(0), "Invalid logic contract");\n', '        version = "2.1.0";\n', '        name = "GeneralTransferManager";\n', '        title = "General Transfer Manager";\n', '        description = "Manage transfers using a time based whitelist";\n', '        compatibleSTVersionRange["lowerBound"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n', '        compatibleSTVersionRange["upperBound"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n', '        logicContract = _logicContract;\n', '    }\n', '\n', '\n', '     /**\n', '     * @notice Used to launch the Module with the help of factory\n', '     * @return address Contract address of the Module\n', '     */\n', '    function deploy(bytes /* _data */) external returns(address) {\n', '        if (setupCost > 0)\n', '            require(polyToken.transferFrom(msg.sender, owner, setupCost), "Failed transferFrom because of sufficent Allowance is not provided");\n', '        address generalTransferManager = new GeneralTransferManagerProxy(msg.sender, address(polyToken), logicContract);\n', '        /*solium-disable-next-line security/no-block-members*/\n', '        emit GenerateModuleFromFactory(address(generalTransferManager), getName(), address(this), msg.sender, setupCost, now);\n', '        return address(generalTransferManager);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Type of the Module factory\n', '     */\n', '    function getTypes() external view returns(uint8[]) {\n', '        uint8[] memory res = new uint8[](1);\n', '        res[0] = 2;\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the instructions associated with the module\n', '     */\n', '    function getInstructions() external view returns(string) {\n', '        /*solium-disable-next-line max-len*/\n', '        return "Allows an issuer to maintain a time based whitelist of authorised token holders.Addresses are added via modifyWhitelist and take a fromTime (the time from which they can send tokens) and a toTime (the time from which they can receive tokens). There are additional flags, allowAllWhitelistIssuances, allowAllWhitelistTransfers & allowAllTransfers which allow you to set corresponding contract level behaviour. Init function takes no parameters.";\n', '    }\n', '\n', '    /**\n', '     * @notice Get the tags related to the module factory\n', '     */\n', '    function getTags() public view returns(bytes32[]) {\n', '        bytes32[] memory availableTags = new bytes32[](2);\n', '        availableTags[0] = "General";\n', '        availableTags[1] = "Transfer Restriction";\n', '        return availableTags;\n', '    }\n', '\n', '\n', '}']