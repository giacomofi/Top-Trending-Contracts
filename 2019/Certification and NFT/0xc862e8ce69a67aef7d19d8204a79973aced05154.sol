['// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '// File: contracts/Broker.sol\n', '\n', 'pragma solidity 0.4.25;\n', '\n', '\n', '\n', '/// @title The Broker + Vault contract for Switcheo Exchange\n', '/// @author Switcheo Network\n', '/// @notice This contract faciliates Ethereum and ERC-20 trades\n', '/// between users. Users can trade with each other by making\n', '/// and taking offers without giving up custody of their tokens.\n', '/// Users should first deposit tokens, then communicate off-chain\n', '/// with the exchange coordinator, in order to place orders\n', '/// (make / take offers). This allows trades to be confirmed\n', '/// immediately by the coordinator, and settled on-chain through\n', '/// this contract at a later time.\n', 'contract Broker is Claimable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Offer {\n', '        address maker;\n', '        address offerAsset;\n', '        address wantAsset;\n', '        uint64 nonce;\n', '        uint256 offerAmount;\n', '        uint256 wantAmount;\n', '        uint256 availableAmount; // the remaining offer amount\n', '    }\n', '\n', '    struct AnnouncedWithdrawal {\n', '        uint256 amount;\n', '        uint256 canWithdrawAt;\n', '    }\n', '\n', '    // Exchange states\n', '    enum State { Active, Inactive }\n', '    State public state;\n', '\n', '    // The maximum announce delay in seconds\n', '    // (7 days * 24 hours * 60 mins * 60 seconds)\n', '    uint32 constant maxAnnounceDelay = 604800;\n', '    // Ether token "address" is set as the constant 0x00\n', '    address constant etherAddr = address(0);\n', '\n', '    // deposits\n', '    uint8 constant ReasonDeposit = 0x01;\n', '    // making an offer\n', '    uint8 constant ReasonMakerGive = 0x02;\n', '    uint8 constant ReasonMakerFeeGive = 0x10;\n', '    uint8 constant ReasonMakerFeeReceive = 0x11;\n', '    // filling an offer\n', '    uint8 constant ReasonFillerGive = 0x03;\n', '    uint8 constant ReasonFillerFeeGive = 0x04;\n', '    uint8 constant ReasonFillerReceive = 0x05;\n', '    uint8 constant ReasonMakerReceive = 0x06;\n', '    uint8 constant ReasonFillerFeeReceive = 0x07;\n', '    // cancelling an offer\n', '    uint8 constant ReasonCancel = 0x08;\n', '    uint8 constant ReasonCancelFeeGive = 0x12;\n', '    uint8 constant ReasonCancelFeeReceive = 0x13;\n', '    // withdrawals\n', '    uint8 constant ReasonWithdraw = 0x09;\n', '    uint8 constant ReasonWithdrawFeeGive = 0x14;\n', '    uint8 constant ReasonWithdrawFeeReceive = 0x15;\n', '\n', '    // The coordinator sends trades (balance transitions) to the exchange\n', '    address public coordinator;\n', '    // The operator receives fees\n', '    address public operator;\n', '    // The time required to wait after a cancellation is announced\n', '    // to let the operator detect it in non-byzantine conditions\n', '    uint32 public cancelAnnounceDelay;\n', '    // The time required to wait after a withdrawal is announced\n', '    // to let the operator detect it in non-byzantine conditions\n', '    uint32 public withdrawAnnounceDelay;\n', '\n', '    // User balances by: userAddress => assetHash => balance\n', '    mapping(address => mapping(address => uint256)) public balances;\n', '    // Offers by the creation transaction hash: transactionHash => offer\n', '    mapping(bytes32 => Offer) public offers;\n', '    // A record of which hashes have been used before\n', '    mapping(bytes32 => bool) public usedHashes;\n', '    // Set of whitelisted spender addresses allowed by the owner\n', '    mapping(address => bool) public whitelistedSpenders;\n', '    // Spenders which have been approved by individual user as: userAddress => spenderAddress => true\n', '    mapping(address => mapping(address => bool)) public approvedSpenders;\n', '    // Announced withdrawals by: userAddress => assetHash => data\n', '    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;\n', '    // Announced cancellations by: offerHash => data\n', '    mapping(bytes32 => uint256) public announcedCancellations;\n', '\n', '    // Emitted when new offers made\n', '    event Make(address indexed maker, bytes32 indexed offerHash);\n', '    // Emitted when offers are filled\n', '    event Fill(address indexed filler, bytes32 indexed offerHash, uint256 amountFilled, uint256 amountTaken, address indexed maker);\n', '    // Emitted when offers are cancelled\n', '    event Cancel(address indexed maker, bytes32 indexed offerHash);\n', '    // Emitted on any balance state transition (+ve)\n', '    event BalanceIncrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\n', '    // Emitted on any balance state transition (-ve)\n', '    event BalanceDecrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\n', '    // Emitted when a withdrawal is annnounced\n', '    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);\n', '    // Emitted when a cancellation is annnounced\n', '    event CancelAnnounce(address indexed user, bytes32 indexed offerHash, uint256 canCancelAt);\n', '    // Emitted when a user approved a spender\n', '    event SpenderApprove(address indexed user, address indexed spender);\n', '    // Emitted when a user rescinds approval for a spender\n', '    event SpenderRescind(address indexed user, address indexed spender);\n', '\n', '    /// @notice Initializes the Broker contract\n', '    /// @dev The coordinator and operator is initialized\n', '    /// to be the address of the sender. The Broker is immediately\n', '    /// put into an active state, with maximum exit delays set.\n', '    constructor()\n', '        public\n', '    {\n', '        coordinator = msg.sender;\n', '        operator = msg.sender;\n', '        cancelAnnounceDelay = maxAnnounceDelay;\n', '        withdrawAnnounceDelay = maxAnnounceDelay;\n', '        state = State.Active;\n', '    }\n', '\n', '    modifier onlyCoordinator() {\n', '        require(\n', '            msg.sender == coordinator,\n', '            "Invalid sender"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyActiveState() {\n', '        require(\n', '            state == State.Active,\n', '            "Invalid state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyInactiveState() {\n', '        require(\n', '            state == State.Inactive,\n', '            "Invalid state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier notMoreThanMaxDelay(uint32 _delay) {\n', '        require(\n', '            _delay <= maxAnnounceDelay,\n', '            "Invalid delay"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier unusedReasonCode(uint8 _reasonCode) {\n', '        require(\n', '            _reasonCode > ReasonWithdrawFeeReceive,\n', '            "Invalid reason code"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @notice Sets the Broker contract state\n', '    /// @dev There are only two states - Active & Inactive.\n', '    ///\n', '    /// The Active state is the normal operating state for the contract -\n', '    /// deposits, trading and withdrawals can be carried out.\n', '    ///\n', '    /// In the Inactive state, the coordinator can invoke additional\n', '    /// emergency methods such as emergencyCancel and emergencyWithdraw,\n', '    /// without the cooperation of users. However, deposits and trading\n', '    /// methods cannot be invoked at that time. This state is meant\n', '    /// primarily to terminate and upgrade the contract, or to be used\n', '    /// in the event that the contract is considered no longer viable\n', '    /// to continue operation, and held tokens should be immediately\n', '    /// withdrawn to their respective owners.\n', '    /// @param _state The state to transition the contract into\n', '    function setState(State _state) external onlyOwner { state = _state; }\n', '\n', '    /// @notice Sets the coordinator address.\n', '    /// @dev All standard operations (except `depositEther`)\n', '    /// must be invoked by the coordinator.\n', '    /// @param _coordinator The address to set as the coordinator\n', '    function setCoordinator(address _coordinator) external onlyOwner {\n', '        _validateAddress(_coordinator);\n', '        coordinator = _coordinator;\n', '    }\n', '\n', '    /// @notice Sets the operator address.\n', '    /// @dev All fees are paid to the operator.\n', '    /// @param _operator The address to set as the operator\n', '    function setOperator(address _operator) external onlyOwner {\n', '        _validateAddress(operator);\n', '        operator = _operator;\n', '    }\n', '\n', '    /// @notice Sets the delay between when a cancel\n', '    /// intention must be announced, and when the cancellation\n', '    /// can actually be executed on-chain\n', '    /// @dev This delay exists so that the coordinator has time to\n', '    /// respond when a user is attempting to bypass it and cancel\n', '    /// offers directly on-chain.\n', '    /// Note that this is an direct on-chain cancellation\n', '    /// is an atypical operation - see `slowCancel`\n', '    /// for more details.\n', '    /// @param _delay The delay in seconds\n', '    function setCancelAnnounceDelay(uint32 _delay)\n', '        external\n', '        onlyOwner\n', '        notMoreThanMaxDelay(_delay)\n', '    {\n', '        cancelAnnounceDelay = _delay;\n', '    }\n', '\n', '    /// @notice Sets the delay (in seconds) between when a withdrawal\n', '    /// intention must be announced, and when the withdrawal\n', '    /// can actually be executed on-chain.\n', '    /// @dev This delay exists so that the coordinator has time to\n', '    /// respond when a user is attempting to bypass it and cancel\n', '    /// offers directly on-chain. See `announceWithdraw` and\n', '    /// `slowWithdraw` for more details.\n', '    /// @param _delay The delay in seconds\n', '    function setWithdrawAnnounceDelay(uint32 _delay)\n', '        external\n', '        onlyOwner\n', '        notMoreThanMaxDelay(_delay)\n', '    {\n', '        withdrawAnnounceDelay = _delay;\n', '    }\n', '\n', '    /// @notice Adds an address to the set of allowed spenders.\n', '    /// @dev Spenders are meant to be additional EVM contracts that\n', '    /// will allow adding or upgrading of trading functionality, without\n', '    /// having to cancel all offers and withdraw all tokens for all users.\n', '    /// This whitelist ensures that all approved spenders are contracts\n', '    /// that have been verified by the owner. Note that each user also\n', '    /// has to invoke `approveSpender` to actually allow the `_spender`\n', '    /// to spend his/her balance, so that they can examine / verify\n', '    /// the new spender contract first.\n', '    /// @param _spender The address to add as a whitelisted spender\n', '    function addSpender(address _spender)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _validateAddress(_spender);\n', '        whitelistedSpenders[_spender] = true;\n', '    }\n', '\n', '    /// @notice Removes an address from the set of allowed spenders.\n', '    /// @dev Note that removing a spender from the whitelist will not\n', "    /// prevent already approved spenders from spending a user's balance.\n", '    /// This is to ensure that the spender contracts can be certain that once\n', '    /// an approval is done, the owner cannot rescient spending priviledges,\n', '    /// and cause tokens to be withheld or locked in the spender contract.\n', '    /// Users must instead manually rescind approvals using `rescindApproval`\n', '    /// after the `_spender` has been removed from the whitelist.\n', '    /// @param _spender The address to remove as a whitelisted spender\n', '    function removeSpender(address _spender)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _validateAddress(_spender);\n', '        delete whitelistedSpenders[_spender];\n', '    }\n', '\n', "    /// @notice Deposits Ethereum tokens under the `msg.sender`'s balance\n", '    /// @dev Allows sending ETH to the contract, and increasing\n', "    /// the user's contract balance by the amount sent in.\n", '    /// This operation is only usable in an Active state to prevent\n', '    /// a terminated contract from receiving tokens.\n', '    function depositEther()\n', '        external\n', '        payable\n', '        onlyActiveState\n', '    {\n', '        require(\n', '            msg.value > 0,\n', "            'Invalid value'\n", '        );\n', '        balances[msg.sender][etherAddr] = balances[msg.sender][etherAddr].add(msg.value);\n', '        emit BalanceIncrease(msg.sender, etherAddr, msg.value, ReasonDeposit);\n', '    }\n', '\n', "    /// @notice Deposits ERC20 tokens under the `_user`'s balance\n", '    /// @dev Allows sending ERC20 tokens to the contract, and increasing\n', "    /// the user's contract balance by the amount sent in. This operation\n", '    /// can only be used after an ERC20 `approve` operation for a\n', '    /// sufficient amount has been carried out.\n', '    ///\n', '    /// Note that this operation does not require user signatures as\n', '    /// a valid ERC20 `approve` call is considered as intent to deposit\n', '    /// the tokens. This is as there is no other ERC20 methods that this\n', '    /// contract can call.\n', '    ///\n', '    /// This operation can only be called by the coordinator,\n', '    /// and should be autoamtically done so whenever an `approve` event\n', '    /// from a ERC20 token (that the coordinator deems valid)\n', '    /// approving this contract to spend tokens on behalf of a user is seen.\n', '    ///\n', '    /// This operation is only usable in an Active state to prevent\n', '    /// a terminated contract from receiving tokens.\n', '    /// @param _user The address of the user that is depositing tokens\n', '    /// @param _token The address of the ERC20 token to deposit\n', '    /// @param _amount The (approved) amount to deposit\n', '    function depositERC20(\n', '        address _user,\n', '        address _token,\n', '        uint256 _amount\n', '    )\n', '        external\n', '        onlyCoordinator\n', '        onlyActiveState\n', '    {\n', '        require(\n', '            _amount > 0,\n', "            'Invalid value'\n", '        );\n', '        balances[_user][_token] = balances[_user][_token].add(_amount);\n', '\n', '        _validateIsContract(_token);\n', '        require(\n', '            _token.call(\n', '                bytes4(keccak256("transferFrom(address,address,uint256)")),\n', '                _user,\n', '                address(this),\n', '                _amount\n', '            ),\n', '            "transferFrom call failed"\n', '        );\n', '        require(\n', '            _getSanitizedReturnValue(),\n', '            "transferFrom failed."\n', '        );\n', '\n', '        emit BalanceIncrease(_user, _token, _amount, ReasonDeposit);\n', '    }\n', '\n', '    /// @notice Withdraws `_amount` worth of `_token`s to the `_withdrawer`\n', '    /// @dev This is the standard withdraw operation. Tokens can only be\n', "    /// withdrawn directly to the token balance owner's address.\n", '    /// Fees can be paid to cover network costs, as the operation must\n', '    /// be invoked by the coordinator. The hash of all parameters, prefixed\n', '    /// with the operation name "withdraw" must be signed by the withdrawer\n', '    /// to validate the withdrawal request. A nonce that is issued by the\n', '    /// coordinator is used to prevent replay attacks.\n', "    /// See `slowWithdraw` for withdrawing without requiring the coordinator's\n", '    /// involvement.\n', '    /// @param _withdrawer The address of the user that is withdrawing tokens\n', '    /// @param _token The address of the token to withdraw\n', '    /// @param _amount The number of tokens to withdraw\n', '    /// @param _feeAsset The address of the token to use for fee payment\n', '    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n', '    /// @param _nonce The nonce to prevent replay attacks\n', "    /// @param _v The `v` component of the `_withdrawer`'s signature\n", "    /// @param _r The `r` component of the `_withdrawer`'s signature\n", "    /// @param _s The `s` component of the `_withdrawer`'s signature\n", '    function withdraw(\n', '        address _withdrawer,\n', '        address _token,\n', '        uint256 _amount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint64 _nonce,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        onlyCoordinator\n', '    {\n', '        bytes32 msgHash = keccak256(abi.encodePacked(\n', '            "withdraw",\n', '            _withdrawer,\n', '            _token,\n', '            _amount,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            _nonce\n', '        ));\n', '\n', '        require(\n', '            _recoverAddress(msgHash, _v, _r, _s) == _withdrawer,\n', '            "Invalid signature"\n', '        );\n', '\n', '        _validateAndAddHash(msgHash);\n', '\n', '        _withdraw(_withdrawer, _token, _amount, _feeAsset, _feeAmount);\n', '    }\n', '\n', '    /// @notice Announces intent to withdraw tokens using `slowWithdraw`\n', '    /// @dev Allows a user to invoke `slowWithdraw` after a minimum of\n', '    /// `withdrawAnnounceDelay` seconds has passed.\n', '    /// This announcement and delay is necessary so that the operator has time\n', '    /// to respond if a user attempts to invoke a `slowWithdraw` even though\n', '    /// the exchange is operating normally. In that case, the coordinator would respond\n', '    /// by not allowing the announced amount of tokens to be used in future trades\n', '    /// the moment a `WithdrawAnnounce` is seen.\n', '    /// @param _token The address of the token to withdraw after the required exit delay\n', '    /// @param _amount The number of tokens to withdraw after the required exit delay\n', '    function announceWithdraw(\n', '        address _token,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            _amount <= balances[msg.sender][_token],\n', '            "Amount too high"\n', '        );\n', '\n', '        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];\n', '        uint256 canWithdrawAt = now + withdrawAnnounceDelay;\n', '\n', '        announcement.canWithdrawAt = canWithdrawAt;\n', '        announcement.amount = _amount;\n', '\n', '        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);\n', '    }\n', '\n', '    /// @notice Withdraw tokens without requiring the coordinator\n', '    /// @dev This operation is meant to be used if the operator becomes "byzantine",\n', '    /// so that users can still exit tokens locked in this contract.\n', '    /// The `announceWithdraw` operation has to be invoked first, and a minimum time of\n', '    /// `withdrawAnnounceDelay` seconds have to pass, before this operation can be carried out.\n', '    /// Note that this direct on-chain withdrawal is an atypical operation, and\n', '    /// the normal `withdraw` operation should be used in non-byzantine states.\n', '    /// @param _withdrawer The address of the user that is withdrawing tokens\n', '    /// @param _token The address of the token to withdraw\n', '    /// @param _amount The number of tokens to withdraw\n', '    function slowWithdraw(\n', '        address _withdrawer,\n', '        address _token,\n', '        uint256 _amount\n', '    )\n', '        external\n', '    {\n', '        AnnouncedWithdrawal memory announcement = announcedWithdrawals[_withdrawer][_token];\n', '\n', '        require(\n', '            announcement.canWithdrawAt != 0 && announcement.canWithdrawAt <= now,\n', '            "Insufficient delay"\n', '        );\n', '\n', '        require(\n', '            announcement.amount == _amount,\n', '            "Invalid amount"\n', '        );\n', '\n', '        delete announcedWithdrawals[_withdrawer][_token];\n', '\n', '        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\n', '    }\n', '\n', "    /// @notice Withdraws tokens to the owner without requiring the owner's signature\n", '    /// @dev Can only be invoked in an Inactive state by the coordinator.\n', '    /// This operation is meant to be used in emergencies only.\n', '    /// @param _withdrawer The address of the user that should have tokens withdrawn\n', '    /// @param _token The address of the token to withdraw\n', '    /// @param _amount The number of tokens to withdraw\n', '    function emergencyWithdraw(\n', '        address _withdrawer,\n', '        address _token,\n', '        uint256 _amount\n', '    )\n', '        external\n', '        onlyCoordinator\n', '        onlyInactiveState\n', '    {\n', '        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\n', '    }\n', '\n', '    /// @notice Makes an offer which can be filled by other users.\n', '    /// @dev Makes an offer for `_offerAmount` of `offerAsset` tokens\n', '    /// for `wantAmount` of `wantAsset` tokens, that can be filled later\n', '    /// by one or more counterparties using `fillOffer` or `fillOffers`.\n', '    /// The offer can be later cancelled using `cancel` or `slowCancel` as long\n', '    /// as it has not completely been filled.\n', '    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\n', '    /// to cover orderbook maintenance and network costs.\n', '    /// The hash of all parameters, prefixed with the operation name "makeOffer"\n', '    /// must be signed by the `_maker` to validate the offer request.\n', '    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n', '    /// This operation can only be invoked by the coordinator in an Active state.\n', '    /// @param _maker The address of the user that is making the offer\n', '    /// @param _offerAsset The address of the token being offered\n', '    /// @param _wantAsset The address of the token asked in return\n', '    /// @param _offerAmount The number of tokens being offered\n', '    /// @param _wantAmount The number of tokens asked for in return\n', '    /// @param _feeAsset The address of the token to use for fee payment\n', '    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n', '    /// @param _nonce The nonce to prevent replay attacks\n', "    /// @param _v The `v` component of the `_maker`'s signature\n", "    /// @param _r The `r` component of the `_maker`'s signature\n", "    /// @param _s The `s` component of the `_maker`'s signature\n", '    function makeOffer(\n', '        address _maker,\n', '        address _offerAsset,\n', '        address _wantAsset,\n', '        uint256 _offerAmount,\n', '        uint256 _wantAmount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint64 _nonce,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        onlyCoordinator\n', '        onlyActiveState\n', '    {\n', '        require(\n', '            _offerAmount > 0 && _wantAmount > 0,\n', '            "Invalid amounts"\n', '        );\n', '\n', '        require(\n', '            _offerAsset != _wantAsset,\n', '            "Invalid assets"\n', '        );\n', '\n', '        bytes32 offerHash = keccak256(abi.encodePacked(\n', '            "makeOffer",\n', '            _maker,\n', '            _offerAsset,\n', '            _wantAsset,\n', '            _offerAmount,\n', '            _wantAmount,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            _nonce\n', '        ));\n', '\n', '        require(\n', '            _recoverAddress(offerHash, _v, _r, _s) == _maker,\n', '            "Invalid signature"\n', '        );\n', '\n', '        _validateAndAddHash(offerHash);\n', '\n', "        // Reduce maker's balance\n", '        _decreaseBalanceAndPayFees(\n', '            _maker,\n', '            _offerAsset,\n', '            _offerAmount,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            ReasonMakerGive,\n', '            ReasonMakerFeeGive,\n', '            ReasonMakerFeeReceive\n', '        );\n', '\n', '        // Store the offer\n', '        Offer storage offer = offers[offerHash];\n', '        offer.maker = _maker;\n', '        offer.offerAsset = _offerAsset;\n', '        offer.wantAsset = _wantAsset;\n', '        offer.offerAmount = _offerAmount;\n', '        offer.wantAmount = _wantAmount;\n', '        offer.availableAmount = _offerAmount;\n', '        offer.nonce = _nonce;\n', '\n', '        emit Make(_maker, offerHash);\n', '    }\n', '\n', '    /// @notice Fills a offer that has been previously made using `makeOffer`.\n', '    /// @dev Fill an offer with `_offerHash` by giving `_amountToTake` of\n', "    /// the offers' `wantAsset` tokens.\n", '    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\n', '    /// to cover orderbook maintenance and network costs.\n', '    /// The hash of all parameters, prefixed with the operation name "fillOffer"\n', '    /// must be signed by the `_filler` to validate the fill request.\n', '    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n', '    /// This operation can only be invoked by the coordinator in an Active state.\n', '    /// @param _filler The address of the user that is filling the offer\n', '    /// @param _offerHash The hash of the offer to fill\n', '    /// @param _amountToTake The number of tokens to take from the offer\n', '    /// @param _feeAsset The address of the token to use for fee payment\n', '    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n', '    /// @param _nonce The nonce to prevent replay attacks\n', "    /// @param _v The `v` component of the `_filler`'s signature\n", "    /// @param _r The `r` component of the `_filler`'s signature\n", "    /// @param _s The `s` component of the `_filler`'s signature\n", '    function fillOffer(\n', '        address _filler,\n', '        bytes32 _offerHash,\n', '        uint256 _amountToTake,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint64 _nonce,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        onlyCoordinator\n', '        onlyActiveState\n', '    {\n', '        bytes32 msgHash = keccak256(\n', '            abi.encodePacked(\n', '                "fillOffer",\n', '                _filler,\n', '                _offerHash,\n', '                _amountToTake,\n', '                _feeAsset,\n', '                _feeAmount,\n', '                _nonce\n', '            )\n', '        );\n', '\n', '        require(\n', '            _recoverAddress(msgHash, _v, _r, _s) == _filler,\n', '            "Invalid signature"\n', '        );\n', '\n', '        _validateAndAddHash(msgHash);\n', '\n', '        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);\n', '    }\n', '\n', '    /// @notice Fills multiple offers that have been previously made using `makeOffer`.\n', '    /// @dev Fills multiple offers with hashes in `_offerHashes` for amounts in\n', '    /// `_amountsToTake`. This method allows conserving of the base gas cost.\n', '    /// A fee of `_feeAmount` of `_feeAsset`  tokens can be paid to the operator\n', '    /// to cover orderbook maintenance and network costs.\n', '    /// The hash of all parameters, prefixed with the operation name "fillOffers"\n', '    /// must be signed by the maker to validate the fill request.\n', '    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n', '    /// This operation can only be invoked by the coordinator in an Active state.\n', '    /// @param _filler The address of the user that is filling the offer\n', '    /// @param _offerHashes The hashes of the offers to fill\n', '    /// @param _amountsToTake The number of tokens to take for each offer\n', '    /// (each index corresponds to the entry with the same index in _offerHashes)\n', '    /// @param _feeAsset The address of the token to use for fee payment\n', '    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n', '    /// @param _nonce The nonce to prevent replay attacks\n', "    /// @param _v The `v` component of the `_filler`'s signature\n", "    /// @param _r The `r` component of the `_filler`'s signature\n", "    /// @param _s The `s` component of the `_filler`'s signature\n", '    function fillOffers(\n', '        address _filler,\n', '        bytes32[] _offerHashes,\n', '        uint256[] _amountsToTake,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint64 _nonce,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        onlyCoordinator\n', '        onlyActiveState\n', '    {\n', '        require(\n', '            _offerHashes.length > 0,\n', "            'Invalid input'\n", '        );\n', '        require(\n', '            _offerHashes.length == _amountsToTake.length,\n', "            'Invalid inputs'\n", '        );\n', '\n', '        bytes32 msgHash = keccak256(\n', '            abi.encodePacked(\n', '                "fillOffers",\n', '                _filler,\n', '                _offerHashes,\n', '                _amountsToTake,\n', '                _feeAsset,\n', '                _feeAmount,\n', '                _nonce\n', '            )\n', '        );\n', '\n', '        require(\n', '            _recoverAddress(msgHash, _v, _r, _s) == _filler,\n', '            "Invalid signature"\n', '        );\n', '\n', '        _validateAndAddHash(msgHash);\n', '\n', '        for (uint32 i = 0; i < _offerHashes.length; i++) {\n', '            _fill(_filler, _offerHashes[i], _amountsToTake[i], etherAddr, 0);\n', '        }\n', '\n', '        _paySeparateFees(\n', '            _filler,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            ReasonFillerFeeGive,\n', '            ReasonFillerFeeReceive\n', '        );\n', '    }\n', '\n', '    /// @notice Cancels an offer that was preivously made using `makeOffer`.\n', '    /// @dev Cancels the offer with `_offerHash`. An `_expectedAvailableAmount`\n', '    /// is provided to allow the coordinator to ensure that the offer is not accidentally\n', '    /// cancelled ahead of time (where there is a pending fill that has not been settled).\n', '    /// The hash of the _offerHash, _feeAsset, `_feeAmount` prefixed with the\n', '    /// operation name "cancel" must be signed by the offer maker to validate\n', '    /// the cancellation request. Only the coordinator can invoke this operation.\n', "    /// See `slowCancel` for cancellation without requiring the coordinator's\n", '    /// involvement.\n', '    /// @param _offerHash The hash of the offer to cancel\n', '    /// @param _expectedAvailableAmount The number of tokens that should be present when cancelling\n', '    /// @param _feeAsset The address of the token to use for fee payment\n', '    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n', "    /// @param _v The `v` component of the offer maker's signature\n", "    /// @param _r The `r` component of the offer maker's signature\n", "    /// @param _s The `s` component of the offer maker's signature\n", '    function cancel(\n', '        bytes32 _offerHash,\n', '        uint256 _expectedAvailableAmount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        onlyCoordinator\n', '    {\n', '        require(\n', '            _recoverAddress(keccak256(abi.encodePacked(\n', '                "cancel",\n', '                _offerHash,\n', '                _feeAsset,\n', '                _feeAmount\n', '            )), _v, _r, _s) == offers[_offerHash].maker,\n', '            "Invalid signature"\n', '        );\n', '\n', '        _cancel(_offerHash, _expectedAvailableAmount, _feeAsset, _feeAmount);\n', '    }\n', '\n', '    /// @notice Announces intent to cancel tokens using `slowCancel`\n', '    /// @dev Allows a user to invoke `slowCancel` after a minimum of\n', '    /// `cancelAnnounceDelay` seconds has passed.\n', '    /// This announcement and delay is necessary so that the operator has time\n', '    /// to respond if a user attempts to invoke a `slowCancel` even though\n', '    /// the exchange is operating normally.\n', '    /// In that case, the coordinator would simply stop matching the offer to\n', '    /// viable counterparties the moment the `CancelAnnounce` is seen.\n', '    /// @param _offerHash The hash of the offer that will be cancelled\n', '    function announceCancel(bytes32 _offerHash)\n', '        external\n', '    {\n', '        Offer memory offer = offers[_offerHash];\n', '\n', '        require(\n', '            offer.maker == msg.sender,\n', '            "Invalid sender"\n', '        );\n', '\n', '        require(\n', '            offer.availableAmount > 0,\n', '            "Offer already cancelled"\n', '        );\n', '\n', '        uint256 canCancelAt = now + cancelAnnounceDelay;\n', '        announcedCancellations[_offerHash] = canCancelAt;\n', '\n', '        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);\n', '    }\n', '\n', '    /// @notice Cancel an offer without requiring the coordinator\n', '    /// @dev This operation is meant to be used if the operator becomes "byzantine",\n', '    /// so that users can still cancel offers in this contract, and withdraw tokens\n', '    /// using `slowWithdraw`.\n', '    /// The `announceCancel` operation has to be invoked first, and a minimum time of\n', '    /// `cancelAnnounceDelay` seconds have to pass, before this operation can be carried out.\n', '    /// Note that this direct on-chain cancellation is an atypical operation, and\n', '    /// the normal `cancel` operation should be used in non-byzantine states.\n', '    /// @param _offerHash The hash of the offer to cancel\n', '    function slowCancel(bytes32 _offerHash)\n', '        external\n', '    {\n', '        require(\n', '            announcedCancellations[_offerHash] != 0 && announcedCancellations[_offerHash] <= now,\n', '            "Insufficient delay"\n', '        );\n', '\n', '        delete announcedCancellations[_offerHash];\n', '\n', '        Offer memory offer = offers[_offerHash];\n', '        _cancel(_offerHash, offer.availableAmount, etherAddr, 0);\n', '    }\n', '\n', '    /// @notice Cancels an offer immediately once cancellation intent\n', '    /// has been announced.\n', '    /// @dev Can only be invoked by the coordinator. This allows\n', '    /// the coordinator to quickly remove offers that it has already\n', '    /// acknowledged, and move its offer book into a consistent state.\n', '    function fastCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\n', '        external\n', '        onlyCoordinator\n', '    {\n', '        require(\n', '            announcedCancellations[_offerHash] != 0,\n', '            "Missing annoncement"\n', '        );\n', '\n', '        delete announcedCancellations[_offerHash];\n', '\n', '        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\n', '    }\n', '\n', "    /// @notice Cancels an offer without requiring the owner's signature,\n", '    /// so that the tokens can be withdrawn using `emergencyWithdraw`.\n', '    /// @dev Can only be invoked in an Inactive state by the coordinator.\n', '    /// This operation is meant to be used in emergencies only.\n', '    function emergencyCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\n', '        external\n', '        onlyCoordinator\n', '        onlyInactiveState\n', '    {\n', '        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\n', '    }\n', '\n', '    /// @notice Approve an address for spending any amount of\n', "    /// any token from the `msg.sender`'s balances\n", '    /// @dev Analogous to ERC-20 `approve`, with the following differences:\n', '    ///     - `_spender` must be whitelisted by owner\n', '    ///     - approval can be rescinded at a later time by the user\n', '    ///       iff it has been removed from the whitelist\n', '    ///     - spending amount is unlimited\n', '    /// @param _spender The address to approve spending\n', '    function approveSpender(address _spender)\n', '        external\n', '    {\n', '        require(\n', '            whitelistedSpenders[_spender],\n', '            "Spender is not whitelisted"\n', '        );\n', '\n', '        approvedSpenders[msg.sender][_spender] = true;\n', '        emit SpenderApprove(msg.sender, _spender);\n', '    }\n', '\n', "    /// @notice Rescinds a previous approval for spending the `msg.sender`'s contract balance.\n", '    /// @dev Rescinds approval for a spender, after it has been removed from\n', '    /// the `whitelistedSpenders` set. This allows an approval to be removed\n', '    /// if both the owner and user agrees that the previously approved spender\n', '    /// contract should no longer be used.\n', '    /// @param _spender The address to rescind spending approval\n', '    function rescindApproval(address _spender)\n', '        external\n', '    {\n', '        require(\n', '            approvedSpenders[msg.sender][_spender],\n', '            "Spender has not been approved"\n', '        );\n', '\n', '        require(\n', '            whitelistedSpenders[_spender] != true,\n', '            "Spender must be removed from the whitelist"\n', '        );\n', '\n', '        delete approvedSpenders[msg.sender][_spender];\n', '        emit SpenderRescind(msg.sender, _spender);\n', '    }\n', '\n', '    /// @notice Transfers tokens from one address to another\n', '    /// @dev Analogous to ERC-20 `transferFrom`, with the following differences:\n', '    ///     - the address of the token to transfer must be specified\n', '    ///     - any amount of token can be transferred, as long as it is less or equal\n', "    ///       to `_from`'s balance\n", '    ///     - reason codes can be attached and they must not use reasons specified in\n', '    ///       this contract\n', '    /// @param _from The address to transfer tokens from\n', '    /// @param _to The address to transfer tokens to\n', '    /// @param _amount The number of tokens to transfer\n', '    /// @param _token The address of the token to transfer\n', '    /// @param _decreaseReason A reason code to emit in the `BalanceDecrease` event\n', '    /// @param _increaseReason A reason code to emit in the `BalanceIncrease` event\n', '    function spendFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount,\n', '        address _token,\n', '        uint8 _decreaseReason,\n', '        uint8 _increaseReason\n', '    )\n', '        external\n', '        unusedReasonCode(_decreaseReason)\n', '        unusedReasonCode(_increaseReason)\n', '    {\n', '        require(\n', '            approvedSpenders[_from][msg.sender],\n', '            "Spender has not been approved"\n', '        );\n', '\n', '        _validateAddress(_to);\n', '\n', '        balances[_from][_token] = balances[_from][_token].sub(_amount);\n', '        emit BalanceDecrease(_from, _token, _amount, _decreaseReason);\n', '\n', '        balances[_to][_token] = balances[_to][_token].add(_amount);\n', '        emit BalanceIncrease(_to, _token, _amount, _increaseReason);\n', '    }\n', '\n', '    /// @dev Overrides ability to renounce ownership as this contract is\n', '    /// meant to always have an owner.\n', '    function renounceOwnership() public { require(false, "Cannot have no owner"); }\n', '\n', '    /// @dev The actual withdraw logic that is used internally by multiple operations.\n', '    function _withdraw(\n', '        address _withdrawer,\n', '        address _token,\n', '        uint256 _amount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount\n', '    )\n', '        private\n', '    {\n', '        // SafeMath.sub checks that balance is sufficient already\n', '        _decreaseBalanceAndPayFees(\n', '            _withdrawer,\n', '            _token,\n', '            _amount,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            ReasonWithdraw,\n', '            ReasonWithdrawFeeGive,\n', '            ReasonWithdrawFeeReceive\n', '        );\n', '\n', '        if (_token == etherAddr) // ether\n', '        {\n', '            _withdrawer.transfer(_amount);\n', '        }\n', '        else\n', '        {\n', '            _validateIsContract(_token);\n', '            require(\n', '                _token.call(\n', '                    bytes4(keccak256("transfer(address,uint256)")), _withdrawer, _amount\n', '                ),\n', '                "transfer call failed"\n', '            );\n', '            require(\n', '                _getSanitizedReturnValue(),\n', '                "transfer failed"\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev The actual fill logic that is used internally by multiple operations.\n', '    function _fill(\n', '        address _filler,\n', '        bytes32 _offerHash,\n', '        uint256 _amountToTake,\n', '        address _feeAsset,\n', '        uint256 _feeAmount\n', '    )\n', '        private\n', '    {\n', '        require(\n', '            _amountToTake > 0,\n', '            "Invalid input"\n', '        );\n', '\n', '        Offer storage offer = offers[_offerHash];\n', '        require(\n', '            offer.maker != _filler,\n', '            "Invalid filler"\n', '        );\n', '\n', '        require(\n', '            offer.availableAmount != 0,\n', '            "Offer already filled"\n', '        );\n', '\n', '        uint256 amountToFill = (_amountToTake.mul(offer.wantAmount)).div(offer.offerAmount);\n', '\n', '        // transfer amountToFill in fillAsset from filler to maker\n', '        balances[_filler][offer.wantAsset] = balances[_filler][offer.wantAsset].sub(amountToFill);\n', '        emit BalanceDecrease(_filler, offer.wantAsset, amountToFill, ReasonFillerGive);\n', '\n', '        balances[offer.maker][offer.wantAsset] = balances[offer.maker][offer.wantAsset].add(amountToFill);\n', '        emit BalanceIncrease(offer.maker, offer.wantAsset, amountToFill, ReasonMakerReceive);\n', '\n', '        // deduct amountToTake in takeAsset from offer\n', '        offer.availableAmount = offer.availableAmount.sub(_amountToTake);\n', '        _increaseBalanceAndPayFees(\n', '            _filler,\n', '            offer.offerAsset,\n', '            _amountToTake,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            ReasonFillerReceive,\n', '            ReasonFillerFeeGive,\n', '            ReasonFillerFeeReceive\n', '        );\n', '        emit Fill(_filler, _offerHash, amountToFill, _amountToTake, offer.maker);\n', '\n', '        if (offer.availableAmount == 0)\n', '        {\n', '            delete offers[_offerHash];\n', '        }\n', '    }\n', '\n', '    /// @dev The actual cancellation logic that is used internally by multiple operations.\n', '    function _cancel(\n', '        bytes32 _offerHash,\n', '        uint256 _expectedAvailableAmount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount\n', '    )\n', '        private\n', '    {\n', '        Offer memory offer = offers[_offerHash];\n', '\n', '        require(\n', '            offer.availableAmount > 0,\n', '            "Offer already cancelled"\n', '        );\n', '\n', '        require(\n', '            offer.availableAmount == _expectedAvailableAmount,\n', '            "Invalid input"\n', '        );\n', '\n', '        delete offers[_offerHash];\n', '\n', '        _increaseBalanceAndPayFees(\n', '            offer.maker,\n', '            offer.offerAsset,\n', '            offer.availableAmount,\n', '            _feeAsset,\n', '            _feeAmount,\n', '            ReasonCancel,\n', '            ReasonCancelFeeGive,\n', '            ReasonCancelFeeReceive\n', '        );\n', '\n', '        emit Cancel(offer.maker, _offerHash);\n', '    }\n', '\n', '    /// @dev Performs an `ecrecover` operation for signed message hashes\n', '    /// in accordance to EIP-191.\n', '    function _recoverAddress(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s)\n', '        private\n', '        pure\n', '        returns (address)\n', '    {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hash));\n', '        return ecrecover(prefixedHash, _v, _r, _s);\n', '    }\n', '\n', "    /// @dev Decreases a user's balance while adding a cut from the decrement\n", '    /// to be paid as fees to the operator. Reason codes should be provided\n', '    /// to be emitted with events for tracking.\n', '    function _decreaseBalanceAndPayFees(\n', '        address _user,\n', '        address _token,\n', '        uint256 _amount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint8 _reason,\n', '        uint8 _feeGiveReason,\n', '        uint8 _feeReceiveReason\n', '    )\n', '        private\n', '    {\n', '        uint256 totalAmount = _amount;\n', '\n', '        if (_feeAsset == _token) {\n', '            totalAmount = _amount.add(_feeAmount);\n', '        }\n', '\n', '        balances[_user][_token] = balances[_user][_token].sub(totalAmount);\n', '        emit BalanceDecrease(_user, _token, totalAmount, _reason);\n', '\n', '        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\n', '    }\n', '\n', "    /// @dev Increases a user's balance while deducting a cut from the increment\n", '    /// to be paid as fees to the operator. Reason codes should be provided\n', '    /// to be emitted with events for tracking.\n', '    function _increaseBalanceAndPayFees(\n', '        address _user,\n', '        address _token,\n', '        uint256 _amount,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint8 _reason,\n', '        uint8 _feeGiveReason,\n', '        uint8 _feeReceiveReason\n', '    )\n', '        private\n', '    {\n', '        uint256 totalAmount = _amount;\n', '\n', '        if (_feeAsset == _token) {\n', '            totalAmount = _amount.sub(_feeAmount);\n', '        }\n', '\n', '        balances[_user][_token] = balances[_user][_token].add(totalAmount);\n', '        emit BalanceIncrease(_user, _token, totalAmount, _reason);\n', '\n', '        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\n', '    }\n', '\n', '    /// @dev Pays fees to the operator, attaching the specified reason codes\n', '    /// to the emitted event, only deducting from the `_user` balance if the\n', '    /// `_token` does not match `_feeAsset`.\n', '    /// IMPORTANT: In the event that the `_token` matches `_feeAsset`,\n', '    /// there should a reduction in balance increment carried out separately,\n', '    /// to ensure balance consistency.\n', '    function _payFees(\n', '        address _user,\n', '        address _token,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint8 _feeGiveReason,\n', '        uint8 _feeReceiveReason\n', '    )\n', '        private\n', '    {\n', '        if (_feeAmount == 0) {\n', '            return;\n', '        }\n', '\n', '        // if the feeAsset does not match the token then the feeAmount needs to be separately deducted\n', '        if (_feeAsset != _token) {\n', '            balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\n', '            emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\n', '        }\n', '\n', '        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\n', '        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\n', '    }\n', '\n', '    /// @dev Pays fees to the operator, attaching the specified reason codes to the emitted event.\n', '    function _paySeparateFees(\n', '        address _user,\n', '        address _feeAsset,\n', '        uint256 _feeAmount,\n', '        uint8 _feeGiveReason,\n', '        uint8 _feeReceiveReason\n', '    )\n', '        private\n', '    {\n', '        if (_feeAmount == 0) {\n', '            return;\n', '        }\n', '\n', '        balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\n', '        emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\n', '\n', '        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\n', '        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\n', '    }\n', '\n', '    /// @dev Ensures that the address is a valid user address.\n', '    function _validateAddress(address _address)\n', '        private\n', '        pure\n', '    {\n', '        require(\n', '            _address != address(0),\n', "            'Invalid address'\n", '        );\n', '    }\n', '\n', "    /// @dev Ensures a hash hasn't been already used, which would mean\n", '    /// a repeated set of arguments and nonce was used. This prevents\n', '    /// replay attacks.\n', '    function _validateAndAddHash(bytes32 _hash)\n', '        private\n', '    {\n', '        require(\n', '            usedHashes[_hash] != true,\n', '            "hash already used"\n', '        );\n', '\n', '        usedHashes[_hash] = true;\n', '    }\n', '\n', '    /// @dev Ensure that the address is a deployed contract\n', '    function _validateIsContract(address addr) private view {\n', '        assembly {\n', '            if iszero(extcodesize(addr)) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @dev Fix for ERC-20 tokens that do not have proper return type\n', '    /// See: https://github.com/ethereum/solidity/issues/4116\n', '    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\n', '    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\n', '    function _getSanitizedReturnValue()\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 result = 0;\n', '        assembly {\n', '            switch returndatasize\n', '            case 0 {    // this is an non-standard ERC-20 token\n', '                result := 1 // assume success on no revert\n', '            }\n', '            case 32 {   // this is a standard ERC-20 token\n', '                returndatacopy(0, 0, 32)\n', '                result := mload(0)\n', '            }\n', '            default {   // this is not an ERC-20 token\n', '                revert(0, 0) // revert for safety\n', '            }\n', '        }\n', '        return result != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/NukeBurner.sol\n', '\n', 'pragma solidity 0.4.25;\n', '\n', '\n', '\n', '\n', '/// @title The NukeBurner contract to burn 2% of tokens on approve+transfer\n', '/// @author Switcheo Network\n', 'contract NukeBurner {\n', '    using SafeMath for uint256;\n', '\n', '    // The Switcheo Broker contract\n', '    StandardToken public nuke;\n', '    Broker public broker;\n', '\n', '    uint8 constant ReasonDepositBurnGive = 0x40;\n', '    uint8 constant ReasonDepositBurnReceive = 0x41;\n', '\n', '    // A record of deposits that will have 1% burnt\n', '    mapping(address => uint256) public preparedBurnAmounts;\n', '    mapping(address => bytes32) public preparedBurnHashes;\n', '\n', '    event PrepareBurn(address indexed depositer, uint256 depositAmount, bytes32 indexed approvalTransactionHash, uint256 burnAmount);\n', '    event ExecuteBurn(address indexed depositer, uint256 burnAmount, bytes32 indexed approvalTransactionHash);\n', '\n', '    /// @notice Initializes the AirDropper contract\n', '    /// @dev The broker is initialized to the Switcheo Broker\n', '    constructor(address brokerAddress, address tokenAddress)\n', '        public\n', '    {\n', '        broker = Broker(brokerAddress);\n', '        nuke = StandardToken(tokenAddress);\n', '    }\n', '\n', '    modifier onlyCoordinator() {\n', '        require(\n', '            msg.sender == address(broker.coordinator()),\n', '            "Invalid sender"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function prepareBurn(\n', '        address _depositer,\n', '        uint256 _depositAmount,\n', '        bytes32 _approvalTransactionHash\n', '    )\n', '        external\n', '        onlyCoordinator\n', '    {\n', '        require(\n', '            _depositAmount > 0,\n', '            "Invalid deposit amount"\n', '        );\n', '\n', '        require(\n', '            nuke.allowance(_depositer, address(broker)) == _depositAmount,\n', '            "Invalid approval amount"\n', '        );\n', '\n', '        preparedBurnAmounts[_depositer] = _depositAmount.div(50);\n', '        preparedBurnHashes[_depositer] = _approvalTransactionHash;\n', '\n', '        emit PrepareBurn(_depositer, _depositAmount, _approvalTransactionHash, preparedBurnAmounts[_depositer]);\n', '    }\n', '\n', '    function executeBurn(\n', '        address _depositer,\n', '        uint256 _burnAmount,\n', '        bytes32 _approvalTransactionHash\n', '    )\n', '        external\n', '        onlyCoordinator\n', '    {\n', '        require(\n', '            _burnAmount == preparedBurnAmounts[_depositer],\n', '            "Invalid burn amount"\n', '        );\n', '\n', '        require(\n', '            _approvalTransactionHash == preparedBurnHashes[_depositer],\n', '            "Invalid approval transaction hash"\n', '        );\n', '\n', '        require(\n', '            nuke.allowance(_depositer, address(broker)) == 0,\n', '            "Invalid approved amount"\n', '        );\n', '\n', '        delete preparedBurnAmounts[_depositer];\n', '        delete preparedBurnHashes[_depositer];\n', '\n', '        broker.spendFrom(\n', '            _depositer,\n', '            address(this),\n', '            _burnAmount,\n', '            address(nuke),\n', '            ReasonDepositBurnGive,\n', '            ReasonDepositBurnReceive\n', '        );\n', '\n', '        emit ExecuteBurn(_depositer, _burnAmount, _approvalTransactionHash);\n', '    }\n', '}']