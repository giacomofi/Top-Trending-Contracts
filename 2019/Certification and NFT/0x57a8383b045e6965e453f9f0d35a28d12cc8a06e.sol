['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  struct restrict {\n', '        uint amount;\n', '        uint restrictTime;\n', '  } \n', '\n', '  mapping(address => uint256) balances;\n', '  mapping (address => restrict) restricts;\n', '\n', '  function getrestrict(address _owner) public view  returns (uint){\n', '      uint restrictAmount = 0;\n', '\n', '      if(restricts[_owner].amount != 0){\n', '        if(restricts[_owner].restrictTime <= now){\n', '            uint diffmonth = (now - restricts[_owner].restrictTime) / (10 minutes);\n', '            if(diffmonth < 4){\n', '                diffmonth = 4 - diffmonth;\n', '                restrictAmount = (diffmonth * restricts[_owner].amount)/4;\n', '            }\n', '        }else{\n', '            restrictAmount = restricts[_owner].amount;\n', '        }\n', '      }\n', '\n', '      return restrictAmount;\n', '  }\n', '\n', '  function getrestrictTime(address _owner) public view returns (uint){\n', '      return restricts[_owner].restrictTime;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '  \n', '    require(_to != address(0));\n', '    \n', '    uint restrictAmount =  getrestrict(msg.sender);\n', '    \n', '    require((_value + restrictAmount) <= balances[msg.sender]);\n', '    \n', '    /* if send address is AB, restrict token */ \n', '    if(msg.sender == address(0xFA3aA02539d1217fe6Af1599913ddb1A852f1934)){\n', '        require(0 == restricts[_to].amount);\n', '        restricts[_to].restrictTime = now + (10 minutes);\n', '        restricts[_to].amount = _value;\n', '    } else if(msg.sender == address(0xD5345443886e2188e63609E77EA73d1df44Ea4BC)){\n', '        require(0 == restricts[_to].amount);\n', '        restricts[_to].restrictTime = now + (10 minutes);\n', '        restricts[_to].amount = _value;\n', '    } \n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract LockToken is BasicToken {\n', '\n', '  string public constant name = "Lock Token";\n', '  string public constant symbol = "LKT";\n', '  uint8 public constant decimals = 18;\n', '\n', '  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n', '  \n', '  constructor() public {\n', '    totalSupply = INITIAL_SUPPLY;\n', '    balances[0xFA3aA02539d1217fe6Af1599913ddb1A852f1934] = 100000000 * (10 ** uint256(decimals));\n', '    balances[0xD5345443886e2188e63609E77EA73d1df44Ea4BC] = 800000000 * (10 ** uint256(decimals));\n', '    balances[0x617eC39184E1527e847449A5d8a252FfD7C29DDf] = 100000000 * (10 ** uint256(decimals));\n', '    \n', '    emit Transfer(msg.sender, 0xFA3aA02539d1217fe6Af1599913ddb1A852f1934, 100000000 * (10 ** uint256(decimals)));\n', '    emit Transfer(msg.sender, 0xD5345443886e2188e63609E77EA73d1df44Ea4BC, 800000000 * (10 ** uint256(decimals)));\n', '    emit Transfer(msg.sender, 0x617eC39184E1527e847449A5d8a252FfD7C29DDf, 100000000 * (10 ** uint256(decimals)));\n', '  }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  struct restrict {\n', '        uint amount;\n', '        uint restrictTime;\n', '  } \n', '\n', '  mapping(address => uint256) balances;\n', '  mapping (address => restrict) restricts;\n', '\n', '  function getrestrict(address _owner) public view  returns (uint){\n', '      uint restrictAmount = 0;\n', '\n', '      if(restricts[_owner].amount != 0){\n', '        if(restricts[_owner].restrictTime <= now){\n', '            uint diffmonth = (now - restricts[_owner].restrictTime) / (10 minutes);\n', '            if(diffmonth < 4){\n', '                diffmonth = 4 - diffmonth;\n', '                restrictAmount = (diffmonth * restricts[_owner].amount)/4;\n', '            }\n', '        }else{\n', '            restrictAmount = restricts[_owner].amount;\n', '        }\n', '      }\n', '\n', '      return restrictAmount;\n', '  }\n', '\n', '  function getrestrictTime(address _owner) public view returns (uint){\n', '      return restricts[_owner].restrictTime;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '  \n', '    require(_to != address(0));\n', '    \n', '    uint restrictAmount =  getrestrict(msg.sender);\n', '    \n', '    require((_value + restrictAmount) <= balances[msg.sender]);\n', '    \n', '    /* if send address is AB, restrict token */ \n', '    if(msg.sender == address(0xFA3aA02539d1217fe6Af1599913ddb1A852f1934)){\n', '        require(0 == restricts[_to].amount);\n', '        restricts[_to].restrictTime = now + (10 minutes);\n', '        restricts[_to].amount = _value;\n', '    } else if(msg.sender == address(0xD5345443886e2188e63609E77EA73d1df44Ea4BC)){\n', '        require(0 == restricts[_to].amount);\n', '        restricts[_to].restrictTime = now + (10 minutes);\n', '        restricts[_to].amount = _value;\n', '    } \n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract LockToken is BasicToken {\n', '\n', '  string public constant name = "Lock Token";\n', '  string public constant symbol = "LKT";\n', '  uint8 public constant decimals = 18;\n', '\n', '  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n', '  \n', '  constructor() public {\n', '    totalSupply = INITIAL_SUPPLY;\n', '    balances[0xFA3aA02539d1217fe6Af1599913ddb1A852f1934] = 100000000 * (10 ** uint256(decimals));\n', '    balances[0xD5345443886e2188e63609E77EA73d1df44Ea4BC] = 800000000 * (10 ** uint256(decimals));\n', '    balances[0x617eC39184E1527e847449A5d8a252FfD7C29DDf] = 100000000 * (10 ** uint256(decimals));\n', '    \n', '    emit Transfer(msg.sender, 0xFA3aA02539d1217fe6Af1599913ddb1A852f1934, 100000000 * (10 ** uint256(decimals)));\n', '    emit Transfer(msg.sender, 0xD5345443886e2188e63609E77EA73d1df44Ea4BC, 800000000 * (10 ** uint256(decimals)));\n', '    emit Transfer(msg.sender, 0x617eC39184E1527e847449A5d8a252FfD7C29DDf, 100000000 * (10 ** uint256(decimals)));\n', '  }\n', '}']
