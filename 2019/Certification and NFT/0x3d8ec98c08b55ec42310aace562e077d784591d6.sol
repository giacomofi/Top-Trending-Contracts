['pragma solidity ^0.5.0;\n', '\n', '/*\n', 'Future Goals:\n', '- remove admins necessity\n', '- encourage contributors to allocate\n', '- needs incentive for someone to call forfeit\n', '- read from previous versions of the script\n', '\n', 'DApp:\n', '- show tokens to allocate\n', '- allocate token to person with praise\n', '- leaderboard, showing amount totalReceived and totalForfeited and amount, praises https://codepen.io/lewismcarey/pen/GJZVoG\n', '- allows you to send SNT to meritocracy\n', '- add/remove contributor\n', '- add/remove adminstrator\n', '\n', 'Extension:\n', '- Command:\n', '    - above command = display allocation, received, withdraw button, allocate button? (might be better in dapp)\n', '    - /kudos 500 "<person>" "<praise>"\n', '*/\n', '\n', '\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'interface ERC20Token {\n', '\n', '    /**\n', '     * @notice send `_value` token to `_to` from `msg.sender`\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    /**\n', '     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of tokens to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    /**\n', '     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    /**\n', '     * @param _owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    /**\n', '     * @notice return total supply of tokens\n', '     */\n', '    function totalSupply() external view returns (uint256 supply);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Meritocracy {\n', '\n', '    struct Status {\n', '        address author;\n', '        string praise;\n', '        uint256 amount;\n', '        uint256 time; // block.timestamp\n', '    }\n', '\n', '    struct Contributor {\n', '        address addr;\n', '        uint256 allocation; // Amount they can send to other contributors, and amount they forfeit, when forfeit just zero this out and leave Token in contract, Owner can use escape to receive it back\n', "        uint256 totalForfeited; // Allocations they've burnt, can be used to show non-active players.\n", '        uint256 totalReceived;\n', '        uint256 received; // Ignore amounts in Status struct, and use this as source of truth, can withdraw at any time\n', "        // bool inPot; // Require Contributor WARN: commented because there's some edge cases not dealt with\n", '        Status[] status;\n', '    }\n', '\n', '    ERC20Token public token; // token contract\n', '    address payable public owner; // contract owner\n', '    uint256 public lastForfeit; // timestamp to block admins calling forfeitAllocations too quickly\n', '    address[] public registry; // array of contributor addresses\n', '    uint256 public maxContributors; // Dynamic finite limit on registry.\n', '    mapping(address => bool) public admins;\n', '    mapping(address => Contributor) public contributors;\n', '\n', '    Meritocracy public previousMeritocracy; // Reference and read from previous contract\n', '\n', '    // Events -----------------------------------------------------------------------------------------------\n', '\n', '    event ContributorAdded(address _contributor);\n', '    event ContributorRemoved(address _contributor);\n', '    event ContributorWithdrew(address _contributor);\n', '    event ContributorTransaction(address _cSender, address _cReceiver);\n', '\n', '    event AdminAdded(address _admin);\n', '    event AdminRemoved(address _admin);\n', '    event AllocationsForfeited();\n', '\n', '    event OwnerChanged(address _owner);\n', '    event TokenChanged(address _token);\n', '    event MaxContributorsChanged(uint256 _maxContributors);\n', '    event EscapeHatchTriggered(address _executor);\n', '\n', '\n', '    // Modifiers --------------------------------------------------------------------------------------------\n', '\n', '    // Functions only Owner can call\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Functions only Admin can call\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    // Open Functions  --------------------------------------------------------------------------------------\n', '\n', '    // Split amount over each contributor in registry, any contributor can allocate? TODO maybe relax this restriction, so anyone can allocate tokens\n', '    function allocate(uint256 _amount) external {\n', '        // Locals\n', '        \n', '        // Contributor memory cAllocator = contributors[msg.sender];\n', '        // Requirements\n', '        // require(cAllocator.addr != address(0)); // is sender a Contributor? TODO maybe relax this restriction.\n', '        uint256 individualAmount = _amount / registry.length;\n', '\n', '        // removing decimals\n', '        individualAmount = (individualAmount / 1000000000000000000 * 1000000000000000000);\n', '        \n', '        uint amount = individualAmount * registry.length;\n', '        \n', '        require(token.transferFrom(msg.sender, address(this), amount));\n', '        // Body\n', '        // cAllocator.inPot = true;\n', '        for (uint256 i = 0; i < registry.length; i++) {\n', '               contributors[registry[i]].allocation += individualAmount;\n', '        }\n', '    }\n', '\n', '    function getRegistry() public view returns (address[] memory) {\n', '        return registry;\n', '    }\n', '\n', '    // Contributor Functions --------------------------------------------------------------------------------\n', '\n', '    // Allows a contributor to withdraw their received Token, when their allocation is 0\n', '    function withdraw() external {\n', '        // Locals\n', '         Contributor storage cReceiver = contributors[msg.sender];\n', '         // Requirements\n', '        require(cReceiver.addr == msg.sender); //is sender a Contributor?\n', '        require(cReceiver.received > 0); // Contributor has received some tokens\n', '        require(cReceiver.allocation == 0); // Contributor must allocate all Token (or have Token burnt)  before they can withdraw.\n', '        // require(cReceiver.inPot); // Contributor has put some tokens into the pot\n', '        // Body\n', '        uint256 r = cReceiver.received;\n', '        cReceiver.received = 0;\n', '        // cReceiver.inPot = false;\n', '        token.transfer(cReceiver.addr, r);\n', '        emit ContributorWithdrew(cReceiver.addr);\n', '    }\n', '\n', '    // Allow Contributors to award allocated tokens to other Contributors\n', '    function award(address _contributor, uint256 _amount,  string memory _praise) public {\n', '        // Locals\n', '        Contributor storage cSender = contributors[msg.sender];\n', '        Contributor storage cReceiver = contributors[_contributor];\n', '        // Requirements\n', '        require(_amount > 0); // Allow Non-Zero amounts only\n', "        require(cSender.addr == msg.sender); // Ensure Contributors both exist, and isn't the same address \n", '        require(cReceiver.addr == _contributor);\n', '        require(cSender.addr != cReceiver.addr); // cannot send to self\n', '        require(cSender.allocation >= _amount); // Ensure Sender has enough tokens to allocate\n', '        // Body\n', '        cSender.allocation -= _amount; // burn is not adjusted, which is done only in forfeitAllocations\n', '        cReceiver.received += _amount;\n', '        cReceiver.totalReceived += _amount;\n', '\n', '        Status memory s = Status({\n', '            author: cSender.addr,\n', '            praise: _praise,\n', '            amount: _amount,\n', '            time: block.timestamp\n', '        });\n', '\n', '        cReceiver.status.push(s); // Record the history\n', '        emit ContributorTransaction(cSender.addr, cReceiver.addr);\n', '    }\n', '\n', '    function getStatusLength(address _contributor) public view returns (uint) {\n', '        return contributors[_contributor].status.length;\n', '    }\n', '\n', '    function getStatus(address _contributor, uint _index) public view returns (\n', '        address author,\n', '        string memory praise,\n', '        uint256 amount,\n', '        uint256 time\n', '    ) {\n', '        author = contributors[_contributor].status[_index].author;\n', '        praise = contributors[_contributor].status[_index].praise;\n', '        amount = contributors[_contributor].status[_index].amount;\n', '        time = contributors[_contributor].status[_index].time;\n', '    }\n', '\n', '    // Allow Contributor to award multiple Contributors \n', '    function awardContributors(address[] calldata _contributors, uint256 _amountEach,  string calldata _praise) external {\n', '        // Locals\n', '        Contributor storage cSender = contributors[msg.sender];\n', '        uint256 contributorsLength = _contributors.length;\n', '        uint256 totalAmount = contributorsLength * _amountEach;\n', '        // Requirements\n', '        require(cSender.allocation >= totalAmount);\n', '        // Body\n', '        for (uint256 i = 0; i < contributorsLength; i++) {\n', '                award(_contributors[i], _amountEach, _praise);\n', '        }\n', '    }\n', '\n', '    // Admin Functions  -------------------------------------------------------------------------------------\n', '\n', '    // Add Contributor to Registry\n', '    function addContributor(address _contributor) public onlyAdmin {\n', '        // Requirements\n', "        require(registry.length + 1 <= maxContributors); // Don't go out of bounds\n", "        require(contributors[_contributor].addr == address(0)); // Contributor doesn't exist\n", '        // Body\n', '        Contributor storage c = contributors[_contributor];\n', '        c.addr = _contributor;\n', '        registry.push(_contributor);\n', '        emit ContributorAdded(_contributor);\n', '    }\n', '\n', '    // Add Multiple Contributors to the Registry in one tx\n', '    function addContributors(address[] calldata _newContributors ) external onlyAdmin {\n', '        // Locals\n', '        uint256 newContributorLength = _newContributors.length;\n', '        // Requirements\n', "        require(registry.length + newContributorLength <= maxContributors); // Don't go out of bounds\n", '        // Body\n', '        for (uint256 i = 0; i < newContributorLength; i++) {\n', '                addContributor(_newContributors[i]);\n', '        }\n', '    }\n', '\n', '    // Remove Contributor from Registry\n', '    // Note: Should not be easy to remove multiple contributors in one tx\n', '    // WARN: Changed to idx, client can do loop by enumerating registry\n', '    function removeContributor(uint256 idx) external onlyAdmin { // address _contributor\n', '        // Locals\n', '        uint256 registryLength = registry.length - 1;\n', '        // Requirements\n', '        require(idx < registryLength); // idx needs to be smaller than registry.length - 1 OR maxContributors\n', '        // Body\n', '        address c = registry[idx];\n', '        // Swap & Pop!\n', '        registry[idx] = registry[registryLength];\n', '        registry.pop();\n', '        delete contributors[c]; // TODO check if this works\n', '        emit ContributorRemoved(c);\n', '    }\n', '\n', '    // Implictly sets a finite limit to registry length\n', '    function setMaxContributors(uint256 _maxContributors) external onlyAdmin {\n', '        require(_maxContributors > registry.length); // have to removeContributor first\n', '        // Body\n', '        maxContributors = _maxContributors;\n', '        emit MaxContributorsChanged(maxContributors);\n', '    }\n', '\n', '    // Zero-out allocations for contributors, minimum once a week, if allocation still exists, add to burn\n', '    function forfeitAllocations() public onlyAdmin {\n', '        // Locals\n', '        uint256 registryLength = registry.length;\n', '        // Requirements\n', '        require(block.timestamp >= lastForfeit + 1 weeks); // prevents admins accidently calling too quickly.\n', '        // Body\n', '        lastForfeit = block.timestamp; \n', '        for (uint256 i = 0; i < registryLength; i++) { // should never be longer than maxContributors, see addContributor\n', '                Contributor storage c = contributors[registry[i]];\n', '                c.totalForfeited += c.allocation; // Shaaaaame!\n', '                c.allocation = 0;\n', '                // cReceiver.inPot = false; // Contributor has to put tokens into next round\n', '        }\n', '        emit AllocationsForfeited();\n', '    }\n', '\n', '    // Owner Functions  -------------------------------------------------------------------------------------\n', '\n', '    // Set Admin flag for address to true\n', '    function addAdmin(address _admin) public onlyOwner {\n', '        admins[_admin] = true;\n', '        emit AdminAdded(_admin);\n', '    }\n', '\n', '    //  Set Admin flag for address to false\n', '    function removeAdmin(address _admin) public onlyOwner {\n', '        delete admins[_admin];\n', '        emit AdminRemoved(_admin);\n', '    }\n', '\n', '    // Change owner address, ideally to a management contract or multisig\n', '    function changeOwner(address payable _owner) external onlyOwner {\n', '        // Body\n', '        removeAdmin(owner);\n', '        addAdmin(_owner);\n', '        owner = _owner;\n', '        emit OwnerChanged(owner);\n', '    }\n', '\n', '    // Change Token address\n', '    // WARN: call escape first, or escape(token);\n', '    function changeToken(address _token) external onlyOwner {\n', '        // Body\n', '        // Zero-out allocation and received, send out received tokens before token switch.\n', '        for (uint256 i = 0; i < registry.length; i++) {\n', '                Contributor storage c = contributors[registry[i]];\n', '                uint256 r =  c.received;\n', '                c.received = 0;\n', '                c.allocation = 0;\n', '                // WARN: Should totalReceived and totalForfeited be zeroed-out? \n', '                token.transfer(c.addr, r); // Transfer any owed tokens to contributor \n', '        }\n', '        lastForfeit = block.timestamp;\n', '        token = ERC20Token(_token);\n', '        emit TokenChanged(_token);\n', '    }\n', '\n', '    // Failsafe, Owner can escape hatch all Tokens and ETH from Contract.\n', '    function escape() public onlyOwner {\n', '        // Body\n', '        token.transfer(owner,  token.balanceOf(address(this)));\n', '        owner.transfer(address(this).balance);\n', '        emit EscapeHatchTriggered(msg.sender);\n', '    }\n', '\n', '    // Overloaded failsafe function, recourse incase changeToken is called before escape and funds are in a different token\n', "    // Don't want to require in changeToken incase bad behaviour of ERC20 token\n", '    function escape(address _token) external onlyOwner {\n', '        // Body\n', '        ERC20Token t = ERC20Token(_token);\n', '        t.transfer(owner,  t.balanceOf(address(this)));\n', '        escape();\n', '    }\n', '\n', '    // Housekeeping -----------------------------------------------------------------------------------------\n', '\n', "    // function importPreviousMeritocracyData() private onlyOwner { // onlyOwner not explicitly needed but safer than sorry, it's problem with overloaded function\n", '    //      // if previousMeritocracy != address(0) { // TODO better truthiness test, casting?\n', '    //      //        // Do Stuff\n', '    //      // }\n', '    // }\n', '\n', '    // Constructor ------------------------------------------------------------------------------------------\n', '\n', '    // constructor(address _token, uint256 _maxContributors, address _previousMeritocracy) public {\n', '        \n', '    // }\n', '\n', '    // Set Owner, Token address,  initial maxContributors\n', '    constructor(address _token, uint256 _maxContributors) public {\n', '        // Body\n', '        owner = msg.sender;\n', '        addAdmin(owner);\n', '        lastForfeit = block.timestamp;\n', '        token = ERC20Token(_token);\n', '        maxContributors= _maxContributors;\n', '        // previousMeritocracy = Meritocracy(_previousMeritocracy);\n', '        // importPreviousMeritocracyData() TODO\n', '    }\n', '}']