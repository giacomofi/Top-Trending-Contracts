['pragma solidity >=0.4.25 <0.6.0;\n', '\n', '/**\n', ' * Minimum recommendation: 10(GWEI) & 121000 Gas \n', '   Minimum send to this contract = 0.2 eth\n', '   Approximately 2.5 mill tokens = 10.000 ETH "hard goal"\n', '   Deadline 4/aug/2019  \n', '    check in site iskra-coin.io\n', ' */\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external;\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract LightCrowdsale1 is ReentrancyGuard {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\n', '    address payable public beneficiary; // wallet to send eth to\n', '    uint public fundingGoal; // maximum amount to raise\n', '    uint public amountRaised; // current amount raised\n', '    uint public minAmountWei; // min amount for crowdsale\n', '    uint public deadline; // time when crowdsale to close\n', '    uint public price; // price for token\n', '    token public tokenReward; // token\n', '    mapping(address => uint256) public balanceOf;\n', '    bool fundingGoalReached = false;\n', '    bool crowdsaleClosed = false;\n', '\n', '    event GoalReached(address recipient, uint totalAmountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constructor\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor(\n', '        address payable ifSuccessfulSendTo,\n', '        uint fundingGoalInEthers,\n', '        uint durationInMinutes,\n', '        uint finneyCostOfEachToken,\n', '        address addressOfTokenUsedAsReward,\n', '        uint minAmountFinney\n', '    ) public {\n', '        beneficiary = ifSuccessfulSendTo;\n', '        fundingGoal = fundingGoalInEthers * 1 ether;\n', '        deadline = now + durationInMinutes * 1 minutes;\n', '        price = finneyCostOfEachToken * 1 finney;\n', '        minAmountWei = minAmountFinney * 1 finney;\n', '        tokenReward = token(addressOfTokenUsedAsReward);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function() payable external {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address sender) public nonReentrant payable {\n', '        checkGoalReached();\n', '        require(!crowdsaleClosed);\n', '        require(sender != address(0));\n', '        uint amount = msg.value;\n', '        require(balanceOf[sender] >= amount);\n', '        require(amount != 0);\n', '        require(amount >= minAmountWei);\n', '\n', '        uint senderBalance = balanceOf[sender];\n', '        balanceOf[sender] = senderBalance.add(amount);\n', '        amountRaised = amountRaised.add(amount);\n', '        uint tokenToSend = amount.div(price) * 1 ether;\n', '        tokenReward.transfer(sender, tokenToSend);\n', '        emit FundTransfer(sender, amount, true);\n', '\n', '        if (beneficiary.send(amount)) {\n', '            emit FundTransfer(beneficiary, amount, false);\n', '        }\n', '\n', '        checkGoalReached();\n', '    }\n', '\n', '    modifier afterDeadline() {if (now >= deadline) _;}\n', '\n', '    /**\n', '     * Check if goal was reached\n', '     *\n', '     * Checks if the goal or time limit has been reached and ends the campaign\n', '     */\n', '    function checkGoalReached() public afterDeadline {\n', '        if (amountRaised >= fundingGoal) {\n', '            fundingGoalReached = true;\n', '            crowdsaleClosed = true;\n', '            emit GoalReached(beneficiary, amountRaised);\n', '        }\n', '        if (now > deadline) {\n', '            crowdsaleClosed = true;\n', '            emit GoalReached(beneficiary, amountRaised);\n', '        }\n', '    }\n', '}']