['pragma solidity >=0.5.4 <0.6.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t * @dev Multiplies two numbers, throws on overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tc = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Integer division of two numbers, truncating the quotient.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\t// uint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn a / b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Adds two numbers, throws on overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '\t\tc = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', 'interface INameTAOPosition {\n', '\tfunction senderIsAdvocate(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsListener(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsSpeaker(address _sender, address _id) external view returns (bool);\n', '\tfunction senderIsPosition(address _sender, address _id) external view returns (bool);\n', '\tfunction getAdvocate(address _id) external view returns (address);\n', '\tfunction nameIsAdvocate(address _nameId, address _id) external view returns (bool);\n', '\tfunction nameIsPosition(address _nameId, address _id) external view returns (bool);\n', '\tfunction initialize(address _id, address _advocateId, address _listenerId, address _speakerId) external returns (bool);\n', '\tfunction determinePosition(address _sender, address _id) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAO\n', ' */\n', 'contract TAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public vaultAddress;\n', '\tstring public name;\t\t\t\t// the name for this TAO\n', "\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\n", '\n', "\t// TAO's data\n", '\tstring public datHash;\n', '\tstring public database;\n', '\tstring public keyValue;\n', '\tbytes32 public contentId;\n', '\n', '\t/**\n', '\t * 0 = TAO\n', '\t * 1 = Name\n', '\t */\n', '\tuint8 public typeId;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _vaultAddress\n', '\t) public {\n', '\t\tname = _name;\n', '\t\toriginId = _originId;\n', '\t\tdatHash = _datHash;\n', '\t\tdatabase = _database;\n', '\t\tkeyValue = _keyValue;\n', '\t\tcontentId = _contentId;\n', '\n', '\t\t// Creating TAO\n', '\t\ttypeId = 0;\n', '\n', '\t\tvaultAddress = _vaultAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if calling address is Vault contract\n', '\t */\n', '\tmodifier onlyVault {\n', '\t\trequire (msg.sender == vaultAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Will receive any ETH sent\n', '\t */\n', '\tfunction () external payable {\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\t_recipient.transfer(_amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\n', '\t * @param _erc20TokenAddress The address of ERC20 Token\n', '\t * @param _recipient The recipient address\n', '\t * @param _amount The amount to transfer\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\n', '\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\n', '\t\t_erc20.transfer(_recipient, _amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'interface INameAccountRecovery {\n', '\tfunction isCompromised(address _id) external view returns (bool);\n', '}\n', '\n', '\n', 'interface INameFactory {\n', '\tfunction nonces(address _nameId) external view returns (uint256);\n', '\tfunction incrementNonce(address _nameId) external returns (uint256);\n', '\tfunction ethAddressToNameId(address _ethAddress) external view returns (address);\n', '\tfunction setNameNewAddress(address _id, address _newAddress) external returns (bool);\n', '\tfunction nameIdToEthAddress(address _nameId) external view returns (address);\n', '}\n', '\n', '\n', 'contract TheAO {\n', '\taddress public theAO;\n', '\taddress public nameTAOPositionAddress;\n', '\n', '\t// Check whether an address is whitelisted and granted access to transact\n', '\t// on behalf of others\n', '\tmapping (address => bool) public whitelist;\n', '\n', '\tconstructor() public {\n', '\t\ttheAO = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if msg.sender is in whitelist.\n', '\t */\n', '\tmodifier inWhitelist() {\n', '\t\trequire (whitelist[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public {\n', '\t\trequire (msg.sender == theAO);\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '}\n', '\n', '\n', 'interface ITAOFactory {\n', '\tfunction nonces(address _taoId) external view returns (uint256);\n', '\tfunction incrementNonce(address _taoId) external returns (uint256);\n', '}\n', '\n', '\n', 'interface ITAOPool {\n', '\tfunction createPool(address _taoId, bool _ethosCapStatus, uint256 _ethosCapAmount) external returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Name\n', ' */\n', 'contract Name is TAO {\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor (string memory _name, address _originId, string memory _datHash, string memory _database, string memory _keyValue, bytes32 _contentId, address _vaultAddress)\n', '\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\n', '\t\t// Creating Name\n', '\t\ttypeId = 1;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenERC20 {\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals = 18;\n', '\t// 18 decimals is the strongly suggested default, avoid changing it\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\tmapping (address => uint256) public balanceOf;\n', '\tmapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply tokens to the creator of the contract\n', '\t */\n', '\tconstructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n', '\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '\t\tname = tokenName;                                   // Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\n', '\t}\n', '\n', '\t/**\n', '\t * Internal transfer, only can be called by this contract\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint _value) internal {\n', '\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_to != address(0));\n', '\t\t// Check if the sender has enough\n', '\t\trequire(balanceOf[_from] >= _value);\n', '\t\t// Check for overflows\n', '\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\n', '\t\t// Save this for an assertion in the future\n', '\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\t\t// Subtract from the sender\n', '\t\tbalanceOf[_from] -= _value;\n', '\t\t// Add the same to the recipient\n', '\t\tbalanceOf[_to] += _value;\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens\n', '\t *\n', '\t * Send `_value` tokens to `_to` from your account\n', '\t *\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n', '\t\t_transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer tokens from other address\n', '\t *\n', '\t * Send `_value` tokens to `_to` in behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '\t\tallowance[_from][msg.sender] -= _value;\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Set allowance for other address and notify\n', '\t *\n', '\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '\t *\n', '\t * @param _spender The address authorized to spend\n', '\t * @param _value the max amount they can spend\n', '\t * @param _extraData some extra information to send to the approved contract\n', '\t */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly\n', '\t *\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '\t\ttotalSupply -= _value;                      // Updates totalSupply\n', '\t\temit Burn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens from other account\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '\t\ttotalSupply -= _value;                              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title AOLibrary\n', ' */\n', 'library AOLibrary {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\n', '\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given TAO ID is a TAO\n', '\t * @param _taoId The ID of the TAO\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isTAO(address _taoId) public view returns (bool) {\n', '\t\treturn (_taoId != address(0) && bytes(TAO(address(uint160(_taoId))).name()).length > 0 && TAO(address(uint160(_taoId))).originId() != address(0) && TAO(address(uint160(_taoId))).typeId() == 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check whether or not the given Name ID is a Name\n', '\t * @param _nameId The ID of the Name\n', '\t * @return true if yes. false otherwise\n', '\t */\n', '\tfunction isName(address _nameId) public view returns (bool) {\n', '\t\treturn (_nameId != address(0) && bytes(TAO(address(uint160(_nameId))).name()).length > 0 && Name(address(uint160(_nameId))).originId() != address(0) && Name(address(uint160(_nameId))).typeId() == 1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_tokenAddress` is a valid ERC20 Token address\n', '\t * @param _tokenAddress The ERC20 Token address to check\n', '\t */\n', '\tfunction isValidERC20TokenAddress(address _tokenAddress) public view returns (bool) {\n', '\t\tif (_tokenAddress == address(0)) {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t\tTokenERC20 _erc20 = TokenERC20(_tokenAddress);\n', '\t\treturn (_erc20.totalSupply() >= 0 && bytes(_erc20.name()).length > 0 && bytes(_erc20.symbol()).length > 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t * @param _sender The address to check\n', '\t * @param _theAO The AO address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\n', '\t\treturn (_sender == _theAO ||\n', '\t\t\t(\n', '\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\n', '\t\t\t\t_nameTAOPositionAddress != address(0) &&\n', '\t\t\t\tINameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\n', '\t\t\t)\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate percentage.\n', '\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\n', '\t *\t\tso 1% is 10000, 1.25% is 12500, etc\n', '\t */\n', '\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _PERCENTAGE_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the divisor used to correctly calculate multiplier.\n', '\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\n', '\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\n', '\t */\n', '\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\n', '\t\treturn _MULTIPLIER_DIVISOR;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev deploy a TAO\n', '\t * @param _name The name of the TAO\n', '\t * @param _originId The Name ID the creates the TAO\n', '\t * @param _datHash The datHash of this TAO\n', '\t * @param _database The database for this TAO\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this TAO\n', '\t * @param _nameTAOVaultAddress The address of NameTAOVault\n', '\t */\n', '\tfunction deployTAO(string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _nameTAOVaultAddress\n', '\t\t) public returns (TAO _tao) {\n', '\t\t_tao = new TAO(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev deploy a Name\n', '\t * @param _name The name of the Name\n', '\t * @param _originId The eth address the creates the Name\n', '\t * @param _datHash The datHash of this Name\n', '\t * @param _database The database for this Name\n', '\t * @param _keyValue The key/value pair to be checked on the database\n', '\t * @param _contentId The contentId related to this Name\n', '\t * @param _nameTAOVaultAddress The address of NameTAOVault\n', '\t */\n', '\tfunction deployName(string memory _name,\n', '\t\taddress _originId,\n', '\t\tstring memory _datHash,\n', '\t\tstring memory _database,\n', '\t\tstring memory _keyValue,\n', '\t\tbytes32 _contentId,\n', '\t\taddress _nameTAOVaultAddress\n', '\t\t) public returns (Name _myName) {\n', '\t\t_myName = new Name(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\n', "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", "\t * @param _currentPrimordialBalance Account's current primordial ion balance\n", '\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\n', '\t * @param _additionalPrimordialAmount The primordial ion amount to be added\n', '\t * @return the new primordial weighted multiplier\n', '\t */\n', '\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\n', '\t\tif (_currentWeightedMultiplier > 0) {\n', '\t\t\tuint256 _totalWeightedIons = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\n', '\t\t\tuint256 _totalIons = _currentPrimordialBalance.add(_additionalPrimordialAmount);\n', '\t\t\treturn _totalWeightedIons.div(_totalIons);\n', '\t\t} else {\n', '\t\t\treturn _additionalWeightedMultiplier;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the primordial ion multiplier on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Multiplier = S\n', '\t *\t\tEnding Multiplier = E\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion mintable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\n', '\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\n', '\t * @return The multiplier in (10 ** 6)\n', '\t */\n', '\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\n', '\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\n', '\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\n', '\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\n', '\t\t\t */\n', '\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\n', '\t\t\t/**\n', '\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\n', '\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\n', '\t\t\t */\n', '\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus percentage of network ion on a given lot\n', '\t *\t\tTotal Primordial Mintable = T\n', '\t *\t\tTotal Primordial Minted = M\n', '\t *\t\tStarting Network Bonus Multiplier = Bs\n', '\t *\t\tEnding Network Bonus Multiplier = Be\n', '\t *\t\tTo Purchase = P\n', '\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion intable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting Network ion bonus multiplier\n', '\t * @param _endingMultiplier The ending Network ion bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\n', '\t\t\t/**\n', '\t\t\t * Let temp = M + (P/2)\n', '\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\n', '\t\t\t */\n', '\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\n', '\n', '\t\t\t/**\n', '\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\n', '\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\n', '\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\n', '\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\n', '\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\n', '\t\t\t */\n', '\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\n', '\t\t\treturn bonusPercentage;\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the bonus amount of network ion on a given lot\n', '\t *\t\tAO Bonus Amount = B% x P\n', '\t *\n', '\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\n', '\t * @param _totalPrimordialMintable Total Primordial ion intable\n', '\t * @param _totalPrimordialMinted Total Primordial ion minted so far\n', '\t * @param _startingMultiplier The starting Network ion bonus multiplier\n', '\t * @param _endingMultiplier The ending Network ion bonus multiplier\n', '\t * @return The bonus percentage\n', '\t */\n', '\tfunction calculateNetworkBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\n', '\t\tuint256 bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\n', '\t\t/**\n', '\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\n', '\t\t * when calculating the network ion bonus amount\n', '\t\t */\n', '\t\tuint256 networkBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\n', '\t\treturn networkBonus;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the maximum amount of Primordial an account can burn\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_maximumMultiplier = S\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\tB = ((S x P) - (P x M)) / S\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _maximumMultiplier The maximum multiplier of this account\n', '\t * @return The maximum burn amount\n', '\t */\n', '\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\n', '\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after burning primordial ion\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToBurn = B\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P - B)\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _amountToBurn The amount of primordial ion to burn\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculate the new multiplier after converting network ion to primordial ion\n', '\t *\t\t_primordialBalance = P\n', '\t *\t\t_currentWeightedMultiplier = M\n', '\t *\t\t_amountToConvert = C\n', '\t *\t\t_newMultiplier = E\n', '\t *\t\tE = (P x M) / (P + C)\n', '\t *\n', "\t * @param _primordialBalance Account's primordial ion balance\n", "\t * @param _currentWeightedMultiplier Account's current weighted multiplier\n", '\t * @param _amountToConvert The amount of network ion to convert\n', '\t * @return The new multiplier\n', '\t */\n', '\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\n', '\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev count num of digits\n', '\t * @param number uint256 of the nuumber to be checked\n', '\t * @return uint8 num of digits\n', '\t */\n', '\tfunction numDigits(uint256 number) public pure returns (uint8) {\n', '\t\tuint8 digits = 0;\n', '\t\twhile(number != 0) {\n', '\t\t\tnumber = number.div(10);\n', '\t\t\tdigits++;\n', '\t\t}\n', '\t\treturn digits;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAOController\n', ' */\n', 'contract TAOController is TheAO {\n', '\taddress public nameFactoryAddress;\n', '\taddress public nameAccountRecoveryAddress;\n', '\n', '\tINameFactory internal _nameFactory;\n', '\tINameTAOPosition internal _nameTAOPosition;\n', '\tINameAccountRecovery internal _nameAccountRecovery;\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress) public {\n', '\t\tsetNameFactoryAddress(_nameFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_id` is a Name or a TAO\n', '\t */\n', '\tmodifier isNameOrTAO(address _id) {\n', '\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check is msg.sender address is a Name\n', '\t */\n', '\t modifier senderIsName() {\n', '\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\n', '\t\t_;\n', '\t }\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of TAO ID\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Only allowed if sender's Name is not compromised\n", '\t */\n', '\tmodifier senderNameNotCompromised() {\n', '\t\trequire (!_nameAccountRecovery.isCompromised(_nameFactory.ethAddressToNameId(msg.sender)));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets NameFactory address\n', '\t * @param _nameFactoryAddress The address of NameFactory\n', '\t */\n', '\tfunction setNameFactoryAddress(address _nameFactoryAddress) public onlyTheAO {\n', '\t\trequire (_nameFactoryAddress != address(0));\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\t\t_nameFactory = INameFactory(_nameFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO sets NameTAOPosition address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = INameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameAccountRecovery Address\n', '\t * @param _nameAccountRecoveryAddress The address of NameAccountRecovery\n', '\t */\n', '\tfunction setNameAccountRecoveryAddress(address _nameAccountRecoveryAddress) public onlyTheAO {\n', '\t\trequire (_nameAccountRecoveryAddress != address(0));\n', '\t\tnameAccountRecoveryAddress = _nameAccountRecoveryAddress;\n', '\t\t_nameAccountRecovery = INameAccountRecovery(nameAccountRecoveryAddress);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TAOCurrency\n', ' */\n', 'contract TAOCurrency is TheAO {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// Public variables of the contract\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\n', '\t// To differentiate denomination of TAO Currency\n', '\tuint256 public powerOfTen;\n', '\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\t// address is the address of nameId, not the eth public address\n', '\tmapping (address => uint256) public balanceOf;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\t// address is the address of TAO/Name Id, not eth public address\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\t// address is the address of TAO/Name Id, not eth public address\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\t/**\n', '\t * Constructor function\n', '\t *\n', '\t * Initializes contract with initial supply TAOCurrency to the creator of the contract\n', '\t */\n', '\tconstructor (string memory _name, string memory _symbol, address _nameTAOPositionAddress) public {\n', '\t\tname = _name;\t\t// Set the name for display purposes\n', '\t\tsymbol = _symbol;\t// Set the symbol for display purposes\n', '\n', '\t\tpowerOfTen = 0;\n', '\t\tdecimals = 0;\n', '\n', '\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks if the calling contract address is The AO\n', '\t *\t\tOR\n', '\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\n', '\t */\n', '\tmodifier onlyTheAO {\n', '\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_id` is a Name or a TAO\n', '\t */\n', '\tmodifier isNameOrTAO(address _id) {\n', '\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev Transfer ownership of The AO to new address\n', '\t * @param _theAO The new address to be transferred\n', '\t */\n', '\tfunction transferOwnership(address _theAO) public onlyTheAO {\n', '\t\trequire (_theAO != address(0));\n', '\t\ttheAO = _theAO;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Whitelist `_account` address to transact on behalf of others\n', '\t * @param _account The address to whitelist\n', '\t * @param _whitelist Either to whitelist or not\n', '\t */\n', '\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\n', '\t\trequire (_account != address(0));\n', '\t\twhitelist[_account] = _whitelist;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev transfer TAOCurrency from other address\n', '\t *\n', '\t * Send `_value` TAOCurrency to `_to` in behalf of `_from`\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to send\n', '\t */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public inWhitelist isNameOrTAO(_from) isNameOrTAO(_to) returns (bool) {\n', '\t\t_transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\n', '\t * @param target Address to receive TAOCurrency\n', '\t * @param mintedAmount The amount of TAOCurrency it will receive\n', '\t * @return true on success\n', '\t */\n', '\tfunction mint(address target, uint256 mintedAmount) public inWhitelist isNameOrTAO(target) returns (bool) {\n', '\t\t_mint(target, mintedAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t *\n', '\t * @dev Whitelisted address remove `_value` TAOCurrency from the system irreversibly on behalf of `_from`.\n', '\t *\n', '\t * @param _from the address of the sender\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist isNameOrTAO(_from) returns (bool success) {\n', '\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\n', '\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\n', '\t\temit Burn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/***** INTERNAL METHODS *****/\n', '\t/**\n', '\t * @dev Send `_value` TAOCurrency from `_from` to `_to`\n', '\t * @param _from The address of sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value The amount to send\n', '\t */\n', '\tfunction _transfer(address _from, address _to, uint256 _value) internal {\n', '\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n', '\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\n', '\t * @param target Address to receive TAOCurrency\n', '\t * @param mintedAmount The amount of TAOCurrency it will receive\n', '\t */\n', '\tfunction _mint(address target, uint256 mintedAmount) internal {\n', '\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\n', '\t\ttotalSupply = totalSupply.add(mintedAmount);\n', '\t\temit Transfer(address(0), address(this), mintedAmount);\n', '\t\temit Transfer(address(this), target, mintedAmount);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Logos is TAOCurrency {\n', '\taddress public nameFactoryAddress;\n', '\taddress public nameAccountRecoveryAddress;\n', '\n', '\tINameFactory internal _nameFactory;\n', '\tINameTAOPosition internal _nameTAOPosition;\n', '\tINameAccountRecovery internal _nameAccountRecovery;\n', '\n', '\t// Mapping of a Name ID to the amount of Logos positioned by others to itself\n', '\t// address is the address of nameId, not the eth public address\n', '\tmapping (address => uint256) public positionFromOthers;\n', '\n', '\t// Mapping of Name ID to other Name ID and the amount of Logos positioned by itself\n', '\tmapping (address => mapping(address => uint256)) public positionOnOthers;\n', '\n', '\t// Mapping of a Name ID to the total amount of Logos positioned by itself on others\n', '\tmapping (address => uint256) public totalPositionOnOthers;\n', '\n', "\t// Mapping of Name ID to it's advocated TAO ID and the amount of Logos earned\n", '\tmapping (address => mapping(address => uint256)) public advocatedTAOLogos;\n', '\n', '\t// Mapping of a Name ID to the total amount of Logos earned from advocated TAO\n', '\tmapping (address => uint256) public totalAdvocatedTAOLogos;\n', '\n', '\t// Event broadcasted to public when `from` address position `value` Logos to `to`\n', '\tevent PositionFrom(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// Event broadcasted to public when `from` address unposition `value` Logos from `to`\n', '\tevent UnpositionFrom(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// Event broadcasted to public when `nameId` receives `amount` of Logos from advocating `taoId`\n', '\tevent AddAdvocatedTAOLogos(address indexed nameId, address indexed taoId, uint256 amount);\n', '\n', '\t// Event broadcasted to public when Logos from advocating `taoId` is transferred from `fromNameId` to `toNameId`\n', '\tevent TransferAdvocatedTAOLogos(address indexed fromNameId, address indexed toNameId, address indexed taoId, uint256 amount);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(string memory _name, string memory _symbol, address _nameFactoryAddress, address _nameTAOPositionAddress)\n', '\t\tTAOCurrency(_name, _symbol, _nameTAOPositionAddress) public {\n', '\t\tsetNameFactoryAddress(_nameFactoryAddress);\n', '\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_taoId` is a TAO\n', '\t */\n', '\tmodifier isTAO(address _taoId) {\n', '\t\trequire (AOLibrary.isTAO(_taoId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if `_nameId` is a Name\n', '\t */\n', '\tmodifier isName(address _nameId) {\n', '\t\trequire (AOLibrary.isName(_nameId));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if msg.sender is the current advocate of _id\n', '\t */\n', '\tmodifier onlyAdvocate(address _id) {\n', '\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Only allowed if Name is not compromised\n', '\t */\n', '\tmodifier nameNotCompromised(address _id) {\n', '\t\trequire (!_nameAccountRecovery.isCompromised(_id));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Only allowed if sender's Name is not compromised\n", '\t */\n', '\tmodifier senderNameNotCompromised() {\n', '\t\trequire (!_nameAccountRecovery.isCompromised(_nameFactory.ethAddressToNameId(msg.sender)));\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** THE AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO sets NameFactory address\n', '\t * @param _nameFactoryAddress The address of NameFactory\n', '\t */\n', '\tfunction setNameFactoryAddress(address _nameFactoryAddress) public onlyTheAO {\n', '\t\trequire (_nameFactoryAddress != address(0));\n', '\t\tnameFactoryAddress = _nameFactoryAddress;\n', '\t\t_nameFactory = INameFactory(_nameFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameTAOPosition Address\n', '\t * @param _nameTAOPositionAddress The address of NameTAOPosition\n', '\t */\n', '\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\n', '\t\trequire (_nameTAOPositionAddress != address(0));\n', '\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\n', '\t\t_nameTAOPosition = INameTAOPosition(_nameTAOPositionAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the NameAccountRecovery Address\n', '\t * @param _nameAccountRecoveryAddress The address of NameAccountRecovery\n', '\t */\n', '\tfunction setNameAccountRecoveryAddress(address _nameAccountRecoveryAddress) public onlyTheAO {\n', '\t\trequire (_nameAccountRecoveryAddress != address(0));\n', '\t\tnameAccountRecoveryAddress = _nameAccountRecoveryAddress;\n', '\t\t_nameAccountRecovery = INameAccountRecovery(nameAccountRecoveryAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Get the total sum of Logos for an address\n', '\t * @param _target The address to check\n', '\t * @return The total sum of Logos (own + positioned + advocated TAOs)\n', '\t */\n', '\tfunction sumBalanceOf(address _target) public isName(_target) view returns (uint256) {\n', '\t\treturn balanceOf[_target].add(positionFromOthers[_target]).add(totalAdvocatedTAOLogos[_target]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the amount of Logos that are available to be positioned on other\n', '\t * @param _sender The sender address to check\n', '\t * @return The amount of Logos that are available to be positioned on other\n', '\t */\n', '\tfunction availableToPositionAmount(address _sender) public isName(_sender) view returns (uint256) {\n', '\t\treturn balanceOf[_sender].sub(totalPositionOnOthers[_sender]);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev `_from` Name position `_value` Logos onto `_to` Name\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to position\n', '\t * @return true on success\n', '\t */\n', '\tfunction positionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) nameNotCompromised(_from) nameNotCompromised(_to) onlyAdvocate(_from) senderNameNotCompromised returns (bool) {\n', "\t\trequire (_from != _to);\t// Can't position Logos to itself\n", '\t\trequire (availableToPositionAmount(_from) >= _value); // should have enough balance to position\n', '\t\trequire (positionFromOthers[_to].add(_value) >= positionFromOthers[_to]); // check for overflows\n', '\n', '\t\tpositionOnOthers[_from][_to] = positionOnOthers[_from][_to].add(_value);\n', '\t\ttotalPositionOnOthers[_from] = totalPositionOnOthers[_from].add(_value);\n', '\t\tpositionFromOthers[_to] = positionFromOthers[_to].add(_value);\n', '\n', '\t\temit PositionFrom(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev `_from` Name unposition `_value` Logos from `_to` Name\n', '\t *\n', '\t * @param _from The address of the sender\n', '\t * @param _to The address of the recipient\n', '\t * @param _value the amount to unposition\n', '\t * @return true on success\n', '\t */\n', '\tfunction unpositionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) nameNotCompromised(_from) nameNotCompromised(_to) onlyAdvocate(_from) senderNameNotCompromised returns (bool) {\n', "\t\trequire (_from != _to);\t// Can't unposition Logos to itself\n", '\t\trequire (positionOnOthers[_from][_to] >= _value);\n', '\n', '\t\tpositionOnOthers[_from][_to] = positionOnOthers[_from][_to].sub(_value);\n', '\t\ttotalPositionOnOthers[_from] = totalPositionOnOthers[_from].sub(_value);\n', '\t\tpositionFromOthers[_to] = positionFromOthers[_to].sub(_value);\n', '\n', '\t\temit UnpositionFrom(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Add `_amount` logos earned from advocating a TAO `_taoId` to its Advocate\n', '\t * @param _taoId The ID of the advocated TAO\n', '\t * @param _amount the amount to reward\n', '\t * @return true on success\n', '\t */\n', '\tfunction addAdvocatedTAOLogos(address _taoId, uint256 _amount) public inWhitelist isTAO(_taoId) returns (bool) {\n', '\t\trequire (_amount > 0);\n', '\t\taddress _nameId = _nameTAOPosition.getAdvocate(_taoId);\n', '\n', '\t\tadvocatedTAOLogos[_nameId][_taoId] = advocatedTAOLogos[_nameId][_taoId].add(_amount);\n', '\t\ttotalAdvocatedTAOLogos[_nameId] = totalAdvocatedTAOLogos[_nameId].add(_amount);\n', '\n', '\t\temit AddAdvocatedTAOLogos(_nameId, _taoId, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer logos earned from advocating a TAO `_taoId` from `_fromNameId` to the Advocate of `_taoId`\n', '\t * @param _fromNameId The ID of the Name that sends the Logos\n', '\t * @param _taoId The ID of the advocated TAO\n', '\t * @return true on success\n', '\t */\n', '\tfunction transferAdvocatedTAOLogos(address _fromNameId, address _taoId) public inWhitelist isName(_fromNameId) isTAO(_taoId) returns (bool) {\n', '\t\taddress _toNameId = _nameTAOPosition.getAdvocate(_taoId);\n', '\t\trequire (_fromNameId != _toNameId);\n', '\t\trequire (totalAdvocatedTAOLogos[_fromNameId] >= advocatedTAOLogos[_fromNameId][_taoId]);\n', '\n', '\t\tuint256 _amount = advocatedTAOLogos[_fromNameId][_taoId];\n', '\t\tadvocatedTAOLogos[_fromNameId][_taoId] = 0;\n', '\t\ttotalAdvocatedTAOLogos[_fromNameId] = totalAdvocatedTAOLogos[_fromNameId].sub(_amount);\n', '\t\tadvocatedTAOLogos[_toNameId][_taoId] = advocatedTAOLogos[_toNameId][_taoId].add(_amount);\n', '\t\ttotalAdvocatedTAOLogos[_toNameId] = totalAdvocatedTAOLogos[_toNameId].add(_amount);\n', '\n', '\t\temit TransferAdvocatedTAOLogos(_fromNameId, _toNameId, _taoId, _amount);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title TAOPool\n', ' *\n', ' * This contract acts as the bookkeeper of TAO Currencies that are staked on TAO\n', ' */\n', 'contract TAOPool is TAOController, ITAOPool {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public taoFactoryAddress;\n', '\taddress public pathosAddress;\n', '\taddress public ethosAddress;\n', '\taddress public logosAddress;\n', '\n', '\tITAOFactory internal _taoFactory;\n', '\tTAOCurrency internal _pathos;\n', '\tTAOCurrency internal _ethos;\n', '\tLogos internal _logos;\n', '\n', '\tstruct Pool {\n', '\t\taddress taoId;\n', '\t\t/**\n', '\t\t * If true, has ethos cap. Otherwise, no ethos cap.\n', '\t\t */\n', '\t\tbool ethosCapStatus;\n', '\t\tuint256 ethosCapAmount;\t// Creates a cap for the amount of Ethos that can be staked into this pool\n', '\n', '\t\t/**\n', '\t\t * If true, Pool is live and can be staked into.\n', '\t\t */\n', '\t\tbool status;\n', '\t}\n', '\n', '\tstruct EthosLot {\n', '\t\tbytes32 ethosLotId;\t\t\t\t\t// The ID of this Lot\n', '\t\taddress nameId;\t\t\t\t\t\t// The ID of the Name that staked Ethos\n', '\t\tuint256 lotQuantity;\t\t\t\t// Amount of Ethos being staked to the Pool from this Lot\n', '\t\taddress taoId;\t\t\t\t\t\t// Identifier for the Pool this Lot is adding to\n', '\t\tuint256 poolPreStakeSnapshot;\t\t// Amount of Ethos contributed to the Pool prior to this Lot Number\n', '\t\tuint256 poolStakeLotSnapshot;\t\t// poolPreStakeSnapshot + lotQuantity\n', '\t\tuint256 lotValueInLogos;\n', '\t\tuint256 logosWithdrawn;\t\t\t\t// Amount of Logos withdrawn from this Lot\n', '\t\tuint256 timestamp;\n', '\t}\n', '\n', '\tuint256 public contractTotalEthosLot;\t\t// Total Ethos lot from all pools\n', '\tuint256 public contractTotalPathosStake;\t// Total Pathos stake from all pools (how many Pathos stakes are there in contract)\n', '\tuint256 public contractTotalEthos;\t\t\t// Quantity of Ethos that has been staked to all Pools\n', '\tuint256 public contractTotalPathos;\t\t\t// Quantity of Pathos that has been staked to all Pools\n', '\tuint256 public contractTotalLogosWithdrawn;\t\t// Quantity of Logos that has been withdrawn from all Pools\n', '\n', '\t// Mapping from TAO ID to Pool\n', '\tmapping (address => Pool) public pools;\n', '\n', '\t// Mapping from Ethos Lot ID to Ethos Lot\n', '\tmapping (bytes32 => EthosLot) public ethosLots;\n', '\n', "\t// Mapping from Pool's TAO ID to total Ethos Lots in the Pool\n", '\tmapping (address => uint256) public poolTotalEthosLot;\n', '\n', "\t// Mapping from Pool's TAO ID to quantity of Logos that has been withdrawn from the Pool\n", '\tmapping (address => uint256) public poolTotalLogosWithdrawn;\n', '\n', '\t// Mapping from a Name ID to its Ethos Lots\n', '\tmapping (address => bytes32[]) internal ownerEthosLots;\n', '\n', '\t// Mapping from a Name ID to quantity of Ethos staked from all Ethos lots\n', '\tmapping (address => uint256) public totalEthosStaked;\n', '\n', '\t// Mapping from a Name ID to quantity of Pathos staked from all Ethos lots\n', '\tmapping (address => uint256) public totalPathosStaked;\n', '\n', '\t// Mapping from a Name ID to total Logos withdrawn from all Ethos lots\n', '\tmapping (address => uint256) public totalLogosWithdrawn;\n', '\n', '\t// Mapping from a Name ID to quantity of Ethos staked from all Ethos lots on a Pool\n', '\tmapping (address => mapping (address => uint256)) public namePoolEthosStaked;\n', '\n', '\t// Mapping from a Name ID to quantity of Pathos staked on a Pool\n', '\tmapping (address => mapping (address => uint256)) public namePoolPathosStaked;\n', '\n', '\t// Mapping from a Name ID to quantity of Logos withdrawn from a Pool\n', '\tmapping (address => mapping (address => uint256)) public namePoolLogosWithdrawn;\n', '\n', '\t// Event to be broadcasted to public when Pool is created\n', '\tevent CreatePool(address indexed taoId, bool ethosCapStatus, uint256 ethosCapAmount, bool status);\n', '\n', "\t// Event to be broadcasted to public when Pool's status is updated\n", '\t// If status == true, start Pool\n', '\t// Otherwise, stop Pool\n', '\tevent UpdatePoolStatus(address indexed taoId, bool status, uint256 nonce);\n', '\n', "\t// Event to be broadcasted to public when Pool's Ethos cap is updated\n", '\tevent UpdatePoolEthosCap(address indexed taoId, bool ethosCapStatus, uint256 ethosCapAmount, uint256 nonce);\n', '\n', '\t/**\n', '\t * Event to be broadcasted to public when nameId stakes Ethos\n', '\t */\n', '\tevent StakeEthos(address indexed taoId, bytes32 indexed ethosLotId, address indexed nameId, uint256 lotQuantity, uint256 poolPreStakeSnapshot, uint256 poolStakeLotSnapshot, uint256 lotValueInLogos, uint256 timestamp);\n', '\n', '\t// Event to be broadcasted to public when nameId stakes Pathos\n', '\tevent StakePathos(address indexed taoId, bytes32 indexed stakeId, address indexed nameId, uint256 stakeQuantity, uint256 currentPoolTotalStakedPathos, uint256 timestamp);\n', '\n', '\t// Event to be broadcasted to public when nameId withdraws Logos from Ethos Lot\n', '\tevent WithdrawLogos(address indexed nameId, bytes32 indexed ethosLotId, address indexed taoId, uint256 withdrawnAmount, uint256 currentLotValueInLogos, uint256 currentLotLogosWithdrawn, uint256 timestamp);\n', '\n', '\t/**\n', '\t * @dev Constructor function\n', '\t */\n', '\tconstructor(address _nameFactoryAddress, address _taoFactoryAddress, address _nameTAOPositionAddress, address _pathosAddress, address _ethosAddress, address _logosAddress)\n', '\t\tTAOController(_nameFactoryAddress) public {\n', '\t\tsetTAOFactoryAddress(_taoFactoryAddress);\n', '\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\n', '\t\tsetPathosAddress(_pathosAddress);\n', '\t\tsetEthosAddress(_ethosAddress);\n', '\t\tsetLogosAddress(_logosAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Check if calling address is TAO Factory address\n', '\t */\n', '\tmodifier onlyTAOFactory {\n', '\t\trequire (msg.sender == taoFactoryAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\t/***** The AO ONLY METHODS *****/\n', '\t/**\n', '\t * @dev The AO set the TAOFactory Address\n', '\t * @param _taoFactoryAddress The address of TAOFactory\n', '\t */\n', '\tfunction setTAOFactoryAddress(address _taoFactoryAddress) public onlyTheAO {\n', '\t\trequire (_taoFactoryAddress != address(0));\n', '\t\ttaoFactoryAddress = _taoFactoryAddress;\n', '\t\t_taoFactory = ITAOFactory(_taoFactoryAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the Pathos Address\n', '\t * @param _pathosAddress The address of Pathos\n', '\t */\n', '\tfunction setPathosAddress(address _pathosAddress) public onlyTheAO {\n', '\t\trequire (_pathosAddress != address(0));\n', '\t\tpathosAddress = _pathosAddress;\n', '\t\t_pathos = TAOCurrency(_pathosAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the Ethos Address\n', '\t * @param _ethosAddress The address of Ethos\n', '\t */\n', '\tfunction setEthosAddress(address _ethosAddress) public onlyTheAO {\n', '\t\trequire (_ethosAddress != address(0));\n', '\t\tethosAddress = _ethosAddress;\n', '\t\t_ethos = TAOCurrency(_ethosAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev The AO set the Logos Address\n', '\t * @param _logosAddress The address of Logos\n', '\t */\n', '\tfunction setLogosAddress(address _logosAddress) public onlyTheAO {\n', '\t\trequire (_logosAddress != address(0));\n', '\t\tlogosAddress = _logosAddress;\n', '\t\t_logos = Logos(_logosAddress);\n', '\t}\n', '\n', '\t/***** PUBLIC METHODS *****/\n', '\t/**\n', '\t * @dev Check whether or not Pool exist for a TAO ID\n', '\t * @param _id The ID to be checked\n', '\t * @return true if yes, false otherwise\n', '\t */\n', '\tfunction isExist(address _id) public view returns (bool) {\n', '\t\treturn pools[_id].taoId != address(0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Create a pool for a TAO\n', '\t */\n', '\tfunction createPool(\n', '\t\taddress _taoId,\n', '\t\tbool _ethosCapStatus,\n', '\t\tuint256 _ethosCapAmount\n', '\t) external isTAO(_taoId) onlyTAOFactory returns (bool) {\n', '\t\t// Make sure ethos cap amount is provided if ethos cap is enabled\n', '\t\tif (_ethosCapStatus) {\n', '\t\t\trequire (_ethosCapAmount > 0);\n', '\t\t}\n', '\t\t// Make sure the pool is not yet created\n', '\t\trequire (pools[_taoId].taoId == address(0));\n', '\n', '\t\tPool storage _pool = pools[_taoId];\n', '\t\t_pool.taoId = _taoId;\n', '\t\t_pool.status = true;\n', '\t\t_pool.ethosCapStatus = _ethosCapStatus;\n', '\t\tif (_ethosCapStatus) {\n', '\t\t\t_pool.ethosCapAmount = _ethosCapAmount;\n', '\t\t}\n', '\n', '\t\temit CreatePool(_pool.taoId, _pool.ethosCapStatus, _pool.ethosCapAmount, _pool.status);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Start/Stop a Pool\n', '\t * @param _taoId The TAO ID of the Pool\n', '\t * @param _status The status to set. true = start. false = stop\n', '\t */\n', '\tfunction updatePoolStatus(address _taoId, bool _status) public isTAO(_taoId) onlyAdvocate(_taoId) senderNameNotCompromised {\n', '\t\trequire (pools[_taoId].taoId != address(0));\n', '\t\tpools[_taoId].status = _status;\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit UpdatePoolStatus(_taoId, _status, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Update Ethos cap of a Pool\n', '\t * @param _taoId The TAO ID of the Pool\n', '\t * @param _ethosCapStatus The ethos cap status to set\n', '\t * @param _ethosCapAmount The ethos cap amount to set\n', '\t */\n', '\tfunction updatePoolEthosCap(address _taoId, bool _ethosCapStatus, uint256 _ethosCapAmount) public isTAO(_taoId) onlyAdvocate(_taoId) senderNameNotCompromised {\n', '\t\trequire (pools[_taoId].taoId != address(0));\n', '\t\t// If there is an ethos cap\n', '\t\tif (_ethosCapStatus) {\n', '\t\t\trequire (_ethosCapAmount > 0 && _ethosCapAmount > _pathos.balanceOf(_taoId));\n', '\t\t}\n', '\n', '\t\tpools[_taoId].ethosCapStatus = _ethosCapStatus;\n', '\t\tif (_ethosCapStatus) {\n', '\t\t\tpools[_taoId].ethosCapAmount = _ethosCapAmount;\n', '\t\t}\n', '\n', '\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\n', '\t\trequire (_nonce > 0);\n', '\n', '\t\temit UpdatePoolEthosCap(_taoId, _ethosCapStatus, _ethosCapAmount, _nonce);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev A Name stakes Ethos in Pool `_taoId`\n', '\t * @param _taoId The TAO ID of the Pool\n', '\t * @param _quantity The amount of Ethos to be staked\n', '\t */\n', '\tfunction stakeEthos(address _taoId, uint256 _quantity) public isTAO(_taoId) senderIsName senderNameNotCompromised {\n', '\t\tPool memory _pool = pools[_taoId];\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_pool.status == true && _quantity > 0 && _ethos.balanceOf(_nameId) >= _quantity);\n', '\n', '\t\t// If there is an ethos cap\n', '\t\tif (_pool.ethosCapStatus) {\n', '\t\t\trequire (_ethos.balanceOf(_taoId).add(_quantity) <= _pool.ethosCapAmount);\n', '\t\t}\n', '\n', '\t\t// Create Ethos Lot for this transaction\n', '\t\tcontractTotalEthosLot++;\n', '\t\tpoolTotalEthosLot[_taoId]++;\n', '\n', '\t\t// Generate Ethos Lot ID\n', '\t\tbytes32 _ethosLotId = keccak256(abi.encodePacked(this, msg.sender, contractTotalEthosLot));\n', '\n', '\t\tEthosLot storage _ethosLot = ethosLots[_ethosLotId];\n', '\t\t_ethosLot.ethosLotId = _ethosLotId;\n', '\t\t_ethosLot.nameId = _nameId;\n', '\t\t_ethosLot.lotQuantity = _quantity;\n', '\t\t_ethosLot.taoId = _taoId;\n', '\t\t_ethosLot.poolPreStakeSnapshot = _ethos.balanceOf(_taoId);\n', '\t\t_ethosLot.poolStakeLotSnapshot = _ethos.balanceOf(_taoId).add(_quantity);\n', '\t\t_ethosLot.lotValueInLogos = _quantity;\n', '\t\t_ethosLot.timestamp = now;\n', '\n', '\t\townerEthosLots[_nameId].push(_ethosLotId);\n', '\n', '\t\t// Update contract variables\n', '\t\ttotalEthosStaked[_nameId] = totalEthosStaked[_nameId].add(_quantity);\n', '\t\tnamePoolEthosStaked[_nameId][_taoId] = namePoolEthosStaked[_nameId][_taoId].add(_quantity);\n', '\t\tcontractTotalEthos = contractTotalEthos.add(_quantity);\n', '\n', '\t\trequire (_ethos.transferFrom(_nameId, _taoId, _quantity));\n', '\n', '\t\temit StakeEthos(_ethosLot.taoId, _ethosLot.ethosLotId, _ethosLot.nameId, _ethosLot.lotQuantity, _ethosLot.poolPreStakeSnapshot, _ethosLot.poolStakeLotSnapshot, _ethosLot.lotValueInLogos, _ethosLot.timestamp);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Retrieve number of Ethos Lots a `_nameId` has\n', "\t * @param _nameId The Name ID of the Ethos Lot's owner\n", '\t * @return Total Ethos Lots the owner has\n', '\t */\n', '\tfunction ownerTotalEthosLot(address _nameId) public view returns (uint256) {\n', '\t\treturn ownerEthosLots[_nameId].length;\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Get list of owner's Ethos Lot IDs from `_from` to `_to` index\n", "\t * @param _nameId The Name Id of the Ethos Lot's owner\n", '\t * @param _from The starting index, (i.e 0)\n', '\t * @param _to The ending index, (i.e total - 1)\n', "\t * @return list of owner's Ethos Lot IDs\n", '\t */\n', '\tfunction ownerEthosLotIds(address _nameId, uint256 _from, uint256 _to) public view returns (bytes32[] memory) {\n', '\t\trequire (_from >= 0 && _to >= _from && ownerEthosLots[_nameId].length > _to);\n', '\t\tbytes32[] memory _ethosLotIds = new bytes32[](_to.sub(_from).add(1));\n', '\t\tfor (uint256 i = _from; i <= _to; i++) {\n', '\t\t\t_ethosLotIds[i.sub(_from)] = ownerEthosLots[_nameId][i];\n', '\t\t}\n', '\t\treturn _ethosLotIds;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Return the amount of Pathos that can be staked on Pool\n', '\t * @param _taoId The TAO ID of the Pool\n', '\t * @return The amount of Pathos that can be staked\n', '\t */\n', '\tfunction availablePathosToStake(address _taoId) public isTAO(_taoId) view returns (uint256) {\n', '\t\tif (pools[_taoId].status == true) {\n', '\t\t\treturn _ethos.balanceOf(_taoId).sub(_pathos.balanceOf(_taoId));\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev A Name stakes Pathos in Pool `_taoId`\n', '\t * @param _taoId The TAO ID of the Pool\n', '\t * @param _quantity The amount of Pathos to stake\n', '\t */\n', '\tfunction stakePathos(address _taoId, uint256 _quantity) public isTAO(_taoId) senderIsName senderNameNotCompromised {\n', '\t\tPool memory _pool = pools[_taoId];\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_pool.status == true && _quantity > 0 && _pathos.balanceOf(_nameId) >= _quantity && _quantity <= availablePathosToStake(_taoId));\n', '\n', '\t\t// Update contract variables\n', '\t\tcontractTotalPathosStake++;\n', '\t\ttotalPathosStaked[_nameId] = totalPathosStaked[_nameId].add(_quantity);\n', '\t\tnamePoolPathosStaked[_nameId][_taoId] = namePoolPathosStaked[_nameId][_taoId].add(_quantity);\n', '\t\tcontractTotalPathos = contractTotalPathos.add(_quantity);\n', '\n', '\t\t// Generate Pathos Stake ID\n', '\t\tbytes32 _stakeId = keccak256(abi.encodePacked(this, msg.sender, contractTotalPathosStake));\n', '\n', '\t\trequire (_pathos.transferFrom(_nameId, _taoId, _quantity));\n', '\n', '\t\t// Also add advocated TAO logos to Advocate of _taoId\n', '\t\trequire (_logos.addAdvocatedTAOLogos(_taoId, _quantity));\n', '\n', '\t\temit StakePathos(_taoId, _stakeId, _nameId, _quantity, _pathos.balanceOf(_taoId), now);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Name that staked Ethos withdraw Logos from Ethos Lot `_ethosLotId`\n', '\t * @param _ethosLotId The ID of the Ethos Lot\n', '\t */\n', '\tfunction withdrawLogos(bytes32 _ethosLotId) public senderIsName senderNameNotCompromised {\n', '\t\tEthosLot storage _ethosLot = ethosLots[_ethosLotId];\n', '\t\taddress _nameId = _nameFactory.ethAddressToNameId(msg.sender);\n', '\t\trequire (_ethosLot.nameId == _nameId && _ethosLot.lotValueInLogos > 0);\n', '\n', '\t\tuint256 logosAvailableToWithdraw = lotLogosAvailableToWithdraw(_ethosLotId);\n', '\n', '\t\trequire (logosAvailableToWithdraw > 0 && logosAvailableToWithdraw <= _ethosLot.lotValueInLogos);\n', '\n', '\t\t// Update lot variables\n', '\t\t_ethosLot.logosWithdrawn = _ethosLot.logosWithdrawn.add(logosAvailableToWithdraw);\n', '\t\t_ethosLot.lotValueInLogos = _ethosLot.lotValueInLogos.sub(logosAvailableToWithdraw);\n', '\n', '\t\t// Update contract variables\n', '\t\tcontractTotalLogosWithdrawn = contractTotalLogosWithdrawn.add(logosAvailableToWithdraw);\n', '\t\tpoolTotalLogosWithdrawn[_ethosLot.taoId] = poolTotalLogosWithdrawn[_ethosLot.taoId].add(logosAvailableToWithdraw);\n', '\t\ttotalLogosWithdrawn[_ethosLot.nameId] = totalLogosWithdrawn[_ethosLot.nameId].add(logosAvailableToWithdraw);\n', '\t\tnamePoolLogosWithdrawn[_ethosLot.nameId][_ethosLot.taoId] = namePoolLogosWithdrawn[_ethosLot.nameId][_ethosLot.taoId].add(logosAvailableToWithdraw);\n', '\n', '\t\t// Mint logos to seller\n', '\t\trequire (_logos.mint(_nameId, logosAvailableToWithdraw));\n', '\n', '\t\temit WithdrawLogos(_ethosLot.nameId, _ethosLot.ethosLotId, _ethosLot.taoId, logosAvailableToWithdraw, _ethosLot.lotValueInLogos, _ethosLot.logosWithdrawn, now);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Name gets Ethos Lot `_ethosLotId` available Logos to withdraw\n', '\t * @param _ethosLotId The ID of the Ethos Lot\n', '\t * @return The amount of Logos available to withdraw\n', '\t */\n', '\tfunction lotLogosAvailableToWithdraw(bytes32 _ethosLotId) public view returns (uint256) {\n', '\t\tEthosLot memory _ethosLot = ethosLots[_ethosLotId];\n', '\t\trequire (_ethosLot.nameId != address(0));\n', '\n', '\t\tuint256 logosAvailableToWithdraw = 0;\n', '\n', '\t\tif (_pathos.balanceOf(_ethosLot.taoId) > _ethosLot.poolPreStakeSnapshot && _ethosLot.lotValueInLogos > 0) {\n', '\t\t\tlogosAvailableToWithdraw = (_pathos.balanceOf(_ethosLot.taoId) >= _ethosLot.poolStakeLotSnapshot) ? _ethosLot.lotQuantity : _pathos.balanceOf(_ethosLot.taoId).sub(_ethosLot.poolPreStakeSnapshot);\n', '\t\t\tif (logosAvailableToWithdraw > 0) {\n', '\t\t\t\tlogosAvailableToWithdraw = logosAvailableToWithdraw.sub(_ethosLot.logosWithdrawn);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn logosAvailableToWithdraw;\n', '\t}\n', '}']