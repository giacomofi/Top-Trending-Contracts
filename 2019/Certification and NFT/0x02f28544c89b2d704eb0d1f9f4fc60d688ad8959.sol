['pragma solidity ^0.5.8;\n', '// @notice SECURITY TOKEN CONTRACT\n', '// @dev ERC-1404 with ERC-20 with ERC223 protection Token Standard Compliant\n', '// @author Geoffrey Tipton at AEN\n', '// ----------------------------------------------------------------------------\n', '// Deployed by : Geoffrey Tipton\n', '// Symbol      : SMPT\n', '// Name        : Smart Pharma Token\n', '// Total supply: 1,000,000,000\n', '// Decimals    : 8\n', '//\n', '// (c) AENCOIN. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '// THE SMPT TOKENS HAVE NOT BEEN REGISTERED UNDER THE U.S. SECURITIES ACT OF\n', '// 1933, AS AMENDED (THE\u3000“SECURITIES ACT”).  THE SMPT TOKENS WERE ISSUED IN\n', '// A TRANSACTION EXEMPT FROM THE REGISTRATION REQUIREMENTS OF THE SECURITIES\n', '// ACT PURSUANT TO REGULATION S PROMULGATED UNDER IT.  THE SMPT TOKENS MAY NOT\n', '// BE OFFERED OR SOLD IN THE UNITED STATES UNLESS REGISTERED UNDER THE SECURITIES\n', '// ACT OR AN EXEMPTION FROM REGISTRATION IS AVAILABLE.  TRANSFERS OF THE SMPT\n', '// TOKENS MAY NOT BE MADE EXCEPT IN ACCORDANCE WITH THE PROVISIONS OF REGULATION S,\n', '// PURSUANT TO REGISTRATION UNDER THE SECURITIES ACT, OR PURSUANT TO AN AVAILABLE\n', '// EXEMPTION FROM REGISTRATION.  FURTHER, HEDGING TRANSACTIONS WITH REGARD TO THE\n', '// SMPT TOKENS MAY NOT BE CONDUCTED UNLESS IN COMPLIANCE WITH THE SECURITIES ACT.\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b; require(c >= a,"Can not add Negative Values"); }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a, "Result can not be negative"); c = a - b;  }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b; require(a == 0 || c / a == b,"Dived by Zero protection"); }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0,"Devide by Zero protection"); c = a / b; }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function allowance(address owner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint value) public returns (bool success);\n', '    function approve(address spender, uint value) public returns (bool success);\n', '    function transferFrom(address from, address to, uint value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC1404 is ERC20Interface {\n', '    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);\n', '    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string memory);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address internal newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public { //Only on contract creation\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Only the contract owner can execute this function");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract Managed is Owned {\n', '    mapping (address => bool) public managers;\n', '\n', '\n', '    modifier onlyManager () {\n', '        require(managers[msg.sender], "Only managers may perform this action");\n', '        _;\n', '    }\n', '\n', '    function addManager (address managerAddress) public onlyOwner {\n', '        managers[managerAddress] = true;\n', '    }\n', '\n', '    function removeManager (address managerAddress) external onlyOwner {\n', '        managers[managerAddress] = false;\n', '    }\n', '}\n', '\n', '/* ----------------------------------------------------------------------------\n', ' * Contract function to manage the white list\n', ' * Byte operation to control function of the whitelist,\n', ' * and prevent duplicate address entries. simple example\n', ' * whiteList[add] = 0000 = 0x00 = Not allowed to do either\n', ' * whiteList[add] = 0001 = 0x01 = Allowed to receive\n', ' * whiteList[add] = 0010 = 0x02 = Allowed to send\n', ' * whiteList[add] = 0011 = 0x03 = Allowed to Send and Receive\n', ' * whiteList[add] = 0100 = 0x04 = Frozen not allowed to do either\n', ' *----------------------------------------------------------------------------\n', ' */\n', 'contract Whitelist is Managed {\n', '    mapping(address => bytes1) public whiteList;\n', '    bytes1 internal listRule;\n', '    bytes1 internal constant WHITELISTED_CAN_RX_CODE = 0x01;  // binary for 0001\n', '    bytes1 internal constant WHITELISTED_CAN_TX_CODE = 0x02;  // binary for 0010\n', '    bytes1 internal constant WHITELISTED_FREEZE_CODE = 0x04;  // binary for 0100\n', '\n', '    function frozen(address _account) public view returns (bool){ //If account is flagged to freeze return true\n', '        return (WHITELISTED_FREEZE_CODE == (whiteList[_account] & WHITELISTED_FREEZE_CODE)); // 10 & 11 = True\n', '    }\n', '\n', '    function addToSendAllowed(address _to) external onlyManager {\n', '        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_TX_CODE; // just add the code 1\n', '    }\n', '\n', '    function addToReceiveAllowed(address _to) external onlyManager {\n', '        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_RX_CODE; // just add the code 2\n', '    }\n', '\n', '    function removeFromSendAllowed(address _to) public onlyManager {\n', '        if (WHITELISTED_CAN_TX_CODE == (whiteList[_to] & WHITELISTED_CAN_TX_CODE))  { //check code 4 so it does toggle when recalled\n', '            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_TX_CODE; // xor the code to remove the flag\n', '        }\n', '    }\n', '\n', '    function removeFromReceiveAllowed(address _to) public onlyManager {\n', '        if (WHITELISTED_CAN_RX_CODE == (whiteList[_to] & WHITELISTED_CAN_RX_CODE))  {\n', '            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_RX_CODE;\n', '        }\n', '    }\n', '\n', '    function removeFromBothSendAndReceiveAllowed (address _to) external onlyManager {\n', '        removeFromSendAllowed(_to);\n', '        removeFromReceiveAllowed(_to);\n', '    }\n', '\n', '    /*  this overides the individual whitelisting and manager positions so a\n', '        frozen account can not be unfrozen by a lower level manager\n', '    */\n', '    function freeze(address _to) external onlyOwner {\n', '        whiteList[_to] = whiteList[_to] | WHITELISTED_FREEZE_CODE; // 4 [0100]\n', '    }\n', '\n', '    function unFreeze(address _to) external onlyOwner {\n', '        if (WHITELISTED_FREEZE_CODE == (whiteList[_to] & WHITELISTED_FREEZE_CODE )) { //Already UnFrozen\n', '            whiteList[_to] = whiteList[_to] ^ WHITELISTED_FREEZE_CODE; // 4 [0100]\n', '        }\n', '    }\n', '\n', '    /*    WhitlistRule defines what the rules are for the white listing.\n', '          0x00 = No rule\n', '          0x01 = Receiver must be Listed\n', '          0x10 = Sender must be listed\n', '          0x11 = Both must be listed\n', '    */\n', '    function setWhitelistRule(byte _newRule) external onlyOwner {\n', '        listRule = _newRule;\n', '    }\n', '    function getWhitelistRule() external view returns (byte){\n', '        return listRule;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and an initial fixed supply\n', 'contract SPTToken is ERC1404, Owned, Whitelist {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '    uint8 internal restrictionCheck;\n', '\n', '    mapping(address => uint) public balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    constructor() public {\n', '        symbol = "SMPT";\n', '        name = "Smart Pharma Token";\n', '        decimals = 8;\n', '        _totalSupply = 100000000000000000;\n', '        balances[msg.sender] = _totalSupply;\n', '        managers[msg.sender] = true;\n', '        listRule = 0x00; //Receiver does not need to be whitelisted.\n', '        emit Transfer(address(0), msg.sender, _totalSupply);\n', '    }\n', '\n', '    modifier transferAllowed(address _from, address _to, uint256 _amount ) {\n', '        require(!frozen(_to) && !frozen(_from), "One of the Accounts are Frozen");  //If not frozen go check\n', '        if ((listRule & WHITELISTED_CAN_TX_CODE) != 0) { // if whitelist send rul applies then must be set\n', '            require(WHITELISTED_CAN_TX_CODE == (whiteList[_from] & WHITELISTED_CAN_TX_CODE), "Sending Account is not whitelisted"); // 10 & 11 = true\n', '        }\n', '        if ((listRule & WHITELISTED_CAN_RX_CODE) != 0) { //if whitelist to receive is required, then check,\n', '            require(WHITELISTED_CAN_RX_CODE == (whiteList[_to] & WHITELISTED_CAN_RX_CODE),"Receiving Account is not Whitelisted"); // 01 & 11 = True\n', '        }\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply minus any lost tokens to the zero address (Potential burn)\n', '    function totalSupply() external view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return balances[owner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // function transfer(address _to, uint _tokens)  public receiveAllowed(_to)  returns (bool success) {\n', '    function transfer(address _to, uint _value)  public transferAllowed(msg.sender, _to, _value) returns (bool) {\n', '        require((_to != address(0)) && (_to != address(this))); // Do not allow transfer to 0x0 or the token contract itself\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    function approve(address spender, uint value) public transferAllowed(msg.sender, spender, value) returns (bool) {\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    function transferFrom(address _from, address _to, uint _value) public transferAllowed(_from, _to, _value) returns (bool) {\n', '        // function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require((_to != address(0)) && (_to != address(this))); // Do not allow transfer to 0x0 or the token contract itself\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /* ------------------------------------------------------------------------\n', '     * Returns the amount of tokens approved by the owner that can be\n', "     * transferred to the spender's account\n", '    */\n', '    function allowance(address owner, address spender) public view returns (uint) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    /* ------------------------------------------------------------------------\n', "     * don't accept ETH\n", '     */\n', '    function () payable external {\n', '        revert();\n', '    }\n', '\n', '    /* ------------------------------------------------------------------------\n', '     * @This is a security over ride function that allows error correction.\n', '     * Owner can transfer out any accidentally sent tokens\n', '     * Call the contract address with the token address, which pretends to be the sender\n', '     * The receiving address is the caller of the contract.\n', '     */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    /* ------------------------------------------------------------------------\n', '     * The following functions are for 1404 interface compliance, to detect\n', '     * a transaction is allowed before sending, to save gas and obtain a clear Message\n', '    */\n', '    function detectTransferRestriction (address _from, address _to, uint256 _value) public view returns (uint8 restrictionCode)\n', '    {\n', '        restrictionCode = 0; // No restrictions\n', '        if ( WHITELISTED_CAN_TX_CODE == (listRule & WHITELISTED_CAN_TX_CODE) ) { //Can Send rule applies\n', '            if (!(WHITELISTED_CAN_TX_CODE == (whiteList[_to] & WHITELISTED_CAN_TX_CODE)) ) { //True if allowed to send\n', '                restrictionCode += 1; // Send is not allowed\n', '            }\n', '        }\n', '        if (WHITELISTED_CAN_RX_CODE == (listRule & WHITELISTED_CAN_RX_CODE)){ // Can Receive Rule applied\n', '            if (!(WHITELISTED_CAN_RX_CODE == (whiteList[_from] & WHITELISTED_CAN_RX_CODE))) {\n', '                restrictionCode += 2; // Receive is not allowed\n', '            }\n', '        }\n', '        if ((WHITELISTED_FREEZE_CODE == (whiteList[_from] & WHITELISTED_FREEZE_CODE)) ) { // Added to Frozen\n', '            restrictionCode += 4; // Sender is Frozen\n', '        }\n', '        if ((WHITELISTED_FREEZE_CODE == (whiteList[_to] & WHITELISTED_FREEZE_CODE)) ) { // Added to Frozen\n', '            restrictionCode += 8; // Receiver is Frozen\n', '        }\n', '\n', '        if (balanceOf(_from) < _value) {\n', '            restrictionCode += 16; // Send has insufficient balance\n', '        }\n', '\n', '        return restrictionCode;\n', '    }\n', '\n', '    /* ------------------------------------------------------------------------------------\n', '    * helper function to return a human readable message for the detectTransferRestriction\n', '    */\n', '    function messageForTransferRestriction (uint8 _restrictionCode) public view returns (string memory _message) {\n', '        _message = "Transfer Allowed";  // default and when is zero\n', '        if (_restrictionCode >= 16) {\n', '            _message = "Insufficient Balance to send";\n', '        } else if (_restrictionCode >= 8) {\n', '            _message = "To Account is Frozen, contact provider";\n', '        } else if (_restrictionCode >= 4) {\n', '            _message = "From Account is Frozen, contact provider";\n', '        } else if (_restrictionCode >= 3) {\n', '            _message = "Both Sending and receiving address has not been KYC Approved";\n', '        } else if (_restrictionCode >= 2) {\n', '            _message = "Receiving address has not been KYC Approved";\n', '        } else if (_restrictionCode >= 1) {\n', '            _message = "Sending address has not been KYC Approved";\n', '        }\n', '        return _message;\n', '    }\n', '}']