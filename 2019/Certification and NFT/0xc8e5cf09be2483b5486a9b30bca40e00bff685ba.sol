['pragma solidity ^0.5.0;\n', '\n', 'interface TeamInterface {\n', '\n', '    function isOwner() external view returns (bool);\n', '\n', '    function isAdmin(address _sender) external view returns (bool);\n', '\n', '    function isDev(address _sender) external view returns (bool);\n', '\n', '}\n', '\n', 'interface ArtistInterface {\n', '\n', '    function getAddress(bytes32 _artistID) external view returns (address payable);\n', '\n', '    function add(bytes32 _artistID, address _address) external;\n', '\n', '    function hasArtist(bytes32 _artistID) external view returns (bool);\n', '\n', '    function updateAddress(bytes32 _artistID, address _address) external;\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n', ' * - added sqrt\n', ' * - added sq\n', ' * - added pwr \n', ' * - changed asserts to requires with error log outputs\n', ' * - removed div, its useless\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library Datasets {\n', '\n', '    struct Player {\n', '        address[] ethAddress; \n', '        bytes32 referrer; \n', '        address payable lastAddress; \n', '        uint256 time;\n', '    }\n', '\n', '    struct MyWorks { \n', '        address ethAddress; \n', '        bytes32 worksID; \n', '        uint256 totalInput; \n', '        uint256 totalOutput; \n', '        uint256 time; \n', '    }\n', '\n', '\n', '    struct Works {\n', '        bytes32 worksID; \n', '        bytes32 artistID; \n', '        uint8 debrisNum; \n', '        uint256 price; \n', '        uint256 beginTime; \n', '        uint256 endTime;\n', '        bool isPublish; \n', '        bytes32 lastUnionID;\n', '    }\n', '\n', '    struct Debris {\n', '        uint8 debrisID; \n', '        bytes32 worksID; \n', '        uint256 initPrice; \n', '        uint256 lastPrice; \n', '        uint256 buyNum; \n', '        address payable firstBuyer; \n', '        address payable lastBuyer; \n', '        bytes32 firstUnionID; \n', '        bytes32 lastUnionID; \n', '        uint256 lastTime; \n', '    }\n', '    \n', '    struct Rule {       \n', '        uint8 firstBuyLimit; \n', '        uint256 freezeGap; \n', '        uint256 protectGap; \n', '        uint256 increaseRatio;\n', '        uint256 discountGap; \n', '        uint256 discountRatio; \n', '\n', '        uint8[3] firstAllot; \n', '        uint8[3] againAllot;\n', '        uint8[3] lastAllot; \n', '    }\n', '\n', '    struct PlayerCount {\n', '        uint256 lastTime; \n', '        uint256 firstBuyNum; \n', '        uint256 firstAmount; \n', '        uint256 secondAmount; \n', '        uint256 rewardAmount;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Works Contract\n', ' * @dev http://www.puzzlebid.com/\n', ' * @author PuzzleBID Game Team \n', ' * @dev Simon<<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fc8a8f958e858491bccdcacfd29f9391">[email&#160;protected]</a>>\n', ' */\n', 'contract Works {\n', '\n', '    using SafeMath for *;\n', '\n', '    TeamInterface private team; \n', '    ArtistInterface private artist; \n', '\n', '    constructor(address _teamAddress, address _artistAddress) public {\n', '        require(_teamAddress != address(0) && _artistAddress != address(0));\n', '        team = TeamInterface(_teamAddress);\n', '        artist = ArtistInterface(_artistAddress);\n', '    }\n', '\n', '    function() external payable {\n', '        revert();\n', '    }\n', '\n', '    event OnUpgrade(address indexed _teamAddress, address indexed _artistAddress);\n', '    event OnAddWorks(\n', '        bytes32 _worksID,\n', '        bytes32 _artistID, \n', '        uint8 _debrisNum, \n', '        uint256 _price, \n', '        uint256 _beginTime,\n', '        bool _isPublish\n', '    );\n', '    event OnInitDebris(\n', '        bytes32 _worksID,\n', '        uint8 _debrisNum,\n', '        uint256 _initPrice\n', '    );\n', '    event OnUpdateDebris(\n', '        bytes32 _worksID, \n', '        uint8 _debrisID, \n', '        bytes32 _unionID, \n', '        address indexed _sender\n', '    );\n', '    event OnUpdateFirstBuyer(\n', '        bytes32 _worksID, \n', '        uint8 _debrisID, \n', '        bytes32 _unionID, \n', '        address indexed _sender\n', '    );\n', '    event OnUpdateBuyNum(bytes32 _worksID, uint8 _debrisID);\n', '    event OnFinish(bytes32 _worksID, bytes32 _unionID, uint256 _time);\n', '    event OnUpdatePools(bytes32 _worksID, uint256 _value);\n', '    event OnUpdateFirstUnionIds(bytes32 _worksID, bytes32 _unionID);\n', '    event OnUpdateSecondUnionIds(bytes32 _worksID, bytes32 _unionID);\n', '\n', '    mapping(bytes32 => Datasets.Works) private works; \n', '    mapping(bytes32 => Datasets.Rule) private rules; \n', '    mapping(bytes32 => uint256) private pools; \n', '    mapping(bytes32 => mapping(uint8 => Datasets.Debris)) private debris; \n', '    mapping(bytes32 => bytes32[]) firstUnionID; \n', '    mapping(bytes32 => bytes32[]) secondUnionID; \n', '\n', '    modifier whenHasWorks(bytes32 _worksID) {\n', '        require(works[_worksID].beginTime != 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotHasWorks(bytes32 _worksID) {\n', '        require(works[_worksID].beginTime == 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenHasArtist(bytes32 _artistID) {\n', '        require(artist.hasArtist(_artistID));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(team.isAdmin(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyDev() {\n', '        require(team.isDev(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function upgrade(address _teamAddress, address _artistAddress) external onlyAdmin() {\n', '        require(_teamAddress != address(0) && _artistAddress != address(0));\n', '        team = TeamInterface(_teamAddress);\n', '        artist = ArtistInterface(_artistAddress);\n', '        emit OnUpgrade(_teamAddress, _artistAddress);\n', '    }\n', '\n', '    function addWorks(\n', '        bytes32 _worksID,\n', '        bytes32 _artistID, \n', '        uint8 _debrisNum, \n', '        uint256 _price, \n', '        uint256 _beginTime\n', '    ) \n', '        external \n', '        onlyAdmin()\n', '        whenNotHasWorks(_worksID)\n', '        whenHasArtist(_artistID)\n', '    {\n', '        require(\n', '            _debrisNum >= 2 && _debrisNum < 256 && \n', '            _price > 0 && _price % _debrisNum == 0 &&\n', '            _beginTime > 0 && _beginTime > now \n', '        ); \n', '\n', '        works[_worksID] = Datasets.Works(\n', '            _worksID, \n', '            _artistID, \n', '            _debrisNum, \n', '            _price.mul(1 wei),\n', '            _beginTime, \n', '            0,\n', '            false,\n', '            bytes32(0)\n', '        ); \n', '\n', '        emit OnAddWorks(\n', '            _worksID,\n', '            _artistID, \n', '            _debrisNum, \n', '            _price, \n', '            _beginTime,\n', '            false\n', '        ); \n', '\n', '        initDebris(_worksID, _price, _debrisNum);\n', '    }\n', '\n', '    function initDebris(bytes32 _worksID, uint256 _price, uint8 _debrisNum) private {      \n', '        uint256 initPrice = (_price / _debrisNum).mul(1 wei);\n', '        for(uint8 i=1; i<=_debrisNum; i++) {\n', '            debris[_worksID][i].worksID = _worksID;\n', '            debris[_worksID][i].initPrice = initPrice;\n', '        }\n', '        emit OnInitDebris(\n', '            _worksID,\n', '            _debrisNum,\n', '            initPrice\n', '        );\n', '    }\n', '\n', '    function configRule(\n', '        bytes32 _worksID,\n', '        uint8 _firstBuyLimit, \n', '        uint256 _freezeGap, \n', '        uint256 _protectGap,\n', '        uint256 _increaseRatio, \n', '        uint256 _discountGap,\n', '        uint256 _discountRatio,\n', '\n', '        uint8[3] calldata _firstAllot,\n', '        uint8[3] calldata _againAllot, \n', '        uint8[3] calldata _lastAllot\n', '    ) \n', '        external\n', '        onlyAdmin()\n', '        whenHasWorks(_worksID)\n', '    {\n', '\n', '        require(\n', '            _firstBuyLimit > 0 &&\n', '            _freezeGap > 0 &&\n', '            _protectGap > 0 &&\n', '            _increaseRatio > 0 && \n', '            _discountGap > 0 &&\n', '            _discountRatio > 0 &&\n', '            _discountGap > _protectGap\n', '        );\n', '\n', '        require(\n', '            _firstAllot[0] > 0 && _firstAllot[1] > 0 && _firstAllot[2] > 0 && \n', '            _againAllot[0] > 0 && _againAllot[1] > 0 && _againAllot[2] > 0 &&\n', '            _lastAllot[0] > 0 && _lastAllot[1] > 0 && _lastAllot[2] > 0\n', '        ); \n', '\n', '        rules[_worksID] = Datasets.Rule(\n', '            _firstBuyLimit,\n', '            _freezeGap.mul(1 seconds),\n', '            _protectGap.mul(1 seconds),\n', '            _increaseRatio,\n', '            _discountGap.mul(1 seconds),    \n', '            _discountRatio,\n', '            _firstAllot,\n', '            _againAllot,\n', '            _lastAllot\n', '        );\n', '    }\n', '\n', '    function publish(bytes32 _worksID, uint256 _beginTime) external onlyAdmin() {\n', '        require(works[_worksID].beginTime != 0 && works[_worksID].isPublish == false);\n', '        require(this.getAllot(_worksID, 0, 0) != 0);\n', '        if(_beginTime > 0) {\n', '            require(_beginTime > now);\n', '            works[_worksID].beginTime = _beginTime;\n', '        }\n', '        works[_worksID].isPublish = true;\n', '    }\n', '\n', '    function close(bytes32 _worksID) external onlyAdmin() {\n', '        works[_worksID].isPublish = false;\n', '    }\n', '\n', '    function getWorks(bytes32 _worksID) external view returns (uint8, uint256, uint256, uint256, bool) {\n', '        return (\n', '            works[_worksID].debrisNum,\n', '            works[_worksID].price,\n', '            works[_worksID].beginTime,\n', '            works[_worksID].endTime,\n', '            works[_worksID].isPublish\n', '        );\n', '    }\n', '\n', '    function getDebris(bytes32 _worksID, uint8 _debrisID) external view \n', '        returns (uint256, address, address, bytes32, bytes32, uint256) {\n', '        return (\n', '            debris[_worksID][_debrisID].buyNum,\n', '            debris[_worksID][_debrisID].firstBuyer,\n', '            debris[_worksID][_debrisID].lastBuyer,\n', '            debris[_worksID][_debrisID].firstUnionID,\n', '            debris[_worksID][_debrisID].lastUnionID,\n', '            debris[_worksID][_debrisID].lastTime\n', '        );\n', '    }\n', '\n', '    function getRule(bytes32 _worksID) external view \n', '        returns (uint256, uint256, uint256, uint8[3] memory, uint8[3] memory, uint8[3] memory) {\n', '        return (\n', '            rules[_worksID].increaseRatio,\n', '            rules[_worksID].discountGap,\n', '            rules[_worksID].discountRatio,\n', '            rules[_worksID].firstAllot,\n', '            rules[_worksID].againAllot,\n', '            rules[_worksID].lastAllot\n', '        );\n', '    }\n', '\n', '    function hasWorks(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].beginTime != 0;\n', '    }\n', '\n', '    function hasDebris(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        return _debrisID > 0 && _debrisID <= works[_worksID].debrisNum;\n', '    }\n', '\n', '    function isPublish(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].isPublish;\n', '    }\n', '\n', '    function isStart(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].beginTime <= now;\n', '    }\n', '\n', '    function isProtect(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        if(debris[_worksID][_debrisID].lastTime == 0) {\n', '            return false;\n', '        }\n', '        uint256 protectGap = rules[_worksID].protectGap;\n', '        return debris[_worksID][_debrisID].lastTime.add(protectGap) < now ? false : true;\n', '    }\n', '\n', '    function isSecond(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        return debris[_worksID][_debrisID].buyNum > 0;\n', '    }\n', '\n', '    function isGameOver(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].endTime != 0;\n', '    }\n', '\n', '    function isFinish(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        bool finish = true; \n', '        uint8 i = 1;\n', '        while(i <= works[_worksID].debrisNum) {\n', '            if(debris[_worksID][i].lastUnionID != _unionID) {\n', '                finish = false;\n', '                break;\n', '            }\n', '            i++;\n', '        }\n', '        return finish;\n', '    } \n', '\n', '    function hasFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        if(0 == firstUnionID[_worksID].length) {\n', '            return false;\n', '        }\n', '        bool has = false;\n', '        for(uint256 i=0; i<firstUnionID[_worksID].length; i++) {\n', '            if(firstUnionID[_worksID][i] == _unionID) {\n', '                has = true;\n', '                break;\n', '            }\n', '        }\n', '        return has;\n', '    }\n', '\n', '    function hasSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        if(0 == secondUnionID[_worksID].length) {\n', '            return false;\n', '        }\n', '        bool has = false;\n', '        for(uint256 i=0; i<secondUnionID[_worksID].length; i++) {\n', '            if(secondUnionID[_worksID][i] == _unionID) {\n', '                has = true;\n', '                break;\n', '            }\n', '        }\n', '        return has;\n', '    }  \n', '\n', '    function getFirstUnionIds(bytes32 _worksID) external view returns (bytes32[] memory) {\n', '        return firstUnionID[_worksID];\n', '    }\n', '\n', '    function getSecondUnionIds(bytes32 _worksID) external view returns (bytes32[] memory) {\n', '        return secondUnionID[_worksID];\n', '    }\n', '\n', '    function getPrice(bytes32 _worksID) external view returns (uint256) {\n', '        return works[_worksID].price;\n', '    }\n', '\n', '    function getDebrisPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {        \n', '        uint256 discountGap = rules[_worksID].discountGap;\n', '        uint256 discountRatio = rules[_worksID].discountRatio;\n', '        uint256 increaseRatio = rules[_worksID].increaseRatio;\n', '        uint256 lastPrice;\n', '\n', '        if(debris[_worksID][_debrisID].buyNum > 0 && debris[_worksID][_debrisID].lastTime.add(discountGap) < now) { \n', '\n', '            uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime.add(discountGap))) / discountGap; \n', '            if((now.sub(debris[_worksID][_debrisID].lastTime.add(discountGap))) % discountGap > 0) { \n', '                n = n.add(1);\n', '            }\n', '            for(uint256 i=0; i<n; i++) {\n', '                if(0 == i) {\n', '                    lastPrice = debris[_worksID][_debrisID].lastPrice.mul(increaseRatio).mul(discountRatio) / 10000; \n', '                } else {\n', '                    lastPrice = lastPrice.mul(discountRatio) / 100;\n', '                }\n', '            }\n', '\n', '        } else if (debris[_worksID][_debrisID].buyNum > 0) { \n', '            lastPrice = debris[_worksID][_debrisID].lastPrice.mul(increaseRatio) / 100;\n', '        } else {\n', '            lastPrice = debris[_worksID][_debrisID].initPrice; \n', '        }\n', '\n', '        return lastPrice;\n', '    }\n', '\n', '    function getDebrisStatus(bytes32 _worksID, uint8 _debrisID) external view returns (uint256[4] memory, uint256, uint256, bytes32)  {\n', '        uint256 gap = 0;\n', '        uint256 status = 0;\n', '\n', '        if(0 == debris[_worksID][_debrisID].buyNum) { \n', '\n', '        } else if(this.isProtect(_worksID, _debrisID)) { \n', '            gap = rules[_worksID].protectGap;\n', '            status = 1;\n', '        } else { \n', '\n', '            if(debris[_worksID][_debrisID].lastTime.add(rules[_worksID].discountGap) > now) {\n', '                gap = rules[_worksID].discountGap; \n', '            } else {\n', '                uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime)) / rules[_worksID].discountGap; \n', '                if((now.sub(debris[_worksID][_debrisID].lastTime.add(rules[_worksID].discountGap))) % rules[_worksID].discountGap > 0) { \n', '                    n = n.add(1);\n', '                }\n', '                gap = rules[_worksID].discountGap.mul(n); \n', '            }\n', '            status = 2;\n', '\n', '        }\n', '        uint256 price = this.getDebrisPrice(_worksID, _debrisID);\n', '        bytes32 lastUnionID = debris[_worksID][_debrisID].lastUnionID;\n', '        uint256[4] memory state = [status, debris[_worksID][_debrisID].lastTime, gap, now];\n', '        return (state, price, debris[_worksID][_debrisID].buyNum, lastUnionID);\n', '    }\n', '\n', '    function getInitPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        return debris[_worksID][_debrisID].initPrice;\n', '    }\n', '\n', '    function getLastPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        return debris[_worksID][_debrisID].lastPrice;\n', '    }\n', '\n', '    function getLastBuyer(bytes32 _worksID, uint8 _debrisID) external view returns(address) {\n', '        return debris[_worksID][_debrisID].lastBuyer;\n', '    }\n', '\n', '    function getLastUnionId(bytes32 _worksID, uint8 _debrisID) external view returns(bytes32) {\n', '        return debris[_worksID][_debrisID].lastUnionID;\n', '    }\n', '\n', '    function getFreezeGap(bytes32 _worksID) external view returns(uint256) {\n', '        return rules[_worksID].freezeGap;\n', '    }\n', '\n', '    function getFirstBuyLimit(bytes32 _worksID) external view returns(uint256) {\n', '        return rules[_worksID].firstBuyLimit;\n', '    }\n', '\n', '    function getArtistId(bytes32 _worksID) external view returns(bytes32) {\n', '        return works[_worksID].artistID;\n', '    }\n', '\n', '    function getDebrisNum(bytes32 _worksID) external view returns(uint8) {\n', '        return works[_worksID].debrisNum;\n', '    }\n', '\n', '    function getAllot(bytes32 _worksID, uint8 _flag) external view returns(uint8[3] memory) {\n', '        require(_flag < 3);\n', '        if(0 == _flag) {\n', '            return rules[_worksID].firstAllot;\n', '        } else if(1 == _flag) {\n', '            return rules[_worksID].againAllot;\n', '        } else {\n', '            return rules[_worksID].lastAllot;\n', '        }        \n', '    }\n', '\n', '    function getAllot(bytes32 _worksID, uint8 _flag, uint8 _element) external view returns(uint8) {\n', '        require(_flag < 3 && _element < 3);\n', '        if(0 == _flag) {\n', '            return rules[_worksID].firstAllot[_element];\n', '        } else if(1 == _flag) {\n', '            return rules[_worksID].againAllot[_element];\n', '        } else {\n', '            return rules[_worksID].lastAllot[_element];\n', '        }        \n', '    }\n', '\n', '    function getPools(bytes32 _worksID) external view returns (uint256) {\n', '        return pools[_worksID];\n', '    }\n', '\n', '    function getPoolsAllot(bytes32 _worksID) external view returns (uint256, uint256[3] memory, uint8[3] memory) {\n', '        require(works[_worksID].endTime != 0); \n', '\n', '        uint8[3] memory lastAllot = this.getAllot(_worksID, 2); \n', '        uint256 finishAccount = pools[_worksID].mul(lastAllot[0]) / 100; \n', '        uint256 firstAccount = pools[_worksID].mul(lastAllot[1]) / 100;\n', '        uint256 allAccount = pools[_worksID].mul(lastAllot[2]) / 100;\n', '        uint256[3] memory account = [finishAccount, firstAccount, allAccount];   \n', '\n', '        return (pools[_worksID], account, lastAllot);\n', '    }\n', '\n', '    function getStartHourglass(bytes32 _worksID) external view returns(uint256) {\n', '        if(works[_worksID].beginTime > 0 && works[_worksID].beginTime > now ) {\n', '            return works[_worksID].beginTime.sub(now);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getWorksStatus(bytes32 _worksID) external view returns (uint256, uint256, uint256, bytes32) {\n', '        return (works[_worksID].beginTime, works[_worksID].endTime, now, works[_worksID].lastUnionID);\n', '    }\n', '\n', '    function getProtectHourglass(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        if(\n', '            debris[_worksID][_debrisID].lastTime > 0 && \n', '            debris[_worksID][_debrisID].lastTime.add(rules[_worksID].protectGap) > now\n', '        ) {\n', '            return debris[_worksID][_debrisID].lastTime.add(rules[_worksID].protectGap).sub(now);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getDiscountHourglass(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        if(debris[_worksID][_debrisID].lastTime == 0) {\n', '            return 0;\n', '        }\n', '        uint256 discountGap = rules[_worksID].discountGap;\n', '        uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime)) / discountGap; \n', '        if((now.sub(debris[_worksID][_debrisID].lastTime)) % discountGap > 0) { \n', '            n = n.add(1);\n', '        }\n', '        return debris[_worksID][_debrisID].lastTime.add(discountGap.mul(n)).sub(now);\n', '    }\n', '\n', '    function updateDebris(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address payable _sender) external onlyDev() {\n', '        debris[_worksID][_debrisID].lastPrice = this.getDebrisPrice(_worksID, _debrisID);\n', '        debris[_worksID][_debrisID].lastUnionID = _unionID; \n', '        debris[_worksID][_debrisID].lastBuyer = _sender; \n', '        debris[_worksID][_debrisID].lastTime = now; \n', '        emit OnUpdateDebris(_worksID, _debrisID, _unionID, _sender);\n', '    }\n', '\n', '    function updateFirstBuyer(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address payable _sender) external onlyDev() {\n', '        debris[_worksID][_debrisID].firstBuyer = _sender;\n', '        debris[_worksID][_debrisID].firstUnionID = _unionID;\n', '        emit OnUpdateFirstBuyer(_worksID, _debrisID, _unionID, _sender);\n', '        this.updateFirstUnionIds(_worksID, _unionID);\n', '    }\n', '\n', '    function updateBuyNum(bytes32 _worksID, uint8 _debrisID) external onlyDev() {\n', '        debris[_worksID][_debrisID].buyNum = debris[_worksID][_debrisID].buyNum.add(1);\n', '        emit OnUpdateBuyNum(_worksID, _debrisID);\n', '    }\n', '\n', '    function finish(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        works[_worksID].endTime = now;\n', '        works[_worksID].lastUnionID = _unionID;\n', '        emit OnFinish(_worksID, _unionID, now);\n', '    }\n', '\n', '    function updatePools(bytes32 _worksID, uint256 _value) external onlyDev() {\n', '        pools[_worksID] = pools[_worksID].add(_value);\n', '        emit OnUpdatePools(_worksID, _value);\n', '    }\n', '\n', '    function updateFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        if(this.hasFirstUnionIds(_worksID, _unionID) == false) {\n', '            firstUnionID[_worksID].push(_unionID);\n', '            emit OnUpdateFirstUnionIds(_worksID, _unionID);\n', '        }\n', '    }\n', '\n', '    function updateSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        if(this.hasSecondUnionIds(_worksID, _unionID) == false) {\n', '            secondUnionID[_worksID].push(_unionID);\n', '            emit OnUpdateSecondUnionIds(_worksID, _unionID);\n', '        }\n', '    }\n', '\n', ' }']
['pragma solidity ^0.5.0;\n', '\n', 'interface TeamInterface {\n', '\n', '    function isOwner() external view returns (bool);\n', '\n', '    function isAdmin(address _sender) external view returns (bool);\n', '\n', '    function isDev(address _sender) external view returns (bool);\n', '\n', '}\n', '\n', 'interface ArtistInterface {\n', '\n', '    function getAddress(bytes32 _artistID) external view returns (address payable);\n', '\n', '    function add(bytes32 _artistID, address _address) external;\n', '\n', '    function hasArtist(bytes32 _artistID) external view returns (bool);\n', '\n', '    function updateAddress(bytes32 _artistID, address _address) external;\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n', ' * - added sqrt\n', ' * - added sq\n', ' * - added pwr \n', ' * - changed asserts to requires with error log outputs\n', ' * - removed div, its useless\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c) \n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y) \n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y) \n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '    \n', '    /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library Datasets {\n', '\n', '    struct Player {\n', '        address[] ethAddress; \n', '        bytes32 referrer; \n', '        address payable lastAddress; \n', '        uint256 time;\n', '    }\n', '\n', '    struct MyWorks { \n', '        address ethAddress; \n', '        bytes32 worksID; \n', '        uint256 totalInput; \n', '        uint256 totalOutput; \n', '        uint256 time; \n', '    }\n', '\n', '\n', '    struct Works {\n', '        bytes32 worksID; \n', '        bytes32 artistID; \n', '        uint8 debrisNum; \n', '        uint256 price; \n', '        uint256 beginTime; \n', '        uint256 endTime;\n', '        bool isPublish; \n', '        bytes32 lastUnionID;\n', '    }\n', '\n', '    struct Debris {\n', '        uint8 debrisID; \n', '        bytes32 worksID; \n', '        uint256 initPrice; \n', '        uint256 lastPrice; \n', '        uint256 buyNum; \n', '        address payable firstBuyer; \n', '        address payable lastBuyer; \n', '        bytes32 firstUnionID; \n', '        bytes32 lastUnionID; \n', '        uint256 lastTime; \n', '    }\n', '    \n', '    struct Rule {       \n', '        uint8 firstBuyLimit; \n', '        uint256 freezeGap; \n', '        uint256 protectGap; \n', '        uint256 increaseRatio;\n', '        uint256 discountGap; \n', '        uint256 discountRatio; \n', '\n', '        uint8[3] firstAllot; \n', '        uint8[3] againAllot;\n', '        uint8[3] lastAllot; \n', '    }\n', '\n', '    struct PlayerCount {\n', '        uint256 lastTime; \n', '        uint256 firstBuyNum; \n', '        uint256 firstAmount; \n', '        uint256 secondAmount; \n', '        uint256 rewardAmount;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Works Contract\n', ' * @dev http://www.puzzlebid.com/\n', ' * @author PuzzleBID Game Team \n', ' * @dev Simon<vsiryxm@163.com>\n', ' */\n', 'contract Works {\n', '\n', '    using SafeMath for *;\n', '\n', '    TeamInterface private team; \n', '    ArtistInterface private artist; \n', '\n', '    constructor(address _teamAddress, address _artistAddress) public {\n', '        require(_teamAddress != address(0) && _artistAddress != address(0));\n', '        team = TeamInterface(_teamAddress);\n', '        artist = ArtistInterface(_artistAddress);\n', '    }\n', '\n', '    function() external payable {\n', '        revert();\n', '    }\n', '\n', '    event OnUpgrade(address indexed _teamAddress, address indexed _artistAddress);\n', '    event OnAddWorks(\n', '        bytes32 _worksID,\n', '        bytes32 _artistID, \n', '        uint8 _debrisNum, \n', '        uint256 _price, \n', '        uint256 _beginTime,\n', '        bool _isPublish\n', '    );\n', '    event OnInitDebris(\n', '        bytes32 _worksID,\n', '        uint8 _debrisNum,\n', '        uint256 _initPrice\n', '    );\n', '    event OnUpdateDebris(\n', '        bytes32 _worksID, \n', '        uint8 _debrisID, \n', '        bytes32 _unionID, \n', '        address indexed _sender\n', '    );\n', '    event OnUpdateFirstBuyer(\n', '        bytes32 _worksID, \n', '        uint8 _debrisID, \n', '        bytes32 _unionID, \n', '        address indexed _sender\n', '    );\n', '    event OnUpdateBuyNum(bytes32 _worksID, uint8 _debrisID);\n', '    event OnFinish(bytes32 _worksID, bytes32 _unionID, uint256 _time);\n', '    event OnUpdatePools(bytes32 _worksID, uint256 _value);\n', '    event OnUpdateFirstUnionIds(bytes32 _worksID, bytes32 _unionID);\n', '    event OnUpdateSecondUnionIds(bytes32 _worksID, bytes32 _unionID);\n', '\n', '    mapping(bytes32 => Datasets.Works) private works; \n', '    mapping(bytes32 => Datasets.Rule) private rules; \n', '    mapping(bytes32 => uint256) private pools; \n', '    mapping(bytes32 => mapping(uint8 => Datasets.Debris)) private debris; \n', '    mapping(bytes32 => bytes32[]) firstUnionID; \n', '    mapping(bytes32 => bytes32[]) secondUnionID; \n', '\n', '    modifier whenHasWorks(bytes32 _worksID) {\n', '        require(works[_worksID].beginTime != 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotHasWorks(bytes32 _worksID) {\n', '        require(works[_worksID].beginTime == 0);\n', '        _;\n', '    }\n', '\n', '    modifier whenHasArtist(bytes32 _artistID) {\n', '        require(artist.hasArtist(_artistID));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(team.isAdmin(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyDev() {\n', '        require(team.isDev(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function upgrade(address _teamAddress, address _artistAddress) external onlyAdmin() {\n', '        require(_teamAddress != address(0) && _artistAddress != address(0));\n', '        team = TeamInterface(_teamAddress);\n', '        artist = ArtistInterface(_artistAddress);\n', '        emit OnUpgrade(_teamAddress, _artistAddress);\n', '    }\n', '\n', '    function addWorks(\n', '        bytes32 _worksID,\n', '        bytes32 _artistID, \n', '        uint8 _debrisNum, \n', '        uint256 _price, \n', '        uint256 _beginTime\n', '    ) \n', '        external \n', '        onlyAdmin()\n', '        whenNotHasWorks(_worksID)\n', '        whenHasArtist(_artistID)\n', '    {\n', '        require(\n', '            _debrisNum >= 2 && _debrisNum < 256 && \n', '            _price > 0 && _price % _debrisNum == 0 &&\n', '            _beginTime > 0 && _beginTime > now \n', '        ); \n', '\n', '        works[_worksID] = Datasets.Works(\n', '            _worksID, \n', '            _artistID, \n', '            _debrisNum, \n', '            _price.mul(1 wei),\n', '            _beginTime, \n', '            0,\n', '            false,\n', '            bytes32(0)\n', '        ); \n', '\n', '        emit OnAddWorks(\n', '            _worksID,\n', '            _artistID, \n', '            _debrisNum, \n', '            _price, \n', '            _beginTime,\n', '            false\n', '        ); \n', '\n', '        initDebris(_worksID, _price, _debrisNum);\n', '    }\n', '\n', '    function initDebris(bytes32 _worksID, uint256 _price, uint8 _debrisNum) private {      \n', '        uint256 initPrice = (_price / _debrisNum).mul(1 wei);\n', '        for(uint8 i=1; i<=_debrisNum; i++) {\n', '            debris[_worksID][i].worksID = _worksID;\n', '            debris[_worksID][i].initPrice = initPrice;\n', '        }\n', '        emit OnInitDebris(\n', '            _worksID,\n', '            _debrisNum,\n', '            initPrice\n', '        );\n', '    }\n', '\n', '    function configRule(\n', '        bytes32 _worksID,\n', '        uint8 _firstBuyLimit, \n', '        uint256 _freezeGap, \n', '        uint256 _protectGap,\n', '        uint256 _increaseRatio, \n', '        uint256 _discountGap,\n', '        uint256 _discountRatio,\n', '\n', '        uint8[3] calldata _firstAllot,\n', '        uint8[3] calldata _againAllot, \n', '        uint8[3] calldata _lastAllot\n', '    ) \n', '        external\n', '        onlyAdmin()\n', '        whenHasWorks(_worksID)\n', '    {\n', '\n', '        require(\n', '            _firstBuyLimit > 0 &&\n', '            _freezeGap > 0 &&\n', '            _protectGap > 0 &&\n', '            _increaseRatio > 0 && \n', '            _discountGap > 0 &&\n', '            _discountRatio > 0 &&\n', '            _discountGap > _protectGap\n', '        );\n', '\n', '        require(\n', '            _firstAllot[0] > 0 && _firstAllot[1] > 0 && _firstAllot[2] > 0 && \n', '            _againAllot[0] > 0 && _againAllot[1] > 0 && _againAllot[2] > 0 &&\n', '            _lastAllot[0] > 0 && _lastAllot[1] > 0 && _lastAllot[2] > 0\n', '        ); \n', '\n', '        rules[_worksID] = Datasets.Rule(\n', '            _firstBuyLimit,\n', '            _freezeGap.mul(1 seconds),\n', '            _protectGap.mul(1 seconds),\n', '            _increaseRatio,\n', '            _discountGap.mul(1 seconds),    \n', '            _discountRatio,\n', '            _firstAllot,\n', '            _againAllot,\n', '            _lastAllot\n', '        );\n', '    }\n', '\n', '    function publish(bytes32 _worksID, uint256 _beginTime) external onlyAdmin() {\n', '        require(works[_worksID].beginTime != 0 && works[_worksID].isPublish == false);\n', '        require(this.getAllot(_worksID, 0, 0) != 0);\n', '        if(_beginTime > 0) {\n', '            require(_beginTime > now);\n', '            works[_worksID].beginTime = _beginTime;\n', '        }\n', '        works[_worksID].isPublish = true;\n', '    }\n', '\n', '    function close(bytes32 _worksID) external onlyAdmin() {\n', '        works[_worksID].isPublish = false;\n', '    }\n', '\n', '    function getWorks(bytes32 _worksID) external view returns (uint8, uint256, uint256, uint256, bool) {\n', '        return (\n', '            works[_worksID].debrisNum,\n', '            works[_worksID].price,\n', '            works[_worksID].beginTime,\n', '            works[_worksID].endTime,\n', '            works[_worksID].isPublish\n', '        );\n', '    }\n', '\n', '    function getDebris(bytes32 _worksID, uint8 _debrisID) external view \n', '        returns (uint256, address, address, bytes32, bytes32, uint256) {\n', '        return (\n', '            debris[_worksID][_debrisID].buyNum,\n', '            debris[_worksID][_debrisID].firstBuyer,\n', '            debris[_worksID][_debrisID].lastBuyer,\n', '            debris[_worksID][_debrisID].firstUnionID,\n', '            debris[_worksID][_debrisID].lastUnionID,\n', '            debris[_worksID][_debrisID].lastTime\n', '        );\n', '    }\n', '\n', '    function getRule(bytes32 _worksID) external view \n', '        returns (uint256, uint256, uint256, uint8[3] memory, uint8[3] memory, uint8[3] memory) {\n', '        return (\n', '            rules[_worksID].increaseRatio,\n', '            rules[_worksID].discountGap,\n', '            rules[_worksID].discountRatio,\n', '            rules[_worksID].firstAllot,\n', '            rules[_worksID].againAllot,\n', '            rules[_worksID].lastAllot\n', '        );\n', '    }\n', '\n', '    function hasWorks(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].beginTime != 0;\n', '    }\n', '\n', '    function hasDebris(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        return _debrisID > 0 && _debrisID <= works[_worksID].debrisNum;\n', '    }\n', '\n', '    function isPublish(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].isPublish;\n', '    }\n', '\n', '    function isStart(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].beginTime <= now;\n', '    }\n', '\n', '    function isProtect(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        if(debris[_worksID][_debrisID].lastTime == 0) {\n', '            return false;\n', '        }\n', '        uint256 protectGap = rules[_worksID].protectGap;\n', '        return debris[_worksID][_debrisID].lastTime.add(protectGap) < now ? false : true;\n', '    }\n', '\n', '    function isSecond(bytes32 _worksID, uint8 _debrisID) external view returns (bool) {\n', '        return debris[_worksID][_debrisID].buyNum > 0;\n', '    }\n', '\n', '    function isGameOver(bytes32 _worksID) external view returns (bool) {\n', '        return works[_worksID].endTime != 0;\n', '    }\n', '\n', '    function isFinish(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        bool finish = true; \n', '        uint8 i = 1;\n', '        while(i <= works[_worksID].debrisNum) {\n', '            if(debris[_worksID][i].lastUnionID != _unionID) {\n', '                finish = false;\n', '                break;\n', '            }\n', '            i++;\n', '        }\n', '        return finish;\n', '    } \n', '\n', '    function hasFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        if(0 == firstUnionID[_worksID].length) {\n', '            return false;\n', '        }\n', '        bool has = false;\n', '        for(uint256 i=0; i<firstUnionID[_worksID].length; i++) {\n', '            if(firstUnionID[_worksID][i] == _unionID) {\n', '                has = true;\n', '                break;\n', '            }\n', '        }\n', '        return has;\n', '    }\n', '\n', '    function hasSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool) {\n', '        if(0 == secondUnionID[_worksID].length) {\n', '            return false;\n', '        }\n', '        bool has = false;\n', '        for(uint256 i=0; i<secondUnionID[_worksID].length; i++) {\n', '            if(secondUnionID[_worksID][i] == _unionID) {\n', '                has = true;\n', '                break;\n', '            }\n', '        }\n', '        return has;\n', '    }  \n', '\n', '    function getFirstUnionIds(bytes32 _worksID) external view returns (bytes32[] memory) {\n', '        return firstUnionID[_worksID];\n', '    }\n', '\n', '    function getSecondUnionIds(bytes32 _worksID) external view returns (bytes32[] memory) {\n', '        return secondUnionID[_worksID];\n', '    }\n', '\n', '    function getPrice(bytes32 _worksID) external view returns (uint256) {\n', '        return works[_worksID].price;\n', '    }\n', '\n', '    function getDebrisPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {        \n', '        uint256 discountGap = rules[_worksID].discountGap;\n', '        uint256 discountRatio = rules[_worksID].discountRatio;\n', '        uint256 increaseRatio = rules[_worksID].increaseRatio;\n', '        uint256 lastPrice;\n', '\n', '        if(debris[_worksID][_debrisID].buyNum > 0 && debris[_worksID][_debrisID].lastTime.add(discountGap) < now) { \n', '\n', '            uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime.add(discountGap))) / discountGap; \n', '            if((now.sub(debris[_worksID][_debrisID].lastTime.add(discountGap))) % discountGap > 0) { \n', '                n = n.add(1);\n', '            }\n', '            for(uint256 i=0; i<n; i++) {\n', '                if(0 == i) {\n', '                    lastPrice = debris[_worksID][_debrisID].lastPrice.mul(increaseRatio).mul(discountRatio) / 10000; \n', '                } else {\n', '                    lastPrice = lastPrice.mul(discountRatio) / 100;\n', '                }\n', '            }\n', '\n', '        } else if (debris[_worksID][_debrisID].buyNum > 0) { \n', '            lastPrice = debris[_worksID][_debrisID].lastPrice.mul(increaseRatio) / 100;\n', '        } else {\n', '            lastPrice = debris[_worksID][_debrisID].initPrice; \n', '        }\n', '\n', '        return lastPrice;\n', '    }\n', '\n', '    function getDebrisStatus(bytes32 _worksID, uint8 _debrisID) external view returns (uint256[4] memory, uint256, uint256, bytes32)  {\n', '        uint256 gap = 0;\n', '        uint256 status = 0;\n', '\n', '        if(0 == debris[_worksID][_debrisID].buyNum) { \n', '\n', '        } else if(this.isProtect(_worksID, _debrisID)) { \n', '            gap = rules[_worksID].protectGap;\n', '            status = 1;\n', '        } else { \n', '\n', '            if(debris[_worksID][_debrisID].lastTime.add(rules[_worksID].discountGap) > now) {\n', '                gap = rules[_worksID].discountGap; \n', '            } else {\n', '                uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime)) / rules[_worksID].discountGap; \n', '                if((now.sub(debris[_worksID][_debrisID].lastTime.add(rules[_worksID].discountGap))) % rules[_worksID].discountGap > 0) { \n', '                    n = n.add(1);\n', '                }\n', '                gap = rules[_worksID].discountGap.mul(n); \n', '            }\n', '            status = 2;\n', '\n', '        }\n', '        uint256 price = this.getDebrisPrice(_worksID, _debrisID);\n', '        bytes32 lastUnionID = debris[_worksID][_debrisID].lastUnionID;\n', '        uint256[4] memory state = [status, debris[_worksID][_debrisID].lastTime, gap, now];\n', '        return (state, price, debris[_worksID][_debrisID].buyNum, lastUnionID);\n', '    }\n', '\n', '    function getInitPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        return debris[_worksID][_debrisID].initPrice;\n', '    }\n', '\n', '    function getLastPrice(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        return debris[_worksID][_debrisID].lastPrice;\n', '    }\n', '\n', '    function getLastBuyer(bytes32 _worksID, uint8 _debrisID) external view returns(address) {\n', '        return debris[_worksID][_debrisID].lastBuyer;\n', '    }\n', '\n', '    function getLastUnionId(bytes32 _worksID, uint8 _debrisID) external view returns(bytes32) {\n', '        return debris[_worksID][_debrisID].lastUnionID;\n', '    }\n', '\n', '    function getFreezeGap(bytes32 _worksID) external view returns(uint256) {\n', '        return rules[_worksID].freezeGap;\n', '    }\n', '\n', '    function getFirstBuyLimit(bytes32 _worksID) external view returns(uint256) {\n', '        return rules[_worksID].firstBuyLimit;\n', '    }\n', '\n', '    function getArtistId(bytes32 _worksID) external view returns(bytes32) {\n', '        return works[_worksID].artistID;\n', '    }\n', '\n', '    function getDebrisNum(bytes32 _worksID) external view returns(uint8) {\n', '        return works[_worksID].debrisNum;\n', '    }\n', '\n', '    function getAllot(bytes32 _worksID, uint8 _flag) external view returns(uint8[3] memory) {\n', '        require(_flag < 3);\n', '        if(0 == _flag) {\n', '            return rules[_worksID].firstAllot;\n', '        } else if(1 == _flag) {\n', '            return rules[_worksID].againAllot;\n', '        } else {\n', '            return rules[_worksID].lastAllot;\n', '        }        \n', '    }\n', '\n', '    function getAllot(bytes32 _worksID, uint8 _flag, uint8 _element) external view returns(uint8) {\n', '        require(_flag < 3 && _element < 3);\n', '        if(0 == _flag) {\n', '            return rules[_worksID].firstAllot[_element];\n', '        } else if(1 == _flag) {\n', '            return rules[_worksID].againAllot[_element];\n', '        } else {\n', '            return rules[_worksID].lastAllot[_element];\n', '        }        \n', '    }\n', '\n', '    function getPools(bytes32 _worksID) external view returns (uint256) {\n', '        return pools[_worksID];\n', '    }\n', '\n', '    function getPoolsAllot(bytes32 _worksID) external view returns (uint256, uint256[3] memory, uint8[3] memory) {\n', '        require(works[_worksID].endTime != 0); \n', '\n', '        uint8[3] memory lastAllot = this.getAllot(_worksID, 2); \n', '        uint256 finishAccount = pools[_worksID].mul(lastAllot[0]) / 100; \n', '        uint256 firstAccount = pools[_worksID].mul(lastAllot[1]) / 100;\n', '        uint256 allAccount = pools[_worksID].mul(lastAllot[2]) / 100;\n', '        uint256[3] memory account = [finishAccount, firstAccount, allAccount];   \n', '\n', '        return (pools[_worksID], account, lastAllot);\n', '    }\n', '\n', '    function getStartHourglass(bytes32 _worksID) external view returns(uint256) {\n', '        if(works[_worksID].beginTime > 0 && works[_worksID].beginTime > now ) {\n', '            return works[_worksID].beginTime.sub(now);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getWorksStatus(bytes32 _worksID) external view returns (uint256, uint256, uint256, bytes32) {\n', '        return (works[_worksID].beginTime, works[_worksID].endTime, now, works[_worksID].lastUnionID);\n', '    }\n', '\n', '    function getProtectHourglass(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        if(\n', '            debris[_worksID][_debrisID].lastTime > 0 && \n', '            debris[_worksID][_debrisID].lastTime.add(rules[_worksID].protectGap) > now\n', '        ) {\n', '            return debris[_worksID][_debrisID].lastTime.add(rules[_worksID].protectGap).sub(now);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getDiscountHourglass(bytes32 _worksID, uint8 _debrisID) external view returns(uint256) {\n', '        if(debris[_worksID][_debrisID].lastTime == 0) {\n', '            return 0;\n', '        }\n', '        uint256 discountGap = rules[_worksID].discountGap;\n', '        uint256 n = (now.sub(debris[_worksID][_debrisID].lastTime)) / discountGap; \n', '        if((now.sub(debris[_worksID][_debrisID].lastTime)) % discountGap > 0) { \n', '            n = n.add(1);\n', '        }\n', '        return debris[_worksID][_debrisID].lastTime.add(discountGap.mul(n)).sub(now);\n', '    }\n', '\n', '    function updateDebris(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address payable _sender) external onlyDev() {\n', '        debris[_worksID][_debrisID].lastPrice = this.getDebrisPrice(_worksID, _debrisID);\n', '        debris[_worksID][_debrisID].lastUnionID = _unionID; \n', '        debris[_worksID][_debrisID].lastBuyer = _sender; \n', '        debris[_worksID][_debrisID].lastTime = now; \n', '        emit OnUpdateDebris(_worksID, _debrisID, _unionID, _sender);\n', '    }\n', '\n', '    function updateFirstBuyer(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address payable _sender) external onlyDev() {\n', '        debris[_worksID][_debrisID].firstBuyer = _sender;\n', '        debris[_worksID][_debrisID].firstUnionID = _unionID;\n', '        emit OnUpdateFirstBuyer(_worksID, _debrisID, _unionID, _sender);\n', '        this.updateFirstUnionIds(_worksID, _unionID);\n', '    }\n', '\n', '    function updateBuyNum(bytes32 _worksID, uint8 _debrisID) external onlyDev() {\n', '        debris[_worksID][_debrisID].buyNum = debris[_worksID][_debrisID].buyNum.add(1);\n', '        emit OnUpdateBuyNum(_worksID, _debrisID);\n', '    }\n', '\n', '    function finish(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        works[_worksID].endTime = now;\n', '        works[_worksID].lastUnionID = _unionID;\n', '        emit OnFinish(_worksID, _unionID, now);\n', '    }\n', '\n', '    function updatePools(bytes32 _worksID, uint256 _value) external onlyDev() {\n', '        pools[_worksID] = pools[_worksID].add(_value);\n', '        emit OnUpdatePools(_worksID, _value);\n', '    }\n', '\n', '    function updateFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        if(this.hasFirstUnionIds(_worksID, _unionID) == false) {\n', '            firstUnionID[_worksID].push(_unionID);\n', '            emit OnUpdateFirstUnionIds(_worksID, _unionID);\n', '        }\n', '    }\n', '\n', '    function updateSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external onlyDev() {\n', '        if(this.hasSecondUnionIds(_worksID, _unionID) == false) {\n', '            secondUnionID[_worksID].push(_unionID);\n', '            emit OnUpdateSecondUnionIds(_worksID, _unionID);\n', '        }\n', '    }\n', '\n', ' }']
