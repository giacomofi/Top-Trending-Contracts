['pragma solidity \n', '\n', '\n', '\n', '\n', '^0.5.0;\n', '\n', 'contract Lockbox {\n', '\n', '    event PayOut(\n', '        address indexed to,\n', '        uint indexed nonce,\n', '        uint256 amount\n', '    );\n', '\n', '    uint constant UINT_MAX = ~uint(0);\n', '\n', '    address public owner; // = msg.sender;\n', '    address payable public returnFundsAddress;\n', '\n', '    mapping(uint256 => bool) usedNonces;\n', '\n', '    constructor(address payable returnFunds) public payable {\n', '        owner = msg.sender;\n', '        returnFundsAddress = returnFunds;\n', '    }\n', '\n', '    // @notice Will receive any eth sent to the contract\n', '    function () external payable {\n', '    }\n', '\n', '    function getOwner() public view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function claimPayment(uint256 amount, uint nonce, bytes memory sig) public {\n', '        require(!usedNonces[nonce], "Reused nonce");\n', '\n', '        // This recreates the message that was signed on the client.\n', '        bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce, this)));\n', '\n', '        //return recoverSigner(message, sig);\n', '        require(recoverSigner(message, sig) == owner, "Non-owner signature");\n', '        \n', '        if (nonce == 0) {\n', '            require(amount == 1, "Req. 1 WEI amt for 0 nonce");\n', '        } else {\n', '            usedNonces[nonce] = true;\n', '        }\n', '\n', '        emit PayOut(msg.sender, nonce, amount);\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function returnFunds(uint256 amount, uint[] memory nonces) public {\n', '        require(msg.sender == owner, "Non-owner sender");\n', '\n', '        for (uint i = 0; i < nonces.length; i++){\n', '            if (nonces[i] != 0)\n', '                usedNonces[nonces[i]] = true;\n', '        }\n', '\n', '        emit PayOut(returnFundsAddress, UINT_MAX, amount);\n', '        returnFundsAddress.transfer(amount);\n', '    }\n', '\n', '    // Destroy contract and reclaim leftover funds.\n', '    function kill() public {\n', '        require(msg.sender == owner, "Non-owner sender");\n', '        selfdestruct(returnFundsAddress);\n', '    }\n', '\n', '    // Signature methods\n', '    function splitSignature(bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (uint8, bytes32, bytes32)\n', '    {\n', '        require(sig.length == 65, "Malformed sig");\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r := mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s := mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        // support both versions of `eth_sign` responses\n', '        if (v < 27) \n', '            v += 27;\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function recoverSigner(bytes32 message, bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    // Builds a prefixed hash to mimic the behavior of eth_sign.\n', '    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}']