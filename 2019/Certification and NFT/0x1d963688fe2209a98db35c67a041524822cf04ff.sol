['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-08\n', '*/\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev ERC-721 non-fungible token standard. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721 {\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they mayb be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved The new approved NFT controller.\n', '   * @param _tokenId The NFT to approve.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", '   * @notice The contract MUST allow multiple operators per owner.\n', '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId The NFT to find the approved address for.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721TokenReceiver.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers. See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721TokenReceiver {\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _operator The address which called `safeTransferFrom` function.\n', '   * @param _from The address which previously owned the token.\n', '   * @param _tokenId The NFT identifier which is being transferred.\n', '   * @param _data Additional data with no specified format.\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '    \n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error. This contract is based\n', ' * on the source code at https://goo.gl/iyQsmU.\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, throws on overflow.\n', '   * @param _a Factor number.\n', '   * @param _b Factor number.\n', '   */\n', '  function mul(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers, truncating the quotient.\n', '   * @param _a Dividend number.\n', '   * @param _b Divisor number.\n', '   */\n', '  function div(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a / _b;\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '   * @param _a Minuend number.\n', '   * @param _b Subtrahend number.\n', '   */\n', '  function sub(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two numbers, throws on overflow.\n', '   * @param _a Number.\n', '   * @param _b Number.\n', '   */\n', '  function add(\n', '    uint256 _a,\n', '    uint256 _b\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * @notice This function uses less than 30,000 gas.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @dev Implementation of standard for detect smart contract interfaces.\n', ' */\n', 'contract SupportsInterface is\n', '  ERC165\n', '{\n', '\n', '  /**\n', '   * @dev Mapping of supported intefraces.\n', '   * @notice You must not set element 0xffffffff to true.\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check which interfaces are suported by this contract.\n', '   * @param _interfaceID Id of the interface.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceID];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev Utility library of inline functions on addresses.\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * @dev Returns whether the target address is a contract.\n', '   * @param _addr Address to check.\n', '   */\n', '  function isContract(\n', '    address _addr\n', '  )\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    uint256 size;\n', '\n', '    /**\n', '     * XXX Currently there is no better way to check if there is a contract in an address than to\n', '     * check the size of the code at that address.\n', '     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n', '     * TODO: Check this again before the Serenity release, because all addresses will be\n', '     * contracts then.\n', '     */\n', '    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFToken.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFToken is\n', '  ERC721,\n', '  SupportsInterface\n', '{\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev A mapping from NFT ID to the address that owns it.\n', '   */\n', '  mapping (uint256 => address) internal idToOwner;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to approved address.\n', '   */\n', '  mapping (uint256 => address) internal idToApprovals;\n', '\n', '   /**\n', '   * @dev Mapping from owner address to count of his tokens.\n', '   */\n', '  mapping (address => uint256) internal ownerToNFTokenCount;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to mapping of operator addresses.\n', '   */\n', '  mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '  /**\n', '   * @dev Magic value of a smart contract that can recieve NFT.\n', '   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '   */\n', '  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   * @param _from Sender of NFT (if address is zero address it indicates token creation).\n', '   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n', '   * @param _tokenId The NFT that got transfered.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   * @param _owner Owner of NFT.\n', '   * @param _approved Address that we are approving.\n', '   * @param _tokenId NFT which we are approving.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   * @param _owner Owner of NFT.\n', '   * @param _operator Address to which we are setting operator rights.\n', '   * @param _approved Status of operator rights(true if operator rights are given and false if\n', '   * revoked).\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier canOperate(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n', '   * @param _tokenId ID of the NFT to transfer.\n', '   */\n', '  modifier canTransfer(\n', '    uint256 _tokenId\n', '  ) {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender\n', '      || getApproved(_tokenId) == msg.sender\n', '      || ownerToOperators[tokenOwner][msg.sender]\n', '    );\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that _tokenId is a valid Token.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier validNFToken(\n', '    uint256 _tokenId\n', '  ) {\n', '    require(idToOwner[_tokenId] != address(0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_owner != address(0));\n', '    return ownerToNFTokenCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address _owner)\n', '  {\n', '    _owner = idToOwner[_tokenId];\n', '    require(_owner != address(0));\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\n', '   * on `_to` and throws if the return value is not `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, _data);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they maybe be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved Address to be approved for the given NFT ID.\n', '   * @param _tokenId ID of the token to be approved.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    canOperate(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(_approved != tokenOwner);\n', '\n', '    idToApprovals[_tokenId] = _approved;\n', '    emit Approval(tokenOwner, _approved, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", "   * @notice This works even if sender doesn't own any tokens at the time.\n", '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external\n', '  {\n', '    require(_operator != address(0));\n', '    ownerToOperators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId ID of the NFT to query the approval of.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (address)\n', '  {\n', '    return idToApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if `_operator` is an approved operator for `_owner`.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(_owner != address(0));\n', '    require(_operator != address(0));\n', '    return ownerToOperators[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Actually perform the safeTransferFrom.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function _safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from);\n', '    require(_to != address(0));\n', '\n', '    _transfer(_to, _tokenId);\n', '\n', '    if (_to.isContract()) {\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n', '      require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Actually preforms the transfer.\n', '   * @notice Does NO checks.\n', '   * @param _to Address of a new owner.\n', '   * @param _tokenId The NFT that is being transferred.\n', '   */\n', '  function _transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    private\n', '  {\n', '    address from = idToOwner[_tokenId];\n', '    clearApproval(_tokenId);\n', '\n', '    removeNFToken(from, _tokenId);\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(from, _to, _tokenId);\n', '  }\n', '   \n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(_to != address(0));\n', '    require(_tokenId != 0);\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    clearApproval(_tokenId);\n', '    removeNFToken(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /** \n', '   * @dev Clears the current approval of a given NFT ID.\n', '   * @param _tokenId ID of the NFT to be transferred.\n', '   */\n', '  function clearApproval(\n', '    uint256 _tokenId\n', '  )\n', '    private\n', '  {\n', '    if(idToApprovals[_tokenId] != 0)\n', '    {\n', '      delete idToApprovals[_tokenId];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    require(idToOwner[_tokenId] == _from);\n', '    assert(ownerToNFTokenCount[_from] > 0);\n', '    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from].sub(1);\n', '    delete idToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    require(idToOwner[_tokenId] == address(0));\n', '\n', '    idToOwner[_tokenId] = _to;\n', '    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Metadata.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Metadata {\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name);\n', '\n', '  /**\n', '   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol);\n', '\n', '  /**\n', '   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n', '   * that conforms to the "ERC721 Metadata JSON Schema".\n', '   */\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenMetadata.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenMetadata is\n', '  NFToken,\n', '  ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev A descriptive name for a collection of NFTs.\n', '   */\n', '  string internal nftName;\n', '\n', '  /**\n', '   * @dev An abbreviated name for NFTokens.\n', '   */\n', '  string internal nftSymbol;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to metadata uri.\n', '   */\n', '  mapping (uint256 => string) internal idToUri;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', "   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\n", '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    if (bytes(idToUri[_tokenId]).length != 0) {\n', '      delete idToUri[_tokenId];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\n', '   * @notice this is a internal function which should be called from user-implemented external\n', '   * function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @param _uri String representing RFC 3986 URI.\n', '   */\n', '  function _setTokenUri(\n', '    uint256 _tokenId,\n', '    string _uri\n', '  )\n', '    validNFToken(_tokenId)\n', '    internal\n', '  {\n', '    idToUri[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTokens.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string _name)\n', '  {\n', '    _name = nftName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an abbreviated name for NFTokens.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string _symbol)\n', '  {\n', '    _symbol = nftSymbol;\n', '  }\n', '\n', '  /**\n', '   * @dev A distinct URI (RFC 3986) for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   */\n', '  function tokenURI(\n', '    uint256 _tokenId\n', '  )\n', '    validNFToken(_tokenId)\n', '    external\n', '    view\n', '    returns (string)\n', '  {\n', '    return idToUri[_tokenId];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n', ' * See https://goo.gl/pc9yoS.\n', ' */\n', 'interface ERC721Enumerable {\n', '\n', '  /**\n', '   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n', '   * assigned and queryable owner not equal to the zero address.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n', '   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n', '   * representing invalid NFTs.\n', '   * @param _owner An address where we are interested in NFTs owned by them.\n', '   * @param _index A counter less than `balanceOf(_owner)`.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenEnumerable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenEnumerable is\n', '  NFToken,\n', '  ERC721Enumerable\n', '{\n', '\n', '  /**\n', '   * @dev Array of all NFT IDs.\n', '   */\n', '  uint256[] internal tokens;\n', '\n', '  /**\n', '   * @dev Mapping from token ID its index in global tokens array.\n', '   */\n', '  mapping(uint256 => uint256) internal idToIndex;\n', '\n', '  /**\n', '   * @dev Mapping from owner to list of owned NFT IDs.\n', '   */\n', '  mapping(address => uint256[]) internal ownerToIds;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to its index in the owner tokens list.\n', '   */\n', '  mapping(uint256 => uint256) internal idToOwnerIndex;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._mint(_to, _tokenId);\n', '    tokens.push(_tokenId);\n', '    idToIndex[_tokenId] = tokens.length.sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is a private function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    address _owner,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super._burn(_owner, _tokenId);\n', '    assert(tokens.length > 0);\n', '\n', '    uint256 tokenIndex = idToIndex[_tokenId];\n', '    // Sanity check. This could be removed in the future.\n', '    assert(tokens[tokenIndex] == _tokenId);\n', '    uint256 lastTokenIndex = tokens.length.sub(1);\n', '    uint256 lastToken = tokens[lastTokenIndex];\n', '\n', '    tokens[tokenIndex] = lastToken;\n', '\n', '    tokens.length--;\n', '    // Consider adding a conditional check for the last token in order to save GAS.\n', '    idToIndex[lastToken] = tokenIndex;\n', '    idToIndex[_tokenId] = 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '   internal\n', '  {\n', '    super.removeNFToken(_from, _tokenId);\n', '    assert(ownerToIds[_from].length > 0);\n', '\n', '    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\n', '    uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n', '\n', '    ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n', '\n', '    ownerToIds[_from].length--;\n', '    // Consider adding a conditional check for the last token in order to save GAS.\n', '    idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n', '    idToOwnerIndex[_tokenId] = 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    super.addNFToken(_to, _tokenId);\n', '\n', '    uint256 length = ownerToIds[_to].length;\n', '    ownerToIds[_to].push(_tokenId);\n', '    idToOwnerIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the count of all existing NFTokens.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return tokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns NFT ID by its index.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < tokens.length);\n', '    // Sanity check. This could be removed in the future.\n', '    assert(idToIndex[tokens[_index]] == _index);\n', '    return tokens[_index];\n', '  }\n', '\n', '  /**\n', "   * @dev returns the n-th NFT ID from a list of owner's tokens.\n", "   * @param _owner Token owner's address.\n", "   * @param _index Index number representing n-th token in owner's list of tokens.\n", '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < ownerToIds[_owner].length);\n', '    return ownerToIds[_owner][_index];\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @dev The contract has an owner address, and provides basic authorization control whitch\n', ' * simplifies the implementation of user permissions. This contract is based on the source code\n', ' * at https://goo.gl/n2ZGVt.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev An event which is triggered when the owner is changed.\n', '   * @param previousOwner The address of the previous owner.\n', '   * @param newOwner The address of the new owner.\n', '   */\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(\n', '    address _newOwner\n', '  )\n', '    onlyOwner\n', '    public\n', '  {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: @0xcert/ethereum-utils/contracts/ownership/Claimable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @dev The contract has an owner address, and provides basic authorization control whitch\n', ' * simplifies the implementation of user permissions. This contract is based on the source code\n', ' * at goo.gl/CfEAkv and upgrades Ownable contracts with additional claim step which makes ownership\n', ' * transfers less prone to errors.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev An event which is triggered when the owner is changed.\n', '   * @param previousOwner The address of the previous owner.\n', '   * @param newOwner The address of the new owner.\n', '   */\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Allows the current owner to give new owner ability to claim the ownership of the contract.\n', "   * This differs from the Owner's function in that it allows setting pedingOwner address to 0x0,\n", '   * which effectively cancels an active claim.\n', '   * @param _newOwner The address which can claim ownership of the contract.\n', '   */\n', '  function transferOwnership(\n', '    address _newOwner\n', '  )\n', '    onlyOwner\n', '    public\n', '  {\n', '    pendingOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current pending owner to claim the ownership of the contract. It emits\n', '   * OwnershipTransferred event and resets pending owner to 0.\n', '   */\n', '  function claimOwnership()\n', '    public\n', '  {\n', '    require(msg.sender == pendingOwner);\n', '    address previousOwner = owner;\n', '    owner = pendingOwner;\n', '    pendingOwner = 0;\n', '    emit OwnershipTransferred(previousOwner, owner);\n', '  }\n', '}\n', '\n', '// File: contracts/Adminable.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Adminable\n', ' * @dev Allows to manage privilages to special contract functionality.\n', ' */\n', 'contract Adminable is Claimable {\n', '  mapping(address => uint) public adminsMap;\n', '  address[] public adminList;\n', '\n', '  /**\n', '   * @dev Returns true, if provided address has special privilages, otherwise false\n', '   * @param adminAddress - address to check\n', '   */\n', '  function isAdmin(address adminAddress)\n', '    public\n', '    view\n', '    returns(bool isIndeed)\n', '  {\n', '    if (adminAddress == owner) return true;\n', '\n', '    if (adminList.length == 0) return false;\n', '    return (adminList[adminsMap[adminAddress]] == adminAddress);\n', '  }\n', '\n', '  /**\n', '   * @dev Grants special rights for address holder\n', '   * @param adminAddress - address of future admin\n', '   */\n', '  function addAdmin(address adminAddress)\n', '    public\n', '    onlyOwner\n', '    returns(uint index)\n', '  {\n', '    require(!isAdmin(adminAddress), "Address already has admin rights!");\n', '\n', '    adminsMap[adminAddress] = adminList.push(adminAddress)-1;\n', '\n', '    return adminList.length-1;\n', '  }\n', '\n', '  /**\n', '   * @dev Removes special rights for provided address\n', '   * @param adminAddress - address of current admin\n', '   */\n', '  function removeAdmin(address adminAddress)\n', '    public\n', '    onlyOwner\n', '    returns(uint index)\n', '  {\n', '    // we can not remove owner from admin role\n', '    require(owner != adminAddress, "Owner can not be removed from admin role!");\n', '    require(isAdmin(adminAddress), "Provided address is not admin.");\n', '\n', '    uint rowToDelete = adminsMap[adminAddress];\n', '    address keyToMove = adminList[adminList.length-1];\n', '    adminList[rowToDelete] = keyToMove;\n', '    adminsMap[keyToMove] = rowToDelete;\n', '    adminList.length--;\n', '\n', '    return rowToDelete;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(isAdmin(msg.sender), "Can be executed only by admin accounts!");\n', '    _;\n', '  }\n', '}\n', '\n', '// File: contracts/MarbleNFTInterface.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Marble NFT Interface\n', ' * @dev Defines Marbles unique extension of NFT.\n', ' * ...It contains methodes returning core properties what describe Marble NFTs and provides management options to create,\n', ' * burn NFT or change approvals of it.\n', ' */\n', 'interface MarbleNFTInterface {\n', '\n', '  /**\n', '   * @dev Mints Marble NFT.\n', '   * @notice This is a external function which should be called just by the owner of contract or any other user who has priviladge of being resposible\n', '   * of creating valid Marble NFT. Valid token contains all neccessary information to be able recreate marble card image.\n', '   * @param _tokenId The ID of new NFT.\n', '   * @param _owner Address of the NFT owner.\n', '   * @param _uri Unique URI proccessed by Marble services to be sure it is valid NFTs DNA. Most likely it is URL pointing to some website address.\n', '   * @param _metadataUri URI pointing to "ERC721 Metadata JSON Schema"\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function mint(\n', '    uint256 _tokenId,\n', '    address _owner,\n', '    address _creator,\n', '    string _uri,\n', '    string _metadataUri,\n', '    uint256 _created\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Burns Marble NFT. Should be fired only by address with proper authority as contract owner or etc.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function burn(\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Allowes to change approval for change of ownership even when sender is not NFT holder. Sender has to have special role granted by contract to use this tool.\n', '   * @notice Careful with this!!!! :))\n', '   * @param _tokenId ID of the NFT to be updated.\n', '   * @param _approved ETH address what supposed to gain approval to take ownership of NFT.\n', '   */\n', '  function forceApproval(\n', '    uint256 _tokenId,\n', '    address _approved\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Returns properties used for generating NFT metadata image (a.k.a. card).\n', '   * @param _tokenId ID of the NFT.\n', '   */\n', '  function tokenSource(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (\n', '      string uri,\n', '      address creator,\n', '      uint256 created\n', '    );\n', '\n', '  /**\n', '   * @dev Returns ID of NFT what matches provided source URI.\n', '   * @param _uri URI of source website.\n', '   */\n', '  function tokenBySourceUri(string _uri)\n', '    external\n', '    view\n', '    returns (uint256 tokenId);\n', '\n', '  /**\n', '   * @dev Returns all properties of Marble NFT. Lets call it Marble NFT Model with properties described below:\n', '   * @param _tokenId ID  of NFT\n', '   * Returned model:\n', '   * uint256 id ID of NFT\n', '   * string uri  URI of source website. Website is used to mine data to crate NFT metadata image.\n', '   * string metadataUri URI to NFT metadata assets. In our case to our websevice providing JSON with additional information based on "ERC721 Metadata JSON Schema".\n', '   * address owner NFT owner address.\n', '   * address creator Address of creator of this NFT. It means that this addres placed sourceURI to candidate contract.\n', '   * uint256 created Date and time of creation of NFT candidate.\n', '   *\n', '   * (id, uri, metadataUri, owner, creator, created)\n', '   */\n', '  function getNFT(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns(\n', '      uint256 id,\n', '      string uri,\n', '      string metadataUri,\n', '      address owner,\n', '      address creator,\n', '      uint256 created\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev Transforms URI to hash.\n', '     * @param _uri URI to be transformed to hash.\n', '     */\n', '    function getSourceUriHash(string _uri)\n', '      external\n', '      view\n', '      returns(uint256 hash);\n', '}\n', '\n', '// File: contracts/MarbleNFT.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MARBLE NFT CONTRACT\n', ' * @notice We omit a fallback function to prevent accidental sends to this contract.\n', ' */\n', 'contract MarbleNFT is\n', '  Adminable,\n', '  NFTokenMetadata,\n', '  NFTokenEnumerable,\n', '  MarbleNFTInterface\n', '{\n', '\n', '  /*\n', '   * @dev structure storing additional information about created NFT\n', '   * uri: URI used as source/key/representation of NFT, it can be considered as tokens DNA\n', '   * creator:  address of candidate creator - a.k.a. address of person who initialy provided source URI\n', '   * created: date of NFT creation\n', '   */\n', '  struct MarbleNFTSource {\n', '\n', '    // URI used as source/key of NFT, we can consider it as tokens DNA\n', '    string uri;\n', '\n', '    // address of candidate creator - a.k.a. address of person who initialy provided source URI\n', '    address creator;\n', '\n', '    // date of NFT creation\n', '    uint256 created;\n', '  }\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to marble NFT source.\n', '   */\n', '  mapping (uint256 => MarbleNFTSource) public idToMarbleNFTSource;\n', '  /**\n', '   * @dev Mapping from marble NFT source uri hash TO NFT ID .\n', '   */\n', '  mapping (uint256 => uint256) public sourceUriHashToId;\n', '\n', '  constructor()\n', '    public\n', '  {\n', '    nftName = "MARBLE-NFT";\n', '    nftSymbol = "MRBLNFT";\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @param _tokenId The unique number representing NFT\n', '   * @param _owner Holder of Marble NFT\n', '   * @param _creator Creator of Marble NFT\n', '   * @param _uri URI representing NFT\n', '   * @param _metadataUri URI pointing to "ERC721 Metadata JSON Schema"\n', '   * @param _created date of creation of NFT candidate\n', '   */\n', '  function mint(\n', '    uint256 _tokenId,\n', '    address _owner,\n', '    address _creator,\n', '    string _uri,\n', '    string _metadataUri,\n', '    uint256 _created\n', '  )\n', '    external\n', '    onlyAdmin\n', '  {\n', '    uint256 uriHash = _getSourceUriHash(_uri);\n', '\n', '    require(uriHash != _getSourceUriHash(""), "NFT URI can not be empty!");\n', '    require(sourceUriHashToId[uriHash] == 0, "NFT with same URI already exists!");\n', '\n', '    _mint(_owner, _tokenId);\n', '    _setTokenUri(_tokenId, _metadataUri);\n', '\n', '    idToMarbleNFTSource[_tokenId] = MarbleNFTSource(_uri, _creator, _created);\n', '    sourceUriHashToId[uriHash] = _tokenId;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns NFT. Sadly, trully.. ...probably someone marbled something ugly!!!! :)\n', '   * @param _tokenId ID of ugly NFT\n', '   */\n', '  function burn(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    onlyAdmin\n', '  {\n', '    address owner = idToOwner[_tokenId];\n', '\n', '    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\n', '\n', '    if (bytes(marbleNFTSource.uri).length != 0) {\n', '      uint256 uriHash = _getSourceUriHash(marbleNFTSource.uri);\n', '      delete sourceUriHashToId[uriHash];\n', '      delete idToMarbleNFTSource[_tokenId];\n', '    }\n', '\n', '    _burn(owner, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Tool to manage misstreated NFTs or to be able to extend our services for new cool stuff like auctions, weird games and so on......\n', '   * @param _tokenId ID of the NFT to be update.\n', '   * @param _approved Address to replace current approved address on NFT\n', '   */\n', '  function forceApproval(\n', '    uint256 _tokenId,\n', '    address _approved\n', '  )\n', '    external\n', '    onlyAdmin\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(_approved != tokenOwner,"Owner can not be become new owner!");\n', '\n', '    idToApprovals[_tokenId] = _approved;\n', '    emit Approval(tokenOwner, _approved, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns model of Marble NFT source properties\n', '   * @param _tokenId ID of the NFT\n', '   */\n', '  function tokenSource(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (\n', '      string uri,\n', '      address creator,\n', '      uint256 created)\n', '  {\n', '    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\n', '    return (marbleNFTSource.uri, marbleNFTSource.creator, marbleNFTSource.created);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns token ID related to provided source uri\n', '   * @param _uri URI representing created NFT\n', '   */\n', '  function tokenBySourceUri(string _uri)\n', '    external\n', '    view\n', '    returns (uint256 tokenId)\n', '  {\n', '    return sourceUriHashToId[_getSourceUriHash(_uri)];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whole Marble NFT model\n', '   * --------------------\n', '   *   MARBLE NFT MODEL\n', '   * --------------------\n', '   * uint256 id NFT unique identification\n', '   * string uri NFT source URI, source is whole site what was proccessed by marble to create this NFT, it is URI representation of NFT (call it DNA)\n', '   * string metadataUri  URI pointint to token NFT metadata shcema\n', '   * address owner Current NFT owner\n', '   * address creator First NFT owner\n', '   * uint256 created Date of NFT candidate creation\n', '   *\n', '   * (id, uri, metadataUri, owner, creator, created)\n', '   */\n', '  function getNFT(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns(\n', '      uint256 id,\n', '      string uri,\n', '      string metadataUri,\n', '      address owner,\n', '      address creator,\n', '      uint256 created\n', '    )\n', '  {\n', '\n', '    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\n', '\n', '    return (\n', '      _tokenId,\n', '      marbleNFTSource.uri,\n', '      idToUri[_tokenId],\n', '      idToOwner[_tokenId],\n', '      marbleNFTSource.creator,\n', '      marbleNFTSource.created);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Transforms URI to hash.\n', '   * @param _uri URI to be transformed to hash.\n', '   */\n', '  function getSourceUriHash(string _uri)\n', '     external\n', '     view\n', '     returns(uint256 hash)\n', '  {\n', '     return _getSourceUriHash(_uri);\n', '  }\n', '\n', '  /**\n', '   * @dev Transforms URI to hash.\n', '   * @param _uri URI to be transformed to hash.\n', '   */\n', '  function _getSourceUriHash(string _uri)\n', '    internal\n', '    pure\n', '    returns(uint256 hash)\n', '  {\n', '    return uint256(keccak256(abi.encodePacked(_uri)));\n', '  }\n', '}']