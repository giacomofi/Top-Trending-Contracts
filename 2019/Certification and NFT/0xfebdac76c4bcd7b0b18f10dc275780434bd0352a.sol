['/**\n', ' * @title ImplementationProvider\n', ' * @dev Interface for providing implementation addresses for other contracts by name.\n', ' */\n', 'interface ImplementationProvider {\n', '  /**\n', '   * @dev Abstract function to return the implementation address of a contract.\n', '   * @param contractName Name of the contract.\n', '   * @return Implementation address of the contract.\n', '   */\n', '  function getImplementation(string contractName) public view returns (address);\n', '}\n', '\n', '// File: zos-lib/contracts/ownership/Ownable.sol\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' *\n', ' * Source: https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.0.0/contracts/ownership/Ownable.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n', ' */\n', 'contract ZOSLibOwnable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: zos-lib/contracts/application/Package.sol\n', '\n', '\n', '\n', '/**\n', ' * @title Package\n', ' * @dev A package is composed by a set of versions, identified via semantic versioning,\n', ' * where each version has a contract address that refers to a reusable implementation,\n', ' * plus an optional content URI with metadata. Note that the semver identifier is restricted\n', ' * to major, minor, and patch, as prerelease tags are not supported.\n', ' */\n', 'contract Package is ZOSLibOwnable {\n', '  /**\n', '   * @dev Emitted when a version is added to the package.\n', '   * @param semanticVersion Name of the added version.\n', '   * @param contractAddress Contract associated with the version.\n', '   * @param contentURI Optional content URI with metadata of the version.\n', '   */\n', '  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\n', '\n', '  struct Version {\n', '    uint64[3] semanticVersion;\n', '    address contractAddress;\n', '    bytes contentURI; \n', '  }\n', '\n', '  mapping (bytes32 => Version) internal versions;\n', '  mapping (uint64 => bytes32) internal majorToLatestVersion;\n', '  uint64 internal latestMajor;\n', '\n', '  /**\n', '   * @dev Returns a version given its semver identifier.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return Contract address and content URI for the version, or zero if not exists.\n', '   */\n', '  function getVersion(uint64[3] semanticVersion) public view returns (address contractAddress, bytes contentURI) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return (version.contractAddress, version.contentURI); \n', '  }\n', '\n', '  /**\n', '   * @dev Returns a contract for a version given its semver identifier.\n', '   * This method is equivalent to `getVersion`, but returns only the contract address.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return Contract address for the version, or zero if not exists.\n', '   */\n', '  function getContract(uint64[3] semanticVersion) public view returns (address contractAddress) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return version.contractAddress;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds a new version to the package. Only the Owner can add new versions.\n', '   * Reverts if the specified semver identifier already exists. \n', '   * Emits a `VersionAdded` event if successful.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @param contractAddress Contract address for the version, must be non-zero.\n', '   * @param contentURI Optional content URI for the version.\n', '   */\n', '  function addVersion(uint64[3] semanticVersion, address contractAddress, bytes contentURI) public onlyOwner {\n', '    require(contractAddress != address(0), "Contract address is required");\n', '    require(!hasVersion(semanticVersion), "Given version is already registered in package");\n', '    require(!semanticVersionIsZero(semanticVersion), "Version must be non zero");\n', '\n', '    // Register version\n', '    bytes32 versionId = semanticVersionHash(semanticVersion);\n', '    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\n', '    \n', '    // Update latest major\n', '    uint64 major = semanticVersion[0];\n', '    if (major > latestMajor) {\n', '      latestMajor = semanticVersion[0];\n', '    }\n', '\n', '    // Update latest version for this major\n', '    uint64 minor = semanticVersion[1];\n', '    uint64 patch = semanticVersion[2];\n', '    uint64[3] latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\n', '    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\n', '       || (minor > latestVersionForMajor[1]) // Or current minor is greater \n', '       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\n', '       ) { \n', '      majorToLatestVersion[major] = versionId;\n', '    }\n', '\n', '    emit VersionAdded(semanticVersion, contractAddress, contentURI);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether a version is present in the package.\n', '   * @param semanticVersion Semver identifier of the version.\n', '   * @return true if the version is registered in this package, false otherwise.\n', '   */\n', '  function hasVersion(uint64[3] semanticVersion) public view returns (bool) {\n', '    Version storage version = versions[semanticVersionHash(semanticVersion)];\n', '    return address(version.contractAddress) != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the version with the highest semver identifier registered in the package.\n', '   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless \n', '   * of the order in which they were registered. Returns zero if no versions are registered.\n', '   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n', '   */\n', '  function getLatest() public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '    return getLatestByMajor(latestMajor);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the version with the highest semver identifier for the given major.\n', '   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, \n', '   * regardless of the order in which they were registered. Returns zero if no versions are registered\n', '   * for the specified major.\n', '   * @param major Major identifier to query\n', '   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n', '   */\n', '  function getLatestByMajor(uint64 major) public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\n', '    Version storage version = versions[majorToLatestVersion[major]];\n', '    return (version.semanticVersion, version.contractAddress, version.contentURI); \n', '  }\n', '\n', '  function semanticVersionHash(uint64[3] version) internal pure returns (bytes32) {\n', '    return keccak256(abi.encodePacked(version[0], version[1], version[2]));\n', '  }\n', '\n', '  function semanticVersionIsZero(uint64[3] version) internal pure returns (bool) {\n', '    return version[0] == 0 && version[1] == 0 && version[2] == 0;\n', '  }\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/Proxy.sol\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  function () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', "   * This is a low level function that doesn't return to its internal call site.\n", '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize)\n', '\n', '      // Call the implementation.\n', "      // out and outsize are 0 because we don't know the size yet.\n", '      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize)\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize) }\n', '      default { return(0, returndatasize) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() internal {\n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '// File: zos-lib/contracts/utils/Address.sol\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.0.0/contracts/utils/Address.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n', ' */\n', 'library ZOSLibAddress {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param account address of the account to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address account) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(account) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address indexed implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _implementation Address of the initial implementation.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  constructor(address _implementation, bytes _data) public payable {\n', '    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));\n', '    _setImplementation(_implementation);\n', '    if(_data.length > 0) {\n', '      require(_implementation.delegatecall(_data));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) private {\n', '    require(ZOSLibAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n', '\n', '\n', '\n', '/**\n', ' * @title AdminUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with an authorization\n', ' * mechanism for administrative tasks.\n', ' * All external functions in this contract must be guarded by the\n', ' * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n', ' * feature proposal that would enable this to be done automatically.\n', ' */\n', 'contract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n', '  /**\n', '   * @dev Emitted when the administration has been transferred.\n', '   * @param previousAdmin Address of the previous admin.\n', '   * @param newAdmin Address of the new admin.\n', '   */\n', '  event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '  /**\n', '   * @dev Storage slot with the admin of the contract.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.admin", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n', '\n', '  /**\n', '   * @dev Modifier to check whether the `msg.sender` is the admin.\n', '   * If it is, it will run the function. Otherwise, it will delegate the call\n', '   * to the implementation.\n', '   */\n', '  modifier ifAdmin() {\n', '    if (msg.sender == _admin()) {\n', '      _;\n', '    } else {\n', '      _fallback();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Contract constructor.\n', '   * @param _implementation address of the initial implementation.\n', '   * @param _admin Address of the proxy administrator.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  constructor(address _implementation, address _admin, bytes _data) UpgradeabilityProxy(_implementation, _data) public payable {\n', '    assert(ADMIN_SLOT == keccak256("org.zeppelinos.proxy.admin"));\n', '\n', '    _setAdmin(_admin);\n', '  }\n', '\n', '  /**\n', '   * @return The address of the proxy admin.\n', '   */\n', '  function admin() external view ifAdmin returns (address) {\n', '    return _admin();\n', '  }\n', '\n', '  /**\n', '   * @return The address of the implementation.\n', '   */\n', '  function implementation() external view ifAdmin returns (address) {\n', '    return _implementation();\n', '  }\n', '\n', '  /**\n', '   * @dev Changes the admin of the proxy.\n', '   * Only the current admin can call this function.\n', '   * @param newAdmin Address to transfer proxy administration to.\n', '   */\n', '  function changeAdmin(address newAdmin) external ifAdmin {\n', '    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");\n', '    emit AdminChanged(_admin(), newAdmin);\n', '    _setAdmin(newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrade the backing implementation of the proxy.\n', '   * Only the admin can call this function.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function upgradeTo(address newImplementation) external ifAdmin {\n', '    _upgradeTo(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrade the backing implementation of the proxy and call a function\n', '   * on the new implementation.\n', '   * This is useful to initialize the proxied contract.\n', '   * @param newImplementation Address of the new implementation.\n', '   * @param data Data to send as msg.data in the low level call.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   */\n', '  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\n', '    _upgradeTo(newImplementation);\n', '    require(newImplementation.delegatecall(data));\n', '  }\n', '\n', '  /**\n', '   * @return The admin slot.\n', '   */\n', '  function _admin() internal view returns (address adm) {\n', '    bytes32 slot = ADMIN_SLOT;\n', '    assembly {\n', '      adm := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the address of the proxy admin.\n', '   * @param newAdmin Address of the new proxy admin.\n', '   */\n', '  function _setAdmin(address newAdmin) internal {\n', '    bytes32 slot = ADMIN_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newAdmin)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Only fall back when the sender is not the admin.\n', '   */\n', '  function _willFallback() internal {\n', '    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");\n', '    super._willFallback();\n', '  }\n', '}\n', '\n', '// File: zos-lib/contracts/application/App.sol\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title App\n', ' * @dev Contract for upgradeable applications.\n', ' * It handles the creation of proxies.\n', ' */\n', 'contract App is ZOSLibOwnable {\n', '  /**\n', '   * @dev Emitted when a new proxy is created.\n', '   * @param proxy Address of the created proxy.\n', '   */\n', '  event ProxyCreated(address proxy);\n', '\n', '  /**\n', '   * @dev Emitted when a package dependency is changed in the application.\n', '   * @param providerName Name of the package that changed.\n', '   * @param package Address of the package associated to the name.\n', '   * @param version Version of the package in use.\n', '   */\n', '  event PackageChanged(string providerName, address package, uint64[3] version);\n', '\n', '  /**\n', '   * @dev Tracks a package in a particular version, used for retrieving implementations\n', '   */\n', '  struct ProviderInfo {\n', '    Package package;\n', '    uint64[3] version;\n', '  }\n', '\n', '  /**\n', '   * @dev Maps from dependency name to a tuple of package and version\n', '   */\n', '  mapping(string => ProviderInfo) internal providers;\n', '\n', '  /**\n', '   * @dev Constructor function.\n', '   */\n', '  constructor() public { }\n', '\n', '  /**\n', '   * @dev Returns the provider for a given package name, or zero if not set.\n', '   * @param packageName Name of the package to be retrieved.\n', '   * @return The provider.\n', '   */\n', '  function getProvider(string packageName) public view returns (ImplementationProvider provider) {\n', '    ProviderInfo storage info = providers[packageName];\n', '    if (address(info.package) == address(0)) return ImplementationProvider(0);\n', '    return ImplementationProvider(info.package.getContract(info.version));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns information on a package given its name.\n', '   * @param packageName Name of the package to be queried.\n', '   * @return A tuple with the package address and pinned version given a package name, or zero if not set\n', '   */\n', '  function getPackage(string packageName) public view returns (Package, uint64[3]) {\n', '    ProviderInfo storage info = providers[packageName];\n', '    return (info.package, info.version);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets a package in a specific version as a dependency for this application.\n', '   * Requires the version to be present in the package.\n', '   * @param packageName Name of the package to set or overwrite.\n', '   * @param package Address of the package to register.\n', '   * @param version Version of the package to use in this application.\n', '   */\n', '  function setPackage(string packageName, Package package, uint64[3] version) public onlyOwner {\n', '    require(package.hasVersion(version), "The requested version must be registered in the given package");\n', '    providers[packageName] = ProviderInfo(package, version);\n', '    emit PackageChanged(packageName, package, version);\n', '  }\n', '\n', '  /**\n', '   * @dev Unsets a package given its name.\n', '   * Reverts if the package is not set in the application.\n', '   * @param packageName Name of the package to remove.\n', '   */\n', '  function unsetPackage(string packageName) public onlyOwner {\n', '    require(address(providers[packageName].package) != address(0), "Package to unset not found");\n', '    delete providers[packageName];\n', '    emit PackageChanged(packageName, address(0), [uint64(0), uint64(0), uint64(0)]);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.\n', '   * @param packageName Name of the package where the contract is contained.\n', '   * @param contractName Name of the contract.\n', '   * @return Address where the contract is implemented.\n', '   */\n', '  function getImplementation(string packageName, string contractName) public view returns (address) {\n', '    ImplementationProvider provider = getProvider(packageName);\n', '    if (address(provider) == address(0)) return address(0);\n', '    return provider.getImplementation(contractName);\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a new proxy for the given contract and forwards a function call to it.\n', '   * This is useful to initialize the proxied contract.\n', '   * @param packageName Name of the package where the contract is contained.\n', '   * @param contractName Name of the contract.\n', '   * @param admin Address of the proxy administrator.\n', '   * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   * @return Address of the new proxy.\n', '   */\n', '   function create(string packageName, string contractName, address admin, bytes data) payable public returns (AdminUpgradeabilityProxy) {\n', '     address implementation = getImplementation(packageName, contractName);\n', '     AdminUpgradeabilityProxy proxy = (new AdminUpgradeabilityProxy).value(msg.value)(implementation, admin, data);\n', '     emit ProxyCreated(proxy);\n', '     return proxy;\n', '  }\n', '}']