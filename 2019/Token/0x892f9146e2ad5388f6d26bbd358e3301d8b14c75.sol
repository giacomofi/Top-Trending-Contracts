['pragma solidity ^0.5.1;\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, ""); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param owner The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(value <= _balances[msg.sender], "");\n', '        require(to != address(0), "");\n', '\n', '        _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0), "");\n', '\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(value <= _balances[from], "");\n', '        require(value <= _allowed[from][msg.sender], "");\n', '        require(to != address(0), "");\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(\n', '        address spender,\n', '        uint256 addedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(spender != address(0), "");\n', '\n', '        _allowed[msg.sender][spender] = (\n', '            _allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(\n', '        address spender,\n', '        uint256 subtractedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(spender != address(0), "");\n', '\n', '        _allowed[msg.sender][spender] = (\n', '            _allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param amount The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param amount The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "");\n', '        require(amount <= _balances[account], "");\n', '\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[account] = _balances[account].sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param amount The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        require(amount <= _allowed[account][msg.sender], "");\n', '\n', '        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n', '        // this function needs to emit an event with the updated approval.\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n', '            amount);\n', '        _burn(account, amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BaseSecurityToken implementation\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-1462\n', ' */\n', 'contract BaseSecurityToken is ERC20 {\n', '    \n', '    struct Document {\n', '        bytes32 name;\n', '        string uri;\n', '        bytes32 contentHash;\n', '    }\n', '\n', '    mapping (bytes32 => Document) private documents;\n', '\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(checkTransferAllowed(msg.sender, to, value) == STATUS_ALLOWED, "transfer must be allowed");\n', '        return ERC20.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        require(checkTransferFromAllowed(from, to, value) == STATUS_ALLOWED, "transfer must be allowed");\n', '        return ERC20.transferFrom(from, to, value);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(checkMintAllowed(account, amount) == STATUS_ALLOWED, "mint must be allowed");\n', '        ERC20._mint(account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(checkBurnAllowed(account, amount) == STATUS_ALLOWED, "burn must be allowed");\n', '        ERC20._burn(account, amount);\n', '    }\n', '\n', '    function attachDocument(bytes32 _name, string calldata _uri, bytes32 _contentHash) external {\n', '        require(_name.length > 0, "name of the document must not be empty");\n', '        require(bytes(_uri).length > 0, "external URI to the document must not be empty");\n', '        require(_contentHash.length > 0, "content hash is required, use SHA-256 when in doubt");\n', '        require(documents[_name].name.length == 0, "document must not be existing under the same name");\n', '        documents[_name] = Document(_name, _uri, _contentHash);\n', '    }\n', '   \n', '    function lookupDocument(bytes32 _name) external view returns (string memory, bytes32) {\n', '        Document storage doc = documents[_name];\n', '        return (doc.uri, doc.contentHash);\n', '    }\n', '\n', '    // Use status codes from:\n', '    // https://eips.ethereum.org/EIPS/eip-1066\n', '    byte private STATUS_ALLOWED = 0x11;\n', '\n', '    function checkTransferAllowed(address, address, uint256) public view returns (byte) {\n', '        return STATUS_ALLOWED;\n', '    }\n', '   \n', '    function checkTransferFromAllowed(address, address, uint256) public view returns (byte) {\n', '        return STATUS_ALLOWED;\n', '    }\n', '   \n', '    function checkMintAllowed(address, uint256) public view returns (byte) {\n', '        return STATUS_ALLOWED;\n', '    }\n', '   \n', '    function checkBurnAllowed(address, uint256) public view returns (byte) {\n', '        return STATUS_ALLOWED;\n', '    }\n', '}\n', '\n', 'contract LockRequestable {\n', '\n', '        // MEMBERS\n', '        /// @notice  the count of all invocations of `generateLockId`.\n', '        uint256 public lockRequestCount;\n', '\n', '        constructor() public {\n', '                lockRequestCount = 0;\n', '        }\n', '\n', '        // FUNCTIONS\n', '        /** @notice  Returns a fresh unique identifier.\n', '            *\n', '            * @dev the generation scheme uses three components.\n', '            * First, the blockhash of the previous block.\n', '            * Second, the deployed address.\n', '            * Third, the next value of the counter.\n', '            * This ensure that identifiers are unique across all contracts\n', '            * following this scheme, and that future identifiers are\n', '            * unpredictable.\n', '            *\n', '            * @return a 32-byte unique identifier.\n', '            */\n', '        function generateLockId() internal returns (bytes32 lockId) {\n', '                return keccak256(\n', '                abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount)\n', '                );\n', '        }\n', '}\n', '\n', 'contract CustodianUpgradeable is LockRequestable {\n', '\n', '        // TYPES\n', '        /// @dev  The struct type for pending custodian changes.\n', '        struct CustodianChangeRequest {\n', '                address proposedNew;\n', '        }\n', '\n', '        // MEMBERS\n', '        /// @dev  The address of the account or contract that acts as the custodian.\n', '        address public custodian;\n', '\n', '        /// @dev  The map of lock ids to pending custodian changes.\n', '        mapping (bytes32 => CustodianChangeRequest) public custodianChangeReqs;\n', '\n', '        constructor(address _custodian) public LockRequestable() {\n', '                custodian = _custodian;\n', '        }\n', '\n', '        // MODIFIERS\n', '        modifier onlyCustodian {\n', '                require(msg.sender == custodian);\n', '                _;\n', '        }\n', '\n', '        /** @notice  Requests a change of the custodian associated with this contract.\n', '            *\n', '            * @dev  Returns a unique lock id associated with the request.\n', '            * Anyone can call this function, but confirming the request is authorized\n', '            * by the custodian.\n', '            *\n', '            * @param  _proposedCustodian  The address of the new custodian.\n', '            * @return  lockId  A unique identifier for this request.\n', '            */\n', '        function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n', '                require(_proposedCustodian != address(0));\n', '\n', '                lockId = generateLockId();\n', '\n', '                custodianChangeReqs[lockId] = CustodianChangeRequest({\n', '                        proposedNew: _proposedCustodian\n', '                });\n', '\n', '                emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n', '        }\n', '\n', '        /** @notice  Confirms a pending change of the custodian associated with this contract.\n', '            *\n', '            * @dev  When called by the current custodian with a lock id associated with a\n', '            * pending custodian change, the `address custodian` member will be updated with the\n', '            * requested address.\n', '            *\n', '            * @param  _lockId  The identifier of a pending change request.\n', '            */\n', '        function confirmCustodianChange(bytes32 _lockId) public onlyCustodian {\n', '                custodian = getCustodianChangeReq(_lockId);\n', '\n', '                delete custodianChangeReqs[_lockId];\n', '\n', '                emit CustodianChangeConfirmed(_lockId, custodian);\n', '        }\n', '\n', '        // PRIVATE FUNCTIONS\n', '        function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\n', '                CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\n', '\n', '                // reject ‘null’ results from the map lookup\n', '                // this can only be the case if an unknown `_lockId` is received\n', '                require(changeRequest.proposedNew != address(0));\n', '\n', '                return changeRequest.proposedNew;\n', '        }\n', '\n', '        /// @dev  Emitted by successful `requestCustodianChange` calls.\n', '        event CustodianChangeRequested(\n', '                bytes32 _lockId,\n', '                address _msgSender,\n', '                address _proposedCustodian\n', '        );\n', '\n', '        /// @dev Emitted by successful `confirmCustodianChange` calls.\n', '        event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\n', '}\n', '\n', 'interface ServiceRegistry {\n', '    function getService(string calldata _name) external view returns (address);\n', '}\n', '\n', 'contract ServiceDiscovery {\n', '    ServiceRegistry internal services;\n', '\n', '    constructor(ServiceRegistry _services) public {\n', '        services = ServiceRegistry(_services);\n', '    }\n', '}\n', '\n', 'contract KnowYourCustomer is CustodianUpgradeable {\n', '\n', '    enum Status {\n', '        none,\n', '        passed,\n', '        suspended\n', '    }\n', '\n', '    struct Customer {\n', '        Status status;\n', '        mapping(string => string) fields;\n', '    }\n', '    \n', '    event ProviderAuthorized(address indexed _provider, string _name);\n', '    event ProviderRemoved(address indexed _provider, string _name);\n', '    event CustomerApproved(address indexed _customer, address indexed _provider);\n', '    event CustomerSuspended(address indexed _customer, address indexed _provider);\n', '    event CustomerFieldSet(address indexed _customer, address indexed _field, string _name);\n', '\n', '    mapping(address => bool) private providers;\n', '    mapping(address => Customer) private customers;\n', '\n', '    constructor(address _custodian) public CustodianUpgradeable(_custodian) {\n', '        customers[_custodian].status = Status.passed;\n', '        customers[_custodian].fields["type"] = "custodian";\n', '        emit CustomerApproved(_custodian, msg.sender);\n', '        emit CustomerFieldSet(_custodian, msg.sender, "type");\n', '    }\n', '\n', '    function providerAuthorize(address _provider, string calldata name) external onlyCustodian {\n', '        require(providers[_provider] == false, "provider must not exist");\n', '        providers[_provider] = true;\n', '        // cc:II. Manage Providers#2;Provider becomes authorized in contract;1;\n', '        emit ProviderAuthorized(_provider, name);\n', '    }\n', '\n', '    function providerRemove(address _provider, string calldata name) external onlyCustodian {\n', '        require(providers[_provider] == true, "provider must exist");\n', '        delete providers[_provider];\n', '        emit ProviderRemoved(_provider, name);\n', '    }\n', '\n', '    function hasWritePermissions(address _provider) external view returns (bool) {\n', '        return _provider == custodian || providers[_provider] == true;\n', '    }\n', '\n', '    function getCustomerStatus(address _customer) external view returns (Status) {\n', '        return customers[_customer].status;\n', '    }\n', '\n', '    function getCustomerField(address _customer, string calldata _field) external view returns (string memory) {\n', '        return customers[_customer].fields[_field];\n', '    }\n', '\n', '    function approveCustomer(address _customer) external onlyAuthorized {\n', '        Status status = customers[_customer].status;\n', '        require(status != Status.passed, "customer must not be approved before");\n', '        customers[_customer].status = Status.passed;\n', '        // cc:III. Manage Customers#2;Customer becomes approved in contract;1;\n', '        emit CustomerApproved(_customer, msg.sender);\n', '    }\n', '\n', '    function setCustomerField(address _customer, string calldata _field, string calldata _value) external onlyAuthorized {\n', '        Status status = customers[_customer].status;\n', '        require(status != Status.none, "customer must have a set status");\n', '        customers[_customer].fields[_field] = _value;\n', '        emit CustomerFieldSet(_customer, msg.sender, _field);\n', '    }\n', '\n', '    function suspendCustomer(address _customer) external onlyAuthorized {\n', '        Status status = customers[_customer].status;\n', '        require(status != Status.suspended, "customer must be not suspended");\n', '        customers[_customer].status = Status.suspended;\n', '        emit CustomerSuspended(_customer, msg.sender);\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        require(msg.sender == custodian || providers[msg.sender] == true);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract TokenSettingsInterface {\n', '\n', '    // METHODS\n', '    function getTradeAllowed() public view returns (bool);\n', '    function getMintAllowed() public view returns (bool);\n', '    function getBurnAllowed() public view returns (bool);\n', '    \n', '    // EVENTS\n', '    event TradeAllowedLocked(bytes32 _lockId, bool _newValue);\n', '    event TradeAllowedConfirmed(bytes32 _lockId, bool _newValue);\n', '    event MintAllowedLocked(bytes32 _lockId, bool _newValue);\n', '    event MintAllowedConfirmed(bytes32 _lockId, bool _newValue);\n', '    event BurnAllowedLocked(bytes32 _lockId, bool _newValue);\n', '    event BurnAllowedConfirmed(bytes32 _lockId, bool _newValue);\n', '\n', '    // MODIFIERS\n', '    modifier onlyCustodian {\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract _BurnAllowed is TokenSettingsInterface, LockRequestable {\n', '    // cc:IV. BurnAllowed Setting#2;Burn Allowed Switch;1;\n', '    //\n', '    // SETTING: Burn Allowed Switch (bool)\n', '    // Boundary: true or false\n', '    //\n', '    // Enables or disables token minting ability globally (even for custodian).\n', '    //\n', '    bool private burnAllowed = false;\n', '\n', '    function getBurnAllowed() public view returns (bool) {\n', '        return burnAllowed;\n', '    }\n', '\n', '    // SETTING MANAGEMENT\n', '\n', '    struct PendingBurnAllowed {\n', '        bool burnAllowed;\n', '        bool set;\n', '    }\n', '\n', '    mapping (bytes32 => PendingBurnAllowed) public pendingBurnAllowedMap;\n', '\n', '    function requestBurnAllowedChange(bool _burnAllowed) public returns (bytes32 lockId) {\n', '       require(_burnAllowed != burnAllowed);\n', '       \n', '       lockId = generateLockId();\n', '       pendingBurnAllowedMap[lockId] = PendingBurnAllowed({\n', '           burnAllowed: _burnAllowed,\n', '           set: true\n', '       });\n', '\n', '       emit BurnAllowedLocked(lockId, _burnAllowed);\n', '    }\n', '\n', '    function confirmBurnAllowedChange(bytes32 _lockId) public onlyCustodian {\n', '        PendingBurnAllowed storage value = pendingBurnAllowedMap[_lockId];\n', '        require(value.set == true);\n', '        burnAllowed = value.burnAllowed;\n', '        emit BurnAllowedConfirmed(_lockId, value.burnAllowed);\n', '        delete pendingBurnAllowedMap[_lockId];\n', '    }\n', '}\n', '\n', '\n', 'contract _MintAllowed is TokenSettingsInterface, LockRequestable {\n', '    // cc:III. MintAllowed Setting#2;Mint Allowed Switch;1;\n', '    //\n', '    // SETTING: Mint Allowed Switch (bool)\n', '    // Boundary: true or false\n', '    //\n', '    // Enables or disables token minting ability globally (even for custodian).\n', '    //\n', '    bool private mintAllowed = false;\n', '\n', '    function getMintAllowed() public view returns (bool) {\n', '        return mintAllowed;\n', '    }\n', '\n', '    // SETTING MANAGEMENT\n', '\n', '    struct PendingMintAllowed {\n', '        bool mintAllowed;\n', '        bool set;\n', '    }\n', '\n', '    mapping (bytes32 => PendingMintAllowed) public pendingMintAllowedMap;\n', '\n', '    function requestMintAllowedChange(bool _mintAllowed) public returns (bytes32 lockId) {\n', '       require(_mintAllowed != mintAllowed);\n', '       \n', '       lockId = generateLockId();\n', '       pendingMintAllowedMap[lockId] = PendingMintAllowed({\n', '           mintAllowed: _mintAllowed,\n', '           set: true\n', '       });\n', '\n', '       emit MintAllowedLocked(lockId, _mintAllowed);\n', '    }\n', '\n', '    function confirmMintAllowedChange(bytes32 _lockId) public onlyCustodian {\n', '        PendingMintAllowed storage value = pendingMintAllowedMap[_lockId];\n', '        require(value.set == true);\n', '        mintAllowed = value.mintAllowed;\n', '        emit MintAllowedConfirmed(_lockId, value.mintAllowed);\n', '        delete pendingMintAllowedMap[_lockId];\n', '    }\n', '}\n', '\n', '\n', 'contract _TradeAllowed is TokenSettingsInterface, LockRequestable {\n', '    // cc:II. TradeAllowed Setting#2;Trade Allowed Switch;1;\n', '    //\n', '    // SETTING: Trade Allowed Switch (bool)\n', '    // Boundary: true or false\n', '    //\n', '    // Enables or disables all token transfers, between any recipients, except mint and burn operations.\n', '    //\n', '    bool private tradeAllowed = false;\n', '\n', '    function getTradeAllowed() public view returns (bool) {\n', '        return tradeAllowed;\n', '    }\n', '\n', '    // SETTING MANAGEMENT\n', '\n', '    struct PendingTradeAllowed {\n', '        bool tradeAllowed;\n', '        bool set;\n', '    }\n', '\n', '    mapping (bytes32 => PendingTradeAllowed) public pendingTradeAllowedMap;\n', '\n', '    function requestTradeAllowedChange(bool _tradeAllowed) public returns (bytes32 lockId) {\n', '       require(_tradeAllowed != tradeAllowed);\n', '       \n', '       lockId = generateLockId();\n', '       pendingTradeAllowedMap[lockId] = PendingTradeAllowed({\n', '           tradeAllowed: _tradeAllowed,\n', '           set: true\n', '       });\n', '\n', '       emit TradeAllowedLocked(lockId, _tradeAllowed);\n', '    }\n', '\n', '    function confirmTradeAllowedChange(bytes32 _lockId) public onlyCustodian {\n', '        PendingTradeAllowed storage value = pendingTradeAllowedMap[_lockId];\n', '        require(value.set == true);\n', '        tradeAllowed = value.tradeAllowed;\n', '        emit TradeAllowedConfirmed(_lockId, value.tradeAllowed);\n', '        delete pendingTradeAllowedMap[_lockId];\n', '    }\n', '}\n', '\n', 'contract TokenSettings is TokenSettingsInterface, CustodianUpgradeable,\n', '_TradeAllowed,\n', '_MintAllowed,\n', '_BurnAllowed\n', '    {\n', '    constructor(address _custodian) public CustodianUpgradeable(_custodian) {\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title TokenController implements restriction logic for BaseSecurityToken.\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-1462\n', ' */\n', 'contract TokenController is CustodianUpgradeable, ServiceDiscovery {\n', '    constructor(address _custodian, ServiceRegistry _services) public\n', '    CustodianUpgradeable(_custodian) ServiceDiscovery(_services) {\n', '    }\n', '\n', '    // Use status codes from:\n', '    // https://eips.ethereum.org/EIPS/eip-1066\n', '    byte private constant STATUS_ALLOWED = 0x11;\n', '\n', '    function checkTransferAllowed(address _from, address _to, uint256) public view returns (byte) {\n', '        require(_settings().getTradeAllowed(), "global trade must be allowed");\n', '        require(_kyc().getCustomerStatus(_from) == KnowYourCustomer.Status.passed, "sender does not have valid KYC status");\n', '        require(_kyc().getCustomerStatus(_to) == KnowYourCustomer.Status.passed, "recipient does not have valid KYC status");\n', '\n', '        // TODO:\n', "        // Check user's region\n", '        // Check amount for transfer limits\n', '\n', '        return STATUS_ALLOWED;\n', '    }\n', '   \n', '    function checkTransferFromAllowed(address _from, address _to, uint256 _amount) external view returns (byte) {\n', '        return checkTransferAllowed(_from, _to, _amount);\n', '    }\n', '   \n', '    function checkMintAllowed(address _from, uint256) external view returns (byte) {\n', '        require(_settings().getMintAllowed(), "global mint must be allowed");\n', '        require(_kyc().getCustomerStatus(_from) == KnowYourCustomer.Status.passed, "recipient does not have valid KYC status");\n', '        \n', '        return STATUS_ALLOWED;\n', '    }\n', '   \n', '    function checkBurnAllowed(address _from, uint256) external view returns (byte) {\n', '        require(_settings().getBurnAllowed(), "global burn must be allowed");\n', '        require(_kyc().getCustomerStatus(_from) == KnowYourCustomer.Status.passed, "sender does not have valid KYC status");\n', '\n', '        return STATUS_ALLOWED;\n', '    }\n', '\n', '    function _settings() private view returns (TokenSettings) {\n', '        return TokenSettings(services.getService("token/settings"));\n', '    }\n', '\n', '    function _kyc() private view returns (KnowYourCustomer) {\n', '        return KnowYourCustomer(services.getService("validators/kyc"));\n', '    }\n', '}\n', '\n', 'contract BaRA is BaseSecurityToken, CustodianUpgradeable, ServiceDiscovery {\n', '    \n', '    uint public limit = 400 * 1e6;\n', '    string public name = "Banksia BioPharm Security Token";\n', '    string public symbol = "BaRA";\n', '    uint8 public decimals = 0;\n', '\n', '    constructor(address _custodian, ServiceRegistry _services,\n', '        string memory _name, string memory _symbol, uint _limit) public \n', '        CustodianUpgradeable(_custodian) ServiceDiscovery(_services) {\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        limit = _limit;\n', '    }\n', '\n', '    function mint(address _to, uint _amount) public onlyCustodian {\n', '        require(_amount != 0, "check amount to mint");\n', '        require(super.totalSupply() + _amount <= limit, "check total supply after mint");\n', '        BaseSecurityToken._mint(_to, _amount);\n', '    }\n', '\n', '    function checkTransferAllowed (address _from, address _to, uint256 _amount) public view returns (byte) {\n', '        return _controller().checkTransferAllowed(_from, _to, _amount);\n', '    }\n', '   \n', '    function checkTransferFromAllowed (address _from, address _to, uint256 _amount) public view returns (byte) {\n', '        return _controller().checkTransferFromAllowed(_from, _to, _amount);\n', '    }\n', '   \n', '    function checkMintAllowed (address _from, uint256 _amount) public view returns (byte) {\n', '        return _controller().checkMintAllowed(_from, _amount);\n', '    }\n', '   \n', '    function checkBurnAllowed (address _from, uint256 _amount) public view returns (byte) {\n', '        return _controller().checkBurnAllowed(_from, _amount);\n', '    }\n', '\n', '    function _controller() private view returns (TokenController) {\n', '        return TokenController(services.getService("token/controller"));\n', '    }\n', '}']