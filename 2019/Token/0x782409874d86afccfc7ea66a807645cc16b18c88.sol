['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-11\n', '*/\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    address newOwner = address(0x0);\n', '\n', '    modifier isOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    function changeOwner(address _newOwner) public isOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0x0);\n', '    }\n', '\n', '}\n', '\n', 'contract Controlled is Owned {\n', '\n', '    bool public transferEnable = true;\n', '\n', '    bool public lockFlag = true;\n', '\n', '    constructor() public {\n', '       setExclude(msg.sender);\n', '    }\n', '\n', '    mapping(address => bool) public locked;\n', '\n', '    mapping(address => bool) public exclude;\n', '\n', '    function disableLock(bool _enable) public isOwner returns (bool success){\n', '        lockFlag = _enable;\n', '        return true;\n', '    }\n', '\n', '    function enableTransfer(bool _enable) public isOwner{\n', '        transferEnable = _enable;\n', '    }\n', '\n', '    function addLock(address _addr) public isOwner returns (bool success){\n', '        require(_addr != msg.sender);\n', '        locked[_addr] = true;\n', '        return true;\n', '    }\n', '\n', '    function setExclude(address _addr) public isOwner returns (bool success){\n', '        exclude[_addr] = true;\n', '        return true;\n', '    }\n', '\n', '    function removeLock(address _addr) public isOwner returns (bool success){\n', '        locked[_addr] = false;\n', '        return true;\n', '    }\n', '\n', '    modifier transferAllowed(address _addr) {\n', '        if (!exclude[_addr]) {\n', '            assert(transferEnable);\n', '            if(lockFlag){\n', '                assert(!locked[_addr]);\n', '            }\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _addr) {\n', '        assert(address(0x0) != _addr && address(0x0) != msg.sender);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract StandardToken is Token, Controlled {\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public transferAllowed(msg.sender) validAddress(_to) returns (bool success) {\n', '        require(_value > 0);\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public transferAllowed(msg.sender) validAddress(_to) returns (bool success) {\n', '        require(_value > 0);\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(_value > 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract Currency is StandardToken {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '\n', '    constructor (address _addr, uint256 initialSupply, string memory _tokenName, string memory _tokenSymbol) public {\n', '        setExclude(_addr);\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '        balances[_addr] = totalSupply;\n', '        name = _tokenName;\n', '        symbol = _tokenSymbol;\n', '    }\n', '\n', '}']