['pragma solidity ^0.5.9;\n', '\n', '/**\n', '* @title Math\n', '* @dev Assorted math operations\n', '*/\n', 'library Math {\n', '/**\n', '* @dev Returns the largest of two numbers.\n', '*/\n', 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'return a >= b ? a : b;\n', '}\n', '\n', '/**\n', '* @dev Returns the smallest of two numbers.\n', '*/\n', 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'return a < b ? a : b;\n', '}\n', '\n', '/**\n', '* @dev Calculates the average of two numbers. Since these are integers,\n', '* averages of an even and odd number cannot be represented, and will be\n', '* rounded down.\n', '*/\n', 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '// (a + b) / 2 can overflow, so we distribute\n', 'return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '}\n', '}\n', '\n', '\n', '/**\n', '* @title Roles\n', '* @dev Library for managing addresses assigned to a Role.\n', '*/\n', 'library Roles {\n', 'struct Role {\n', 'mapping (address => bool) bearer;\n', '}\n', '\n', '/**\n', '* @dev give an account access to this role\n', '*/\n', 'function add(Role storage role, address account) internal {\n', 'require(account != address(0));\n', 'require(!has(role, account));\n', '\n', 'role.bearer[account] = true;\n', '}\n', '\n', '/**\n', "* @dev remove an account's access to this role\n", '*/\n', 'function remove(Role storage role, address account) internal {\n', 'require(account != address(0));\n', 'require(has(role, account));\n', '\n', 'role.bearer[account] = false;\n', '}\n', '\n', '/**\n', '* @dev check if an account has this role\n', '* @return bool\n', '*/\n', 'function has(Role storage role, address account) internal view returns (bool) {\n', 'require(account != address(0));\n', 'return role.bearer[account];\n', '}\n', '}\n', '\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Unsigned math operations with safety checks that revert on error\n', '*/\n', 'library SafeMath {\n', '/**\n', '* @dev Multiplies two unsigned integers, reverts on overflow.\n', '*/\n', 'function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "// benefit is lost if 'b' is also tested.\n", '// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', 'if (a == 0) {\n', 'return 0;\n', '}\n', '\n', 'uint256 c = a * b;\n', 'require(c / a == b);\n', '\n', 'return c;\n', '}\n', '\n', '/**\n', '* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '*/\n', 'function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '// Solidity only automatically asserts when dividing by 0\n', 'require(b > 0);\n', 'uint256 c = a / b;\n', "// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', 'return c;\n', '}\n', '\n', '/**\n', '* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '*/\n', 'function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b <= a);\n', 'uint256 c = a - b;\n', '\n', 'return c;\n', '}\n', '\n', '/**\n', '* @dev Adds two unsigned integers, reverts on overflow.\n', '*/\n', 'function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'uint256 c = a + b;\n', 'require(c >= a);\n', '\n', 'return c;\n', '}\n', '\n', '/**\n', '* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '* reverts when dividing by zero.\n', '*/\n', 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b != 0);\n', 'return a % b;\n', '}\n', '}\n', '\n', '\n', '\n', '\n', 'contract MinterRole {\n', 'using Roles for Roles.Role;\n', '\n', 'event MinterAdded(address indexed account);\n', 'event MinterRemoved(address indexed account);\n', '\n', 'Roles.Role private _minters;\n', '\n', 'constructor () internal {\n', '_addMinter(msg.sender);\n', '}\n', '\n', 'modifier onlyMinter() {\n', 'require(isMinter(msg.sender));\n', '_;\n', '}\n', '\n', 'function isMinter(address account) public view returns (bool) {\n', 'return _minters.has(account);\n', '}\n', '\n', 'function addMinter(address account) public onlyMinter {\n', '_addMinter(account);\n', '}\n', '\n', 'function renounceMinter() public {\n', '_removeMinter(msg.sender);\n', '}\n', '\n', 'function _addMinter(address account) internal {\n', '_minters.add(account);\n', 'emit MinterAdded(account);\n', '}\n', '\n', 'function _removeMinter(address account) internal {\n', '_minters.remove(account);\n', 'emit MinterRemoved(account);\n', '}\n', '}\n', '\n', '\n', '/**\n', '* @title ERC20 interface\n', '* @dev see https://eips.ethereum.org/EIPS/eip-20\n', '*/\n', 'interface IERC20 {\n', 'function transfer(address to, uint256 value) external returns (bool);\n', '\n', 'function approve(address spender, uint256 value) external returns (bool);\n', '\n', 'function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', 'function totalSupply() external view returns (uint256);\n', '\n', 'function balanceOf(address who) external view returns (uint256);\n', '\n', 'function allowance(address owner, address spender) external view returns (uint256);\n', '\n', 'event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', 'event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', 'function receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Standard ERC20 token\n', '*\n', '* @dev Implementation of the basic standard token.\n', '* https://eips.ethereum.org/EIPS/eip-20\n', '* Originally based on code by FirstBlood:\n', '* https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', '*\n', '* This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', "* all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", '* compliant implementations may not do it.\n', '*/\n', 'contract ERC20 is IERC20 {\n', 'using SafeMath for uint256;\n', '\n', 'mapping (address => uint256) private _balances;\n', '\n', 'mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', 'uint256 private _totalSupply;\n', '\n', '/**\n', '* @dev Total number of tokens in existence\n', '*/\n', 'function totalSupply() public view returns (uint256) {\n', 'return _totalSupply;\n', '}\n', '\n', '/**\n', '* @dev Gets the balance of the specified address.\n', '* @param owner The address to query the balance of.\n', '* @return A uint256 representing the amount owned by the passed address.\n', '*/\n', 'function balanceOf(address owner) public view returns (uint256) {\n', 'return _balances[owner];\n', '}\n', '\n', '/**\n', '* @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '* @param owner address The address which owns the funds.\n', '* @param spender address The address which will spend the funds.\n', '* @return A uint256 specifying the amount of tokens still available for the spender.\n', '*/\n', 'function allowance(address owner, address spender) public view returns (uint256) {\n', 'return _allowed[owner][spender];\n', '}\n', '\n', '/**\n', '* @dev Transfer token to a specified address\n', '* @param to The address to transfer to.\n', '* @param value The amount to be transferred.\n', '*/\n', 'function transfer(address to, uint256 value) public returns (bool) {\n', '_transfer(msg.sender, to, value);\n', 'return true;\n', '}\n', '\n', '/**\n', '* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '* Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '* @param spender The address which will spend the funds.\n', '* @param value The amount of tokens to be spent.\n', '*/\n', 'function approve(address spender, uint256 value) public returns (bool) {\n', '_approve(msg.sender, spender, value);\n', 'return true;\n', '}\n', '\n', '/**\n', '* @dev Transfer tokens from one address to another.\n', '* Note that while this function emits an Approval event, this is not required as per the specification,\n', '* and other compliant implementations may not emit the event.\n', '* @param from address The address which you want to send tokens from\n', '* @param to address The address which you want to transfer to\n', '* @param value uint256 the amount of tokens to be transferred\n', '*/\n', 'function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '_transfer(from, to, value);\n', '_approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', 'return true;\n', '}\n', '\n', '/**\n', '* @dev Increase the amount of tokens that an owner allowed to a spender.\n', '* approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '* allowed value is better to use this function to avoid 2 calls (and wait until\n', '* the first transaction is mined)\n', '* From MonolithDAO Token.sol\n', '* Emits an Approval event.\n', '* @param spender The address which will spend the funds.\n', '* @param addedValue The amount of tokens to increase the allowance by.\n', '*/\n', 'function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '_approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', 'return true;\n', '}\n', '\n', '/**\n', '* @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '* approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '* allowed value is better to use this function to avoid 2 calls (and wait until\n', '* the first transaction is mined)\n', '* From MonolithDAO Token.sol\n', '* Emits an Approval event.\n', '* @param spender The address which will spend the funds.\n', '* @param subtractedValue The amount of tokens to decrease the allowance by.\n', '*/\n', 'function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '_approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', 'return true;\n', '}\n', '\n', '/**\n', '* @dev Transfer token for a specified addresses\n', '* @param from The address to transfer from.\n', '* @param to The address to transfer to.\n', '* @param value The amount to be transferred.\n', '*/\n', 'function _transfer(address from, address to, uint256 value) internal {\n', 'require(to != address(0));\n', '\n', '_balances[from] = _balances[from].sub(value);\n', '_balances[to] = _balances[to].add(value);\n', 'emit Transfer(from, to, value);\n', '}\n', '\n', '/**\n', '* @dev Internal function that mints an amount of the token and assigns it to\n', '* an account. This encapsulates the modification of balances such that the\n', '* proper events are emitted.\n', '* @param account The account that will receive the created tokens.\n', '* @param value The amount that will be created.\n', '*/\n', 'function _mint(address account, uint256 value) internal {\n', 'require(account != address(0));\n', '\n', '_totalSupply = _totalSupply.add(value);\n', '_balances[account] = _balances[account].add(value);\n', 'emit Transfer(address(0), account, value);\n', '}\n', '\n', '/**\n', '* @dev Internal function that burns an amount of the token of a given\n', '* account.\n', '* @param account The account whose tokens will be burnt.\n', '* @param value The amount that will be burnt.\n', '*/\n', 'function _burn(address account, uint256 value) internal {\n', 'require(account != address(0));\n', '\n', '_totalSupply = _totalSupply.sub(value);\n', '_balances[account] = _balances[account].sub(value);\n', 'emit Transfer(account, address(0), value);\n', '}\n', '\n', '/**\n', "* @dev Approve an address to spend another addresses' tokens.\n", '* @param owner The address that owns the tokens.\n', '* @param spender The address that will spend the tokens.\n', '* @param value The number of tokens that can be spent.\n', '*/\n', 'function _approve(address owner, address spender, uint256 value) internal {\n', 'require(spender != address(0));\n', 'require(owner != address(0));\n', '\n', '_allowed[owner][spender] = value;\n', 'emit Approval(owner, spender, value);\n', '}\n', '\n', '/**\n', '* @dev Internal function that burns an amount of the token of a given\n', "* account, deducting from the sender's allowance for said account. Uses the\n", '* internal burn function.\n', '* Emits an Approval event (reflecting the reduced allowance).\n', '* @param account The account whose tokens will be burnt.\n', '* @param value The amount that will be burnt.\n', '*/\n', 'function _burnFrom(address account, uint256 value) internal {\n', '_burn(account, value);\n', '_approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '}\n', '}\n', '\n', '\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', 'address private _owner;\n', '\n', 'event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '/**\n', '* @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '* account.\n', '*/\n', 'constructor () internal {\n', '_owner = msg.sender;\n', 'emit OwnershipTransferred(address(0), _owner);\n', '}\n', '\n', '/**\n', '* @return the address of the owner.\n', '*/\n', 'function owner() public view returns (address) {\n', 'return _owner;\n', '}\n', '\n', '/**\n', '* @dev Throws if called by any account other than the owner.\n', '*/\n', 'modifier onlyOwner() {\n', 'require(isOwner());\n', '_;\n', '}\n', '\n', '/**\n', '* @return true if `msg.sender` is the owner of the contract.\n', '*/\n', 'function isOwner() public view returns (bool) {\n', 'return msg.sender == _owner;\n', '}\n', '\n', '/**\n', '* @dev Allows the current owner to relinquish control of the contract.\n', '* It will not be possible to call the functions with the `onlyOwner`\n', '* modifier anymore.\n', '* @notice Renouncing ownership will leave the contract without an owner,\n', '* thereby removing any functionality that is only available to the owner.\n', '*/\n', 'function renounceOwnership() public onlyOwner {\n', 'emit OwnershipTransferred(_owner, address(0));\n', '_owner = address(0);\n', '}\n', '\n', '/**\n', '* @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '* @param newOwner The address to transfer ownership to.\n', '*/\n', 'function transferOwnership(address newOwner) public onlyOwner {\n', '_transferOwnership(newOwner);\n', '}\n', '\n', '/**\n', '* @dev Transfers control of the contract to a newOwner.\n', '* @param newOwner The address to transfer ownership to.\n', '*/\n', 'function _transferOwnership(address newOwner) internal {\n', 'require(newOwner != address(0));\n', 'emit OwnershipTransferred(_owner, newOwner);\n', '_owner = newOwner;\n', '}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title ERC20Detailed token\n', '* @dev The decimals are only for visualization purposes.\n', '* All the operations are done using the smallest and indivisible token unit,\n', '* just as on Ethereum all the operations are done in wei.\n', '*/\n', 'contract ERC20Detailed is IERC20 {\n', 'string private _name;\n', 'string private _symbol;\n', 'uint8 private _decimals;\n', '\n', 'constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '_name = name;\n', '_symbol = symbol;\n', '_decimals = decimals;\n', '}\n', '\n', '/**\n', '* @return the name of the token.\n', '*/\n', 'function name() public view returns (string memory) {\n', 'return _name;\n', '}\n', '\n', '/**\n', '* @return the symbol of the token.\n', '*/\n', 'function symbol() public view returns (string memory) {\n', 'return _symbol;\n', '}\n', '\n', '/**\n', '* @return the number of decimals of the token.\n', '*/\n', 'function decimals() public view returns (uint8) {\n', 'return _decimals;\n', '}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title ERC20Mintable\n', '* @dev ERC20 minting logic\n', '*/\n', 'contract ERC20Mintable is ERC20, MinterRole {\n', '/**\n', '* @dev Function to mint tokens\n', '* @param to The address that will receive the minted tokens.\n', '* @param value The amount of tokens to mint.\n', '* @return A boolean that indicates if the operation was successful.\n', '*/\n', 'function mint(address to, uint256 value) public onlyMinter returns (bool) {\n', '_mint(to, value);\n', 'return true;\n', '}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Capped token\n', '* @dev Mintable token with a token cap.\n', '*/\n', 'contract ERC20Capped is ERC20Mintable {\n', 'uint256 private _cap;\n', '\n', 'constructor (uint256 cap) public {\n', 'require(cap > 0);\n', '_cap = cap;\n', '}\n', '\n', '/**\n', '* @return the cap for the token minting.\n', '*/\n', 'function cap() public view returns (uint256) {\n', 'return _cap;\n', '}\n', '\n', 'function _mint(address account, uint256 value) internal {\n', 'require(totalSupply().add(value) <= _cap);\n', 'super._mint(account, value);\n', '}\n', '}\n', '\n', '\n', 'contract PictosisGenesisToken is ERC20, ERC20Detailed, ERC20Mintable, ERC20Capped {\n', 'address public exchangeContract;\n', '\n', 'constructor()\n', 'ERC20Capped(125000000000000000000000000)\n', 'ERC20Mintable()\n', 'ERC20Detailed("Pictosis Genesis Token", "PICTO-G", 18)\n', 'ERC20()\n', 'public\n', '{\n', '}\n', '\n', 'function burnFrom(address from, uint256 value) public onlyMinter {\n', '_burnFrom(from, value);\n', '}\n', '\n', 'function setExchangeContract(address _exchangeContract) public onlyMinter {\n', 'exchangeContract = _exchangeContract;\n', '}\n', '\n', 'function completeExchange(address from) public {\n', 'require(msg.sender == exchangeContract && exchangeContract != address(0), "Only the exchange contract can invoke this function");\n', '_burnFrom(from, balanceOf(from));\n', '}\n', '\n', 'function transfer(address to, uint256 value) public returns (bool) {\n', 'revert("Token can only be exchanged for PICTO tokens in the exchange contract");\n', '}\n', '\n', 'uint256 constant D160 = 0x0010000000000000000000000000000000000000000;\n', '\n', '// data is an array of uint256s. Each uint256 represents a transfer.\n', '// The 160 LSB is the destination of the address that wants to be sent\n', '// The 96 MSB is the amount of tokens that wants to be sent.\n', '// i.e. assume we want to mint 1200 tokens for address 0xABCDEFAABBCCDDEEFF1122334455667788990011\n', '// 1200 in hex: 0x0000410d586a20a4c00000. Concatenate this value and the address\n', '// ["0x0000410d586a20a4c00000ABCDEFAABBCCDDEEFF1122334455667788990011"]\n', 'function multiMint(uint256[] memory data) public onlyMinter {\n', 'for (uint256 i = 0; i < data.length; i++) {\n', 'address addr = address(data[i] & (D160 - 1));\n', 'uint256 amount = data[i] / D160;\n', '_mint(addr, amount);\n', '}\n', '}\n', '\n', '/// @notice This method can be used by the minter to extract mistakenly\n', '/// sent tokens to this contract.\n', '/// @param _token The address of the token contract that you want to recover\n', '/// set to 0x0000...0000 in case you want to extract ether.\n', 'function claimTokens(address _token) public onlyMinter {\n', 'if (_token == address(0)) {\n', 'msg.sender.transfer(address(this).balance);\n', 'return;\n', '}\n', '\n', 'ERC20 token = ERC20(_token);\n', 'uint256 balance = token.balanceOf(address(this));\n', 'token.transfer(msg.sender, balance);\n', 'emit ClaimedTokens(_token, msg.sender, balance);\n', '}\n', '\n', 'event ClaimedTokens(address indexed _token, address indexed _sender, uint256 _amount);\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Arrays\n', '* @dev Utility library of inline array functions\n', '*/\n', 'library Arrays {\n', '/**\n', '* @dev Upper bound search function which is kind of binary search algorithm. It searches sorted\n', '* array to find index of the element value. If element is found then returns its index otherwise\n', '* it returns index of first element which is greater than searched value. If searched element is\n', '* bigger than any array element function then returns first index after last element (i.e. all\n', '* values inside the array are smaller than the target). Complexity O(log n).\n', '* @param array The array sorted in ascending order.\n', "* @param element The element's value to be found.\n", '* @return The calculated index value. Returns 0 for empty array.\n', '*/\n', 'function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n', 'if (array.length == 0) {\n', 'return 0;\n', '}\n', '\n', 'uint256 low = 0;\n', 'uint256 high = array.length;\n', '\n', 'while (low < high) {\n', 'uint256 mid = Math.average(low, high);\n', '\n', '// Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n', '// because Math.average rounds down (it does integer division with truncation).\n', 'if (array[mid] > element) {\n', 'high = mid;\n', '} else {\n', 'low = mid + 1;\n', '}\n', '}\n', '\n', '// At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n', 'if (low > 0 && array[low - 1] == element) {\n', 'return low - 1;\n', '} else {\n', 'return low;\n', '}\n', '}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Counters\n', '* @author Matt Condon (@shrugs)\n', '* @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', '* of elements in a mapping, issuing ERC721 ids, or counting request ids\n', '*\n', '* Include with `using Counters for Counters.Counter;`\n', '* Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n', '* overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', '* directly accessed.\n', '*/\n', 'library Counters {\n', 'using SafeMath for uint256;\n', '\n', 'struct Counter {\n', '// This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "// the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '// this feature: see https://github.com/ethereum/solidity/issues/4637\n', 'uint256 _value; // default: 0\n', '}\n', '\n', 'function current(Counter storage counter) internal view returns (uint256) {\n', 'return counter._value;\n', '}\n', '\n', 'function increment(Counter storage counter) internal {\n', 'counter._value += 1;\n', '}\n', '\n', 'function decrement(Counter storage counter) internal {\n', 'counter._value = counter._value.sub(1);\n', '}\n', '}\n', '\n', '\n', '\n', '/**\n', '* @title ERC20 token with snapshots.\n', "* @dev Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n", '* https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n', '* When a snapshot is made, the balances and totalSupply at the time of the snapshot are recorded for later\n', '* access.\n', '*\n', '* To make a snapshot, call the `snapshot` function, which will emit the `Snapshot` event and return a snapshot id.\n', '* To get the total supply from a snapshot, call the function `totalSupplyAt` with the snapshot id.\n', '* To get the balance of an account from a snapshot, call the `balanceOfAt` function with the snapshot id and the\n', '* account address.\n', '* @author Validity Labs AG <info@validitylabs.org>\n', '*/\n', 'contract ERC20Snapshot is ERC20 {\n', 'using SafeMath for uint256;\n', 'using Arrays for uint256[];\n', 'using Counters for Counters.Counter;\n', '\n', '// Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n', '// Snapshot struct, but that would impede usage of functions that work on an array.\n', 'struct Snapshots {\n', 'uint256[] ids;\n', 'uint256[] values;\n', '}\n', '\n', 'mapping (address => Snapshots) private _accountBalanceSnapshots;\n', 'Snapshots private _totalSupplySnaphots;\n', '\n', '// Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n', 'Counters.Counter private _currentSnapshotId;\n', '\n', 'event Snapshot(uint256 id);\n', '\n', '// Creates a new snapshot id. Balances are only stored in snapshots on demand: unless a snapshot was taken, a\n', '// balance change will not be recorded. This means the extra added cost of storing snapshotted balances is only paid\n', '// when required, but is also flexible enough that it allows for e.g. daily snapshots.\n', 'function snapshot() public returns (uint256) {\n', '_currentSnapshotId.increment();\n', '\n', 'uint256 currentId = _currentSnapshotId.current();\n', 'emit Snapshot(currentId);\n', 'return currentId;\n', '}\n', '\n', 'function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\n', '(bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n', '\n', 'return snapshotted ? value : balanceOf(account);\n', '}\n', '\n', 'function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\n', '(bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnaphots);\n', '\n', 'return snapshotted ? value : totalSupply();\n', '}\n', '\n', '// _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\n', '// snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\n', '// The same is true for the total supply and _mint and _burn.\n', 'function _transfer(address from, address to, uint256 value) internal {\n', '_updateAccountSnapshot(from);\n', '_updateAccountSnapshot(to);\n', '\n', 'super._transfer(from, to, value);\n', '}\n', '\n', 'function _mint(address account, uint256 value) internal {\n', '_updateAccountSnapshot(account);\n', '_updateTotalSupplySnapshot();\n', '\n', 'super._mint(account, value);\n', '}\n', '\n', 'function _burn(address account, uint256 value) internal {\n', '_updateAccountSnapshot(account);\n', '_updateTotalSupplySnapshot();\n', '\n', 'super._burn(account, value);\n', '}\n', '\n', '// When a valid snapshot is queried, there are three possibilities:\n', '// a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n', '// created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n', '// to this id is the current one.\n', '// b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n', '// requested id, and its value is the one to return.\n', '// c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n', '// no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n', '// larger than the requested one.\n', '//\n', '// In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n', "// it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n", '// exactly this.\n', 'function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\n', 'private view returns (bool, uint256)\n', '{\n', 'require(snapshotId > 0);\n', 'require(snapshotId <= _currentSnapshotId.current());\n', '\n', 'uint256 index = snapshots.ids.findUpperBound(snapshotId);\n', '\n', 'if (index == snapshots.ids.length) {\n', 'return (false, 0);\n', '} else {\n', 'return (true, snapshots.values[index]);\n', '}\n', '}\n', '\n', 'function _updateAccountSnapshot(address account) private {\n', '_updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n', '}\n', '\n', 'function _updateTotalSupplySnapshot() private {\n', '_updateSnapshot(_totalSupplySnaphots, totalSupply());\n', '}\n', '\n', 'function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n', 'uint256 currentId = _currentSnapshotId.current();\n', 'if (_lastSnapshotId(snapshots.ids) < currentId) {\n', 'snapshots.ids.push(currentId);\n', 'snapshots.values.push(currentValue);\n', '}\n', '}\n', '\n', 'function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n', 'if (ids.length == 0) {\n', 'return 0;\n', '} else {\n', 'return ids[ids.length - 1];\n', '}\n', '}\n', '}\n', '\n', '\n', '\n', '\n', 'contract PictosisToken is ERC20, ERC20Detailed, ERC20Mintable, ERC20Capped, ERC20Snapshot, Ownable {\n', 'uint transfersEnabledDate;\n', '\n', 'modifier onlyTransfersEnabled() {\n', 'require(block.timestamp >= transfersEnabledDate, "Transfers disabled");\n', '_;\n', '}\n', '\n', 'constructor(uint _enableTransfersDate, uint _cap)\n', 'ERC20Capped(_cap)\n', 'ERC20Mintable()\n', 'ERC20Detailed("Pictosis Token", "PICTO", 18)\n', 'ERC20()\n', 'Ownable()\n', 'public\n', '{\n', 'transfersEnabledDate = _enableTransfersDate;\n', '}\n', '\n', 'function areTransfersEnabled() public view returns(bool) {\n', 'return block.timestamp >= transfersEnabledDate;\n', '}\n', '\n', 'function transfer(\n', 'address to,\n', 'uint256 value\n', ')\n', 'public\n', 'onlyTransfersEnabled\n', 'returns (bool)\n', '{\n', 'return super.transfer(to, value);\n', '}\n', '\n', 'function transferFrom(\n', 'address from,\n', 'address to,\n', 'uint256 value\n', ')\n', 'public\n', 'onlyTransfersEnabled\n', 'returns (bool)\n', '{\n', 'return super.transferFrom(from, to, value);\n', '}\n', '\n', '/// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '/// its behalf, and then a function is triggered in the contract that is\n', '/// being approved, `_spender`. This allows users to use their tokens to\n', '/// interact with contracts in one function call instead of two\n', '/// @param _spender The address of the contract able to transfer the tokens\n', '/// @param _amount The amount of tokens to be approved for transfer\n', '/// @return True if the function call was successful\n', 'function approveAndCall(\n', 'address _spender,\n', 'uint256 _amount,\n', 'bytes memory _extraData\n', ')\n', 'public\n', 'returns (bool success)\n', '{\n', 'require(approve(_spender, _amount), "Couldn\'t approve spender");\n', '\n', 'ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);\n', '\n', 'return true;\n', '}\n', '}\n', '\n', 'contract PictosisGenesisExchanger is Ownable {\n', 'using SafeMath for uint256;\n', '\n', 'mapping (address => uint256) public collected;\n', 'uint256 public totalCollected;\n', '\n', 'PictosisGenesisToken public genesis;\n', 'PictosisToken public picto;\n', '\n', 'constructor(address _genesis, address _picto) public {\n', 'genesis = PictosisGenesisToken(_genesis);\n', 'picto = PictosisToken(_picto);\n', '}\n', '\n', '/// @notice Can collect tokens;\n', 'function canCollect() public view returns(bool) {\n', 'return picto.areTransfersEnabled();\n', '}\n', '\n', '/// @notice This method should be called by the genesis holders to collect their picto token. Requires approval\n', 'function collect() public {\n', 'require(picto.areTransfersEnabled(), "Cannot collect tokens yet");\n', '\n', 'uint balance = genesis.balanceOf(msg.sender);\n', 'uint256 amountToSend = balance.sub(collected[msg.sender]);\n', '\n', 'require(balance >= collected[msg.sender], "Balance must be greater than collected amount");\n', 'require(amountToSend > 0, "No tokens available or already exchanged");\n', 'require(picto.balanceOf(address(this)) >= amountToSend, "Exchanger does not have funds available");\n', '\n', 'totalCollected = totalCollected.add(amountToSend);\n', 'collected[msg.sender] = collected[msg.sender].add(amountToSend);\n', '\n', 'require(picto.transfer(msg.sender, amountToSend), "Transfer failure");\n', '\n', 'emit TokensCollected(msg.sender, amountToSend);\n', '}\n', '\n', '/// @notice This method can be used by the minter to extract mistakenly\n', '/// sent tokens to this contract.\n', '/// @param _token The address of the token contract that you want to recover\n', '/// set to 0x0000...0000 in case you want to extract ether.\n', 'function claimTokens(address _token) public onlyOwner {\n', 'if (_token == address(0)) {\n', 'msg.sender.transfer(address(this).balance);\n', 'return;\n', '}\n', '\n', 'ERC20 token = ERC20(_token);\n', 'uint256 balance = token.balanceOf(address(this));\n', '\n', 'if(_token == address(picto)){\n', 'if(balance > genesis.totalSupply()){\n', 'balance = balance.sub(genesis.totalSupply());\n', '}\n', 'require(balance >= genesis.totalSupply(), "Cannot withdraw PICTO until everyone exchanges the tokens");\n', '}\n', '\n', 'token.transfer(msg.sender, balance);\n', 'emit ClaimedTokens(_token, msg.sender, balance);\n', '}\n', '\n', 'event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', 'event TokensCollected(address indexed _holder, uint256 _amount);\n', '}']