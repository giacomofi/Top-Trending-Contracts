['pragma solidity ^0.5.2;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: @daostack/infra/contracts/Reputation.sol\n', '\n', '/**\n', ' * @title Reputation system\n', ' * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .\n', " * A reputation is use to assign influence measure to a DAO'S peers.\n", ' * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.\n', ' * The Reputation contract maintain a map of address to reputation value.\n', ' * It provides an onlyOwner functions to mint and burn reputation _to (or _from) a specific address.\n', ' */\n', '\n', 'contract Reputation is Ownable {\n', '\n', '    uint8 public decimals = 18;             //Number of decimals of the smallest unit\n', '    // Event indicating minting of reputation to an address.\n', '    event Mint(address indexed _to, uint256 _amount);\n', '    // Event indicating burning of reputation for an address.\n', '    event Burn(address indexed _from, uint256 _amount);\n', '\n', '      /// @dev `Checkpoint` is the structure that attaches a block number to a\n', '      ///  given value, the block number attached is the one that last changed the\n', '      ///  value\n', '    struct Checkpoint {\n', '\n', '    // `fromBlock` is the block number that the value was generated from\n', '        uint128 fromBlock;\n', '\n', '          // `value` is the amount of reputation at a specific block number\n', '        uint128 value;\n', '    }\n', '\n', '      // `balances` is the map that tracks the balance of each address, in this\n', '      //  contract when the balance changes the block number that the change\n', '      //  occurred is also included in the map\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '      // Tracks the history of the `totalSupply` of the reputation\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', '    /// @notice Constructor to create a Reputation\n', '    constructor(\n', '    ) public\n', '    {\n', '    }\n', '\n', '    /// @dev This function makes it easy to get the total number of reputation\n', '    /// @return The total number of reputation\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '\n', '  ////////////////\n', '  // Query balance and totalSupply in History\n', '  ////////////////\n', '    /**\n', '    * @dev return the reputation amount of a given owner\n', '    * @param _owner an address of the owner which we want to get his reputation\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '      /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '      /// @param _owner The address from which the balance will be retrieved\n', '      /// @param _blockNumber The block number when the balance is queried\n', '      /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(address _owner, uint256 _blockNumber)\n', '    public view returns (uint256)\n', '    {\n', '        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            return 0;\n', '          // This will return the expected balance during normal situations\n', '        } else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '      /// @notice Total amount of reputation at a specific `_blockNumber`.\n', '      /// @param _blockNumber The block number when the totalSupply is queried\n', '      /// @return The total amount of reputation at `_blockNumber`\n', '    function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {\n', '        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '            return 0;\n', '          // This will return the expected totalSupply during normal situations\n', '        } else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '      /// @notice Generates `_amount` reputation that are assigned to `_owner`\n', '      /// @param _user The address that will be assigned the new reputation\n', '      /// @param _amount The quantity of reputation generated\n', '      /// @return True if the reputation are generated correctly\n', '    function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {\n', '        uint256 curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n', '        uint256 previousBalanceTo = balanceOf(_user);\n', '        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '        updateValueAtNow(balances[_user], previousBalanceTo + _amount);\n', '        emit Mint(_user, _amount);\n', '        return true;\n', '    }\n', '\n', '      /// @notice Burns `_amount` reputation from `_owner`\n', '      /// @param _user The address that will lose the reputation\n', '      /// @param _amount The quantity of reputation to burn\n', '      /// @return True if the reputation are burned correctly\n', '    function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {\n', '        uint256 curTotalSupply = totalSupply();\n', '        uint256 amountBurned = _amount;\n', '        uint256 previousBalanceFrom = balanceOf(_user);\n', '        if (previousBalanceFrom < amountBurned) {\n', '            amountBurned = previousBalanceFrom;\n', '        }\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);\n', '        updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);\n', '        emit Burn(_user, amountBurned);\n', '        return true;\n', '    }\n', '\n', '  ////////////////\n', '  // Internal helper functions to query and set a value in a snapshot array\n', '  ////////////////\n', '\n', '      /// @dev `getValueAt` retrieves the number of reputation at a given block number\n', '      /// @param checkpoints The history of values being queried\n', '      /// @param _block The block number to retrieve the value at\n', '      /// @return The number of reputation being queried\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {\n', '        if (checkpoints.length == 0) {\n', '            return 0;\n', '        }\n', '\n', '          // Shortcut for the actual value\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock) {\n', '            return checkpoints[checkpoints.length-1].value;\n', '        }\n', '        if (_block < checkpoints[0].fromBlock) {\n', '            return 0;\n', '        }\n', '\n', '          // Binary search of the value in the array\n', '        uint256 min = 0;\n', '        uint256 max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint256 mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock<=_block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '      /// @dev `updateValueAtNow` used to update the `balances` map and the\n', '      ///  `totalSupplyHistory`\n', '      /// @param checkpoints The history of data being updated\n', '      /// @param _value The new number of reputation\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {\n', '        require(uint128(_value) == _value); //check value is in the 128 bits bounderies\n', '        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n', '            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n', '            newCheckPoint.fromBlock = uint128(block.number);\n', '            newCheckPoint.value = uint128(_value);\n', '        } else {\n', '            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/DxReputation.sol\n', '\n', '// is Reputation\n', 'contract DxReputation is Reputation {\n', '    constructor() public {}\n', '}']