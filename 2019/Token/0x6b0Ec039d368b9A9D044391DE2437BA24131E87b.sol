['/*\n', ' * Crypto stamp colors storage\n', ' * Store colors for connected physical assets\n', ' *\n', ' * Developed by capacity.at\n', ' * for post.at\n', ' */\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others (`ERC165Checker`).\n', ' *\n', ' * For an implementation, see `ERC165`.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of NFTs in `owner`'s account.\n", '     */\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the NFT specified by `tokenId`.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * \n', '     *\n', '     * Requirements:\n', '     * - `from`, `to` cannot be zero.\n', '     * - `tokenId` must be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this\n', '     * NFT by either `approve` or `setApproveForAll`.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Requirements:\n', '     * - If the caller is not `from`, it must be approved to move this NFT by\n', '     * either `approve` or `setApproveForAll`.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Enumerable is IERC721 {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {\n', '    // solhint-disable-previous-line no-empty-blocks\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/CryptostampColors.sol\n', '\n', '/*\n', 'Implements a color store for crypto stamp\n', '*/\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', 'contract CryptostampColors {\n', '    using SafeMath for uint256;\n', '\n', '    IERC721Full internal cryptostamp;\n', '\n', '    address public createControl;\n', '\n', '    address public tokenAssignmentControl;\n', '\n', '    enum Colors {\n', '        Black,\n', '        Green,\n', '        Blue,\n', '        Yellow,\n', '        Red\n', '    }\n', '\n', '    uint256 public constant packFactor = 85;\n', '    uint256 public constant packBits = 3;\n', '    uint256[] public packedColors;\n', '\n', '    event SavedColors(uint256 firstId, uint256 lastId);\n', '\n', '    constructor(address _createControl, address _tokenAssignmentControl)\n', '    public\n', '    {\n', '        createControl = _createControl;\n', '        tokenAssignmentControl = _tokenAssignmentControl;\n', '    }\n', '\n', '    modifier onlyCreateControl()\n', '    {\n', '        require(msg.sender == createControl, "createControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenAssignmentControl() {\n', '        require(msg.sender == tokenAssignmentControl, "tokenAssignmentControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier requireCryptostamp() {\n', '        require(address(cryptostamp) != address(0x0), "You need to provide an actual Cryptostamp contract.");\n', '        _;\n', '    }\n', '\n', '    /*** Enable adjusting variables after deployment ***/\n', '\n', '    function setCryptostamp(IERC721Full _newCryptostamp)\n', '    public\n', '    onlyCreateControl\n', '    {\n', '        require(address(_newCryptostamp) != address(0x0), "You need to provide an actual Cryptostamp contract.");\n', '        cryptostamp = _newCryptostamp;\n', '    }\n', '\n', '    /*** Actual color storage ***/\n', '\n', '    function calcPackedColors(Colors[] memory _values)\n', '    public pure\n', '    returns (uint256)\n', '    {\n', '        uint256 valcount = _values.length;\n', '        require(valcount <= packFactor, "Can only pack values up to a maximum of the packFactor.");\n', '        uint256 packedVal = 0;\n', '        for (uint256 i = 0; i < valcount; i++) {\n', '            packedVal += uint256(_values[i]) * (2 ** (i * packBits));\n', '        }\n', '        return packedVal;\n', '    }\n', '\n', '    function setColorsPacked(uint256 _tokenIdStart, uint256[] memory _packedValues)\n', '    public\n', '    onlyCreateControl\n', '    requireCryptostamp\n', '    {\n', '        require(_tokenIdStart == packedColors.length * packFactor, "Values can can only be appended at the end.");\n', '        require(_tokenIdStart % packFactor == 0, "The starting token ID needs to be aligned with the packing factor.");\n', '        uint256 valcount = _packedValues.length;\n', '        for (uint256 i = 0; i < valcount; i++) {\n', '            packedColors.push(_packedValues[i]);\n', '        }\n', '        emit SavedColors(_tokenIdStart, totalSupply() - 1);\n', '    }\n', '\n', '    // Returns the color of a given token ID\n', '    function getColor(uint256 tokenId)\n', '    public view\n', '    requireCryptostamp\n', '    returns (Colors)\n', '    {\n', '        require(tokenId < totalSupply(), "The token ID has no color stored.");\n', '        require(tokenId < cryptostamp.totalSupply(), "The token ID is not valid.");\n', '        uint256 packElement = tokenId / packFactor;\n', '        uint256 packItem = tokenId % packFactor;\n', '        uint256 packValue = (packedColors[packElement] >> (packBits * packItem)) % (2 ** packBits);\n', '        require(packValue < 5, "Error in packed Value.");\n', '        return Colors(packValue);\n', '    }\n', '\n', '    // Returns the amount of colors saved.\n', '    function totalSupply()\n', '    public view\n', '    requireCryptostamp\n', '    returns (uint256)\n', '    {\n', '        uint256 maxSupply = packedColors.length * packFactor;\n', '        uint256 csSupply = cryptostamp.totalSupply();\n', '        if (csSupply < maxSupply) {\n', '            return csSupply;\n', '        }\n', '        return maxSupply;\n', '    }\n', '\n', "    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\n", '\n', "    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\n", '    function rescueToken(IERC20 _foreignToken, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\n', '    }\n', '\n', "    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\n", '    function approveNFTrescue(IERC721 _foreignNFT, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        _foreignNFT.setApprovalForAll(_to, true);\n', '    }\n', ' \n', '    // Make sure this contract cannot receive ETH.\n', '    function()\n', '    external payable\n', '    {\n', '        revert("The contract cannot receive ETH payments.");\n', '    }\n', '}']