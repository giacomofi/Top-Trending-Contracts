['pragma solidity 0.5.2;\n', '\n', '\n', '// @title Abstract ERC20 token interface\n', 'interface IERC20 {\n', '\tfunction balanceOf(address owner) external view returns (uint256 balance);\n', '\tfunction transfer(address to, uint256 value) external returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint256 value) external returns (bool success);\n', '\tfunction approve(address spender, uint256 value) external returns (bool success);\n', '\tfunction allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '\tevent Issuance(address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t* @dev Multiplies two numbers, reverts on overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b);\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\trequire(b > 0); // Solidity only automatically asserts when dividing by 0\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\trequire(b <= a);\n', '\t\tuint256 c = a - b;\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Adds two numbers, reverts on overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a);\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '\t* reverts when dividing by zero.\n', '\t*/\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\trequire(b != 0);\n', '\t\treturn a % b;\n', '\t}\n', '}\n', '\n', 'contract ERC20 is IERC20 {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping (address => uint256) private _balances;\n', '\n', '\tmapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '\tuint256 private _totalSupply;\n', '\n', '\t/**\n', '\t* @dev Total number of tokens in existence\n', '\t*/\n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Gets the balance of the specified address.\n', '\t* @param owner The address to query the balance of.\n', '\t* @return An uint256 representing the amount owned by the passed address.\n', '\t*/\n', '\tfunction balanceOf(address owner) public view returns (uint256) {\n', '\t\treturn _balances[owner];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '\t * @param owner address The address which owns the funds.\n', '\t * @param spender address The address which will spend the funds.\n', '\t * @return A uint256 specifying the amount of tokens still available for the spender.\n', '\t */\n', '\tfunction allowance(\n', '\t\taddress owner,\n', '\t\taddress spender\n', '\t )\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn _allowed[owner][spender];\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer token for a specified address\n', '\t* @param to The address to transfer to.\n', '\t* @param value The amount to be transferred.\n', '\t*/\n', '\tfunction transfer(address to, uint256 value) public returns (bool) {\n', '\t\t_transfer(msg.sender, to, value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t * @param spender The address which will spend the funds.\n', '\t * @param value The amount of tokens to be spent.\n', '\t */\n', '\tfunction approve(address spender, uint256 value) public returns (bool) {\n', '\t\trequire(spender != address(0));\n', '\n', '\t\t_allowed[msg.sender][spender] = value;\n', '\t\temit Approval(msg.sender, spender, value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Transfer tokens from one address to another\n', '\t * @param from address The address which you want to send tokens from\n', '\t * @param to address The address which you want to transfer to\n', '\t * @param value uint256 the amount of tokens to be transferred\n', '\t */\n', '\tfunction transferFrom(\n', '\t\taddress from,\n', '\t\taddress to,\n', '\t\tuint256 value\n', '\t)\n', '\t\tpublic\n', '\t\treturns (bool)\n', '\t{\n', '\t\trequire(value <= _allowed[from][msg.sender]);\n', '\n', '\t\t_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '\t\t_transfer(from, to, value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '\t * approve should be called when allowed_[_spender] == 0. To increment\n', '\t * allowed value is better to use this function to avoid 2 calls (and wait until\n', '\t * the first transaction is mined)\n', '\t * From MonolithDAO Token.sol\n', '\t * @param spender The address which will spend the funds.\n', '\t * @param addedValue The amount of tokens to increase the allowance by.\n', '\t */\n', '\tfunction increaseAllowance(\n', '\t\taddress spender,\n', '\t\tuint256 addedValue\n', '\t)\n', '\t\tpublic\n', '\t\treturns (bool)\n', '\t{\n', '\t\trequire(spender != address(0));\n', '\n', '\t\t_allowed[msg.sender][spender] = (\n', '\t\t\t_allowed[msg.sender][spender].add(addedValue));\n', '\t\temit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '\t * approve should be called when allowed_[_spender] == 0. To decrement\n', '\t * allowed value is better to use this function to avoid 2 calls (and wait until\n', '\t * the first transaction is mined)\n', '\t * From MonolithDAO Token.sol\n', '\t * @param spender The address which will spend the funds.\n', '\t * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '\t */\n', '\tfunction decreaseAllowance(\n', '\t\taddress spender,\n', '\t\tuint256 subtractedValue\n', '\t)\n', '\t\tpublic\n', '\t\treturns (bool)\n', '\t{\n', '\t\trequire(spender != address(0));\n', '\n', '\t\t_allowed[msg.sender][spender] = (\n', '\t\t\t_allowed[msg.sender][spender].sub(subtractedValue));\n', '\t\temit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer token for a specified addresses\n', '\t* @param from The address to transfer from.\n', '\t* @param to The address to transfer to.\n', '\t* @param value The amount to be transferred.\n', '\t*/\n', '\tfunction _transfer(address from, address to, uint256 value) internal {\n', '\t\trequire(value <= _balances[from]);\n', '\t\trequire(to != address(0));\n', '\n', '\t\t_balances[from] = _balances[from].sub(value);\n', '\t\t_balances[to] = _balances[to].add(value);\n', '\t\temit Transfer(from, to, value);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Internal function that mints an amount of the token and assigns it to\n', '\t * an account. This encapsulates the modification of balances such that the\n', '\t * proper events are emitted.\n', '\t * @param account The account that will receive the created tokens.\n', '\t * @param value The amount that will be created.\n', '\t */\n', '\tfunction _mint(address account, uint256 value) internal {\n', '\t\trequire(account != address(0));\n', '\t\t_totalSupply = _totalSupply.add(value);\n', '\t\t_balances[account] = _balances[account].add(value);\n', '\t\temit Transfer(address(0), account, value);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Internal function that burns an amount of the token of a given\n', '\t * account.\n', '\t * @param account The account whose tokens will be burnt.\n', '\t * @param value The amount that will be burnt.\n', '\t */\n', '\tfunction _burn(address account, uint256 value) internal {\n', '\t\trequire(account != address(0));\n', '\t\trequire(value <= _balances[account]);\n', '\n', '\t\t_totalSupply = _totalSupply.sub(value);\n', '\t\t_balances[account] = _balances[account].sub(value);\n', '\t\temit Transfer(account, address(0), value);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Internal function that burns an amount of the token of a given\n', "\t * account, deducting from the sender's allowance for said account. Uses the\n", '\t * internal burn function.\n', '\t * @param account The account whose tokens will be burnt.\n', '\t * @param value The amount that will be burnt.\n', '\t */\n', '\tfunction _burnFrom(address account, uint256 value) internal {\n', '\t\trequire(value <= _allowed[account][msg.sender]);\n', '\n', '\t\t// Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n', '\t\t// this function needs to emit an event with the updated approval.\n', '\t\t_allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n', '\t\t\tvalue);\n', '\t\t_burn(account, value);\n', '\t}\n', '}\n', '\n', 'contract ERC20Burnable is ERC20 {\n', '\n', '\t/**\n', '\t * @dev Burns a specific amount of tokens.\n', '\t * @param value The amount of token to be burned.\n', '\t */\n', '\tfunction burn(uint256 value) public {\n', '\t\t_burn(msg.sender, value);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Burns a specific amount of tokens from the target address and decrements allowance\n', '\t * @param from address The address which you want to send tokens from\n', '\t * @param value uint256 The amount of token to be burned\n', '\t */\n', '\tfunction burnFrom(address from, uint256 value) public {\n', '\t\t_burnFrom(from, value);\n', '\t}\n', '}\n', '\n', 'contract Owned {\n', '\n', '\taddress public owner = msg.sender;\n', '\taddress public potentialOwner;\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyPotentialOwner {\n', '\t\trequire(msg.sender == potentialOwner);\n', '\t\t_;\n', '\t}\n', '\n', '\tevent NewOwner(address old, address current);\n', '\tevent NewPotentialOwner(address old, address potential);\n', '\n', '\tfunction setOwner(address _new)\n', '\t\tpublic\n', '\t\tonlyOwner\n', '\t{\n', '\t\temit NewPotentialOwner(owner, _new);\n', '\t\tpotentialOwner = _new;\n', '\t}\n', '\n', '\tfunction confirmOwnership()\n', '\t\tpublic\n', '\t\tonlyPotentialOwner\n', '\t{\n', '\t\temit NewOwner(owner, potentialOwner);\n', '\t\towner = potentialOwner;\n', '\t\tpotentialOwner = address(0);\n', '\t}\n', '}\n', '\n', '/// @title Token contract - Implements Standard ERC20 Token with additional features.\n', '/// @author Zerion - <inbox@zerion.io>\n', 'contract Token is ERC20Burnable, Owned {\n', '\n', '\t// Time of the contract creation\n', '\tuint256 public creationTime;\n', '\n', '\tconstructor() public {\n', '\t\t/* solium-disable-next-line security/no-block-members */\n', '\t\tcreationTime = now;\n', '\t}\n', '\n', '\t/// @dev Owner can transfer out any accidentally sent ERC20 tokens\n', '\tfunction transferERC20Token(IERC20 _token, address _to, uint256 _value)\n', '\t\tpublic\n', '\t\tonlyOwner\n', '\t\treturns (bool success)\n', '\t{\n', '\t\trequire(_token.balanceOf(address(this)) >= _value);\n', '\t\tuint256 receiverBalance = _token.balanceOf(_to);\n', '\t\trequire(_token.transfer(_to, _value));\n', '\n', '\t\tuint256 receiverNewBalance = _token.balanceOf(_to);\n', '\t\tassert(receiverNewBalance == receiverBalance + _value);\n', '\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', 'contract FluenceToken is Token {\n', '\n', "    string constant public name = 'Fluence Presale Token (Test)';\n", "    string constant public symbol = 'FPT-test';\n", '    uint8  constant public decimals = 18;\n', '\n', '    uint256 constant public presaleTokens = 6000000e18;\n', '\n', '    bool public isVestingEnabled = true;\n', '    mapping (address => uint256) public vestedTokens;\n', '\n', '    // The moment when the crowdsale ends. The time of the first payout.\n', '    uint256 checkpoint;\n', '\n', '    address crowdsaleManager;\n', '    address migrationManager;\n', '\n', '    modifier onlyCrowdsaleManager {\n', '        require(msg.sender == crowdsaleManager);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDuringVestingPeriod {\n', '        require(isVestingEnabled);\n', '        _;\n', '    }\n', '\n', '    function vest(uint256 amount) public onlyDuringVestingPeriod {\n', '        _transfer(msg.sender, address(this), amount);\n', '        vestedTokens[msg.sender] += amount;\n', '    }\n', '\n', '    function unvest(uint256 amount) public {\n', '        require(onVesting(msg.sender) >= amount);\n', '        \n', '        uint256 tokens_to_unvest = (amount * 100) / (100 + _getBonus());\n', '        _transfer(address(this), msg.sender, tokens_to_unvest);\n', '        vestedTokens[msg.sender] -= tokens_to_unvest;\n', '        _mint(msg.sender, amount - tokens_to_unvest);\n', '    }\n', '\n', '    function disableVesting() public onlyCrowdsaleManager {\n', '        isVestingEnabled = false;\n', '    }\n', '\n', '    function payoutFirstBonus() public onlyCrowdsaleManager {\n', '        require(!isVestingEnabled && checkpoint == 0);  // can only be called once\n', '        checkpoint = now;\n', '    }\n', '\n', '    function setCrowdsaleManager(address manager) public onlyOwner {\n', '        crowdsaleManager = manager;\n', '    }\n', '\n', '    function setMigrationManager(address manager) public onlyOwner {\n', '        require(migrationManager == address(0));  // can only be called once\n', '        migrationManager = manager;\n', '        _mint(migrationManager, presaleTokens);\n', '    }\n', '\n', '    function onVesting(address account) public view returns (uint256) {\n', '        return vestedTokens[account] * (100 + _getBonus()) / 100;\n', '    }\n', '\n', '    function _getBonus() internal view returns (uint256) {\n', '        if (checkpoint == 0) {\n', '            return 0;\n', '        }\n', '        uint256 initialBonus = 5;\n', '        uint256 monthsPassed = (now - checkpoint) / (30 minutes);\n', '        uint256 additionalBonus = (monthsPassed > 4 ? 4: monthsPassed) * 5;  // 5% for every 30 days; no more than 20%\n', '        return initialBonus + additionalBonus;\n', '    }\n', '}']