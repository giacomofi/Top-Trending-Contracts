['pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\n', '}\n', '\n', 'contract DarchNetwork {\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '    address payable public fundsWallet;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '\n', '    constructor(\n', '        uint256 initialSupply,\n', '        string memory tokenName,\n', '        string memory tokenSymbol\n', '    ) public {\n', '        initialSupply = 1000000000;\n', '        tokenName = "Darch Network";\n', '        tokenSymbol = "DARCH";\n', '        fundsWallet = msg.sender;\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '\n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != address(0x0));\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = byte(uint8(48 + _i % 10));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    uint private productId;\n', '    function getProductID() private returns (uint256) {\n', '    return productId++;\n', '    }\n', '\n', '    uint private requestID;\n', '    function getRequestID() private returns (uint256) {\n', '    return requestID++;\n', '    }\n', '\n', '\n', '    struct productDetails {\n', '      uint time;\n', '      string headline;\n', '      string explain;\n', '      string imagelist;\n', '      string showdemo;\n', '      string category;\n', '      address senderaddress;\n', '      uint256 pid;\n', '      uint256 price;\n', '    }\n', '\n', '    mapping (string => productDetails) newProduct;\n', '    string[] public listofproducts;\n', '\n', '    function SharenewProduct(string memory uHeadline, string memory uExplain, string memory uImageList, string memory uShowDemo,string memory uCate, uint uPrice, string memory pname) public {\n', '\n', '        uint256 newpid = getProductID();\n', '        newProduct[pname].time = now;\n', '        newProduct[pname].senderaddress = msg.sender;\n', '        newProduct[pname].headline = uHeadline;\n', '        newProduct[pname].explain = uExplain;\n', '        newProduct[pname].imagelist = uImageList;\n', '        newProduct[pname].showdemo = uShowDemo;\n', '        newProduct[pname].category = uCate;\n', '        newProduct[pname].pid = newpid;\n', '        newProduct[pname].price = uPrice;\n', '        listofproducts.push(pname) -1;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '    function numberofProduct() view public returns (uint) {\n', '      return listofproducts.length;\n', '    }\n', '\n', '    function getpnamefromid(uint _pid) view public returns (string memory){\n', '        return listofproducts[_pid];\n', '    }\n', '\n', '\n', '    function getProductFromName(string memory pname) view public returns (string memory, string memory,string memory, string memory, string memory, string memory, string memory) {\n', '\n', '        if(newProduct[pname].time == 0){\n', '            return ("0", "0", "0","0","0","0","0");\n', '        } else {\n', '        return (uint2str(newProduct[pname].time), uint2str(newProduct[pname].price), newProduct[pname].headline, newProduct[pname].explain, newProduct[pname].imagelist, newProduct[pname].showdemo, newProduct[pname].category);\n', '        }\n', '    }\n', '\n', '\n', '    function checkProductExist(string memory pname) view public returns (bool) {\n', '\n', '        if(newProduct[pname].time == 0){\n', '            return false;\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '  struct Requesters {\n', '      bool exists;\n', '      uint256 ptime;\n', '      string publicKey;\n', '      address rqaddress;\n', '  }\n', '\n', '  mapping(string => Requesters[]) rlist;\n', '  mapping (string => bool) public RWlist;\n', '  string[] public listofrequests;\n', '\n', ' function checkWalletexist(string memory _wallet) view public returns (bool){\n', '        return RWlist[_wallet];\n', ' }\n', '\n', '\n', '  function setNewRequest(string memory pname, string memory pubkey) public returns (uint)  {\n', '      bool checkProduct = checkProductExist(pname);\n', '      if(checkProduct){\n', '          string memory wid = appendString(WallettoString(msg.sender),pname);\n', '\n', '          bool cwallet = checkWalletexist(wid);\n', '\n', '          if(cwallet){\n', '              revert();\n', '          } else {\n', '            if(balanceOf[msg.sender] >= newProduct[pname].price) {\n', '              transfer(fundsWallet, newProduct[pname].price);\n', '              RWlist[wid]=true;\n', '              rlist[pname].push(Requesters(true,now, pubkey, msg.sender));\n', '              listofproducts.push(wid) -1;\n', '              return rlist[pname].length - 1;\n', '            } else {\n', '                revert();\n', '            }\n', '\n', '          }\n', '      } else {\n', '          revert();\n', '      }\n', '\n', '  }\n', '\n', '\n', '\n', '    function num_of_request() view public returns (uint) {\n', '      return listofproducts.length;\n', '    }\n', '\n', '    function get_product_from_pid(uint _listid) view public returns (string memory){\n', '        return listofproducts[_listid];\n', '    }\n', '\n', '\n', '   function num_of_product_requests(string memory key) public view returns (uint) {\n', '    return rlist[key].length;\n', '  }\n', '\n', '  function get_public_key(string memory key, uint index) public view returns (string memory) {\n', '    if (rlist[key][index].exists == false) {\n', '      assert(false);\n', '    }\n', '    return rlist[key][index].publicKey;\n', '  }\n', '\n', '\n', '   struct TransmitProduct {\n', '      bool exists;\n', '      bool status;\n', '      uint256 ptime;\n', '      string signedMessage;\n', '      address forwho;\n', '  }\n', '\n', '  mapping(string => TransmitProduct[]) responseList;\n', '  mapping (string => bool) public BWlist;\n', '  string[] public listoftransmits;\n', '\n', '\n', '  function checkBWalletexist(string memory _walletandid) view public returns (bool){\n', '        return BWlist[_walletandid];\n', '  }\n', '\n', '  function WallettoString(address x) public returns(string memory) {\n', '    bytes memory b = new bytes(20);\n', '    for (uint i = 0; i < 20; i++)\n', '        b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '    return string(b);\n', ' }\n', '\n', ' function appendString(string memory a, string memory b) internal pure returns (string memory) {\n', '    return string(abi.encodePacked(a, b));\n', '}\n', '\n', '\n', '\n', '   function setTransmitProduct(string memory pname, uint index, string memory smessage) payable public  {\n', '      bool checkProduct = checkProductExist(pname);\n', '      if(checkProduct){\n', '          address radress = rlist[pname][index].rqaddress;\n', '          string memory wid = appendString(WallettoString(radress),pname);\n', '          bool cwallet = checkBWalletexist(wid);\n', '\n', '          if(cwallet){\n', '              //Buraya geliyorsa daha önce zaten göndermiş demektir.\n', '              revert();\n', '          } else {\n', '\n', '              if(msg.sender == newProduct[pname].senderaddress){\n', '\n', '                require(balanceOf[fundsWallet] >= newProduct[pname].price);\n', '                _transfer(fundsWallet, msg.sender, newProduct[pname].price);\n', '\n', '                BWlist[wid]=true;\n', '                //Sadece alıcının çözüleceği şekilde istek şifrelenerek blockchaine yükleniyor.\n', '                responseList[pname].push(TransmitProduct(true, true, now, smessage, radress));\n', '                listoftransmits.push(wid) -1;\n', '              } else {\n', '                  revert();\n', '              }\n', '          }\n', '      } else {\n', '          revert();\n', '      }\n', '\n', '  }\n', '\n', '\n', '\n', '  function cancelTransmitProduct(string memory pname, uint index) public  {\n', '      bool checkProduct = checkProductExist(pname);\n', '      if(checkProduct){\n', '          address radress = rlist[pname][index].rqaddress;\n', '          string memory wid = appendString(WallettoString(radress),pname);\n', '          bool cwallet = checkBWalletexist(wid);\n', '\n', '\n', '          if(cwallet){\n', '              //Buraya geliyorsa daha önce zaten göndermiş demektir.\n', '              revert();\n', '          } else {\n', '              //Eğer önceden gönderim yapılmamışsa burası çalışır.\n', '              //rqaddress\n', '              if(msg.sender == rlist[pname][index].rqaddress){\n', '                //Sadece o ürüne istek gönderen kişi iptal edebilir.\n', '\n', '                //coin kontrattan iptal edene iletiliyor.\n', '\n', '                 require(balanceOf[fundsWallet] >= newProduct[pname].price);\n', '\n', '                _transfer(fundsWallet,msg.sender,newProduct[pname].price);\n', '\n', '\n', '                BWlist[wid]=true;\n', '                //status false olması ürünün iptal edildiği anlamına geliyor.\n', '                //Gönderici parasını alıyor ve ürün\n', '                responseList[pname].push(TransmitProduct(true, false, now, "canceled", radress));\n', '                listoftransmits.push(wid) -1;\n', '              } else {\n', '                  revert();\n', '              }\n', '          }\n', '      } else {\n', '          revert();\n', '      }\n', '\n', '  }\n', '\n', '\n', '    function num_of_transmit() view public returns (uint) {\n', '      return listoftransmits.length;\n', '    }\n', '\n', '    function get_transmits_from_pid(uint _listid) view public returns (string memory){\n', '        return listoftransmits[_listid];\n', '    }\n', '\n', '  function num_of_product_transmit(string memory _pid) public view returns (uint) {\n', '    return responseList[_pid].length;\n', '  }\n', '\n', '  function getTransmits(string memory _pid, uint index) public view returns (address) {\n', '    if (responseList[_pid][index].exists == false) {\n', '      assert(false);\n', '    }\n', '    return rlist[_pid][index].rqaddress;\n', '  }\n', '\n', '\n', '\n', '    function() payable external{\n', '      uint256 yirmimart = 1553040000;\n', '      uint256 onnisan = 1554854400;\n', '      uint256 birmayis = 1556668800;\n', '      uint256 yirmimayis = 1558310400;\n', '      uint256 onhaziran = 1560124800;\n', '\n', '      if(yirmimart > now) {\n', '        require(balanceOf[fundsWallet] >= msg.value * 100);\n', '        _transfer(fundsWallet, msg.sender, msg.value * 100);\n', '        fundsWallet.transfer(msg.value);\n', '      } else if(yirmimart < now && onnisan > now) {\n', '        require(balanceOf[fundsWallet] >= msg.value * 15000);\n', '        _transfer(fundsWallet, msg.sender, msg.value * 15000);\n', '        fundsWallet.transfer(msg.value);\n', '      } else if(onnisan < now && birmayis > now) {\n', '        require(balanceOf[fundsWallet] >= msg.value * 12000);\n', '        _transfer(fundsWallet, msg.sender, msg.value * 12000);\n', '        fundsWallet.transfer(msg.value);\n', '      }else if(birmayis < now && yirmimayis > now) {\n', '        require(balanceOf[fundsWallet] >= msg.value * 10000);\n', '        _transfer(fundsWallet, msg.sender, msg.value * 10000);\n', '        fundsWallet.transfer(msg.value);\n', '      }else if(yirmimayis < now && onhaziran > now) {\n', '        require(balanceOf[fundsWallet] >= msg.value * 7500);\n', '        _transfer(fundsWallet, msg.sender, msg.value * 7500);\n', '        fundsWallet.transfer(msg.value);\n', '      } else {\n', '        assert(false);\n', '      }\n', '\n', '    }\n', '\n', '}']