['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract LoveAirCoffee is ERC20 {\n', '    \n', '    address owner = msg.sender;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    \n', '    // Public variables of the token\n', '    string public name="Love Air Coffee";\n', '    string public symbol="LAC";\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public totalSupply; \n', '    \n', '    uint256 public tokensPerOneEther;\n', '    \n', '    bool public transferTokenNow=true;\n', '    \n', '    bool public frozenCoin=true;\n', '    \n', '    uint256 public minEther;\n', '    uint256 public maxEther;\n', '\n', '    enum State { Disabled, Enabled }\n', '    \n', '    State public state = State.Disabled;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function LoveAirCoffee(uint256 initialSupply) public{\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '        balanceOf[msg.sender]=totalSupply;\n', '        emit Transfer(address(0),owner,totalSupply);\n', '    }\n', '    \n', '    function startBuyingTokens(bool _transferTokenNow,uint256 _minEther,uint256 _maxEther) public onlyOwner {\n', '        require(state == State.Disabled);\n', '        transferTokenNow = _transferTokenNow;\n', '        minEther = _minEther * 10 ** uint256(decimals);\n', '        maxEther = _maxEther * 10 ** uint256(decimals);\n', '        state = State.Enabled;\n', '    }\n', '    \n', '    function stopBuyingTokens() public onlyOwner {\n', '        require(state == State.Enabled);\n', '        state = State.Disabled;\n', '    }\n', '    \n', '    function setFrozenCoin(bool _value) public onlyOwner {\n', '        frozenCoin = _value;\n', '    }\n', '\n', '    // NewBuyPrice Price users can buy from the contract\n', '    function setPrices(uint256 newBuyPrice) onlyOwner public {\n', '        tokensPerOneEther = newBuyPrice;\n', '    }\n', '\n', '    // Buy tokens\n', '    function () payable external {\n', '        require(state == State.Enabled);\n', '        require(msg.value >= minEther && msg.value <= maxEther);\n', '        require(state == State.Enabled);\n', '        if(transferTokenNow){\n', '            uint256 tokens = (tokensPerOneEther * msg.value);\n', '           _transfer(owner, msg.sender, tokens);   // makes the transferss \n', '        }\n', '\n', '        owner.transfer(msg.value);\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) constant public returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);                   // Check if the sender has enough\n', '        require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows\n', '        balanceOf[_from] -= _value;                             // Subtract from the sender\n', '        balanceOf[_to] += _value;                               // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // Transfer tokens\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '         require(!frozenCoin);\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Transfer tokens from other address\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(!frozenCoin);\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    //Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    //Destroy tokens\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(!frozenCoin);\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    //Destroy tokens from other account\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(!frozenCoin);\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowed[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']