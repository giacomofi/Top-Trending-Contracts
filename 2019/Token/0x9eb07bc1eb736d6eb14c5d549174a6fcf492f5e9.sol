['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/mockContracts/TestToken.sol\n', '\n', '/* all this file is based on code from open zepplin\n', ' * https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token */\n', '\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        require(b > 0);\n', '        uint c = a / b;\n', '        require(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * ERC20Basic\n', ' * Simpler version of ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * Basic token\n', ' * Basic version of StandardToken, with no allowances\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    /*\n', '     * Fix for the ERC20 short address attack\n', '     */\n', '    modifier onlyPayloadSize(uint size) {\n', '        if (msg.data.length < size + 4) {\n', '         revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value)  public onlyPayloadSize(2 * 32) returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already revert if this condition is not met\n', '        if (_value > _allowance) revert();\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * SimpleToken\n', ' *\n', ' * Very simple ERC20 Token example, where all tokens are pre-assigned\n', ' * to the creator. Note they can later distribute these tokens\n', ' * as they wish using `transfer` and other `StandardToken` functions.\n', ' */\n', 'contract TestToken is StandardToken {\n', '\n', '    string public name = "Test";\n', '    string public symbol = "TST";\n', '    uint public decimals = 18;\n', '    uint public INITIAL_SUPPLY = 10**(50+18);\n', '\n', '    function TestToken(string _name, string _symbol, uint _decimals) public {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    event Burn(address indexed _burner, uint _value);\n', '\n', '    function burn(uint _value) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(msg.sender, _value);\n', '        Transfer(msg.sender, address(0x0), _value);\n', '        return true;\n', '    }\n', '\n', '    // save some gas by making only one contract call\n', '    function burnFrom(address _from, uint256 _value) public returns (bool) {\n', '        transferFrom( _from, msg.sender, _value );\n', '        return burn(_value);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/mockContracts/TestToken.sol\n', '\n', '/* all this file is based on code from open zepplin\n', ' * https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token */\n', '\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        require(b > 0);\n', '        uint c = a / b;\n', '        require(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * ERC20Basic\n', ' * Simpler version of ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * Basic token\n', ' * Basic version of StandardToken, with no allowances\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    /*\n', '     * Fix for the ERC20 short address attack\n', '     */\n', '    modifier onlyPayloadSize(uint size) {\n', '        if (msg.data.length < size + 4) {\n', '         revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value)  public onlyPayloadSize(2 * 32) returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already revert if this condition is not met\n', '        if (_value > _allowance) revert();\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', '/*\n', ' * SimpleToken\n', ' *\n', ' * Very simple ERC20 Token example, where all tokens are pre-assigned\n', ' * to the creator. Note they can later distribute these tokens\n', ' * as they wish using `transfer` and other `StandardToken` functions.\n', ' */\n', 'contract TestToken is StandardToken {\n', '\n', '    string public name = "Test";\n', '    string public symbol = "TST";\n', '    uint public decimals = 18;\n', '    uint public INITIAL_SUPPLY = 10**(50+18);\n', '\n', '    function TestToken(string _name, string _symbol, uint _decimals) public {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    event Burn(address indexed _burner, uint _value);\n', '\n', '    function burn(uint _value) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(msg.sender, _value);\n', '        Transfer(msg.sender, address(0x0), _value);\n', '        return true;\n', '    }\n', '\n', '    // save some gas by making only one contract call\n', '    function burnFrom(address _from, uint256 _value) public returns (bool) {\n', '        transferFrom( _from, msg.sender, _value );\n', '        return burn(_value);\n', '    }\n', '}']
