['pragma solidity ^0.4.23;\n', 'library SafeMath{\n', '    function add(uint a,uint b) internal pure returns(uint c){\n', '        c=a+b;\n', '        require(c>=a);\n', '    }\n', '    function sub(uint a,uint b) internal pure returns(uint c){\n', '        require(b<=a);\n', '        c=a-b;\n', '    }\n', '    function mul(uint a,uint b) internal pure returns(uint c){\n', '        c=a*b;\n', '        require(a==0||c/a==b);\n', '    }\n', '    function div(uint a,uint b) internal pure returns(uint c){\n', '        require(a==b*c+a%b);\n', '        c=a/b;\n', '    }\n', '}\n', 'interface ERC20{\n', '  function totalSupply() external returns(uint);\n', '\n', '  function banlanceOf(address tonkenOwner) external returns(uint balance);\n', '\n', '  function allowance(address tokenOwner,address spender) external returns(uint remaining);\n', '\n', '  function transfer(address to,uint tokens) external returns(bool success);\n', '\n', '  function approve(address spender,uint tokens) external returns(bool success);\n', '\n', '  function transferFrom(address from,address to,uint tokens) external returns(bool success);\n', '  \n', '  event Transfer(address indexed from,address indexed to,uint tokens);\n', '  event Approval(address indexed spender,address indexed to,uint tokens);\n', '}\n', 'interface ApproveAndCallFallBack{\n', '  function receiverApproval(address from,uint tokens,address token,bytes date) public;\n', '}\n', '\n', 'interface ContractRceiver{\n', '    function tokenFallBack(address _from,uint _value,bytes _data) public;\n', '}\n', 'interface ERC223{\n', '    function transfer(address to,uint value,bytes data) public returns(bool ok);\n', '    event Transfer(address indexed from,address indexed to,uint value,bytes indexed data);\n', '}\n', 'contract Owned{\n', '    address public owner;\n', '    address public newOwner;\n', '    event transferownership(address indexed from,address indexed to);\n', '    constructor() public{\n', '        owner=msg.sender;\n', '    }\n', '    modifier onlyOwner{\n', '        require(msg.sender==owner);\n', '        _;\n', '    }\n', '    function ownershiptransferred(address _newOwner) public onlyOwner{\n', '        newOwner=_newOwner;\n', '    }\n', '    function acceptowner() public{\n', '        require(msg.sender==newOwner);\n', '        emit transferownership(owner,newOwner);\n', '        owner=newOwner;\n', '        newOwner=address(0);\n', '    }\n', '}\n', 'contract BCBtokens is ERC20,ERC223,Owned{\n', ' using SafeMath for uint;\n', ' string public symbol;\n', ' string public name;\n', ' uint8 public decimals;\n', ' uint256 _totalSupply;\n', ' mapping(address=>uint) balances;\n', ' mapping(address=>mapping(address=>uint)) allowed;\n', ' constructor() public{\n', '     symbol = "BCB";\n', '     name="BCB";\n', '     decimals=18;\n', '     _totalSupply=99000000*10**18;\n', '     balances[owner] = _totalSupply;\n', '     emit Transfer(address(0),owner,_totalSupply);\n', '  }\n', '  function Iscontract(address _addr) public view returns(bool success){\n', '      uint length;\n', '      assembly{\n', '          length:=extcodesize(_addr)\n', '      }\n', '      return (length>0);\n', '  }\n', '   \n', '  function totalSupply() public view returns(uint){\n', '      return _totalSupply.sub(balances[address(0)]);\n', '  }\n', '  function banlanceOf(address tokenOwner) public returns(uint balance){\n', '      return balances[tokenOwner];\n', '  }\n', '  function transfer(address to,uint tokens) public returns(bool success){\n', '      balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '      balances[to] = balances[to].add(tokens);\n', '      emit Transfer(msg.sender,to,tokens);\n', '      return true;\n', '  }\n', '  function transfer(address to ,uint value,bytes data) public returns(bool ok){\n', '      if(Iscontract(to)){\n', '          balances[msg.sender]=balances[msg.sender].sub(value);\n', '          balances[to] = balances[to].add(value);\n', '          ContractRceiver c = ContractRceiver(to);\n', '          c.tokenFallBack(msg.sender,value,data);\n', '          emit Transfer(msg.sender,to,value,data);\n', '          return true;\n', '      }\n', '  }\n', '  function approve(address spender,uint tokens) public returns(bool success){\n', '      allowed[msg.sender][spender]=tokens;\n', '      emit Approval(msg.sender,spender,tokens);\n', '      return true;\n', '  }\n', '  function transferFrom(address from,address to,uint tokens) public returns(bool success){\n', '      balances[from] = balances[from].sub(tokens);\n', '      allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '      balances[to] = balances[to].add(tokens);\n', '      return true;\n', '  }\n', '  function allowance(address tokenOwner,address spender) public returns(uint remaining){\n', '      return allowed[tokenOwner][spender];\n', '  }\n', '     function approveAndCall(address spender,uint tokens,bytes data) public returns(bool success){\n', '    allowed[msg.sender][spender]=tokens;\n', '    emit Approval(msg.sender,spender,tokens);\n', '    ApproveAndCallFallBack(spender).receiverApproval(msg.sender,tokens,this,data);\n', '    return true;\n', '  }\n', '  function () public payable{\n', '    revert();\n', '  }\n', '}']