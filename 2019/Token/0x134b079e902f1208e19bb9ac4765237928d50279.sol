['pragma solidity 0.5.9;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        ERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '    internal\n', '    {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract TokenTimelock is Ownable {\n', '    using SafeERC20 for ERC20;\n', '    using SafeMath for uint256;\n', '\n', '    ERC20 public token;\n', '\n', '    struct User {\n', '        uint deposit;\n', '        uint balance;\n', '        uint releaseTime;\n', '        uint step;\n', '    }\n', '\n', '    mapping(address => User) public users;\n', '\n', '    uint public releaseStep = 90 days;\n', '    uint public releaseStepCount = 8;\n', '    uint public releaseStepPercent = 12500;\n', '\n', '    constructor(ERC20 _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    function addTokens(address _user, uint256 _value) onlyOwner external returns (bool) {\n', '        require(_user != address(0));\n', '        require(users[_user].deposit == 0);\n', '        require(_value > 0);\n', '\n', '        token.safeTransferFrom(msg.sender, address(this), _value);\n', '\n', '        users[_user].deposit = _value;\n', '        users[_user].balance = _value;\n', '        users[_user].releaseTime = now + 720 days;\n', '    }\n', '\n', '\n', '    function getTokens() external {\n', '        require(users[msg.sender].balance > 0);\n', '        uint currentStep = getCurrentStep(msg.sender);\n', '        require(currentStep > 0);\n', '        require(currentStep > users[msg.sender].step);\n', '\n', '        if (currentStep == releaseStepCount) {\n', '            users[msg.sender].step = releaseStepCount;\n', '            token.safeTransfer(msg.sender, users[msg.sender].balance);\n', '            users[msg.sender].balance = 0;\n', '        } else {\n', '            uint p = releaseStepPercent * (currentStep - users[msg.sender].step);\n', '            uint val = _valueFromPercent(users[msg.sender].deposit, p);\n', '\n', '            if (users[msg.sender].balance >= val) {\n', '                users[msg.sender].balance = users[msg.sender].balance.sub(val);\n', '                token.safeTransfer(msg.sender, val);\n', '            }\n', '\n', '            users[msg.sender].step = currentStep;\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function getCurrentStep(address _user) public view returns (uint) {\n', '        require(users[_user].deposit != 0);\n', '        uint _id;\n', '        \n', '        if (users[_user].releaseTime >= now) {\n', '            uint _count = (users[_user].releaseTime - now) / releaseStep;\n', '            _count = _count == releaseStepCount ? _count : _count + 1;\n', '            _id = releaseStepCount - _count;\n', '        } else _id = releaseStepCount;\n', '\n', '        return _id;\n', '    }\n', '    \n', ' \n', '     \n', '\n', '    //1% - 1000, 10% - 10000 50% - 50000\n', '    function _valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount)    {\n', '        uint _amount = _value.mul(_percent).div(100000);\n', '        return (_amount);\n', '    }\n', '\n', '    function getUser(address _user) public view returns(uint, uint, uint, uint){\n', '        return (users[_user].deposit, users[_user].balance, users[_user].step, users[_user].releaseTime);\n', '    }\n', '}']