['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-07\n', '*/\n', '\n', 'pragma solidity ^0.5.10;\n', '\n', '/* MintHelper for BitcoinSoV\n', ' * Based off https://github.com/0xbitcoin/mint-helper\n', ' * 1% Burn fee comes from mining pool&#39;s fee, allowing miner payout contract to receive its full share.\n', ' * https://www.btcsov.com\n', ' */\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC918Interface {\n', '  function totalSupply() public view returns (uint);\n', '  function getMiningDifficulty() public view returns (uint);\n', '  function getMiningTarget() public view returns (uint);\n', '  function getMiningReward() public view returns (uint);\n', '  function balanceOf(address tokenOwner) public view returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '}\n', '\n', '/*\n', 'The owner (or anyone) will deposit tokens in here\n', 'The owner calls the multisend method to send out payments\n', '*/\n', 'contract MintHelper is Ownable {\n', '   using SafeMath for uint;\n', '\n', '    string public name;\n', '    address public mintableToken;\n', '    address public payoutsWallet;\n', '    address public minterWallet;\n', '    uint public minterFeePercent;\n', '\n', '    constructor(address mToken, address pWallet, address mWallet, string memory mName, uint256 mMintFeePct)\n', '    public\n', '    {\n', '      mintableToken = mToken;\n', '      payoutsWallet = pWallet;\n', '      minterWallet = mWallet;\n', '      name = mName;\n', '      \n', '      minterFeePercent = mMintFeePct;\n', '    }\n', '\n', '    function setMintableToken(address mToken)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      mintableToken = mToken;\n', '      return true;\n', '    }\n', '\n', '    function setPayoutsWallet(address pWallet)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      payoutsWallet = pWallet;\n', '      return true;\n', '    }\n', '\n', '    function setMinterWallet(address mWallet)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      minterWallet = mWallet;\n', '      return true;\n', '    }\n', '\n', '    function setMinterFeePercent(uint fee)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '      require(fee >= 0 && fee <= 100, "Fee not within range");\n', '      minterFeePercent = fee;\n', '      return true;\n', '    }\n', '\n', '    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n', '    public\n', '    returns (bool)\n', '    {\n', '      //identify the rewards that will be won and how to split them up\n', '      uint totalReward = ERC918Interface(mintableToken).getMiningReward();\n', '\n', '      // Pool fee covers the 0.5 BSOV (1%) burned. Payout fund gets the 90% it expects.\n', '      uint burnAmount = totalReward.div(100);\n', '      uint minterReward = totalReward.mul(minterFeePercent).div(100).sub(burnAmount);\n', '      uint payoutReward = totalReward.sub(minterReward);\n', '      \n', '      // get paid in new tokens\n', '      require(ERC918Interface(mintableToken).mint(nonce, challenge_digest), "Could not mint token");\n', '\n', '      //transfer the tokens to the correct wallets\n', '      require(ERC20Interface(mintableToken).transfer(minterWallet, minterReward), "Could not transfer minter fee of token");\n', '      require(ERC20Interface(mintableToken).transfer(payoutsWallet, payoutReward), "Could not transfer minter fee of token");\n', '\n', '      return true;\n', '    }\n', '\n', '    //withdraw any eth inside\n', '    function withdraw()\n', '    public onlyOwner\n', '    {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    //send tokens out\n', '    function send(address _tokenAddr, address dest, uint value)\n', '    public onlyOwner\n', '    returns (bool)\n', '    {\n', '     return ERC20Interface(_tokenAddr).transfer(dest, value);\n', '    }\n', '}']