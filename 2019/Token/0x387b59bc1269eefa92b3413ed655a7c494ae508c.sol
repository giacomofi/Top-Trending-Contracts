['pragma solidity ^0.4.19;\n', 'contract ERC721 {\n', '   string constant private tokenName = "ENCRYPTOART";\n', '   string constant private tokenSymbol = "ENA";\n', '   uint256 constant private totalTokens = 10000000000;\n', '   mapping(address => uint) private balances;\n', '   mapping(uint256 => address) private tokenOwners;\n', '   mapping(uint256 => bool) private tokenExists;\n', '   mapping(address => mapping (address => uint256)) private allowed;\n', '   mapping(address => mapping(uint256 => uint256)) private ownerTokens;\n', '   \n', '   mapping(uint256 => string) tokenLinks;\n', '   function name() public constant returns (string){\n', '       return tokenName;\n', '   }\n', '   function symbol() public constant returns (string) {\n', '       return tokenSymbol;\n', '   }\n', '   function totalSupply() public constant returns (uint256){\n', '       return totalTokens;\n', '   }\n', '   function balanceOf(address _owner) constant returns (uint){\n', '       return balances[_owner];\n', '   }\n', '   function ownerOf(uint256 _tokenId) constant returns (address){\n', '       require(tokenExists[_tokenId]);\n', '       return tokenOwners[_tokenId];\n', '   }\n', '   function approve(address _to, uint256 _tokenId){\n', '       require(msg.sender == ownerOf(_tokenId));\n', '       require(msg.sender != _to);\n', '       allowed[msg.sender][_to] = _tokenId;\n', '       Approval(msg.sender, _to, _tokenId);\n', '   }\n', '   function takeOwnership(uint256 _tokenId){\n', '       require(tokenExists[_tokenId]);\n', '       address oldOwner = ownerOf(_tokenId);\n', '       address newOwner = msg.sender;\n', '       require(newOwner != oldOwner);\n', '       require(allowed[oldOwner][newOwner] == _tokenId);\n', '       balances[oldOwner] -= 1;\n', '       tokenOwners[_tokenId] = newOwner;\n', '       balances[oldOwner] += 1;\n', '       Transfer(oldOwner, newOwner, _tokenId);\n', '   }\n', '   function transfer(address _to, uint256 _tokenId){\n', '       address currentOwner = msg.sender;\n', '       address newOwner = _to;\n', '       require(tokenExists[_tokenId]);\n', '       require(currentOwner == ownerOf(_tokenId));\n', '       require(currentOwner != newOwner);\n', '       require(newOwner != address(0));\n', '       require(allowed[currentOwner][newOwner] == _tokenId);\n', '       balances[currentOwner] -= 1;\n', '       tokenOwners[_tokenId] = newOwner;\n', '       balances[newOwner] += 1;\n', '       Transfer(currentOwner, newOwner, _tokenId);\n', '   }\n', '   function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId){\n', '       return ownerTokens[_owner][_index];\n', '   }\n', '   function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl){\n', '       return tokenLinks[_tokenId];\n', '   }\n', '   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '}']
['pragma solidity ^0.4.19;\n', 'contract ERC721 {\n', '   string constant private tokenName = "ENCRYPTOART";\n', '   string constant private tokenSymbol = "ENA";\n', '   uint256 constant private totalTokens = 10000000000;\n', '   mapping(address => uint) private balances;\n', '   mapping(uint256 => address) private tokenOwners;\n', '   mapping(uint256 => bool) private tokenExists;\n', '   mapping(address => mapping (address => uint256)) private allowed;\n', '   mapping(address => mapping(uint256 => uint256)) private ownerTokens;\n', '   \n', '   mapping(uint256 => string) tokenLinks;\n', '   function name() public constant returns (string){\n', '       return tokenName;\n', '   }\n', '   function symbol() public constant returns (string) {\n', '       return tokenSymbol;\n', '   }\n', '   function totalSupply() public constant returns (uint256){\n', '       return totalTokens;\n', '   }\n', '   function balanceOf(address _owner) constant returns (uint){\n', '       return balances[_owner];\n', '   }\n', '   function ownerOf(uint256 _tokenId) constant returns (address){\n', '       require(tokenExists[_tokenId]);\n', '       return tokenOwners[_tokenId];\n', '   }\n', '   function approve(address _to, uint256 _tokenId){\n', '       require(msg.sender == ownerOf(_tokenId));\n', '       require(msg.sender != _to);\n', '       allowed[msg.sender][_to] = _tokenId;\n', '       Approval(msg.sender, _to, _tokenId);\n', '   }\n', '   function takeOwnership(uint256 _tokenId){\n', '       require(tokenExists[_tokenId]);\n', '       address oldOwner = ownerOf(_tokenId);\n', '       address newOwner = msg.sender;\n', '       require(newOwner != oldOwner);\n', '       require(allowed[oldOwner][newOwner] == _tokenId);\n', '       balances[oldOwner] -= 1;\n', '       tokenOwners[_tokenId] = newOwner;\n', '       balances[oldOwner] += 1;\n', '       Transfer(oldOwner, newOwner, _tokenId);\n', '   }\n', '   function transfer(address _to, uint256 _tokenId){\n', '       address currentOwner = msg.sender;\n', '       address newOwner = _to;\n', '       require(tokenExists[_tokenId]);\n', '       require(currentOwner == ownerOf(_tokenId));\n', '       require(currentOwner != newOwner);\n', '       require(newOwner != address(0));\n', '       require(allowed[currentOwner][newOwner] == _tokenId);\n', '       balances[currentOwner] -= 1;\n', '       tokenOwners[_tokenId] = newOwner;\n', '       balances[newOwner] += 1;\n', '       Transfer(currentOwner, newOwner, _tokenId);\n', '   }\n', '   function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId){\n', '       return ownerTokens[_owner][_index];\n', '   }\n', '   function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl){\n', '       return tokenLinks[_tokenId];\n', '   }\n', '   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '}']
