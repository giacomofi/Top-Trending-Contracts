['pragma solidity ^0.5.0;\n', '\n', ' /// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', ' /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public view returns (uint);\n', '  function allowance(address owner, address spender) public view returns (uint);\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '\n', '/// @title PayFair contract - standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', 'contract PayFair is SafeMath, ERC20, Ownable {\n', ' string public name = "PayFair Token";\n', ' string public symbol = "PFR";\n', ' uint public constant decimals = 8;\n', ' uint public constant FROZEN_TOKENS = 11e6;\n', ' uint public constant MULTIPLIER = 10 ** decimals;\n', ' ERC20 public oldToken;\n', ' \n', ' /// approve() allowances\n', ' mapping (address => mapping (address => uint)) allowed;\n', ' /// holder balances\n', ' mapping(address => uint) balances;\n', ' \n', ' /// @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', ' /// @param size payload size\n', ' modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4);\n', '    _;\n', ' }\n', '\n', ' /// @dev Constructor\n', ' constructor (address oldTokenAdddress) public {\n', '   owner = msg.sender;\n', '   oldToken = ERC20(oldTokenAdddress);\n', '   \n', '   totalSupply = convertToDecimal(FROZEN_TOKENS);\n', '   balances[owner] = convertToDecimal(FROZEN_TOKENS);\n', ' }\n', '\n', ' /// Fallback method will buyout tokens\n', ' function() external payable {\n', '   revert();\n', ' }\n', '\n', ' function upgradeTokens(uint amountToUpgrade) public {  \n', '    require(amountToUpgrade <= convertToDecimal(oldToken.balanceOf(msg.sender)));\n', '    require(amountToUpgrade <= convertToDecimal(oldToken.allowance(msg.sender, address(this))));   \n', '    \n', '    emit Transfer(address(0), msg.sender, amountToUpgrade);\n', '    totalSupply = safeAdd(totalSupply, amountToUpgrade);\n', '    balances[msg.sender] = safeAdd(balances[msg.sender], amountToUpgrade);\n', '    oldToken.transferFrom(msg.sender, address(0x0), amountToUpgrade);\n', ' }\n', '\n', ' /// @dev Converts token value to value with decimal places\n', ' /// @param amount Source token value\n', ' function convertToDecimal(uint amount) private pure returns (uint) {\n', '   return safeMul(amount, MULTIPLIER);\n', ' }\n', '\n', ' /// @dev Tranfer tokens to address\n', ' /// @param _to dest address\n', ' /// @param _value tokens amount\n', ' /// @return transfer result\n', ' function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '   balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '   balances[_to] = safeAdd(balances[_to], _value);\n', '\n', '   emit Transfer(msg.sender, _to, _value);\n', '   return true;\n', ' }\n', '\n', ' /// @dev Tranfer tokens from one address to other\n', ' /// @param _from source address\n', ' /// @param _to dest address\n', ' /// @param _value tokens amount\n', ' /// @return transfer result\n', ' function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', ' }\n', ' /// @dev Tokens balance\n', ' /// @param _owner holder address\n', ' /// @return balance amount\n', ' function balanceOf(address _owner) public view returns (uint balance) {\n', '   return balances[_owner];\n', ' }\n', '\n', ' /// @dev Approve transfer\n', ' /// @param _spender holder address\n', ' /// @param _value tokens amount\n', ' /// @return result\n', ' function approve(address _spender, uint _value) public returns (bool success) {\n', '   // To change the approve amount you first have to reduce the addresses`\n', '   //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '   //  already 0 to mitigate the race condition described here:\n', '   //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   require ((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '   allowed[msg.sender][_spender] = _value;\n', '   emit Approval(msg.sender, _spender, _value);\n', '   return true;\n', ' }\n', '\n', ' /// @dev Token allowance\n', ' /// @param _owner holder address\n', ' /// @param _spender spender address\n', ' /// @return remain amount\n', ' function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '   return allowed[_owner][_spender];\n', ' }\n', '}']
['pragma solidity ^0.5.0;\n', '\n', ' /// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', ' /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public view returns (uint);\n', '  function allowance(address owner, address spender) public view returns (uint);\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '\n', '/// @title PayFair contract - standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', 'contract PayFair is SafeMath, ERC20, Ownable {\n', ' string public name = "PayFair Token";\n', ' string public symbol = "PFR";\n', ' uint public constant decimals = 8;\n', ' uint public constant FROZEN_TOKENS = 11e6;\n', ' uint public constant MULTIPLIER = 10 ** decimals;\n', ' ERC20 public oldToken;\n', ' \n', ' /// approve() allowances\n', ' mapping (address => mapping (address => uint)) allowed;\n', ' /// holder balances\n', ' mapping(address => uint) balances;\n', ' \n', ' /// @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', ' /// @param size payload size\n', ' modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4);\n', '    _;\n', ' }\n', '\n', ' /// @dev Constructor\n', ' constructor (address oldTokenAdddress) public {\n', '   owner = msg.sender;\n', '   oldToken = ERC20(oldTokenAdddress);\n', '   \n', '   totalSupply = convertToDecimal(FROZEN_TOKENS);\n', '   balances[owner] = convertToDecimal(FROZEN_TOKENS);\n', ' }\n', '\n', ' /// Fallback method will buyout tokens\n', ' function() external payable {\n', '   revert();\n', ' }\n', '\n', ' function upgradeTokens(uint amountToUpgrade) public {  \n', '    require(amountToUpgrade <= convertToDecimal(oldToken.balanceOf(msg.sender)));\n', '    require(amountToUpgrade <= convertToDecimal(oldToken.allowance(msg.sender, address(this))));   \n', '    \n', '    emit Transfer(address(0), msg.sender, amountToUpgrade);\n', '    totalSupply = safeAdd(totalSupply, amountToUpgrade);\n', '    balances[msg.sender] = safeAdd(balances[msg.sender], amountToUpgrade);\n', '    oldToken.transferFrom(msg.sender, address(0x0), amountToUpgrade);\n', ' }\n', '\n', ' /// @dev Converts token value to value with decimal places\n', ' /// @param amount Source token value\n', ' function convertToDecimal(uint amount) private pure returns (uint) {\n', '   return safeMul(amount, MULTIPLIER);\n', ' }\n', '\n', ' /// @dev Tranfer tokens to address\n', ' /// @param _to dest address\n', ' /// @param _value tokens amount\n', ' /// @return transfer result\n', ' function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '   balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '   balances[_to] = safeAdd(balances[_to], _value);\n', '\n', '   emit Transfer(msg.sender, _to, _value);\n', '   return true;\n', ' }\n', '\n', ' /// @dev Tranfer tokens from one address to other\n', ' /// @param _from source address\n', ' /// @param _to dest address\n', ' /// @param _value tokens amount\n', ' /// @return transfer result\n', ' function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', ' }\n', ' /// @dev Tokens balance\n', ' /// @param _owner holder address\n', ' /// @return balance amount\n', ' function balanceOf(address _owner) public view returns (uint balance) {\n', '   return balances[_owner];\n', ' }\n', '\n', ' /// @dev Approve transfer\n', ' /// @param _spender holder address\n', ' /// @param _value tokens amount\n', ' /// @return result\n', ' function approve(address _spender, uint _value) public returns (bool success) {\n', '   // To change the approve amount you first have to reduce the addresses`\n', '   //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '   //  already 0 to mitigate the race condition described here:\n', '   //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   require ((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '   allowed[msg.sender][_spender] = _value;\n', '   emit Approval(msg.sender, _spender, _value);\n', '   return true;\n', ' }\n', '\n', ' /// @dev Token allowance\n', ' /// @param _owner holder address\n', ' /// @param _spender spender address\n', ' /// @return remain amount\n', ' function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '   return allowed[_owner][_spender];\n', ' }\n', '}']
