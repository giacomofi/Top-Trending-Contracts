['pragma solidity 0.5.3;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\n', '        require(token.approve(spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title TokenDistributor\n', ' * @dev This contract is a token holder contract that will \n', ' * allow beneficiaries to release the tokens in ten six-months period intervals.\n', ' */\n', 'contract TokenDistributor is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event TokensReleased(address account, uint256 amount);\n', '\n', '    // ERC20 basic token contract being held\n', '    IERC20 private _token;\n', '\n', '    // timestamp when token release is enabled\n', '    uint256 private _releaseTime;\n', '\n', '    uint256 private _totalReleased;\n', '    mapping(address => uint256) private _released;\n', '\n', '    // beneficiary of tokens that are released\n', '    address private _beneficiary1;\n', '    address private _beneficiary2;\n', '    address private _beneficiary3;\n', '    address private _beneficiary4;\n', '\n', '    uint256 public releasePerStep = uint256(1000000) * 10 ** 18;\n', '\n', '    /**\n', '     * @dev Constructor\n', '     */\n', '    constructor (IERC20 token, uint256 releaseTime, address beneficiary1, address beneficiary2, address beneficiary3, address beneficiary4) public {\n', '        _token = token;\n', '        _releaseTime = releaseTime;\n', '        _beneficiary1 = beneficiary1;\n', '        _beneficiary2 = beneficiary2;\n', '        _beneficiary3 = beneficiary3;\n', '        _beneficiary4 = beneficiary4;\n', '    }\n', '\n', '    /**\n', '     * @return the token being held.\n', '     */\n', '    function token() public view returns (IERC20) {\n', '        return _token;\n', '    }\n', '\n', '    /**\n', '     * @return the total amount already released.\n', '     */\n', '    function totalReleased() public view returns (uint256) {\n', '        return _totalReleased;\n', '    }\n', '\n', '    /**\n', '     * @return the amount already released to an account.\n', '     */\n', '    function released(address account) public view returns (uint256) {\n', '        return _released[account];\n', '    }\n', '\n', '    /**\n', '     * @return the beneficiary1 of the tokens.\n', '     */\n', '    function beneficiary1() public view returns (address) {\n', '        return _beneficiary1;\n', '    }\n', '\n', '    /**\n', '     * @return the beneficiary2 of the tokens.\n', '     */\n', '    function beneficiary2() public view returns (address) {\n', '        return _beneficiary2;\n', '    }\n', '\n', '    /**\n', '     * @return the beneficiary3 of the tokens.\n', '     */\n', '    function beneficiary3() public view returns (address) {\n', '        return _beneficiary3;\n', '    }\n', '\n', '    /**\n', '     * @return the beneficiary4 of the tokens.\n', '     */\n', '    function beneficiary4() public view returns (address) {\n', '        return _beneficiary4;\n', '    }\n', '\n', '    /**\n', '     * @return the time when the tokens are released.\n', '     */\n', '    function releaseTime() public view returns (uint256) {\n', '        return _releaseTime;\n', '    }\n', '\n', '    /**\n', "     * @dev Release one of the beneficiary's tokens.\n", '     * @param account Whose tokens will be sent to.\n', '     * @param amount Value in wei to send to the account.\n', '     */\n', '    function releaseToAccount(address account, uint256 amount) internal {\n', "        require(amount != 0, 'The amount must be greater than zero.');\n", '\n', '        _released[account] = _released[account].add(amount);\n', '        _totalReleased = _totalReleased.add(amount);\n', '\n', '        _token.safeTransfer(account, amount);\n', '        emit TokensReleased(account, amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers 1000000 tokens in each interval(six-months timelocks) to beneficiaries.\n', '     */\n', '    function release() onlyOwner public {\n', "        require(block.timestamp >= releaseTime(), 'Teamï¿½s tokens can be released every six months.');\n", '\n', '        uint256 _value1 = releasePerStep.mul(10).div(100);      //10%\n', '        uint256 _value2 = releasePerStep.mul(68).div(100);      //68%\n', '        uint256 _value3 = releasePerStep.mul(12).div(100);      //12%\n', '        uint256 _value4 = releasePerStep.mul(10).div(100);      //10%\n', '\n', '        _releaseTime = _releaseTime.add(180 days);\n', '\n', '        releaseToAccount(_beneficiary1, _value1);\n', '        releaseToAccount(_beneficiary2, _value2);\n', '        releaseToAccount(_beneficiary3, _value3);\n', '        releaseToAccount(_beneficiary4, _value4);\n', '    }\n', '}']