['// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC20Detailed token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @return the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @return the symbol of the token.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @return the number of decimals of the token.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://eips.ethereum.org/EIPS/eip-20\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', "     * @dev Approve an address to spend another addresses' tokens.\n", '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '\n', '// File: contracts/lib/CommonValidationsLibrary.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'library CommonValidationsLibrary {\n', '\n', '    /**\n', '     * Ensures that an address array is not empty.\n', '     *\n', '     * @param  _addressArray       Address array input\n', '     */\n', '    function validateNonEmpty(\n', '        address[] calldata _addressArray\n', '    )\n', '        external\n', '        pure\n', '    {\n', '        require(\n', '            _addressArray.length > 0,\n', '            "Address array length must be > 0"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Ensures that an address array and uint256 array are equal length\n', '     *\n', '     * @param  _addressArray       Address array input\n', '     * @param  _uint256Array       Uint256 array input\n', '     */\n', '    function validateEqualLength(\n', '        address[] calldata _addressArray,\n', '        uint256[] calldata _uint256Array\n', '    )\n', '        external\n', '        pure\n', '    {\n', '        require(\n', '            _addressArray.length == _uint256Array.length,\n', '            "Input length mismatch"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/lib/CommonMath.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'library CommonMath {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUInt256()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0);\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Checks for rounding errors and returns value of potential partial amounts of a principal\n', '     *\n', '     * @param  _principal       Number fractional amount is derived from\n', '     * @param  _numerator       Numerator of fraction\n', '     * @param  _denominator     Denominator of fraction\n', '     * @return uint256          Fractional amount of principal calculated\n', '     */\n', '    function getPartialAmount(\n', '        uint256 _principal,\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Get remainder of partial amount (if 0 not a partial amount)\n', '        uint256 remainder = mulmod(_principal, _numerator, _denominator);\n', '\n', '        // Return if not a partial amount\n', '        if (remainder == 0) {\n', '            return _principal.mul(_numerator).div(_denominator);\n', '        }\n', '\n', '        // Calculate error percentage\n', '        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\n', '\n', '        // Require error percentage is less than 0.1%.\n', '        require(\n', '            errPercentageTimes1000000 < 1000,\n', '            "CommonMath.getPartialAmount: Rounding error exceeds bounds"\n', '        );\n', '\n', '        return _principal.mul(_numerator).div(_denominator);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/core/interfaces/ISetFactory.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title ISetFactory\n', ' * @author Set Protocol\n', ' *\n', ' * The ISetFactory interface provides operability for authorized contracts\n', ' * to interact with SetTokenFactory\n', ' */\n', 'interface ISetFactory {\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * Return core address\n', '     *\n', '     * @return address        core address\n', '     */\n', '    function core()\n', '        external\n', '        returns (address);\n', '\n', '    /**\n', '     * Deploys a new Set Token and adds it to the valid list of SetTokens\n', '     *\n', '     * @param  _components           The address of component tokens\n', '     * @param  _units                The units of each component token\n', '     * @param  _naturalUnit          The minimum unit to be issued or redeemed\n', '     * @param  _name                 The bytes32 encoded name of the new Set\n', '     * @param  _symbol               The bytes32 encoded symbol of the new Set\n', '     * @param  _callData             Byte string containing additional call parameters\n', '     * @return setTokenAddress       The address of the new Set\n', '     */\n', '    function createSet(\n', '        address[] calldata _components,\n', '        uint[] calldata _units,\n', '        uint256 _naturalUnit,\n', '        bytes32 _name,\n', '        bytes32 _symbol,\n', '        bytes calldata _callData\n', '    )\n', '        external\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/core/tokens/SetToken.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SetToken\n', ' * @author Set Protocol\n', ' *\n', ' * Implementation of the basic Set token.\n', ' */\n', 'contract SetToken is\n', '    ERC20,\n', '    ERC20Detailed\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    uint256 public naturalUnit;\n', '    address[] public components;\n', '    uint256[] public units;\n', '\n', '    // Mapping of componentHash to isComponent\n', '    mapping(address => bool) internal isComponent;\n', '\n', '    // Address of the Factory contract that created the SetToken\n', '    address public factory;\n', '\n', '    /* ============ Constructor ============ */\n', '\n', '    /**\n', '     * Constructor function for Set token\n', '     *\n', '     * As looping operations are expensive, checking for duplicates will be on the onus of the application developer\n', '     *\n', '     * @param _factory          The factory used to create the Set Token\n', '     * @param _components       A list of component address which you want to include\n', '     * @param _units            A list of quantities of each component (corresponds to the Set of _components)\n', '     * @param _naturalUnit      The minimum multiple of Sets that can be issued or redeemed\n', "     * @param _name             The Set's name\n", "     * @param _symbol           The Set's symbol\n", '     */\n', '    constructor(\n', '        address _factory,\n', '        address[] memory _components,\n', '        uint256[] memory _units,\n', '        uint256 _naturalUnit,\n', '        string memory _name,\n', '        string memory _symbol\n', '    )\n', '        public\n', '        ERC20Detailed(\n', '            _name,\n', '            _symbol,\n', '            18\n', '        )\n', '    {\n', '        // Storing count and unit counts to local variable to save on invocation\n', '        uint256 unitCount = _units.length;\n', '\n', '        // Require naturalUnit passed is greater than 0\n', '        require(\n', '            _naturalUnit > 0,\n', '            "SetToken.constructor: Natural unit must be positive"\n', '        );\n', '\n', '        // Confirm an empty _components array is not passed\n', '        CommonValidationsLibrary.validateNonEmpty(_components);\n', '\n', '        // Confirm there is one quantity for every token address\n', '        CommonValidationsLibrary.validateEqualLength(_components, _units);\n', '\n', '        // NOTE: It will be the onus of developers to check whether the addressExists\n', '        // are in fact ERC20 addresses\n', '        uint8 minDecimals = 18;\n', '        uint8 currentDecimals;\n', '        for (uint256 i = 0; i < unitCount; i++) {\n', '            // Check that all units are non-zero\n', '            uint256 currentUnits = _units[i];\n', '            require(\n', '                currentUnits > 0,\n', '                "SetToken.constructor: Units must be positive"\n', '            );\n', '\n', '            // Check that all addresses are non-zero\n', '            address currentComponent = _components[i];\n', '            require(\n', '                currentComponent != address(0),\n', '                "SetToken.constructor: Invalid component address"\n', '            );\n', '\n', '            // Figure out which of the components has the minimum decimal value\n', '            /* solium-disable-next-line security/no-low-level-calls */\n', '            (bool success, ) = currentComponent.call(abi.encodeWithSignature("decimals()"));\n', '            if (success) {\n', '                currentDecimals = ERC20Detailed(currentComponent).decimals();\n', '                minDecimals = currentDecimals < minDecimals ? currentDecimals : minDecimals;\n', '            } else {\n', '                // If one of the components does not implement decimals, we assume the worst\n', '                // and set minDecimals to 0\n', '                minDecimals = 0;\n', '            }\n', '\n', '            // Check the component has not already been added\n', '            require(\n', '                !tokenIsComponent(currentComponent),\n', '                "SetToken.constructor: Duplicated component"\n', '            );\n', '\n', '            // Add component to isComponent mapping\n', '            isComponent[currentComponent] = true;\n', '\n', '            // Add component data to components and units state variables\n', '            components.push(currentComponent);\n', '            units.push(currentUnits);\n', '        }\n', '\n', '        // This is the minimum natural unit possible for a Set with these components.\n', '        require(\n', '            _naturalUnit >= CommonMath.safePower(10, uint256(18).sub(minDecimals)),\n', '            "SetToken.constructor: Invalid natural unit"\n', '        );\n', '\n', '        factory = _factory;\n', '        naturalUnit = _naturalUnit;\n', '    }\n', '\n', '    /* ============ Public Functions ============ */\n', '\n', '    /*\n', '     * Mint set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _issuer      The address of the issuing account\n', '     * @param  _quantity    The number of sets to attribute to issuer\n', '     */\n', '    function mint(\n', '        address _issuer,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        // Check that function caller is Core\n', '        require(\n', '            msg.sender == ISetFactory(factory).core(),\n', '            "SetToken.mint: Sender must be core"\n', '        );\n', '\n', '        _mint(_issuer, _quantity);\n', '    }\n', '\n', '    /*\n', '     * Burn set token for given address.\n', '     * Can only be called by authorized contracts.\n', '     *\n', '     * @param  _from        The address of the redeeming account\n', '     * @param  _quantity    The number of sets to burn from redeemer\n', '     */\n', '    function burn(\n', '        address _from,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        // Check that function caller is Core\n', '        require(\n', '            msg.sender == ISetFactory(factory).core(),\n', '            "SetToken.burn: Sender must be core"\n', '        );\n', '\n', '        _burn(_from, _quantity);\n', '    }\n', '\n', '    /*\n', '     * Get addresses of all components in the Set\n', '     *\n', '     * @return  componentAddresses       Array of component tokens\n', '     */\n', '    function getComponents()\n', '        external\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return components;\n', '    }\n', '\n', '    /*\n', '     * Get units of all tokens in Set\n', '     *\n', '     * @return  units       Array of component units\n', '     */\n', '    function getUnits()\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        return units;\n', '    }\n', '\n', '    /*\n', "     * Validates address is member of Set's components\n", '     *\n', '     * @param  _tokenAddress     Address of token being checked\n', "     * @return  bool             Whether token is member of Set's components\n", '     */\n', '    function tokenIsComponent(\n', '        address _tokenAddress\n', '    )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isComponent[_tokenAddress];\n', '    }\n', '}']