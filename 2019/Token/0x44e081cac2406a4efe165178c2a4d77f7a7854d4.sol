['// File: contracts/lib/interface/IEthPool.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '/**\n', ' * @title EthPool interface\n', ' */\n', 'interface IEthPool {\n', '    function deposit(address _receiver) external payable;\n', '\n', '    function withdraw(uint _value) external;\n', '\n', '    function approve(address _spender, uint _value) external returns (bool);\n', '\n', '    function transferFrom(address _from, address payable _to, uint _value) external returns (bool);\n', '\n', '    function transferToCelerWallet(address _from, address _walletAddr, bytes32 _walletId, uint _value) external returns (bool);\n', '\n', '    function increaseAllowance(address _spender, uint _addedValue) external returns (bool);\n', '\n', '    function decreaseAllowance(address _spender, uint _subtractedValue) external returns (bool);\n', '\n', '    function balanceOf(address _owner) external view returns (uint);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '\n', '    event Deposit(address indexed receiver, uint value);\n', '    \n', '    // transfer from "from" account inside EthPool to real "to" address outside EthPool\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// File: contracts/lib/interface/ICelerWallet.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '/**\n', ' * @title CelerWallet interface\n', ' */\n', 'interface ICelerWallet {\n', '    function create(address[] calldata _owners, address _operator, bytes32 _nonce) external returns(bytes32);\n', '\n', '    function depositETH(bytes32 _walletId) external payable;\n', '\n', '    function depositERC20(bytes32 _walletId, address _tokenAddress, uint _amount) external;\n', '    \n', '    function withdraw(bytes32 _walletId, address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function transferToWallet(bytes32 _fromWalletId, bytes32 _toWalletId, address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function transferOperatorship(bytes32 _walletId, address _newOperator) external;\n', '\n', '    function proposeNewOperator(bytes32 _walletId, address _newOperator) external;\n', '\n', '    function drainToken(address _tokenAddress, address _receiver, uint _amount) external;\n', '\n', '    function getWalletOwners(bytes32 _walletId) external view returns(address[] memory);\n', '\n', '    function getOperator(bytes32 _walletId) external view returns(address);\n', '\n', '    function getBalance(bytes32 _walletId, address _tokenAddress) external view returns(uint);\n', '\n', '    function getProposedNewOperator(bytes32 _walletId) external view returns(address);\n', '\n', '    function getProposalVote(bytes32 _walletId, address _owner) external view returns(bool);\n', '\n', '    event CreateWallet(bytes32 indexed walletId, address[] indexed owners, address indexed operator);\n', '\n', '    event DepositToWallet(bytes32 indexed walletId, address indexed tokenAddress, uint amount);\n', '\n', '    event WithdrawFromWallet(bytes32 indexed walletId, address indexed tokenAddress, address indexed receiver, uint amount);\n', '\n', '    event TransferToWallet(bytes32 indexed fromWalletId, bytes32 indexed toWalletId, address indexed tokenAddress, address receiver, uint amount);\n', '\n', '    event ChangeOperator(bytes32 indexed walletId, address indexed oldOperator, address indexed newOperator);\n', '\n', '    event ProposeNewOperator(bytes32 indexed walletId, address indexed newOperator, address indexed proposer);\n', '\n', '    event DrainToken(address indexed tokenAddress, address indexed receiver, uint amount);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/EthPool.sol\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ETH Pool providing an ERC20 like interface\n', ' * @notice Implementation of an ERC20 like pool for native ETH.\n', ' * @dev Originally based on code of ERC20 by openzeppelin-solidity v2.1.2\n', ' *   https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.1.2/contracts/token/ERC20/ERC20.sol\n', ' */ \n', 'contract EthPool is IEthPool {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) private balances;\n', '    mapping (address => mapping (address => uint)) private allowed;\n', '    \n', '    // mock ERC20 details to enable etherscan-like tools to monitor EthPool correctly\n', '    string public constant name = "EthInPool";\n', '    string public constant symbol = "EthIP";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /**\n', '     * @notice Deposit ETH to ETH Pool\n', '     * @param _receiver the address ETH is deposited to \n', '     */\n', '    function deposit(address _receiver) public payable {\n', '        require(_receiver != address(0), "Receiver address is 0");\n', '\n', '        balances[_receiver] = balances[_receiver].add(msg.value);\n', '        emit Deposit(_receiver, msg.value);\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw ETH from ETH Pool\n', '     * @param _value the amount of ETH to withdraw\n', '     */\n', '    function withdraw(uint _value) public {\n', '        _transfer(msg.sender, msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '     * @notice Approve the passed address to spend the specified amount of ETH on behalf of msg.sender.\n', '     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     *   and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     *   race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of ETH to be spent.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(_spender != address(0), "Spender address is 0");\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer ETH from one address to another.\n', '     * @dev Note that while this function emits an Approval event, this is not required as per the specification.\n', '     * @param _from The address which you want to transfer ETH from\n', '     * @param _to The address which you want to transfer to\n', '     * @param _value the amount of ETH to be transferred\n', '     */\n', '    function transferFrom(address _from, address payable _to, uint _value) public returns (bool) {\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer ETH from one address to a wallet in CelerWallet contract.\n', '     * @param _from The address which you want to transfer ETH from\n', '     * @param _walletAddr CelerWallet address which should have a depositETH(bytes32) payable API\n', '     * @param _walletId id of the wallet you want to deposit ETH into\n', '     * @param _value the amount of ETH to be transferred\n', '     */\n', '    function transferToCelerWallet(\n', '        address _from,\n', '        address _walletAddr,\n', '        bytes32 _walletId,\n', '        uint _value\n', '    )\n', '        external\n', '        returns (bool)\n', '    {\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        emit Transfer(_from, _walletAddr, _value);\n', '\n', '        ICelerWallet wallet = ICelerWallet(_walletAddr);\n', '        wallet.depositETH.value(_value)(_walletId);\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Increase the amount of ETH that an owner allowed to a spender.\n', '     * @dev approve should be called when allowed[msg.sender][spender] == 0. To increment\n', '     *   allowed value is better to use this function to avoid 2 calls (and wait until\n', '     *   the first transaction is mined)\n', '     *   From MonolithDAO Token.sol\n', '     *   Emits an Approval event.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of ETH to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address _spender, uint _addedValue) public returns (bool) {\n', '        require(_spender != address(0), "Spender address is 0");\n', '\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Decrease the amount of ETH that an owner allowed to a spender.\n', '     * @dev approve should be called when allowed[msg.sender][spender] == 0. To decrement\n', '     *   allowed value is better to use this function to avoid 2 calls (and wait until\n', '     *   the first transaction is mined)\n', '     *   From MonolithDAO Token.sol\n', '     *   Emits an Approval event.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of ETH to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address _spender, uint _subtractedValue) public returns (bool) {\n', '        require(_spender != address(0), "Spender address is 0");\n', '\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].sub(_subtractedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the balance of the specified address.\n', '     * @param _owner The address to query the balance of.\n', '     * @return An uint representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @notice Function to check the amount of ETH that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint specifying the amount of ETH still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer ETH for a specified addresses\n', '     * @param _from The address to transfer from.\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function _transfer(address _from, address payable _to, uint _value) internal {\n', '        require(_to != address(0), "To address is 0");\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        _to.transfer(_value);\n', '    }\n', '}']