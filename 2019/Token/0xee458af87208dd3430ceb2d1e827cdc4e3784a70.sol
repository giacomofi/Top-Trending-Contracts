['/**\n', ' * Source Code first verified at https://etherscan.io on Monday, November 26, 2018\n', ' (UTC) */\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', 'library SafeMath {\n', '        function mul (uint256 a, uint256 b) internal pure returns (uint256) {\n', '                if (a == 0) {\n', '                        return 0;\n', '                }\n', '                uint256 c = a * b;\n', '                assert(c / a == b);\n', '                return c;\n', '        }\n', '\n', '        function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '                return a / b;\n', '        }\n', '\n', '        function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '                assert(b <= a);\n', '                return a - b;\n', '        }\n', '\n', '        function add (uint256 a, uint256 b) internal pure returns (uint256) {\n', '                uint256 c = a + b;\n', '                assert(c >= a);\n', '                return c;\n', '        }\n', '}\n', '\n', 'contract ERCBasic {\n', '        event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '        function totalSupply () public view returns (uint256);\n', '        function balanceOf (address who) public view returns (uint256);\n', '        function transfer (address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract ERC is ERCBasic {\n', '        event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '        function transferFrom (address from, address to, uint256 value) public returns (bool);\n', '        function allowance (address owner, address spender) public view returns (uint256);\n', '        function approve (address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract Ownable {\n', '        \n', '        address payable internal owner;\n', '        address internal foundationOwner;\n', '\n', '        constructor () public {\n', '                owner = msg.sender;\n', '                foundationOwner = owner;\n', '        }\n', '\n', '        modifier onlyOwner () {\n', '                require(msg.sender == owner);\n', '                _;\n', '        }\n', '\n', '        modifier hasMintability () {\n', '                require(msg.sender == owner || msg.sender == foundationOwner);\n', '                _;\n', '        }\n', '\n', '      \n', '}\n', '\n', 'contract Pausable is Ownable {\n', '        event ContractPause();\n', '        event ContractResume();\n', '        event ContractPauseSchedule(uint256 from, uint256 to);\n', '\n', '        uint256 internal pauseFrom;\n', '        uint256 internal pauseTo;\n', '\n', '        modifier whenRunning () {\n', '                require(now < pauseFrom || now > pauseTo);\n', '                _;\n', '        }\n', '\n', '        modifier whenPaused () {\n', '                require(now >= pauseFrom && now <= pauseTo);\n', '                _;\n', '        }\n', '\n', '        function pause () public onlyOwner {\n', '                pauseFrom = now - 1;\n', '                pauseTo = now + 30000 days;\n', '                emit ContractPause();\n', '        }\n', '\n', '        function pause (uint256 from, uint256 to) public onlyOwner {\n', '                require(to > from);\n', '                pauseFrom = from;\n', '                pauseTo = to;\n', '                emit ContractPauseSchedule(from, to);\n', '        }\n', '\n', '        function resume () public onlyOwner {\n', '                pauseFrom = now - 2;\n', '                pauseTo = now - 1;\n', '                emit ContractResume();\n', '        }\n', '}\n', '\n', 'contract TokenForge is Ownable {\n', '        event ForgeStart();\n', '        event ForgeStop();\n', '\n', '        bool public forge_running = true;\n', '\n', '        modifier canForge () {\n', '                require(forge_running);\n', '                _;\n', '        }\n', '\n', '        modifier cannotForge () {\n', '                require(!forge_running);\n', '                _;\n', '        }\n', '\n', '        function startForge () public onlyOwner cannotForge returns (bool) {\n', '                forge_running = true;\n', '                emit ForgeStart();\n', '                return true;\n', '        }\n', '\n', '        function stopForge () public onlyOwner canForge returns (bool) {\n', '                forge_running = false;\n', '                emit ForgeStop();\n', '                return true;\n', '        }\n', '}\n', '\n', 'contract CappedToken is Ownable {\n', '        using SafeMath for uint256;\n', '\n', '        uint256 public token_cap;\n', '        uint256 public token_created;\n', '        uint256 public token_foundation_cap;\n', '        uint256 public token_foundation_created;\n', '\n', '\n', '        constructor (uint256 _cap, uint256 _foundationCap) public {\n', '                token_cap = _cap;\n', '                token_foundation_cap = _foundationCap;\n', '        }\n', '\n', '        function changeCap (uint256 _cap) public onlyOwner returns (bool) {\n', '                if (_cap < token_created && _cap > 0) return false;\n', '                token_cap = _cap;\n', '                return true;\n', '        }\n', '\n', '        function canMint (uint256 amount) public view returns (bool) {\n', '                return (token_cap == 0) || (token_created.add(amount) <= token_cap);\n', '        }\n', '        \n', '        function canMintFoundation(uint256 amount) internal view returns(bool) {\n', '                return(token_foundation_created.add(amount) <= token_foundation_cap);\n', '        }\n', '}\n', '\n', 'contract BasicToken is ERCBasic, Pausable {\n', '        using SafeMath for uint256;\n', '\n', '        mapping(address => uint256) public wallets;\n', '\n', '        modifier canTransfer (address _from, address _to, uint256 amount) {\n', '                require((_from != address(0)) && (_to != address(0)));\n', '                require(_from != _to);\n', '                require(amount > 0);\n', '                _;\n', '        }\n', '\n', '        function balanceOf (address user) public view returns (uint256) {\n', '                return wallets[user];\n', '        }\n', '}\n', '\n', 'contract DelegatableToken is ERC, BasicToken {\n', '        using SafeMath for uint256;\n', '\n', '        mapping(address => mapping(address => uint256)) public warrants;\n', '\n', '        function allowance (address owner, address delegator) public view returns (uint256) {\n', '                return warrants[owner][delegator];\n', '        }\n', '\n', '        function approve (address delegator, uint256 value) public whenRunning returns (bool) {\n', '                if (delegator == msg.sender) return true;\n', '                warrants[msg.sender][delegator] = value;\n', '                emit Approval(msg.sender, delegator, value);\n', '                return true;\n', '        }\n', '\n', '        function increaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\n', '                if (delegator == msg.sender) return true;\n', '                uint256 value = warrants[msg.sender][delegator].add(delta);\n', '                warrants[msg.sender][delegator] = value;\n', '                emit Approval(msg.sender, delegator, value);\n', '                return true;\n', '        }\n', '\n', '        function decreaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\n', '                if (delegator == msg.sender) return true;\n', '                uint256 value = warrants[msg.sender][delegator];\n', '                if (value < delta) {\n', '                        value = 0;\n', '                }\n', '                else {\n', '                        value = value.sub(delta);\n', '                }\n', '                warrants[msg.sender][delegator] = value;\n', '                emit Approval(msg.sender, delegator, value);\n', '                return true;\n', '        }\n', '}\n', '\n', 'contract LockableProtocol is BasicToken {\n', '        function invest (address investor, uint256 amount) public returns (bool);\n', '        function getInvestedToken (address investor) public view returns (uint256);\n', '        function getLockedToken (address investor) public view returns (uint256);\n', '        function availableWallet (address user) public view returns (uint256) {\n', '                return wallets[user].sub(getLockedToken(user));\n', '        }\n', '}\n', '\n', 'contract MintAndBurnToken is TokenForge, CappedToken, LockableProtocol {\n', '        using SafeMath for uint256;\n', '        \n', '        event Mint(address indexed user, uint256 amount);\n', '        event Burn(address indexed user, uint256 amount);\n', '\n', '        constructor (uint256 _initial, uint256 _cap, uint256 _qnetCap) public CappedToken(_cap, _qnetCap) {\n', '                token_created = _initial;\n', '                wallets[msg.sender] = _initial;\n', '\n', '        emit Mint(msg.sender, _initial);\n', '        emit Transfer(address(0), msg.sender, _initial);\n', '        }\n', '\n', '        function totalSupply () public view returns (uint256) {\n', '                return token_created;\n', '        }\n', '\n', '        function totalQnetSupply() public view returns(uint256) {\n', '                return token_foundation_created;\n', '        }\n', '\n', '        function mint (address target, uint256 amount) public hasMintability whenRunning canForge returns (bool) {\n', '                require(target != owner && target != foundationOwner);\n', '                require(canMint(amount));\n', '\n', '        if (msg.sender == foundationOwner) {\n', '                require(canMintFoundation(amount));\n', '                token_foundation_created = token_foundation_created.add(amount);\n', '        }\n', '        \n', '        token_created = token_created.add(amount);\n', '        wallets[target] = wallets[target].add(amount);\n', '\n', '        emit Mint(target, amount);\n', '        emit Transfer(address(0), target, amount);\n', '        return true;\n', '        }\n', '\n', '        function burn (uint256 amount) public whenRunning canForge returns (bool) {\n', '                uint256 balance = availableWallet(msg.sender);\n', '                require(amount <= balance);\n', '\n', '        token_created = token_created.sub(amount);\n', '        wallets[msg.sender] -= amount;\n', '\n', '        emit Burn(msg.sender, amount);\n', '        emit Transfer(msg.sender, address(0), amount);\n', '\n', '        return true;\n', '        }\n', '}\n', '\n', 'contract LockableToken is MintAndBurnToken, DelegatableToken {\n', '        using SafeMath for uint256;\n', '\n', '        struct LockBin {\n', '                uint256 start;\n', '                uint256 finish;\n', '                uint256 duration;\n', '                uint256 amount;\n', '        }\n', '\n', '        event InvestStart();\n', '        event InvestStop();\n', '        event NewInvest(uint256 release_start, uint256 release_duration);\n', '\n', '        uint256 public releaseStart;\n', '        uint256 public releaseDuration;\n', '        bool public forceStopInvest;\n', '        mapping(address => mapping(uint => LockBin)) public lockbins;\n', '\n', '        modifier canInvest () {\n', '                require(!forceStopInvest);\n', '                _;\n', '        }\n', '\n', '        constructor (uint256 _initial, uint256 _cap, uint256 _qnetCap) public MintAndBurnToken(_initial, _cap, _qnetCap) {\n', '                forceStopInvest = true;\n', '        }\n', '\n', '        function pauseInvest () public onlyOwner whenRunning returns (bool) {\n', '                require(!forceStopInvest);\n', '                forceStopInvest = true;\n', '                emit InvestStop();\n', '                return true;\n', '        }\n', '\n', '        function resumeInvest () public onlyOwner whenRunning returns (bool) {\n', '                require(forceStopInvest);\n', '                forceStopInvest = false;\n', '                emit InvestStart();\n', '                return true;\n', '        }\n', '\n', '        function setInvest (uint256 release_start, uint256 release_duration) public onlyOwner whenRunning returns (bool) {\n', '                releaseStart = release_start;\n', '                releaseDuration = release_duration;\n', '                forceStopInvest = false;\n', '\n', '        emit NewInvest(release_start, release_duration);\n', '        return true;\n', '        }\n', '\n', '        function invest (address investor, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\n', '                require(investor != address(0));\n', '                require(investor != owner);\n', '                require(investor != foundationOwner);\n', '                require(amount > 0);\n', '                require(canMint(amount));\n', '\n', '        mapping(uint => LockBin) storage locks = lockbins[investor];\n', '        LockBin storage info = locks[0];\n', '        uint index = info.amount + 1;\n', '        locks[index] = LockBin({\n', '                start: releaseStart,\n', '                finish: releaseStart + releaseDuration,\n', '                duration: releaseDuration / (1 days),\n', '                amount: amount\n', '        });\n', '        info.amount = index;\n', '\n', '        token_created = token_created.add(amount);\n', '        wallets[investor] = wallets[investor].add(amount);\n', '        emit Mint(investor, amount);\n', '        emit Transfer(address(0), investor, amount);\n', '\n', '        return true;\n', '        }\n', '\n', '        function batchInvest (address[] memory investors, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\n', '                require(amount > 0);\n', '\n', '        uint investorsLength = investors.length;\n', '        uint investorsCount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < investorsLength; i ++) {\n', '                r = investors[i];\n', '                if (r == address(0) || r == owner || r == foundationOwner) continue;\n', '                investorsCount ++;\n', '        }\n', '        require(investorsCount > 0);\n', '\n', '        uint256 totalAmount = amount.mul(uint256(investorsCount));\n', '        require(canMint(totalAmount));\n', '\n', '        token_created = token_created.add(totalAmount);\n', '\n', '        for (i = 0; i < investorsLength; i ++) {\n', '                r = investors[i];\n', '                if (r == address(0) || r == owner || r == foundationOwner) continue;\n', '\n', '        mapping(uint => LockBin) storage locks = lockbins[r];\n', '        LockBin storage info = locks[0];\n', '        uint index = info.amount + 1;\n', '        locks[index] = LockBin({\n', '                start: releaseStart,\n', '                finish: releaseStart + releaseDuration,\n', '                duration: releaseDuration / (1 days),\n', '                amount: amount\n', '        });\n', '        info.amount = index;\n', '\n', '        wallets[r] = wallets[r].add(amount);\n', '        emit Mint(r, amount);\n', '        emit Transfer(address(0), r, amount);\n', '        }\n', '\n', '        return true;\n', '        }\n', '\n', '        function batchInvests (address[] memory investors, uint256[] memory amounts) public onlyOwner whenRunning canInvest returns (bool) {\n', '                uint investorsLength = investors.length;\n', '                require(investorsLength == amounts.length);\n', '\n', '        uint investorsCount = 0;\n', '        uint256 totalAmount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < investorsLength; i ++) {\n', '                r = investors[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                investorsCount ++;\n', '                totalAmount += amounts[i];\n', '        }\n', '        require(totalAmount > 0);\n', '        require(canMint(totalAmount));\n', '\n', '        uint256 amount;\n', '        token_created = token_created.add(totalAmount);\n', '        for (i = 0; i < investorsLength; i ++) {\n', '                r = investors[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                amount = amounts[i];\n', '                wallets[r] = wallets[r].add(amount);\n', '                emit Mint(r, amount);\n', '                emit Transfer(address(0), r, amount);\n', '\n', '        mapping(uint => LockBin) storage locks = lockbins[r];\n', '        LockBin storage info = locks[0];\n', '        uint index = info.amount + 1;\n', '        locks[index] = LockBin({\n', '                start: releaseStart,\n', '                finish: releaseStart + releaseDuration,\n', '                duration: releaseDuration / (1 days),\n', '                amount: amount\n', '        });\n', '        info.amount = index;\n', '        }\n', '\n', '        return true;\n', '        }\n', '\n', '        function getInvestedToken (address investor) public view returns (uint256) {\n', '                require(investor != address(0) && investor != owner && investor != foundationOwner);\n', '\n', '        mapping(uint => LockBin) storage locks = lockbins[investor];\n', '        uint256 balance = 0;\n', '        uint l = locks[0].amount;\n', '        for (uint i = 1; i <= l; i ++) {\n', '                LockBin memory bin = locks[i];\n', '                balance = balance.add(bin.amount);\n', '        }\n', '        return balance;\n', '        }\n', '\n', '        function getLockedToken (address investor) public view returns (uint256) {\n', '                require(investor != address(0) && investor != owner && investor != foundationOwner);\n', '\n', '        mapping(uint => LockBin) storage locks = lockbins[investor];\n', '        uint256 balance = 0;\n', '        uint256 d = 1;\n', '        uint l = locks[0].amount;\n', '        for (uint i = 1; i <= l; i ++) {\n', '                LockBin memory bin = locks[i];\n', '                if (now <= bin.start) {\n', '                        balance = balance.add(bin.amount);\n', '                }\n', '                else if (now < bin.finish) {\n', '                        d = (now - bin.start) / (1 days);\n', '                        balance = balance.add(bin.amount - bin.amount * d / bin.duration);\n', '                }\n', '        }\n', '        return balance;\n', '        }\n', '\n', '        function canPay (address user, uint256 amount) internal view returns (bool) {\n', '                uint256 balance = availableWallet(user);\n', '                return amount <= balance;\n', '        }\n', '\n', '        function transfer (address target, uint256 value) public whenRunning canTransfer(msg.sender, target, value) returns (bool) {\n', '                require(target != owner);\n', '                require(canPay(msg.sender, value));\n', '\n', '        wallets[msg.sender] = wallets[msg.sender].sub(value);\n', '        wallets[target] = wallets[target].add(value);\n', '        emit Transfer(msg.sender, target, value);\n', '        return true;\n', '        }\n', '\n', '\n', '        function batchTransfer (address[] memory receivers, uint256 amount) public whenRunning returns (bool) {\n', '                require(amount > 0);\n', '\n', '        uint receiveLength = receivers.length;\n', '        uint receiverCount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < receiveLength; i ++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                receiverCount ++;\n', '        }\n', '        require(receiverCount > 0);\n', '\n', '        uint256 totalAmount = amount.mul(uint256(receiverCount));\n', '        require(canPay(msg.sender, totalAmount));\n', '\n', '        wallets[msg.sender] -= totalAmount;\n', '        for (i = 0; i < receiveLength; i++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                wallets[r] = wallets[r].add(amount);\n', '                emit Transfer(msg.sender, r, amount);\n', '        }\n', '        return true;\n', '        }\n', '\n', '        function batchTransfers (address[] memory receivers, uint256[] memory amounts) public whenRunning returns (bool) {\n', '                uint receiveLength = receivers.length;\n', '                require(receiveLength == amounts.length);\n', '\n', '        uint receiverCount = 0;\n', '        uint256 totalAmount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < receiveLength; i ++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                receiverCount ++;\n', '                totalAmount += amounts[i];\n', '        }\n', '        require(totalAmount > 0);\n', '        require(canPay(msg.sender, totalAmount));\n', '\n', '        wallets[msg.sender] -= totalAmount;\n', '        uint256 amount;\n', '        for (i = 0; i < receiveLength; i++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                amount = amounts[i];\n', '                if (amount == 0) continue;\n', '                wallets[r] = wallets[r].add(amount);\n', '                emit Transfer(msg.sender, r, amount);\n', '        }\n', '        return true;\n', '        }\n', '\n', '        function transferFrom (address from, address to, uint256 value) public whenRunning canTransfer(from, to, value) returns (bool) {\n', '                require(from != owner);\n', '                require(to != owner);\n', '                require(canPay(from, value));\n', '\n', '        uint256 warrant;\n', '        if (msg.sender != from) {\n', '                warrant = warrants[from][msg.sender];\n', '                require(value <= warrant);\n', '                warrants[from][msg.sender] = warrant.sub(value);\n', '        }\n', '\n', '        wallets[from] = wallets[from].sub(value);\n', '        wallets[to] = wallets[to].add(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '        }\n', '\n', '        function batchTransferFrom (address from, address[] memory  receivers, uint256 amount) public whenRunning returns (bool) {\n', '                require(from != address(0) && from != owner);\n', '                require(amount > 0);\n', '\n', '        uint receiveLength = receivers.length;\n', '        uint receiverCount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < receiveLength; i ++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                receiverCount ++;\n', '        }\n', '        require(receiverCount > 0);\n', '\n', '        uint256 totalAmount = amount.mul(uint256(receiverCount));\n', '        require(canPay(from, totalAmount));\n', '\n', '        uint256 warrant;\n', '        if (msg.sender != from) {\n', '                warrant = warrants[from][msg.sender];\n', '                require(totalAmount <= warrant);\n', '                warrants[from][msg.sender] = warrant.sub(totalAmount);\n', '        }\n', '\n', '        wallets[from] -= totalAmount;\n', '        for (i = 0; i < receiveLength; i++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                wallets[r] = wallets[r].add(amount);\n', '                emit Transfer(from, r, amount);\n', '        }\n', '        return true;\n', '        }\n', '\n', '        function batchTransferFroms (address from, address[] memory receivers, uint256[] memory amounts) public whenRunning returns (bool) {\n', '                require(from != address(0) && from != owner);\n', '\n', '        uint receiveLength = receivers.length;\n', '        require(receiveLength == amounts.length);\n', '\n', '        uint receiverCount = 0;\n', '        uint256 totalAmount = 0;\n', '        uint i;\n', '        address r;\n', '        for (i = 0; i < receiveLength; i ++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                receiverCount ++;\n', '                totalAmount += amounts[i];\n', '        }\n', '        require(totalAmount > 0);\n', '        require(canPay(from, totalAmount));\n', '\n', '        uint256 warrant;\n', '        if (msg.sender != from) {\n', '                warrant = warrants[from][msg.sender];\n', '                require(totalAmount <= warrant);\n', '                warrants[from][msg.sender] = warrant.sub(totalAmount);\n', '        }\n', '\n', '        wallets[from] -= totalAmount;\n', '        uint256 amount;\n', '        for (i = 0; i < receiveLength; i++) {\n', '                r = receivers[i];\n', '                if (r == address(0) || r == owner) continue;\n', '                amount = amounts[i];\n', '                if (amount == 0) continue;\n', '                wallets[r] = wallets[r].add(amount);\n', '                emit Transfer(from, r, amount);\n', '        }\n', '        return true;\n', '        }\n', '}\n', '\n', 'contract DaccToken is LockableToken {\n', '        string  public constant name     = "Distributed Adult Art & Culture";\n', '        string  public constant symbol   = "DACC";\n', '        uint8   public constant decimals = 18;\n', '\n', '        uint256 private constant TOKEN_CAP     = 1000000000 * 10 ** uint256(decimals);\n', '        uint256 private constant TOKEN_FOUNDATION_CAP = 1000000000   * 10 ** uint256(decimals);\n', '        uint256 private constant TOKEN_INITIAL = 0   * 10 ** uint256(decimals);\n', '\n', '        constructor () public LockableToken(TOKEN_INITIAL, TOKEN_CAP, TOKEN_FOUNDATION_CAP) {\n', '        }\n', '\n', '        \n', ' \t    function suicideQent () public onlyOwner{\n', '             selfdestruct(owner);\n', '        }\n', '        \n', '}']