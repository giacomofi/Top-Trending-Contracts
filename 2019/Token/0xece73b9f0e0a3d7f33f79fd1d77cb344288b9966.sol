['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-09\n', '*/\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', 'interface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    function transferTo(address _to, uint256 _value) public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed _burner, uint256 _value);\n', '}\n', '\n', 'contract StdToken is Token {\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    uint public supply;\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferTo(address _to, uint256 _value) public returns (bool) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _burn(address _burner, uint256 _value) internal returns (bool) {\n', '        require(_value > 0);\n', '        require(balances[_burner] > 0);\n', '        balances[_burner] -= _value;\n', '        supply -= _value;\n', '        emit Burn(_burner, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract RVG is owned, StdToken {\n', '\n', '    string public name = "Revolution Global";\n', '    string public symbol = "RVG";\n', '    string public website = "www.rvgtoken.io";\n', '    uint public decimals = 18;\n', '\n', '    uint256 public totalSupplied;\n', '    uint256 public totalBurned;\n', '\n', '    constructor(uint256 _totalSupply) public {\n', '        supply = _totalSupply * (1 ether / 1 wei);\n', '        totalBurned = 0;\n', '        totalSupplied = 0;\n', '        balances[address(this)] = supply;\n', '    }\n', '\n', '    function transferTo(address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        totalSupplied += _value;\n', '        _transfer(address(this), _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function burn() public onlyOwner returns (bool) {\n', '        uint256 remainBalance = supply - totalSupplied;\n', '        uint256 burnAmount = remainBalance / 10;\n', '        totalBurned += burnAmount;\n', '        _burn(address(this), burnAmount);\n', '        return true;\n', '    }\n', '\n', '    function burnByValue(uint256 _value) public onlyOwner returns (bool) {\n', '        totalBurned += _value;\n', '        _burn(address(this), _value);\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'interface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    function transferTo(address _to, uint256 _value) public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed _burner, uint256 _value);\n', '}\n', '\n', 'contract StdToken is Token {\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    uint public supply;\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferTo(address _to, uint256 _value) public returns (bool) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _burn(address _burner, uint256 _value) internal returns (bool) {\n', '        require(_value > 0);\n', '        require(balances[_burner] > 0);\n', '        balances[_burner] -= _value;\n', '        supply -= _value;\n', '        emit Burn(_burner, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract RVG is owned, StdToken {\n', '\n', '    string public name = "Revolution Global";\n', '    string public symbol = "RVG";\n', '    string public website = "www.rvgtoken.io";\n', '    uint public decimals = 18;\n', '\n', '    uint256 public totalSupplied;\n', '    uint256 public totalBurned;\n', '\n', '    constructor(uint256 _totalSupply) public {\n', '        supply = _totalSupply * (1 ether / 1 wei);\n', '        totalBurned = 0;\n', '        totalSupplied = 0;\n', '        balances[address(this)] = supply;\n', '    }\n', '\n', '    function transferTo(address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        totalSupplied += _value;\n', '        _transfer(address(this), _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function burn() public onlyOwner returns (bool) {\n', '        uint256 remainBalance = supply - totalSupplied;\n', '        uint256 burnAmount = remainBalance / 10;\n', '        totalBurned += burnAmount;\n', '        _burn(address(this), burnAmount);\n', '        return true;\n', '    }\n', '\n', '    function burnByValue(uint256 _value) public onlyOwner returns (bool) {\n', '        totalBurned += _value;\n', '        _burn(address(this), _value);\n', '        return true;\n', '    }\n', '}']
