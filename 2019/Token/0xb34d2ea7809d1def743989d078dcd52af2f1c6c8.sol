['pragma solidity 0.5.2;\n', '\n', 'contract ERC20 {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  event OwnershipTransferred(address indexed oldone, address indexed newone);\n', '  event ERC20TragetChanged(address indexed oldToken, address indexed newToken);\n', '\n', '  address public owner;\n', '  address public tokenAddr;\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '    tokenAddr = address(0);\n', '  }\n', '\n', '  modifier onlyOwner () {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership (address newOwner) public returns (bool);\n', '  function setERC20 (address newTokenAddr) public returns (bool);\n', '}\n', '\n', '\n', '\n', 'contract TokenMerge is Ownable {\n', '\n', '  function takeStock(address[] memory tokenFrom, uint256[] memory amounts, address[] memory tokenTo) public onlyOwner {\n', '    ERC20 token = ERC20(tokenAddr);\n', '    require(tokenFrom.length == amounts.length);\n', '\n', '    if (tokenTo.length == 1){\n', '      for(uint i = 0; i < tokenFrom.length; i++) {\n', '        require(token.transferFrom(tokenFrom[i], tokenTo[0], amounts[i]));\n', '      }\n', '    }\n', '    else {\n', '      require(tokenFrom.length == tokenTo.length);\n', '      for(uint i = 0; i < tokenFrom.length; i++) {\n', '        require(token.transferFrom(tokenFrom[i], tokenTo[i], amounts[i]));\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  function flushStock(address[] memory tokenFrom, address tokenTo) public onlyOwner {\n', '    ERC20 token = ERC20(tokenAddr);\n', '    require(tokenFrom.length > 0 );\n', '\n', '    for(uint i = 0; i < tokenFrom.length; i++) {\n', '      require(token.transferFrom(tokenFrom[i], tokenTo, token.balanceOf(tokenFrom[i])));\n', '    }\n', '  } \n', '\n', '\n', '  function multiSendEth(address payable[] memory addresses) public payable{\n', '    uint addressesLength = addresses.length;\n', '    require(addressesLength > 0);\n', '      for(uint i = 0; i < addressesLength; i++) {\n', '        addresses[i].transfer(msg.value / addressesLength);\n', '      }\n', '    msg.sender.transfer(address(this).balance);\n', '  }\n', '\n', '\n', '  function transferOwnership (address newOwner) public onlyOwner returns (bool) {\n', '    require(newOwner != address(0));\n', '    require(newOwner != owner);\n', '\n', '    address oldOwner = owner;\n', '    owner = newOwner;\n', '    emit OwnershipTransferred(oldOwner, newOwner);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '  function setERC20 (address newTokenAddr) public onlyOwner returns (bool) {\n', '    require(newTokenAddr != tokenAddr);\n', '\n', '    address oldTokenAddr = tokenAddr;\n', '    tokenAddr = newTokenAddr;\n', '    emit ERC20TragetChanged(oldTokenAddr, newTokenAddr);\n', '    \n', '    return true;\n', '  }\n', '}']
['pragma solidity 0.5.2;\n', '\n', 'contract ERC20 {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  event OwnershipTransferred(address indexed oldone, address indexed newone);\n', '  event ERC20TragetChanged(address indexed oldToken, address indexed newToken);\n', '\n', '  address public owner;\n', '  address public tokenAddr;\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '    tokenAddr = address(0);\n', '  }\n', '\n', '  modifier onlyOwner () {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership (address newOwner) public returns (bool);\n', '  function setERC20 (address newTokenAddr) public returns (bool);\n', '}\n', '\n', '\n', '\n', 'contract TokenMerge is Ownable {\n', '\n', '  function takeStock(address[] memory tokenFrom, uint256[] memory amounts, address[] memory tokenTo) public onlyOwner {\n', '    ERC20 token = ERC20(tokenAddr);\n', '    require(tokenFrom.length == amounts.length);\n', '\n', '    if (tokenTo.length == 1){\n', '      for(uint i = 0; i < tokenFrom.length; i++) {\n', '        require(token.transferFrom(tokenFrom[i], tokenTo[0], amounts[i]));\n', '      }\n', '    }\n', '    else {\n', '      require(tokenFrom.length == tokenTo.length);\n', '      for(uint i = 0; i < tokenFrom.length; i++) {\n', '        require(token.transferFrom(tokenFrom[i], tokenTo[i], amounts[i]));\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  function flushStock(address[] memory tokenFrom, address tokenTo) public onlyOwner {\n', '    ERC20 token = ERC20(tokenAddr);\n', '    require(tokenFrom.length > 0 );\n', '\n', '    for(uint i = 0; i < tokenFrom.length; i++) {\n', '      require(token.transferFrom(tokenFrom[i], tokenTo, token.balanceOf(tokenFrom[i])));\n', '    }\n', '  } \n', '\n', '\n', '  function multiSendEth(address payable[] memory addresses) public payable{\n', '    uint addressesLength = addresses.length;\n', '    require(addressesLength > 0);\n', '      for(uint i = 0; i < addressesLength; i++) {\n', '        addresses[i].transfer(msg.value / addressesLength);\n', '      }\n', '    msg.sender.transfer(address(this).balance);\n', '  }\n', '\n', '\n', '  function transferOwnership (address newOwner) public onlyOwner returns (bool) {\n', '    require(newOwner != address(0));\n', '    require(newOwner != owner);\n', '\n', '    address oldOwner = owner;\n', '    owner = newOwner;\n', '    emit OwnershipTransferred(oldOwner, newOwner);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '  function setERC20 (address newTokenAddr) public onlyOwner returns (bool) {\n', '    require(newTokenAddr != tokenAddr);\n', '\n', '    address oldTokenAddr = tokenAddr;\n', '    tokenAddr = newTokenAddr;\n', '    emit ERC20TragetChanged(oldTokenAddr, newTokenAddr);\n', '    \n', '    return true;\n', '  }\n', '}']
