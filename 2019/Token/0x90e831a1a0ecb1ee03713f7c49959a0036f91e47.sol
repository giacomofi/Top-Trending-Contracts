['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract XNR is StandardToken {\n', '  \n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  // Requires that before a function executes either:\n', '  // The global isThawed value is set true\n', '  // The sender is in a whitelisted thawedAddress\n', '  // It has been a year since contract deployment\n', '  modifier requireThawed() {\n', '    require(isThawed == true || thawedAddresses[msg.sender] == true || now > thawTime);\n', '    _;\n', '  }\n', '\n', '  // Applies to thaw functions. Only the designated manager is allowed when this modifier is present\n', '  modifier onlyManager() {\n', '    require(msg.sender == owner || msg.sender == manager);\n', '    _;\n', '  }\n', '\n', '  address owner;\n', '  address manager;\n', '  uint initialBalance;\n', '  string public name;\n', '  string public symbol;\n', '  uint public decimals;\n', '  mapping (uint=>string) public metadata;\n', '  mapping (uint=>string) public publicMetadata;\n', '  bool isThawed = false;\n', '  mapping (address=>bool) public thawedAddresses;\n', '  uint256 thawTime;\n', '\n', '  constructor() public {\n', '    address bountyMgrAddress = address(0x03De5f75915DC5382C5dF82538F8D5e124A7ebB8);\n', '    \n', '    initialBalance = 18666666667 * 1e8;\n', '    uint256 bountyMgrBalance = 933333333 * 1e8;\n', '    totalSupply = initialBalance;\n', '\n', '    balances[msg.sender] = safeSub(initialBalance, bountyMgrBalance);\n', '    balances[bountyMgrAddress] = bountyMgrBalance;\n', '\n', '    Transfer(address(0x0), address(msg.sender), balances[msg.sender]);\n', '    Transfer(address(0x0), address(bountyMgrAddress), balances[bountyMgrAddress]);\n', '\n', '    name = "Neuroneum";\n', '    symbol = "XNR";\n', '    decimals = 8;\n', '    owner = msg.sender;\n', '    thawedAddresses[msg.sender] = true;\n', '    thawedAddresses[bountyMgrAddress] = true;\n', '    thawTime = now + 1 years;\n', '  }\n', '\n', '  // **\n', '  // ** Manager functions **\n', '  // **\n', '  // Thaw a specific address, allowing it to send tokens\n', '  function thawAddress(address _address) onlyManager {\n', '    thawedAddresses[_address] = true;\n', '  }\n', '  // Thaw all addresses. This is irreversible\n', '  function thawAllAddresses() onlyManager {\n', '    isThawed = true;\n', '  }\n', '  // Freeze all addresses except for those whitelisted in thawedAddresses. This is irreversible\n', '  // This only applies if the thawTime has not yet past.\n', '  function freezeAllAddresses() onlyManager {\n', '    isThawed = false;\n', '  }\n', '\n', '  // **\n', '  // ** Owner functions **\n', '  // **\n', '  // Set a new owner\n', '  function setOwner(address _newOwner) onlyOwner {\n', '    owner = _newOwner;\n', '  }\n', '\n', '  // Set a manager, who can unfreeze wallets as needed\n', '  function setManager(address _address) onlyOwner {\n', '    manager = _address;\n', '  }\n', '\n', '  // Change the ticker symbol of the token\n', '  function changeSymbol(string newSymbol) onlyOwner {\n', '    symbol = newSymbol;\n', '  }\n', '\n', '  // Change the long-form name of the token\n', '  function changeName(string newName) onlyOwner {\n', '    name = newName;\n', '  }\n', '\n', '  // Set any admin level metadata needed for XNR mainnet purposes\n', '  function setMetadata(uint key, string value) onlyOwner {\n', '    metadata[key] = value;\n', '  }\n', '\n', '  // Standard ERC20 transfer commands, with additional requireThawed modifier\n', '  function transfer(address _to, uint _value) requireThawed returns (bool success) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '  function transferFrom(address _from, address _to, uint _value) requireThawed returns (bool success) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}']