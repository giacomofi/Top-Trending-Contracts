['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner()  {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = true;\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS paused\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS NOT paused\n', '     */\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyOwner whenNotPaused returns (bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyOwner whenPaused returns (bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '     * @dev transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amout of tokens to be transfered\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '       * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '       * @param _spender The address which will spend the funds.\n', '       * @param _value The amount of tokens to be spent.\n', '       */\n', '      function approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '      }\n', '\n', '      /**\n', '       * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '       * @param _owner address The address which owns the funds.\n', '       * @param _spender address The address which will spend the funds.\n', '       * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '       */\n', '      function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '      }\n', '\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '    bool public mintingFinished = false;\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will recieve the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(0X0, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() public onlyOwner returns (bool) {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BlockableToken is Ownable{\n', '    event Blocked(address blockedAddress);\n', '    event UnBlocked(address unBlockedAddress);\n', '    //keep mapping of blocked addresses\n', '    mapping (address => bool) public blockedAddresses;\n', '    modifier whenNotBlocked(){\n', '      require(!blockedAddresses[msg.sender]);\n', '      _;\n', '    }\n', '\n', '    function blockAddress(address toBeBlocked) onlyOwner public {\n', '      blockedAddresses[toBeBlocked] = true;\n', '      emit Blocked(toBeBlocked);\n', '    }\n', '    function unBlockAddress(address toBeUnblocked) onlyOwner public {\n', '      blockedAddresses[toBeUnblocked] = false;\n', '      emit UnBlocked(toBeUnblocked);\n', '    }\n', '}\n', '\n', '\n', 'contract StrikeToken is MintableToken, Pausable, BlockableToken{\n', '    string public name = "Dimensions Strike Token";\n', '    string public symbol = "DST";\n', '    uint256 public decimals = 18;\n', '\n', '    event Ev(string message, address whom, uint256 val);\n', '\n', '    struct XRec {\n', '        bool inList;\n', '        address next;\n', '        address prev;\n', '        uint256 val;\n', '    }\n', '\n', '    struct QueueRecord {\n', '        address whom;\n', '        uint256 val;\n', '    }\n', '\n', '    address first = 0x0;\n', '    address last = 0x0;\n', '\n', '    mapping (address => XRec) public theList;\n', '\n', '    QueueRecord[]  theQueue;\n', '\n', '    // add a record to the END of the list\n', '    function add(address whom, uint256 value) internal {\n', '        theList[whom] = XRec(true,0x0,last,value);\n', '        if (last != 0x0) {\n', '            theList[last].next = whom;\n', '        } else {\n', '            first = whom;\n', '        }\n', '        last = whom;\n', '        emit Ev("add",whom,value);\n', '    }\n', '\n', '    function remove(address whom) internal {\n', '        if (first == whom) {\n', '            first = theList[whom].next;\n', '            theList[whom] = XRec(false,0x0,0x0,0);\n', '            return;\n', '        }\n', '        address next = theList[whom].next;\n', '        address prev = theList[whom].prev;\n', '        if (prev != 0x0) {\n', '            theList[prev].next = next;\n', '        }\n', '        if (next != 0x0) {\n', '            theList[next].prev = prev;\n', '        }\n', '        theList[whom] =XRec(false,0x0,0x0,0);\n', '        emit Ev("remove",whom,0);\n', '    }\n', '\n', '    function update(address whom, uint256 value) internal {\n', '        if (value != 0) {\n', '            if (!theList[whom].inList) {\n', '                add(whom,value);\n', '            } else {\n', '                theList[whom].val = value;\n', '                emit Ev("update",whom,value);\n', '            }\n', '            return;\n', '        }\n', '        if (theList[whom].inList) {\n', '            remove(whom);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Allows anyone to transfer the Strike tokens once trading has started\n', '     * @param _to the recipient address of the tokens.\n', '     * @param _value number of tokens to be transfered.\n', '     */\n', '    function transfer(address _to, uint _value) public whenNotPaused whenNotBlocked returns (bool) {\n', '        bool result = super.transfer(_to, _value);\n', '        update(msg.sender,balances[msg.sender]);\n', '        update(_to,balances[_to]);\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows anyone to transfer the Strike tokens once trading has started\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint the amout of tokens to be transfered\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public whenNotPaused whenNotBlocked returns (bool) {\n', '        bool result = super.transferFrom(_from, _to, _value);\n', '        update(_from,balances[_from]);\n', '        update(_to,balances[_to]);\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will recieve the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '\n', '    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n', '        bool result = super.mint(_to,_amount);\n', '        update(_to,balances[_to]);\n', '        return result;\n', '    }\n', '\n', '    constructor()  public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function changeOwner(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract StrikeTokenCrowdsale is Ownable, Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    StrikeToken public token = new StrikeToken();\n', '\n', '    // start and end times\n', '    uint256 public startTimestamp = 1575158400;\n', '    uint256 public endTimestamp = 1577750400;\n', '    uint256 etherToWei = 10**18;\n', '\n', '    // address where funds are collected and tokens distributed\n', '    address public hardwareWallet = 0xDe3A91E42E9F6955ce1a9eDb23Be4aBf8d2eb08B;\n', '    address public restrictedWallet = 0xDe3A91E42E9F6955ce1a9eDb23Be4aBf8d2eb08B;\n', '    address public additionalTokensFromCommonPoolWallet = 0xDe3A91E42E9F6955ce1a9eDb23Be4aBf8d2eb08B;\n', '\n', '    mapping (address => uint256) public deposits;\n', '    uint256 public numberOfPurchasers;\n', '\n', '    // Percentage bonus tokens given in Token Sale, on a daily basis\n', '    uint256[] public bonus = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n', '    uint256 public rate = 4800; // 4800 DST is one Ether\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '    uint256 public tokensSold = 0;\n', '    uint256 public advisorTokensGranted = 0;\n', '    uint256 public commonPoolTokensGranted = 0;\n', '\n', '    uint256 public minContribution = 100 * 1 finney;\n', '    uint256 public hardCapEther = 30000;\n', '    uint256 hardcap = hardCapEther * etherToWei;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event MainSaleClosed();\n', '\n', '    uint256 public weiRaisedInPresale  = 0 ether;\n', '\n', '    bool private frozen = false;\n', '\n', '    function freeze() public onlyOwner{\n', '      frozen = true;\n', '    }\n', '    function unfreeze() public onlyOwner{\n', '      frozen = false;\n', '    }\n', '\n', '    modifier whenNotFrozen() {\n', '        require(!frozen);\n', '        _;\n', '    }\n', '    modifier whenFrozen() {\n', '        require(frozen);\n', '        _;\n', '    }\n', '\n', '    function setHardwareWallet(address _wallet) public onlyOwner {\n', '        require(_wallet != 0x0);\n', '        hardwareWallet = _wallet;\n', '    }\n', '\n', '    function setRestrictedWallet(address _restrictedWallet) public onlyOwner {\n', '        require(_restrictedWallet != 0x0);\n', '        restrictedWallet = _restrictedWallet;\n', '    }\n', '\n', '    function setAdditionalTokensFromCommonPoolWallet(address _wallet) public onlyOwner {\n', '        require(_wallet != 0x0);\n', '        additionalTokensFromCommonPoolWallet = _wallet;\n', '    }\n', '\n', '    function setHardCapEther(uint256 newEtherAmt) public onlyOwner{\n', '        require(newEtherAmt > 0);\n', '        hardCapEther = newEtherAmt;\n', '        hardcap = hardCapEther * etherToWei;\n', '    }\n', '\n', '    constructor() public  {\n', '        require(startTimestamp >= now);\n', '        require(endTimestamp >= startTimestamp);\n', '    }\n', '\n', '    // check if valid purchase\n', '    modifier validPurchase {\n', '        require(now >= startTimestamp);\n', '        require(now < endTimestamp);\n', '        require(msg.value >= minContribution);\n', '        require(frozen == false);\n', '        _;\n', '    }\n', '\n', '    // @return true if crowdsale event has ended\n', '    function hasEnded() public constant returns (bool) {\n', '        if (now > endTimestamp)\n', '            return true;\n', '        return false;\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary) public payable validPurchase {\n', '        require(beneficiary != 0x0);\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // Check if the hardcap has been exceeded\n', '        uint256 weiRaisedSoFar = weiRaised.add(weiAmount);\n', '        require(weiRaisedSoFar + weiRaisedInPresale <= hardcap);\n', '\n', '        if (deposits[msg.sender] == 0) {\n', '            numberOfPurchasers++;\n', '        }\n', '        deposits[msg.sender] = weiAmount.add(deposits[msg.sender]);\n', '\n', '        uint256 daysInSale = (now - startTimestamp) / (1 days);\n', '        uint256 thisBonus = 0;\n', '        if(daysInSale < 29 ){\n', '            thisBonus = bonus[daysInSale];\n', '        }\n', '\n', '        // Calculate token amount to be created\n', '        uint256 tokens = weiAmount.mul(rate);\n', '        uint256 extraBonus = tokens.mul(thisBonus);\n', '        extraBonus = extraBonus.div(100);\n', '        tokens = tokens.add(extraBonus);\n', '\n', '        // Update the global token sale variables\n', '        uint256 finalTokenCount;\n', '        finalTokenCount = tokens.add(tokensSold);\n', '        weiRaised = weiRaisedSoFar;\n', '        tokensSold = finalTokenCount;\n', '\n', '        token.mint(beneficiary, tokens);\n', '        hardwareWallet.transfer(msg.value);\n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '    }\n', '\n', '    function grantTokensAdvisors(address beneficiary,uint256 dstTokenCount) public onlyOwner{\n', '        dstTokenCount = dstTokenCount * etherToWei;\n', '        advisorTokensGranted = advisorTokensGranted.add(dstTokenCount);\n', '        token.mint(beneficiary,dstTokenCount);\n', '    }\n', '\n', '    function grantTokensCommonPool(address beneficiary,uint256 dstTokenCount) public onlyOwner{\n', '        dstTokenCount = dstTokenCount * etherToWei;\n', '        commonPoolTokensGranted = commonPoolTokensGranted.add(dstTokenCount);\n', '        token.mint(beneficiary,dstTokenCount);\n', '    }\n', '\n', '    // finish mining coins and transfer ownership of Change coin to owner\n', '    function finishMinting() public onlyOwner returns(bool){\n', '        require(hasEnded());\n', '\n', '        uint issuedTokenSupply = token.totalSupply();\n', '        uint publicTokens = issuedTokenSupply-advisorTokensGranted;\n', '        if(publicTokens>60*advisorTokensGranted/40 ){\n', '          uint restrictedTokens=(publicTokens)*40/60-advisorTokensGranted;\n', '          token.mint(restrictedWallet, restrictedTokens);\n', '          advisorTokensGranted=advisorTokensGranted+restrictedTokens;\n', '        }\n', '        else if(publicTokens<60*advisorTokensGranted/40){\n', '          uint256 deltaCommonPool=advisorTokensGranted*60/40-publicTokens;\n', '          token.mint(additionalTokensFromCommonPoolWallet,deltaCommonPool);\n', '        }\n', '\n', '        token.finishMinting();\n', '        token.transferOwnership(owner);\n', '        emit MainSaleClosed();\n', '        return true;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function () payable public {\n', '        buyTokens(msg.sender);\n', '    }\n', '    function setRate(uint256 amount) onlyOwner public {\n', '        require(amount>=0);\n', '        rate = amount;\n', '    }\n', '    function setBonus(uint256 [] amounts) onlyOwner public {\n', '      require( amounts.length > 30 );\n', '        bonus = amounts;\n', '    }\n', '    function setWeiRaisedInPresale(uint256 amount) onlyOwner public {\n', '        require(amount>=0);\n', '        weiRaisedInPresale = amount;\n', '    }\n', '    function setEndTimeStamp(uint256 end) onlyOwner public {\n', '        require(end>now);\n', '        endTimestamp = end;\n', '    }\n', '    function setStartTimeStamp(uint256 start) onlyOwner public {\n', '        startTimestamp = start;\n', '    }\n', '    function pauseTrading() onlyOwner public{\n', '        token.pause();\n', '    }\n', '    function startTrading() onlyOwner public{\n', '        token.unpause();\n', '    }\n', '    function smartBlockAddress(address toBeBlocked) onlyOwner public{\n', '        token.blockAddress(toBeBlocked);\n', '    }\n', '    function smartUnBlockAddress(address toBeUnblocked) onlyOwner public{\n', '        token.unBlockAddress(toBeUnblocked);\n', '    }\n', '    function changeTokenOwner(address newOwner) public onlyOwner {\n', '        require(hasEnded());\n', '        token.changeOwner(newOwner);\n', '    }\n', '    function bulkGrantTokenAdvisors(address [] beneficiaries,uint256 [] granttokencounts) public onlyOwner{\n', '      require( beneficiaries.length == granttokencounts.length);\n', '      for (uint256 i=0; i<beneficiaries.length; i++) {\n', '        grantTokensAdvisors(beneficiaries[i],granttokencounts[i]);\n', '      }\n', '    }\n', '    function bulkGrantTokenCommonPool(address [] beneficiaries,uint256 [] granttokencounts) public onlyOwner{\n', '      require( beneficiaries.length == granttokencounts.length);\n', '      for (uint256 i=0; i<beneficiaries.length; i++) {\n', '        grantTokensCommonPool(beneficiaries[i],granttokencounts[i]);\n', '      }\n', '    }\n', '\n', '}']