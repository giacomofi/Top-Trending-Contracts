['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-10\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', 'contract MyToken {\n', '    /* Public variables of the token */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    constructor(uint256 _supply, string _name, string _symbol, uint8 _decimals) public {\n', '        /* if supply not given then generate 1 million of the smallest unit of the token */\n', '        if (_supply == 0) _supply = 1000000;\n', '\n', '        /* Unless you add other functions these variables will never change */\n', '        balanceOf[msg.sender] = _supply;\n', '        name = _name; \n', '        symbol = _symbol;\n', '\n', '        /* If you want a divisible token then add the amount of decimals the base unit has  */\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) public {\n', '        /* if the sender doenst have enough balance then stop */\n', '        if (balanceOf[msg.sender] < _value) {revert();}\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) {revert();}\n', '\n', '        /* Add and subtract new balances */\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '\n', '        /* Notifiy anyone listening that this transfer took place */\n', '        emit Transfer(msg.sender, _to, _value);\n', '    }\n', '}']