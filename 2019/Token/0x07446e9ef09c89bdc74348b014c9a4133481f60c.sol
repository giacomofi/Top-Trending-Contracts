['pragma solidity ^0.5.3;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Owned contract\n', '    // ----------------------------------------------------------------------------\n', '    contract Owned {\n', '        address public owner;\n', '        address public newOwner;\n', '\n', '        event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '        modifier onlyOwner {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '\n', '        function transferOwnership(address _newOwner) public onlyOwner {\n', '            newOwner = _newOwner;\n', '        }\n', '        function acceptOwnership() public {\n', '            require(msg.sender == newOwner);\n', '            emit OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '            newOwner = address(0);\n', '        }\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Safe maths\n', '    // ----------------------------------------------------------------------------\n', '    library SafeMath {\n', '        function add(uint a, uint b) internal pure returns (uint c) {\n', '            c = a + b;\n', '            require(c >= a);\n', '        }\n', '        function sub(uint a, uint b) internal pure returns (uint c) {\n', '            require(b <= a);\n', '            c = a - b;\n', '        }\n', '        function mul(uint a, uint b) internal pure returns (uint c) {\n', '            c = a * b;\n', '            require(a == 0 || c / a == b);\n', '        }\n', '        function div(uint a, uint b) internal pure returns (uint c) {\n', '            require(b > 0);\n', '            c = a / b;\n', '        }\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // ERC Token Standard #20 Interface\n', '    // ----------------------------------------------------------------------------\n', '    contract ERC20Interface {\n', '        function totalSupply() public view returns (uint);\n', '        function balanceOf(address tokenOwner) public view returns (uint balance);\n', '        function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '        function transfer(address to, uint tokens) public returns (bool success);\n', '        function approve(address spender, uint tokens) public returns (bool success);\n', '        function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '        event Transfer(address indexed from, address indexed to, uint tokens);\n', '        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // MPAY Token Contract\n', '    // ----------------------------------------------------------------------------\n', '    contract MPAY is ERC20Interface, Owned{\n', '        using SafeMath for uint;\n', '        \n', '        string public symbol;\n', '        string public name;\n', '        uint8 public decimals;\n', '        uint _totalSupply;\n', '        mapping(address => uint) balances;\n', '        mapping(address => mapping(address => uint)) allowed;\n', '        mapping(address => uint) unLockedCoins; // this will keep number of unLockedCoins per address\n', '        struct PC {\n', '        uint256 lockingPeriod;\n', '        uint256 coins;\n', '        bool added;\n', '        }\n', '        mapping(address => PC[]) record; // this will keep record of Locking periods and coins per address\n', '\n', '        // ------------------------------------------------------------------------\n', '        // Constructor\n', '        // ------------------------------------------------------------------------\n', '        constructor(address _owner) public{\n', '            symbol = "MPAY";\n', '            name = "MPAY";\n', '            decimals = 18;\n', '            owner = _owner;\n', '            _totalSupply = 4e8; //400,000,000\n', '            balances[owner] = totalSupply();\n', '            emit Transfer(address(0),owner,totalSupply());\n', '        }\n', '\n', '        function totalSupply() public view returns (uint){\n', '        return _totalSupply * 10**uint(decimals);\n', '        }\n', '\n', '        // ------------------------------------------------------------------------\n', '        // Get the token balance for account `tokenOwner`\n', '        // ------------------------------------------------------------------------\n', '        function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '            return balances[tokenOwner];\n', '        }\n', '\n', '        // ------------------------------------------------------------------------\n', "        // Transfer the balance from token owner's account to `to` account\n", "        // - Owner's account must have sufficient balance to transfer\n", '        // - 0 value transfers are allowed\n', '        // ------------------------------------------------------------------------\n', '        function transfer(address to, uint tokens) public returns (bool success) {\n', '            // will update unLockedCoins based on time\n', '            if(msg.sender != owner){\n', '                _updateUnLockedCoins(msg.sender, tokens);\n', '                unLockedCoins[msg.sender] = unLockedCoins[msg.sender].sub(tokens);\n', '                unLockedCoins[to] = unLockedCoins[to].add(tokens);\n', '            }\n', '            // prevent transfer to 0x0, use burn instead\n', '            require(to != address(0));\n', '            require(balances[msg.sender] >= tokens );\n', '            require(balances[to] + tokens >= balances[to]);\n', '            balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '            balances[to] = balances[to].add(tokens);\n', '            emit Transfer(msg.sender,to,tokens);\n', '            return true;\n', '        }\n', '        \n', '        // ------------------------------------------------------------------------\n', '        // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "        // from the token owner's account\n", '        // ------------------------------------------------------------------------\n', '        function approve(address spender, uint tokens) public returns (bool success){\n', '            allowed[msg.sender][spender] = tokens;\n', '            emit Approval(msg.sender,spender,tokens);\n', '            return true;\n', '        }\n', '\n', '        // ------------------------------------------------------------------------\n', '        // Transfer `tokens` from the `from` account to the `to` account\n', '        // \n', '        // The calling account must already have sufficient tokens approve(...)\n', '        // for spending from the `from` account and\n', '        // - From account must have sufficient balance to transfer\n', '        // - Spender must have sufficient allowance to transfer\n', '        // - 0 value transfers are allowed\n', '        // ------------------------------------------------------------------------\n', '        function transferFrom(address from, address to, uint tokens) public returns (bool success){\n', '            // will update unLockedCoins based on time\n', '            if(msg.sender != owner){\n', '                _updateUnLockedCoins(from, tokens);\n', '                unLockedCoins[from] = unLockedCoins[from].sub(tokens);\n', '                unLockedCoins[to] = unLockedCoins[to].add(tokens);\n', '            }\n', '            require(tokens <= allowed[from][msg.sender]); //check allowance\n', '            require(balances[from] >= tokens);\n', '            balances[from] = balances[from].sub(tokens);\n', '            balances[to] = balances[to].add(tokens);\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '            emit Transfer(from,to,tokens);\n', '            return true;\n', '        }\n', '        // ------------------------------------------------------------------------\n', '        // Returns the amount of tokens approved by the owner that can be\n', "        // transferred to the spender's account\n", '        // ------------------------------------------------------------------------\n', '        function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '            return allowed[tokenOwner][spender];\n', '        }\n', '        \n', '        // ------------------------------------------------------------------------\n', "        // Transfer the balance from token owner's account to `to` account\n", "        // - Owner's account must have sufficient balance to transfer\n", '        // - 0 value transfers are allowed\n', '        // - takes in locking Period to lock the tokens to be used\n', '        // - if want to transfer without locking enter 0 in lockingPeriod argument \n', '        // ------------------------------------------------------------------------\n', '        function distributeTokens(address to, uint tokens, uint256 lockingPeriod) onlyOwner public returns (bool success) {\n', '            // transfer tokens to the "to" address\n', '            transfer(to, tokens);\n', '            // if there is no lockingPeriod, add coins to unLockedCoins per address\n', '            if(lockingPeriod == 0)\n', '                unLockedCoins[to] = unLockedCoins[to].add(tokens);\n', '            // if there is a lockingPeriod, add coins to record mapping\n', '            else\n', '                _addRecord(to, tokens, lockingPeriod);\n', '            return true;\n', '        }\n', '        \n', '        // ------------------------------------------------------------------------\n', '        // Adds record of addresses with locking period and coins to lock\n', '        // ------------------------------------------------------------------------\n', '        function _addRecord(address to, uint tokens, uint256 lockingPeriod) private {\n', '                record[to].push(PC(lockingPeriod,tokens, false));\n', '        }\n', '        \n', '        // ------------------------------------------------------------------------\n', '        // Checks if there is any uunLockedCoins available\n', '        // ------------------------------------------------------------------------\n', '        function _updateUnLockedCoins(address _from, uint tokens) private returns (bool success) {\n', '            // if unLockedCoins are greater than "tokens" of "to", initiate transfer\n', '            if(unLockedCoins[_from] >= tokens){\n', '                return true;\n', '            }\n', '            // if unLockedCoins are less than "tokens" of "to", update unLockedCoins by checking record with "now" time\n', '            else{\n', '                _updateRecord(_from);\n', '                // check if unLockedCoins are greater than "token" of "to", initiate transfer\n', '                if(unLockedCoins[_from] >= tokens){\n', '                    return true;\n', '                }\n', '                // otherwise revert\n', '                else{\n', '                    revert();\n', '                }\n', '            }\n', '        }\n', '        \n', '        // ------------------------------------------------------------------------\n', '        // Unlock the coins if lockingPeriod is expired\n', '        // ------------------------------------------------------------------------\n', '        function _updateRecord(address _address) private returns (bool success){\n', '            PC[] memory tempArray = record[_address];\n', '            uint tempCount = 0;\n', '            for(uint i=0; i < tempArray.length; i++){\n', '                if(tempArray[i].lockingPeriod < now && tempArray[i].added == false){\n', '                    tempCount = tempCount.add(tempArray[i].coins);\n', '                    tempArray[i].added = true;\n', '                    record[_address][i] = PC(tempArray[i].lockingPeriod, tempArray[i].coins, tempArray[i].added);\n', '                }\n', '            }\n', '            unLockedCoins[_address] = unLockedCoins[_address].add(tempCount);\n', '            return true;\n', '        }\n', '        \n', '    }']