['pragma solidity ^0.5.0;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param owner The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified addresses\n', '    * @param from The address to transfer from.\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '        _burn(account, value);\n', '        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n', '    }\n', '}\n', '\n', '// File: contracts/assettoken/library/AssetTokenL.sol\n', '\n', '/*\n', '    Copyright 2018, CONDA\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/** @title AssetTokenL library. */\n', 'library AssetTokenL {\n', '    using SafeMath for uint256;\n', '\n', '///////////////////\n', '// Struct Parameters (passed as parameter to library)\n', '///////////////////\n', '\n', '    struct Supply {\n', '        // `balances` is the map that tracks the balance of each address, in this\n', '        // contract when the balance changes. TransfersAndMints-index when the change\n', '        // occurred is also included\n', '        mapping (address => Checkpoint[]) balances;\n', '\n', '        // Tracks the history of the `totalSupply` of the token\n', '        Checkpoint[] totalSupplyHistory;\n', '\n', '        // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n', '        mapping (address => mapping (address => uint256)) allowed;\n', '\n', '        // Minting cap max amount of tokens\n', '        uint256 cap;\n', '\n', '        // When successfully funded\n', '        uint256 goal;\n', '\n', '        //crowdsale start\n', '        uint256 startTime;\n', '\n', '        //crowdsale end\n', '        uint256 endTime;\n', '\n', '        //crowdsale dividends\n', '        Dividend[] dividends;\n', '\n', '        //counter per address how much was claimed in continuous way\n', '        //note: counter also increases when recycled and tried to claim in continous way\n', '        mapping (address => uint256) dividendsClaimed;\n', '\n', '        uint256 tokenActionIndex; //only modify within library\n', '    }\n', '\n', '    struct Availability {\n', '        // Flag that determines if the token is yet alive.\n', '        // Meta data cannot be changed anymore (except capitalControl)\n', '        bool tokenAlive;\n', '\n', '        // Flag that determines if the token is transferable or not.\n', '        bool transfersEnabled;\n', '\n', '        // Flag that minting is finished\n', '        bool mintingPhaseFinished;\n', '\n', '        // Flag that minting is paused\n', '        bool mintingPaused;\n', '    }\n', '\n', '    struct Roles {\n', '        // role that can pause/resume\n', '        address pauseControl;\n', '\n', '        // role that can rescue accidentally sent tokens\n', '        address tokenRescueControl;\n', '\n', '        // role that can mint during crowdsale (usually controller)\n', '        address mintControl;\n', '    }\n', '\n', '///////////////////\n', '// Structs (saved to blockchain)\n', '///////////////////\n', '\n', '    /// @dev `Dividend` is the structure that saves the status of a dividend distribution\n', '    struct Dividend {\n', '        uint256 currentTokenActionIndex;\n', '        uint256 timestamp;\n', '        DividendType dividendType;\n', '        address dividendToken;\n', '        uint256 amount;\n', '        uint256 claimedAmount;\n', '        uint256 totalSupply;\n', '        bool recycled;\n', '        mapping (address => bool) claimed;\n', '    }\n', '\n', '    /// @dev Dividends can be of those types.\n', '    enum DividendType { Ether, ERC20 }\n', '\n', '    /** @dev Checkpoint` is the structure that attaches a history index to a given value\n', "      * @notice That uint128 is used instead of uint/uint256. That's to save space. Should be big enough (feedback from audit)\n", '      */\n', '    struct Checkpoint {\n', '\n', "        // `currentTokenActionIndex` is the index when the value was generated. It's uint128 to save storage space\n", '        uint128 currentTokenActionIndex;\n', '\n', "        // `value` is the amount of tokens at a specific index. It's uint128 to save storage space\n", '        uint128 value;\n', '    }\n', '\n', '///////////////////\n', '// Functions\n', '///////////////////\n', '\n', '    /// @dev This is the actual transfer function in the token contract, it can\n', '    ///  only be called by other functions in this contract. Check for availability must be done before.\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function doTransfer(Supply storage _self, Availability storage /*_availability*/, address _from, address _to, uint256 _amount) public {\n', '        // Do not allow transfer to 0x0 or the token contract itself\n', '        require(_to != address(0), "addr0");\n', '        require(_to != address(this), "target self");\n', '\n', '        // If the amount being transfered is more than the balance of the\n', '        //  account the transfer throws\n', '        uint256 previousBalanceFrom = balanceOfNow(_self, _from);\n', '        require(previousBalanceFrom >= _amount, "not enough");\n', '\n', '        // First update the balance array with the new value for the address\n', '        //  sending the tokens\n', '        updateValueAtNow(_self, _self.balances[_from], previousBalanceFrom.sub(_amount));\n', '\n', '        // Then update the balance array with the new value for the address\n', '        //  receiving the tokens\n', '        uint256 previousBalanceTo = balanceOfNow(_self, _to);\n', '        \n', '        updateValueAtNow(_self, _self.balances[_to], previousBalanceTo.add(_amount));\n', '\n', "        //info: don't move this line inside updateValueAtNow (because transfer is 2 actions)\n", '        increaseTokenActionIndex(_self);\n', '\n', '        // An event to make the transfer easy to find on the blockchain\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    function increaseTokenActionIndex(Supply storage _self) private {\n', '        _self.tokenActionIndex = _self.tokenActionIndex.add(1);\n', '\n', '        emit TokenActionIndexIncreased(_self.tokenActionIndex, block.number);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` of his tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(Supply storage _self, address _spender, uint256 _amount) public returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender,0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (_self.allowed[msg.sender][_spender] == 0), "amount");\n', '\n', '        _self.allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Increase the amount of tokens that an owner allowed to a spender.\n', '    /// @dev approve should be called when allowed[_spender] == 0. To increment\n', '    ///  allowed value is better to use this function to avoid 2 calls (and wait until\n', '    ///  the first transaction is mined)\n', '    ///  From MonolithDAO Token.sol\n', '    /// @param _spender The address which will spend the funds.\n', '    /// @param _addedValue The amount of tokens to increase the allowance by.\n', '    /// @return True if the approval was successful\n', '    function increaseApproval(Supply storage _self, address _spender, uint256 _addedValue) public returns (bool) {\n', '        _self.allowed[msg.sender][_spender] = _self.allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, _self.allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Decrease the amount of tokens that an owner allowed to a spender.\n', '    /// @dev approve should be called when allowed[_spender] == 0. To decrement\n', '    ///  allowed value is better to use this function to avoid 2 calls (and wait until\n', '    ///  the first transaction is mined)\n', '    ///  From MonolithDAO Token.sol\n', '    /// @param _spender The address which will spend the funds.\n', '    /// @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    /// @return True if the approval was successful\n', '    function decreaseApproval(Supply storage _self, address _spender, uint256 _subtractedValue) public returns (bool) {\n', '        uint256 oldValue = _self.allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            _self.allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            _self.allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, _self.allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` if it is approved by `_from`\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(Supply storage _supply, Availability storage _availability, address _from, address _to, uint256 _amount) \n', '    public \n', '    returns (bool success) \n', '    {\n', '        // The standard ERC 20 transferFrom functionality\n', '        require(_supply.allowed[_from][msg.sender] >= _amount, "allowance");\n', '        _supply.allowed[_from][msg.sender] = _supply.allowed[_from][msg.sender].sub(_amount);\n', '\n', '        doTransfer(_supply, _availability, _from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` WITHOUT approval. UseCase: notar transfers from lost wallet\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @param _fullAmountRequired Full amount required (causes revert if not).\n', '    /// @return True if the transfer was successful\n', '    function enforcedTransferFrom(\n', '        Supply storage _self, \n', '        Availability storage _availability, \n', '        address _from, \n', '        address _to, \n', '        uint256 _amount, \n', '        bool _fullAmountRequired) \n', '    public \n', '    returns (bool success) \n', '    {\n', '        if(_fullAmountRequired && _amount != balanceOfNow(_self, _from))\n', '        {\n', '            revert("Only full amount in case of lost wallet is allowed");\n', '        }\n', '\n', '        doTransfer(_self, _availability, _from, _to, _amount);\n', '\n', '        emit SelfApprovedTransfer(msg.sender, _from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '////////////////\n', '// Miniting \n', '////////////////\n', '\n', '    /// @notice Function to mint tokens\n', '    /// @param _to The address that will receive the minted tokens.\n', '    /// @param _amount The amount of tokens to mint.\n', '    /// @return A boolean that indicates if the operation was successful.\n', '    function mint(Supply storage _self, address _to, uint256 _amount) public returns (bool) {\n', '        uint256 curTotalSupply = totalSupplyNow(_self);\n', '        uint256 previousBalanceTo = balanceOfNow(_self, _to);\n', '\n', '        // Check cap\n', '        require(curTotalSupply.add(_amount) <= _self.cap, "cap"); //leave inside library to never go over cap\n', '\n', '        // Check timeframe\n', '        require(_self.startTime <= now, "too soon");\n', '        require(_self.endTime >= now, "too late");\n', '\n', '        updateValueAtNow(_self, _self.totalSupplyHistory, curTotalSupply.add(_amount));\n', '        updateValueAtNow(_self, _self.balances[_to], previousBalanceTo.add(_amount));\n', '\n', "        //info: don't move this line inside updateValueAtNow (because transfer is 2 actions)\n", '        increaseTokenActionIndex(_self);\n', '\n', '        emit MintDetailed(msg.sender, _to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '    /// @dev Queries the balance of `_owner` at `_specificTransfersAndMintsIndex`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _specificTransfersAndMintsIndex The balance at index\n', '    /// @return The balance at `_specificTransfersAndMintsIndex`\n', '    function balanceOfAt(Supply storage _self, address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256) {\n', '        return getValueAt(_self.balances[_owner], _specificTransfersAndMintsIndex);\n', '    }\n', '\n', '    function balanceOfNow(Supply storage _self, address _owner) public view returns (uint256) {\n', '        return getValueAt(_self.balances[_owner], _self.tokenActionIndex);\n', '    }\n', '\n', '    /// @dev Total amount of tokens at `_specificTransfersAndMintsIndex`.\n', '    /// @param _specificTransfersAndMintsIndex The totalSupply at index\n', '    /// @return The total amount of tokens at `_specificTransfersAndMintsIndex`\n', '    function totalSupplyAt(Supply storage _self, uint256 _specificTransfersAndMintsIndex) public view returns(uint256) {\n', '        return getValueAt(_self.totalSupplyHistory, _specificTransfersAndMintsIndex);\n', '    }\n', '\n', '    function totalSupplyNow(Supply storage _self) public view returns(uint256) {\n', '        return getValueAt(_self.totalSupplyHistory, _self.tokenActionIndex);\n', '    }\n', '\n', '////////////////\n', '// Internal helper functions to query and set a value in a snapshot array\n', '////////////////\n', '\n', '    /// @dev `getValueAt` retrieves the number of tokens at a given index\n', '    /// @param checkpoints The history of values being queried\n', '    /// @param _specificTransfersAndMintsIndex The index to retrieve the history checkpoint value at\n', '    /// @return The number of tokens being queried\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint256 _specificTransfersAndMintsIndex) private view returns (uint256) { \n', '        \n', '        //  requested before a check point was ever created for this token\n', '        if (checkpoints.length == 0 || checkpoints[0].currentTokenActionIndex > _specificTransfersAndMintsIndex) {\n', '            return 0;\n', '        }\n', '\n', '        // Shortcut for the actual value\n', '        if (_specificTransfersAndMintsIndex >= checkpoints[checkpoints.length-1].currentTokenActionIndex) {\n', '            return checkpoints[checkpoints.length-1].value;\n', '        }\n', '\n', '        // Binary search of the value in the array\n', '        uint256 min = 0;\n', '        uint256 max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint256 mid = (max + min + 1)/2;\n', '            if (checkpoints[mid].currentTokenActionIndex<=_specificTransfersAndMintsIndex) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    /// @dev `updateValueAtNow` used to update the `balances` map and the `totalSupplyHistory`\n', '    /// @param checkpoints The history of data being updated\n', '    /// @param _value The new number of tokens\n', '    function updateValueAtNow(Supply storage _self, Checkpoint[] storage checkpoints, uint256 _value) private {\n', '        require(_value == uint128(_value), "invalid cast1");\n', '        require(_self.tokenActionIndex == uint128(_self.tokenActionIndex), "invalid cast2");\n', '\n', '        checkpoints.push(Checkpoint(\n', '            uint128(_self.tokenActionIndex),\n', '            uint128(_value)\n', '        ));\n', '    }\n', '\n', '    /// @dev Function to stop minting new tokens.\n', '    /// @return True if the operation was successful.\n', '    function finishMinting(Availability storage _self) public returns (bool) {\n', '        if(_self.mintingPhaseFinished) {\n', '            return false;\n', '        }\n', '\n', '        _self.mintingPhaseFinished = true;\n', '        emit MintFinished(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Reopening crowdsale means minting is again possible. UseCase: notary approves and does that.\n', '    /// @return True if the operation was successful.\n', '    function reopenCrowdsale(Availability storage _self) public returns (bool) {\n', '        if(_self.mintingPhaseFinished == false) {\n', '            return false;\n', '        }\n', '\n', '        _self.mintingPhaseFinished = false;\n', '        emit Reopened(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Set roles/operators.\n', '    /// @param _pauseControl pause control.\n', '    /// @param _tokenRescueControl token rescue control (accidentally assigned tokens).\n', '    function setRoles(Roles storage _self, address _pauseControl, address _tokenRescueControl) public {\n', '        require(_pauseControl != address(0), "addr0");\n', '        require(_tokenRescueControl != address(0), "addr0");\n', '        \n', '        _self.pauseControl = _pauseControl;\n', '        _self.tokenRescueControl = _tokenRescueControl;\n', '\n', '        emit RolesChanged(msg.sender, _pauseControl, _tokenRescueControl);\n', '    }\n', '\n', '    /// @notice Set mint control.\n', '    function setMintControl(Roles storage _self, address _mintControl) public {\n', '        require(_mintControl != address(0), "addr0");\n', '\n', '        _self.mintControl = _mintControl;\n', '\n', '        emit MintControlChanged(msg.sender, _mintControl);\n', '    }\n', '\n', '    /// @notice Set token alive which can be seen as not in draft state anymore.\n', '    function setTokenAlive(Availability storage _self) public {\n', '        _self.tokenAlive = true;\n', '    }\n', '\n', '////////////////\n', '// Pausing token for unforeseen reasons\n', '////////////////\n', '\n', '    /// @notice pause transfer.\n', '    /// @param _transfersEnabled True if transfers are allowed.\n', '    function pauseTransfer(Availability storage _self, bool _transfersEnabled) public\n', '    {\n', '        _self.transfersEnabled = _transfersEnabled;\n', '\n', '        if(_transfersEnabled) {\n', '            emit TransferResumed(msg.sender);\n', '        } else {\n', '            emit TransferPaused(msg.sender);\n', '        }\n', '    }\n', '\n', '    /// @notice calling this can enable/disable capital increase/decrease flag\n', '    /// @param _mintingEnabled True if minting is allowed\n', '    function pauseCapitalIncreaseOrDecrease(Availability storage _self, bool _mintingEnabled) public\n', '    {\n', '        _self.mintingPaused = (_mintingEnabled == false);\n', '\n', '        if(_mintingEnabled) {\n', '            emit MintingResumed(msg.sender);\n', '        } else {\n', '            emit MintingPaused(msg.sender);\n', '        }\n', '    }\n', '\n', '    /// @notice Receives ether to be distriubted to all token owners\n', '    function depositDividend(Supply storage _self, uint256 msgValue)\n', '    public \n', '    {\n', '        require(msgValue > 0, "amount0");\n', '\n', '        // gets the current number of total token distributed\n', '        uint256 currentSupply = totalSupplyNow(_self);\n', '\n', '        // a deposit without investment would end up in unclaimable deposit for token holders\n', '        require(currentSupply > 0, "0investors");\n', '\n', '        // creates a new index for the dividends\n', '        uint256 dividendIndex = _self.dividends.length;\n', '\n', '        // Stores the current meta data for the dividend payout\n', '        _self.dividends.push(\n', '            Dividend(\n', '                _self.tokenActionIndex, // current index used for claiming\n', '                block.timestamp, // Timestamp of the distribution\n', '                DividendType.Ether, // Type of dividends\n', '                address(0),\n', '                msgValue, // Total amount that has been distributed\n', '                0, // amount that has been claimed\n', '                currentSupply, // Total supply now\n', '                false // Already recylced\n', '            )\n', '        );\n', '        emit DividendDeposited(msg.sender, _self.tokenActionIndex, msgValue, currentSupply, dividendIndex);\n', '    }\n', '\n', '    /// @notice Receives ERC20 to be distriubted to all token owners\n', '    function depositERC20Dividend(Supply storage _self, address _dividendToken, uint256 _amount, address baseCurrency)\n', '    public\n', '    {\n', '        require(_amount > 0, "amount0");\n', '        require(_dividendToken == baseCurrency, "not baseCurrency");\n', '\n', '        // gets the current number of total token distributed\n', '        uint256 currentSupply = totalSupplyNow(_self);\n', '\n', '        // a deposit without investment would end up in unclaimable deposit for token holders\n', '        require(currentSupply > 0, "0investors");\n', '\n', '        // creates a new index for the dividends\n', '        uint256 dividendIndex = _self.dividends.length;\n', '\n', '        // Stores the current meta data for the dividend payout\n', '        _self.dividends.push(\n', '            Dividend(\n', '                _self.tokenActionIndex, // index that counts up on transfers and mints\n', '                block.timestamp, // Timestamp of the distribution\n', '                DividendType.ERC20, \n', '                _dividendToken, \n', '                _amount, // Total amount that has been distributed\n', '                0, // amount that has been claimed\n', '                currentSupply, // Total supply now\n', '                false // Already recylced\n', '            )\n', '        );\n', '\n', "        // it shouldn't return anything but according to ERC20 standard it could if badly implemented\n", '        // IMPORTANT: potentially a call with reentrance -> do at the end\n', '        require(ERC20(_dividendToken).transferFrom(msg.sender, address(this), _amount), "transferFrom");\n', '\n', '        emit DividendDeposited(msg.sender, _self.tokenActionIndex, _amount, currentSupply, dividendIndex);\n', '    }\n', '\n', '    /// @notice Function to claim dividends for msg.sender\n', '    /// @dev dividendsClaimed should not be handled here.\n', '    function claimDividend(Supply storage _self, uint256 _dividendIndex) public {\n', '        // Loads the details for the specific Dividend payment\n', '        Dividend storage dividend = _self.dividends[_dividendIndex];\n', '\n', '        // Devidends should not have been claimed already\n', '        require(dividend.claimed[msg.sender] == false, "claimed");\n', '\n', '         // Devidends should not have been recycled already\n', '        require(dividend.recycled == false, "recycled");\n', '\n', '        // get the token balance at the time of the dividend distribution\n', '        uint256 balance = balanceOfAt(_self, msg.sender, dividend.currentTokenActionIndex.sub(1));\n', '\n', '        // calculates the amount of dividends that can be claimed\n', '        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\n', '\n', '        // flag that dividends have been claimed\n', '        dividend.claimed[msg.sender] = true;\n', '        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\n', '\n', '        claimThis(dividend.dividendType, _dividendIndex, msg.sender, claim, dividend.dividendToken);\n', '    }\n', '\n', '    /// @notice Claim all dividends.\n', '    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\n', '    function claimDividendAll(Supply storage _self) public {\n', '        claimLoopInternal(_self, _self.dividendsClaimed[msg.sender], (_self.dividends.length-1));\n', '    }\n', '\n', '    /// @notice Claim dividends in batches. In case claimDividendAll runs out of gas.\n', '    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\n', '    /// @param _startIndex start index (inclusive number).\n', '    /// @param _endIndex end index (inclusive number).\n', '    function claimInBatches(Supply storage _self, uint256 _startIndex, uint256 _endIndex) public {\n', '        claimLoopInternal(_self, _startIndex, _endIndex);\n', '    }\n', '\n', '    /// @notice Claim loop of batch claim and claim all.\n', '    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\n', '    /// @param _startIndex start index (inclusive number).\n', '    /// @param _endIndex end index (inclusive number).\n', '    function claimLoopInternal(Supply storage _self, uint256 _startIndex, uint256 _endIndex) private {\n', '        require(_startIndex <= _endIndex, "start after end");\n', '\n', '        //early exit if already claimed\n', '        require(_self.dividendsClaimed[msg.sender] < _self.dividends.length, "all claimed");\n', '\n', '        uint256 dividendsClaimedTemp = _self.dividendsClaimed[msg.sender];\n', '\n', '        // Cycle through all dividend distributions and make the payout\n', '        for (uint256 i = _startIndex; i <= _endIndex; i++) {\n', '            if (_self.dividends[i].recycled == true) {\n', '                //recycled and tried to claim in continuous way internally counts as claimed\n', '                dividendsClaimedTemp = SafeMath.add(i, 1);\n', '            }\n', '            else if (_self.dividends[i].claimed[msg.sender] == false) {\n', '                dividendsClaimedTemp = SafeMath.add(i, 1);\n', '                claimDividend(_self, i);\n', '            }\n', '        }\n', '\n', '        // This is done after the loop to reduce writes.\n', '        // Remembers what has been claimed after hole-free claiming procedure.\n', '        // IMPORTANT: do only if batch claim docks on previous claim to avoid unexpected claim all behaviour.\n', '        if(_startIndex <= _self.dividendsClaimed[msg.sender]) {\n', '            _self.dividendsClaimed[msg.sender] = dividendsClaimedTemp;\n', '        }\n', '    }\n', '\n', '    /// @notice Dividends which have not been claimed can be claimed by owner after timelock (to avoid loss)\n', '    /// @param _dividendIndex index of dividend to recycle.\n', '    /// @param _recycleLockedTimespan timespan required until possible.\n', '    /// @param _currentSupply current supply.\n', '    function recycleDividend(Supply storage _self, uint256 _dividendIndex, uint256 _recycleLockedTimespan, uint256 _currentSupply) public {\n', '        // Get the dividend distribution\n', '        Dividend storage dividend = _self.dividends[_dividendIndex];\n', '\n', '        // should not have been recycled already\n', '        require(dividend.recycled == false, "recycled");\n', '\n', '        // The recycle time has to be over\n', '        require(dividend.timestamp < SafeMath.sub(block.timestamp, _recycleLockedTimespan), "timeUp");\n', '\n', '        // Devidends should not have been claimed already\n', '        require(dividend.claimed[msg.sender] == false, "claimed");\n', '\n', '        //\n', '        //refund\n', '        //\n', '\n', '        // The amount, which has not been claimed is distributed to token owner\n', '        _self.dividends[_dividendIndex].recycled = true;\n', '\n', '        // calculates the amount of dividends that can be claimed\n', '        uint256 claim = SafeMath.sub(dividend.amount, dividend.claimedAmount);\n', '\n', '        // flag that dividends have been claimed\n', '        dividend.claimed[msg.sender] = true;\n', '        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\n', '\n', '        claimThis(dividend.dividendType, _dividendIndex, msg.sender, claim, dividend.dividendToken);\n', '\n', '        emit DividendRecycled(msg.sender, _self.tokenActionIndex, claim, _currentSupply, _dividendIndex);\n', '    }\n', '\n', '    /// @dev the core claim function of single dividend.\n', '    function claimThis(DividendType _dividendType, uint256 _dividendIndex, address payable _beneficiary, uint256 _claim, address _dividendToken) \n', '    private \n', '    {\n', '        // transfer the dividends to the token holder\n', '        if (_claim > 0) {\n', '            if (_dividendType == DividendType.Ether) { \n', '                _beneficiary.transfer(_claim);\n', '            } \n', '            else if (_dividendType == DividendType.ERC20) { \n', '                require(ERC20(_dividendToken).transfer(_beneficiary, _claim), "transfer");\n', '            }\n', '            else {\n', '                revert("unknown type");\n', '            }\n', '\n', '            emit DividendClaimed(_beneficiary, _dividendIndex, _claim);\n', '        }\n', '    }\n', '\n', '    /// @notice If this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\n', '    /// @param _foreignTokenAddress token where contract has balance.\n', '    /// @param _to the beneficiary.\n', '    function rescueToken(Availability storage _self, address _foreignTokenAddress, address _to) public\n', '    {\n', '        require(_self.mintingPhaseFinished, "unfinished");\n', '        ERC20(_foreignTokenAddress).transfer(_to, ERC20(_foreignTokenAddress).balanceOf(address(this)));\n', '    }\n', '\n', '///////////////////\n', '// Events (must be redundant in calling contract to work!)\n', '///////////////////\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event SelfApprovedTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value);\n', '    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\n', '    event MintFinished(address indexed initiator);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event TransferPaused(address indexed initiator);\n', '    event TransferResumed(address indexed initiator);\n', '    event MintingPaused(address indexed initiator);\n', '    event MintingResumed(address indexed initiator);\n', '    event Reopened(address indexed initiator);\n', '    event DividendDeposited(address indexed depositor, uint256 transferAndMintIndex, uint256 amount, uint256 totalSupply, uint256 dividendIndex);\n', '    event DividendClaimed(address indexed claimer, uint256 dividendIndex, uint256 claim);\n', '    event DividendRecycled(address indexed recycler, uint256 transferAndMintIndex, uint256 amount, uint256 totalSupply, uint256 dividendIndex);\n', '    event RolesChanged(address indexed initiator, address pauseControl, address tokenRescueControl);\n', '    event MintControlChanged(address indexed initiator, address mintControl);\n', '    event TokenActionIndexIncreased(uint256 tokenActionIndex, uint256 blocknumber);\n', '}\n', '\n', '// File: contracts/assettoken/abstract/IBasicAssetTokenFull.sol\n', '\n', 'contract IBasicAssetTokenFull {\n', '    function checkCanSetMetadata() internal returns (bool);\n', '\n', '    function getCap() public view returns (uint256);\n', '    function getGoal() public view returns (uint256);\n', '    function getStart() public view returns (uint256);\n', '    function getEnd() public view returns (uint256);\n', '    function getLimits() public view returns (uint256, uint256, uint256, uint256);\n', '    function setMetaData(\n', '        string calldata _name, \n', '        string calldata _symbol, \n', '        address _tokenBaseCurrency, \n', '        uint256 _cap, \n', '        uint256 _goal, \n', '        uint256 _startTime, \n', '        uint256 _endTime) \n', '        external;\n', '    \n', '    function getTokenRescueControl() public view returns (address);\n', '    function getPauseControl() public view returns (address);\n', '    function isTransfersPaused() public view returns (bool);\n', '\n', '    function setMintControl(address _mintControl) public;\n', '    function setRoles(address _pauseControl, address _tokenRescueControl) public;\n', '\n', '    function setTokenAlive() public;\n', '    function isTokenAlive() public view returns (bool);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    function approve(address _spender, uint256 _amount) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool);\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool);\n', '\n', '    function finishMinting() public returns (bool);\n', '\n', '    function rescueToken(address _foreignTokenAddress, address _to) public;\n', '\n', '    function balanceOfAt(address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256);\n', '\n', '    function totalSupplyAt(uint256 _specificTransfersAndMintsIndex) public view returns(uint256);\n', '\n', '    function enableTransfers(bool _transfersEnabled) public;\n', '\n', '    function pauseTransfer(bool _transfersEnabled) public;\n', '\n', '    function pauseCapitalIncreaseOrDecrease(bool _mintingEnabled) public;    \n', '\n', '    function isMintingPaused() public view returns (bool);\n', '\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '\n', '    function transfer(address _to, uint256 _amount) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n', '\n', '    function enableTransferInternal(bool _transfersEnabled) internal;\n', '\n', '    function reopenCrowdsaleInternal() internal returns (bool);\n', '\n', '    function transferFromInternal(address _from, address _to, uint256 _amount) internal returns (bool success);\n', '    function enforcedTransferFromInternal(address _from, address _to, uint256 _value, bool _fullAmountRequired) internal returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\n', '    event MintFinished(address indexed initiator);\n', '    event TransferPaused(address indexed initiator);\n', '    event TransferResumed(address indexed initiator);\n', '    event Reopened(address indexed initiator);\n', '    event MetaDataChanged(address indexed initiator, string name, string symbol, address baseCurrency, uint256 cap, uint256 goal, uint256 startTime, uint256 endTime);\n', '    event RolesChanged(address indexed initiator, address _pauseControl, address _tokenRescueControl);\n', '    event MintControlChanged(address indexed initiator, address mintControl);\n', '}\n', '\n', '// File: contracts/assettoken/BasicAssetToken.sol\n', '\n', '/*\n', '    Copyright 2018, CONDA\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '/** @title Basic AssetToken. This contract includes the basic AssetToken features */\n', 'contract BasicAssetToken is IBasicAssetTokenFull, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    using AssetTokenL for AssetTokenL.Supply;\n', '    using AssetTokenL for AssetTokenL.Availability;\n', '    using AssetTokenL for AssetTokenL.Roles;\n', '\n', '///////////////////\n', '// Variables\n', '///////////////////\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', "    // The token's name\n", '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    // Fixed number of 0 decimals like real world equity\n', '    function decimals() public pure returns (uint8) {\n', '        return 0;\n', '    }\n', '\n', '    // An identifier\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    // 1000 is version 1\n', '    uint16 public constant version = 2000;\n', '\n', '    // Defines the baseCurrency of the token\n', '    address public baseCurrency;\n', '\n', '    // Supply: balance, checkpoints etc.\n', '    AssetTokenL.Supply supply;\n', '\n', "    // Availability: what's paused\n", '    AssetTokenL.Availability availability;\n', '\n', '    // Roles: who is entitled\n', '    AssetTokenL.Roles roles;\n', '\n', '///////////////////\n', '// Simple state getters\n', '///////////////////\n', '\n', '    function isMintingPaused() public view returns (bool) {\n', '        return availability.mintingPaused;\n', '    }\n', '\n', '    function isMintingPhaseFinished() public view returns (bool) {\n', '        return availability.mintingPhaseFinished;\n', '    }\n', '\n', '    function getPauseControl() public view returns (address) {\n', '        return roles.pauseControl;\n', '    }\n', '\n', '    function getTokenRescueControl() public view returns (address) {\n', '        return roles.tokenRescueControl;\n', '    }\n', '\n', '    function getMintControl() public view returns (address) {\n', '        return roles.mintControl;\n', '    }\n', '\n', '    function isTransfersPaused() public view returns (bool) {\n', '        return !availability.transfersEnabled;\n', '    }\n', '\n', '    function isTokenAlive() public view returns (bool) {\n', '        return availability.tokenAlive;\n', '    }\n', '\n', '    function getCap() public view returns (uint256) {\n', '        return supply.cap;\n', '    }\n', '\n', '    function getGoal() public view returns (uint256) {\n', '        return supply.goal;\n', '    }\n', '\n', '    function getStart() public view returns (uint256) {\n', '        return supply.startTime;\n', '    }\n', '\n', '    function getEnd() public view returns (uint256) {\n', '        return supply.endTime;\n', '    }\n', '\n', '    function getLimits() public view returns (uint256, uint256, uint256, uint256) {\n', '        return (supply.cap, supply.goal, supply.startTime, supply.endTime);\n', '    }\n', '\n', '    function getCurrentHistoryIndex() public view returns (uint256) {\n', '        return supply.tokenActionIndex;\n', '    }\n', '\n', '///////////////////\n', '// Events\n', '///////////////////\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\n', '    event MintFinished(address indexed initiator);\n', '    event TransferPaused(address indexed initiator);\n', '    event TransferResumed(address indexed initiator);\n', '    event MintingPaused(address indexed initiator);\n', '    event MintingResumed(address indexed initiator);\n', '    event Reopened(address indexed initiator);\n', '    event MetaDataChanged(address indexed initiator, string name, string symbol, address baseCurrency, uint256 cap, uint256 goal, uint256 startTime, uint256 endTime);\n', '    event RolesChanged(address indexed initiator, address pauseControl, address tokenRescueControl);\n', '    event MintControlChanged(address indexed initiator, address mintControl);\n', '    event TokenActionIndexIncreased(uint256 tokenActionIndex, uint256 blocknumber);\n', '\n', '///////////////////\n', '// Modifiers\n', '///////////////////\n', '    modifier onlyPauseControl() {\n', '        require(msg.sender == roles.pauseControl, "pauseCtrl");\n', '        _;\n', '    }\n', '\n', '    //can be overwritten in inherited contracts...\n', '    function _canDoAnytime() internal view returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    modifier onlyOwnerOrOverruled() {\n', '        if(_canDoAnytime() == false) { \n', '            require(isOwner(), "only owner");\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier canMint() {\n', '        if(_canDoAnytime() == false) { \n', '            require(canMintLogic(), "canMint");\n', '        }\n', '        _;\n', '    }\n', '\n', '    function canMintLogic() private view returns (bool) {\n', '        return msg.sender == roles.mintControl && availability.tokenAlive && !availability.mintingPhaseFinished && !availability.mintingPaused;\n', '    }\n', '\n', '    //can be overwritten in inherited contracts...\n', '    function checkCanSetMetadata() internal returns (bool) {\n', '        if(_canDoAnytime() == false) {\n', '            require(isOwner(), "owner only");\n', '            require(!availability.tokenAlive, "alive");\n', '            require(!availability.mintingPhaseFinished, "finished");\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    modifier canSetMetadata() {\n', '        checkCanSetMetadata();\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenAlive() {\n', '        require(availability.tokenAlive, "not alive");\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenRescueControl() {\n', '        require(msg.sender == roles.tokenRescueControl, "rescueCtrl");\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer() {\n', '        require(availability.transfersEnabled, "paused");\n', '        _;\n', '    }\n', '\n', '///////////////////\n', '// Set / Get Metadata\n', '///////////////////\n', '\n', "    /// @notice Change the token's metadata.\n", '    /// @dev Time is via block.timestamp (check crowdsale contract)\n', '    /// @param _nameParam The name of the token.\n', '    /// @param _symbolParam The symbol of the token.\n', '    /// @param _tokenBaseCurrency The base currency.\n', '    /// @param _cap The max amount of tokens that can be minted.\n', '    /// @param _goal The goal of tokens that should be sold.\n', '    /// @param _startTime Time when crowdsale should start.\n', '    /// @param _endTime Time when crowdsale should end.\n', '    function setMetaData(\n', '        string calldata _nameParam, \n', '        string calldata _symbolParam, \n', '        address _tokenBaseCurrency, \n', '        uint256 _cap, \n', '        uint256 _goal, \n', '        uint256 _startTime, \n', '        uint256 _endTime) \n', '        external \n', '    canSetMetadata \n', '    {\n', '        require(_cap >= _goal, "cap higher goal");\n', '\n', '        _name = _nameParam;\n', '        _symbol = _symbolParam;\n', '\n', '        baseCurrency = _tokenBaseCurrency;\n', '        supply.cap = _cap;\n', '        supply.goal = _goal;\n', '        supply.startTime = _startTime;\n', '        supply.endTime = _endTime;\n', '\n', '        emit MetaDataChanged(msg.sender, _nameParam, _symbolParam, _tokenBaseCurrency, _cap, _goal, _startTime, _endTime);\n', '    }\n', '\n', "    /// @notice Set mint control role. Usually this is CONDA's controller.\n", '    /// @param _mintControl Contract address or wallet that should be allowed to mint.\n', '    function setMintControl(address _mintControl) public canSetMetadata {\n', '        roles.setMintControl(_mintControl);\n', '    }\n', '\n', '    /// @notice Set roles.\n', '    /// @param _pauseControl address that is allowed to pause.\n', '    /// @param _tokenRescueControl address that is allowed rescue tokens.\n', '    function setRoles(address _pauseControl, address _tokenRescueControl) public \n', '    canSetMetadata\n', '    {\n', '        roles.setRoles(_pauseControl, _tokenRescueControl);\n', '    }\n', '\n', '    function setTokenAlive() public \n', '    onlyOwnerOrOverruled\n', '    {\n', '        availability.setTokenAlive();\n', '    }\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _amount) public canTransfer returns (bool success) {\n', '        supply.doTransfer(availability, msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition (requires allowance/approval)\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        return transferFromInternal(_from, _to, _amount);\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition (requires allowance/approval)\n', '    /// @dev modifiers in this internal method because also used by features.\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFromInternal(address _from, address _to, uint256 _amount) internal canTransfer returns (bool success) {\n', '        return supply.transferFrom(availability, _from, _to, _amount);\n', '    }\n', '\n', '    /// @notice balance of `_owner` for this token\n', "    /// @param _owner The address that's balance is being requested\n", '    /// @return The balance of `_owner` now (at the current index)\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return supply.balanceOfNow(_owner);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` of his tokens\n', '    /// @dev This is a modified version of the ERC20 approve function to be a bit safer\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        return supply.approve(_spender, _amount);\n', '    }\n', '\n', '    /// @notice This method can check how much is approved by `_owner` for `_spender`\n', '    /// @dev This function makes it easy to read the `allowed[]` map\n', '    /// @param _owner The address of the account that owns the token\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return supply.allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @notice This function makes it easy to get the total number of tokens\n', '    /// @return The total number of tokens now (at current index)\n', '    function totalSupply() public view returns (uint256) {\n', '        return supply.totalSupplyNow();\n', '    }\n', '\n', '\n', '    /// @notice Increase the amount of tokens that an owner allowed to a spender.\n', '    /// @dev approve should be called when allowed[_spender] == 0. To increment\n', '    /// allowed value is better to use this function to avoid 2 calls (and wait until\n', '    /// the first transaction is mined)\n', '    /// From MonolithDAO Token.sol\n', '    /// @param _spender The address which will spend the funds.\n', '    /// @param _addedValue The amount of tokens to increase the allowance by.\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n', '        return supply.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    /// @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    /// approve should be called when allowed[_spender] == 0. To decrement\n', '    /// allowed value is better to use this function to avoid 2 calls (and wait until\n', '    /// the first transaction is mined)\n', '    /// From MonolithDAO Token.sol\n', '    /// @param _spender The address which will spend the funds.\n', '    /// @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n', '        return supply.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '\n', '////////////////\n', '// Miniting \n', '////////////////\n', '\n', '    /// @dev Can rescue tokens accidentally assigned to this contract\n', '    /// @param _to The beneficiary who receives increased balance.\n', '    /// @param _amount The amount of balance increase.\n', '    function mint(address _to, uint256 _amount) public canMint returns (bool) {\n', '        return supply.mint(_to, _amount);\n', '    }\n', '\n', '    /// @notice Function to stop minting new tokens\n', '    /// @return True if the operation was successful.\n', '    function finishMinting() public onlyOwnerOrOverruled returns (bool) {\n', '        return availability.finishMinting();\n', '    }\n', '\n', '////////////////\n', '// Rescue Tokens \n', '////////////////\n', '\n', '    /// @dev Can rescue tokens accidentally assigned to this contract\n', '    /// @param _foreignTokenAddress The address from which the balance will be retrieved\n', '    /// @param _to beneficiary\n', '    function rescueToken(address _foreignTokenAddress, address _to)\n', '    public\n', '    onlyTokenRescueControl\n', '    {\n', '        availability.rescueToken(_foreignTokenAddress, _to);\n', '    }\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', "    /// @notice Someone's token balance of this token\n", '    /// @dev Queries the balance of `_owner` at `_specificTransfersAndMintsIndex`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _specificTransfersAndMintsIndex The balance at index\n', '    /// @return The balance at `_specificTransfersAndMintsIndex`\n', '    function balanceOfAt(address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256) {\n', '        return supply.balanceOfAt(_owner, _specificTransfersAndMintsIndex);\n', '    }\n', '\n', '    /// @notice Total amount of tokens at `_specificTransfersAndMintsIndex`.\n', '    /// @param _specificTransfersAndMintsIndex The totalSupply at index\n', '    /// @return The total amount of tokens at `_specificTransfersAndMintsIndex`\n', '    function totalSupplyAt(uint256 _specificTransfersAndMintsIndex) public view returns(uint256) {\n', '        return supply.totalSupplyAt(_specificTransfersAndMintsIndex);\n', '    }\n', '\n', '////////////////\n', '// Enable tokens transfers\n', '////////////////\n', '\n', '    /// @dev this function is not public and can be overwritten\n', '    function enableTransferInternal(bool _transfersEnabled) internal {\n', '        availability.pauseTransfer(_transfersEnabled);\n', '    }\n', '\n', '    /// @notice Enables token holders to transfer their tokens freely if true\n', '    /// @param _transfersEnabled True if transfers are allowed\n', '    function enableTransfers(bool _transfersEnabled) public \n', '    onlyOwnerOrOverruled \n', '    {\n', '        enableTransferInternal(_transfersEnabled);\n', '    }\n', '\n', '////////////////\n', '// Pausing token for unforeseen reasons\n', '////////////////\n', '\n', '    /// @dev `pauseTransfer` is an alias for `enableTransfers` using the pauseControl modifier\n', '    /// @param _transfersEnabled False if transfers are allowed\n', '    function pauseTransfer(bool _transfersEnabled) public\n', '    onlyPauseControl\n', '    {\n', '        enableTransferInternal(_transfersEnabled);\n', '    }\n', '\n', '    /// @dev `pauseCapitalIncreaseOrDecrease` can pause mint\n', '    /// @param _mintingEnabled False if minting is allowed\n', '    function pauseCapitalIncreaseOrDecrease(bool _mintingEnabled) public\n', '    onlyPauseControl\n', '    {\n', '        availability.pauseCapitalIncreaseOrDecrease(_mintingEnabled);\n', '    }\n', '\n', '    /// @dev capitalControl (if exists) can reopen the crowdsale.\n', '    /// this function is not public and can be overwritten\n', '    function reopenCrowdsaleInternal() internal returns (bool) {\n', '        return availability.reopenCrowdsale();\n', '    }\n', '\n', '    /// @dev capitalControl (if exists) can enforce a transferFrom e.g. in case of lost wallet.\n', '    /// this function is not public and can be overwritten\n', '    function enforcedTransferFromInternal(address _from, address _to, uint256 _value, bool _fullAmountRequired) internal returns (bool) {\n', '        return supply.enforcedTransferFrom(availability, _from, _to, _value, _fullAmountRequired);\n', '    }\n', '}\n', '\n', '// File: contracts/assettoken/interfaces/ICRWDControllerTransfer.sol\n', '\n', 'interface ICRWDControllerTransfer {\n', '    function transferParticipantsVerification(address _underlyingCurrency, address _from, address _to, uint256 _amount) external returns (bool);\n', '}\n', '\n', '// File: contracts/assettoken/interfaces/IGlobalIndexControllerLocation.sol\n', '\n', 'interface IGlobalIndexControllerLocation {\n', '    function getControllerAddress() external view returns (address);\n', '}\n', '\n', '// File: contracts/assettoken/abstract/ICRWDAssetToken.sol\n', '\n', 'contract ICRWDAssetToken is IBasicAssetTokenFull {\n', '    function setGlobalIndexAddress(address _globalIndexAddress) public;\n', '}\n', '\n', '// File: contracts/assettoken/CRWDAssetToken.sol\n', '\n', '/*\n', '    Copyright 2018, CONDA\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '/** @title CRWD AssetToken. This contract inherits basic functionality and extends calls to controller. */\n', 'contract CRWDAssetToken is BasicAssetToken, ICRWDAssetToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    IGlobalIndexControllerLocation public globalIndex;\n', '\n', '    function getControllerAddress() public view returns (address) {\n', '        return globalIndex.getControllerAddress();\n', '    }\n', '\n', '    /** @dev ERC20 transfer function overlay to transfer tokens and call controller.\n', '      * @param _to The recipient address.\n', '      * @param _amount The amount.\n', '      * @return A boolean that indicates if the operation was successful.\n', '      */\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '        ICRWDControllerTransfer(getControllerAddress()).transferParticipantsVerification(baseCurrency, msg.sender, _to, _amount);\n', '        return super.transfer(_to, _amount);\n', '    }\n', '\n', '    /** @dev ERC20 transferFrom function overlay to transfer tokens and call controller.\n', '      * @param _from The sender address (requires approval).\n', '      * @param _to The recipient address.\n', '      * @param _amount The amount.\n', '      * @return A boolean that indicates if the operation was successful.\n', '      */\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        ICRWDControllerTransfer(getControllerAddress()).transferParticipantsVerification(baseCurrency, _from, _to, _amount);\n', '        return super.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    /** @dev Mint function overlay to mint/create tokens.\n', '      * @param _to The address that will receive the minted tokens.\n', '      * @param _amount The amount of tokens to mint.\n', '      * @return A boolean that indicates if the operation was successful.\n', '      */\n', '    function mint(address _to, uint256 _amount) public canMint returns (bool) {\n', '        return super.mint(_to,_amount);\n', '    }\n', '\n', '    /** @dev Set address of GlobalIndex.\n', '      * @param _globalIndexAddress Address to be used for current destination e.g. controller lookup.\n', '      */\n', '    function setGlobalIndexAddress(address _globalIndexAddress) public onlyOwner {\n', '        globalIndex = IGlobalIndexControllerLocation(_globalIndexAddress);\n', '    }\n', '}\n', '\n', '// File: contracts/assettoken/feature/FeatureCapitalControl.sol\n', '\n', '/*\n', '    Copyright 2018, CONDA\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '/** @title FeatureCapitalControl. */\n', 'contract FeatureCapitalControl is ICRWDAssetToken {\n', '    \n', '////////////////\n', '// Variables\n', '////////////////\n', '\n', '    //if set can mint after finished. E.g. a notary.\n', '    address public capitalControl;\n', '\n', '////////////////\n', '// Constructor\n', '////////////////\n', '\n', '    constructor(address _capitalControl) public {\n', '        capitalControl = _capitalControl;\n', '        enableTransferInternal(false); //disable transfer as default\n', '    }\n', '\n', '////////////////\n', '// Modifiers\n', '////////////////\n', '\n', '    //override: skip certain modifier checks as capitalControl\n', '    function _canDoAnytime() internal view returns (bool) {\n', '        return msg.sender == capitalControl;\n', '    }\n', '\n', '    modifier onlyCapitalControl() {\n', '        require(msg.sender == capitalControl, "permission");\n', '        _;\n', '    }\n', '\n', '////////////////\n', '// Functions\n', '////////////////\n', '\n', '    /// @notice set capitalControl\n', '    /// @dev this looks unprotected but has a checkCanSetMetadata check.\n', '    ///  depending on inheritance this can be done \n', '    ///  before alive and any time by capitalControl\n', '    function setCapitalControl(address _capitalControl) public {\n', '        require(checkCanSetMetadata(), "forbidden");\n', '\n', '        capitalControl = _capitalControl;\n', '    }\n', '\n', '    /// @notice as capital control I can pass my ownership to a new address (e.g. private key leaked).\n', '    /// @param _capitalControl new capitalControl address\n', '    function updateCapitalControl(address _capitalControl) public onlyCapitalControl {\n', '        capitalControl = _capitalControl;\n', '    }\n', '\n', '////////////////\n', '// Reopen crowdsale (by capitalControl e.g. notary)\n', '////////////////\n', '\n', '    /// @notice capitalControl can reopen the crowdsale.\n', '    function reopenCrowdsale() public onlyCapitalControl returns (bool) {        \n', '        return reopenCrowdsaleInternal();\n', '    }\n', '}\n', '\n', '// File: contracts/assettoken/feature/FeatureCapitalControlWithForcedTransferFrom.sol\n', '\n', '/*\n', '    Copyright 2018, CONDA\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/** @title FeatureCapitalControlWithForcedTransferFrom. */\n', 'contract FeatureCapitalControlWithForcedTransferFrom is FeatureCapitalControl {\n', '\n', '///////////////////\n', '// Constructor\n', '///////////////////\n', '\n', '    constructor(address _capitalControl) FeatureCapitalControl(_capitalControl) public { }\n', '\n', '///////////////////\n', '// Events\n', '///////////////////\n', '\n', '    event SelfApprovedTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '///////////////////\n', '// Overrides\n', '///////////////////\n', '\n', '    //override: transferFrom that has special self-approve behaviour when executed as capitalControl\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n', '    {\n', '        if (msg.sender == capitalControl) {\n', '            return enforcedTransferFromInternal(_from, _to, _value, true);\n', '        } else {\n', '            return transferFromInternal(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/assettoken/STOs/AssetTokenT001.sol\n', '\n', '/** @title AssetTokenT001 Token. A CRWDAssetToken with CapitalControl and LostWallet feature */\n', 'contract AssetTokenT001 is CRWDAssetToken, FeatureCapitalControlWithForcedTransferFrom\n', '{    \n', '    constructor(address _capitalControl) FeatureCapitalControlWithForcedTransferFrom(_capitalControl) public {}\n', '}']