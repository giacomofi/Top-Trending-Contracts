['pragma solidity ^0.5.7;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract EIP20 is EIP20Interface {\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    /*\n', '    NOTE:\n', '    The following variables are OPTIONAL vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public name;                   //fancy name: eg Simon Bucks\n', '    uint8 public decimals;                //How many decimals to show.\n', '    string public symbol;                 //An identifier: eg SBX\n', '\n', '    constructor(\n', '        uint256 _initialAmount,\n', '        string memory _tokenName,\n', '        uint8 _decimalUnits,\n', '        string memory _tokenSymbol\n', '    ) public {\n', '        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n', '        totalSupply = _initialAmount;                        // Update total supply\n', '        name = _tokenName;                                   // Set the name for display purposes\n', '        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n', '        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', 'contract BitbattleExchange{\n', '    using SafeMath for uint256;\n', '\n', '    constructor(address _escrow, address _namiMultiSigWallet) public {\n', '        require(_namiMultiSigWallet != address(0));\n', '        escrow = _escrow;\n', '        namiMultiSigWallet = _namiMultiSigWallet;\n', '        \n', '        // init token\n', '        // BinanceCoin\n', '        TokenAddress[0] = 0xB8c77482e45F1F44dE1745F52C74426C631bDD52;\n', '        // Maker\n', '        TokenAddress[1] = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n', '        // BasicAttentionToken\n', '        TokenAddress[2] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n', '        // OmiseGo\n', '        TokenAddress[3] = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07;\n', '        // Chainlink\n', '        TokenAddress[4] = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\n', '        // Holo\n', '        TokenAddress[5] = 0x6c6EE5e31d828De241282B9606C8e98Ea48526E2;\n', '        // Zilliqa\n', '        TokenAddress[6] = 0x05f4a42e251f2d52b8ed15E9FEdAacFcEF1FAD27;\n', '        // Augur\n', '        TokenAddress[7] = 0x1985365e9f78359a9B6AD760e32412f4a445E862;\n', '        // 0x\n', '        TokenAddress[8] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n', '        // THETA\n', '        TokenAddress[9] = 0x3883f5e181fccaF8410FA61e12b59BAd963fb645;\n', '        // PundiX\n', '        TokenAddress[10] = 0xA15C7Ebe1f07CaF6bFF097D8a589fb8AC49Ae5B3;\n', '        // IOST\n', '        TokenAddress[11] = 0xFA1a856Cfa3409CFa145Fa4e20Eb270dF3EB21ab;\n', '        // EnjinCoin\n', '        TokenAddress[12] = 0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c;\n', '        // HuobiToken\n', '        TokenAddress[13] = 0x6f259637dcD74C767781E37Bc6133cd6A68aa161;\n', '        // Status\n', '        TokenAddress[14] = 0x744d70FDBE2Ba4CF95131626614a1763DF805B9E;\n', '        \n', '        // Nami\n', '        TokenAddress[15] = 0x8d80de8A78198396329dfA769aD54d24bF90E7aa;\n', '        // Dai\n', '        TokenAddress[16] = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n', '        // KyberNetwork\n', '        TokenAddress[17] = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200;\n', '        // Golem\n', '        TokenAddress[18] = 0xa74476443119A942dE498590Fe1f2454d7D4aC0d;\n', '        // Populous\n', '        TokenAddress[19] = 0xd4fa1460F537bb9085d22C7bcCB5DD450Ef28e3a;\n', '        // CryptoCom\n', '        TokenAddress[20] = 0xB63B606Ac810a52cCa15e44bB630fd42D8d1d83d;\n', '        // Waltonchain\n', '        TokenAddress[21] = 0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74;\n', '        // Decentraland\n', '        TokenAddress[22] = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942;\n', '        // LoomNetwork\n', '        TokenAddress[23] = 0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0;\n', '        // Loopring\n', '        TokenAddress[24] = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '        // Aelf\n', '        TokenAddress[25] = 0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e;\n', '        // PowerLedger\n', '        TokenAddress[26] = 0x595832F8FC6BF59c85C527fEC3740A1b7a361269;\n', '        // USDCoin\n', '        TokenAddress[27] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '    }\n', '\n', '    // escrow has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public escrow;\n', '    uint public minWithdraw = 1 * 10**18;\n', '    uint public maxWithdraw = 1000000 * 10**18;\n', '\n', "    // Gathered funds can be withdraw only to namimultisigwallet's address.\n", '    address public namiMultiSigWallet;\n', '    \n', '    // Token Address\n', '    mapping(uint256 => address) public TokenAddress;\n', '\n', '\n', '    /**\n', '    * list setting function\n', '    */\n', '    mapping(address => bool) public isController;\n', '\n', '    /**\n', '     * List event\n', '     */\n', '    event Withdraw(address indexed user, uint amount, uint timeWithdraw, uint tokenIndex);\n', '\n', '    modifier onlyEscrow() {\n', '        require(msg.sender == escrow);\n', '        _;\n', '    }\n', '\n', '    modifier onlyNamiMultisig {\n', '        require(msg.sender == namiMultiSigWallet);\n', '        _;\n', '    }\n', '\n', '    modifier onlyController {\n', '        require(isController[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    \n', '    /**\n', '     * Admin function\n', '     */\n', '    function() external payable {}\n', '    function changeEscrow(address _escrow) public\n', '    onlyNamiMultisig\n', '    {\n', '        require(_escrow != address(0));\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function changeMinWithdraw(uint _minWithdraw) public\n', '    onlyEscrow\n', '    {\n', '        require(_minWithdraw != 0);\n', '        minWithdraw = _minWithdraw;\n', '    }\n', '\n', '    function changeMaxWithdraw(uint _maxNac) public\n', '    onlyEscrow\n', '    {\n', '        require(_maxNac != 0);\n', '        maxWithdraw = _maxNac;\n', '    }\n', '\n', '    /// @dev withdraw ether, only escrow can call\n', '    /// @param _amount value ether in wei to withdraw\n', '    function withdrawEther(uint _amount, address payable _to) public\n', '    onlyEscrow\n', '    {\n', '        require(_to != address(0x0));\n', '        // Available at any phase.\n', '        if (address(this).balance > 0) {\n', '            _to.transfer(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * make new controller\n', '     * require input address is not a controller\n', '     * execute any time in sc state\n', '     */\n', '    function setController(address _controller)\n', '    public\n', '    onlyEscrow\n', '    {\n', '        require(!isController[_controller]);\n', '        isController[_controller] = true;\n', '    }\n', '\n', '    /**\n', '     * remove controller\n', '     * require input address is a controller\n', '     * execute any time in sc state\n', '     */\n', '    function removeController(address _controller)\n', '    public\n', '    onlyEscrow\n', '    {\n', '        require(isController[_controller]);\n', '        isController[_controller] = false;\n', '    }\n', '    \n', '    /**\n', '     * update token address\n', '     */\n', '    function updateTokenAddress(address payable _tokenAddress, uint _tokenIndex) public\n', '    onlyEscrow\n', '    {\n', '        require(_tokenAddress != address(0));\n', '        TokenAddress[_tokenIndex] = _tokenAddress;\n', '    }\n', '\n', '\n', '    function withdrawToken(address _account, uint _amount, uint _tokenIndex) public\n', '    onlyController\n', '    {\n', '        require(_account != address(0x0) && _amount != 0);\n', '        require(_amount >= minWithdraw && _amount <= maxWithdraw);\n', '        \n', '        // check valid token index\n', '        require(TokenAddress[_tokenIndex] != address(0));\n', '        EIP20 ERC20Token = EIP20(TokenAddress[_tokenIndex]);\n', '        if (ERC20Token.balanceOf(address(this)) >= _amount) {\n', '            ERC20Token.transfer(_account, _amount);\n', '        } else {\n', '            revert();\n', '        }\n', '        // emit event\n', '        emit Withdraw(_account, _amount, now, _tokenIndex);\n', '    }\n', '}']