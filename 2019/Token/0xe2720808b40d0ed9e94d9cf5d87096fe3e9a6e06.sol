['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ForeignToken {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\tconstructor() public{\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '\tevent Pause();\n', '\tevent Unpause();\n', '\n', '\tbool public paused = false;\n', '\n', '\tmodifier whenNotPaused() {\n', '\t\trequire(!paused);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier whenPaused() {\n', '\t\trequire(paused);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction pause() onlyOwner whenNotPaused public {\n', '\t\tpaused = true;\n', '\t\temit Pause();\n', '\t}\n', '\n', '\tfunction unpause() onlyOwner whenPaused public {\n', '\t\tpaused = false;\n', '\t\temit Unpause();\n', '\t}\n', '}\n', '\n', 'contract CARLO is ERC20,Pausable {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping (address => bool) public blacklist;\n', '\n', '    string public constant name = "CARLO";\n', '    string public constant symbol = "CARLO";\n', '    uint8 public constant decimals = 18; \n', '\n', '\tuint256 public foundationDistributed = 100000000e18;\n', '\tuint256 public marketDistributed = 360000000e18;\n', '\tuint256 public devDistributed = 240000000e18;\n', '\tuint256 public labDistributed = 300000000e18;\n', '\t\n', '\tuint256 public devLockFirstDistributed = 300000000e18;\n', '\tuint256 public devLockSecondDistributed = 300000000e18;\n', '\tuint256 public devLockThirdDistributed = 400000000e18; \n', '\n', '    uint256 public totalRemaining; \n', '\t\n', '\taddress private devLockFirstBeneficiary = 0x9E01714A3700168E82b898618C6181Eb6abF7cff;\n', '\taddress private devLockSecondBeneficiary = 0x20986b25C551f7944cEbF500F6C950229865FAae;\n', '\taddress private devLockThirdBeneficiary = 0x3cD928a432c9666be26fE82480A8a77dA33b2B42;\n', '\taddress private foundationBeneficiary = 0xCCF02CC2fF5e896fF3D7D6aDC59bAbe514EBb64C;\n', '\taddress private marketBeneficiary = 0xC9b66dC5A27d94F9ab804dF98437945700b93555;\n', '\taddress private devBeneficiary = 0xf89fdcca528e1E82da8dee643b38e693AebB6F45;\n', '\taddress private labBeneficiary = 0x239d10c737E26cB85746426313aCF167b564eDB8;\n', '\n', '\tuint256 private _releaseTimeFirst = now + 365 days; \n', '\tuint256 private _releaseTimeSecond = now + 365 days + 365 days; \n', '\tuint256 private _releaseTimeThird = now + 365 days + 365 days + 365 days; \t\n', '\t\n', '\tbool public devLockFirstReleased = true;\n', '\tbool public devLockSecondReleased = true;\n', '\tbool public devLockThirdReleased = true;\n', '    \n', '    event Burn(address indexed burner, uint256 value);\n', '\tevent OwnershipTransferred(address indexed perviousOwner, address indexed newOwner);\n', '    \n', '    constructor() public {  \n', '\t\towner = msg.sender;\n', '\t\ttotalSupply = 2000000000e18;\n', '\t\ttotalRemaining = totalSupply.sub(foundationDistributed).sub(marketDistributed).sub(labDistributed).sub(devDistributed);\n', '        balances[owner] = totalRemaining;\n', '\t\tbalances[foundationBeneficiary] = foundationDistributed;\n', '\t\tbalances[marketBeneficiary] = marketDistributed;\n', '\t\tbalances[labBeneficiary] = labDistributed;\n', '\t\tbalances[devBeneficiary] = devDistributed;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\tbalances[owner] = balances[owner].sub(totalRemaining);\n', '\t\tbalances[newOwner] = balances[newOwner].add(totalRemaining);\n', '\t\temit Transfer(owner, newOwner, totalRemaining);\n', '\t\towner = newOwner;\t\t\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);  \n', '        _;\n', '    }\n', '\t\n', '\tfunction isPayLockFirst() public view returns (bool) { \n', '\t\tif (now >= _releaseTimeFirst) {\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\tfunction isPayLockSecond() public view returns (bool) { \n', '\t\tif (now >= _releaseTimeSecond) {\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\tfunction isPayLockThird() public view returns (bool) { \t\t\n', '\t\tif (now >= _releaseTimeThird) {\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\tfunction releaseFirst()internal {\n', '\t\tbalances[owner] = balances[owner].sub(devLockFirstDistributed);\n', '\t\tbalances[devLockFirstBeneficiary] = balances[devLockFirstBeneficiary].add(devLockFirstDistributed);\n', '\t\temit Transfer(owner, devLockFirstBeneficiary, devLockFirstDistributed);\n', '\t\ttotalRemaining = totalRemaining.sub(devLockFirstDistributed);\n', '\t\tdevLockFirstReleased = false;\n', '\t}\n', '\tfunction releaseSecond() internal {\n', '\t\tbalances[owner] = balances[owner].sub(devLockSecondDistributed);\n', '\t\tbalances[devLockSecondBeneficiary] = balances[devLockSecondBeneficiary].add(devLockSecondDistributed);\n', '\t\temit Transfer(owner, devLockSecondBeneficiary, devLockSecondDistributed);\n', '\t\ttotalRemaining = totalRemaining.sub(devLockSecondDistributed);\n', '\t\tdevLockSecondReleased = false;\n', '\t}\n', '\tfunction releaseThird() internal {\n', '\t\tbalances[owner] = balances[owner].sub(devLockThirdDistributed);\n', '\t\tbalances[devLockThirdBeneficiary] = balances[devLockThirdBeneficiary].add(devLockThirdDistributed);\n', '\t\temit Transfer(owner, devLockThirdBeneficiary, devLockThirdDistributed);\n', '\t\ttotalRemaining = totalRemaining.sub(devLockThirdDistributed);\n', '\t\tdevLockThirdReleased = false;\n', '\t}\n', '\t\n', '\tfunction release(address from) internal {\n', '\t\tif (from == devLockFirstBeneficiary) {\n', '\t\t\tif (isPayLockFirst()) {\n', '\t\t\t\tif (devLockFirstReleased) {\n', '\t\t\t\t\treleaseFirst();\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (from == devLockSecondBeneficiary) {\n', '\t\t\tif (isPayLockSecond()) {\n', '\t\t\t\tif (devLockSecondReleased) {\n', '\t\t\t\t\treleaseSecond();\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (from == devLockThirdBeneficiary) {\n', '\t\t\tif (isPayLockThird()) {\n', '\t\t\t\tif (devLockThirdReleased) {\n', '\t\t\t\t\treleaseThird();\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t}\n', '    \n', '    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public whenNotPaused returns (bool success) {\n', '        require(blacklist[msg.sender] == false);\n', '\t\trequire(blacklist[_to] == false);\n', '\t\trequire(_to != address(0));\n', '\t\tif (msg.sender == owner) {\n', '\t\t\trequire(balances[msg.sender] >= (totalRemaining.add(_amount)));\n', '\t\t}\n', '\t\trelease(msg.sender);\n', '        require(_amount <= balances[msg.sender]);\t\t\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\t\t\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public whenNotPaused returns (bool success) {\n', '        require(blacklist[msg.sender] == false);\n', '\t\trequire(blacklist[_to] == false);\n', '\t\trequire(blacklist[_from] == false);\n', '\t\trequire(_to != address(0));\n', '\t\tif (_from == owner) {\n', '\t\t\trequire(balances[_from] >= (totalRemaining.add(_amount)));\n', '\t\t}\n', '\t\trelease(_from);\n', '        require(_amount <= balances[_from]);\n', '        require(_amount <= allowed[_from][msg.sender]);\t\t\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) {\n', '\t\trequire(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\t\n', '\tfunction addOrRemoveBlackList(address _addr, bool action) onlyOwner public returns (bool success) {\n', '\t\trequire(_addr != address(0));\n', '\t\tblacklist[_addr] = action;\n', '\t\treturn true;\n', '\t}\n', '    \n', '    function allowance(address _owner, address _spender) constant public returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n', '        ForeignToken t = ForeignToken(tokenAddress);\n', '        uint bal = t.balanceOf(who);\n', '        return bal;\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        uint256 etherBalance = address(this).balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    \n', '    function burn(uint256 _value) onlyOwner public {\n', '\t\trequire(balances[msg.sender] >= totalRemaining.add(_value));\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Burn(burner, _value);\n', '    }\n', '    \n', '    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n', '        ForeignToken token = ForeignToken(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(owner, amount);\n', '    }\n', '}']