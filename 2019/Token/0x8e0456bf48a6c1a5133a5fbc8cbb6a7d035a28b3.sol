['pragma solidity ^0.4.25;\n', '\n', 'interface IERC20 {\n', '  function transfer(address _to, uint256 _amount) external returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\n', '  function balanceOf(address _owner) constant external returns (uint256 balance);\n', '  function approve(address _spender, uint256 _amount) external returns (bool success);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool success);\n', '  function totalSupply() external constant returns (uint);\n', '}\n', '\n', 'interface IResultStorage {\n', '    function getResult(bytes32 _predictionId) external returns (uint8);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public executor;\n', '    address public superOwner;\n', '  \n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        superOwner = msg.sender;\n', '        owner = msg.sender;\n', '        executor = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlySuperOwner {\n', '        require(msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrSuperOwner {\n', '        require(msg.sender == owner || msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed {\n', '        require(msg.sender == owner || msg.sender == executor || msg.sender == superOwner, "Not allowed");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwnerOrSuperOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function transferSuperOwnership(address _newOwner) public onlySuperOwner {\n', '        superOwner = _newOwner;\n', '    }\n', '\n', '    function transferExecutorOwnership(address _newExecutor) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(executor, _newExecutor);\n', '        executor = _newExecutor;\n', '    }\n', '}\n', '\n', 'contract ResultStorage is Owned, IResultStorage {\n', '\n', '    event ResultAssigned(bytes32 indexed _predictionId, uint8 _outcomeId);\n', '    event Withdraw(uint _amount);\n', '\n', '    struct Result {     \n', '        uint8 outcomeId;\n', '        bool resolved; \n', '    }\n', '\n', '    uint8 public constant version = 1;\n', '    bool public paused;\n', '    mapping(bytes32 => Result) public results;  \n', '\n', '    modifier notPaused() {\n', '        require(paused == false, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier resolved(bytes32 _predictionId) {\n', '        require(results[_predictionId].resolved == true, "Prediction is not resolved");\n', '        _;\n', '    }\n', ' \n', '    function setOutcome (bytes32 _predictionId, uint8 _outcomeId)\n', '            public \n', '            onlyAllowed\n', '            notPaused {        \n', '        \n', '        results[_predictionId].outcomeId = _outcomeId;\n', '        results[_predictionId].resolved = true;\n', '        \n', '        emit ResultAssigned(_predictionId, _outcomeId);\n', '    }\n', '\n', '    function getResult(bytes32 _predictionId) \n', '            public \n', '            view \n', '            resolved(_predictionId)\n', '            returns (uint8) {\n', '        return results[_predictionId].outcomeId;\n', '    }\n', '\n', '    //////////\n', '    // Safety Methods\n', '    //////////\n', '    function () public payable {\n', '        require(false);\n', '    }\n', '\n', '    function withdrawETH() external onlyOwnerOrSuperOwner {\n', '        uint balance = address(this).balance;\n', '        owner.transfer(balance);\n', '        emit Withdraw(balance);\n', '    }\n', '\n', '    function withdrawTokens(uint _amount, address _token) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(_token).transfer(owner, _amount));\n', '        emit Withdraw(_amount);\n', '    }\n', '\n', '    function pause(bool _paused) external onlyOwnerOrSuperOwner {\n', '        paused = _paused;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'interface IERC20 {\n', '  function transfer(address _to, uint256 _amount) external returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\n', '  function balanceOf(address _owner) constant external returns (uint256 balance);\n', '  function approve(address _spender, uint256 _amount) external returns (bool success);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool success);\n', '  function totalSupply() external constant returns (uint);\n', '}\n', '\n', 'interface IResultStorage {\n', '    function getResult(bytes32 _predictionId) external returns (uint8);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public executor;\n', '    address public superOwner;\n', '  \n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        superOwner = msg.sender;\n', '        owner = msg.sender;\n', '        executor = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlySuperOwner {\n', '        require(msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrSuperOwner {\n', '        require(msg.sender == owner || msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed {\n', '        require(msg.sender == owner || msg.sender == executor || msg.sender == superOwner, "Not allowed");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwnerOrSuperOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function transferSuperOwnership(address _newOwner) public onlySuperOwner {\n', '        superOwner = _newOwner;\n', '    }\n', '\n', '    function transferExecutorOwnership(address _newExecutor) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(executor, _newExecutor);\n', '        executor = _newExecutor;\n', '    }\n', '}\n', '\n', 'contract ResultStorage is Owned, IResultStorage {\n', '\n', '    event ResultAssigned(bytes32 indexed _predictionId, uint8 _outcomeId);\n', '    event Withdraw(uint _amount);\n', '\n', '    struct Result {     \n', '        uint8 outcomeId;\n', '        bool resolved; \n', '    }\n', '\n', '    uint8 public constant version = 1;\n', '    bool public paused;\n', '    mapping(bytes32 => Result) public results;  \n', '\n', '    modifier notPaused() {\n', '        require(paused == false, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier resolved(bytes32 _predictionId) {\n', '        require(results[_predictionId].resolved == true, "Prediction is not resolved");\n', '        _;\n', '    }\n', ' \n', '    function setOutcome (bytes32 _predictionId, uint8 _outcomeId)\n', '            public \n', '            onlyAllowed\n', '            notPaused {        \n', '        \n', '        results[_predictionId].outcomeId = _outcomeId;\n', '        results[_predictionId].resolved = true;\n', '        \n', '        emit ResultAssigned(_predictionId, _outcomeId);\n', '    }\n', '\n', '    function getResult(bytes32 _predictionId) \n', '            public \n', '            view \n', '            resolved(_predictionId)\n', '            returns (uint8) {\n', '        return results[_predictionId].outcomeId;\n', '    }\n', '\n', '    //////////\n', '    // Safety Methods\n', '    //////////\n', '    function () public payable {\n', '        require(false);\n', '    }\n', '\n', '    function withdrawETH() external onlyOwnerOrSuperOwner {\n', '        uint balance = address(this).balance;\n', '        owner.transfer(balance);\n', '        emit Withdraw(balance);\n', '    }\n', '\n', '    function withdrawTokens(uint _amount, address _token) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(_token).transfer(owner, _amount));\n', '        emit Withdraw(_amount);\n', '    }\n', '\n', '    function pause(bool _paused) external onlyOwnerOrSuperOwner {\n', '        paused = _paused;\n', '    }\n', '}']
