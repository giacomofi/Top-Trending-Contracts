['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-04\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove an account&#39;s access to this role\n', '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', 'contract PauserRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    constructor () internal {\n', '        _addPauser(msg.sender);\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(msg.sender);\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', ' * all accounts just by listening to said events. Note that this isn&#39;t required by the specification, and other\n', ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param owner The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified addresses\n', '    * @param from The address to transfer from.\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account, deducting from the sender&#39;s allowance for said account. Uses the\n', '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '        _burn(account, value);\n', '        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @return true if the contract is paused, false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev ERC20 modified with pausable transfers.\n', ' **/\n', 'contract ERC20Pausable is ERC20, Pausable {\n', '    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.approve(spender, value);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n', '        return super.increaseAllowance(spender, addedValue);\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n', '        return super.decreaseAllowance(spender, subtractedValue);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Detailed token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @return the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @return the symbol of the token.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @return the number of decimals of the token.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract BNDESRegistry is Ownable() {\n', '\n', '    /**\n', '        The account of clients and suppliers are assigned to states. \n', '        Reserved accounts (e.g. from BNDES and ANCINE) do not have state.\n', '        AVAILABLE - The account is not yet assigned any role (any of them - client, supplier or any reserved addresses).\n', '        WAITING_VALIDATION - The account was linked to a legal entity but it still needs to be validated\n', '        VALIDATED - The account was validated\n', '        INVALIDATED_BY_VALIDATOR - The account was invalidated\n', '        INVALIDATED_BY_CHANGE - The client or supplier changed the ethereum account so the original one must be invalidated.\n', '     */\n', '    enum BlockchainAccountState {AVAILABLE,WAITING_VALIDATION,VALIDATED,INVALIDATED_BY_VALIDATOR,INVALIDATED_BY_CHANGE} \n', '    BlockchainAccountState blockchainState; //Not used. Defined to create the enum type.\n', '\n', '    address responsibleForSettlement;\n', '    address responsibleForRegistryValidation;\n', '    address responsibleForDisbursement;\n', '    address redemptionAddress;\n', '    address tokenAddress;\n', '\n', '    /**\n', '        Describes the Legal Entity - clients or suppliers\n', '     */\n', '    struct LegalEntityInfo {\n', '        uint64 cnpj; //Brazilian identification of legal entity\n', '        uint64 idFinancialSupportAgreement; //SCC contract\n', '        uint32 salic; //ANCINE identifier\n', '        string idProofHash; //hash of declaration\n', '        BlockchainAccountState state;\n', '    } \n', '\n', '    /**\n', '        Links Ethereum addresses to LegalEntityInfo        \n', '     */\n', '    mapping(address => LegalEntityInfo) public legalEntitiesInfo;\n', '\n', '    /**\n', '        Links Legal Entity to Ethereum address. \n', '        cnpj => (idFinancialSupportAgreement => address)\n', '     */\n', '    mapping(uint64 => mapping(uint64 => address)) cnpjFSAddr; \n', '\n', '\n', '    /**\n', '        Links Ethereum addresses to the possibility to change the account\n', '        Since the Ethereum account can be changed once, it is not necessary to put the bool to false.\n', '        TODO: Discuss later what is the best data structure\n', '     */\n', '    mapping(address => bool) public legalEntitiesChangeAccount;\n', '\n', '\n', '    event AccountRegistration(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string idProofHash);\n', '    event AccountChange(address oldAddr, address newAddr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string idProofHash);\n', '    event AccountValidation(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic);\n', '    event AccountInvalidation(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the token address.\n', '     */\n', '    modifier onlyTokenAddress() {\n', '        require(isTokenAddress());\n', '        _;\n', '    }\n', '\n', '    constructor () public {\n', '        responsibleForSettlement = msg.sender;\n', '        responsibleForRegistryValidation = msg.sender;\n', '        responsibleForDisbursement = msg.sender;\n', '        redemptionAddress = msg.sender;\n', '    }\n', '\n', '\n', '   /**\n', '    * Link blockchain address with CNPJ - It can be a cliente or a supplier\n', '    * The link still needs to be validated by BNDES\n', '    * This method can only be called by BNDESToken contract because BNDESToken can pause.\n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param addr the address to be associated with the legal entity.\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function registryLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, \n', '        address addr, string memory idProofHash) onlyTokenAddress public { \n', '\n', '        // Endere&#231;o n&#227;o pode ter sido cadastrado anteriormente\n', '        require (isAvailableAccount(addr), "Endere&#231;o n&#227;o pode ter sido cadastrado anteriormente");\n', '\n', '        require (isValidHash(idProofHash), "O hash da declara&#231;&#227;o &#233; inv&#225;lido");\n', '\n', '        legalEntitiesInfo[addr] = LegalEntityInfo(cnpj, idFinancialSupportAgreement, salic, idProofHash, BlockchainAccountState.WAITING_VALIDATION);\n', '        \n', '        // N&#227;o pode haver outro endere&#231;o cadastrado para esse mesmo subcr&#233;dito\n', '        if (idFinancialSupportAgreement > 0) {\n', '            address account = getBlockchainAccount(cnpj,idFinancialSupportAgreement);\n', '            require (isAvailableAccount(account), "Cliente j&#225; est&#225; associado a outro endere&#231;o. Use a fun&#231;&#227;o Troca.");\n', '        }\n', '        else {\n', '            address account = getBlockchainAccount(cnpj,0);\n', '            require (isAvailableAccount(account), "Fornecedor j&#225; est&#225; associado a outro endere&#231;o. Use a fun&#231;&#227;o Troca.");\n', '        }\n', '        \n', '        cnpjFSAddr[cnpj][idFinancialSupportAgreement] = addr;\n', '\n', '        emit AccountRegistration(addr, cnpj, idFinancialSupportAgreement, salic, idProofHash);\n', '    }\n', '\n', '   /**\n', '    * Changes the original link between CNPJ and Ethereum account. \n', '    * The new link still needs to be validated by BNDES.\n', '    * This method can only be called by BNDESToken contract because BNDESToken can pause and because there are \n', '    * additional instructions there.\n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param newAddr the new address to be associated with the legal entity\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function changeAccountLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, \n', '        address newAddr, string memory idProofHash) onlyTokenAddress public {\n', '\n', '        address oldAddr = getBlockchainAccount(cnpj, idFinancialSupportAgreement);\n', '    \n', '        // Tem que haver um endere&#231;o associado a esse cnpj/subcr&#233;dito\n', '        require(!isReservedAccount(oldAddr), "N&#227;o pode trocar endere&#231;o de conta reservada");\n', '\n', '        require(!isAvailableAccount(oldAddr), "Tem que haver um endere&#231;o associado a esse cnpj/subcr&#233;dito");\n', '\n', '        require(isAvailableAccount(newAddr), "Novo endere&#231;o n&#227;o est&#225; dispon&#237;vel");\n', '\n', '        require (isChangeAccountEnabled(oldAddr), "A conta atual n&#227;o est&#225; habilitada para troca");\n', '\n', '        require (isValidHash(idProofHash), "O hash da declara&#231;&#227;o &#233; inv&#225;lido");        \n', '\n', '        require(legalEntitiesInfo[oldAddr].cnpj==cnpj \n', '                    && legalEntitiesInfo[oldAddr].idFinancialSupportAgreement ==idFinancialSupportAgreement, \n', '                    "Dados inconsistentes de cnpj ou subcr&#233;dito");\n', '\n', '        // Aponta o novo endere&#231;o para o novo LegalEntityInfo\n', '        legalEntitiesInfo[newAddr] = LegalEntityInfo(cnpj, idFinancialSupportAgreement, salic, idProofHash, BlockchainAccountState.WAITING_VALIDATION);\n', '\n', '        // Apaga o mapping do endere&#231;o antigo\n', '        legalEntitiesInfo[oldAddr].state = BlockchainAccountState.INVALIDATED_BY_CHANGE;\n', '\n', '        // Aponta mapping CNPJ e Subcredito para newAddr\n', '        cnpjFSAddr[cnpj][idFinancialSupportAgreement] = newAddr;\n', '\n', '        emit AccountChange(oldAddr, newAddr, cnpj, idFinancialSupportAgreement, salic, idProofHash); \n', '\n', '    }\n', '\n', '   /**\n', '    * Validates the initial registry of a legal entity or the change of its registry\n', '    * @param addr Ethereum address that needs to be validated\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function validateRegistryLegalEntity(address addr, string memory idProofHash) public {\n', '\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o respons&#225;vel pela valida&#231;&#227;o pode validar contas");\n', '\n', '        require(legalEntitiesInfo[addr].state == BlockchainAccountState.WAITING_VALIDATION, "A conta precisa estar no estado Aguardando Valida&#231;&#227;o");\n', '\n', '        require(keccak256(abi.encodePacked(legalEntitiesInfo[addr].idProofHash)) == keccak256(abi.encodePacked(idProofHash)), "O hash recebido &#233; diferente do esperado");\n', '\n', '        legalEntitiesInfo[addr].state = BlockchainAccountState.VALIDATED;\n', '\n', '        emit AccountValidation(addr, legalEntitiesInfo[addr].cnpj, \n', '            legalEntitiesInfo[addr].idFinancialSupportAgreement,\n', '            legalEntitiesInfo[addr].salic);\n', '    }\n', '\n', '   /**\n', '    * Invalidates the initial registry of a legal entity or the change of its registry\n', '    * The invalidation can be called at any time in the lifecycle of the address (not only when it is WAITING_VALIDATION)\n', '    * @param addr Ethereum address that needs to be validated\n', '    */\n', '    function invalidateRegistryLegalEntity(address addr) public {\n', '\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o respons&#225;vel pela valida&#231;&#227;o pode invalidar contas");\n', '\n', '        require(!isReservedAccount(addr), "N&#227;o &#233; poss&#237;vel invalidar conta reservada");\n', '\n', '        legalEntitiesInfo[addr].state = BlockchainAccountState.INVALIDATED_BY_VALIDATOR;\n', '        \n', '        emit AccountInvalidation(addr, legalEntitiesInfo[addr].cnpj, \n', '            legalEntitiesInfo[addr].idFinancialSupportAgreement,\n', '            legalEntitiesInfo[addr].salic);\n', '    }\n', '\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Settlement. \n', '    * The owner can assign other address to be the Responsible for Settlement. \n', '    * @param rs Ethereum address to be assigned as Responsible for Settlement.\n', '    */\n', '    function setResponsibleForSettlement(address rs) onlyOwner public {\n', '        responsibleForSettlement = rs;\n', '    }\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Validation. \n', '    * The owner can assign other address to be the Responsible for Validation. \n', '    * @param rs Ethereum address to be assigned as Responsible for Validation.\n', '    */\n', '    function setResponsibleForRegistryValidation(address rs) onlyOwner public {\n', '        responsibleForRegistryValidation = rs;\n', '    }\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Disbursment. \n', '    * The owner can assign other address to be the Responsible for Disbursment. \n', '    * @param rs Ethereum address to be assigned as Responsible for Disbursment.\n', '    */\n', '    function setResponsibleForDisbursement(address rs) onlyOwner public {\n', '        responsibleForDisbursement = rs;\n', '    }\n', '\n', '   /**\n', '    * The supplier reedems the BNDESToken by transfering the tokens to a specific address, \n', '    * called Redemption address. \n', '    * By default, the redemption address is the address of the owner. \n', '    * The owner can change the redemption address using this function. \n', '    * @param rs new Redemption address\n', '    */\n', '    function setRedemptionAddress(address rs) onlyOwner public {\n', '        redemptionAddress = rs;\n', '    }\n', '\n', '   /**\n', '    * @param rs Ethereum address to be assigned to the token address.\n', '    */\n', '    function setTokenAddress(address rs) onlyOwner public {\n', '        tokenAddress = rs;\n', '    }\n', '\n', '   /**\n', '    * Enable the legal entity to change the account\n', '    * @param rs account that can be changed.\n', '    */\n', '    function enableChangeAccount (address rs) public {\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o respons&#225;vel pela valida&#231;&#227;o pode habilitar a troca de conta");\n', '        legalEntitiesChangeAccount[rs] = true;\n', '    }\n', '\n', '    function isChangeAccountEnabled (address rs) view public returns (bool) {\n', '        return legalEntitiesChangeAccount[rs] == true;\n', '    }    \n', '\n', '    function isTokenAddress() public view returns (bool) {\n', '        return tokenAddress == msg.sender;\n', '    } \n', '    function isResponsibleForSettlement(address addr) view public returns (bool) {\n', '        return (addr == responsibleForSettlement);\n', '    }\n', '    function isResponsibleForRegistryValidation(address addr) view public returns (bool) {\n', '        return (addr == responsibleForRegistryValidation);\n', '    }\n', '    function isResponsibleForDisbursement(address addr) view public returns (bool) {\n', '        return (addr == responsibleForDisbursement);\n', '    }\n', '    function isRedemptionAddress(address addr) view public returns (bool) {\n', '        return (addr == redemptionAddress);\n', '    }\n', '\n', '    function isReservedAccount(address addr) view public returns (bool) {\n', '\n', '        if (isOwner(addr) || isResponsibleForSettlement(addr) \n', '                           || isResponsibleForRegistryValidation(addr)\n', '                           || isResponsibleForDisbursement(addr)\n', '                           || isRedemptionAddress(addr) ) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isOwner(address addr) view public returns (bool) {\n', '        return owner()==addr;\n', '    }\n', '\n', '    function isSupplier(address addr) view public returns (bool) {\n', '\n', '        if (isReservedAccount(addr))\n', '            return false;\n', '\n', '        if (isAvailableAccount(addr))\n', '            return false;\n', '\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement == 0;\n', '    }\n', '\n', '    function isValidatedSupplier (address addr) view public returns (bool) {\n', '        return isSupplier(addr) && (legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED);\n', '    }\n', '\n', '    function isClient (address addr) view public returns (bool) {\n', '        if (isReservedAccount(addr)) {\n', '            return false;\n', '        }\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement != 0;\n', '    }\n', '\n', '    function isValidatedClient (address addr) view public returns (bool) {\n', '        return isClient(addr) && (legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED);\n', '    }\n', '\n', '    function isAvailableAccount(address addr) view public returns (bool) {\n', '        if ( isReservedAccount(addr) ) {\n', '            return false;\n', '        } \n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.AVAILABLE;\n', '    }\n', '\n', '    function isWaitingValidationAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.WAITING_VALIDATION;\n', '    }\n', '\n', '    function isValidatedAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED;\n', '    }\n', '\n', '    function isInvalidatedByValidatorAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.INVALIDATED_BY_VALIDATOR;\n', '    }\n', '\n', '    function isInvalidatedByChangeAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.INVALIDATED_BY_CHANGE;\n', '    }\n', '\n', '    function getResponsibleForSettlement() view public returns (address) {\n', '        return responsibleForSettlement;\n', '    }\n', '    function getResponsibleForRegistryValidation() view public returns (address) {\n', '        return responsibleForRegistryValidation;\n', '    }\n', '    function getResponsibleForDisbursement() view public returns (address) {\n', '        return responsibleForDisbursement;\n', '    }\n', '    function getRedemptionAddress() view public returns (address) {\n', '        return redemptionAddress;\n', '    }\n', '    function getCNPJ(address addr) view public returns (uint64) {\n', '        return legalEntitiesInfo[addr].cnpj;\n', '    }\n', '\n', '    function getIdLegalFinancialAgreement(address addr) view public returns (uint64) {\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement;\n', '    }\n', '\n', '    function getLegalEntityInfo (address addr) view public returns (uint64, uint64, uint32, string memory, uint, address) {\n', '        return (legalEntitiesInfo[addr].cnpj, legalEntitiesInfo[addr].idFinancialSupportAgreement, \n', '             legalEntitiesInfo[addr].salic, legalEntitiesInfo[addr].idProofHash, (uint) (legalEntitiesInfo[addr].state),\n', '             addr);\n', '    }\n', '\n', '    function getBlockchainAccount(uint64 cnpj, uint64 idFinancialSupportAgreement) view public returns (address) {\n', '        return cnpjFSAddr[cnpj][idFinancialSupportAgreement];\n', '    }\n', '\n', '    function getLegalEntityInfoByCNPJ (uint64 cnpj, uint64 idFinancialSupportAgreement) \n', '        view public returns (uint64, uint64, uint32, string memory, uint, address) {\n', '        \n', '        address addr = getBlockchainAccount(cnpj,idFinancialSupportAgreement);\n', '        return getLegalEntityInfo (addr);\n', '    }\n', '\n', '    function getAccountState(address addr) view public returns (int) {\n', '\n', '        if ( isReservedAccount(addr) ) {\n', '            return 100;\n', '        } \n', '        else {\n', '            return ((int) (legalEntitiesInfo[addr].state));\n', '        }\n', '\n', '    }\n', '\n', '\n', '  function isValidHash(string memory str) pure public returns (bool)  {\n', '\n', '    bytes memory b = bytes(str);\n', '    if(b.length != 64) return false;\n', '\n', '    for (uint i=0; i<64; i++) {\n', '        if (b[i] < "0") return false;\n', '        if (b[i] > "9" && b[i] <"a") return false;\n', '        if (b[i] > "f") return false;\n', '    }\n', '        \n', '    return true;\n', ' }\n', '\n', '\n', '}\n', '\n', '\n', 'contract BNDESToken is ERC20Pausable, ERC20Detailed("BNDESToken", "BND", 2) {\n', '\n', '    uint private version = 20190517;\n', '\n', '    BNDESRegistry registry;\n', '\n', '    event BNDESTokenDisbursement(uint64 cnpj, uint64 idFinancialSupportAgreement, uint256 value);\n', '    event BNDESTokenTransfer(uint64 fromCnpj, uint64 fromIdFinancialSupportAgreement, uint64 toCnpj, uint256 value);\n', '    event BNDESTokenRedemption(uint64 cnpj, uint256 value);\n', '    event BNDESTokenRedemptionSettlement(string redemptionTransactionHash, string receiptHash);\n', '    event BNDESManualIntervention(string description);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    constructor (address newRegistryAddr) public {\n', '        registry = BNDESRegistry(newRegistryAddr);\n', '    }\n', '\n', '\n', '    function getVersion() view public returns (uint) {\n', '        return version;\n', '    }\n', '\n', '\n', '   /**\n', '    * The transfer funcion follows ERC20 token signature. \n', '    * Using them, it is possible to disburse money to the client, transfer from client to supplier and redeem.\n', '    * @param to the Ethereum address to where the money should be sent\n', '    * @param value how much BNDESToken the supplier wants to redeem\n', '    */\n', '    function transfer (address to, uint256 value) public whenNotPaused returns (bool) {\n', '\n', '        address from = msg.sender;\n', '\n', '        require(from != to, "N&#227;o pode transferir token para si mesmo");\n', '\n', '        if (registry.isResponsibleForDisbursement(from)) {\n', '\n', '            require(registry.isValidatedClient(to), "O endere&#231;o n&#227;o pertence a um cliente ou n&#227;o est&#225; validada");\n', '\n', '            _mint(to, value);\n', '\n', '            emit BNDESTokenDisbursement(registry.getCNPJ(to), registry.getIdLegalFinancialAgreement(to), value);\n', '\n', '        } else { \n', '\n', '            if (registry.isRedemptionAddress(to)) { \n', '\n', '                require(registry.isValidatedSupplier(from), "A conta do endere&#231;o n&#227;o pertence a um fornecedor ou n&#227;o est&#225; validada");\n', '\n', '                _burn(from, value);\n', '\n', '                emit BNDESTokenRedemption(registry.getCNPJ(from), value);\n', '\n', '            } else {\n', '\n', '                // Se nem from nem to s&#227;o o Banco, eh transferencia normal\n', '\n', '                require(registry.isValidatedClient(from), "O endere&#231;o n&#227;o pertence a um cliente ou n&#227;o est&#225; validada");\n', '                require(registry.isValidatedSupplier(to), "A conta do endere&#231;o n&#227;o pertence a um fornecedor ou n&#227;o est&#225; validada");\n', '\n', '                _transfer(msg.sender, to, value);\n', '\n', '                emit BNDESTokenTransfer(registry.getCNPJ(from), registry.getIdLegalFinancialAgreement(from), \n', '                                registry.getCNPJ(to), value);\n', '  \n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    * When redeeming, the supplier indicated to the Resposible for Settlement that he wants to receive \n', '    * the FIAT money.\n', '    * @param value - how much BNDESToken the supplier wants to redeem\n', '    */\n', '    function redeem (uint256 value) public whenNotPaused returns (bool) {\n', '        return transfer(registry.getRedemptionAddress(), value);\n', '    }\n', '\n', '   /**\n', '    * Using this function, the Responsible for Settlement indicates that he has made the FIAT money transfer.\n', '    * @param redemptionTransactionHash hash of the redeem transaction in which the FIAT money settlement occurred.\n', '    * @param receiptHash hash that proof the FIAT money transfer\n', '    */\n', '    function notifyRedemptionSettlement(string memory redemptionTransactionHash, string memory receiptHash) \n', '        public whenNotPaused {\n', '        require (registry.isResponsibleForSettlement(msg.sender), "A liquida&#231;&#227;o s&#243; n&#227;o pode ser realizada pelo endere&#231;o que submeteu a transa&#231;&#227;o"); \n', '        require (registry.isValidHash(receiptHash), "O hash do recibo &#233; inv&#225;lido");\n', '        emit BNDESTokenRedemptionSettlement(redemptionTransactionHash, receiptHash);\n', '    }\n', '\n', '\n', '    function registryLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string memory idProofHash) \n', '        public whenNotPaused { \n', '        registry.registryLegalEntity(cnpj,  idFinancialSupportAgreement, salic, msg.sender, idProofHash);\n', '    }\n', '\n', '   /**\n', '    * Changes the original link between CNPJ and Ethereum account. \n', '    * The new link still needs to be validated by BNDES.\n', '    * IMPORTANT: The BNDESTOKENs are transfered from the original to the new Ethereum address \n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function changeAccountLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string memory idProofHash) \n', '        public whenNotPaused {\n', '        \n', '        address oldAddr = registry.getBlockchainAccount(cnpj, idFinancialSupportAgreement);\n', '        address newAddr = msg.sender;\n', '        \n', '        registry.changeAccountLegalEntity(cnpj, idFinancialSupportAgreement, salic, msg.sender, idProofHash);\n', '\n', '        // Se h&#225; saldo no enderecoAntigo, precisa transferir\n', '        if (balanceOf(oldAddr) > 0) {\n', '            _transfer(oldAddr, newAddr, balanceOf(oldAddr));\n', '        }\n', '\n', '    }\n', '\n', '    //These methods may be necessary to solve incidents.\n', '    function burn(address from, uint256 value, string memory description) public onlyOwner {\n', '        _burn(from, value);\n', '        emit BNDESManualIntervention(description);        \n', '    }\n', '\n', '    //These methods may be necessary to solve incidents.\n', '    function mint(address to, uint256 value, string memory description) public onlyOwner {\n', '        _mint(to, value);\n', '        emit BNDESManualIntervention(description);        \n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return registry.owner() == msg.sender;\n', '    } \n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '        require(false, "Unsupported method - transferFrom");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '        require(false, "Unsupported method - approve");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n', '        require(false, "Unsupported method - increaseAllowance");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n', '        require(false, "Unsupported method - decreaseAllowance");\n', '    }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', 'contract PauserRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    constructor () internal {\n', '        _addPauser(msg.sender);\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(msg.sender);\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param owner The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified addresses\n', '    * @param from The address to transfer from.\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '        _burn(account, value);\n', '        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @return true if the contract is paused, false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev ERC20 modified with pausable transfers.\n', ' **/\n', 'contract ERC20Pausable is ERC20, Pausable {\n', '    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.approve(spender, value);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n', '        return super.increaseAllowance(spender, addedValue);\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n', '        return super.decreaseAllowance(spender, subtractedValue);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Detailed token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @return the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @return the symbol of the token.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @return the number of decimals of the token.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract BNDESRegistry is Ownable() {\n', '\n', '    /**\n', '        The account of clients and suppliers are assigned to states. \n', '        Reserved accounts (e.g. from BNDES and ANCINE) do not have state.\n', '        AVAILABLE - The account is not yet assigned any role (any of them - client, supplier or any reserved addresses).\n', '        WAITING_VALIDATION - The account was linked to a legal entity but it still needs to be validated\n', '        VALIDATED - The account was validated\n', '        INVALIDATED_BY_VALIDATOR - The account was invalidated\n', '        INVALIDATED_BY_CHANGE - The client or supplier changed the ethereum account so the original one must be invalidated.\n', '     */\n', '    enum BlockchainAccountState {AVAILABLE,WAITING_VALIDATION,VALIDATED,INVALIDATED_BY_VALIDATOR,INVALIDATED_BY_CHANGE} \n', '    BlockchainAccountState blockchainState; //Not used. Defined to create the enum type.\n', '\n', '    address responsibleForSettlement;\n', '    address responsibleForRegistryValidation;\n', '    address responsibleForDisbursement;\n', '    address redemptionAddress;\n', '    address tokenAddress;\n', '\n', '    /**\n', '        Describes the Legal Entity - clients or suppliers\n', '     */\n', '    struct LegalEntityInfo {\n', '        uint64 cnpj; //Brazilian identification of legal entity\n', '        uint64 idFinancialSupportAgreement; //SCC contract\n', '        uint32 salic; //ANCINE identifier\n', '        string idProofHash; //hash of declaration\n', '        BlockchainAccountState state;\n', '    } \n', '\n', '    /**\n', '        Links Ethereum addresses to LegalEntityInfo        \n', '     */\n', '    mapping(address => LegalEntityInfo) public legalEntitiesInfo;\n', '\n', '    /**\n', '        Links Legal Entity to Ethereum address. \n', '        cnpj => (idFinancialSupportAgreement => address)\n', '     */\n', '    mapping(uint64 => mapping(uint64 => address)) cnpjFSAddr; \n', '\n', '\n', '    /**\n', '        Links Ethereum addresses to the possibility to change the account\n', '        Since the Ethereum account can be changed once, it is not necessary to put the bool to false.\n', '        TODO: Discuss later what is the best data structure\n', '     */\n', '    mapping(address => bool) public legalEntitiesChangeAccount;\n', '\n', '\n', '    event AccountRegistration(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string idProofHash);\n', '    event AccountChange(address oldAddr, address newAddr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string idProofHash);\n', '    event AccountValidation(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic);\n', '    event AccountInvalidation(address addr, uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the token address.\n', '     */\n', '    modifier onlyTokenAddress() {\n', '        require(isTokenAddress());\n', '        _;\n', '    }\n', '\n', '    constructor () public {\n', '        responsibleForSettlement = msg.sender;\n', '        responsibleForRegistryValidation = msg.sender;\n', '        responsibleForDisbursement = msg.sender;\n', '        redemptionAddress = msg.sender;\n', '    }\n', '\n', '\n', '   /**\n', '    * Link blockchain address with CNPJ - It can be a cliente or a supplier\n', '    * The link still needs to be validated by BNDES\n', '    * This method can only be called by BNDESToken contract because BNDESToken can pause.\n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param addr the address to be associated with the legal entity.\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function registryLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, \n', '        address addr, string memory idProofHash) onlyTokenAddress public { \n', '\n', '        // Endereço não pode ter sido cadastrado anteriormente\n', '        require (isAvailableAccount(addr), "Endereço não pode ter sido cadastrado anteriormente");\n', '\n', '        require (isValidHash(idProofHash), "O hash da declaração é inválido");\n', '\n', '        legalEntitiesInfo[addr] = LegalEntityInfo(cnpj, idFinancialSupportAgreement, salic, idProofHash, BlockchainAccountState.WAITING_VALIDATION);\n', '        \n', '        // Não pode haver outro endereço cadastrado para esse mesmo subcrédito\n', '        if (idFinancialSupportAgreement > 0) {\n', '            address account = getBlockchainAccount(cnpj,idFinancialSupportAgreement);\n', '            require (isAvailableAccount(account), "Cliente já está associado a outro endereço. Use a função Troca.");\n', '        }\n', '        else {\n', '            address account = getBlockchainAccount(cnpj,0);\n', '            require (isAvailableAccount(account), "Fornecedor já está associado a outro endereço. Use a função Troca.");\n', '        }\n', '        \n', '        cnpjFSAddr[cnpj][idFinancialSupportAgreement] = addr;\n', '\n', '        emit AccountRegistration(addr, cnpj, idFinancialSupportAgreement, salic, idProofHash);\n', '    }\n', '\n', '   /**\n', '    * Changes the original link between CNPJ and Ethereum account. \n', '    * The new link still needs to be validated by BNDES.\n', '    * This method can only be called by BNDESToken contract because BNDESToken can pause and because there are \n', '    * additional instructions there.\n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param newAddr the new address to be associated with the legal entity\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function changeAccountLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, \n', '        address newAddr, string memory idProofHash) onlyTokenAddress public {\n', '\n', '        address oldAddr = getBlockchainAccount(cnpj, idFinancialSupportAgreement);\n', '    \n', '        // Tem que haver um endereço associado a esse cnpj/subcrédito\n', '        require(!isReservedAccount(oldAddr), "Não pode trocar endereço de conta reservada");\n', '\n', '        require(!isAvailableAccount(oldAddr), "Tem que haver um endereço associado a esse cnpj/subcrédito");\n', '\n', '        require(isAvailableAccount(newAddr), "Novo endereço não está disponível");\n', '\n', '        require (isChangeAccountEnabled(oldAddr), "A conta atual não está habilitada para troca");\n', '\n', '        require (isValidHash(idProofHash), "O hash da declaração é inválido");        \n', '\n', '        require(legalEntitiesInfo[oldAddr].cnpj==cnpj \n', '                    && legalEntitiesInfo[oldAddr].idFinancialSupportAgreement ==idFinancialSupportAgreement, \n', '                    "Dados inconsistentes de cnpj ou subcrédito");\n', '\n', '        // Aponta o novo endereço para o novo LegalEntityInfo\n', '        legalEntitiesInfo[newAddr] = LegalEntityInfo(cnpj, idFinancialSupportAgreement, salic, idProofHash, BlockchainAccountState.WAITING_VALIDATION);\n', '\n', '        // Apaga o mapping do endereço antigo\n', '        legalEntitiesInfo[oldAddr].state = BlockchainAccountState.INVALIDATED_BY_CHANGE;\n', '\n', '        // Aponta mapping CNPJ e Subcredito para newAddr\n', '        cnpjFSAddr[cnpj][idFinancialSupportAgreement] = newAddr;\n', '\n', '        emit AccountChange(oldAddr, newAddr, cnpj, idFinancialSupportAgreement, salic, idProofHash); \n', '\n', '    }\n', '\n', '   /**\n', '    * Validates the initial registry of a legal entity or the change of its registry\n', '    * @param addr Ethereum address that needs to be validated\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function validateRegistryLegalEntity(address addr, string memory idProofHash) public {\n', '\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o responsável pela validação pode validar contas");\n', '\n', '        require(legalEntitiesInfo[addr].state == BlockchainAccountState.WAITING_VALIDATION, "A conta precisa estar no estado Aguardando Validação");\n', '\n', '        require(keccak256(abi.encodePacked(legalEntitiesInfo[addr].idProofHash)) == keccak256(abi.encodePacked(idProofHash)), "O hash recebido é diferente do esperado");\n', '\n', '        legalEntitiesInfo[addr].state = BlockchainAccountState.VALIDATED;\n', '\n', '        emit AccountValidation(addr, legalEntitiesInfo[addr].cnpj, \n', '            legalEntitiesInfo[addr].idFinancialSupportAgreement,\n', '            legalEntitiesInfo[addr].salic);\n', '    }\n', '\n', '   /**\n', '    * Invalidates the initial registry of a legal entity or the change of its registry\n', '    * The invalidation can be called at any time in the lifecycle of the address (not only when it is WAITING_VALIDATION)\n', '    * @param addr Ethereum address that needs to be validated\n', '    */\n', '    function invalidateRegistryLegalEntity(address addr) public {\n', '\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o responsável pela validação pode invalidar contas");\n', '\n', '        require(!isReservedAccount(addr), "Não é possível invalidar conta reservada");\n', '\n', '        legalEntitiesInfo[addr].state = BlockchainAccountState.INVALIDATED_BY_VALIDATOR;\n', '        \n', '        emit AccountInvalidation(addr, legalEntitiesInfo[addr].cnpj, \n', '            legalEntitiesInfo[addr].idFinancialSupportAgreement,\n', '            legalEntitiesInfo[addr].salic);\n', '    }\n', '\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Settlement. \n', '    * The owner can assign other address to be the Responsible for Settlement. \n', '    * @param rs Ethereum address to be assigned as Responsible for Settlement.\n', '    */\n', '    function setResponsibleForSettlement(address rs) onlyOwner public {\n', '        responsibleForSettlement = rs;\n', '    }\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Validation. \n', '    * The owner can assign other address to be the Responsible for Validation. \n', '    * @param rs Ethereum address to be assigned as Responsible for Validation.\n', '    */\n', '    function setResponsibleForRegistryValidation(address rs) onlyOwner public {\n', '        responsibleForRegistryValidation = rs;\n', '    }\n', '\n', '   /**\n', '    * By default, the owner is also the Responsible for Disbursment. \n', '    * The owner can assign other address to be the Responsible for Disbursment. \n', '    * @param rs Ethereum address to be assigned as Responsible for Disbursment.\n', '    */\n', '    function setResponsibleForDisbursement(address rs) onlyOwner public {\n', '        responsibleForDisbursement = rs;\n', '    }\n', '\n', '   /**\n', '    * The supplier reedems the BNDESToken by transfering the tokens to a specific address, \n', '    * called Redemption address. \n', '    * By default, the redemption address is the address of the owner. \n', '    * The owner can change the redemption address using this function. \n', '    * @param rs new Redemption address\n', '    */\n', '    function setRedemptionAddress(address rs) onlyOwner public {\n', '        redemptionAddress = rs;\n', '    }\n', '\n', '   /**\n', '    * @param rs Ethereum address to be assigned to the token address.\n', '    */\n', '    function setTokenAddress(address rs) onlyOwner public {\n', '        tokenAddress = rs;\n', '    }\n', '\n', '   /**\n', '    * Enable the legal entity to change the account\n', '    * @param rs account that can be changed.\n', '    */\n', '    function enableChangeAccount (address rs) public {\n', '        require(isResponsibleForRegistryValidation(msg.sender), "Somente o responsável pela validação pode habilitar a troca de conta");\n', '        legalEntitiesChangeAccount[rs] = true;\n', '    }\n', '\n', '    function isChangeAccountEnabled (address rs) view public returns (bool) {\n', '        return legalEntitiesChangeAccount[rs] == true;\n', '    }    \n', '\n', '    function isTokenAddress() public view returns (bool) {\n', '        return tokenAddress == msg.sender;\n', '    } \n', '    function isResponsibleForSettlement(address addr) view public returns (bool) {\n', '        return (addr == responsibleForSettlement);\n', '    }\n', '    function isResponsibleForRegistryValidation(address addr) view public returns (bool) {\n', '        return (addr == responsibleForRegistryValidation);\n', '    }\n', '    function isResponsibleForDisbursement(address addr) view public returns (bool) {\n', '        return (addr == responsibleForDisbursement);\n', '    }\n', '    function isRedemptionAddress(address addr) view public returns (bool) {\n', '        return (addr == redemptionAddress);\n', '    }\n', '\n', '    function isReservedAccount(address addr) view public returns (bool) {\n', '\n', '        if (isOwner(addr) || isResponsibleForSettlement(addr) \n', '                           || isResponsibleForRegistryValidation(addr)\n', '                           || isResponsibleForDisbursement(addr)\n', '                           || isRedemptionAddress(addr) ) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isOwner(address addr) view public returns (bool) {\n', '        return owner()==addr;\n', '    }\n', '\n', '    function isSupplier(address addr) view public returns (bool) {\n', '\n', '        if (isReservedAccount(addr))\n', '            return false;\n', '\n', '        if (isAvailableAccount(addr))\n', '            return false;\n', '\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement == 0;\n', '    }\n', '\n', '    function isValidatedSupplier (address addr) view public returns (bool) {\n', '        return isSupplier(addr) && (legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED);\n', '    }\n', '\n', '    function isClient (address addr) view public returns (bool) {\n', '        if (isReservedAccount(addr)) {\n', '            return false;\n', '        }\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement != 0;\n', '    }\n', '\n', '    function isValidatedClient (address addr) view public returns (bool) {\n', '        return isClient(addr) && (legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED);\n', '    }\n', '\n', '    function isAvailableAccount(address addr) view public returns (bool) {\n', '        if ( isReservedAccount(addr) ) {\n', '            return false;\n', '        } \n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.AVAILABLE;\n', '    }\n', '\n', '    function isWaitingValidationAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.WAITING_VALIDATION;\n', '    }\n', '\n', '    function isValidatedAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.VALIDATED;\n', '    }\n', '\n', '    function isInvalidatedByValidatorAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.INVALIDATED_BY_VALIDATOR;\n', '    }\n', '\n', '    function isInvalidatedByChangeAccount(address addr) view public returns (bool) {\n', '        return legalEntitiesInfo[addr].state == BlockchainAccountState.INVALIDATED_BY_CHANGE;\n', '    }\n', '\n', '    function getResponsibleForSettlement() view public returns (address) {\n', '        return responsibleForSettlement;\n', '    }\n', '    function getResponsibleForRegistryValidation() view public returns (address) {\n', '        return responsibleForRegistryValidation;\n', '    }\n', '    function getResponsibleForDisbursement() view public returns (address) {\n', '        return responsibleForDisbursement;\n', '    }\n', '    function getRedemptionAddress() view public returns (address) {\n', '        return redemptionAddress;\n', '    }\n', '    function getCNPJ(address addr) view public returns (uint64) {\n', '        return legalEntitiesInfo[addr].cnpj;\n', '    }\n', '\n', '    function getIdLegalFinancialAgreement(address addr) view public returns (uint64) {\n', '        return legalEntitiesInfo[addr].idFinancialSupportAgreement;\n', '    }\n', '\n', '    function getLegalEntityInfo (address addr) view public returns (uint64, uint64, uint32, string memory, uint, address) {\n', '        return (legalEntitiesInfo[addr].cnpj, legalEntitiesInfo[addr].idFinancialSupportAgreement, \n', '             legalEntitiesInfo[addr].salic, legalEntitiesInfo[addr].idProofHash, (uint) (legalEntitiesInfo[addr].state),\n', '             addr);\n', '    }\n', '\n', '    function getBlockchainAccount(uint64 cnpj, uint64 idFinancialSupportAgreement) view public returns (address) {\n', '        return cnpjFSAddr[cnpj][idFinancialSupportAgreement];\n', '    }\n', '\n', '    function getLegalEntityInfoByCNPJ (uint64 cnpj, uint64 idFinancialSupportAgreement) \n', '        view public returns (uint64, uint64, uint32, string memory, uint, address) {\n', '        \n', '        address addr = getBlockchainAccount(cnpj,idFinancialSupportAgreement);\n', '        return getLegalEntityInfo (addr);\n', '    }\n', '\n', '    function getAccountState(address addr) view public returns (int) {\n', '\n', '        if ( isReservedAccount(addr) ) {\n', '            return 100;\n', '        } \n', '        else {\n', '            return ((int) (legalEntitiesInfo[addr].state));\n', '        }\n', '\n', '    }\n', '\n', '\n', '  function isValidHash(string memory str) pure public returns (bool)  {\n', '\n', '    bytes memory b = bytes(str);\n', '    if(b.length != 64) return false;\n', '\n', '    for (uint i=0; i<64; i++) {\n', '        if (b[i] < "0") return false;\n', '        if (b[i] > "9" && b[i] <"a") return false;\n', '        if (b[i] > "f") return false;\n', '    }\n', '        \n', '    return true;\n', ' }\n', '\n', '\n', '}\n', '\n', '\n', 'contract BNDESToken is ERC20Pausable, ERC20Detailed("BNDESToken", "BND", 2) {\n', '\n', '    uint private version = 20190517;\n', '\n', '    BNDESRegistry registry;\n', '\n', '    event BNDESTokenDisbursement(uint64 cnpj, uint64 idFinancialSupportAgreement, uint256 value);\n', '    event BNDESTokenTransfer(uint64 fromCnpj, uint64 fromIdFinancialSupportAgreement, uint64 toCnpj, uint256 value);\n', '    event BNDESTokenRedemption(uint64 cnpj, uint256 value);\n', '    event BNDESTokenRedemptionSettlement(string redemptionTransactionHash, string receiptHash);\n', '    event BNDESManualIntervention(string description);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    constructor (address newRegistryAddr) public {\n', '        registry = BNDESRegistry(newRegistryAddr);\n', '    }\n', '\n', '\n', '    function getVersion() view public returns (uint) {\n', '        return version;\n', '    }\n', '\n', '\n', '   /**\n', '    * The transfer funcion follows ERC20 token signature. \n', '    * Using them, it is possible to disburse money to the client, transfer from client to supplier and redeem.\n', '    * @param to the Ethereum address to where the money should be sent\n', '    * @param value how much BNDESToken the supplier wants to redeem\n', '    */\n', '    function transfer (address to, uint256 value) public whenNotPaused returns (bool) {\n', '\n', '        address from = msg.sender;\n', '\n', '        require(from != to, "Não pode transferir token para si mesmo");\n', '\n', '        if (registry.isResponsibleForDisbursement(from)) {\n', '\n', '            require(registry.isValidatedClient(to), "O endereço não pertence a um cliente ou não está validada");\n', '\n', '            _mint(to, value);\n', '\n', '            emit BNDESTokenDisbursement(registry.getCNPJ(to), registry.getIdLegalFinancialAgreement(to), value);\n', '\n', '        } else { \n', '\n', '            if (registry.isRedemptionAddress(to)) { \n', '\n', '                require(registry.isValidatedSupplier(from), "A conta do endereço não pertence a um fornecedor ou não está validada");\n', '\n', '                _burn(from, value);\n', '\n', '                emit BNDESTokenRedemption(registry.getCNPJ(from), value);\n', '\n', '            } else {\n', '\n', '                // Se nem from nem to são o Banco, eh transferencia normal\n', '\n', '                require(registry.isValidatedClient(from), "O endereço não pertence a um cliente ou não está validada");\n', '                require(registry.isValidatedSupplier(to), "A conta do endereço não pertence a um fornecedor ou não está validada");\n', '\n', '                _transfer(msg.sender, to, value);\n', '\n', '                emit BNDESTokenTransfer(registry.getCNPJ(from), registry.getIdLegalFinancialAgreement(from), \n', '                                registry.getCNPJ(to), value);\n', '  \n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    * When redeeming, the supplier indicated to the Resposible for Settlement that he wants to receive \n', '    * the FIAT money.\n', '    * @param value - how much BNDESToken the supplier wants to redeem\n', '    */\n', '    function redeem (uint256 value) public whenNotPaused returns (bool) {\n', '        return transfer(registry.getRedemptionAddress(), value);\n', '    }\n', '\n', '   /**\n', '    * Using this function, the Responsible for Settlement indicates that he has made the FIAT money transfer.\n', '    * @param redemptionTransactionHash hash of the redeem transaction in which the FIAT money settlement occurred.\n', '    * @param receiptHash hash that proof the FIAT money transfer\n', '    */\n', '    function notifyRedemptionSettlement(string memory redemptionTransactionHash, string memory receiptHash) \n', '        public whenNotPaused {\n', '        require (registry.isResponsibleForSettlement(msg.sender), "A liquidação só não pode ser realizada pelo endereço que submeteu a transação"); \n', '        require (registry.isValidHash(receiptHash), "O hash do recibo é inválido");\n', '        emit BNDESTokenRedemptionSettlement(redemptionTransactionHash, receiptHash);\n', '    }\n', '\n', '\n', '    function registryLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string memory idProofHash) \n', '        public whenNotPaused { \n', '        registry.registryLegalEntity(cnpj,  idFinancialSupportAgreement, salic, msg.sender, idProofHash);\n', '    }\n', '\n', '   /**\n', '    * Changes the original link between CNPJ and Ethereum account. \n', '    * The new link still needs to be validated by BNDES.\n', '    * IMPORTANT: The BNDESTOKENs are transfered from the original to the new Ethereum address \n', '    * @param cnpj Brazilian identifier to legal entities\n', '    * @param idFinancialSupportAgreement contract number of financial contract with BNDES. It assumes 0 if it is a supplier.\n', '    * @param salic contract number of financial contract with ANCINE. It assumes 0 if it is a supplier.\n', '    * @param idProofHash The legal entities have to send BNDES a PDF where it assumes as responsible for an Ethereum account. \n', '    *                   This PDF is signed with eCNPJ and send to BNDES. \n', '    */\n', '    function changeAccountLegalEntity(uint64 cnpj, uint64 idFinancialSupportAgreement, uint32 salic, string memory idProofHash) \n', '        public whenNotPaused {\n', '        \n', '        address oldAddr = registry.getBlockchainAccount(cnpj, idFinancialSupportAgreement);\n', '        address newAddr = msg.sender;\n', '        \n', '        registry.changeAccountLegalEntity(cnpj, idFinancialSupportAgreement, salic, msg.sender, idProofHash);\n', '\n', '        // Se há saldo no enderecoAntigo, precisa transferir\n', '        if (balanceOf(oldAddr) > 0) {\n', '            _transfer(oldAddr, newAddr, balanceOf(oldAddr));\n', '        }\n', '\n', '    }\n', '\n', '    //These methods may be necessary to solve incidents.\n', '    function burn(address from, uint256 value, string memory description) public onlyOwner {\n', '        _burn(from, value);\n', '        emit BNDESManualIntervention(description);        \n', '    }\n', '\n', '    //These methods may be necessary to solve incidents.\n', '    function mint(address to, uint256 value, string memory description) public onlyOwner {\n', '        _mint(to, value);\n', '        emit BNDESManualIntervention(description);        \n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return registry.owner() == msg.sender;\n', '    } \n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '        require(false, "Unsupported method - transferFrom");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '        require(false, "Unsupported method - approve");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n', '        require(false, "Unsupported method - increaseAllowance");\n', '    }\n', '\n', '    //Unsupported methods - created to avoid call the lib functions by overriding them\n', '    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n', '        require(false, "Unsupported method - decreaseAllowance");\n', '    }\n', '\n', '\n', '\n', '}']
