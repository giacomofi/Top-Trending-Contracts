['pragma solidity ^0.4.24;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'interface tokenRecipient {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function receiveApproval(address _from, uint _value, address _token, bytes _extraData) external;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'contract owned {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'address public owner;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'address public newOwner;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'event OwnershipTransferred(address indexed _from, address indexed _to);\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'constructor() owned() public {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'owner = msg.sender;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'modifier onlyOwner {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(msg.sender == owner);\t\t\t\t\t\n', '\t\t\t\t\t\n', '_;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function transferOwnership(address _newOwner) onlyOwner public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'newOwner = _newOwner;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function acceptOwnership() public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(msg.sender == newOwner);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'owner = newOwner;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'emit OwnershipTransferred(owner, newOwner);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'newOwner = address(0);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'contract TokenERC20 is owned {\t\t\t\t\t\n', '\t\t\t\t\t\n', "string public name = 'Super28coin';\t\t\t\t\t\n", '\t\t\t\t\t\n', "string public symbol = '28T';\t\t\t\t\t\n", '\t\t\t\t\t\n', 'uint8 public decimals = 8;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'uint public totalSupply = 120000000000000;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'mapping (address => uint) public balanceOf;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'mapping (address => mapping (address => uint)) public allowance;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'mapping (address => bool) public frozenAccount;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'event Transfer(address indexed from, address indexed to, uint value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'event Approval(address indexed _owner, address indexed _spender, uint _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'event FrozenFunds(address indexed target, bool frozen);\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'constructor() TokenERC20() public {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'balanceOf[msg.sender] = totalSupply;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function _transfer(address _from, address _to, uint _value) internal {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(_to != 0x0);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(balanceOf[_from] >= _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(balanceOf[_to] + _value > balanceOf[_to]);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(!frozenAccount[msg.sender]);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(!frozenAccount[_from]);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(!frozenAccount[_to]);\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'uint previousBalances = balanceOf[_from] + balanceOf[_to];\t\t\t\t\t\n', '\t\t\t\t\t\n', 'balanceOf[_from] -= _value;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'balanceOf[_to] += _value;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'emit Transfer(_from, _to, _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function _multipleTransfer(address _from, address[] addresses, uint[] amounts) internal {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'for (uint i=0; i<addresses.length; i++) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'address _to = addresses[i];\t\t\t\t\t\n', '\t\t\t\t\t\n', 'uint _value = amounts[i];\t\t\t\t\t\n', '\t\t\t\t\t\n', '_transfer(_from, _to, _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function transfer(address _to, uint _value) public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', '_transfer(msg.sender, _to, _value);\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'require(allowance[_from][msg.sender] >= _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'allowance[_from][msg.sender] -= _value;\t\t\t\t\t\n', '\t\t\t\t\t\n', '_transfer(_from, _to, _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'tokenRecipient spender = tokenRecipient(_spender);\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', 'spender.receiveApproval(msg.sender, _value, this, _extraData);\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\n', '\t\t\t\t\t\n', 'function approve(address _spender, uint _value) public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'allowance[msg.sender][_spender] = _value;\t\t\t\t\t\n', '\t\t\t\t\t\n', 'emit Approval(msg.sender, _spender, _value);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\t\t\n', '\n', '\n', '\t\t\t\t\t\n', 'function freezeAccount(address target, bool freeze) onlyOwner public returns (bool success) {\t\t\t\t\t\n', '\t\t\t\t\t\n', 'frozenAccount[target] = freeze;\t\t\t\t\t\n', 'emit FrozenFunds(target, freeze);\t\t\t\t\t\n', '\t\t\t\t\t\n', 'return true;\t\t\t\t\t\n', '\t\t\t\t\t\n', '}\t\t\t\t\t\n', '\t\t\t\t\t\n', '}']