['/**\n', ' *Submitted for verification at Etherscan.io on 2019-06-19\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  \n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  \n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', ' \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract NewEscrow is Ownable {\n', '\n', '    enum OrderStatus { Pending, Completed, Refunded, Disputed }\n', '\n', '    event PaymentCreation(uint indexed orderId, address indexed customer, uint value);\n', '    event PaymentCompletion(uint indexed orderId, address indexed customer, uint value, OrderStatus status);\n', '    \n', '    uint orderCount;\n', '    \n', '    struct Order {\n', '        uint orderId;\n', '        address customer;\n', '        uint value;\n', '        OrderStatus status;\n', '        uint quantity;\n', '        uint itemId;\n', '        address disputeCreatedBy;\n', '        bool paymentStatus;\n', '        bool paymentMade;\n', '        \n', '    }\n', '    \n', '    struct Item {\n', '        uint quantity;\n', '        string name;\n', '        uint price;\n', '    }\n', '    \n', '    mapping(uint => Item) public items;\n', '    mapping(uint => Order) public orders;\n', '    \n', '    address public admin;\n', '    address public seller;    \n', '    \n', '    modifier onlyDisputed(uint256 _orderID) {\n', '        require(orders[_orderID].status != OrderStatus.Disputed);\n', '        _;\n', '    }\n', '    \n', '    modifier onlySeller() {\n', '        require(msg.sender == seller);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDisputeEnder(uint256 _orderID,address _caller) {\n', '        require(_caller == admin || _caller == orders[_orderID].disputeCreatedBy);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDisputeCreater(uint256 _orderID,address _caller) {\n', '        require(_caller == seller || _caller == orders[_orderID].customer);\n', '        _;\n', '    }\n', '    \n', '     modifier onlyAdminOrBuyer(uint256 _orderID, address _caller) {\n', '        require( _caller == admin || _caller == orders[_orderID].customer);\n', '        _;\n', '    }\n', '    \n', '     modifier onlyBuyer(uint256 _orderID, address _caller) {\n', '        require(_caller == orders[_orderID].customer);\n', '        _;\n', '    }\n', '    \n', '    \n', '    modifier onlyAdminOrSeller(address _caller) {\n', '        require(_caller == admin || _caller == seller);\n', '        _;\n', '    }\n', '    \n', '    constructor (address _seller) public {\n', '        admin = 0x382468fb5070Ae19e9D82ec388e79AE4e43d890D;\n', '        seller = _seller;\n', '        orderCount = 1;\n', '    }\n', '    \n', '    function buyProduct(uint _itemId, uint _itemQuantity) public payable {\n', '        require(msg.value > 0);\n', '        require(msg.value == (items[_itemId].price * _itemQuantity));\n', '        require(!orders[orderCount].paymentMade);\n', '        require(msg.sender != seller && msg.sender != admin);\n', '        orders[orderCount].paymentMade = true;\n', '        createPayment(_itemId, msg.sender, _itemQuantity);\n', '    }\n', '    \n', '    function createPayment(uint _itemId, address _customer, uint _itemQuantity) internal {\n', '       \n', '        require(items[_itemId].quantity >= _itemQuantity);\n', '    \n', '        orders[orderCount].orderId = orderCount;\n', '        \n', '        items[_itemId].quantity = items[_itemId].quantity - _itemQuantity;\n', '        \n', '        uint totalPrice = _itemQuantity * items[_itemId].price;\n', '        \n', '        orders[orderCount].value = totalPrice;\n', '        orders[orderCount].quantity = _itemQuantity;\n', '        orders[orderCount].customer = _customer;\n', '        orders[orderCount].itemId = _itemId;\n', '        orders[orderCount].status = OrderStatus.Pending;\n', '        \n', '        emit PaymentCreation(orderCount, _customer, totalPrice);\n', '        orderCount = orderCount + 1;\n', '    }\n', '    \n', '    function addItem(uint _itemId, string _itemName, uint _quantity, uint _price) external onlySeller  {\n', '\n', '        items[_itemId].name = _itemName;\n', '        items[_itemId].quantity = _quantity;\n', '        items[_itemId].price = _price;\n', '    }\n', '    \n', '    \n', '    function release(uint _orderId) public onlyDisputed(_orderId) onlyAdminOrBuyer(_orderId,msg.sender) {\n', '    \n', '        completePayment(_orderId, seller, OrderStatus.Completed);\n', '        \n', '    }\n', '    \n', '    function refund(uint _orderId, uint _itemId) public onlyDisputed(_orderId) onlyAdminOrSeller(msg.sender){\n', '        \n', '        items[_itemId].quantity = items[_itemId].quantity + orders[_orderId].quantity;\n', '        \n', '        incompletePayment(_orderId, orders[_orderId].customer, OrderStatus.Refunded);\n', '    }\n', '\n', '\n', '    function completePayment(uint _orderId, address _receiver, OrderStatus _status) private {\n', '        require(orders[_orderId].paymentStatus != true);\n', '        \n', '        Order storage payment = orders[_orderId];\n', '     \n', '        uint adminSupply = SafeMath.div(SafeMath.mul(orders[_orderId].value, 7), 100);\n', '        \n', '        uint sellerSupply = SafeMath.div(SafeMath.mul(orders[_orderId].value, 93), 100);\n', '        \n', '        _receiver.transfer(sellerSupply);\n', '        \n', '        admin.transfer(adminSupply);\n', '        \n', '        orders[_orderId].status = _status;\n', '        \n', '        orders[_orderId].paymentStatus = true;\n', '        \n', '        emit PaymentCompletion(_orderId, _receiver, payment.value, _status);\n', '    }\n', '    \n', '    function incompletePayment(uint _orderId, address _receiver, OrderStatus _status) private {\n', '        require(orders[_orderId].paymentStatus != true);                        \n', '        \n', '        Order storage payment = orders[_orderId];\n', '        \n', '        _receiver.transfer(orders[_orderId].value);\n', '       \n', '        orders[_orderId].status = _status;\n', '        \n', '        orders[_orderId].paymentStatus = true;\n', '        \n', '        emit PaymentCompletion(_orderId, _receiver, payment.value, _status);\n', '    }\n', '    \n', '     function openDispute (uint256 _orderID) external onlyDisputeCreater(_orderID,msg.sender){ \n', '        orders[_orderID].status = OrderStatus.Disputed;\n', '        orders[_orderID].disputeCreatedBy = msg.sender;\n', '    }\n', '    \n', '    function closeDispute (uint256 _orderID,uint256 _itemId, address _paymentSendTo) external onlyDisputeEnder(_orderID,msg.sender){\n', '        if (msg.sender == admin)\n', '        {\n', '            if (_paymentSendTo == orders[_orderID].customer)\n', '            {\n', '                orders[_orderID].status = OrderStatus.Refunded;\n', '                refund(_orderID, _itemId);\n', '            }\n', '            else if (_paymentSendTo == seller)\n', '            {\n', '                orders[_orderID].status = OrderStatus.Completed;\n', '                release(_orderID);\n', '            }\n', '        }\n', '        else if (msg.sender == orders[_orderID].customer)\n', '        {\n', '            orders[_orderID].status = OrderStatus.Completed;\n', '            release(_orderID);\n', '        }\n', '        else if (msg.sender == seller)\n', '        {\n', '            orders[_orderID].status = OrderStatus.Refunded;\n', '            refund(_orderID, _itemId);\n', '        }\n', '    }\n', '\n', '}']