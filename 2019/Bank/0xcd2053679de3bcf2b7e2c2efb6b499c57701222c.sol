['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-10\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address payable public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address payable _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address payable _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'library ERC20SafeTransfer {\n', '    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("transfer(address,uint256)", _to, _value));\n', '        require(success, "Transfer failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("transferFrom(address,address,uint256)", _from, _to, _value));\n', '        require(success, "Transfer From failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("approve(address,uint256)", _spender, _value));\n', '        require(success,  "Approve failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function fetchReturnData() internal pure returns (bool success){\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 {\n', '                success := 1\n', '            }\n', '            case 32 {\n', '                returndatacopy(0, 0, 32)\n', '                success := mload(0)\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title A contract which allows its owner to withdraw any ether which is contained inside\n', 'contract Withdrawable is Ownable {\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _token The address of the token that the user wants to withdraw\n', '    /// @param _amount The amount of tokens that the caller wants to withdraw\n', '    /// @return bool value indicating whether the transfer was successful\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\n', '        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\n', '    }\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _amount The amount of ether that the caller wants to withdraw\n', '    function withdrawETH(uint256 _amount) external onlyOwner {\n', '        owner.transfer(_amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function decimals() public view returns (uint256);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/lib/TokenTransferProxy.sol\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="03626e6a7143337b53716c696660772d606c6e">[email&#160;protected]</a>>, Will Warren - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2e594742426e1e567e5c41444b4d5a004d4143">[email&#160;protected]</a>>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        emit LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        emit LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        require(ERC20SafeTransfer.safeTransferFrom(token, from, to, value));\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public view functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool private _paused = false;\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "Contract is paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "Contract not paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    _paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    _paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', '/*\n', '    Modified Util contract as used by Kyber Network\n', '*/\n', '\n', 'library Utils {\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\n', '    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '    uint256 constant internal MAX_UINT = 2**256-1;\n', '    address constant internal ETH_ADDRESS = address(0x0);\n', '\n', '    // Currently constants can&#39;t be accessed from other contracts, so providing functions to do that here\n', '    function precision() internal pure returns (uint256) { return PRECISION; }\n', '    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\n', '    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\n', '    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\n', '    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\n', '    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\n', '    function eth_address() internal pure returns (address) { return ETH_ADDRESS; }\n', '\n', '    /// @notice Retrieve the number of decimals used for a given ERC20 token\n', '    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\n', '    /// ensure that an exception doesn&#39;t cause transaction failure\n', '    /// @param token the token for which we should retrieve the decimals\n', '    /// @return decimals the number of decimals in the given token\n', '    function getDecimals(address token)\n', '        internal\n', '        returns (uint256 decimals)\n', '    {\n', '        bytes4 functionSig = bytes4(keccak256("decimals()"));\n', '\n', '        /// @dev Using assembly due to issues with current solidity `address.call()`\n', '        /// implementation: https://github.com/ethereum/solidity/issues/2884\n', '        assembly {\n', '            // Pointer to next free memory slot\n', '            let ptr := mload(0x40)\n', '            // Store functionSig variable at ptr\n', '            mstore(ptr,functionSig)\n', '            let functionSigLength := 0x04\n', '            let wordLength := 0x20\n', '\n', '            let success := call(\n', '                                5000, // Amount of gas\n', '                                token, // Address to call\n', '                                0, // ether to send\n', '                                ptr, // ptr to input data\n', '                                functionSigLength, // size of data\n', '                                ptr, // where to store output data (overwrite input)\n', '                                wordLength // size of output data (32 bytes)\n', '                               )\n', '\n', '            switch success\n', '            case 0 {\n', '                decimals := 0 // If the token doesn&#39;t implement `decimals()`, return 0 as default\n', '            }\n', '            case 1 {\n', '                decimals := mload(ptr) // Set decimals to return data from call\n', '            }\n', '            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\n', '        }\n', '    }\n', '\n', '    /// @dev Checks that a given address has its token allowance and balance set above the given amount\n', '    /// @param tokenOwner the address which should have custody of the token\n', '    /// @param tokenAddress the address of the token to check\n', '    /// @param tokenAmount the amount of the token which should be set\n', '    /// @param addressToAllow the address which should be allowed to transfer the token\n', '    /// @return bool true if the allowance and balance is set, false if not\n', '    function tokenAllowanceAndBalanceSet(\n', '        address tokenOwner,\n', '        address tokenAddress,\n', '        uint256 tokenAmount,\n', '        address addressToAllow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\n', '            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\n', '        );\n', '    }\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint numerator;\n', '        uint denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal returns (uint) {\n', '        return calcDstQty(srcAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\n', '    }\n', '\n', '    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal returns (uint) {\n', '        return calcSrcQty(destAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\n', '    }\n', '\n', '    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n', '        internal pure returns (uint)\n', '    {\n', '        require(srcAmount <= MAX_QTY);\n', '        require(destAmount <= MAX_QTY);\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n', '        }\n', '    }\n', '\n', '    /// @notice Bringing this in from the Math library as we&#39;ve run out of space in TotlePrimary (see EIP-170)\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract Partner {\n', '\n', '    address payable public partnerBeneficiary;\n', '    uint256 public partnerPercentage; //This is out of 1 ETH, e.g. 0.5 ETH is 50% of the fee\n', '\n', '    uint256 public companyPercentage;\n', '    address payable public companyBeneficiary;\n', '\n', '    event LogPayout(\n', '        address[] tokens,\n', '        uint256[] amount\n', '    );\n', '\n', '    function init(\n', '        address payable _companyBeneficiary,\n', '        uint256 _companyPercentage,\n', '        address payable _partnerBeneficiary,\n', '        uint256 _partnerPercentage\n', '    ) public {\n', '        require(companyBeneficiary == address(0x0) && partnerBeneficiary == address(0x0));\n', '        companyBeneficiary = _companyBeneficiary;\n', '        companyPercentage = _companyPercentage;\n', '        partnerBeneficiary = _partnerBeneficiary;\n', '        partnerPercentage = _partnerPercentage;\n', '    }\n', '\n', '    function payout(\n', '        address[] memory tokens,\n', '        uint256[] memory amounts\n', '    ) public {\n', '        // Payout both the partner and the company at the same time\n', '        for(uint256 index = 0; index<tokens.length; index++){\n', '            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n', '            uint256 companyAmount = amounts[index] - partnerAmount;\n', '            if(tokens[index] == Utils.eth_address()){\n', '                partnerBeneficiary.transfer(partnerAmount);\n', '                companyBeneficiary.transfer(companyAmount);\n', '            } else {\n', '                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n', '                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n', '            }\n', '        }\n', '\temit LogPayout(tokens,amounts);\n', '    }\n', '\n', '    function getTotalFeePercentage() public view returns (uint256){\n', '        return partnerPercentage + companyPercentage;\n', '    }\n', '\n', '    function() external payable {\n', '\n', '    }\n', '}\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'contract ExchangeHandler is Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    /* Logger public logger; */\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    function performOrder(\n', '        bytes memory genericPayload,\n', '        uint256 availableToSpend,\n', '        uint256 targetAmount,\n', '        bool targetAmountIsSource\n', '    )\n', '        public\n', '        payable\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder);\n', '\n', '}\n', '\n', '/// @title The primary contract for Totle\n', 'contract TotlePrimary is Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    TokenTransferProxy public tokenTransferProxy;\n', '    mapping(address => bool) public signers;\n', '    /* Logger public logger; */\n', '\n', '    /*\n', '    *   Types\n', '    */\n', '\n', '    // Structs\n', '    struct Order {\n', '        address payable exchangeHandler;\n', '        bytes encodedPayload;\n', '    }\n', '\n', '    struct Trade {\n', '        address sourceToken;\n', '        address destinationToken;\n', '        uint256 amount;\n', '        bool isSourceAmount; //true if amount is sourceToken, false if it&#39;s destinationToken\n', '        Order[] orders;\n', '    }\n', '\n', '    struct Swap {\n', '        Trade[] trades;\n', '        uint256 minimumExchangeRate;\n', '        uint256 minimumDestinationAmount;\n', '        uint256 sourceAmount;\n', '        uint256 tradeToTakeFeeFrom;\n', '        bool takeFeeFromSource; //Takes the fee before the trade if true, takes it after if false\n', '        address payable redirectAddress;\n', '        bool required;\n', '    }\n', '\n', '    struct SwapCollection {\n', '        Swap[] swaps;\n', '        address payable partnerContract;\n', '        uint256 expirationBlock;\n', '        bytes32 id;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    struct TokenBalance {\n', '        address tokenAddress;\n', '        uint256 balance;\n', '    }\n', '\n', '    struct FeeVariables {\n', '        uint256 feePercentage;\n', '        Partner partner;\n', '        uint256 totalFee;\n', '    }\n', '\n', '    struct AmountsSpentReceived{\n', '        uint256 spent;\n', '        uint256 received;\n', '    }\n', '    /*\n', '    *   Events\n', '    */\n', '\n', '    event LogSwapCollection(\n', '        bytes32 indexed id,\n', '        address indexed partnerContract,\n', '        address indexed user\n', '    );\n', '\n', '    event LogSwap(\n', '        bytes32 indexed id,\n', '        address sourceAsset,\n', '        address destinationAsset,\n', '        uint256 sourceAmount,\n', '        uint256 destinationAmount,\n', '        address feeAsset,\n', '        uint256 feeAmount\n', '    );\n', '\n', '    /// @notice Constructor\n', '    /// @param _tokenTransferProxy address of the TokenTransferProxy\n', '    /// @param _signer the suggester&#39;s address that signs the payloads. More can be added with add/removeSigner functions\n', '    constructor (address _tokenTransferProxy, address _signer/*, address _logger*/) public {\n', '        tokenTransferProxy = TokenTransferProxy(_tokenTransferProxy);\n', '        signers[_signer] = true;\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    modifier notExpired(SwapCollection memory swaps) {\n', '        require(swaps.expirationBlock > block.number, "Expired");\n', '        _;\n', '    }\n', '\n', '    modifier validSignature(SwapCollection memory swaps){\n', '        bytes32 hash = keccak256(abi.encode(swaps.swaps, swaps.partnerContract, swaps.expirationBlock, swaps.id, msg.sender));\n', '        require(signers[ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), swaps.v, swaps.r, swaps.s)], "Invalid signature");\n', '        _;\n', '    }\n', '\n', '    /// @notice Performs the requested set of swaps\n', '    /// @param swaps The struct that defines the collection of swaps to perform\n', '    function performSwapCollection(\n', '        SwapCollection memory swaps\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        notExpired(swaps)\n', '        validSignature(swaps)\n', '    {\n', '        TokenBalance[20] memory balances;\n', '        balances[0] = TokenBalance(address(Utils.eth_address()), msg.value);\n', '        this.log("Created eth balance", balances[0].balance, 0x0);\n', '        for(uint256 swapIndex = 0; swapIndex < swaps.swaps.length; swapIndex++){\n', '            this.log("About to perform swap", swapIndex, swaps.id);\n', '            performSwap(swaps.id, swaps.swaps[swapIndex], balances, swaps.partnerContract);\n', '        }\n', '        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n', '        transferAllTokensToUser(balances);\n', '    }\n', '\n', '    function addSigner(address newSigner) public onlyOwner {\n', '         signers[newSigner] = true;\n', '    }\n', '\n', '    function removeSigner(address signer) public onlyOwner {\n', '         signers[signer] = false;\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '\n', '    function performSwap(\n', '        bytes32 swapCollectionId,\n', '        Swap memory swap,\n', '        TokenBalance[20] memory balances,\n', '        address payable partnerContract\n', '    )\n', '        internal\n', '    {\n', '        if(!transferFromSenderDifference(balances, swap.trades[0].sourceToken, swap.sourceAmount)){\n', '            if(swap.required){\n', '                revert("Failed to get tokens for required swap");\n', '            } else {\n', '                return;\n', '            }\n', '        }\n', '        uint256 amountSpentFirstTrade = 0;\n', '        uint256 amountReceived = 0;\n', '        uint256 feeAmount = 0;\n', '        for(uint256 tradeIndex = 0; tradeIndex < swap.trades.length; tradeIndex++){\n', '            if(tradeIndex == swap.tradeToTakeFeeFrom && swap.takeFeeFromSource){\n', '                feeAmount = takeFee(balances, swap.trades[tradeIndex].sourceToken, partnerContract,tradeIndex==0 ? swap.sourceAmount : amountReceived);\n', '            }\n', '            uint256 tempSpent;\n', '            this.log("About to performTrade",0,0x0);\n', '            (tempSpent, amountReceived) = performTrade(\n', '                swap.trades[tradeIndex],\n', '                balances,\n', '                Utils.min(\n', '                    tradeIndex == 0 ? swap.sourceAmount : amountReceived,\n', '                    balances[findToken(balances, swap.trades[tradeIndex].sourceToken)].balance\n', '                )\n', '            );\n', '            if(!swap.trades[tradeIndex].isSourceAmount && amountReceived < swap.trades[tradeIndex].amount){\n', '                if(swap.required){\n', '                    revert("Not enough destination amount");\n', '                }\n', '                return;\n', '            }\n', '            if(tradeIndex == 0){\n', '                amountSpentFirstTrade = tempSpent;\n', '            }\n', '            if(tradeIndex == swap.tradeToTakeFeeFrom && !swap.takeFeeFromSource){\n', '                feeAmount = takeFee(balances, swap.trades[tradeIndex].destinationToken, partnerContract, amountReceived);\n', '            }\n', '        }\n', '        this.log("About to emit LogSwap", 0, 0x0);\n', '        emit LogSwap(\n', '            swapCollectionId,\n', '            swap.trades[0].sourceToken,\n', '            swap.trades[swap.trades.length-1].destinationToken,\n', '            amountSpentFirstTrade,\n', '            amountReceived,\n', '            swap.takeFeeFromSource?swap.trades[swap.tradeToTakeFeeFrom].sourceToken:swap.trades[swap.tradeToTakeFeeFrom].destinationToken,\n', '            feeAmount\n', '        );\n', '\n', '        if(amountReceived < swap.minimumDestinationAmount){\n', '            this.log("Minimum destination amount failed", 0, 0x0);\n', '            revert("Tokens got less than minimumDestinationAmount");\n', '        } else if (minimumRateFailed(swap.trades[0].sourceToken, swap.trades[swap.trades.length-1].destinationToken,swap.sourceAmount, amountReceived, swap.minimumExchangeRate)){\n', '            this.log("Minimum rate failed", 0, 0x0);\n', '            revert("Minimum exchange rate not met");\n', '        }\n', '        if(swap.redirectAddress != msg.sender && swap.redirectAddress != address(0x0)){\n', '            this.log("About to redirect tokens", amountReceived, 0x0);\n', '            uint256 destinationTokenIndex = findToken(balances,swap.trades[swap.trades.length-1].destinationToken);\n', '            uint256 amountToSend = Math.min(amountReceived, balances[destinationTokenIndex].balance);\n', '            transferTokens(balances, destinationTokenIndex, swap.redirectAddress, amountToSend);\n', '            removeBalance(balances, swap.trades[swap.trades.length-1].destinationToken, amountToSend);\n', '        }\n', '    }\n', '\n', '    function performTrade(\n', '        Trade memory trade, \n', '        TokenBalance[20] memory balances,\n', '        uint256 availableToSpend\n', '    ) \n', '        internal returns (uint256 totalSpent, uint256 totalReceived)\n', '    {\n', '        uint256 tempSpent = 0;\n', '        uint256 tempReceived = 0;\n', '        for(uint256 orderIndex = 0; orderIndex < trade.orders.length; orderIndex++){\n', '            if((availableToSpend - totalSpent) * 10000 < availableToSpend){\n', '                break;\n', '            } else if(!trade.isSourceAmount && tempReceived == trade.amount){\n', '                break;\n', '            } else if (trade.isSourceAmount && tempSpent == trade.amount){\n', '                break;\n', '            }\n', '            this.log("About to perform order", orderIndex,0x0);\n', '            (tempSpent, tempReceived) = performOrder(\n', '                trade.orders[orderIndex], \n', '                availableToSpend - totalSpent,\n', '                trade.isSourceAmount ? availableToSpend - totalSpent : trade.amount - totalReceived, \n', '                trade.isSourceAmount,\n', '                trade.sourceToken, \n', '                balances);\n', '            this.log("Order performed",0,0x0);\n', '            totalSpent += tempSpent;\n', '            totalReceived += tempReceived;\n', '        }\n', '        addBalance(balances, trade.destinationToken, tempReceived);\n', '        removeBalance(balances, trade.sourceToken, tempSpent);\n', '        this.log("Trade performed",tempSpent, 0);\n', '    }\n', '\n', '    function performOrder(\n', '        Order memory order, \n', '        uint256 availableToSpend,\n', '        uint256 targetAmount,\n', '        bool isSourceAmount,\n', '        address tokenToSpend,\n', '        TokenBalance[20] memory balances\n', '    )\n', '        internal returns (uint256 spent, uint256 received)\n', '    {\n', '        this.log("Performing order", availableToSpend, 0x0);\n', '\n', '        if(tokenToSpend == Utils.eth_address()){\n', '            (spent, received) = ExchangeHandler(order.exchangeHandler).performOrder.value(availableToSpend)(order.encodedPayload, availableToSpend, targetAmount, isSourceAmount);\n', '\n', '        } else {\n', '            transferTokens(balances, findToken(balances, tokenToSpend), order.exchangeHandler, availableToSpend);\n', '            (spent, received) = ExchangeHandler(order.exchangeHandler).performOrder(order.encodedPayload, availableToSpend, targetAmount, isSourceAmount);\n', '        }\n', '        this.log("Performing order", spent,0x0);\n', '        this.log("Performing order", received,0x0);\n', '    }\n', '\n', '    function minimumRateFailed(\n', '        address sourceToken,\n', '        address destinationToken,\n', '        uint256 sourceAmount,\n', '        uint256 destinationAmount,\n', '        uint256 minimumExchangeRate\n', '    )\n', '        internal returns(bool failed)\n', '    {\n', '        this.log("About to get source decimals",sourceAmount,0x0);\n', '        uint256 sourceDecimals = sourceToken == Utils.eth_address() ? 18 : Utils.getDecimals(sourceToken);\n', '        this.log("About to get destination decimals",destinationAmount,0x0);\n', '        uint256 destinationDecimals = destinationToken == Utils.eth_address() ? 18 : Utils.getDecimals(destinationToken);\n', '        this.log("About to calculate amount got",0,0x0);\n', '        uint256 rateGot = Utils.calcRateFromQty(sourceAmount, destinationAmount, sourceDecimals, destinationDecimals);\n', '        this.log("Minimum rate failed", rateGot, 0x0);\n', '        return rateGot < minimumExchangeRate;\n', '    }\n', '\n', '    function takeFee(\n', '        TokenBalance[20] memory balances,\n', '        address token,\n', '        address payable partnerContract,\n', '        uint256 amountTraded\n', '    )\n', '        internal\n', '        returns (uint256 feeAmount)\n', '    {\n', '        Partner partner = Partner(partnerContract);\n', '        uint256 feePercentage = partner.getTotalFeePercentage();\n', '        this.log("Got fee percentage", feePercentage, 0x0);\n', '        feeAmount = calculateFee(amountTraded, feePercentage);\n', '        this.log("Taking fee", feeAmount, 0);\n', '        transferTokens(balances, findToken(balances, token), partnerContract, feeAmount);\n', '        removeBalance(balances, findToken(balances, token), feeAmount);\n', '        this.log("Took fee", 0, 0x0);\n', '        return feeAmount;\n', '    }\n', '\n', '    function transferFromSenderDifference(\n', '        TokenBalance[20] memory balances,\n', '        address token,\n', '        uint256 sourceAmount\n', '    )\n', '        internal returns (bool)\n', '    {\n', '        if(token == Utils.eth_address()){\n', '            if(sourceAmount>balances[0].balance){\n', '                this.log("Not enough eth", 0,0x0);\n', '                return false;\n', '            }\n', '            this.log("Enough eth", 0,0x0);\n', '            return true;\n', '        }\n', '\n', '        uint256 tokenIndex = findToken(balances, token);\n', '        if(sourceAmount>balances[tokenIndex].balance){\n', '            this.log("Transferring in token", 0,0x0);\n', '            bool success;\n', '            (success,) = address(tokenTransferProxy).call(abi.encodeWithSignature("transferFrom(address,address,address,uint256)", token, msg.sender, address(this), sourceAmount - balances[tokenIndex].balance));\n', '            if(success){\n', '                this.log("Got enough token", 0,0x0);\n', '                balances[tokenIndex].balance = sourceAmount;\n', '                return true;\n', '            }\n', '            this.log("Didn&#39;t get enough token", 0,0x0);\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferAllTokensToUser(\n', '        TokenBalance[20] memory balances\n', '    )\n', '        internal\n', '    {\n', '        this.log("About to transfer all tokens", 0, 0x0);\n', '        for(uint256 balanceIndex = 0; balanceIndex < balances.length; balanceIndex++){\n', '            if(balanceIndex != 0 && balances[balanceIndex].tokenAddress == address(0x0)){\n', '                return;\n', '            }\n', '            this.log("Transferring tokens", uint256(balances[balanceIndex].balance),0x0);\n', '            transferTokens(balances, balanceIndex, msg.sender, balances[balanceIndex].balance);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function transferTokens(\n', '        TokenBalance[20] memory balances,\n', '        uint256 tokenIndex,\n', '        address payable destination,\n', '        uint256 tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        if(tokenAmount > 0){\n', '            if(balances[tokenIndex].tokenAddress == Utils.eth_address()){\n', '                destination.transfer(tokenAmount);\n', '            } else {\n', '                ERC20SafeTransfer.safeTransfer(balances[tokenIndex].tokenAddress, destination, tokenAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function findToken(\n', '        TokenBalance[20] memory balances,\n', '        address token\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        for(uint256 index = 0; index < balances.length; index++){\n', '            if(balances[index].tokenAddress == token){\n', '                return index;\n', '            } else if (index != 0 && balances[index].tokenAddress == address(0x0)){\n', '                balances[index] = TokenBalance(token, 0);\n', '                return index;\n', '            }\n', '        }\n', '    }\n', '\n', '    function addBalance(\n', '        TokenBalance[20] memory balances,\n', '        address tokenAddress,\n', '        uint256 amountToAdd\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        uint256 tokenIndex = findToken(balances, tokenAddress);\n', '        addBalance(balances, tokenIndex, amountToAdd);\n', '    }\n', '\n', '    function addBalance(\n', '        TokenBalance[20] memory balances,\n', '        uint256 balanceIndex,\n', '        uint256 amountToAdd\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '       balances[balanceIndex].balance += amountToAdd;\n', '    }\n', '\n', '    function removeBalance(\n', '        TokenBalance[20] memory balances,\n', '        address tokenAddress,\n', '        uint256 amountToRemove\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        uint256 tokenIndex = findToken(balances, tokenAddress);\n', '        removeBalance(balances, tokenIndex, amountToRemove);\n', '    }\n', '\n', '    function removeBalance(\n', '        TokenBalance[20] memory balances,\n', '        uint256 balanceIndex,\n', '        uint256 amountToRemove\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        balances[balanceIndex].balance -= amountToRemove;\n', '    }\n', '\n', '    // @notice Calculates the fee amount given a fee percentage and amount\n', '    // @param amount the amount to calculate the fee based on\n', '    // @param fee the percentage, out of 1 eth (e.g. 0.01 ETH would be 1%)\n', '    function calculateFee(uint256 amount, uint256 fee) internal pure returns (uint256){\n', '        return SafeMath.div(SafeMath.mul(amount, fee), 1 ether);\n', '    }\n', '\n', '    /*\n', '    *   Payable fallback function\n', '    */\n', '\n', '    /// @notice payable fallback to allow handler or exchange contracts to return ether\n', '    /// @dev only accounts containing code (ie. contracts) can send ether to contract\n', '    function() external payable whenNotPaused {\n', '        // Check in here that the sender is a contract! (to stop accidents)\n', '        uint256 size;\n', '        address sender = msg.sender;\n', '        assembly {\n', '            size := extcodesize(sender)\n', '        }\n', '        if (size == 0) {\n', '            revert("EOA cannot send ether to primary fallback");\n', '        }\n', '    }\n', '    event Log(string a, uint256 b, bytes32 c);\n', '\n', '    function log(string memory a, uint256 b, bytes32 c) public {\n', '        emit Log(a,b,c);\n', '    }\n', '}']
['pragma solidity 0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address payable public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address payable _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address payable _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'library ERC20SafeTransfer {\n', '    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("transfer(address,uint256)", _to, _value));\n', '        require(success, "Transfer failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("transferFrom(address,address,uint256)", _from, _to, _value));\n', '        require(success, "Transfer From failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\n', '        (success,) = _tokenAddress.call(abi.encodeWithSignature("approve(address,uint256)", _spender, _value));\n', '        require(success,  "Approve failed");\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function fetchReturnData() internal pure returns (bool success){\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 {\n', '                success := 1\n', '            }\n', '            case 32 {\n', '                returndatacopy(0, 0, 32)\n', '                success := mload(0)\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title A contract which allows its owner to withdraw any ether which is contained inside\n', 'contract Withdrawable is Ownable {\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _token The address of the token that the user wants to withdraw\n', '    /// @param _amount The amount of tokens that the caller wants to withdraw\n', '    /// @return bool value indicating whether the transfer was successful\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\n', '        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\n', '    }\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _amount The amount of ether that the caller wants to withdraw\n', '    function withdrawETH(uint256 _amount) external onlyOwner {\n', '        owner.transfer(_amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function decimals() public view returns (uint256);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/lib/TokenTransferProxy.sol\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        emit LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        emit LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        require(ERC20SafeTransfer.safeTransferFrom(token, from, to, value));\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public view functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool private _paused = false;\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "Contract is paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "Contract not paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    _paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    _paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', '/*\n', '    Modified Util contract as used by Kyber Network\n', '*/\n', '\n', 'library Utils {\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\n', '    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '    uint256 constant internal MAX_UINT = 2**256-1;\n', '    address constant internal ETH_ADDRESS = address(0x0);\n', '\n', "    // Currently constants can't be accessed from other contracts, so providing functions to do that here\n", '    function precision() internal pure returns (uint256) { return PRECISION; }\n', '    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\n', '    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\n', '    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\n', '    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\n', '    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\n', '    function eth_address() internal pure returns (address) { return ETH_ADDRESS; }\n', '\n', '    /// @notice Retrieve the number of decimals used for a given ERC20 token\n', '    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\n', "    /// ensure that an exception doesn't cause transaction failure\n", '    /// @param token the token for which we should retrieve the decimals\n', '    /// @return decimals the number of decimals in the given token\n', '    function getDecimals(address token)\n', '        internal\n', '        returns (uint256 decimals)\n', '    {\n', '        bytes4 functionSig = bytes4(keccak256("decimals()"));\n', '\n', '        /// @dev Using assembly due to issues with current solidity `address.call()`\n', '        /// implementation: https://github.com/ethereum/solidity/issues/2884\n', '        assembly {\n', '            // Pointer to next free memory slot\n', '            let ptr := mload(0x40)\n', '            // Store functionSig variable at ptr\n', '            mstore(ptr,functionSig)\n', '            let functionSigLength := 0x04\n', '            let wordLength := 0x20\n', '\n', '            let success := call(\n', '                                5000, // Amount of gas\n', '                                token, // Address to call\n', '                                0, // ether to send\n', '                                ptr, // ptr to input data\n', '                                functionSigLength, // size of data\n', '                                ptr, // where to store output data (overwrite input)\n', '                                wordLength // size of output data (32 bytes)\n', '                               )\n', '\n', '            switch success\n', '            case 0 {\n', "                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\n", '            }\n', '            case 1 {\n', '                decimals := mload(ptr) // Set decimals to return data from call\n', '            }\n', '            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\n', '        }\n', '    }\n', '\n', '    /// @dev Checks that a given address has its token allowance and balance set above the given amount\n', '    /// @param tokenOwner the address which should have custody of the token\n', '    /// @param tokenAddress the address of the token to check\n', '    /// @param tokenAmount the amount of the token which should be set\n', '    /// @param addressToAllow the address which should be allowed to transfer the token\n', '    /// @return bool true if the allowance and balance is set, false if not\n', '    function tokenAllowanceAndBalanceSet(\n', '        address tokenOwner,\n', '        address tokenAddress,\n', '        uint256 tokenAmount,\n', '        address addressToAllow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\n', '            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\n', '        );\n', '    }\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint numerator;\n', '        uint denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal returns (uint) {\n', '        return calcDstQty(srcAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\n', '    }\n', '\n', '    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal returns (uint) {\n', '        return calcSrcQty(destAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\n', '    }\n', '\n', '    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n', '        internal pure returns (uint)\n', '    {\n', '        require(srcAmount <= MAX_QTY);\n', '        require(destAmount <= MAX_QTY);\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n', '        }\n', '    }\n', '\n', "    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\n", '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract Partner {\n', '\n', '    address payable public partnerBeneficiary;\n', '    uint256 public partnerPercentage; //This is out of 1 ETH, e.g. 0.5 ETH is 50% of the fee\n', '\n', '    uint256 public companyPercentage;\n', '    address payable public companyBeneficiary;\n', '\n', '    event LogPayout(\n', '        address[] tokens,\n', '        uint256[] amount\n', '    );\n', '\n', '    function init(\n', '        address payable _companyBeneficiary,\n', '        uint256 _companyPercentage,\n', '        address payable _partnerBeneficiary,\n', '        uint256 _partnerPercentage\n', '    ) public {\n', '        require(companyBeneficiary == address(0x0) && partnerBeneficiary == address(0x0));\n', '        companyBeneficiary = _companyBeneficiary;\n', '        companyPercentage = _companyPercentage;\n', '        partnerBeneficiary = _partnerBeneficiary;\n', '        partnerPercentage = _partnerPercentage;\n', '    }\n', '\n', '    function payout(\n', '        address[] memory tokens,\n', '        uint256[] memory amounts\n', '    ) public {\n', '        // Payout both the partner and the company at the same time\n', '        for(uint256 index = 0; index<tokens.length; index++){\n', '            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n', '            uint256 companyAmount = amounts[index] - partnerAmount;\n', '            if(tokens[index] == Utils.eth_address()){\n', '                partnerBeneficiary.transfer(partnerAmount);\n', '                companyBeneficiary.transfer(companyAmount);\n', '            } else {\n', '                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n', '                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n', '            }\n', '        }\n', '\temit LogPayout(tokens,amounts);\n', '    }\n', '\n', '    function getTotalFeePercentage() public view returns (uint256){\n', '        return partnerPercentage + companyPercentage;\n', '    }\n', '\n', '    function() external payable {\n', '\n', '    }\n', '}\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'contract ExchangeHandler is Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    /* Logger public logger; */\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    function performOrder(\n', '        bytes memory genericPayload,\n', '        uint256 availableToSpend,\n', '        uint256 targetAmount,\n', '        bool targetAmountIsSource\n', '    )\n', '        public\n', '        payable\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder);\n', '\n', '}\n', '\n', '/// @title The primary contract for Totle\n', 'contract TotlePrimary is Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    TokenTransferProxy public tokenTransferProxy;\n', '    mapping(address => bool) public signers;\n', '    /* Logger public logger; */\n', '\n', '    /*\n', '    *   Types\n', '    */\n', '\n', '    // Structs\n', '    struct Order {\n', '        address payable exchangeHandler;\n', '        bytes encodedPayload;\n', '    }\n', '\n', '    struct Trade {\n', '        address sourceToken;\n', '        address destinationToken;\n', '        uint256 amount;\n', "        bool isSourceAmount; //true if amount is sourceToken, false if it's destinationToken\n", '        Order[] orders;\n', '    }\n', '\n', '    struct Swap {\n', '        Trade[] trades;\n', '        uint256 minimumExchangeRate;\n', '        uint256 minimumDestinationAmount;\n', '        uint256 sourceAmount;\n', '        uint256 tradeToTakeFeeFrom;\n', '        bool takeFeeFromSource; //Takes the fee before the trade if true, takes it after if false\n', '        address payable redirectAddress;\n', '        bool required;\n', '    }\n', '\n', '    struct SwapCollection {\n', '        Swap[] swaps;\n', '        address payable partnerContract;\n', '        uint256 expirationBlock;\n', '        bytes32 id;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    struct TokenBalance {\n', '        address tokenAddress;\n', '        uint256 balance;\n', '    }\n', '\n', '    struct FeeVariables {\n', '        uint256 feePercentage;\n', '        Partner partner;\n', '        uint256 totalFee;\n', '    }\n', '\n', '    struct AmountsSpentReceived{\n', '        uint256 spent;\n', '        uint256 received;\n', '    }\n', '    /*\n', '    *   Events\n', '    */\n', '\n', '    event LogSwapCollection(\n', '        bytes32 indexed id,\n', '        address indexed partnerContract,\n', '        address indexed user\n', '    );\n', '\n', '    event LogSwap(\n', '        bytes32 indexed id,\n', '        address sourceAsset,\n', '        address destinationAsset,\n', '        uint256 sourceAmount,\n', '        uint256 destinationAmount,\n', '        address feeAsset,\n', '        uint256 feeAmount\n', '    );\n', '\n', '    /// @notice Constructor\n', '    /// @param _tokenTransferProxy address of the TokenTransferProxy\n', "    /// @param _signer the suggester's address that signs the payloads. More can be added with add/removeSigner functions\n", '    constructor (address _tokenTransferProxy, address _signer/*, address _logger*/) public {\n', '        tokenTransferProxy = TokenTransferProxy(_tokenTransferProxy);\n', '        signers[_signer] = true;\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    modifier notExpired(SwapCollection memory swaps) {\n', '        require(swaps.expirationBlock > block.number, "Expired");\n', '        _;\n', '    }\n', '\n', '    modifier validSignature(SwapCollection memory swaps){\n', '        bytes32 hash = keccak256(abi.encode(swaps.swaps, swaps.partnerContract, swaps.expirationBlock, swaps.id, msg.sender));\n', '        require(signers[ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), swaps.v, swaps.r, swaps.s)], "Invalid signature");\n', '        _;\n', '    }\n', '\n', '    /// @notice Performs the requested set of swaps\n', '    /// @param swaps The struct that defines the collection of swaps to perform\n', '    function performSwapCollection(\n', '        SwapCollection memory swaps\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '        notExpired(swaps)\n', '        validSignature(swaps)\n', '    {\n', '        TokenBalance[20] memory balances;\n', '        balances[0] = TokenBalance(address(Utils.eth_address()), msg.value);\n', '        this.log("Created eth balance", balances[0].balance, 0x0);\n', '        for(uint256 swapIndex = 0; swapIndex < swaps.swaps.length; swapIndex++){\n', '            this.log("About to perform swap", swapIndex, swaps.id);\n', '            performSwap(swaps.id, swaps.swaps[swapIndex], balances, swaps.partnerContract);\n', '        }\n', '        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n', '        transferAllTokensToUser(balances);\n', '    }\n', '\n', '    function addSigner(address newSigner) public onlyOwner {\n', '         signers[newSigner] = true;\n', '    }\n', '\n', '    function removeSigner(address signer) public onlyOwner {\n', '         signers[signer] = false;\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '\n', '    function performSwap(\n', '        bytes32 swapCollectionId,\n', '        Swap memory swap,\n', '        TokenBalance[20] memory balances,\n', '        address payable partnerContract\n', '    )\n', '        internal\n', '    {\n', '        if(!transferFromSenderDifference(balances, swap.trades[0].sourceToken, swap.sourceAmount)){\n', '            if(swap.required){\n', '                revert("Failed to get tokens for required swap");\n', '            } else {\n', '                return;\n', '            }\n', '        }\n', '        uint256 amountSpentFirstTrade = 0;\n', '        uint256 amountReceived = 0;\n', '        uint256 feeAmount = 0;\n', '        for(uint256 tradeIndex = 0; tradeIndex < swap.trades.length; tradeIndex++){\n', '            if(tradeIndex == swap.tradeToTakeFeeFrom && swap.takeFeeFromSource){\n', '                feeAmount = takeFee(balances, swap.trades[tradeIndex].sourceToken, partnerContract,tradeIndex==0 ? swap.sourceAmount : amountReceived);\n', '            }\n', '            uint256 tempSpent;\n', '            this.log("About to performTrade",0,0x0);\n', '            (tempSpent, amountReceived) = performTrade(\n', '                swap.trades[tradeIndex],\n', '                balances,\n', '                Utils.min(\n', '                    tradeIndex == 0 ? swap.sourceAmount : amountReceived,\n', '                    balances[findToken(balances, swap.trades[tradeIndex].sourceToken)].balance\n', '                )\n', '            );\n', '            if(!swap.trades[tradeIndex].isSourceAmount && amountReceived < swap.trades[tradeIndex].amount){\n', '                if(swap.required){\n', '                    revert("Not enough destination amount");\n', '                }\n', '                return;\n', '            }\n', '            if(tradeIndex == 0){\n', '                amountSpentFirstTrade = tempSpent;\n', '            }\n', '            if(tradeIndex == swap.tradeToTakeFeeFrom && !swap.takeFeeFromSource){\n', '                feeAmount = takeFee(balances, swap.trades[tradeIndex].destinationToken, partnerContract, amountReceived);\n', '            }\n', '        }\n', '        this.log("About to emit LogSwap", 0, 0x0);\n', '        emit LogSwap(\n', '            swapCollectionId,\n', '            swap.trades[0].sourceToken,\n', '            swap.trades[swap.trades.length-1].destinationToken,\n', '            amountSpentFirstTrade,\n', '            amountReceived,\n', '            swap.takeFeeFromSource?swap.trades[swap.tradeToTakeFeeFrom].sourceToken:swap.trades[swap.tradeToTakeFeeFrom].destinationToken,\n', '            feeAmount\n', '        );\n', '\n', '        if(amountReceived < swap.minimumDestinationAmount){\n', '            this.log("Minimum destination amount failed", 0, 0x0);\n', '            revert("Tokens got less than minimumDestinationAmount");\n', '        } else if (minimumRateFailed(swap.trades[0].sourceToken, swap.trades[swap.trades.length-1].destinationToken,swap.sourceAmount, amountReceived, swap.minimumExchangeRate)){\n', '            this.log("Minimum rate failed", 0, 0x0);\n', '            revert("Minimum exchange rate not met");\n', '        }\n', '        if(swap.redirectAddress != msg.sender && swap.redirectAddress != address(0x0)){\n', '            this.log("About to redirect tokens", amountReceived, 0x0);\n', '            uint256 destinationTokenIndex = findToken(balances,swap.trades[swap.trades.length-1].destinationToken);\n', '            uint256 amountToSend = Math.min(amountReceived, balances[destinationTokenIndex].balance);\n', '            transferTokens(balances, destinationTokenIndex, swap.redirectAddress, amountToSend);\n', '            removeBalance(balances, swap.trades[swap.trades.length-1].destinationToken, amountToSend);\n', '        }\n', '    }\n', '\n', '    function performTrade(\n', '        Trade memory trade, \n', '        TokenBalance[20] memory balances,\n', '        uint256 availableToSpend\n', '    ) \n', '        internal returns (uint256 totalSpent, uint256 totalReceived)\n', '    {\n', '        uint256 tempSpent = 0;\n', '        uint256 tempReceived = 0;\n', '        for(uint256 orderIndex = 0; orderIndex < trade.orders.length; orderIndex++){\n', '            if((availableToSpend - totalSpent) * 10000 < availableToSpend){\n', '                break;\n', '            } else if(!trade.isSourceAmount && tempReceived == trade.amount){\n', '                break;\n', '            } else if (trade.isSourceAmount && tempSpent == trade.amount){\n', '                break;\n', '            }\n', '            this.log("About to perform order", orderIndex,0x0);\n', '            (tempSpent, tempReceived) = performOrder(\n', '                trade.orders[orderIndex], \n', '                availableToSpend - totalSpent,\n', '                trade.isSourceAmount ? availableToSpend - totalSpent : trade.amount - totalReceived, \n', '                trade.isSourceAmount,\n', '                trade.sourceToken, \n', '                balances);\n', '            this.log("Order performed",0,0x0);\n', '            totalSpent += tempSpent;\n', '            totalReceived += tempReceived;\n', '        }\n', '        addBalance(balances, trade.destinationToken, tempReceived);\n', '        removeBalance(balances, trade.sourceToken, tempSpent);\n', '        this.log("Trade performed",tempSpent, 0);\n', '    }\n', '\n', '    function performOrder(\n', '        Order memory order, \n', '        uint256 availableToSpend,\n', '        uint256 targetAmount,\n', '        bool isSourceAmount,\n', '        address tokenToSpend,\n', '        TokenBalance[20] memory balances\n', '    )\n', '        internal returns (uint256 spent, uint256 received)\n', '    {\n', '        this.log("Performing order", availableToSpend, 0x0);\n', '\n', '        if(tokenToSpend == Utils.eth_address()){\n', '            (spent, received) = ExchangeHandler(order.exchangeHandler).performOrder.value(availableToSpend)(order.encodedPayload, availableToSpend, targetAmount, isSourceAmount);\n', '\n', '        } else {\n', '            transferTokens(balances, findToken(balances, tokenToSpend), order.exchangeHandler, availableToSpend);\n', '            (spent, received) = ExchangeHandler(order.exchangeHandler).performOrder(order.encodedPayload, availableToSpend, targetAmount, isSourceAmount);\n', '        }\n', '        this.log("Performing order", spent,0x0);\n', '        this.log("Performing order", received,0x0);\n', '    }\n', '\n', '    function minimumRateFailed(\n', '        address sourceToken,\n', '        address destinationToken,\n', '        uint256 sourceAmount,\n', '        uint256 destinationAmount,\n', '        uint256 minimumExchangeRate\n', '    )\n', '        internal returns(bool failed)\n', '    {\n', '        this.log("About to get source decimals",sourceAmount,0x0);\n', '        uint256 sourceDecimals = sourceToken == Utils.eth_address() ? 18 : Utils.getDecimals(sourceToken);\n', '        this.log("About to get destination decimals",destinationAmount,0x0);\n', '        uint256 destinationDecimals = destinationToken == Utils.eth_address() ? 18 : Utils.getDecimals(destinationToken);\n', '        this.log("About to calculate amount got",0,0x0);\n', '        uint256 rateGot = Utils.calcRateFromQty(sourceAmount, destinationAmount, sourceDecimals, destinationDecimals);\n', '        this.log("Minimum rate failed", rateGot, 0x0);\n', '        return rateGot < minimumExchangeRate;\n', '    }\n', '\n', '    function takeFee(\n', '        TokenBalance[20] memory balances,\n', '        address token,\n', '        address payable partnerContract,\n', '        uint256 amountTraded\n', '    )\n', '        internal\n', '        returns (uint256 feeAmount)\n', '    {\n', '        Partner partner = Partner(partnerContract);\n', '        uint256 feePercentage = partner.getTotalFeePercentage();\n', '        this.log("Got fee percentage", feePercentage, 0x0);\n', '        feeAmount = calculateFee(amountTraded, feePercentage);\n', '        this.log("Taking fee", feeAmount, 0);\n', '        transferTokens(balances, findToken(balances, token), partnerContract, feeAmount);\n', '        removeBalance(balances, findToken(balances, token), feeAmount);\n', '        this.log("Took fee", 0, 0x0);\n', '        return feeAmount;\n', '    }\n', '\n', '    function transferFromSenderDifference(\n', '        TokenBalance[20] memory balances,\n', '        address token,\n', '        uint256 sourceAmount\n', '    )\n', '        internal returns (bool)\n', '    {\n', '        if(token == Utils.eth_address()){\n', '            if(sourceAmount>balances[0].balance){\n', '                this.log("Not enough eth", 0,0x0);\n', '                return false;\n', '            }\n', '            this.log("Enough eth", 0,0x0);\n', '            return true;\n', '        }\n', '\n', '        uint256 tokenIndex = findToken(balances, token);\n', '        if(sourceAmount>balances[tokenIndex].balance){\n', '            this.log("Transferring in token", 0,0x0);\n', '            bool success;\n', '            (success,) = address(tokenTransferProxy).call(abi.encodeWithSignature("transferFrom(address,address,address,uint256)", token, msg.sender, address(this), sourceAmount - balances[tokenIndex].balance));\n', '            if(success){\n', '                this.log("Got enough token", 0,0x0);\n', '                balances[tokenIndex].balance = sourceAmount;\n', '                return true;\n', '            }\n', '            this.log("Didn\'t get enough token", 0,0x0);\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferAllTokensToUser(\n', '        TokenBalance[20] memory balances\n', '    )\n', '        internal\n', '    {\n', '        this.log("About to transfer all tokens", 0, 0x0);\n', '        for(uint256 balanceIndex = 0; balanceIndex < balances.length; balanceIndex++){\n', '            if(balanceIndex != 0 && balances[balanceIndex].tokenAddress == address(0x0)){\n', '                return;\n', '            }\n', '            this.log("Transferring tokens", uint256(balances[balanceIndex].balance),0x0);\n', '            transferTokens(balances, balanceIndex, msg.sender, balances[balanceIndex].balance);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function transferTokens(\n', '        TokenBalance[20] memory balances,\n', '        uint256 tokenIndex,\n', '        address payable destination,\n', '        uint256 tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        if(tokenAmount > 0){\n', '            if(balances[tokenIndex].tokenAddress == Utils.eth_address()){\n', '                destination.transfer(tokenAmount);\n', '            } else {\n', '                ERC20SafeTransfer.safeTransfer(balances[tokenIndex].tokenAddress, destination, tokenAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function findToken(\n', '        TokenBalance[20] memory balances,\n', '        address token\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        for(uint256 index = 0; index < balances.length; index++){\n', '            if(balances[index].tokenAddress == token){\n', '                return index;\n', '            } else if (index != 0 && balances[index].tokenAddress == address(0x0)){\n', '                balances[index] = TokenBalance(token, 0);\n', '                return index;\n', '            }\n', '        }\n', '    }\n', '\n', '    function addBalance(\n', '        TokenBalance[20] memory balances,\n', '        address tokenAddress,\n', '        uint256 amountToAdd\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        uint256 tokenIndex = findToken(balances, tokenAddress);\n', '        addBalance(balances, tokenIndex, amountToAdd);\n', '    }\n', '\n', '    function addBalance(\n', '        TokenBalance[20] memory balances,\n', '        uint256 balanceIndex,\n', '        uint256 amountToAdd\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '       balances[balanceIndex].balance += amountToAdd;\n', '    }\n', '\n', '    function removeBalance(\n', '        TokenBalance[20] memory balances,\n', '        address tokenAddress,\n', '        uint256 amountToRemove\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        uint256 tokenIndex = findToken(balances, tokenAddress);\n', '        removeBalance(balances, tokenIndex, amountToRemove);\n', '    }\n', '\n', '    function removeBalance(\n', '        TokenBalance[20] memory balances,\n', '        uint256 balanceIndex,\n', '        uint256 amountToRemove\n', '    )\n', '        internal\n', '        pure\n', '    {\n', '        balances[balanceIndex].balance -= amountToRemove;\n', '    }\n', '\n', '    // @notice Calculates the fee amount given a fee percentage and amount\n', '    // @param amount the amount to calculate the fee based on\n', '    // @param fee the percentage, out of 1 eth (e.g. 0.01 ETH would be 1%)\n', '    function calculateFee(uint256 amount, uint256 fee) internal pure returns (uint256){\n', '        return SafeMath.div(SafeMath.mul(amount, fee), 1 ether);\n', '    }\n', '\n', '    /*\n', '    *   Payable fallback function\n', '    */\n', '\n', '    /// @notice payable fallback to allow handler or exchange contracts to return ether\n', '    /// @dev only accounts containing code (ie. contracts) can send ether to contract\n', '    function() external payable whenNotPaused {\n', '        // Check in here that the sender is a contract! (to stop accidents)\n', '        uint256 size;\n', '        address sender = msg.sender;\n', '        assembly {\n', '            size := extcodesize(sender)\n', '        }\n', '        if (size == 0) {\n', '            revert("EOA cannot send ether to primary fallback");\n', '        }\n', '    }\n', '    event Log(string a, uint256 b, bytes32 c);\n', '\n', '    function log(string memory a, uint256 b, bytes32 c) public {\n', '        emit Log(a,b,c);\n', '    }\n', '}']
