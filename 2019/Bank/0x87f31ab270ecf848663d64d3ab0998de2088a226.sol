['pragma solidity ^0.4.4;\n', '\n', 'contract SlotMachine {\n', '\n', '    address public slotMachineFunds;\n', '\n', '    uint256 public coinPrice = 0.1 ether;\n', '\n', '    address owner;\n', '\n', '    event Rolled(address sender, uint rand1, uint rand2, uint rand3);\n', '\n', '    mapping (address => uint) pendingWithdrawals;\n', '\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    //the user plays one roll of the machine putting in money for the win\n', '    function oneRoll() payable public{\n', '        require(msg.value >= coinPrice);\n', '\n', '        uint rand1 = randomGen(msg.value);\n', '        uint rand2 = randomGen(msg.value + 10);\n', '        uint rand3 = randomGen(msg.value + 20);\n', '\n', '        uint result = calculatePrize(rand1, rand2, rand3);\n', '\n', '        emit Rolled(msg.sender, rand1, rand2, rand3);\n', '\n', '        pendingWithdrawals[msg.sender] += result;\n', '        \n', '    }\n', '    \n', '    function contractBalance() constant public returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function calculatePrize(uint rand1, uint rand2, uint rand3) constant public returns(uint) {\n', '        if(rand1 == 5 && rand2 == 5 && rand3 == 5) {\n', '            return coinPrice * 30;\n', '        } else if (rand1 == 6 && rand2 == 5 && rand3 == 6) {\n', '            return coinPrice * 20;\n', '        } else if (rand1 == 4 && rand2 == 4 && rand3 == 4) {\n', '            return coinPrice * 15;\n', '        } else if (rand1 == 3 && rand2 == 3 && rand3 == 3) {\n', '            return coinPrice * 12;\n', '        } else if (rand1 == 2 && rand2 == 2 && rand3 == 2) {\n', '            return coinPrice * 10;\n', '        } else if (rand1 == 1 && rand2 == 1 && rand3 == 1) {\n', '            return coinPrice * 5;\n', '        } else if ((rand1 == rand2) || (rand1 == rand3) || (rand2 == rand3)) {\n', '            return coinPrice;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function withdraw() public{\n', '        uint amount = pendingWithdrawals[msg.sender];\n', '\n', '        pendingWithdrawals[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function balanceOf(address user) constant public returns(uint) {\n', '        return pendingWithdrawals[user];\n', '    }\n', '\n', '    function setCoinPrice(uint _coinPrice) public onlyOwner {\n', '        coinPrice = _coinPrice;\n', '    }\n', '\n', '    function() onlyOwner payable public {\n', '    }\n', '    \n', '    function addEther() payable public {}\n', '\n', '    function cashout(uint _amount) onlyOwner public{\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '    function randomGen(uint seed) private constant returns (uint randomNumber) {\n', '        return (uint(keccak256(blockhash(block.number-1), seed )) % 6) + 1;\n', '    }\n', '    \n', '    function killContract() public onlyOwner { //onlyOwner is custom modifier\n', '  \t    selfdestruct(owner);  // `owner` is the owners address\n', '    }\n', '\n', '\n', '}']