['pragma solidity ^0.4.25;\n', '\n', '/**\n', '*\n', '* «KillFish» is an economic game that provides the possibility to earn Ethereum.\n', '*  \n', '* The world ocean is a huge object containing many predatory fish fighting and eating each other.\n', '* Every player has an in-game task to maintain his/her fish growth periodically replenishing (feeding)\n', '* it or chasing after any smaller-size fish. As a matter of fact, this game is endless and a user\n', '* is capable to get in or out of the game at any stage, to collect and draw out his/her earnings \n', '* using the money transfer service on the Ethereum wallet.\n', '* \n', '* Every player can use 2 basic methods for earning money:\n', '* 1. To collect dividends from all new fish engaged in the game and from all fish that are about\n', '*     to leave the game, as well as from other actions of the players.\n', '* 2. To attack smaller-size prey status assigned fish 2 or 3 times a week.  \n', '*\n', '* More information on the site https://killfish.io\n', '* \n', '* «KillFish» - экономическая игра, предоставляющая возможность игрокам зарабатывать деньги в Ethereum.\n', '* \n', '* Мировой океан огромен и в нём обитает множество хищных рыб, которые стремятся съесть друг друга.\n', '* Задача игрока состоит в том, что бы поддерживать рост своей рыбы, периодически пополняя(кормя)\n', '* её или охотясь на меньших по размерам рыб . Игра по сути своей бесконечная, можно на любом этапе\n', '* войти и выйти из неё, получить свой доход переводом на Ethereum кошелёк.\n', '*\n', '* Каждый игрок имеет возможность заработать 2 основными способами в игре:\n', '* 1. Получать долю от всех новых рыб в игре и всех рыб, которые покидают игру,\n', '*     а также от других действий игроков.\n', '* 2. 2-3 раза в неделю нападать на рыб меньшего размера, которые находятся в статусе жертвы.\n', '* \n', '* Больше информации на сайте https://killfish.io\n', '*\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC721 {\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function transfer(address _to, uint256 _tokenId) public returns (bool);\n', '    \n', '    event Transfer(\n', '        address indexed from, \n', '        address indexed to, \n', '        uint256 indexed tokenId\n', '    );\n', '}\n', '\n', 'contract KillFish is Ownable, ERC721 {\n', '    \n', '    using SafeMath for uint256;\n', '    using SafeMath for uint64;\n', '    \n', '    /**\n', '    * token structure\n', '    */\n', '    \n', '    struct Fish {  \n', '        uint64 genes;       //genes determine only the appearance 00 000 000 000-99 999 999 999\n', '        string nickname;    //fish nickname\n', '        uint64 birthTime;   //birth time\n', '        uint64 feedTime;    //last feeding time\n', '        uint64 huntTime;    //last hunting time\n', '        uint256 share;      //fish size (per share)\n', '        uint256 feedValue;  //how much fish should eat (per eth)\n', '        uint256 eatenValue; //how much did the fish eat (per eth)\n', '    }\n', '    \n', '    /**\n', '    * storage\n', '    */\n', '    \n', '    Fish[] fishes;\n', '    \n', '    mapping (uint256 => address) private _tokenOwner;\n', '    \n', '    mapping (address => uint256) private _ownedTokensCount;\n', '    \n', '    uint256 private _totalSupply;\n', '    \n', '    uint256 public totalShares;\n', '    \n', '    uint256 public balanceFishes;\n', '    uint256 public balanceOwner;\n', '    uint256 public balanceMarketing;\n', '    \n', '    uint256 public maxGasPrice;\n', '    \n', '    /**\n', '    * constants\n', '    */\n', '    \n', '    string constant public name = "KillFish.io";\n', '    string constant public symbol = "FISH";\n', '    \n', '    uint256 constant public minPayment = 10000 szabo;   // 10000 szabo=0.01 eth\n', '    uint8 constant public percentFeeFishesInput = 5;\n', '    uint8 constant public percentFeeFishesOutput = 5;\n', '    uint8 constant public percentFeeFishesBite = 20;\n', '    \n', '    uint8 constant public percentFeeMarketingInput = 5;\n', '    uint8 constant public percentFeeAdminOutput = 5;\n', '    uint8 constant public percentFeeAdminBite = 10;\n', '    \n', '    uint8 constant public percentFeed = 5;\n', '    \n', '    uint64 constant public pausePrey = 7 days;\n', '    uint64 constant public pauseHunter = 2 days;\n', '    \n', '    /**\n', '    * admin functions\n', '    */\n', '    \n', '    event UpdateMaxGasPrice(\n', '        uint256 maxGasPrice\n', '    );\n', '    event WithdrawalMarketing(\n', '        address indexed to, \n', '        uint256 value\n', '    );\n', '    event WithdrawalOwner(\n', '        address indexed to, \n', '        uint256 value\n', '    );\n', '    \n', '    function updateMaxGasPrice(uint256 _newMaxGasPrice) public onlyOwner {\n', '        require(_newMaxGasPrice >= 10000000000 wei); // 10000000000 wei = 10 gwei\n', '        \n', '        maxGasPrice=_newMaxGasPrice;\n', '        \n', '        emit UpdateMaxGasPrice(maxGasPrice);\n', '    }\n', '    \n', '    function withdrawalMarketing(address _to, uint256 _value) public onlyOwner {\n', '        balanceMarketing=balanceMarketing.sub(_value);\n', '        emit WithdrawalMarketing(_to, _value);\n', '        \n', '        _to.transfer(_value);\n', '    }\n', '    \n', '    function withdrawalOwner(address _to, uint256 _value) public onlyOwner {\n', '        balanceOwner=balanceOwner.sub(_value);\n', '        emit WithdrawalOwner(_to, _value);\n', '        \n', '        _to.transfer(_value);\n', '    }\n', '    \n', '    constructor() public {\n', '        \n', '        updateMaxGasPrice(25000000000 wei); // 25000000000 wei = 25 gwei\n', '        \n', '    }\n', '    \n', '    /**\n', '    * ERC721 functions\n', '    */\n', '    \n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        require(msg.sender == _tokenOwner[_tokenId], "not token owner");\n', '        _;\n', '    }\n', '    \n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256 total) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return _ownedTokensCount[_owner];\n', '    }\n', '    \n', '    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n', '        return _tokenOwner[_tokenId];\n', '    }\n', '    \n', '    function _transfer(address _from, address _to, uint256 _tokenId) private returns (bool) {\n', '        _ownedTokensCount[_to] = _ownedTokensCount[_to].add(1);\n', '        _ownedTokensCount[_from] = _ownedTokensCount[_from].sub(1);\n', '        _tokenOwner[_tokenId] = _to;\n', '        emit Transfer(_from, _to, _tokenId);\n', '        return true;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) returns (bool)  {\n', '        return _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    \n', '    /**\n', '    * refund\n', '    */\n', '    \n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '    * fish functions\n', '    */\n', '    \n', '    event CreateFish(\n', '        uint256 indexed tokenId,\n', '        uint64 genes,\n', '        string nickname,\n', '        uint64 birthTime,\n', '        uint256 share,\n', '        uint256 feedValue,\n', '        uint256 eatenValue\n', '    );\n', '    event FeedFish(\n', '        uint256 indexed tokenId,\n', '        uint256 share,\n', '        uint256 feedValue,\n', '        uint256 eatenValue\n', '    );\n', '    event DestroyFish(\n', '        uint256 indexed tokenId,\n', '        uint256 share,\n', '        uint256 withdrawal\n', '    );    \n', '    event BiteFish(\n', '        uint256 indexed tokenId,\n', '        uint256 indexed preyId,\n', '        uint256 hunterShare,\n', '        uint256 hunterFeedValue,\n', '        uint256 preyShare,\n', '        uint256 preyFeedValue\n', '    );\n', '    event UpdateNickname(\n', '        uint256 indexed tokenId,\n', '        string nickname\n', '    );    \n', '    \n', '    modifier checkMaxGasPrice() {\n', '        require(tx.gasprice<=maxGasPrice, "gas price > maxGasPrice");\n', '        _;\n', '    }\n', '    \n', '    modifier checkMinPayment() {\n', '        require(msg.value>=minPayment, "msg.value < minPayment");\n', '        _;\n', '    }\n', '    \n', '    function createFish(string _nickname) public payable checkMinPayment checkMaxGasPrice returns(uint256) {\n', '        \n', '        uint256 feeMarketing=msg.value.mul(percentFeeMarketingInput).div(100);\n', '        uint256 feeFishes=msg.value.mul(percentFeeFishesInput).div(100);\n', '        uint256 value=msg.value.sub(feeMarketing).sub(feeFishes);\n', '        \n', '        balanceFishes=balanceFishes.add(value).add(feeFishes);\n', '        balanceMarketing=balanceMarketing.add(feeMarketing);\n', '        \n', '        uint256 share=_newShare(value);\n', '        \n', '        totalShares=totalShares.add(share);\n', '        \n', '        Fish memory newFish=Fish({\n', '            genes: _newGenes(),\n', '            nickname: _nickname,\n', '            birthTime: uint64(now),\n', '            feedTime: uint64(now),\n', '            huntTime: uint64(now), \n', '            share: share,\n', '            feedValue: _newFeedValue(share),\n', '            eatenValue: value\n', '        });\n', '        uint256 newTokenId = fishes.push(newFish) - 1;\n', '        \n', '        _totalSupply=_totalSupply.add(1);\n', '        _ownedTokensCount[msg.sender]=_ownedTokensCount[msg.sender].add(1);\n', '        _tokenOwner[newTokenId]=msg.sender;\n', '        \n', '        emit CreateFish(newTokenId, fishes[newTokenId].genes, fishes[newTokenId].nickname, fishes[newTokenId].birthTime, fishes[newTokenId].share, fishes[newTokenId].feedValue, value);\n', '        emit Transfer(address(0), msg.sender, newTokenId);\n', '        \n', '        return newTokenId;\n', '    }\n', '    \n', '    function feedFish(uint256 _tokenId) public payable checkMinPayment checkMaxGasPrice returns(bool) {\n', '        require(statusLive(_tokenId), "fish dead");\n', '        \n', '        uint256 feeMarketing=msg.value.mul(percentFeeMarketingInput).div(100);\n', '        uint256 feeFishes=msg.value.mul(percentFeeFishesInput).div(100);\n', '        uint256 value=msg.value.sub(feeMarketing).sub(feeFishes);\n', '        \n', '        balanceFishes=balanceFishes.add(value).add(feeFishes);\n', '        balanceMarketing=balanceMarketing.add(feeMarketing);\n', '        \n', '        uint256 share=_newShare(value);\n', '        \n', '        totalShares=totalShares.add(share);\n', '        fishes[_tokenId].share=fishes[_tokenId].share.add(share);\n', '        fishes[_tokenId].eatenValue=fishes[_tokenId].eatenValue.add(value);\n', '        \n', '        if (value<fishes[_tokenId].feedValue) {\n', '            fishes[_tokenId].feedValue=fishes[_tokenId].feedValue.sub(value);\n', '        } else {\n', '            fishes[_tokenId].feedValue=_newFeedValue(fishes[_tokenId].share);\n', '            fishes[_tokenId].feedTime=uint64(now);\n', '            fishes[_tokenId].huntTime=uint64(now);\n', '        }\n', '        \n', '        emit FeedFish(_tokenId, share, fishes[_tokenId].feedValue, value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function destroyFish(uint256 _tokenId) public onlyOwnerOf(_tokenId) checkMaxGasPrice returns(bool) {\n', '        \n', '        uint256 share=fishes[_tokenId].share;\n', '        uint256 withdrawal=shareToValue(share);\n', '        uint256 feeFishes=withdrawal.mul(percentFeeFishesOutput).div(100);\n', '        uint256 feeAdmin=withdrawal.mul(percentFeeAdminOutput).div(100);\n', '        \n', '        withdrawal=withdrawal.sub(feeFishes).sub(feeAdmin);\n', '        \n', '        totalShares=totalShares.sub(share);\n', '        fishes[_tokenId].share=0;\n', '        fishes[_tokenId].feedValue=0;\n', '        fishes[_tokenId].nickname="";\n', '        fishes[_tokenId].feedTime=uint64(now);\n', '        \n', '        _transfer(msg.sender, address(0), _tokenId);\n', '        \n', '        balanceOwner=balanceOwner.add(feeAdmin);\n', '        balanceFishes=balanceFishes.sub(withdrawal).sub(feeAdmin);\n', '        \n', '        emit DestroyFish(_tokenId, share, withdrawal);\n', '        \n', '        msg.sender.transfer(withdrawal);\n', '        \n', '        return true;   \n', '    }\n', '    \n', '    function biteFish(uint256 _tokenId, uint256 _preyId) public onlyOwnerOf(_tokenId) checkMaxGasPrice returns(bool) {\n', '        require(statusLive(_preyId), "prey dead");\n', '        require(statusPrey(_preyId), "not prey");\n', '        require(statusHunter(_tokenId), "not hunter");\n', '        require(fishes[_preyId].share<fishes[_tokenId].share, "too much prey");\n', '        \n', '        uint256 sharePrey;\n', '        uint256 shareHunter;\n', '        uint256 shareFishes;\n', '        uint256 shareAdmin;\n', '        uint256 value;\n', '        \n', '        if (shareToValue(fishes[_preyId].share)<minPayment.mul(2)) {\n', '            sharePrey=fishes[_preyId].share;\n', '            \n', '            _transfer(ownerOf(_preyId), address(0), _preyId);\n', '            fishes[_preyId].nickname="";\n', '        } else {\n', '            sharePrey=fishes[_preyId].share.mul(percentFeed).div(100);\n', '            \n', '            if (shareToValue(sharePrey)<minPayment) {\n', '                sharePrey=valueToShare(minPayment);\n', '            }\n', '\n', '        }\n', '        \n', '        shareFishes=sharePrey.mul(percentFeeFishesBite).div(100);\n', '        shareAdmin=sharePrey.mul(percentFeeAdminBite).div(100);\n', '        shareHunter=sharePrey.sub(shareFishes).sub(shareAdmin);\n', '        \n', '        fishes[_preyId].share=fishes[_preyId].share.sub(sharePrey);\n', '        fishes[_tokenId].share=fishes[_tokenId].share.add(shareHunter);\n', '        \n', '        fishes[_preyId].feedValue=_newFeedValue(fishes[_preyId].share);\n', '        fishes[_preyId].feedTime=uint64(now);\n', '        \n', '        fishes[_tokenId].huntTime=uint64(now);\n', '        \n', '        value=shareToValue(shareHunter);\n', '        \n', '        if (value<fishes[_tokenId].feedValue) {\n', '            fishes[_tokenId].feedValue=fishes[_tokenId].feedValue.sub(value);\n', '        } else {\n', '            fishes[_tokenId].feedValue=_newFeedValue(fishes[_tokenId].share);\n', '            fishes[_tokenId].feedTime=uint64(now);\n', '        }\n', '        \n', '        value=shareToValue(shareAdmin);\n', '        \n', '        totalShares=totalShares.sub(shareFishes).sub(shareAdmin);\n', '        \n', '        balanceOwner=balanceOwner.add(value);\n', '        balanceFishes=balanceFishes.sub(value);\n', '        \n', '        emit BiteFish(_tokenId, _preyId, shareHunter, fishes[_tokenId].feedValue, sharePrey, fishes[_preyId].feedValue);\n', '        \n', '        return true;        \n', '    }\n', '    \n', '    function updateNickname(uint256 _tokenId, string _nickname) public onlyOwnerOf(_tokenId) returns(bool) {\n', '        \n', '        fishes[_tokenId].nickname=_nickname;\n', '        \n', '        emit UpdateNickname(_tokenId, _nickname);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '    * utilities\n', '    */\n', '    \n', '    function getFish(uint256 _tokenId) public view\n', '        returns (\n', '        uint64 genes,\n', '        string nickname,\n', '        uint64 birthTime,\n', '        uint64 feedTime,\n', '        uint64 huntTime,\n', '        uint256 share,\n', '        uint256 feedValue,\n', '        uint256 eatenValue\n', '    ) {\n', '        Fish memory fish=fishes[_tokenId];\n', '        \n', '        genes=fish.genes;\n', '        nickname=fish.nickname;\n', '        birthTime=fish.birthTime;\n', '        feedTime=fish.feedTime;\n', '        huntTime=fish.huntTime;\n', '        share=fish.share; \n', '        feedValue=fish.feedValue; \n', '        eatenValue=fish.eatenValue; \n', '    }\n', '\n', '    function statusLive(uint256 _tokenId) public view returns(bool) {\n', '        if (fishes[_tokenId].share==0) {return false;}\n', '        return true;\n', '    }\n', '    \n', '    function statusPrey(uint256 _tokenId) public view returns(bool) {\n', '        if (now<=fishes[_tokenId].feedTime.add(pausePrey)) {return false;}\n', '        return true;\n', '    }\n', '    \n', '    function statusHunter(uint256 _tokenId) public view returns(bool) {\n', '        if (now<=fishes[_tokenId].huntTime.add(pauseHunter)) {return false;}\n', '        return true;\n', '    }\n', '    \n', '    function shareToValue(uint256 _share) public view returns(uint256) {\n', '        if (totalShares == 0) {return 0;}\n', '        return _share.mul(balanceFishes).div(totalShares);\n', '    }\n', '    \n', '    function valueToShare(uint256 _value) public view returns(uint256) {\n', '        if (balanceFishes == 0) {return 0;}\n', '        return _value.mul(totalShares).div(balanceFishes);\n', '    }\n', '    \n', '    function _newShare(uint256 _value) private view returns(uint256) {\n', '        if (totalShares == 0) {return _value;}\n', '        return _value.mul(totalShares).div(balanceFishes.sub(_value));\n', '    }\n', '    \n', '    function _newFeedValue(uint256 _share) private view returns(uint256) {\n', '        uint256 _value=shareToValue(_share);\n', '        return _value.mul(percentFeed).div(100);\n', '    }\n', '    \n', '    function _newGenes() private view returns(uint64) {\n', '        return uint64(uint256(keccak256(abi.encodePacked(now, totalShares, balanceFishes)))%(10**11));\n', '    }\n', '    \n', '}']