['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.5.2;\n', '\n', '\n', '/// @title Utility Functions for bytes\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library BytesUtil {\n', '    function bytesToBytes32(\n', '        bytes memory b,\n', '        uint offset\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return bytes32(bytesToUintX(b, offset, 32));\n', '    }\n', '\n', '    function bytesToUint(\n', '        bytes memory b,\n', '        uint offset\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        return bytesToUintX(b, offset, 32);\n', '    }\n', '\n', '    function bytesToAddress(\n', '        bytes memory b,\n', '        uint offset\n', '        )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '    }\n', '\n', '    function bytesToUint16(\n', '        bytes memory b,\n', '        uint offset\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint16)\n', '    {\n', '        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\n', '    }\n', '\n', '    function bytesToUintX(\n', '        bytes memory b,\n', '        uint offset,\n', '        uint numBytes\n', '        )\n', '        private\n', '        pure\n', '        returns (uint data)\n', '    {\n', '        require(b.length >= offset + numBytes, "INVALID_SIZE");\n', '        assembly {\n', '            data := mload(add(add(b, numBytes), offset))\n', '        }\n', '    }\n', '\n', '    function subBytes(\n', '        bytes memory b,\n', '        uint offset\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes memory data)\n', '    {\n', '        require(b.length >= offset + 32, "INVALID_SIZE");\n', '        assembly {\n', '            data := add(add(b, 32), offset)\n', '        }\n', '    }\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint {\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "INVALID_VALUE");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "INVALID_VALUE");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "INVALID_VALUE");\n', '    }\n', '\n', '    function hasRoundingError(\n', '        uint value,\n', '        uint numerator,\n', '        uint denominator\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint multiplied = mul(value, numerator);\n', '        uint remainder = multiplied % denominator;\n', '        // Return true if the rounding error is larger than 1%\n', '        return mul(remainder, 100) > multiplied;\n', '    }\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title ITradeHistory\n', '/// @dev Stores the trade history and cancelled data of orders\n', '/// @author Brecht Devos - <brecht@loopring.org>.\n', 'contract ITradeHistory {\n', '\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public filled;\n', '\n', "    // This map is used to keep trace of order's cancellation history.\n", '    mapping (address => mapping (bytes32 => bool)) public cancelled;\n', '\n', '    // A map from a broker to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '\n', '    // A map from a broker to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '\n', '    // A map from a broker to an order owner to its cutoff timestamp.\n', '    mapping (address => mapping (address => uint)) public cutoffsOwner;\n', '\n', '    // A map from a broker to an order owner to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (address => mapping (bytes20 => uint))) public tradingPairCutoffsOwner;\n', '\n', '\n', '    function batchUpdateFilled(\n', '        bytes32[] calldata filledInfo\n', '        )\n', '        external;\n', '\n', '    function setCancelled(\n', '        address broker,\n', '        bytes32 orderHash\n', '        )\n', '        external;\n', '\n', '    function setCutoffs(\n', '        address broker,\n', '        uint cutoff\n', '        )\n', '        external;\n', '\n', '    function setTradingPairCutoffs(\n', '        address broker,\n', '        bytes20 tokenPair,\n', '        uint cutoff\n', '        )\n', '        external;\n', '\n', '    function setCutoffsOfOwner(\n', '        address broker,\n', '        address owner,\n', '        uint cutoff\n', '        )\n', '        external;\n', '\n', '    function setTradingPairCutoffsOfOwner(\n', '        address broker,\n', '        address owner,\n', '        bytes20 tokenPair,\n', '        uint cutoff\n', '        )\n', '        external;\n', '\n', '    function batchGetFilledAndCheckCancelled(\n', '        bytes32[] calldata orderInfo\n', '        )\n', '        external\n', '        view\n', '        returns (uint[] memory fills);\n', '\n', '\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '\n', '\n', '    function suspend()\n', '        external;\n', '\n', '    function resume()\n', '        external;\n', '\n', '    function kill()\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title ITradeDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract ITradeDelegate {\n', '\n', '    function batchTransfer(\n', '        bytes32[] calldata batch\n', '        )\n', '        external;\n', '\n', '\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '\n', '\n', '    function suspend()\n', '        external;\n', '\n', '    function resume()\n', '        external;\n', '\n', '    function kill()\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title IOrderRegistry\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract IOrderRegistry {\n', '\n', '    /// @dev   Returns wether the order hash was registered in the registry.\n', '    /// @param broker The broker of the order\n', '    /// @param orderHash The hash of the order\n', '    /// @return True if the order hash was registered, else false.\n', '    function isOrderHashRegistered(\n', '        address broker,\n', '        bytes32 orderHash\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev   Registers an order in the registry.\n', '    ///        msg.sender needs to be the broker of the order.\n', '    /// @param orderHash The hash of the order\n', '    function registerOrderHash(\n', '        bytes32 orderHash\n', '        )\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title IOrderBook\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>.\n', 'contract IOrderBook {\n', '    // The map of registered order hashes\n', '    mapping(bytes32 => bool) public orderSubmitted;\n', '\n', '    /// @dev  Event emitted when an order was successfully submitted\n', '    ///        orderHash      The hash of the order\n', '    ///        orderData      The data of the order as passed to submitOrder()\n', '    event OrderSubmitted(\n', '        bytes32 orderHash,\n', '        bytes   orderData\n', '    );\n', '\n', '    /// @dev   Submits an order to the on-chain order book.\n', '    ///        No signature is needed. The order can only be sumbitted by its\n', '    ///        owner or its broker (the owner can be the address of a contract).\n', '    /// @param orderData The data of the order. Contains all fields that are used\n', '    ///        for the order hash calculation.\n', '    ///        See OrderHelper.updateHash() for detailed information.\n', '    function submitOrder(\n', '        bytes calldata orderData\n', '        )\n', '        external\n', '        returns (bytes32);\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', '/// @title IFeeHolder - A contract holding fees.\n', 'contract IFeeHolder {\n', '\n', '    event TokenWithdrawn(\n', '        address owner,\n', '        address token,\n', '        uint value\n', '    );\n', '\n', '    // A map of all fee balances\n', '    mapping(address => mapping(address => uint)) public feeBalances;\n', '\n', '    /// @dev   Allows withdrawing the tokens to be burned by\n', '    ///        authorized contracts.\n', '    /// @param token The token to be used to burn buy and burn LRC\n', '    /// @param value The amount of tokens to withdraw\n', '    function withdrawBurned(\n', '        address token,\n', '        uint value\n', '        )\n', '        external\n', '        returns (bool success);\n', '\n', '    /// @dev   Allows withdrawing the fee payments funds\n', '    ///        msg.sender is the recipient of the fee and the address\n', '    ///        to which the tokens will be sent.\n', '    /// @param token The token to withdraw\n', '    /// @param value The amount of tokens to withdraw\n', '    function withdrawToken(\n', '        address token,\n', '        uint value\n', '        )\n', '        external\n', '        returns (bool success);\n', '\n', '    function batchAddFeeBalances(\n', '        bytes32[] calldata batch\n', '        )\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @title IBurnRateTable - A contract for managing burn rates for tokens\n', 'contract IBurnRateTable {\n', '\n', '    struct TokenData {\n', '        uint    tier;\n', '        uint    validUntil;\n', '    }\n', '\n', '    mapping(address => TokenData) public tokens;\n', '\n', '    uint public constant YEAR_TO_SECONDS = 31556952;\n', '\n', '    // Tiers\n', '    uint8 public constant TIER_4 = 0;\n', '    uint8 public constant TIER_3 = 1;\n', '    uint8 public constant TIER_2 = 2;\n', '    uint8 public constant TIER_1 = 3;\n', '\n', '    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%\n', '\n', '    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply\n', '    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%\n', '\n', '    // Burn rates\n', '    // Matching\n', '    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%\n', '    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%\n', '    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%\n', '    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%\n', '    // P2P\n', '    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%\n', '    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%\n', '    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%\n', '    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%\n', '\n', '    event TokenTierUpgraded(\n', '        address indexed addr,\n', '        uint            tier\n', '    );\n', '\n', '    /// @dev   Returns the P2P and matching burn rate for the token.\n', '    /// @param token The token to get the burn rate for.\n', '    /// @return The burn rate. The P2P burn rate and matching burn rate\n', '    ///         are packed together in the lowest 4 bytes.\n', '    ///         (2 bytes P2P, 2 bytes matching)\n', '    function getBurnRate(\n', '        address token\n', '        )\n', '        external\n', '        view\n', '        returns (uint32 burnRate);\n', '\n', '    /// @dev   Returns the tier of a token.\n', '    /// @param token The token to get the token tier for.\n', '    /// @return The tier of the token\n', '    function getTokenTier(\n', '        address token\n', '        )\n', '        public\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev   Upgrades the tier of a token. Before calling this function,\n', '    ///        msg.sender needs to approve this contract for the neccessary funds.\n', '    /// @param token The token to upgrade the tier for.\n', '    /// @return True if successful, false otherwise.\n', '    function upgradeTokenTier(\n', '        address token\n', '        )\n', '        external\n', '        returns (bool);\n', '\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title IBrokerRegistry\n', '/// @dev A broker is an account that can submit orders on behalf of other\n', '///      accounts. When registering a broker, the owner can also specify a\n', '///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract IBrokerRegistry {\n', '    event BrokerRegistered(\n', '        address owner,\n', '        address broker,\n', '        address interceptor\n', '    );\n', '\n', '    event BrokerUnregistered(\n', '        address owner,\n', '        address broker,\n', '        address interceptor\n', '    );\n', '\n', '    event AllBrokersUnregistered(\n', '        address owner\n', '    );\n', '\n', '    /// @dev   Validates if the broker was registered for the order owner and\n', '    ///        returns the possible BrokerInterceptor to be used.\n', '    /// @param owner The owner of the order\n', '    /// @param broker The broker of the order\n', '    /// @return True if the broker was registered for the owner\n', '    ///         and the BrokerInterceptor to use.\n', '    function getBroker(\n', '        address owner,\n', '        address broker\n', '        )\n', '        external\n', '        view\n', '        returns(\n', '            bool registered,\n', '            address interceptor\n', '        );\n', '\n', '    /// @dev   Gets all registered brokers for an owner.\n', '    /// @param owner The owner\n', '    /// @param start The start index of the list of brokers\n', '    /// @param count The number of brokers to return\n', '    /// @return The list of requested brokers and corresponding BrokerInterceptors\n', '    function getBrokers(\n', '        address owner,\n', '        uint    start,\n', '        uint    count\n', '        )\n', '        external\n', '        view\n', '        returns (\n', '            address[] memory brokers,\n', '            address[] memory interceptors\n', '        );\n', '\n', '    /// @dev   Registers a broker for msg.sender and an optional\n', '    ///        corresponding BrokerInterceptor.\n', '    /// @param broker The broker to register\n', '    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)\n', '    function registerBroker(\n', '        address broker,\n', '        address interceptor\n', '        )\n', '        external;\n', '\n', '    /// @dev   Unregisters a broker for msg.sender\n', '    /// @param broker The broker to unregister\n', '    function unregisterBroker(\n', '        address broker\n', '        )\n', '        external;\n', '\n', '    /// @dev   Unregisters all brokers for msg.sender\n', '    function unregisterAllBrokers(\n', '        )\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '/// @title Utility Functions for Multihash signature verificaiton\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// For more information:\n', '///   - https://github.com/saurfang/ipfs-multihash-on-solidity\n', '///   - https://github.com/multiformats/multihash\n', '///   - https://github.com/multiformats/js-multihash\n', 'library MultihashUtil {\n', '\n', '    enum HashAlgorithm { Ethereum, EIP712 }\n', '\n', '    string public constant SIG_PREFIX = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    function verifySignature(\n', '        address signer,\n', '        bytes32 plaintext,\n', '        bytes memory multihash\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint length = multihash.length;\n', '        require(length >= 2, "invalid multihash format");\n', '        uint8 algorithm;\n', '        uint8 size;\n', '        assembly {\n', '            algorithm := mload(add(multihash, 1))\n', '            size := mload(add(multihash, 2))\n', '        }\n', '        require(length == (2 + size), "bad multihash size");\n', '\n', '        if (algorithm == uint8(HashAlgorithm.Ethereum)) {\n', '            require(signer != address(0x0), "invalid signer address");\n', '            require(size == 65, "bad Ethereum multihash size");\n', '            bytes32 hash;\n', '            uint8 v;\n', '            bytes32 r;\n', '            bytes32 s;\n', '            assembly {\n', '                let data := mload(0x40)\n', '                mstore(data, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // SIG_PREFIX\n', '                mstore(add(data, 28), plaintext)                                                 // plaintext\n', '                hash := keccak256(data, 60)                                                      // 28 + 32\n', '                // Extract v, r and s from the multihash data\n', '                v := mload(add(multihash, 3))\n', '                r := mload(add(multihash, 35))\n', '                s := mload(add(multihash, 67))\n', '            }\n', '            return signer == ecrecover(\n', '                hash,\n', '                v,\n', '                r,\n', '                s\n', '            );\n', '        } else if (algorithm == uint8(HashAlgorithm.EIP712)) {\n', '            require(signer != address(0x0), "invalid signer address");\n', '            require(size == 65, "bad EIP712 multihash size");\n', '            uint8 v;\n', '            bytes32 r;\n', '            bytes32 s;\n', '            assembly {\n', '                // Extract v, r and s from the multihash data\n', '                v := mload(add(multihash, 3))\n', '                r := mload(add(multihash, 35))\n', '                s := mload(add(multihash, 67))\n', '            }\n', '            return signer == ecrecover(\n', '                plaintext,\n', '                v,\n', '                r,\n', '                s\n', '            );\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '\n', '    function verifyTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes memory data\n', '        )\n', '        public\n', '        returns (bool);\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'library Data {\n', '\n', '    enum TokenType { ERC20 }\n', '\n', '    struct Header {\n', '        uint version;\n', '        uint numOrders;\n', '        uint numRings;\n', '        uint numSpendables;\n', '    }\n', '\n', '    struct Context {\n', '        address lrcTokenAddress;\n', '        ITradeDelegate  delegate;\n', '        ITradeHistory   tradeHistory;\n', '        IBrokerRegistry orderBrokerRegistry;\n', '        IOrderRegistry  orderRegistry;\n', '        IFeeHolder feeHolder;\n', '        IOrderBook orderBook;\n', '        IBurnRateTable burnRateTable;\n', '        uint64 ringIndex;\n', '        uint feePercentageBase;\n', '        bytes32[] tokenBurnRates;\n', '        uint feeData;\n', '        uint feePtr;\n', '        uint transferData;\n', '        uint transferPtr;\n', '    }\n', '\n', '    struct Mining {\n', '        // required fields\n', '        address feeRecipient;\n', '\n', '        // optional fields\n', '        address miner;\n', '        bytes   sig;\n', '\n', '        // computed fields\n', '        bytes32 hash;\n', '        address interceptor;\n', '    }\n', '\n', '    struct Spendable {\n', '        bool initialized;\n', '        uint amount;\n', '        uint reserved;\n', '    }\n', '\n', '    struct Order {\n', '        uint      version;\n', '\n', '        // required fields\n', '        address   owner;\n', '        address   tokenS;\n', '        address   tokenB;\n', '        uint      amountS;\n', '        uint      amountB;\n', '        uint      validSince;\n', '        Spendable tokenSpendableS;\n', '        Spendable tokenSpendableFee;\n', '\n', '        // optional fields\n', '        address   dualAuthAddr;\n', '        address   broker;\n', '        Spendable brokerSpendableS;\n', '        Spendable brokerSpendableFee;\n', '        address   orderInterceptor;\n', '        address   wallet;\n', '        uint      validUntil;\n', '        bytes     sig;\n', '        bytes     dualAuthSig;\n', '        bool      allOrNone;\n', '        address   feeToken;\n', '        uint      feeAmount;\n', '        int16     waiveFeePercentage;\n', '        uint16    tokenSFeePercentage;    // Pre-trading\n', '        uint16    tokenBFeePercentage;   // Post-trading\n', '        address   tokenRecipient;\n', '        uint16    walletSplitPercentage;\n', '\n', '        // computed fields\n', '        bool    P2P;\n', '        bytes32 hash;\n', '        address brokerInterceptor;\n', '        uint    filledAmountS;\n', '        uint    initialFilledAmountS;\n', '        bool    valid;\n', '\n', '        TokenType tokenTypeS;\n', '        TokenType tokenTypeB;\n', '        TokenType tokenTypeFee;\n', '        bytes32 trancheS;\n', '        bytes32 trancheB;\n', '        bytes   transferDataS;\n', '    }\n', '\n', '    struct Participation {\n', '        // required fields\n', '        Order order;\n', '\n', '        // computed fields\n', '        uint splitS;\n', '        uint feeAmount;\n', '        uint feeAmountS;\n', '        uint feeAmountB;\n', '        uint rebateFee;\n', '        uint rebateS;\n', '        uint rebateB;\n', '        uint fillAmountS;\n', '        uint fillAmountB;\n', '    }\n', '\n', '    struct Ring{\n', '        uint size;\n', '        Participation[] participations;\n', '        bytes32 hash;\n', '        uint minerFeesToOrdersPercentage;\n', '        bool valid;\n', '    }\n', '\n', '    struct FeeContext {\n', '        Data.Ring ring;\n', '        Data.Context ctx;\n', '        address feeRecipient;\n', '        uint walletPercentage;\n', '        int16 waiveFeePercentage;\n', '        address owner;\n', '        address wallet;\n', '        bool P2P;\n', '    }\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title IRingSubmitter\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', 'contract IRingSubmitter {\n', '    uint16  public constant FEE_PERCENTAGE_BASE = 1000;\n', '\n', '    /// @dev  Event emitted when a ring was successfully mined\n', '    ///        _ringIndex     The index of the ring\n', '    ///        _ringHash      The hash of the ring\n', '    ///        _feeRecipient  The recipient of the matching fee\n', '    ///        _fills         The info of the orders in the ring stored like:\n', '    ///                       [orderHash, owner, tokenS, amountS, split, feeAmount, feeAmountS, feeAmountB]\n', '    event RingMined(\n', '        uint            _ringIndex,\n', '        bytes32 indexed _ringHash,\n', '        address indexed _feeRecipient,\n', '        bytes           _fills\n', '    );\n', '\n', '    /// @dev   Event emitted when a ring was not successfully mined\n', '    ///         _ringHash  The hash of the ring\n', '    event InvalidRing(\n', '        bytes32 _ringHash\n', '    );\n', '\n', '    /// @dev   Submit order-rings for validation and settlement.\n', '    /// @param data Packed data of all rings.\n', '    function submitRings(\n', '        bytes calldata data\n', '        )\n', '        external;\n', '}\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title MiningHelper\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'library MiningHelper {\n', '\n', '    function updateMinerAndInterceptor(\n', '        Data.Mining memory mining\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '\n', '        if (mining.miner == address(0x0)) {\n', '            mining.miner = mining.feeRecipient;\n', '        }\n', '\n', '        // We do not support any interceptors for now\n', '        /* else { */\n', '        /*     (bool registered, address interceptor) = ctx.minerBrokerRegistry.getBroker( */\n', '        /*         mining.feeRecipient, */\n', '        /*         mining.miner */\n', '        /*     ); */\n', '        /*     if (registered) { */\n', '        /*         mining.interceptor = interceptor; */\n', '        /*     } */\n', '        /* } */\n', '    }\n', '\n', '    function updateHash(\n', '        Data.Mining memory mining,\n', '        Data.Ring[] memory rings\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        bytes32 hash;\n', '        assembly {\n', '            let ring := mload(add(rings, 32))                               // rings[0]\n', '            let ringHashes := mload(add(ring, 64))                          // ring.hash\n', '            for { let i := 1 } lt(i, mload(rings)) { i := add(i, 1) } {\n', '                ring := mload(add(rings, mul(add(i, 1), 32)))               // rings[i]\n', '                ringHashes := xor(ringHashes, mload(add(ring, 64)))         // ring.hash\n', '            }\n', '            let data := mload(0x40)\n', '            data := add(data, 12)\n', '            // Store data back to front to allow overwriting data at the front because of padding\n', '            mstore(add(data, 40), ringHashes)                               // ringHashes\n', '            mstore(sub(add(data, 20), 12), mload(add(mining, 32)))          // mining.miner\n', '            mstore(sub(data, 12),          mload(add(mining,  0)))          // mining.feeRecipient\n', '            hash := keccak256(data, 72)                                     // 20 + 20 + 32\n', '        }\n', '        mining.hash = hash;\n', '    }\n', '\n', '    function checkMinerSignature(\n', '        Data.Mining memory mining\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (mining.sig.length == 0) {\n', '            return (msg.sender == mining.miner);\n', '        } else {\n', '            return MultihashUtil.verifySignature(\n', '                mining.miner,\n', '                mining.hash,\n', '                mining.sig\n', '            );\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title OrderHelper\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'library OrderHelper {\n', '    using MathUint      for uint;\n', '\n', '    string constant internal EIP191_HEADER = "\\x19\\x01";\n', '    string constant internal EIP712_DOMAIN_NAME = "Loopring Protocol";\n', '    string constant internal EIP712_DOMAIN_VERSION = "2";\n', '    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(\n', '        abi.encodePacked(\n', '            "EIP712Domain(",\n', '            "string name,",\n', '            "string version",\n', '            ")"\n', '        )\n', '    );\n', '    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(\n', '        abi.encodePacked(\n', '            "Order(",\n', '            "uint amountS,",\n', '            "uint amountB,",\n', '            "uint feeAmount,",\n', '            "uint validSince,",\n', '            "uint validUntil,",\n', '            "address owner,",\n', '            "address tokenS,",\n', '            "address tokenB,",\n', '            "address dualAuthAddr,",\n', '            "address broker,",\n', '            "address orderInterceptor,",\n', '            "address wallet,",\n', '            "address tokenRecipient,",\n', '            "address feeToken,",\n', '            "uint16 walletSplitPercentage,",\n', '            "uint16 tokenSFeePercentage,",\n', '            "uint16 tokenBFeePercentage,",\n', '            "bool allOrNone,",\n', '            "uint8 tokenTypeS,",\n', '            "uint8 tokenTypeB,",\n', '            "uint8 tokenTypeFee,",\n', '            "bytes32 trancheS,",\n', '            "bytes32 trancheB,",\n', '            "bytes transferDataS",\n', '            ")"\n', '        )\n', '    );\n', '    bytes32 constant internal EIP712_DOMAIN_HASH = keccak256(\n', '        abi.encodePacked(\n', '            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n', '            keccak256(bytes(EIP712_DOMAIN_NAME)),\n', '            keccak256(bytes(EIP712_DOMAIN_VERSION))\n', '        )\n', '    );\n', '\n', '    function updateHash(Data.Order memory order)\n', '        internal\n', '        pure\n', '    {\n', '        /* bytes32 message = keccak256( */\n', '        /*     abi.encode( */\n', '        /*         EIP712_ORDER_SCHEMA_HASH, */\n', '        /*         order.amountS, */\n', '        /*         order.amountB, */\n', '        /*         order.feeAmount, */\n', '        /*         order.validSince, */\n', '        /*         order.validUntil, */\n', '        /*         order.owner, */\n', '        /*         order.tokenS, */\n', '        /*         order.tokenB, */\n', '        /*         order.dualAuthAddr, */\n', '        /*         order.broker, */\n', '        /*         order.orderInterceptor, */\n', '        /*         order.wallet, */\n', '        /*         order.tokenRecipient */\n', '        /*         order.feeToken, */\n', '        /*         order.walletSplitPercentage, */\n', '        /*         order.tokenSFeePercentage, */\n', '        /*         order.tokenBFeePercentage, */\n', '        /*         order.allOrNone, */\n', '        /*         order.tokenTypeS, */\n', '        /*         order.tokenTypeB, */\n', '        /*         order.tokenTypeFee, */\n', '        /*         order.trancheS, */\n', '        /*         order.trancheB, */\n', '        /*         order.transferDataS */\n', '        /*     ) */\n', '        /* ); */\n', '        /* order.hash = keccak256( */\n', '        /*    abi.encodePacked( */\n', '        /*        EIP191_HEADER, */\n', '        /*        EIP712_DOMAIN_HASH, */\n', '        /*        message */\n', '        /*    ) */\n', '        /*); */\n', '\n', '        // Precalculated EIP712_ORDER_SCHEMA_HASH amd EIP712_DOMAIN_HASH because\n', "        // the solidity compiler doesn't correctly precalculate them for us.\n", '        bytes32 _EIP712_ORDER_SCHEMA_HASH = 0x40b942178d2a51f1f61934268590778feb8114db632db7d88537c98d2b05c5f2;\n', '        bytes32 _EIP712_DOMAIN_HASH = 0xaea25658c273c666156bd427f83a666135fcde6887a6c25fc1cd1562bc4f3f34;\n', '\n', '        bytes32 hash;\n', '        assembly {\n', '            // Calculate the hash for transferDataS separately\n', '            let transferDataS := mload(add(order, 1184))              // order.transferDataS\n', '            let transferDataSHash := keccak256(add(transferDataS, 32), mload(transferDataS))\n', '\n', '            let ptr := mload(64)\n', '            mstore(add(ptr,   0), _EIP712_ORDER_SCHEMA_HASH)     // EIP712_ORDER_SCHEMA_HASH\n', '            mstore(add(ptr,  32), mload(add(order, 128)))        // order.amountS\n', '            mstore(add(ptr,  64), mload(add(order, 160)))        // order.amountB\n', '            mstore(add(ptr,  96), mload(add(order, 640)))        // order.feeAmount\n', '            mstore(add(ptr, 128), mload(add(order, 192)))        // order.validSince\n', '            mstore(add(ptr, 160), mload(add(order, 480)))        // order.validUntil\n', '            mstore(add(ptr, 192), mload(add(order,  32)))        // order.owner\n', '            mstore(add(ptr, 224), mload(add(order,  64)))        // order.tokenS\n', '            mstore(add(ptr, 256), mload(add(order,  96)))        // order.tokenB\n', '            mstore(add(ptr, 288), mload(add(order, 288)))        // order.dualAuthAddr\n', '            mstore(add(ptr, 320), mload(add(order, 320)))        // order.broker\n', '            mstore(add(ptr, 352), mload(add(order, 416)))        // order.orderInterceptor\n', '            mstore(add(ptr, 384), mload(add(order, 448)))        // order.wallet\n', '            mstore(add(ptr, 416), mload(add(order, 768)))        // order.tokenRecipient\n', '            mstore(add(ptr, 448), mload(add(order, 608)))        // order.feeToken\n', '            mstore(add(ptr, 480), mload(add(order, 800)))        // order.walletSplitPercentage\n', '            mstore(add(ptr, 512), mload(add(order, 704)))        // order.tokenSFeePercentage\n', '            mstore(add(ptr, 544), mload(add(order, 736)))        // order.tokenBFeePercentage\n', '            mstore(add(ptr, 576), mload(add(order, 576)))        // order.allOrNone\n', '            mstore(add(ptr, 608), mload(add(order, 1024)))       // order.tokenTypeS\n', '            mstore(add(ptr, 640), mload(add(order, 1056)))       // order.tokenTypeB\n', '            mstore(add(ptr, 672), mload(add(order, 1088)))       // order.tokenTypeFee\n', '            mstore(add(ptr, 704), mload(add(order, 1120)))       // order.trancheS\n', '            mstore(add(ptr, 736), mload(add(order, 1152)))       // order.trancheB\n', '            mstore(add(ptr, 768), transferDataSHash)             // keccak256(order.transferDataS)\n', '            let message := keccak256(ptr, 800)                   // 25 * 32\n', '\n', '            mstore(add(ptr,  0), 0x1901)                         // EIP191_HEADER\n', '            mstore(add(ptr, 32), _EIP712_DOMAIN_HASH)            // EIP712_DOMAIN_HASH\n', '            mstore(add(ptr, 64), message)                        // message\n', '            hash := keccak256(add(ptr, 30), 66)                  // 2 + 32 + 32\n', '        }\n', '        order.hash = hash;\n', '    }\n', '\n', '    function updateBrokerAndInterceptor(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        if (order.broker == address(0x0)) {\n', '            order.broker = order.owner;\n', '        } else {\n', '            bool registered;\n', '            (registered, /*order.brokerInterceptor*/) = ctx.orderBrokerRegistry.getBroker(\n', '                order.owner,\n', '                order.broker\n', '            );\n', '            order.valid = order.valid && registered;\n', '        }\n', '    }\n', '\n', '    function check(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        // If the order was already partially filled\n', "        // we don't have to check all of the infos and the signature again\n", '        if(order.filledAmountS == 0) {\n', '            validateAllInfo(order, ctx);\n', '            checkBrokerSignature(order, ctx);\n', '        } else {\n', '            validateUnstableInfo(order, ctx);\n', '        }\n', '\n', '        checkP2P(order);\n', '    }\n', '\n', '    function validateAllInfo(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        bool valid = true;\n', '        valid = valid && (order.version == 0); // unsupported order version\n', '        valid = valid && (order.owner != address(0x0)); // invalid order owner\n', '        valid = valid && (order.tokenS != address(0x0)); // invalid order tokenS\n', '        valid = valid && (order.tokenB != address(0x0)); // invalid order tokenB\n', '        valid = valid && (order.amountS != 0); // invalid order amountS\n', '        valid = valid && (order.amountB != 0); // invalid order amountB\n', '        valid = valid && (order.feeToken != address(0x0)); // invalid fee token\n', '\n', '        valid = valid && (order.tokenSFeePercentage < ctx.feePercentageBase); // invalid tokenS percentage\n', '        valid = valid && (order.tokenBFeePercentage < ctx.feePercentageBase); // invalid tokenB percentage\n', '        valid = valid && (order.walletSplitPercentage <= 100); // invalid wallet split percentage\n', '\n', '        // We only support ERC20 for now\n', '        valid = valid && (order.tokenTypeS == Data.TokenType.ERC20 && order.trancheS == 0x0);\n', '        valid = valid && (order.tokenTypeB == Data.TokenType.ERC20 && order.trancheB == 0x0);\n', '        valid = valid && (order.tokenTypeFee == Data.TokenType.ERC20);\n', '        valid = valid && (order.transferDataS.length == 0);\n', '\n', '        valid = valid && (order.validSince <= now); // order is too early to match\n', '\n', '        order.valid = order.valid && valid;\n', '\n', '        validateUnstableInfo(order, ctx);\n', '    }\n', '\n', '\n', '    function validateUnstableInfo(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        bool valid = true;\n', '        valid = valid && (order.validUntil == 0 || order.validUntil > now);  // order is expired\n', '        valid = valid && (order.waiveFeePercentage <= int16(ctx.feePercentageBase)); // invalid waive percentage\n', '        valid = valid && (order.waiveFeePercentage >= -int16(ctx.feePercentageBase)); // invalid waive percentage\n', '        if (order.dualAuthAddr != address(0x0)) { // if dualAuthAddr exists, dualAuthSig must be exist.\n', '            valid = valid && (order.dualAuthSig.length > 0);\n', '        }\n', '        order.valid = order.valid && valid;\n', '    }\n', '\n', '\n', '    function checkP2P(\n', '        Data.Order memory order\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        order.P2P = (order.tokenSFeePercentage > 0 || order.tokenBFeePercentage > 0);\n', '    }\n', '\n', '\n', '    function checkBrokerSignature(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        if (order.sig.length == 0) {\n', '            bool registered = ctx.orderRegistry.isOrderHashRegistered(\n', '                order.broker,\n', '                order.hash\n', '            );\n', '\n', '            if (!registered) {\n', '                order.valid = order.valid && ctx.orderBook.orderSubmitted(order.hash);\n', '            }\n', '        } else {\n', '            order.valid = order.valid && MultihashUtil.verifySignature(\n', '                order.broker,\n', '                order.hash,\n', '                order.sig\n', '            );\n', '        }\n', '    }\n', '\n', '    function checkDualAuthSignature(\n', '        Data.Order memory order,\n', '        bytes32 miningHash\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        if (order.dualAuthSig.length != 0) {\n', '            order.valid = order.valid && MultihashUtil.verifySignature(\n', '                order.dualAuthAddr,\n', '                miningHash,\n', '                order.dualAuthSig\n', '            );\n', '        }\n', '    }\n', '\n', '    function validateAllOrNone(\n', '        Data.Order memory order\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Check if this order needs to be completely filled\n', '        if(order.allOrNone) {\n', '            order.valid = order.valid && (order.filledAmountS == order.amountS);\n', '        }\n', '    }\n', '\n', '    function getSpendableS(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return getSpendable(\n', '            ctx.delegate,\n', '            order.tokenS,\n', '            order.owner,\n', '            order.tokenSpendableS\n', '        );\n', '    }\n', '\n', '    function getSpendableFee(\n', '        Data.Order memory order,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return getSpendable(\n', '            ctx.delegate,\n', '            order.feeToken,\n', '            order.owner,\n', '            order.tokenSpendableFee\n', '        );\n', '    }\n', '\n', '    function reserveAmountS(\n', '        Data.Order memory order,\n', '        uint amount\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        order.tokenSpendableS.reserved += amount;\n', '    }\n', '\n', '    function reserveAmountFee(\n', '        Data.Order memory order,\n', '        uint amount\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        order.tokenSpendableFee.reserved += amount;\n', '    }\n', '\n', '    function resetReservations(\n', '        Data.Order memory order\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        order.tokenSpendableS.reserved = 0;\n', '        order.tokenSpendableFee.reserved = 0;\n', '    }\n', '\n', '    /// @return Amount of ERC20 token that can be spent by this contract.\n', '    function getERC20Spendable(\n', '        ITradeDelegate delegate,\n', '        address tokenAddress,\n', '        address owner\n', '        )\n', '        private\n', '        view\n', '        returns (uint spendable)\n', '    {\n', '        ERC20 token = ERC20(tokenAddress);\n', '        spendable = token.allowance(\n', '            owner,\n', '            address(delegate)\n', '        );\n', '        if (spendable != 0) {\n', '            uint balance = token.balanceOf(owner);\n', '            spendable = (balance < spendable) ? balance : spendable;\n', '        }\n', '    }\n', '\n', '    function getSpendable(\n', '        ITradeDelegate delegate,\n', '        address tokenAddress,\n', '        address owner,\n', '        Data.Spendable memory tokenSpendable\n', '        )\n', '        private\n', '        view\n', '        returns (uint spendable)\n', '    {\n', '        if (!tokenSpendable.initialized) {\n', '            tokenSpendable.amount = getERC20Spendable(\n', '                delegate,\n', '                tokenAddress,\n', '                owner\n', '            );\n', '            tokenSpendable.initialized = true;\n', '        }\n', '        spendable = tokenSpendable.amount.sub(tokenSpendable.reserved);\n', '    }\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ParticipationHelper\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'library ParticipationHelper {\n', '    using MathUint for uint;\n', '    using OrderHelper for Data.Order;\n', '\n', '    function setMaxFillAmounts(\n', '        Data.Participation memory p,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        uint spendableS = p.order.getSpendableS(ctx);\n', '        uint remainingS = p.order.amountS.sub(p.order.filledAmountS);\n', '        p.fillAmountS = (spendableS < remainingS) ? spendableS : remainingS;\n', '\n', '        if (!p.order.P2P) {\n', '            // No need to check the fee balance of the owner if feeToken == tokenB,\n', '            // fillAmountB will be used to pay the fee.\n', '            if (!(p.order.feeToken == p.order.tokenB &&\n', '                  p.order.owner == p.order.tokenRecipient &&\n', '                  p.order.feeAmount <= p.order.amountB)) {\n', '                // Check how much fee needs to be paid. We limit fillAmountS to how much\n', '                // fee the order owner can pay.\n', '                uint feeAmount = p.order.feeAmount.mul(p.fillAmountS) / p.order.amountS;\n', '                if (feeAmount > 0) {\n', '                    uint spendableFee = p.order.getSpendableFee(ctx);\n', '                    if (p.order.feeToken == p.order.tokenS && p.fillAmountS + feeAmount > spendableS) {\n', '                        assert(spendableFee == spendableS);\n', '                        // Equally divide the available tokens between fillAmountS and feeAmount\n', '                        uint totalAmount = p.order.amountS.add(p.order.feeAmount);\n', '                        p.fillAmountS = spendableS.mul(p.order.amountS) / totalAmount;\n', '                        feeAmount = spendableS.mul(p.order.feeAmount) / totalAmount;\n', '                    } else if (feeAmount > spendableFee) {\n', '                        // Scale down fillAmountS so the available feeAmount is sufficient\n', '                        feeAmount = spendableFee;\n', '                        p.fillAmountS = feeAmount.mul(p.order.amountS) / p.order.feeAmount;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        p.fillAmountB = p.fillAmountS.mul(p.order.amountB) / p.order.amountS;\n', '    }\n', '\n', '    function calculateFees(\n', '        Data.Participation memory p,\n', '        Data.Participation memory prevP,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (p.order.P2P) {\n', '            // Calculate P2P fees\n', '            p.feeAmount = 0;\n', '            p.feeAmountS = p.fillAmountS.mul(p.order.tokenSFeePercentage) / ctx.feePercentageBase;\n', '            p.feeAmountB = p.fillAmountB.mul(p.order.tokenBFeePercentage) / ctx.feePercentageBase;\n', '        } else {\n', '            // Calculate matching fees\n', '            p.feeAmount = p.order.feeAmount.mul(p.fillAmountS) / p.order.amountS;\n', '            p.feeAmountS = 0;\n', '            p.feeAmountB = 0;\n', '\n', '            // If feeToken == tokenB AND owner == tokenRecipient, try to pay using fillAmountB\n', '\n', '            if (p.order.feeToken == p.order.tokenB &&\n', '                p.order.owner == p.order.tokenRecipient &&\n', '                p.fillAmountB >= p.feeAmount) {\n', '                p.feeAmountB = p.feeAmount;\n', '                p.feeAmount = 0;\n', '            }\n', '\n', '            if (p.feeAmount > 0) {\n', '                // Make sure we can pay the feeAmount\n', '                uint spendableFee = p.order.getSpendableFee(ctx);\n', '                if (p.feeAmount > spendableFee) {\n', '                    // This normally should not happen, but this is possible when self-trading\n', '                    return false;\n', '                } else {\n', '                    p.order.reserveAmountFee(p.feeAmount);\n', '                }\n', '            }\n', '        }\n', '\n', '        if ((p.fillAmountS - p.feeAmountS) >= prevP.fillAmountB) {\n', '            // The miner (or in a P2P case, the taker) gets the margin\n', '            p.splitS = (p.fillAmountS - p.feeAmountS) - prevP.fillAmountB;\n', '            p.fillAmountS = prevP.fillAmountB + p.feeAmountS;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function checkFills(\n', '        Data.Participation memory p\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool valid)\n', '    {\n', '        // Check if the rounding error of the calculated fillAmountB is larger than 1%.\n', "        // If that's the case, this partipation in invalid\n", '        // p.fillAmountB := p.fillAmountS.mul(p.order.amountB) / p.order.amountS\n', '        valid = !MathUint.hasRoundingError(\n', '            p.fillAmountS,\n', '            p.order.amountB,\n', '            p.order.amountS\n', '        );\n', '\n', '        // We at least need to buy and sell something\n', '        valid = valid && p.fillAmountS > 0;\n', '        valid = valid && p.fillAmountB > 0;\n', '    }\n', '\n', '    function adjustOrderState(\n', '        Data.Participation memory p\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Update filled amount\n', '        p.order.filledAmountS += p.fillAmountS + p.splitS;\n', '\n', '        // Update spendables\n', '        uint totalAmountS = p.fillAmountS + p.splitS;\n', '        uint totalAmountFee = p.feeAmount;\n', '        p.order.tokenSpendableS.amount = p.order.tokenSpendableS.amount.sub(totalAmountS);\n', '        p.order.tokenSpendableFee.amount = p.order.tokenSpendableFee.amount.sub(totalAmountFee);\n', '        if (p.order.brokerInterceptor != address(0x0)) {\n', '            p.order.brokerSpendableS.amount = p.order.brokerSpendableS.amount.sub(totalAmountS);\n', '            p.order.brokerSpendableFee.amount = p.order.brokerSpendableFee.amount.sub(totalAmountFee);\n', '        }\n', '    }\n', '\n', '    function revertOrderState(\n', '        Data.Participation memory p\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Revert filled amount\n', '        p.order.filledAmountS = p.order.filledAmountS.sub(p.fillAmountS + p.splitS);\n', '\n', "        // We do not revert any spendables. Rings will not get rebalanced so this doesn't matter.\n", '    }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title RingHelper\n', 'library RingHelper {\n', '    using MathUint for uint;\n', '    using OrderHelper for Data.Order;\n', '    using ParticipationHelper for Data.Participation;\n', '\n', '    function updateHash(\n', '        Data.Ring memory ring\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint ringSize = ring.size;\n', '        bytes32 hash;\n', '        assembly {\n', '            let data := mload(0x40)\n', '            let ptr := data\n', '            let participations := mload(add(ring, 32))                                  // ring.participations\n', '            for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {\n', '                let participation := mload(add(participations, add(32, mul(i, 32))))    // participations[i]\n', '                let order := mload(participation)                                       // participation.order\n', '\n', '                let waiveFeePercentage := and(mload(add(order, 672)), 0xFFFF)           // order.waiveFeePercentage\n', '                let orderHash := mload(add(order, 864))                                 // order.hash\n', '\n', '                mstore(add(ptr, 2), waiveFeePercentage)\n', '                mstore(ptr, orderHash)\n', '\n', '                ptr := add(ptr, 34)\n', '            }\n', '            hash := keccak256(data, sub(ptr, data))\n', '        }\n', '        ring.hash = hash;\n', '    }\n', '\n', '    function calculateFillAmountAndFee(\n', '        Data.Ring memory ring,\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '    {\n', '        // Invalid order data could cause a divide by zero in the calculations\n', '        if (!ring.valid) {\n', '            return;\n', '        }\n', '\n', '        uint i;\n', '        int j;\n', '        uint prevIndex;\n', '\n', '        for (i = 0; i < ring.size; i++) {\n', '            ring.participations[i].setMaxFillAmounts(\n', '                ctx\n', '            );\n', '        }\n', '\n', '        uint smallest = 0;\n', '        for (j = int(ring.size) - 1; j >= 0; j--) {\n', '            prevIndex = (uint(j) + ring.size - 1) % ring.size;\n', '            smallest = calculateOrderFillAmounts(\n', '                ctx,\n', '                ring.participations[uint(j)],\n', '                ring.participations[prevIndex],\n', '                uint(j),\n', '                smallest\n', '            );\n', '        }\n', '        for (j = int(ring.size) - 1; j >= int(smallest); j--) {\n', '            prevIndex = (uint(j) + ring.size - 1) % ring.size;\n', '            calculateOrderFillAmounts(\n', '                ctx,\n', '                ring.participations[uint(j)],\n', '                ring.participations[prevIndex],\n', '                uint(j),\n', '                smallest\n', '            );\n', '        }\n', '\n', '        for (i = 0; i < ring.size; i++) {\n', '            // Check if the fill amounts of the participation are valid\n', '            ring.valid = ring.valid && ring.participations[i].checkFills();\n', '\n', '            // Reserve the total amount tokenS used for all the orders\n', '            // (e.g. the owner of order 0 could use LRC as feeToken in order 0, while\n', '            // the same owner can also sell LRC in order 2).\n', '            ring.participations[i].order.reserveAmountS(ring.participations[i].fillAmountS);\n', '        }\n', '\n', '        for (i = 0; i < ring.size; i++) {\n', '            prevIndex = (i + ring.size - 1) % ring.size;\n', '\n', '            // Check if we can transfer the tokens (if ST-20)\n', '            ring.valid = ring.valid && verifyTransferProxy(\n', '                ring.participations[i].order.tokenS,\n', '                ring.participations[i].order.owner,\n', '                ring.participations[prevIndex].order.tokenRecipient,\n', '                ring.participations[i].fillAmountS\n', '            );\n', '\n', '            bool valid = ring.participations[i].calculateFees(ring.participations[prevIndex], ctx);\n', '            if (!valid) {\n', '                ring.valid = false;\n', '                break;\n', '            }\n', '\n', '            int16 waiveFeePercentage = ring.participations[i].order.waiveFeePercentage;\n', '            if (waiveFeePercentage < 0) {\n', '                ring.minerFeesToOrdersPercentage += uint(-waiveFeePercentage);\n', '            }\n', '        }\n', '        // Miner can only distribute 100% of its fees to all orders combined\n', '        ring.valid = ring.valid && (ring.minerFeesToOrdersPercentage <= ctx.feePercentageBase);\n', '\n', '        // Ring calculations are done. Make sure te remove all spendable reservations for this ring\n', '        for (i = 0; i < ring.size; i++) {\n', '            ring.participations[i].order.resetReservations();\n', '        }\n', '    }\n', '\n', '    // ST-20: transfer, transferFrom must respect the result of verifyTransfer\n', '    function verifyTransferProxy(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC20(token).verifyTransfer.selector,\n', '            from,\n', '            to,\n', '            amount,\n', '            new bytes(0)\n', '        );\n', '        (bool success, bytes memory returnData) = token.call(callData);\n', '        // We expect a single boolean as the return value\n', '        if (success && returnData.length == 32) {\n', '            // Check if a boolean was returned\n', '            assembly {\n', '                success := mload(add(returnData, 32))\n', '            }\n', '            return success;\n', '        } else {\n', '            // No function found, normal ERC20 token\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function calculateOrderFillAmounts(\n', '        Data.Context memory ctx,\n', '        Data.Participation memory p,\n', '        Data.Participation memory prevP,\n', '        uint i,\n', '        uint smallest\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint smallest_)\n', '    {\n', '        // Default to the same smallest index\n', '        smallest_ = smallest;\n', '\n', '        uint postFeeFillAmountS = p.fillAmountS;\n', '        uint tokenSFeePercentage = p.order.tokenSFeePercentage;\n', '        if (tokenSFeePercentage > 0) {\n', '            uint feeAmountS = p.fillAmountS.mul(tokenSFeePercentage) / ctx.feePercentageBase;\n', '            postFeeFillAmountS = p.fillAmountS - feeAmountS;\n', '        }\n', '\n', '        if (prevP.fillAmountB > postFeeFillAmountS) {\n', '            smallest_ = i;\n', '            prevP.fillAmountB = postFeeFillAmountS;\n', '            prevP.fillAmountS = postFeeFillAmountS.mul(prevP.order.amountS) / prevP.order.amountB;\n', '        }\n', '    }\n', '\n', '    function checkOrdersValid(\n', '        Data.Ring memory ring\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        ring.valid = ring.valid && (ring.size > 1 && ring.size <= 8); // invalid ring size\n', '        for (uint i = 0; i < ring.size; i++) {\n', '            uint prev = (i + ring.size - 1) % ring.size;\n', '            ring.valid = ring.valid && ring.participations[i].order.valid;\n', '            ring.valid = ring.valid && ring.participations[i].order.tokenS == ring.participations[prev].order.tokenB;\n', '        }\n', '    }\n', '\n', '    function checkForSubRings(\n', '        Data.Ring memory ring\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        for (uint i = 0; i < ring.size - 1; i++) {\n', '            address tokenS = ring.participations[i].order.tokenS;\n', '            for (uint j = i + 1; j < ring.size; j++) {\n', '                ring.valid = ring.valid && (tokenS != ring.participations[j].order.tokenS);\n', '            }\n', '        }\n', '    }\n', '\n', '    function adjustOrderStates(\n', '        Data.Ring memory ring\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Adjust the orders\n', '        for (uint i = 0; i < ring.size; i++) {\n', '            ring.participations[i].adjustOrderState();\n', '        }\n', '    }\n', '\n', '\n', '    function revertOrderStats(\n', '        Data.Ring memory ring\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        for (uint i = 0; i < ring.size; i++) {\n', '            ring.participations[i].revertOrderState();\n', '        }\n', '    }\n', '\n', '    function doPayments(\n', '        Data.Ring memory ring,\n', '        Data.Context memory ctx,\n', '        Data.Mining memory mining\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        payFees(ring, ctx, mining);\n', '        transferTokens(ring, ctx, mining.feeRecipient);\n', '    }\n', '\n', '    function generateFills(\n', '        Data.Ring memory ring,\n', '        uint destPtr\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint fill)\n', '    {\n', '        uint ringSize = ring.size;\n', '        uint fillSize = 8 * 32;\n', '        assembly {\n', '            fill := destPtr\n', '            let participations := mload(add(ring, 32))                                 // ring.participations\n', '\n', '            for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {\n', '                let participation := mload(add(participations, add(32, mul(i, 32))))   // participations[i]\n', '                let order := mload(participation)                                      // participation.order\n', '\n', '                // Calculate the actual fees paid after rebate\n', '                let feeAmount := sub(\n', '                    mload(add(participation, 64)),                                      // participation.feeAmount\n', '                    mload(add(participation, 160))                                      // participation.rebateFee\n', '                )\n', '                let feeAmountS := sub(\n', '                    mload(add(participation, 96)),                                      // participation.feeAmountS\n', '                    mload(add(participation, 192))                                      // participation.rebateFeeS\n', '                )\n', '                let feeAmountB := sub(\n', '                    mload(add(participation, 128)),                                     // participation.feeAmountB\n', '                    mload(add(participation, 224))                                      // participation.rebateFeeB\n', '                )\n', '\n', '                mstore(add(fill,   0), mload(add(order, 864)))                         // order.hash\n', '                mstore(add(fill,  32), mload(add(order,  32)))                         // order.owner\n', '                mstore(add(fill,  64), mload(add(order,  64)))                         // order.tokenS\n', '                mstore(add(fill,  96), mload(add(participation, 256)))                 // participation.fillAmountS\n', '                mstore(add(fill, 128), mload(add(participation,  32)))                 // participation.splitS\n', '                mstore(add(fill, 160), feeAmount)                                      // feeAmount\n', '                mstore(add(fill, 192), feeAmountS)                                     // feeAmountS\n', '                mstore(add(fill, 224), feeAmountB)                                     // feeAmountB\n', '\n', '                fill := add(fill, fillSize)\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferTokens(\n', '        Data.Ring memory ring,\n', '        Data.Context memory ctx,\n', '        address feeRecipient\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        for (uint i = 0; i < ring.size; i++) {\n', '            transferTokensForParticipation(\n', '                ctx,\n', '                feeRecipient,\n', '                ring.participations[i],\n', '                ring.participations[(i + ring.size - 1) % ring.size]\n', '            );\n', '        }\n', '    }\n', '\n', '    function transferTokensForParticipation(\n', '        Data.Context memory ctx,\n', '        address feeRecipient,\n', '        Data.Participation memory p,\n', '        Data.Participation memory prevP\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint buyerFeeAmountAfterRebateB = prevP.feeAmountB.sub(prevP.rebateB);\n', '\n', '        // If the buyer needs to pay fees in tokenB, the seller needs\n', '        // to send the tokenS amount to the fee holder contract\n', '        uint amountSToBuyer = p.fillAmountS\n', '            .sub(p.feeAmountS)\n', '            .sub(buyerFeeAmountAfterRebateB);\n', '\n', '        uint amountSToFeeHolder = p.feeAmountS\n', '            .sub(p.rebateS)\n', '            .add(buyerFeeAmountAfterRebateB);\n', '\n', '        uint amountFeeToFeeHolder = p.feeAmount\n', '            .sub(p.rebateFee);\n', '\n', '        if (p.order.tokenS == p.order.feeToken) {\n', '            amountSToFeeHolder = amountSToFeeHolder.add(amountFeeToFeeHolder);\n', '            amountFeeToFeeHolder = 0;\n', '        }\n', '\n', '        // Transfers\n', '        ctx.transferPtr = addTokenTransfer(\n', '            ctx.transferData,\n', '            ctx.transferPtr,\n', '            p.order.feeToken,\n', '            p.order.owner,\n', '            address(ctx.feeHolder),\n', '            amountFeeToFeeHolder\n', '        );\n', '        ctx.transferPtr = addTokenTransfer(\n', '            ctx.transferData,\n', '            ctx.transferPtr,\n', '            p.order.tokenS,\n', '            p.order.owner,\n', '            address(ctx.feeHolder),\n', '            amountSToFeeHolder\n', '        );\n', '        ctx.transferPtr = addTokenTransfer(\n', '            ctx.transferData,\n', '            ctx.transferPtr,\n', '            p.order.tokenS,\n', '            p.order.owner,\n', '            prevP.order.tokenRecipient,\n', '            amountSToBuyer\n', '        );\n', '\n', '        // Miner (or for P2P the taker) gets the margin without sharing it with the wallet or burning\n', '        ctx.transferPtr = addTokenTransfer(\n', '            ctx.transferData,\n', '            ctx.transferPtr,\n', '            p.order.tokenS,\n', '            p.order.owner,\n', '            feeRecipient,\n', '            p.splitS\n', '        );\n', '    }\n', '\n', '    function addTokenTransfer(\n', '        uint data,\n', '        uint ptr,\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint amount\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        if (amount > 0 && from != to) {\n', '            assembly {\n', '                // Try to find an existing fee payment of the same token to the same owner\n', '                let addNew := 1\n', '                for { let p := data } lt(p, ptr) { p := add(p, 128) } {\n', '                    let dataToken := mload(add(p,  0))\n', '                    let dataFrom := mload(add(p, 32))\n', '                    let dataTo := mload(add(p, 64))\n', '                    // if(token == dataToken && from == dataFrom && to == dataTo)\n', '                    if and(and(eq(token, dataToken), eq(from, dataFrom)), eq(to, dataTo)) {\n', '                        let dataAmount := mload(add(p, 96))\n', '                        // dataAmount = amount.add(dataAmount);\n', '                        dataAmount := add(amount, dataAmount)\n', '                        // require(dataAmount >= amount) (safe math)\n', '                        if lt(dataAmount, amount) {\n', '                            revert(0, 0)\n', '                        }\n', '                        mstore(add(p, 96), dataAmount)\n', '                        addNew := 0\n', '                        // End the loop\n', '                        p := ptr\n', '                    }\n', '                }\n', '                // Add a new transfer\n', '                if eq(addNew, 1) {\n', '                    mstore(add(ptr,  0), token)\n', '                    mstore(add(ptr, 32), from)\n', '                    mstore(add(ptr, 64), to)\n', '                    mstore(add(ptr, 96), amount)\n', '                    ptr := add(ptr, 128)\n', '                }\n', '            }\n', '            return ptr;\n', '        } else {\n', '            return ptr;\n', '        }\n', '    }\n', '\n', '    function payFees(\n', '        Data.Ring memory ring,\n', '        Data.Context memory ctx,\n', '        Data.Mining memory mining\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        Data.FeeContext memory feeCtx;\n', '        feeCtx.ring = ring;\n', '        feeCtx.ctx = ctx;\n', '        feeCtx.feeRecipient = mining.feeRecipient;\n', '        for (uint i = 0; i < ring.size; i++) {\n', '            payFeesForParticipation(\n', '                feeCtx,\n', '                ring.participations[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    function payFeesForParticipation(\n', '        Data.FeeContext memory feeCtx,\n', '        Data.Participation memory p\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        feeCtx.walletPercentage = p.order.P2P ? 100 : (\n', '            (p.order.wallet == address(0x0) ? 0 : p.order.walletSplitPercentage)\n', '        );\n', '        feeCtx.waiveFeePercentage = p.order.waiveFeePercentage;\n', '        feeCtx.owner = p.order.owner;\n', '        feeCtx.wallet = p.order.wallet;\n', '        feeCtx.P2P = p.order.P2P;\n', '\n', '        p.rebateFee = payFeesAndBurn(\n', '            feeCtx,\n', '            p.order.feeToken,\n', '            p.feeAmount\n', '        );\n', '        p.rebateS = payFeesAndBurn(\n', '            feeCtx,\n', '            p.order.tokenS,\n', '            p.feeAmountS\n', '        );\n', '        p.rebateB = payFeesAndBurn(\n', '            feeCtx,\n', '            p.order.tokenB,\n', '            p.feeAmountB\n', '        );\n', '    }\n', '\n', '    function payFeesAndBurn(\n', '        Data.FeeContext memory feeCtx,\n', '        address token,\n', '        uint totalAmount\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        if (totalAmount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint amount = totalAmount;\n', '        // No need to pay any fees in a P2P order without a wallet\n', '        // (but the fee amount is a part of amountS of the order, so the fee amount is rebated).\n', '        if (feeCtx.P2P && feeCtx.wallet == address(0x0)) {\n', '            amount = 0;\n', '        }\n', '\n', '        uint feeToWallet = 0;\n', '        uint minerFee = 0;\n', '        uint minerFeeBurn = 0;\n', '        uint walletFeeBurn = 0;\n', '        if (amount > 0) {\n', '            feeToWallet = amount.mul(feeCtx.walletPercentage) / 100;\n', '            minerFee = amount - feeToWallet;\n', '\n', '            // Miner can waive fees for this order. If waiveFeePercentage > 0 this is a simple reduction in fees.\n', '            if (feeCtx.waiveFeePercentage > 0) {\n', '                minerFee = minerFee.mul(\n', '                    feeCtx.ctx.feePercentageBase - uint(feeCtx.waiveFeePercentage)) /\n', '                    feeCtx.ctx.feePercentageBase;\n', '            } else if (feeCtx.waiveFeePercentage < 0) {\n', '                // No fees need to be paid by this order\n', '                minerFee = 0;\n', '            }\n', '\n', '            uint32 burnRate = getBurnRate(feeCtx, token);\n', '            assert(burnRate <= feeCtx.ctx.feePercentageBase);\n', '\n', '            // Miner fee\n', '            minerFeeBurn = minerFee.mul(burnRate) / feeCtx.ctx.feePercentageBase;\n', '            minerFee = minerFee - minerFeeBurn;\n', '            // Wallet fee\n', '            walletFeeBurn = feeToWallet.mul(burnRate) / feeCtx.ctx.feePercentageBase;\n', '            feeToWallet = feeToWallet - walletFeeBurn;\n', '\n', '            // Pay the wallet\n', '            feeCtx.ctx.feePtr = addFeePayment(\n', '                feeCtx.ctx.feeData,\n', '                feeCtx.ctx.feePtr,\n', '                token,\n', '                feeCtx.wallet,\n', '                feeToWallet\n', '            );\n', '\n', '            // Pay the burn rate with the feeHolder as owner\n', '            feeCtx.ctx.feePtr = addFeePayment(\n', '                feeCtx.ctx.feeData,\n', '                feeCtx.ctx.feePtr,\n', '                token,\n', '                address(feeCtx.ctx.feeHolder),\n', '                minerFeeBurn + walletFeeBurn\n', '            );\n', '\n', "            // Fees can be paid out in different tokens so we can't easily accumulate the total fee\n", '            // that needs to be paid out to order owners. So we pay out each part out here to all\n', '            // orders that need it.\n', '            uint feeToMiner = minerFee;\n', '            if (feeCtx.ring.minerFeesToOrdersPercentage > 0 && minerFee > 0) {\n', '                // Pay out the fees to the orders\n', '                distributeMinerFeeToOwners(\n', '                    feeCtx,\n', '                    token,\n', '                    minerFee\n', '                );\n', '                // Subtract all fees the miner pays to the orders\n', '                feeToMiner = minerFee.mul(feeCtx.ctx.feePercentageBase -\n', '                    feeCtx.ring.minerFeesToOrdersPercentage) /\n', '                    feeCtx.ctx.feePercentageBase;\n', '            }\n', '\n', '            // Pay the miner\n', '            feeCtx.ctx.feePtr = addFeePayment(\n', '                feeCtx.ctx.feeData,\n', '                feeCtx.ctx.feePtr,\n', '                token,\n', '                feeCtx.feeRecipient,\n', '                feeToMiner\n', '            );\n', '        }\n', '\n', '        // Calculate the total fee payment after possible discounts (burn rebate + fee waiving)\n', '        // and return the total rebate\n', '        return totalAmount.sub((feeToWallet + minerFee) + (minerFeeBurn + walletFeeBurn));\n', '    }\n', '\n', '    function getBurnRate(\n', '        Data.FeeContext memory feeCtx,\n', '        address token\n', '        )\n', '        internal\n', '        view\n', '        returns (uint32)\n', '    {\n', '        bytes32[] memory tokenBurnRates = feeCtx.ctx.tokenBurnRates;\n', '        uint length = tokenBurnRates.length;\n', '        for (uint i = 0; i < length; i += 2) {\n', '            if (token == address(bytes20(tokenBurnRates[i]))) {\n', '                uint32 burnRate = uint32(bytes4(tokenBurnRates[i + 1]));\n', '                return feeCtx.P2P ? (burnRate / 0x10000) : (burnRate & 0xFFFF);\n', '            }\n', '        }\n', '        // Not found, add it to the list\n', '        uint32 burnRate = feeCtx.ctx.burnRateTable.getBurnRate(token);\n', '        assembly {\n', '            let ptr := add(tokenBurnRates, mul(add(1, length), 32))\n', '            mstore(ptr, token)                              // token\n', '            mstore(add(ptr, 32), burnRate)                  // burn rate\n', '            mstore(tokenBurnRates, add(length, 2))          // length\n', '        }\n', '        return feeCtx.P2P ? (burnRate / 0x10000) : (burnRate & 0xFFFF);\n', '    }\n', '\n', '    function distributeMinerFeeToOwners(\n', '        Data.FeeContext memory feeCtx,\n', '        address token,\n', '        uint minerFee\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        for (uint i = 0; i < feeCtx.ring.size; i++) {\n', '            if (feeCtx.ring.participations[i].order.waiveFeePercentage < 0) {\n', '                uint feeToOwner = minerFee\n', '                    .mul(uint(-feeCtx.ring.participations[i].order.waiveFeePercentage)) / feeCtx.ctx.feePercentageBase;\n', '\n', '                feeCtx.ctx.feePtr = addFeePayment(\n', '                    feeCtx.ctx.feeData,\n', '                    feeCtx.ctx.feePtr,\n', '                    token,\n', '                    feeCtx.ring.participations[i].order.owner,\n', '                    feeToOwner);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addFeePayment(\n', '        uint data,\n', '        uint ptr,\n', '        address token,\n', '        address owner,\n', '        uint amount\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        if (amount == 0) {\n', '            return ptr;\n', '        } else {\n', '            assembly {\n', '                // Try to find an existing fee payment of the same token to the same owner\n', '                let addNew := 1\n', '                for { let p := data } lt(p, ptr) { p := add(p, 96) } {\n', '                    let dataToken := mload(add(p,  0))\n', '                    let dataOwner := mload(add(p, 32))\n', '                    // if(token == dataToken && owner == dataOwner)\n', '                    if and(eq(token, dataToken), eq(owner, dataOwner)) {\n', '                        let dataAmount := mload(add(p, 64))\n', '                        // dataAmount = amount.add(dataAmount);\n', '                        dataAmount := add(amount, dataAmount)\n', '                        // require(dataAmount >= amount) (safe math)\n', '                        if lt(dataAmount, amount) {\n', '                            revert(0, 0)\n', '                        }\n', '                        mstore(add(p, 64), dataAmount)\n', '                        addNew := 0\n', '                        // End the loop\n', '                        p := ptr\n', '                    }\n', '                }\n', '                // Add a new fee payment\n', '                if eq(addNew, 1) {\n', '                    mstore(add(ptr,  0), token)\n', '                    mstore(add(ptr, 32), owner)\n', '                    mstore(add(ptr, 64), amount)\n', '                    ptr := add(ptr, 96)\n', '                }\n', '            }\n', '            return ptr;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '/// @title Errors\n', 'contract Errors {\n', '    string constant ZERO_VALUE                 = "ZERO_VALUE";\n', '    string constant ZERO_ADDRESS               = "ZERO_ADDRESS";\n', '    string constant INVALID_VALUE              = "INVALID_VALUE";\n', '    string constant INVALID_ADDRESS            = "INVALID_ADDRESS";\n', '    string constant INVALID_SIZE               = "INVALID_SIZE";\n', '    string constant INVALID_SIG                = "INVALID_SIG";\n', '    string constant INVALID_STATE              = "INVALID_STATE";\n', '    string constant NOT_FOUND                  = "NOT_FOUND";\n', '    string constant ALREADY_EXIST              = "ALREADY_EXIST";\n', '    string constant REENTRY                    = "REENTRY";\n', '    string constant UNAUTHORIZED               = "UNAUTHORIZED";\n', '    string constant UNIMPLEMENTED              = "UNIMPLEMENTED";\n', '    string constant UNSUPPORTED                = "UNSUPPORTED";\n', '    string constant TRANSFER_FAILURE           = "TRANSFER_FAILURE";\n', '    string constant WITHDRAWAL_FAILURE         = "WITHDRAWAL_FAILURE";\n', '    string constant BURN_FAILURE               = "BURN_FAILURE";\n', '    string constant BURN_RATE_FROZEN           = "BURN_RATE_FROZEN";\n', '    string constant BURN_RATE_MINIMIZED        = "BURN_RATE_MINIMIZED";\n', '    string constant UNAUTHORIZED_ONCHAIN_ORDER = "UNAUTHORIZED_ONCHAIN_ORDER";\n', '    string constant INVALID_CANDIDATE          = "INVALID_CANDIDATE";\n', '    string constant ALREADY_VOTED              = "ALREADY_VOTED";\n', '    string constant NOT_OWNER                  = "NOT_OWNER";\n', '}\n', '\n', '\n', '\n', '/// @title NoDefaultFunc\n', '/// @dev Disable default functions.\n', 'contract NoDefaultFunc is Errors {\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        revert(UNSUPPORTED);\n', '    }\n', '}\n', '\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Deserializes the data passed to submitRings\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', 'library ExchangeDeserializer {\n', '    using BytesUtil     for bytes;\n', '\n', '    function deserialize(\n', '        address lrcTokenAddress,\n', '        bytes memory data\n', '        )\n', '        internal\n', '        view\n', '        returns (\n', '            Data.Mining memory mining,\n', '            Data.Order[] memory orders,\n', '            Data.Ring[] memory rings\n', '        )\n', '    {\n', '        // Read the header\n', '        Data.Header memory header;\n', '        header.version = data.bytesToUint16(0);\n', '        header.numOrders = data.bytesToUint16(2);\n', '        header.numRings = data.bytesToUint16(4);\n', '        header.numSpendables = data.bytesToUint16(6);\n', '\n', '        // Validation\n', '        require(header.version == 0, "Unsupported serialization format");\n', '        require(header.numOrders > 0, "Invalid number of orders");\n', '        require(header.numRings > 0, "Invalid number of rings");\n', '        require(header.numSpendables > 0, "Invalid number of spendables");\n', '\n', '        // Calculate data pointers\n', '        uint dataPtr;\n', '        assembly {\n', '            dataPtr := data\n', '        }\n', '        uint miningDataPtr = dataPtr + 8;\n', '        uint orderDataPtr = miningDataPtr + 3 * 2;\n', '        uint ringDataPtr = orderDataPtr + (30 * header.numOrders) * 2;\n', '        uint dataBlobPtr = ringDataPtr + (header.numRings * 9) + 32;\n', '\n', '        // The data stream needs to be at least large enough for the\n', '        // header/mining/orders/rings data + 64 bytes of zeros in the data blob.\n', '        require(data.length >= (dataBlobPtr - dataPtr) + 32, "Invalid input data");\n', '\n', '        // Setup the rings\n', '        mining = setupMiningData(dataBlobPtr, miningDataPtr + 2);\n', '        orders = setupOrders(dataBlobPtr, orderDataPtr + 2, header.numOrders, header.numSpendables, lrcTokenAddress);\n', '        rings = assembleRings(ringDataPtr + 1, header.numRings, orders);\n', '    }\n', '\n', '    function setupMiningData(\n', '        uint data,\n', '        uint tablesPtr\n', '        )\n', '        internal\n', '        view\n', '        returns (Data.Mining memory mining)\n', '    {\n', '        bytes memory emptyBytes = new bytes(0);\n', '        uint offset;\n', '\n', '        assembly {\n', '            // Default to transaction origin for feeRecipient\n', '            mstore(add(data, 20), origin)\n', '\n', '            // mining.feeRecipient\n', '            offset := mul(and(mload(add(tablesPtr,  0)), 0xFFFF), 4)\n', '            mstore(\n', '                add(mining,   0),\n', '                mload(add(add(data, 20), offset))\n', '            )\n', '\n', '            // Restore default to 0\n', '            mstore(add(data, 20), 0)\n', '\n', '            // mining.miner\n', '            offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\n', '            mstore(\n', '                add(mining,  32),\n', '                mload(add(add(data, 20), offset))\n', '            )\n', '\n', '            // Default to empty bytes array\n', '            mstore(add(data, 32), emptyBytes)\n', '\n', '            // mining.sig\n', '            offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\n', '            mstore(\n', '                add(mining, 64),\n', '                add(data, add(offset, 32))\n', '            )\n', '\n', '            // Restore default to 0\n', '            mstore(add(data, 32), 0)\n', '        }\n', '    }\n', '\n', '    function setupOrders(\n', '        uint data,\n', '        uint tablesPtr,\n', '        uint numOrders,\n', '        uint numSpendables,\n', '        address lrcTokenAddress\n', '        )\n', '        internal\n', '        pure\n', '        returns (Data.Order[] memory orders)\n', '    {\n', '        bytes memory emptyBytes = new bytes(0);\n', '        uint orderStructSize = 38 * 32;\n', '        // Memory for orders length + numOrders order pointers\n', '        uint arrayDataSize = (1 + numOrders) * 32;\n', '        Data.Spendable[] memory spendableList = new Data.Spendable[](numSpendables);\n', '        uint offset;\n', '\n', '        assembly {\n', '            // Allocate memory for all orders\n', '            orders := mload(0x40)\n', '            mstore(add(orders, 0), numOrders)                       // orders.length\n', '            // Reserve the memory for the orders array\n', '            mstore(0x40, add(orders, add(arrayDataSize, mul(orderStructSize, numOrders))))\n', '\n', '            for { let i := 0 } lt(i, numOrders) { i := add(i, 1) } {\n', '                let order := add(orders, add(arrayDataSize, mul(orderStructSize, i)))\n', '\n', '                // Store the memory location of this order in the orders array\n', '                mstore(add(orders, mul(add(1, i), 32)), order)\n', '\n', '                // order.version\n', '                offset := and(mload(add(tablesPtr,  0)), 0xFFFF)\n', '                mstore(\n', '                    add(order,   0),\n', '                    offset\n', '                )\n', '\n', '                // order.owner\n', '                offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order,  32),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.tokenS\n', '                offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order,  64),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.tokenB\n', '                offset := mul(and(mload(add(tablesPtr,  6)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order,  96),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.amountS\n', '                offset := mul(and(mload(add(tablesPtr,  8)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 128),\n', '                    mload(add(add(data, 32), offset))\n', '                )\n', '\n', '                // order.amountB\n', '                offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 160),\n', '                    mload(add(add(data, 32), offset))\n', '                )\n', '\n', '                // order.validSince\n', '                offset := mul(and(mload(add(tablesPtr, 12)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 192),\n', '                    and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\n', '                )\n', '\n', '                // order.tokenSpendableS\n', '                offset := and(mload(add(tablesPtr, 14)), 0xFFFF)\n', "                // Force the spendable index to 0 if it's invalid\n", '                offset := mul(offset, lt(offset, numSpendables))\n', '                mstore(\n', '                    add(order, 224),\n', '                    mload(add(spendableList, mul(add(offset, 1), 32)))\n', '                )\n', '\n', '                // order.tokenSpendableFee\n', '                offset := and(mload(add(tablesPtr, 16)), 0xFFFF)\n', "                // Force the spendable index to 0 if it's invalid\n", '                offset := mul(offset, lt(offset, numSpendables))\n', '                mstore(\n', '                    add(order, 256),\n', '                    mload(add(spendableList, mul(add(offset, 1), 32)))\n', '                )\n', '\n', '                // order.dualAuthAddr\n', '                offset := mul(and(mload(add(tablesPtr, 18)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 288),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.broker\n', '                offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 320),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.orderInterceptor\n', '                offset := mul(and(mload(add(tablesPtr, 22)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 416),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.wallet\n', '                offset := mul(and(mload(add(tablesPtr, 24)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 448),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // order.validUntil\n', '                offset := mul(and(mload(add(tablesPtr, 26)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 480),\n', '                    and(mload(add(add(data,  4), offset)), 0xFFFFFFFF)\n', '                )\n', '\n', '                // Default to empty bytes array for value sig and dualAuthSig\n', '                mstore(add(data, 32), emptyBytes)\n', '\n', '                // order.sig\n', '                offset := mul(and(mload(add(tablesPtr, 28)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 512),\n', '                    add(data, add(offset, 32))\n', '                )\n', '\n', '                // order.dualAuthSig\n', '                offset := mul(and(mload(add(tablesPtr, 30)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 544),\n', '                    add(data, add(offset, 32))\n', '                )\n', '\n', '                // Restore default to 0\n', '                mstore(add(data, 32), 0)\n', '\n', '                // order.allOrNone\n', '                offset := and(mload(add(tablesPtr, 32)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 576),\n', '                    gt(offset, 0)\n', '                )\n', '\n', '                // lrcTokenAddress is the default value for feeToken\n', '                mstore(add(data, 20), lrcTokenAddress)\n', '\n', '                // order.feeToken\n', '                offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 608),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // Restore default to 0\n', '                mstore(add(data, 20), 0)\n', '\n', '                // order.feeAmount\n', '                offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 640),\n', '                    mload(add(add(data, 32), offset))\n', '                )\n', '\n', '                // order.waiveFeePercentage\n', '                offset := and(mload(add(tablesPtr, 38)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 672),\n', '                    offset\n', '                )\n', '\n', '                // order.tokenSFeePercentage\n', '                offset := and(mload(add(tablesPtr, 40)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 704),\n', '                    offset\n', '                )\n', '\n', '                // order.tokenBFeePercentage\n', '                offset := and(mload(add(tablesPtr, 42)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 736),\n', '                    offset\n', '                )\n', '\n', '                // The owner is the default value of tokenRecipient\n', '                mstore(add(data, 20), mload(add(order, 32)))                // order.owner\n', '\n', '                // order.tokenRecipient\n', '                offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 768),\n', '                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '                )\n', '\n', '                // Restore default to 0\n', '                mstore(add(data, 20), 0)\n', '\n', '                // order.walletSplitPercentage\n', '                offset := and(mload(add(tablesPtr, 46)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 800),\n', '                    offset\n', '                )\n', '\n', '                // order.tokenTypeS\n', '                offset := and(mload(add(tablesPtr, 48)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 1024),\n', '                    offset\n', '                )\n', '\n', '                // order.tokenTypeB\n', '                offset := and(mload(add(tablesPtr, 50)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 1056),\n', '                    offset\n', '                )\n', '\n', '                // order.tokenTypeFee\n', '                offset := and(mload(add(tablesPtr, 52)), 0xFFFF)\n', '                mstore(\n', '                    add(order, 1088),\n', '                    offset\n', '                )\n', '\n', '                // order.trancheS\n', '                offset := mul(and(mload(add(tablesPtr, 54)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 1120),\n', '                    mload(add(add(data, 32), offset))\n', '                )\n', '\n', '                // order.trancheB\n', '                offset := mul(and(mload(add(tablesPtr, 56)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 1152),\n', '                    mload(add(add(data, 32), offset))\n', '                )\n', '\n', '                // Default to empty bytes array for transferDataS\n', '                mstore(add(data, 32), emptyBytes)\n', '\n', '                // order.transferDataS\n', '                offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)\n', '                mstore(\n', '                    add(order, 1184),\n', '                    add(data, add(offset, 32))\n', '                )\n', '\n', '                // Restore default to 0\n', '                mstore(add(data, 32), 0)\n', '\n', '                // Set default  values\n', '                mstore(add(order, 832), 0)         // order.P2P\n', '                mstore(add(order, 864), 0)         // order.hash\n', '                mstore(add(order, 896), 0)         // order.brokerInterceptor\n', '                mstore(add(order, 928), 0)         // order.filledAmountS\n', '                mstore(add(order, 960), 0)         // order.initialFilledAmountS\n', '                mstore(add(order, 992), 1)         // order.valid\n', '\n', '                // Advance to the next order\n', '                tablesPtr := add(tablesPtr, 60)\n', '            }\n', '        }\n', '    }\n', '\n', '    function assembleRings(\n', '        uint data,\n', '        uint numRings,\n', '        Data.Order[] memory orders\n', '        )\n', '        internal\n', '        pure\n', '        returns (Data.Ring[] memory rings)\n', '    {\n', '        uint ringsArrayDataSize = (1 + numRings) * 32;\n', '        uint ringStructSize = 5 * 32;\n', '        uint participationStructSize = 10 * 32;\n', '\n', '        assembly {\n', '            // Allocate memory for all rings\n', '            rings := mload(0x40)\n', '            mstore(add(rings, 0), numRings)                      // rings.length\n', '            // Reserve the memory for the rings array\n', '            mstore(0x40, add(rings, add(ringsArrayDataSize, mul(ringStructSize, numRings))))\n', '\n', '            for { let r := 0 } lt(r, numRings) { r := add(r, 1) } {\n', '                let ring := add(rings, add(ringsArrayDataSize, mul(ringStructSize, r)))\n', '\n', '                // Store the memory location of this ring in the rings array\n', '                mstore(add(rings, mul(add(r, 1), 32)), ring)\n', '\n', '                // Get the ring size\n', '                let ringSize := and(mload(data), 0xFF)\n', '                data := add(data, 1)\n', '\n', '                // require(ringsSize <= 8)\n', '                if gt(ringSize, 8) {\n', '                    revert(0, 0)\n', '                }\n', '\n', '                // Allocate memory for all participations\n', '                let participations := mload(0x40)\n', '                mstore(add(participations, 0), ringSize)         // participations.length\n', '                // Memory for participations length + ringSize participation pointers\n', '                let participationsData := add(participations, mul(add(1, ringSize), 32))\n', '                // Reserve the memory for the participations\n', '                mstore(0x40, add(participationsData, mul(participationStructSize, ringSize)))\n', '\n', '                // Initialize ring properties\n', '                mstore(add(ring,   0), ringSize)                 // ring.size\n', '                mstore(add(ring,  32), participations)           // ring.participations\n', '                mstore(add(ring,  64), 0)                        // ring.hash\n', '                mstore(add(ring,  96), 0)                        // ring.minerFeesToOrdersPercentage\n', '                mstore(add(ring, 128), 1)                        // ring.valid\n', '\n', '                for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {\n', '                    let participation := add(participationsData, mul(participationStructSize, i))\n', '\n', '                    // Store the memory location of this participation in the participations array\n', '                    mstore(add(participations, mul(add(i, 1), 32)), participation)\n', '\n', '                    // Get the order index\n', '                    let orderIndex := and(mload(data), 0xFF)\n', '                    // require(orderIndex < orders.length)\n', '                    if iszero(lt(orderIndex, mload(orders))) {\n', '                        revert(0, 0)\n', '                    }\n', '                    data := add(data, 1)\n', '\n', '                    // participation.order\n', '                    mstore(\n', '                        add(participation,   0),\n', '                        mload(add(orders, mul(add(orderIndex, 1), 32)))\n', '                    )\n', '\n', '                    // Set default values\n', '                    mstore(add(participation,  32), 0)          // participation.splitS\n', '                    mstore(add(participation,  64), 0)          // participation.feeAmount\n', '                    mstore(add(participation,  96), 0)          // participation.feeAmountS\n', '                    mstore(add(participation, 128), 0)          // participation.feeAmountB\n', '                    mstore(add(participation, 160), 0)          // participation.rebateFee\n', '                    mstore(add(participation, 192), 0)          // participation.rebateS\n', '                    mstore(add(participation, 224), 0)          // participation.rebateB\n', '                    mstore(add(participation, 256), 0)          // participation.fillAmountS\n', '                    mstore(add(participation, 288), 0)          // participation.fillAmountB\n', '                }\n', '\n', '                // Advance to the next ring\n', '                data := add(data, sub(8, ringSize))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title An Implementation of IRingSubmitter.\n', '/// @author Daniel Wang - <daniel@loopring.org>,\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>\n', '/// @author Brechtpd - <brecht@loopring.org>\n', '/// Recognized contributing developers from the community:\n', '///     https://github.com/rainydio\n', '///     https://github.com/BenjaminPrice\n', '///     https://github.com/jonasshen\n', '///     https://github.com/Hephyrius\n', 'contract RingSubmitter is IRingSubmitter, NoDefaultFunc {\n', '    using MathUint      for uint;\n', '    using BytesUtil     for bytes;\n', '    using OrderHelper     for Data.Order;\n', '    using RingHelper      for Data.Ring;\n', '    using MiningHelper    for Data.Mining;\n', '\n', '    address public constant lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;\n', '    address public constant wethTokenAddress            = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address public constant delegateAddress             = 0xb258f5C190faDAB30B5fF0D6ab7E32a646A4BaAe;\n', '    address public constant tradeHistoryAddress         = 0xBF5a37670B3DE1E606EC68bE3558c536b2008669;\n', '    address public constant orderBrokerRegistryAddress  = 0x4e1E917F030556788AB3C9d8D0971Ebf0d5439E9;\n', '    address public constant orderRegistryAddress        = 0x6fb707F15Ab3657Dc52776b057B33cB7D95e4E90;\n', '    address public constant feeHolderAddress            = 0x5beaEA36efA78F43a6d61145817FDFf6A9929e60;\n', '    address public constant orderBookAddress            = 0xaC0F8a27012fe8dc5a0bB7f5fc7170934F7e3577;\n', '    address public constant burnRateTableAddress        = 0x20D90aefBA13F044C5d23c48C3b07e2E43a006DB;\n', '\n', '    uint64  public  ringIndex                   = 0;\n', '\n', '    uint    public constant MAX_RING_SIZE       = 8;\n', '\n', '    struct SubmitRingsParam {\n', '        uint16[]    encodeSpecs;\n', '        uint16      miningSpec;\n', '        uint16[]    orderSpecs;\n', '        uint8[][]   ringSpecs;\n', '        address[]   addressList;\n', '        uint[]      uintList;\n', '        bytes[]     bytesList;\n', '    }\n', '\n', '    /* constructor( */\n', '    /*     address _lrcTokenAddress, */\n', '    /*     address _wethTokenAddress, */\n', '    /*     address _delegateAddress, */\n', '    /*     address _tradeHistoryAddress, */\n', '    /*     address _orderBrokerRegistryAddress, */\n', '    /*     address _orderRegistryAddress, */\n', '    /*     address _feeHolderAddress, */\n', '    /*     address _orderBookAddress, */\n', '    /*     address _burnRateTableAddress */\n', '    /*     ) */\n', '    /*     public */\n', '    /* { */\n', '    /*     require(_lrcTokenAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_wethTokenAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_delegateAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_tradeHistoryAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_orderBrokerRegistryAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_orderRegistryAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_feeHolderAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_orderBookAddress != address(0x0), ZERO_ADDRESS); */\n', '    /*     require(_burnRateTableAddress != address(0x0), ZERO_ADDRESS); */\n', '\n', '    /*     lrcTokenAddress = _lrcTokenAddress; */\n', '    /*     wethTokenAddress = _wethTokenAddress; */\n', '    /*     delegateAddress = _delegateAddress; */\n', '    /*     tradeHistoryAddress = _tradeHistoryAddress; */\n', '    /*     orderBrokerRegistryAddress = _orderBrokerRegistryAddress; */\n', '    /*     orderRegistryAddress = _orderRegistryAddress; */\n', '    /*     feeHolderAddress = _feeHolderAddress; */\n', '    /*     orderBookAddress = _orderBookAddress; */\n', '    /*     burnRateTableAddress = _burnRateTableAddress; */\n', '    /* } */\n', '\n', '    function submitRings(\n', '        bytes calldata data\n', '        )\n', '        external\n', '    {\n', '        uint i;\n', '        bytes32[] memory tokenBurnRates;\n', '        Data.Context memory ctx = Data.Context(\n', '            lrcTokenAddress,\n', '            ITradeDelegate(delegateAddress),\n', '            ITradeHistory(tradeHistoryAddress),\n', '            IBrokerRegistry(orderBrokerRegistryAddress),\n', '            IOrderRegistry(orderRegistryAddress),\n', '            IFeeHolder(feeHolderAddress),\n', '            IOrderBook(orderBookAddress),\n', '            IBurnRateTable(burnRateTableAddress),\n', '            ringIndex,\n', '            FEE_PERCENTAGE_BASE,\n', '            tokenBurnRates,\n', '            0,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '\n', "        // Check if the highest bit of ringIndex is '1'\n", '        require((ctx.ringIndex >> 63) == 0, REENTRY);\n', '\n', "        // Set the highest bit of ringIndex to '1' (IN STORAGE!)\n", '        ringIndex = ctx.ringIndex | (1 << 63);\n', '\n', '        (\n', '            Data.Mining  memory mining,\n', '            Data.Order[] memory orders,\n', '            Data.Ring[]  memory rings\n', '        ) = ExchangeDeserializer.deserialize(lrcTokenAddress, data);\n', '\n', '        // Allocate memory that is used to batch things for all rings\n', '        setupLists(ctx, orders, rings);\n', '\n', '        for (i = 0; i < orders.length; i++) {\n', '            orders[i].updateHash();\n', '            orders[i].updateBrokerAndInterceptor(ctx);\n', '        }\n', '\n', '        batchGetFilledAndCheckCancelled(ctx, orders);\n', '\n', '        for (i = 0; i < orders.length; i++) {\n', '            orders[i].check(ctx);\n', '            // An order can only be sent once\n', '            for (uint j = i + 1; j < orders.length; j++) {\n', '                require(orders[i].hash != orders[j].hash, INVALID_VALUE);\n', '            }\n', '        }\n', '\n', '        for (i = 0; i < rings.length; i++) {\n', '            rings[i].updateHash();\n', '        }\n', '\n', '        mining.updateHash(rings);\n', '        mining.updateMinerAndInterceptor();\n', '        require(mining.checkMinerSignature(), INVALID_SIG);\n', '\n', '        for (i = 0; i < orders.length; i++) {\n', "            // We don't need to verify the dual author signature again if it uses the same\n", '            // dual author address as the previous order (the miner can optimize the order of the orders\n', "            // so this happens as much as possible). We don't need to check if the signature is the same\n", '            // because the same mining hash is signed for all orders.\n', '            if(i > 0 && orders[i].dualAuthAddr == orders[i - 1].dualAuthAddr) {\n', '                continue;\n', '            }\n', '            orders[i].checkDualAuthSignature(mining.hash);\n', '        }\n', '\n', '        for (i = 0; i < rings.length; i++) {\n', '            Data.Ring memory ring = rings[i];\n', '            ring.checkOrdersValid();\n', '            ring.checkForSubRings();\n', '            ring.calculateFillAmountAndFee(ctx);\n', '            if (ring.valid) {\n', '                ring.adjustOrderStates();\n', '            }\n', '        }\n', '\n', '        // Check if the allOrNone orders are completely filled over all rings\n', '        // This can invalidate rings\n', '        checkRings(orders, rings);\n', '\n', '        for (i = 0; i < rings.length; i++) {\n', '            Data.Ring memory ring = rings[i];\n', '            if (ring.valid) {\n', '                // Only settle rings we have checked to be valid\n', '                ring.doPayments(ctx, mining);\n', '                emitRingMinedEvent(\n', '                    ring,\n', '                    ctx.ringIndex++,\n', '                    mining.feeRecipient\n', '                );\n', '            } else {\n', '                emit InvalidRing(ring.hash);\n', '            }\n', '        }\n', '\n', '        // Do all token transfers for all rings\n', '        batchTransferTokens(ctx);\n', '        // Do all fee payments for all rings\n', '        batchPayFees(ctx);\n', '        // Update all order stats\n', '        updateOrdersStats(ctx, orders);\n', '\n', "        // Update ringIndex while setting the highest bit of ringIndex back to '0'\n", '        ringIndex = ctx.ringIndex;\n', '    }\n', '\n', '    function checkRings(\n', '        Data.Order[] memory orders,\n', '        Data.Ring[] memory rings\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Check if allOrNone orders are completely filled\n', '        // When a ring is turned invalid because of an allOrNone order we have to\n', '        // recheck the other rings again because they may contain other allOrNone orders\n', '        // that may not be completely filled anymore.\n', '        bool reevaluateRings = true;\n', '        while (reevaluateRings) {\n', '            reevaluateRings = false;\n', '            for (uint i = 0; i < orders.length; i++) {\n', '                if (orders[i].valid) {\n', '                    orders[i].validateAllOrNone();\n', '                    // Check if the order valid status has changed\n', '                    reevaluateRings = reevaluateRings || !orders[i].valid;\n', '                }\n', '            }\n', '            if (reevaluateRings) {\n', '                for (uint i = 0; i < rings.length; i++) {\n', '                    Data.Ring memory ring = rings[i];\n', '                    if (ring.valid) {\n', '                        ring.checkOrdersValid();\n', '                        if (!ring.valid) {\n', '                            // If the ring was valid before the completely filled check we have to revert the filled amountS\n', "                            // of the orders in the ring. This is a bit awkward so maybe there's a better solution.\n", '                            ring.revertOrderStats();\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function emitRingMinedEvent(\n', '        Data.Ring memory ring,\n', '        uint _ringIndex,\n', '        address feeRecipient\n', '        )\n', '        internal\n', '    {\n', '        bytes32 ringHash = ring.hash;\n', '        // keccak256("RingMined(uint256,bytes32,address,bytes)")\n', '        bytes32 ringMinedSignature = 0xb2ef4bc5209dff0c46d5dfddb2b68a23bd4820e8f33107fde76ed15ba90695c9;\n', '        uint fillsSize = ring.size * 8 * 32;\n', '\n', '        uint data;\n', '        uint ptr;\n', '        assembly {\n', '            data := mload(0x40)\n', '            ptr := data\n', '            mstore(ptr, _ringIndex)                     // ring index data\n', '            mstore(add(ptr, 32), 0x40)                  // offset to fills data\n', '            mstore(add(ptr, 64), fillsSize)             // fills length\n', '            ptr := add(ptr, 96)\n', '        }\n', '        ptr = ring.generateFills(ptr);\n', '\n', '        assembly {\n', '            log3(\n', '                data,                                   // data start\n', '                sub(ptr, data),                         // data length\n', '                ringMinedSignature,                     // Topic 0: RingMined signature\n', '                ringHash,                               // Topic 1: ring hash\n', '                feeRecipient                            // Topic 2: feeRecipient\n', '            )\n', '        }\n', '    }\n', '\n', '    function setupLists(\n', '        Data.Context memory ctx,\n', '        Data.Order[] memory orders,\n', '        Data.Ring[] memory rings\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        setupTokenBurnRateList(ctx, orders);\n', '        setupFeePaymentList(ctx, rings);\n', '        setupTokenTransferList(ctx, rings);\n', '    }\n', '\n', '    function setupTokenBurnRateList(\n', '        Data.Context memory ctx,\n', '        Data.Order[] memory orders\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Allocate enough memory to store burn rates for all tokens even\n', '        // if every token is unique (max 2 unique tokens / order)\n', '        uint maxNumTokenBurnRates = orders.length * 2;\n', '        bytes32[] memory tokenBurnRates;\n', '        assembly {\n', '            tokenBurnRates := mload(0x40)\n', '            mstore(tokenBurnRates, 0)                               // tokenBurnRates.length\n', '            mstore(0x40, add(\n', '                tokenBurnRates,\n', '                add(32, mul(maxNumTokenBurnRates, 64))\n', '            ))\n', '        }\n', '        ctx.tokenBurnRates = tokenBurnRates;\n', '    }\n', '\n', '    function setupFeePaymentList(\n', '        Data.Context memory ctx,\n', '        Data.Ring[] memory rings\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint totalMaxSizeFeePayments = 0;\n', '        for (uint i = 0; i < rings.length; i++) {\n', '            // Up to (ringSize + 3) * 3 payments per order (because of fee sharing by miner)\n', '            // (3 x 32 bytes for every fee payment)\n', '            uint ringSize = rings[i].size;\n', '            uint maxSize = (ringSize + 3) * 3 * ringSize * 3;\n', '            totalMaxSizeFeePayments += maxSize;\n', '        }\n', '        // Store the data directly in the call data format as expected by batchAddFeeBalances:\n', '        // - 0x00: batchAddFeeBalances selector (4 bytes)\n', '        // - 0x04: parameter offset (batchAddFeeBalances has a single function parameter) (32 bytes)\n', '        // - 0x24: length of the array passed into the function (32 bytes)\n', '        // - 0x44: the array data (32 bytes x length)\n', '        bytes4 batchAddFeeBalancesSelector = ctx.feeHolder.batchAddFeeBalances.selector;\n', '        uint ptr;\n', '        assembly {\n', '            let data := mload(0x40)\n', '            mstore(data, batchAddFeeBalancesSelector)\n', '            mstore(add(data, 4), 32)\n', '            ptr := add(data, 68)\n', '            mstore(0x40, add(ptr, mul(totalMaxSizeFeePayments, 32)))\n', '        }\n', '        ctx.feeData = ptr;\n', '        ctx.feePtr = ptr;\n', '    }\n', '\n', '    function setupTokenTransferList(\n', '        Data.Context memory ctx,\n', '        Data.Ring[] memory rings\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint totalMaxSizeTransfers = 0;\n', '        for (uint i = 0; i < rings.length; i++) {\n', '            // Up to 4 transfers per order\n', '            // (4 x 32 bytes for every transfer)\n', '            uint maxSize = 4 * rings[i].size * 4;\n', '            totalMaxSizeTransfers += maxSize;\n', '        }\n', '        // Store the data directly in the call data format as expected by batchTransfer:\n', '        // - 0x00: batchTransfer selector (4 bytes)\n', '        // - 0x04: parameter offset (batchTransfer has a single function parameter) (32 bytes)\n', '        // - 0x24: length of the array passed into the function (32 bytes)\n', '        // - 0x44: the array data (32 bytes x length)\n', '        bytes4 batchTransferSelector = ctx.delegate.batchTransfer.selector;\n', '        uint ptr;\n', '        assembly {\n', '            let data := mload(0x40)\n', '            mstore(data, batchTransferSelector)\n', '            mstore(add(data, 4), 32)\n', '            ptr := add(data, 68)\n', '            mstore(0x40, add(ptr, mul(totalMaxSizeTransfers, 32)))\n', '        }\n', '        ctx.transferData = ptr;\n', '        ctx.transferPtr = ptr;\n', '    }\n', '\n', '    function updateOrdersStats(\n', '        Data.Context memory ctx,\n', '        Data.Order[] memory orders\n', '        )\n', '        internal\n', '    {\n', '        // Store the data directly in the call data format as expected by batchUpdateFilled:\n', '        // - 0x00: batchUpdateFilled selector (4 bytes)\n', '        // - 0x04: parameter offset (batchUpdateFilled has a single function parameter) (32 bytes)\n', '        // - 0x24: length of the array passed into the function (32 bytes)\n', '        // - 0x44: the array data (32 bytes x length)\n', '        // For every (valid) order we store 2 words:\n', '        // - order.hash\n', '        // - order.filledAmountS after all rings\n', '        bytes4 batchUpdateFilledSelector = ctx.tradeHistory.batchUpdateFilled.selector;\n', '        address _tradeHistoryAddress = address(ctx.tradeHistory);\n', '        assembly {\n', '            let data := mload(0x40)\n', '            mstore(data, batchUpdateFilledSelector)\n', '            mstore(add(data, 4), 32)\n', '            let ptr := add(data, 68)\n', '            let arrayLength := 0\n', '            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {\n', '                let order := mload(add(orders, mul(add(i, 1), 32)))\n', '                let filledAmount := mload(add(order, 928))                               // order.filledAmountS\n', '                let initialFilledAmount := mload(add(order, 960))                        // order.initialFilledAmountS\n', '                let filledAmountChanged := iszero(eq(filledAmount, initialFilledAmount))\n', '                // if (order.valid && filledAmountChanged)\n', '                if and(gt(mload(add(order, 992)), 0), filledAmountChanged) {             // order.valid\n', '                    mstore(add(ptr,   0), mload(add(order, 864)))                        // order.hash\n', '                    mstore(add(ptr,  32), filledAmount)\n', '\n', '                    ptr := add(ptr, 64)\n', '                    arrayLength := add(arrayLength, 2)\n', '                }\n', '            }\n', '\n', '            // Only do the external call if the list is not empty\n', '            if gt(arrayLength, 0) {\n', '                mstore(add(data, 36), arrayLength)      // filledInfo.length\n', '\n', '                let success := call(\n', '                    gas,                                // forward all gas\n', '                    _tradeHistoryAddress,               // external address\n', '                    0,                                  // wei\n', '                    data,                               // input start\n', '                    sub(ptr, data),                     // input length\n', '                    data,                               // output start\n', '                    0                                   // output length\n', '                )\n', '                if eq(success, 0) {\n', '                    // Propagate the revert message\n', '                    returndatacopy(0, 0, returndatasize())\n', '                    revert(0, returndatasize())\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function batchGetFilledAndCheckCancelled(\n', '        Data.Context memory ctx,\n', '        Data.Order[] memory orders\n', '        )\n', '        internal\n', '    {\n', '        // Store the data in the call data format as expected by batchGetFilledAndCheckCancelled:\n', '        // - 0x00: batchGetFilledAndCheckCancelled selector (4 bytes)\n', '        // - 0x04: parameter offset (batchGetFilledAndCheckCancelled has a single function parameter) (32 bytes)\n', '        // - 0x24: length of the array passed into the function (32 bytes)\n', '        // - 0x44: the array data (32 bytes x length)\n', '        // For every order we store 5 words:\n', '        // - order.broker\n', '        // - order.owner\n', '        // - order.hash\n', '        // - order.validSince\n', '        // - The trading pair of the order: order.tokenS ^ order.tokenB\n', '        bytes4 batchGetFilledAndCheckCancelledSelector = ctx.tradeHistory.batchGetFilledAndCheckCancelled.selector;\n', '        address _tradeHistoryAddress = address(ctx.tradeHistory);\n', '        assembly {\n', '            let data := mload(0x40)\n', '            mstore(data, batchGetFilledAndCheckCancelledSelector)\n', '            mstore(add(data,  4), 32)\n', '            mstore(add(data, 36), mul(mload(orders), 5))                // orders.length\n', '            let ptr := add(data, 68)\n', '            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {\n', '                let order := mload(add(orders, mul(add(i, 1), 32)))     // orders[i]\n', '                mstore(add(ptr,   0), mload(add(order, 320)))           // order.broker\n', '                mstore(add(ptr,  32), mload(add(order,  32)))           // order.owner\n', '                mstore(add(ptr,  64), mload(add(order, 864)))           // order.hash\n', '                mstore(add(ptr,  96), mload(add(order, 192)))           // order.validSince\n', '                // bytes20(order.tokenS) ^ bytes20(order.tokenB)        // tradingPair\n', '                mstore(add(ptr, 128), mul(\n', '                    xor(\n', '                        mload(add(order, 64)),                 // order.tokenS\n', '                        mload(add(order, 96))                  // order.tokenB\n', '                    ),\n', '                    0x1000000000000000000000000)               // shift left 12 bytes (bytes20 is padded on the right)\n', '                )\n', '                ptr := add(ptr, 160)                                    // 5 * 32\n', '            }\n', '            // Return data is stored just like the call data without the signature:\n', '            // 0x00: Offset to data\n', '            // 0x20: Array length\n', '            // 0x40: Array data\n', '            let returnDataSize := mul(add(2, mload(orders)), 32)\n', '            let success := call(\n', '                gas,                                // forward all gas\n', '                _tradeHistoryAddress,               // external address\n', '                0,                                  // wei\n', '                data,                               // input start\n', '                sub(ptr, data),                     // input length\n', '                data,                               // output start\n', '                returnDataSize                      // output length\n', '            )\n', '            // Check if the call was successful and the return data is the expected size\n', '            if or(eq(success, 0), iszero(eq(returndatasize(), returnDataSize))) {\n', '                if eq(success, 0) {\n', '                    // Propagate the revert message\n', '                    returndatacopy(0, 0, returndatasize())\n', '                    revert(0, returndatasize())\n', '                }\n', '                revert(0, 0)\n', '            }\n', '            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {\n', '                let order := mload(add(orders, mul(add(i, 1), 32)))     // orders[i]\n', '                let fill := mload(add(data,  mul(add(i, 2), 32)))       // fills[i]\n', '                mstore(add(order, 928), fill)                           // order.filledAmountS\n', '                mstore(add(order, 960), fill)                           // order.initialFilledAmountS\n', '                // If fills[i] == ~uint(0) the order was cancelled\n', '                // order.valid = order.valid && (order.filledAmountS != ~uint(0))\n', '                mstore(add(order, 992),                                 // order.valid\n', '                    and(\n', '                        gt(mload(add(order, 992)), 0),                  // order.valid\n', '                        iszero(eq(fill, not(0)))                        // fill != ~uint(0\n', '                    )\n', '                )\n', '            }\n', '        }\n', '    }\n', '\n', '    function batchTransferTokens(\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '    {\n', '        // Check if there are any transfers\n', '        if (ctx.transferData == ctx.transferPtr) {\n', '            return;\n', '        }\n', '        // We stored the token transfers in the call data as expected by batchTransfer.\n', '        // The only thing we still need to do is update the final length of the array and call\n', '        // the function on the TradeDelegate contract with the generated data.\n', '        address _tradeDelegateAddress = address(ctx.delegate);\n', '        uint arrayLength = (ctx.transferPtr - ctx.transferData) / 32;\n', '        uint data = ctx.transferData - 68;\n', '        uint ptr = ctx.transferPtr;\n', '        assembly {\n', '            mstore(add(data, 36), arrayLength)      // batch.length\n', '\n', '            let success := call(\n', '                gas,                                // forward all gas\n', '                _tradeDelegateAddress,              // external address\n', '                0,                                  // wei\n', '                data,                               // input start\n', '                sub(ptr, data),                     // input length\n', '                data,                               // output start\n', '                0                                   // output length\n', '            )\n', '            if eq(success, 0) {\n', '                // Propagate the revert message\n', '                returndatacopy(0, 0, returndatasize())\n', '                revert(0, returndatasize())\n', '            }\n', '        }\n', '    }\n', '\n', '    function batchPayFees(\n', '        Data.Context memory ctx\n', '        )\n', '        internal\n', '    {\n', '        // Check if there are any fee payments\n', '        if (ctx.feeData == ctx.feePtr) {\n', '            return;\n', '        }\n', '        // We stored the fee payments in the call data as expected by batchAddFeeBalances.\n', '        // The only thing we still need to do is update the final length of the array and call\n', '        // the function on the FeeHolder contract with the generated data.\n', '        address _feeHolderAddress = address(ctx.feeHolder);\n', '        uint arrayLength = (ctx.feePtr - ctx.feeData) / 32;\n', '        uint data = ctx.feeData - 68;\n', '        uint ptr = ctx.feePtr;\n', '        assembly {\n', '            mstore(add(data, 36), arrayLength)      // batch.length\n', '\n', '            let success := call(\n', '                gas,                                // forward all gas\n', '                _feeHolderAddress,                  // external address\n', '                0,                                  // wei\n', '                data,                               // input start\n', '                sub(ptr, data),                     // input length\n', '                data,                               // output start\n', '                0                                   // output length\n', '            )\n', '            if eq(success, 0) {\n', '                // Propagate the revert message\n', '                returndatacopy(0, 0, returndatasize())\n', '                revert(0, returndatasize())\n', '            }\n', '        }\n', '    }\n', '\n', '}']