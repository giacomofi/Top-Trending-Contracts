['pragma solidity 0.4.25;\n', '\n', '\n', '/**\n', '*\n', '* ETH INVESTMENT SMART PLATFORM - ETHUP\n', '* Web               - https://ethup.io\n', '* GitHub            - https://github.com/ethup/ethup\n', '* Twitter           - https://twitter.com/ethup1\n', '* Youtube           - https://www.youtube.com/channel/UC4JMZcpySACj4lGbXLJm9KQ\n', '* EN  Telegram_chat: https://t.me/Ethup_en\n', '* RU  Telegram_chat: https://t.me/Ethup_ru\n', '* KOR Telegram_chat: https://t.me/Ethup_kor\n', '* CN  Telegram_chat: https://t.me/Ethup_cn\n', '* Email:             mailto:info(at sign)ethup.io\n', '* \n', '* \n', '*  - GAIN 1% - 4% PER 24 HOURS\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 ETH\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 85,0% payments\n', '*    --   10% marketing\n', '*    --    5% technical support\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  smart platform is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', "*  freely accessed online. In order to insure our investors' complete security, full control over the \n", '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', "*  system's permanent autonomous functioning.\n", '* \n', '* ---How to use:\n', '*  1. Select a level and send from ETH wallet to the smart contract address 0xeccf2a50fca80391b0380188255866f0fc7fe852\n', '*     any amount from 0.01 to 50 ETH.\n', '*\n', '*       Level 1: from 0.01 to 0.1 ETH - 1%\n', '*       Level 2: from 0.1 to 1 ETH - 1.5%\n', '*       Level 3: from 1 to 5 ETH - 2.0%\n', '*       Level 4: from 5 to 10 ETH - 2.5%\n', '*       Level 5: from 10 to 20 ETH - 3%.\n', '*       Level 6: from 20 to 30 ETH - 3.5%\n', '*       Level 7: from 30 to 50 ETH - 4%\n', '*\n', '*  2. Verify your transaction in the history of your application (wallet) or etherscan.io, specifying the address \n', '*     of your wallet.\n', "*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \n", '*      spending too much on GAS) to the smart contract address 0xeccf2a50fca80391b0380188255866f0fc7fe852.\n', '*  OR\n', '*  3b. For add investment, you need to deposit the amount that you want to add and the \n', '*      accrued interest automatically summed to your new contribution.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 210000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* Every 24 hours from the moment of the deposit or from the last successful write-off of the accrued interest, \n', '* the smart contract will transfer your dividends to your account that corresponds to the number of your wallet. \n', '* Dividends are accrued until 150% of the investment is paid.\n', '* After receiving 150% of all invested funds (or 50% of profits), your wallet will disconnected from payments. \n', '* You can make reinvestment by receiving an additional + 10% for the deposit amount and continue the participation. \n', '* The bonus will received only by the participant who has already received 150% of the profits and invests again.\n', '*\n', "* The amount of daily charges depends on the sum of all the participant's contributions to the smart contract.\n", '*\n', '* In case you make a contribution without first removing the accrued interest,\n', '* it is added to your new contribution and credited to your account in smart contract\n', '*\n', '* ---Additional tools embedded in the smart contract:\n', '*     - Referral program 5%. The same bonus gets referral and referrer.\n', '*     - Reinvestment. After full payment of your first investment, you can receive a 10% bonus for reinvesting funds. \n', '*       You can reinvest any amount.\n', '*     - BOOST mode. Get the percentage of your funds remaining in the system. \n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - EthUp. Scroll down to find it.\n', '*/ \n', '\n', '\n', 'library Zero {\n', '    function requireNotZero(address addr) internal pure {\n', '        require(addr != address(0), "require not zero address");\n', '    }\n', '\n', '    function requireNotZero(uint val) internal pure {\n', '        require(val != 0, "require not zero value");\n', '    }\n', '\n', '    function notZero(address addr) internal pure returns(bool) {\n', '        return !(addr == address(0));\n', '    }\n', '\n', '    function isZero(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '\n', '    function isZero(uint a) internal pure returns(bool) {\n', '        return a == 0;\n', '    }\n', '\n', '    function notZero(uint a) internal pure returns(bool) {\n', '        return a != 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Percent {\n', '    using SafeMath for uint;\n', '\n', '    // Solidity automatically throws when dividing by 0\n', '    struct percent {\n', '        uint num;\n', '        uint den;\n', '    }\n', '\n', '    function mul(percent storage p, uint a) internal view returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a.mul(p.num).div(p.den);\n', '    }\n', '\n', '    function div(percent storage p, uint a) internal view returns (uint) {\n', '        return a.div(p.num).mul(p.den);\n', '    }\n', '\n', '    function sub(percent storage p, uint a) internal view returns (uint) {\n', '        uint b = mul(p, a);\n', '        if (b >= a) {\n', '            return 0; // solium-disable-line lbrace\n', '        }\n', '        return a.sub(b);\n', '    }\n', '\n', '    function add(percent storage p, uint a) internal view returns (uint) {\n', '        return a.add(mul(p, a));\n', '    }\n', '\n', '    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '        return Percent.percent(p.num, p.den);\n', '    }\n', '\n', '    // memory\n', '    function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a.mul(p.num).div(p.den);\n', '    }\n', '\n', '    function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '        return a.div(p.num).mul(p.den);\n', '    }\n', '\n', '    function msub(percent memory p, uint a) internal pure returns (uint) {\n', '        uint b = mmul(p, a);\n', '        if (b >= a) {\n', '            return 0;\n', '        }\n', '        return a.sub(b);\n', '    }\n', '\n', '    function madd(percent memory p, uint a) internal pure returns (uint) {\n', '        return a.add(mmul(p, a));\n', '    }\n', '}\n', '\n', 'library ToAddress {\n', '\n', '    function toAddress(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source, 0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function isNotContract(address addr) internal view returns(bool) {\n', '        uint length;\n', '        assembly { length := extcodesize(addr) }\n', '        return length == 0;\n', '    }\n', '}\n', '\n', 'contract Accessibility {\n', '\n', '    address private owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "access denied");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function disown() internal {\n', '        delete owner;\n', '    }\n', '}\n', '\n', 'contract InvestorsStorage is Accessibility {\n', '    using SafeMath for uint;\n', '\n', '    struct Dividends {\n', '        uint value;     //paid\n', '        uint limit;\n', '        uint deferred;  //not paid yet\n', '    }\n', '\n', '    struct Investor {\n', '        uint investment;\n', '        uint paymentTime;\n', '        Dividends dividends;\n', '    }\n', '\n', '    uint public size;\n', '\n', '    mapping (address => Investor) private investors;\n', '\n', '    function isInvestor(address addr) public view returns (bool) {\n', '        return investors[addr].investment > 0;\n', '    }\n', '\n', '    function investorInfo(\n', '        address addr\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            uint investment,\n', '            uint paymentTime,\n', '            uint value,\n', '            uint limit,\n', '            uint deferred\n', '        )\n', '    {\n', '        investment = investors[addr].investment;\n', '        paymentTime = investors[addr].paymentTime;\n', '        value = investors[addr].dividends.value;\n', '        limit = investors[addr].dividends.limit;\n', '        deferred = investors[addr].dividends.deferred;\n', '    }\n', '\n', '    function newInvestor(\n', '        address addr,\n', '        uint investment,\n', '        uint paymentTime,\n', '        uint dividendsLimit\n', '    )\n', '        public\n', '        onlyOwner\n', '        returns (\n', '            bool\n', '        )\n', '    {\n', '        Investor storage inv = investors[addr];\n', '        if (inv.investment != 0 || investment == 0) {\n', '            return false;\n', '        }\n', '        inv.investment = investment;\n', '        inv.paymentTime = paymentTime;\n', '        inv.dividends.limit = dividendsLimit;\n', '        size++;\n', '        return true;\n', '    }\n', '\n', '    function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].investment = investors[addr].investment.add(investment);\n', '        return true;\n', '    }\n', '\n', '    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].paymentTime = paymentTime;\n', '        return true;\n', '    }\n', '\n', '    function addDeferredDividends(address addr, uint dividends) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].dividends.deferred = investors[addr].dividends.deferred.add(dividends);\n', '        return true;\n', '    }\n', '\n', '    function addDividends(address addr, uint dividends) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        if (investors[addr].dividends.value + dividends > investors[addr].dividends.limit) {\n', '            investors[addr].dividends.value = investors[addr].dividends.limit;\n', '        } else {\n', '            investors[addr].dividends.value = investors[addr].dividends.value.add(dividends);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function setNewInvestment(address addr, uint investment, uint limit) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].investment = investment;\n', '        investors[addr].dividends.limit = limit;\n', '        // reset payment dividends\n', '        investors[addr].dividends.value = 0;\n', '        investors[addr].dividends.deferred = 0;\n', '\n', '        return true;\n', '    }\n', '\n', '    function addDividendsLimit(address addr, uint limit) public onlyOwner returns (bool) {\n', '        if (investors[addr].investment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].dividends.limit = investors[addr].dividends.limit.add(limit);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract EthUp is Accessibility {\n', '    using Percent for Percent.percent;\n', '    using SafeMath for uint;\n', '    using Zero for *;\n', '    using ToAddress for *;\n', '\n', '    // investors storage - iterable map;\n', '    InvestorsStorage private m_investors;\n', '    mapping(address => bool) private m_referrals;\n', '\n', '    // automatically generates getters\n', '    address public advertisingAddress;\n', '    address public adminsAddress;\n', '    uint public investmentsNumber;\n', '    uint public constant MIN_INVESTMENT = 10 finney; // 0.01 eth\n', '    uint public constant MAX_INVESTMENT = 50 ether;\n', '    uint public constant MAX_BALANCE = 1e5 ether; // 100 000 eth\n', '\n', '    // percents\n', '    Percent.percent private m_1_percent = Percent.percent(1, 100);          //  1/100   *100% = 1%\n', '    Percent.percent private m_1_5_percent = Percent.percent(15, 1000);      //  15/1000 *100% = 1.5%\n', '    Percent.percent private m_2_percent = Percent.percent(2, 100);          //  2/100   *100% = 2%\n', '    Percent.percent private m_2_5_percent = Percent.percent(25, 1000);      //  25/1000 *100% = 2.5%\n', '    Percent.percent private m_3_percent = Percent.percent(3, 100);          //  3/100   *100% = 3%\n', '    Percent.percent private m_3_5_percent = Percent.percent(35, 1000);      //  35/1000 *100% = 3.5%\n', '    Percent.percent private m_4_percent = Percent.percent(4, 100);          //  4/100   *100% = 4%\n', '\n', '    Percent.percent private m_refPercent = Percent.percent(5, 100);         //  5/100   *100% = 5%\n', '    Percent.percent private m_adminsPercent = Percent.percent(5, 100);      //  5/100   *100% = 5%\n', '    Percent.percent private m_advertisingPercent = Percent.percent(1, 10);  //  1/10    *100% = 10%\n', '\n', '    Percent.percent private m_maxDepositPercent = Percent.percent(15, 10);  //  15/10   *100% = 150%\n', '    Percent.percent private m_reinvestPercent = Percent.percent(1, 10);     //  10/100  *100% = 10%\n', '\n', '    // more events for easy read from blockchain\n', '    event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\n', '    event LogNewInvestor(address indexed addr, uint when);\n', '    event LogNewInvestment(address indexed addr, uint when, uint investment, uint value);\n', '    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\n', '    event LogReinvest(address indexed addr, uint when, uint investment);\n', '    event LogPayDividends(address indexed addr, uint when, uint value);\n', '    event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n', '    event LogBalanceChanged(uint when, uint balance);\n', '    event LogDisown(uint when);\n', '\n', '    modifier balanceChanged() {\n', '        _;\n', '        emit LogBalanceChanged(now, address(this).balance);\n', '    }\n', '\n', '    modifier notFromContract() {\n', '        require(msg.sender.isNotContract(), "only externally accounts");\n', '        _;\n', '    }\n', '\n', '    modifier checkPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        adminsAddress = msg.sender;\n', '        advertisingAddress = msg.sender;\n', '\n', '        m_investors = new InvestorsStorage();\n', '        investmentsNumber = 0;\n', '    }\n', '\n', '    function() public payable {\n', '        // investor get him dividends\n', '        if (msg.value.isZero()) {\n', '            getMyDividends();\n', '            return;\n', '        }\n', '\n', '        // sender do invest\n', '        doInvest(msg.sender, msg.data.toAddress());\n', '    }\n', '\n', '    function doDisown() public onlyOwner {\n', '        disown();\n', '        emit LogDisown(now);\n', '    }\n', '\n', '    function investorsNumber() public view returns(uint) {\n', '        return m_investors.size();\n', '    }\n', '\n', '    function balanceETH() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function percent1() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_1_percent.num, m_1_percent.den);\n', '    }\n', '\n', '    function percent1_5() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_1_5_percent.num, m_1_5_percent.den);\n', '    }\n', '\n', '    function percent2() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_2_percent.num, m_2_percent.den);\n', '    }\n', '\n', '    function percent2_5() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_2_5_percent.num, m_2_5_percent.den);\n', '    }\n', '\n', '    function percent3() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_3_percent.num, m_3_percent.den);\n', '    }\n', '\n', '    function percent3_5() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_3_5_percent.num, m_3_5_percent.den);\n', '    }\n', '\n', '    function percent4() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_4_percent.num, m_4_percent.den);\n', '    }\n', '\n', '    function advertisingPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\n', '    }\n', '\n', '    function adminsPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\n', '    }\n', '\n', '    function maxDepositPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_maxDepositPercent.num, m_maxDepositPercent.den);\n', '    }\n', '\n', '    function investorInfo(\n', '        address investorAddr\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            uint investment,\n', '            uint paymentTime,\n', '            uint dividends,\n', '            uint dividendsLimit,\n', '            uint dividendsDeferred,\n', '            bool isReferral\n', '        )\n', '    {\n', '        (\n', '            investment,\n', '            paymentTime,\n', '            dividends,\n', '            dividendsLimit,\n', '            dividendsDeferred\n', '        ) = m_investors.investorInfo(investorAddr);\n', '\n', '        isReferral = m_referrals[investorAddr];\n', '    }\n', '\n', '    function getInvestorDividendsAtNow(\n', '        address investorAddr\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            uint dividends\n', '        )\n', '    {\n', '        dividends = calcDividends(investorAddr);\n', '    }\n', '\n', '    function getDailyPercentAtNow(\n', '        address investorAddr\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            uint numerator,\n', '            uint denominator\n', '        )\n', '    {\n', '        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\n', '\n', '        Percent.percent memory p = getDailyPercent(investor.investment);\n', '        (numerator, denominator) = (p.num, p.den);\n', '    }\n', '\n', '    function getRefBonusPercentAtNow() public view returns(uint numerator, uint denominator) {\n', '        Percent.percent memory p = getRefBonusPercent();\n', '        (numerator, denominator) = (p.num, p.den);\n', '    }\n', '\n', '    function getMyDividends() public notFromContract balanceChanged {\n', '        // calculate dividends\n', '        uint dividends = calcDividends(msg.sender);\n', '        require(dividends.notZero(), "cannot to pay zero dividends");\n', '\n', '        // update investor payment timestamp\n', '        assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '        // check enough eth\n', '        if (address(this).balance < dividends) {\n', '            dividends = address(this).balance;\n', '        }\n', '\n', '        // update payouts dividends\n', '        assert(m_investors.addDividends(msg.sender, dividends));\n', '\n', '        // transfer dividends to investor\n', '        msg.sender.transfer(dividends);\n', '        emit LogPayDividends(msg.sender, now, dividends);\n', '    }\n', '\n', '    // for fiat investors and bounty program\n', '    function createInvest(\n', '        address investorAddress,\n', '        address referrerAddr\n', '    )\n', '        public\n', '        payable\n', '        notFromContract\n', '        balanceChanged\n', '        onlyOwner\n', '    {\n', '        //require(adminsAddress == msg.sender, "only admin can do invest from new investor");\n', '        doInvest(investorAddress, referrerAddr);\n', '    }\n', '\n', '    function doInvest(\n', '        address investorAddress,\n', '        address referrerAddr\n', '    )\n', '        public\n', '        payable\n', '        notFromContract\n', '        balanceChanged\n', '    {\n', '        uint investment = msg.value;\n', '        uint receivedEther = msg.value;\n', '\n', '        require(investment >= MIN_INVESTMENT, "investment must be >= MIN_INVESTMENT");\n', '        require(address(this).balance + investment <= MAX_BALANCE, "the contract eth balance limit");\n', '\n', '        // send excess of ether if needed\n', '        if (receivedEther > MAX_INVESTMENT) {\n', '            uint excess = receivedEther - MAX_INVESTMENT;\n', '            investment = MAX_INVESTMENT;\n', '            investorAddress.transfer(excess);\n', '            emit LogSendExcessOfEther(investorAddress, now, receivedEther, investment, excess);\n', '        }\n', '\n', '        // commission\n', '        uint advertisingCommission = m_advertisingPercent.mul(investment);\n', '        uint adminsCommission = m_adminsPercent.mul(investment);\n', '        advertisingAddress.transfer(advertisingCommission);\n', '        adminsAddress.transfer(adminsCommission);\n', '\n', '        bool senderIsInvestor = m_investors.isInvestor(investorAddress);\n', '\n', '        // ref system works only once and only on first invest\n', '        if (referrerAddr.notZero() &&\n', '            !senderIsInvestor &&\n', '            !m_referrals[investorAddress] &&\n', '            referrerAddr != investorAddress &&\n', '            m_investors.isInvestor(referrerAddr)) {\n', '\n', '            // add referral bonus to investor`s and referral`s investments\n', '            uint refBonus = getRefBonusPercent().mmul(investment);\n', '            assert(m_investors.addInvestment(referrerAddr, refBonus)); // add referrer bonus\n', '            investment = investment.add(refBonus);                     // add referral bonus\n', '            m_referrals[investorAddress] = true;\n', '            emit LogNewReferral(investorAddress, referrerAddr, now, refBonus);\n', '        }\n', '\n', '        // Dividends cannot be greater then 150% from investor investment\n', '        uint maxDividends = getMaxDepositPercent().mmul(investment);\n', '\n', '        if (senderIsInvestor) {\n', '            // check for reinvest\n', '            InvestorsStorage.Investor memory investor = getMemInvestor(investorAddress);\n', '            if (investor.dividends.value == investor.dividends.limit) {\n', '                uint reinvestBonus = getReinvestBonusPercent().mmul(investment);\n', '                investment = investment.add(reinvestBonus);\n', '                maxDividends = getMaxDepositPercent().mmul(investment);\n', '                // reinvest\n', '                assert(m_investors.setNewInvestment(investorAddress, investment, maxDividends));\n', '                emit LogReinvest(investorAddress, now, investment);\n', '            } else {\n', '                // prevent burning dividends\n', '                uint dividends = calcDividends(investorAddress);\n', '                if (dividends.notZero()) {\n', '                    assert(m_investors.addDeferredDividends(investorAddress, dividends));\n', '                }\n', '                // update existing investor investment\n', '                assert(m_investors.addInvestment(investorAddress, investment));\n', '                assert(m_investors.addDividendsLimit(investorAddress, maxDividends));\n', '            }\n', '            assert(m_investors.setPaymentTime(investorAddress, now));\n', '        } else {\n', '            // create new investor\n', '            assert(m_investors.newInvestor(investorAddress, investment, now, maxDividends));\n', '            emit LogNewInvestor(investorAddress, now);\n', '        }\n', '\n', '        investmentsNumber++;\n', '        emit LogNewInvestment(investorAddress, now, investment, receivedEther);\n', '    }\n', '\n', '    function setAdvertisingAddress(address addr) public onlyOwner {\n', '        addr.requireNotZero();\n', '        advertisingAddress = addr;\n', '    }\n', '\n', '    function setAdminsAddress(address addr) public onlyOwner {\n', '        addr.requireNotZero();\n', '        adminsAddress = addr;\n', '    }\n', '\n', '    function getMemInvestor(\n', '        address investorAddr\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            InvestorsStorage.Investor memory\n', '        )\n', '    {\n', '        (\n', '            uint investment,\n', '            uint paymentTime,\n', '            uint dividends,\n', '            uint dividendsLimit,\n', '            uint dividendsDeferred\n', '        ) = m_investors.investorInfo(investorAddr);\n', '\n', '        return InvestorsStorage.Investor(\n', '            investment,\n', '            paymentTime,\n', '            InvestorsStorage.Dividends(\n', '                dividends,\n', '                dividendsLimit,\n', '                dividendsDeferred)\n', '        );\n', '    }\n', '\n', '    function calcDividends(address investorAddr) internal view returns(uint dividends) {\n', '        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\n', '        uint interval = 1 days;\n', '        uint pastTime = now.sub(investor.paymentTime);\n', '\n', '        // safe gas if dividends will be 0\n', '        if (investor.investment.isZero() || pastTime < interval) {\n', '            return 0;\n', '        }\n', '\n', '        // paid dividends cannot be greater then 150% from investor investment\n', '        if (investor.dividends.value >= investor.dividends.limit) {\n', '            return 0;\n', '        }\n', '\n', '        Percent.percent memory p = getDailyPercent(investor.investment);\n', '        Percent.percent memory c = Percent.percent(p.num + p.den, p.den);\n', '\n', '        uint intervals = pastTime.div(interval);\n', '        uint totalDividends = investor.dividends.limit.add(investor.investment).sub(investor.dividends.value).sub(investor.dividends.deferred);\n', '\n', '        dividends = investor.investment;\n', '        for (uint i = 0; i < intervals; i++) {\n', '            dividends = c.mmul(dividends);\n', '            if (dividends > totalDividends) {\n', '                dividends = totalDividends.add(investor.dividends.deferred);\n', '                break;\n', '            }\n', '        }\n', '\n', '        dividends = dividends.sub(investor.investment);\n', '\n', '        //uint totalDividends = dividends + investor.dividends;\n', '        //if (totalDividends >= investor.dividendsLimit) {\n', '        //    dividends = investor.dividendsLimit - investor.dividends;\n', '        //}\n', '    }\n', '\n', '    function getMaxDepositPercent() internal view returns(Percent.percent memory p) {\n', '        p = m_maxDepositPercent.toMemory();\n', '    }\n', '\n', '    function getDailyPercent(uint value) internal view returns(Percent.percent memory p) {\n', '        // (1) 1% if\xa00.01 ETH <= value < 0.1 ETH\n', '        // (2) 1.5% if\xa00.1 ETH <= value < 1 ETH\n', '        // (3) 2% if 1 ETH\xa0<= value < 5 ETH\n', '        // (4) 2.5% if 5 ETH <= value < 10 ETH\n', '        // (5) 3% if 10 ETH <= value < 20 ETH\n', '        // (6) 3.5% if 20 ETH <= value < 30 ETH\n', '        // (7) 4% if 30 ETH <= value <= 50 ETH\n', '\n', '        if (MIN_INVESTMENT <= value && value < 100 finney) {\n', '            p = m_1_percent.toMemory();                     // (1)\n', '        } else if (100 finney <= value && value < 1 ether) {\n', '            p = m_1_5_percent.toMemory();                   // (2)\n', '        } else if (1 ether <= value && value < 5 ether) {\n', '            p = m_2_percent.toMemory();                     // (3)\n', '        } else if (5 ether <= value && value < 10 ether) {\n', '            p = m_2_5_percent.toMemory();                   // (4)\n', '        } else if (10 ether <= value && value < 20 ether) {\n', '            p = m_3_percent.toMemory();                     // (5)\n', '        } else if (20 ether <= value && value < 30 ether) {\n', '            p = m_3_5_percent.toMemory();                   // (6)\n', '        } else if (30 ether <= value && value <= MAX_INVESTMENT) {\n', '            p = m_4_percent.toMemory();                     // (7)\n', '        }\n', '    }\n', '\n', '    function getRefBonusPercent() internal view returns(Percent.percent memory p) {\n', '        p = m_refPercent.toMemory();\n', '    }\n', '\n', '    function getReinvestBonusPercent() internal view returns(Percent.percent memory p) {\n', '        p = m_reinvestPercent.toMemory();\n', '    }\n', '}']