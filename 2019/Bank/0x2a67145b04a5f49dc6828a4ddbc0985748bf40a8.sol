['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-11\n', '*/\n', '\n', '/**\n', ' *created on 2019-07-11\n', '*/\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', '/*\n', '* RANLYTICS ICO CONTRACT\n', '* Offers dividend distribution-based returns for all token holders equivalent to that received by all RANlytics shareholders\n', '* 300,000 tokens on offer - no more can be created once quota is filled. Tokens generated as purchased\n', '* Each token is equivalent to 1 RANlytics share.\n', '* In the event that the company is sold, the total proceeds of the sale will be divided equally by the total pool of shares + tokens, \n', '* and both shareholders and token holders will receive payment from the proceeds of the sale proportionate to their total share or token holding.\n', '*/\n', '\n', 'contract Hourglass {\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyholders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with dividends\n', '    modifier hasDividends() {\n', '        require(myDividends() > 0);\n', '        _;\n', '    }\n', '    \n', '    // administrators can:\n', '    // -> change the name of the contract\n', '    // -> change the name of the token\n', '    // -> burn tokens in admin address\n', '    // -> close token buying\n', '    // they CANNOT:\n', '    // -> disable dividend withdrawals\n', '    // -> kill the contract\n', '    // -> change the price of tokens\n', '    modifier onlyAdministrator(){\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[_customerAddress]);\n', '        _;\n', '    }\n', '    \n', '    \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    event onCompanyBurn(\n', '        uint256 tokensBurnt\n', '    );\n', '    \n', '    // ERC20 spec\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "RANlytics Round C ICO";\n', '    string public symbol = "RANC";\n', '    uint8 constant public decimals = 18;\n', '    uint256 constant maxTokens = 300000*1e18;\n', '    address constant internal companyAccount_ = 0xbADEc210d7E0E4082f8e9BC7b1C1abCAb925F4b8;\n', '    \n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    // administrator list (see above on what they can do)\n', '    mapping(address => bool) public administrators;\n', '    \n', '    //lock further investments\n', '    bool internal locked_ = false;\n', '\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    function Hourglass()\n', '        public\n', '    {\n', '        // add administrators here\n', '        administrators[0xbADEc210d7E0E4082f8e9BC7b1C1abCAb925F4b8] = true;\n', '\n', '    }\n', '    \n', '     \n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller\n', '     */\n', '    function buy()\n', '        public\n', '        payable\n', '    {\n', '        purchaseTokens(msg.value);\n', '    }\n', '    \n', '    /**\n', '     * Fallback function to handle ethereum that was sent straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '        purchaseTokens(msg.value);\n', '    }\n', '    \n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        hasDividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(); \n', '        \n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] +=  (int256) (_dividends);\n', '        \n', '        \n', '        // lambo delivery service\n', '        _customerAddress.transfer(_dividends);\n', '        \n', '        // fire event\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    \n', '  \n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyholders()\n', '        public\n', '        returns(bool)\n', '    {\n', '        // setup\n', '        address _customerAddress = msg.sender;\n', '        \n', '        // make sure we have the requested tokens\n', '        // also disables transfers until ambassador phase is over\n', '        // ( we dont want whale premines )\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        \n', '        // withdraw all outstanding dividends first\n', '        if(myDividends() > 0) withdraw();\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\n', '        \n', '        // update dividend trackers\n', '        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens / 1e18);\n', '        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens / 1e18);\n', '        \n', '        \n', '        // fire event\n', '        Transfer(_customerAddress, _toAddress, _amountOfTokens);\n', '        \n', '        // ERC20\n', '        return true;\n', '       \n', '    }\n', '    \n', '\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '    /**\n', '     * In case one of us dies, we need to replace ourselves.\n', '     */\n', '    function setAdministrator(address _identifier, bool _status)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '    \n', '    function payDividend()\n', '        onlyAdministrator()\n', '        payable\n', '        public\n', '    {\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (msg.value * 1e18 ) / tokenSupply_);    \n', '    }\n', '    \n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setName(string _name)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        name = _name;\n', '    }\n', '    \n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setSymbol(string _symbol)\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        symbol = _symbol;\n', '    }\n', '\n', '    /**\n', '     *  If we want to burn tokens being converted to RANlytics shares.\n', '     */\n', '    function burnAdminTokens()\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        address _adminAddress = msg.sender;\n', '        require(tokenBalanceLedger_[_adminAddress] > 0);\n', '        \n', '        //decrease token supply\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, tokenBalanceLedger_[_adminAddress]);\n', '        \n', '        //burn tokens in admin address\n', '        tokenBalanceLedger_[_adminAddress] = 0;\n', '        \n', '        //fire event on burnt tokens\n', '        onCompanyBurn(tokenBalanceLedger_[_adminAddress]);\n', '    }\n', '\n', '     /**\n', '     * If we want to lock buying early, we can.\n', '     */\n', '    function lockBuying()\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        locked_ = true;\n', '    }\n', '    \n', '    /**\n', '     * dividends are rounded down to wei, as such we may see dust settle in the contract.\n', '     * admin has the ability to claim this dust\n', '     * Only call if all users have withdrawn all dividends\n', '     * the function can only work if dust left is less than 0.00010000 eth so admin can&#39;t claim unclaimed dividends\n', '     * \n', '     */\n', '    function cleanupEthInContract()\n', '        onlyAdministrator()\n', '        public\n', '    {\n', '        require(this.balance < 10000);\n', '         companyAccount_.transfer(this.balance);\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     * Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return this.balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return tokenSupply_;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the status of buying enabled or not.\n', '     * true if buying still possible\n', '     */\n', '    function buyOpen()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return !locked_;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     */ \n', '    function myDividends() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return  dividendsOf(_customerAddress) ;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return (uint256) ((int256)(SafeMath.mul(profitPerShare_ , tokenBalanceLedger_[_customerAddress] )) / 1e18 - payoutsTo_[_customerAddress]) ;\n', '    }\n', '    \n', '    \n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 _incomingEthereum)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        //we require the buy in is not locked\n', '        require(!locked_);\n', '        \n', '        //we require a minumum buyin of 0.1 ethereum\n', '        require(_incomingEthereum >= 1e17);\n', '        \n', '        // data setup\n', '        address _customerAddress = msg.sender;\n', '        uint256 _amountOfTokens = _incomingEthereum * 20;\n', '        \n', '        // no point in continuing execution if OP is a hacker\n', '        // prevents overflow in the case that the ICO somehow magically starts being used by everyone in the world\n', '        // (or hackers)\n', '        // and yes we know that the safemath function automatically rules out the "greater than" equation.\n', '        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n', '        \n', '        //any purchase over a total of 300,000 tokens is rejected\n', '        require(SafeMath.add(tokenSupply_, _amountOfTokens) < maxTokens);\n', '        \n', '        // we can&#39;t give people infinite ethereum\n', '        if(tokenSupply_ > 0){\n', '            \n', '            // add tokens to the pool\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '        \n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '        \n', '        //set the invest lock if more than 300000 tokens are allocated\n', '        //we will accept the last buyers order and allocate those shares over the 300000 shares as an over subscription.\n', '        if (tokenSupply_ > maxTokens) locked_ = true;\n', '        \n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        \n', '        // Tells the contract that the buyer doesn&#39;t deserve dividends for the tokens before they owned them;\n', '        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens / 1e18) );\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '        \n', '        //transfer all ethereum to RANLytics\n', '        companyAccount_.transfer(_incomingEthereum);\n', '        \n', '        // fire event\n', '        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '\n', '   \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']