['///auto-generated single file for verifying contract on etherscan\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract R1Exchange is SafeMath, Ownable {\n', '    mapping(address => bool) public admins;\n', '    mapping(address => bool) public feeAccounts;\n', '    // mapping(token address => mapping(owner address => mapping(channelId uint => uint256))) public tokenList;\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public tokenList;\n', '    // mapping(owner address =>  mapping(orderHash bytes32 => uint256)) public tokenList;\n', '    mapping(address => mapping(bytes32 => uint256)) public orderFilled;//tokens filled\n', '    mapping(bytes32 => bool) public withdrawn;\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public withdrawAllowance;\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public applyList;//withdraw apply list\n', '    mapping(address => mapping(address => mapping(uint256 => uint))) public latestApply;//save the latest apply timestamp\n', '    // mapping(owner address => mapping(channelId uint => nonce uint256))) public canceled;\n', '    mapping(address => mapping(uint256 => uint)) public canceled;\n', '    string public constant version = &#39;2.0.0&#39;;\n', '    uint public applyWait = 1 days;\n', '    uint public feeRate = 10;\n', '    bool public withdrawEnabled = false;\n', '    bool public stop = false;\n', '    uint256 private DEFAULT_CHANNEL_ID = 0;\n', '    bool public depositToEnabled = true;\n', '    bool public transferEnabled = false;\n', '    bool public changeChannelEnabled = false;\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\n', '    event DepositTo(address indexed token, address indexed from, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\n', '    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\n', '    event ApplyWithdraw(address indexed token, address indexed user, uint256 amount, uint256 time, uint256 channelId);\n', '    event ApproveWithdraw(address indexed token, address indexed user, uint256 channelId);\n', '    event Trade(address indexed maker, address indexed taker, uint256 amount, uint256 makerFee, uint256 takerFee, uint256 makerNonce, uint256 takerNonce);\n', '    event InnerTransfer(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 balance, uint256 channelId);\n', '    event ChangeChannel(address indexed token, address indexed user, uint256 amount, uint256 fromChannelId, uint256 toChannelId);\n', '    event BatchCancel(uint256 count, uint256 channelId);\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender]);\n', '        _;\n', '    }\n', '    modifier isWithdrawEnabled {\n', '        require(withdrawEnabled);\n', '        _;\n', '    }\n', '    modifier isFeeAccount(address fa) {\n', '        require(feeAccounts[fa]);\n', '        _;\n', '    }\n', '    modifier notStop() {\n', '        require(!stop);\n', '        _;\n', '    }\n', '    modifier isDepositToEnabled() {\n', '        require(depositToEnabled);\n', '        _;\n', '    }\n', '    modifier isTransferEnabled() {\n', '        require(transferEnabled);\n', '        _;\n', '    }\n', '    modifier isChangeChannelEnabled() {\n', '        require(changeChannelEnabled);\n', '        _;\n', '    }\n', '    function() public {\n', '        revert();\n', '    }\n', '    function setAdmin(address admin, bool isAdmin) public onlyOwner {\n', '        require(admin != 0);\n', '        admins[admin] = isAdmin;\n', '    }\n', '    function setFeeAccount(address acc, bool asFee) public onlyOwner {\n', '        require(acc != 0);\n', '        feeAccounts[acc] = asFee;\n', '    }\n', '    function enableWithdraw(bool enabled) public onlyOwner {\n', '        withdrawEnabled = enabled;\n', '    }\n', '    function enableDepositTo(bool enabled) public onlyOwner {\n', '        depositToEnabled = enabled;\n', '    }\n', '    function enableTransfer(bool enabled) public onlyOwner {\n', '        transferEnabled = enabled;\n', '    }\n', '    function enableChangeChannel(bool enabled) public onlyOwner {\n', '        changeChannelEnabled = enabled;\n', '    }\n', '    function changeLockTime(uint lock) public onlyOwner {\n', '        require(lock <= 7 days);\n', '        applyWait = lock;\n', '    }\n', '    function changeFeeRate(uint fr) public onlyOwner {\n', '        //max fee rate MUST <=10%\n', '        require(fr >= 10);\n', '        feeRate = fr;\n', '    }\n', '    function stopTrade() public onlyOwner {\n', '        stop = true;\n', '    }\n', '    /**\n', '    * cancel the order that before nonce.\n', '    **/\n', '    function batchCancel(address[] users, uint256[] nonces, uint256 channelId) public onlyAdmin {\n', '        require(users.length == nonces.length);\n', '        uint256 count = 0;\n', '        for (uint i = 0; i < users.length; i++) {\n', '            require(nonces[i] >= canceled[users[i]][channelId]);\n', '            canceled[users[i]][channelId] = nonces[i];\n', '            count++;\n', '        }\n', '        BatchCancel(count, channelId);\n', '    }\n', '    function deposit(uint256 channelId) public payable {\n', '        tokenList[0][msg.sender][channelId] = safeAdd(tokenList[0][msg.sender][channelId], msg.value);\n', '        Deposit(0, msg.sender, msg.value, tokenList[0][msg.sender][channelId], channelId);\n', '    }\n', '    function depositToken(address token, uint256 amount, uint256 channelId) public {\n', '        require(token != 0);\n', '        tokenList[token][msg.sender][channelId] = safeAdd(tokenList[token][msg.sender][channelId], amount);\n', '        require(Token(token).transferFrom(msg.sender, this, amount));\n', '        Deposit(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\n', '    }\n', '    function depositTo(address to, uint256 channelId) public payable isDepositToEnabled {\n', '        require(to != 0 && msg.value > 0);\n', '        tokenList[0][to][channelId] = safeAdd(tokenList[0][to][channelId], msg.value);\n', '        DepositTo(0, msg.sender, to, msg.value, tokenList[0][to][channelId], channelId);\n', '    }\n', '    function depositTokenTo(address token, address to, uint256 amount, uint256 channelId) public isDepositToEnabled {\n', '        require(token != 0 && to != 0 && amount > 0);\n', '        tokenList[token][to][channelId] = safeAdd(tokenList[token][to][channelId], amount);\n', '        require(Token(token).transferFrom(msg.sender, this, amount));\n', '        DepositTo(token, msg.sender, to, amount, tokenList[token][to][channelId], channelId);\n', '    }\n', '    function batchDepositTokenTo(address[] token, address[] to, uint256[] amount, uint256 channelId) public isDepositToEnabled {\n', '        require(to.length == amount.length && to.length <= 200);\n', '        for (uint i = 0; i < to.length; i++) {\n', '            depositTokenTo(token[i], to[i], amount[i], channelId);\n', '        }\n', '    }\n', '    function innerTransfer(address token, address to, uint256 amount, uint256 channelId) public isTransferEnabled {\n', '        require(to != 0);\n', '        require(amount <= tokenList[token][msg.sender][channelId]);\n', '        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\n', '        tokenList[token][to][channelId] = safeAdd(tokenList[token][to][channelId], amount);\n', '        InnerTransfer(token, msg.sender, to, amount, tokenList[token][msg.sender][channelId], channelId);\n', '    }\n', '    function batchInnerTransfer(address[] token, address[] to, uint256[] amount, uint256 channelId) public isTransferEnabled {\n', '        require(to.length == amount.length && to.length <= 200);\n', '        for (uint i = 0; i < to.length; i++) {\n', '            innerTransfer(token[i], to[i], amount[i], channelId);\n', '        }\n', '    }\n', '    function changeChannel(address token, uint256 amount, uint256 fromChannelId, uint256 toChannelId) public isChangeChannelEnabled {\n', '        require(amount <= tokenList[token][msg.sender][fromChannelId]);\n', '        tokenList[token][msg.sender][fromChannelId] = safeSub(tokenList[token][msg.sender][fromChannelId], amount);\n', '        tokenList[token][msg.sender][toChannelId] = safeAdd(tokenList[token][msg.sender][toChannelId], amount);\n', '        ChangeChannel(token, msg.sender, amount, fromChannelId, toChannelId);\n', '    }\n', '    function batchChangeChannel(address[] token, uint256[] amount, uint256 fromChannelId, uint256 toChannelId) public isChangeChannelEnabled {\n', '        require(token.length == amount.length && amount.length <= 200);\n', '        for (uint i = 0; i < amount.length; i++) {\n', '            changeChannel(token[i], amount[i], fromChannelId, toChannelId);\n', '        }\n', '    }\n', '    function applyWithdraw(address token, uint256 amount, uint256 channelId) public {\n', '        uint256 apply = safeAdd(applyList[token][msg.sender][channelId], amount);\n', '        require(safeAdd(apply, withdrawAllowance[token][msg.sender][channelId]) <= tokenList[token][msg.sender][channelId]);\n', '        applyList[token][msg.sender][channelId] = apply;\n', '        latestApply[token][msg.sender][channelId] = block.timestamp;\n', '        ApplyWithdraw(token, msg.sender, amount, block.timestamp, channelId);\n', '    }\n', '    /**\n', '    * approve user&#39;s withdraw application\n', '    **/\n', '    function approveWithdraw(address token, address user, uint256 channelId) public onlyAdmin {\n', '        withdrawAllowance[token][user][channelId] = safeAdd(withdrawAllowance[token][user][channelId], applyList[token][user][channelId]);\n', '        applyList[token][user][channelId] = 0;\n', '        latestApply[token][user][channelId] = 0;\n', '        ApproveWithdraw(token, user, channelId);\n', '    }\n', '    /**\n', '    * user&#39;s withdraw will success in two cases:\n', '    *    1. when the admin calls the approveWithdraw function;\n', '    * or 2. when the lock time has passed since the application;\n', '    **/\n', '    function withdraw(address token, uint256 amount, uint256 channelId) public {\n', '        require(amount <= tokenList[token][msg.sender][channelId]);\n', '        if (amount > withdrawAllowance[token][msg.sender][channelId]) {\n', '            //withdraw wait over time\n', '            require(latestApply[token][msg.sender][channelId] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender][channelId]) > applyWait);\n', '            withdrawAllowance[token][msg.sender][channelId] = safeAdd(withdrawAllowance[token][msg.sender][channelId], applyList[token][msg.sender][channelId]);\n', '            applyList[token][msg.sender][channelId] = 0;\n', '        }\n', '        require(amount <= withdrawAllowance[token][msg.sender][channelId]);\n', '        withdrawAllowance[token][msg.sender][channelId] = safeSub(withdrawAllowance[token][msg.sender][channelId], amount);\n', '        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\n', '        latestApply[token][msg.sender][channelId] = 0;\n', '        if (token == 0) {//withdraw ether\n', '            require(msg.sender.send(amount));\n', '        } else {//withdraw token\n', '            require(Token(token).transfer(msg.sender, amount));\n', '        }\n', '        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\n', '    }\n', '    /**\n', '    * withdraw directly when withdrawEnabled=true\n', '    **/\n', '    function withdrawNoLimit(address token, uint256 amount, uint256 channelId) public isWithdrawEnabled {\n', '        require(amount <= tokenList[token][msg.sender][channelId]);\n', '        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\n', '        if (token == 0) {//withdraw ether\n', '            require(msg.sender.send(amount));\n', '        } else {//withdraw token\n', '            require(Token(token).transfer(msg.sender, amount));\n', '        }\n', '        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\n', '    }\n', '    struct AdminWithdrawParam {\n', '        address user;\n', '        address token;\n', '        address feeAccount;\n', '        address channelFeeAccount;\n', '        uint256 amount;\n', '        uint256 nonce;\n', '        uint256 fee;\n', '        uint256 channelFee;\n', '        uint256 channelId;\n', '    }\n', '    /**\n', '    * admin withdraw according to user&#39;s signed withdraw info\n', '    * PARAMS:\n', '    * addresses:\n', '    * [0] user\n', '    * [1] token\n', '    * [2] feeAccount\n', '    * [3] channelFeeAccount\n', '    * values:\n', '    * [0] amount\n', '    * [1] nonce\n', '    * [2] fee\n', '    * [3] channelFee\n', '    * [4] channelId\n', '    **/\n', '    function adminWithdraw(address[4] addresses, uint256[5] values, uint8 v, bytes32 r, bytes32 s)\n', '    public\n', '    onlyAdmin\n', '    isFeeAccount(addresses[2])\n', '    {\n', '        AdminWithdrawParam memory param = AdminWithdrawParam({\n', '            user : addresses[0],\n', '            token : addresses[1],\n', '            feeAccount : addresses[2],\n', '            channelFeeAccount : addresses[3],\n', '            amount : values[0],\n', '            nonce : values[1],\n', '            fee : values[2],\n', '            channelFee : values[3],\n', '            channelId : values[4]\n', '            });\n', '        require(param.amount <= tokenList[param.token][param.user][param.channelId]);\n', '        param.fee = checkFee(param.amount, param.fee);\n', '        param.channelFee = checkFee(param.amount, param.channelFee);\n', '        bytes32 hash = keccak256(this, param.user, param.token, param.amount, param.nonce, param.channelFeeAccount, param.channelId);\n', '        require(!withdrawn[hash]);\n', '        withdrawn[hash] = true;\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == param.user);\n', '        tokenList[param.token][param.user][param.channelId] = safeSub(tokenList[param.token][param.user][param.channelId], param.amount);\n', '        tokenList[param.token][param.feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[param.token][param.feeAccount][DEFAULT_CHANNEL_ID], param.fee);\n', '        tokenList[param.token][param.channelFeeAccount][param.channelId] = safeAdd(tokenList[param.token][param.channelFeeAccount][param.channelId], param.channelFee);\n', '        param.amount = safeSub(param.amount, param.fee);\n', '        param.amount = safeSub(param.amount, param.channelFee);\n', '        if (param.token == 0) {//withdraw ether\n', '            require(param.user.send(param.amount));\n', '        } else {//withdraw token\n', '            require(Token(param.token).transfer(param.user, param.amount));\n', '        }\n', '        Withdraw(param.token, param.user, param.amount, tokenList[param.token][param.user][param.channelId], param.channelId);\n', '    }\n', '    function checkFee(uint256 amount, uint256 fee) private returns (uint256){\n', '        uint256 maxFee = fee;\n', '        if (safeMul(fee, feeRate) > amount) {\n', '            maxFee = amount / feeRate;\n', '        }\n', '        return maxFee;\n', '    }\n', '    function getOrderHash(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address base, uint256 expires, uint256 nonce, address feeToken, address channelFeeAccount, uint256 channelId) public view returns (bytes32) {\n', '        return keccak256(this, tokenBuy, amountBuy, tokenSell, amountSell, base, expires, nonce, feeToken, channelFeeAccount, channelId);\n', '    }\n', '    function balanceOf(address token, address user, uint256 channelId) public constant returns (uint256) {\n', '        return tokenList[token][user][channelId];\n', '    }\n', '    struct Order {\n', '        address tokenBuy;\n', '        address tokenSell;\n', '        uint256 amountBuy;\n', '        uint256 amountSell;\n', '        address user;\n', '        uint256 fee;\n', '        uint256 expires;\n', '        uint256 nonce;\n', '        bytes32 orderHash;\n', '        address baseToken;\n', '        address feeToken;//0:default;others:payed with erc-20 token\n', '        address channelFeeAccount;\n', '        uint256 channelFee;\n', '        uint256 channelId;\n', '    }\n', '    /**\n', '    * swap maker and taker&#39;s tokens according to their signed order info.\n', '    *\n', '    * PARAMS:\n', '    * addresses:\n', '    * [0]:maker tokenBuy\n', '    * [1]:taker tokenBuy\n', '    * [2]:maker tokenSell\n', '    * [3]:taker tokenSell\n', '    * [4]:maker user\n', '    * [5]:taker user\n', '    * [6]:maker baseTokenAddr .default:0 ,then baseToken is ETH\n', '    * [7]:taker baseTokenAddr .default:0 ,then baseToken is ETH\n', '    * [8]:maker feeToken .\n', '    * [9]:taker feeToken .\n', '    * [10]:feeAccount\n', '    * [11]:makerChannelAccount\n', '    * [12]:takerChannelAccount\n', '    * values:\n', '    * [0]:maker amountBuy\n', '    * [1]:taker amountBuy\n', '    * [2]:maker amountSell\n', '    * [3]:taker amountSell\n', '    * [4]:maker fee\n', '    * [5]:taker fee\n', '    * [6]:maker expires\n', '    * [7]:taker expires\n', '    * [8]:maker nonce\n', '    * [9]:taker nonce\n', '    * [10]:tradeAmount of token\n', '    * [11]:makerChannelFee\n', '    * [12]:takerChannelFee\n', '    * [13]:makerChannelId\n', '    * [14]:takerChannelId\n', '    * v,r,s:maker and taker&#39;s signature\n', '    **/\n', '    function trade(\n', '        address[13] addresses,\n', '        uint256[15] values,\n', '        uint8[2] v,\n', '        bytes32[2] r,\n', '        bytes32[2] s\n', '    ) public\n', '    onlyAdmin\n', '    isFeeAccount(addresses[10])\n', '    notStop\n', '    {\n', '        Order memory makerOrder = Order({\n', '            tokenBuy : addresses[0],\n', '            tokenSell : addresses[2],\n', '            user : addresses[4],\n', '            amountBuy : values[0],\n', '            amountSell : values[2],\n', '            fee : values[4],\n', '            expires : values[6],\n', '            nonce : values[8],\n', '            orderHash : 0,\n', '            baseToken : addresses[6],\n', '            feeToken : addresses[8],\n', '            channelFeeAccount : addresses[11],\n', '            channelFee : values[11],\n', '            channelId : values[13]\n', '            });\n', '        Order memory takerOrder = Order({\n', '            tokenBuy : addresses[1],\n', '            tokenSell : addresses[3],\n', '            user : addresses[5],\n', '            amountBuy : values[1],\n', '            amountSell : values[3],\n', '            fee : values[5],\n', '            expires : values[7],\n', '            nonce : values[9],\n', '            orderHash : 0,\n', '            baseToken : addresses[7],\n', '            feeToken : addresses[9],\n', '            channelFeeAccount : addresses[12],\n', '            channelFee : values[12],\n', '            channelId : values[14]\n', '            });\n', '        uint256 tradeAmount = values[10];\n', '        //check expires\n', '        require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);\n', '        //check order nonce canceled\n', '        require(makerOrder.nonce >= canceled[makerOrder.user][makerOrder.channelId] && takerOrder.nonce >= canceled[takerOrder.user][takerOrder.channelId]);\n', '        //make sure both is the same trade pair\n', '        require(makerOrder.baseToken == takerOrder.baseToken && makerOrder.tokenBuy == takerOrder.tokenSell && makerOrder.tokenSell == takerOrder.tokenBuy);\n', '        require(takerOrder.baseToken == takerOrder.tokenBuy || takerOrder.baseToken == takerOrder.tokenSell);\n', '        makerOrder.orderHash = getOrderHash(makerOrder.tokenBuy, makerOrder.amountBuy, makerOrder.tokenSell, makerOrder.amountSell, makerOrder.baseToken, makerOrder.expires, makerOrder.nonce, makerOrder.feeToken, makerOrder.channelFeeAccount, makerOrder.channelId);\n', '        takerOrder.orderHash = getOrderHash(takerOrder.tokenBuy, takerOrder.amountBuy, takerOrder.tokenSell, takerOrder.amountSell, takerOrder.baseToken, takerOrder.expires, takerOrder.nonce, takerOrder.feeToken, takerOrder.channelFeeAccount, takerOrder.channelId);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", makerOrder.orderHash), v[0], r[0], s[0]) == makerOrder.user);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", takerOrder.orderHash), v[1], r[1], s[1]) == takerOrder.user);\n', '        balance(makerOrder, takerOrder, addresses[10], tradeAmount);\n', '        //event\n', '        Trade(makerOrder.user, takerOrder.user, tradeAmount, makerOrder.fee, takerOrder.fee, makerOrder.nonce, takerOrder.nonce);\n', '    }\n', '    function balance(Order makerOrder, Order takerOrder, address feeAccount, uint256 tradeAmount) internal {\n', '        ///check the price meets the condition.\n', '        ///match condition: (makerOrder.amountSell*takerOrder.amountSell)/(makerOrder.amountBuy*takerOrder.amountBuy) >=1\n', '        require(safeMul(makerOrder.amountSell, takerOrder.amountSell) >= safeMul(makerOrder.amountBuy, takerOrder.amountBuy));\n', '        ///If the price is ok,always use maker&#39;s price first!\n', '        uint256 takerBuy = 0;\n', '        uint256 takerSell = 0;\n', '        if (takerOrder.baseToken == takerOrder.tokenBuy) {\n', '            //taker sell tokens\n', '            uint256 makerAmount = safeSub(makerOrder.amountBuy, orderFilled[makerOrder.user][makerOrder.orderHash]);\n', '            uint256 takerAmount = safeSub(takerOrder.amountSell, orderFilled[takerOrder.user][takerOrder.orderHash]);\n', '            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n', '            takerSell = tradeAmount;\n', '            takerBuy = safeMul(makerOrder.amountSell, takerSell) / makerOrder.amountBuy;\n', '            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerSell);\n', '            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerSell);\n', '        } else {\n', '            // taker buy tokens\n', '            takerAmount = safeSub(takerOrder.amountBuy, orderFilled[takerOrder.user][takerOrder.orderHash]);\n', '            makerAmount = safeSub(makerOrder.amountSell, orderFilled[makerOrder.user][makerOrder.orderHash]);\n', '            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n', '            takerBuy = tradeAmount;\n', '            takerSell = safeMul(makerOrder.amountBuy, takerBuy) / makerOrder.amountSell;\n', '            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerBuy);\n', '            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerBuy);\n', '        }\n', '        //taker give tokens\n', '        tokenList[takerOrder.tokenSell][takerOrder.user][takerOrder.channelId] = safeSub(tokenList[takerOrder.tokenSell][takerOrder.user][takerOrder.channelId], takerSell);\n', '        //taker get tokens\n', '        tokenList[takerOrder.tokenBuy][takerOrder.user][takerOrder.channelId] = safeAdd(tokenList[takerOrder.tokenBuy][takerOrder.user][takerOrder.channelId], takerBuy);\n', '        //maker give tokens\n', '        tokenList[makerOrder.tokenSell][makerOrder.user][makerOrder.channelId] = safeSub(tokenList[makerOrder.tokenSell][makerOrder.user][makerOrder.channelId], takerBuy);\n', '        //maker get tokens\n', '        tokenList[makerOrder.tokenBuy][makerOrder.user][makerOrder.channelId] = safeAdd(tokenList[makerOrder.tokenBuy][makerOrder.user][makerOrder.channelId], takerSell);\n', '        chargeFee(makerOrder, feeAccount, takerSell);\n', '        chargeFee(takerOrder, feeAccount, takerBuy);\n', '    }\n', '    ///charge fees.fee can be payed as other erc20 token or the tokens that user get\n', '    ///returns:fees to reduce from the user&#39;s tokenBuy\n', '    function chargeFee(Order order, address feeAccount, uint256 amountBuy) internal returns (uint256){\n', '        uint256 totalFee = 0;\n', '        if (order.feeToken != 0) {\n', '            ///use erc-20 token as fee .\n', '            //make sure the user has enough tokens\n', '            totalFee = safeAdd(order.fee, order.channelFee);\n', '            require(totalFee <= tokenList[order.feeToken][order.user][order.channelId]);\n', '            tokenList[order.feeToken][feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[order.feeToken][feeAccount][DEFAULT_CHANNEL_ID], order.fee);\n', '            tokenList[order.feeToken][order.channelFeeAccount][order.channelId] = safeAdd(tokenList[order.feeToken][order.channelFeeAccount][order.channelId], order.channelFee);\n', '            tokenList[order.feeToken][order.user][order.channelId] = safeSub(tokenList[order.feeToken][order.user][order.channelId], totalFee);\n', '        } else {\n', '            order.fee = checkFee(amountBuy, order.fee);\n', '            order.channelFee = checkFee(amountBuy, order.channelFee);\n', '            totalFee = safeAdd(order.fee, order.channelFee);\n', '            tokenList[order.tokenBuy][feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[order.tokenBuy][feeAccount][DEFAULT_CHANNEL_ID], order.fee);\n', '            tokenList[order.tokenBuy][order.channelFeeAccount][order.channelId] = safeAdd(tokenList[order.tokenBuy][order.channelFeeAccount][order.channelId], order.channelFee);\n', '            tokenList[order.tokenBuy][order.user][order.channelId] = safeSub(tokenList[order.tokenBuy][order.user][order.channelId], totalFee);\n', '        }\n', '    }\n', '    function batchTrade(\n', '        address[13][] addresses,\n', '        uint256[15][] values,\n', '        uint8[2][] v,\n', '        bytes32[2][] r,\n', '        bytes32[2][] s\n', '    ) public onlyAdmin {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            trade(addresses[i], values[i], v[i], r[i], s[i]);\n', '        }\n', '    }\n', '    ///help to refund token to users.this method is called when contract needs updating\n', '    function refund(address user, address[] tokens, uint256[] channelIds) public onlyAdmin {\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            for (uint j = 0; j < channelIds.length; j++) {\n', '                uint256 channelId = channelIds[j];\n', '                uint256 amount = tokenList[token][user][channelId];\n', '                if (amount > 0) {\n', '                    tokenList[token][user][channelId] = 0;\n', '                    if (token == 0) {//withdraw ether\n', '                        require(user.send(amount));\n', '                    } else {//withdraw token\n', '                        require(Token(token).transfer(user, amount));\n', '                    }\n', '                    Withdraw(token, user, amount, tokenList[token][user][channelId], channelId);\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']