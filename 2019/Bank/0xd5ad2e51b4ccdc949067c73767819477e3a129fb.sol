['pragma solidity ^0.4.25;\n', '\n', ' /*\n', '  * @title: SafeMath\n', '  * @dev: Helper contract functions to arithmatic operations safely.\n', '  */\n', 'contract SafeMath {\n', '  function Sub(uint128 a, uint128 b) pure public returns (uint128) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function Add(uint128 a, uint128 b) pure public returns (uint128) {\n', '    uint128 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', ' /*\n', '  * @title: Token\n', '  * @dev: Interface contract for ERC20 tokens\n', '  */\n', 'contract Token {\n', '  function totalSupply() public view returns (uint256 supply);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', ' /*\n', '  * @title: Dex\n', '  * @author Dexhigh Services Pvt. Ltd (https://www.dexhigh.com)\n', '  * @dev The Dex Contract implement all the required functionalities viz order sharing, local exchange etc.\n', '  */\n', 'contract DEX is SafeMath\n', '{\n', '    uint32 public lastTransferId = 1;\n', '\n', '    // Events\n', '    event NewDeposit(uint32 indexed exId, uint32  prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\n', '    event NewWithdraw(uint32 indexed exId, uint32  prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\n', '    uint32 public lastNewOrderId = 1;\n', '    event NewOrder(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qty, uint32 lastNewOrderId);\n', '    event NewCancel(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qt, uint32 lastNewOrderId);\n', '    event NewBestBidAsk(uint32 indexed prTrade, uint32 indexed prBase, bool isBid, uint80 price);\n', '    uint32 public lastTradeId = 1;\n', '    event NewTrade(uint32 indexed prTrade, uint32 prBase, uint32 indexed bidId, uint32 indexed askId, uint32 accountIdBid, uint32 accountIdAsk, bool isSell, uint80 price, uint104 qty, uint32 lastTradeId, uint64 timestamp);\n', '\n', '    // basePrice, All the prices will be "based" by basePrice\n', '    uint256 public constant basePrice = 10000000000;\n', '    uint80 public constant maxPrice = 10000000000000000000001;\n', '    uint104 public constant maxQty = 1000000000000000000000000000001;\n', '    uint128 public constant maxBalance = 1000000000000000000000000000000000001;\n', '    bool public isContractUse = true;\n', '\n', '    //No Args constructor will add msg.sender as owner/operator\n', '    // Add ETH product\n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '        operator = owner;\n', '        AddOwner(msg.sender);\n', '        AddProduct(18, 0x0);\n', '        //lastProductId = 1; // productId == 1 -> ETH 0x0\n', '    }\n', '\n', '    address public owner;\n', '    // Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public operator;\n', '    // Functions with this modifier can only be executed by the operator\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator);\n', '        _;\n', '    }\n', '    function transferOperator(address _operator) onlyOwner public {\n', '        operator = _operator;\n', '    }\n', '\n', '    // Functions with this modifier can only be executed by the owner of each exchange\n', '    modifier onlyExOwner()  {\n', '        require(owner_id[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    // Functions with this modifier can only be executed when this contract is not abandoned\n', '    modifier onlyContractUse {\n', '        require(isContractUse == true);\n', '        _;\n', '    }\n', '\n', '    uint32 public lastOwnerId;\n', '    mapping (uint32 => address) id_owner;\n', '    mapping (address => uint32) owner_id;\n', '    mapping (uint32 => uint8) ownerId_takerFeeRateLocal;\n', '    mapping (uint32 => uint32) ownerId_accountId;\n', '\n', '    //Delete the owner of exchange\n', '    function DeleteOwner(uint32 exId) onlyOperator public\n', '    {\n', '        require(lastOwnerId >= exId && exId > 0);\n', '        owner_id[id_owner[exId]] = 0;\n', '    }\n', '\n', '    //Add Owner of exchange\n', '    function AddOwner(address newOwner) onlyOperator public\n', '    {\n', '        require(owner_id[newOwner] == 0);\n', '\n', '        owner_id[newOwner] = ++lastOwnerId;\n', '        id_owner[lastOwnerId] = newOwner;\n', '\n', '        ownerId_accountId[lastOwnerId] = FindOrAddAccount();\n', '    }\n', '    //Get exchange owner list and id\n', '    function GetOwnerList() view public returns (address[] owners, uint32[] ownerIds)\n', '    {\n', '        owners = new address[](lastOwnerId);\n', '        ownerIds = new uint32[](lastOwnerId);\n', '\n', '        for (uint32 i = 1; i <= lastOwnerId; i++)\n', '        {\n', '            owners[i - 1] = id_owner[i];\n', '            ownerIds[i - 1] = i;\n', '        }\n', '    }\n', '    //Set local exchange fee\n', '    function setTakerFeeRateLocal(uint8 _takerFeeRate) public\n', '    {\n', '        require (_takerFeeRate <= 100);// takerFeeRate cannot be more than 1%\n', '        uint32 ownerId = owner_id[msg.sender];\n', '        require(ownerId != 0);\n', '        ownerId_takerFeeRateLocal[ownerId] = _takerFeeRate;//bp\n', '    }\n', '    // Get fee Rate for an exchange with owner id == ownerId\n', '    function getTakerFeeRateLocal(uint32 ownerId) public view returns (uint8)\n', '    {\n', '        return ownerId_takerFeeRateLocal[ownerId];//bp\n', '    }\n', '\n', '    //Air Drop events\n', '    function airDrop(uint32 exId, uint32 prCode, uint32[] accountIds, uint104[] qtys) onlyExOwner public\n', '    {\n', '        uint32 accountId = FindOrRevertAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        uint256 n = accountIds.length;\n', '        require(n == qtys.length);\n', '\n', '        uint128 sum = 0;\n', '        for (uint32 i = 0; i < n; i++)\n', '        {\n', '            sum += qtys[i];\n', '        }\n', '\n', '        exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, sum);\n', '\n', '        for (i = 0; i < n; i++)\n', '        {\n', '            exId_prCode_AccountId_Balance[exId][prCode][accountIds[i]].available += qtys[i];\n', '            // exId_prCode_AccountId_Balance[exId][prCode][accountIds[i]].available >> qtys[i]\n', '            // 2^128 >> 2^104 -> minimum 2^24 times of airdrop need for overflow (hard to imagine)\n', '            // because prCode_AccountId_Balance[prCode][accountIds[i]].available restircted by maxBalance in deposit function\n', '        }\n', '    }\n', '\n', '    //information of product\n', '    struct ProductInfo\n', '    {\n', '        uint256 divider;\n', '        bool isTradeBid;\n', '        bool isTradeAsk;\n', '        bool isDeposit;\n', '        bool isWithdraw;\n', '        uint32 ownerId;\n', '        uint104 minQty;\n', '    }\n', '\n', '    uint32 public lastProductId;\n', '    uint256 public newProductFee;\n', '    mapping (uint32 => address) prCode_product;\n', '    mapping (address => uint32) product_prCode;\n', '    mapping (uint32 => ProductInfo) prCode_productInfo;\n', '\n', '    // Add product by exchange owner\n', '    function AddProduct(uint256 decimals, address product) payable onlyExOwner public\n', '    {\n', '        require(msg.value >= newProductFee || msg.sender == operator);\n', '        require(product_prCode[product] == 0);\n', '        require(decimals <= 18);\n', '\n', '        product_prCode[product] = ++lastProductId;\n', '        prCode_product[lastProductId] = product;\n', '\n', '        ProductInfo memory productInfo;\n', '        productInfo.divider = 10 ** decimals; // max = 10 ^ 18 because of require(decimals <= 18);\n', '        productInfo.ownerId = owner_id[msg.sender];\n', '        prCode_productInfo[lastProductId] = productInfo;\n', '\n', '        exId_prCode_AccountId_Balance[1][1][ownerId_accountId[1]].available += uint128(msg.value); //eth transfer < 2^128\n', '    }\n', '    // Set Product Information\n', '    function SetProductInfo(uint32 prCode, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint104 _minQty, uint32 exId) public\n', '    {\n', '        ProductInfo storage prInfo = prCode_productInfo[prCode];\n', '\n', '        require(msg.sender == operator || owner_id[msg.sender] == prInfo.ownerId );\n', '\n', '        prInfo.isTradeBid = isTradeBid;\n', '        prInfo.isTradeAsk = isTradeAsk;\n', '        prInfo.isDeposit = isDeposit;\n', '        prInfo.isWithdraw = isWithdraw;\n', '        prInfo.minQty = _minQty;\n', '        prInfo.ownerId = exId;\n', '    }\n', '    // Set product listing fee\n', '    function SetProductFee(uint256 productFee) onlyOperator public\n', '    {\n', '        newProductFee = productFee;\n', '    }\n', '    // Get product address and id\n', '    function GetProductList() view public returns (address[] products, uint32[] productIds)\n', '    {\n', '        products = new address[](lastProductId);\n', '        productIds = new uint32[](lastProductId);\n', '\n', '        for (uint32 i = 1; i <= lastProductId; i++)\n', '        {\n', '            products[i - 1] = prCode_product[i];\n', '            productIds[i - 1] = i;\n', '        }\n', '    }\n', '    // Get infromation of product\n', '    function GetProductInfo(address product) view public returns (uint32 prCode, uint256 divider, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint32 ownerId, uint104 minQty)\n', '    {\n', '        prCode = product_prCode[product];\n', '\n', '        divider = prCode_productInfo[prCode].divider;\n', '        isTradeBid = prCode_productInfo[prCode].isTradeBid;\n', '        isTradeAsk = prCode_productInfo[prCode].isTradeAsk;\n', '        isDeposit = prCode_productInfo[prCode].isDeposit;\n', '        isWithdraw = prCode_productInfo[prCode].isWithdraw;\n', '        ownerId = prCode_productInfo[prCode].ownerId;\n', '        minQty = prCode_productInfo[prCode].minQty;\n', '    }\n', '\n', '    uint32 public lastAcccountId;\n', '    mapping (uint32 => uint8) id_announceLV;\n', '    //Each announceLV open information as\n', '    //0: None, 1: Trade, 2:Balance, 3:DepositWithdrawal, 4:OpenOrder\n', '    mapping (uint32 => address) id_account;\n', '    mapping (uint32 => bool) accountId_freeze;\n', '    mapping (address => uint32) account_id;\n', '    // Find or add account\n', '    function FindOrAddAccount() private returns (uint32)\n', '    {\n', '        if (account_id[msg.sender] == 0)\n', '        {\n', '            account_id[msg.sender] = ++lastAcccountId;\n', '            id_account[lastAcccountId] = msg.sender;\n', '        }\n', '        return account_id[msg.sender];\n', '    }\n', '    // Find or revert account\n', '    function FindOrRevertAccount() private view returns (uint32)\n', '    {\n', '        uint32 accountId = account_id[msg.sender];\n', '        require(accountId != 0);\n', '        return accountId;\n', '    }\n', '    // Get account id of msg sender\n', '    function GetMyAccountId() view public returns (uint32)\n', '    {\n', '        return account_id[msg.sender];\n', '    }\n', '    // Get account id of any users\n', '    function GetAccountId(address account) view public returns (uint32)\n', '    {\n', '        return account_id[account];\n', '    }\n', '    // Get account announcement level\n', '    function GetMyAnnounceLV() view public returns (uint32)\n', '    {\n', '        return id_announceLV[account_id[msg.sender]];\n', '    }\n', '    // Set account announce level\n', '    function ChangeAnnounceLV(uint8 announceLV) public\n', '    {\n', '        id_announceLV[FindOrRevertAccount()] = announceLV;\n', '    }\n', '    // Freeze or unfreez of account\n', '    function SetFreezeByAddress(bool isFreeze, address account) onlyOperator public\n', '    {\n', '        uint32 accountId = account_id[account];\n', '\n', '        if (accountId != 0)\n', '        {\n', '            accountId_freeze[accountId] = isFreeze;\n', '        }\n', '    }\n', '\n', '    // reserved: Balance held up in orderBook\n', '    // available: Balance available for trade\n', '    struct Balance\n', '    {\n', '        uint128 reserved;\n', '        uint128 available;\n', '    }\n', '\n', '    struct ListItem\n', '    {\n', '        uint32 prev;\n', '        uint32 next;\n', '    }\n', '\n', '    struct OrderLink\n', '    {\n', '        uint32 firstId;\n', '        uint32 lastId;\n', '        uint80 nextPrice;\n', '        uint80 prevPrice;\n', '        mapping (uint32 => ListItem) id_orderList;\n', '    }\n', '\n', '    struct Order\n', '    {\n', '        uint32 exId;\n', '        uint32 accountId;\n', '        uint32 prTrade;\n', '        uint32 prBase;\n', '        uint104 qty;\n', '        uint80 price;\n', '        bool isSell;\n', '    }\n', '\n', '    uint32 public lastOrderId;\n', '    mapping (uint32 => Order) id_Order;\n', '\n', '    //orderbook information\n', '    struct OrderBook\n', '    {\n', '        uint8 tickSize;\n', '\n', '        uint80 bestBidPrice;\n', '        uint80 bestAskPrice;\n', '\n', '        mapping (uint80 => OrderLink) bidPrice_Order;\n', '        mapping (uint80 => OrderLink) askPrice_Order;\n', '    }\n', '    mapping (uint32 => mapping (uint32 => OrderBook)) basePID_tradePID_orderBook;\n', '    function SetOrderBookTickSize(uint32 prTrade, uint32 prBase, uint8 _tickSize) onlyOperator public\n', '    {\n', '        basePID_tradePID_orderBook[prBase][prTrade].tickSize = _tickSize;\n', '    }\n', '\n', '    mapping (uint32 => mapping (uint32 => mapping (uint32 => Balance))) exId_prCode_AccountId_Balance;\n', '\n', '    // open order list\n', '    struct OpenOrder\n', '    {\n', '        uint32 startId;\n', '        mapping(uint32 => ListItem) id_orderList;\n', '    }\n', '    mapping(uint32 => OpenOrder) accountId_OpenOrder;\n', '    function AddOpenOrder(uint32 accountId, uint32 orderId) private\n', '    {\n', '        OpenOrder memory openOrder = accountId_OpenOrder[accountId];\n', '\n', '        if (openOrder.startId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[openOrder.startId].prev = orderId;\n', '            accountId_OpenOrder[accountId].id_orderList[orderId].next = openOrder.startId;\n', '        }\n', '        accountId_OpenOrder[accountId].startId = orderId;\n', '    }\n', '    function RemoveOpenOrder(uint32 accountId, uint32 orderId) private\n', '    {\n', '        OpenOrder memory openOrder = accountId_OpenOrder[accountId];\n', '\n', '        uint32 nextId = accountId_OpenOrder[accountId].id_orderList[orderId].next;\n', '        uint32 prevId = accountId_OpenOrder[accountId].id_orderList[orderId].prev;\n', '\n', '        if (nextId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[nextId].prev = prevId;\n', '        }\n', '\n', '        if (prevId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[prevId].next = nextId;\n', '        }\n', '\n', '        if (openOrder.startId == orderId)\n', '        {\n', '            accountId_OpenOrder[accountId].startId = nextId;\n', '        }\n', '    }\n', '\n', '    //withdrawal and deposit record (DW records)\n', '    struct DWrecord\n', '    {\n', '        uint32 prCode;\n', '        bool isDeposit;\n', '        uint128 qty;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    struct DWrecords\n', '    {\n', '        uint32 N;\n', '        mapping (uint32 => DWrecord) N_DWrecord;\n', '    }\n', '    mapping (uint32 => mapping (uint32 => DWrecords)) exId_AccountId_DWrecords;\n', '\n', '    //record deposit and withdrawal\n', '    function RecordDW(uint32 exId, uint32 accountId, uint32 prCode, bool isDeposit, uint128 qty) private\n', '    {\n', '        DWrecord memory dW;\n', '        dW.isDeposit = isDeposit;\n', '        dW.prCode = prCode;\n', '        dW.qty = qty;\n', '        dW.timestamp = uint64(now);\n', '\n', '        exId_AccountId_DWrecords[exId][accountId].N_DWrecord[++exId_AccountId_DWrecords[exId][accountId].N] = dW;\n', '\n', '        if (isDeposit == true)\n', '            emit NewDeposit(exId, prCode, accountId, qty, dW.timestamp, lastTransferId++);\n', '        else\n', '            emit NewWithdraw(exId, prCode, accountId, qty, dW.timestamp, lastTransferId++);\n', '    }\n', "    // returns 'N', DW  records with account id, accountId, for exchange id, exId\n", '    function GetDWrecords(uint32 N, uint32 exId, uint32 accountId) view public returns (uint32[] prCode, bool[] isDeposit, uint128[] qty, uint64[] timestamp)\n', '    {\n', '        checkAnnounceLV(accountId, 3);\n', '\n', '        DWrecords storage dWrecords = exId_AccountId_DWrecords[exId][accountId];\n', '        uint32 n = dWrecords.N;\n', '\n', '        if (n > N)\n', '            n = N;\n', '\n', '        prCode = new uint32[](n);\n', '        isDeposit = new bool[](n);\n', '        qty = new uint128[](n);\n', '        timestamp = new uint64[](n);\n', '\n', '        for (uint32 i = dWrecords.N; i > dWrecords.N - n; i--)\n', '        {\n', '            N = dWrecords.N - i;\n', '            prCode[N] = dWrecords.N_DWrecord[i].prCode;\n', '            isDeposit[N] = dWrecords.N_DWrecord[i].isDeposit;\n', '            qty[N] = dWrecords.N_DWrecord[i].qty;\n', '            timestamp[N] = dWrecords.N_DWrecord[i].timestamp;\n', '        }\n', '    }\n', '\n', '    //Deposit ETH to exchange\n', '    function depositETH(uint32 exId) payable onlyContractUse public\n', '    {\n', '        require(exId <= lastOwnerId);\n', '        uint32 accountId = FindOrAddAccount();\n', '        exId_prCode_AccountId_Balance[exId][1][accountId].available = Add(exId_prCode_AccountId_Balance[exId][1][accountId].available, uint128(msg.value));\n', '        RecordDW(exId, accountId, 1, true, uint104(msg.value));\n', '    }\n', '    // Withdraw ETH from exchange\n', '    function withdrawETH(uint32 exId, uint104 amount) public\n', '    {\n', '        uint32 accountId = FindOrRevertAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        exId_prCode_AccountId_Balance[exId][1][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][1][accountId].available, amount);\n', '        require(msg.sender.send(amount));\n', '        RecordDW(exId, accountId, 1, false,  amount);\n', '    }\n', "    // Deposit/Withdraw, ERC20's to exchange\n", '    function depositWithdrawToken(uint32 exId, uint128 amount, bool isDeposit, address prAddress) public\n', '    {\n', '        uint32 prCode = product_prCode[prAddress];\n', '        require(amount < maxBalance && prCode != 0);\n', '        uint32 accountId = FindOrAddAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '\n', '        if (isDeposit == true)\n', '        {\n', '            require(prCode_productInfo[prCode].isDeposit == true && isContractUse == true && exId <= lastOwnerId);\n', '            require(Token(prAddress).transferFrom(msg.sender, this, amount));\n', '            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Add(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);\n', '            require (exId_prCode_AccountId_Balance[exId][prCode][accountId].available < maxBalance);\n', '        }\n', '        else\n', '        {\n', '            require(prCode_productInfo[prCode].isWithdraw == true);\n', '            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);\n', '            require(Token(prAddress).transfer(msg.sender, amount));\n', '        }\n', '        RecordDW(exId, accountId, prCode, isDeposit, amount);\n', '    }\n', '\n', '    // This function will be never used in normal situations.\n', '    // This function is only prepared for emergency case such as smart contract hacking Vulnerability or smart contract abolishment\n', '    // Withdrawn fund by this function cannot belong to any exchange operators or owners.\n', '    // Withdrawn fund should be distributed to individual accounts having original ownership of withdrawn fund.\n', '    // After using this function, this contract cannot get any deposit or trade.\n', '    // After using this function, this contract will be abolished.\n', '    function emergencyWithdrawal(uint32 prCode, uint256 amount) onlyOwner public\n', '    {\n', '        isContractUse = false;//This cannot be return. After activating this, this contract cannot support any deposit or trade function.\n', '        if (prCode == 1)\n', '            require(msg.sender.send(amount));\n', '        else\n', '            Token(prCode_product[prCode]).transfer(msg.sender, amount);\n', '    }\n', '\n', '    // Find tick size of each price\n', '    function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)\n', '    {\n', '        if (price > 0)\n', '        {\n', '            uint80 tick = GetTick(price, n);\n', '\n', '            if (isAsk == true)\n', '                return (((price - 1) / tick) + 1) * tick;\n', '            else\n', '                return (price / tick) * tick;\n', '        }\n', '        else\n', '        {\n', '            return price;\n', '        }\n', '    }\n', '\n', '    function GetTick(uint80 price, uint8 n)  public pure returns  (uint80)\n', '    {\n', '        if (n < 1)\n', '            n = 1;\n', '\n', '        uint80 x = 1;\n', '\n', '        for (uint8 i=1; i <= n / 2; i++)\n', '        {\n', '            x *= 10;\n', '        }\n', '\n', '        if (price < 10 * x)\n', '            return 1;\n', '        else\n', '        {\n', '            uint80 tick = 10000;\n', '\n', '            uint80 priceTenPercent = price / 10 / x;\n', '\n', '            while (priceTenPercent > tick)\n', '            {\n', '                tick *= 10;\n', '            }\n', '\n', '            while (priceTenPercent < tick)\n', '            {\n', '                tick /= 10;\n', '            }\n', '\n', '            if (n % 2 == 1)\n', '            {\n', '                if (price >= 50 * tick * x)\n', '                {\n', '                    tick *= 5;\n', '                }\n', '            }\n', '            else\n', '            {\n', '                if (price < 50 * tick * x)\n', '                {\n', '                    tick *= 5;\n', '                }\n', '                else\n', '                {\n', '                    tick *= 10;\n', '                }\n', '\n', '            }\n', '\n', '            return tick;\n', '        }\n', '    }\n', '    // New limit order\n', '    function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)\n', '    {\n', '        uint32 accountId = FindOrRevertAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        uint80 lastBestPrice;\n', '        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];\n', '        require(price != 0 && price <= maxPrice && qty <= maxQty &&\n', '            ((isSell == false && prCode_productInfo[prTrade].isTradeBid == true && prCode_productInfo[prBase].isTradeAsk == true)\n', '            || (isSell == true && prCode_productInfo[prTrade].isTradeAsk == true && prCode_productInfo[prBase].isTradeBid == true))\n', '            && prCode_productInfo[prTrade].minQty <= qty);\n', '\n', '        if (isSell == true)\n', '        {\n', '            price = GetNextTick(true, price, orderBook.tickSize);\n', '            lastBestPrice = orderBook.bestAskPrice;\n', '        }\n', '        else\n', '        {\n', '            price = GetNextTick(false, price, orderBook.tickSize);\n', '            lastBestPrice = orderBook.bestBidPrice;\n', '        }\n', '\n', '        Order memory order;\n', '        order.exId = exId;\n', '        order.isSell = isSell;\n', '        order.prTrade = prTrade;\n', '        order.prBase = prBase;\n', '        order.accountId = accountId;\n', '        order.price = price;\n', '        order.qty = qty;\n', '\n', '        require (IsPossibleLimit(exId, order));\n', '\n', '        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);\n', '\n', '        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));\n', '\n', '        if (order.qty != 0)\n', '        {\n', '            uint80 priceNext;\n', '            uint80 price0;\n', '\n', '            if (isSell == true)\n', '            {\n', '                price0 = orderBook.bestAskPrice;\n', '                if (price0 == 0)\n', '                {\n', '                    orderBook.askPrice_Order[price].prevPrice = 0;\n', '                    orderBook.askPrice_Order[price].nextPrice = 0;\n', '                    orderBook.bestAskPrice = price;\n', '                }\n', '                else if(price < price0)\n', '                {\n', '                    orderBook.askPrice_Order[price0].prevPrice = price;\n', '                    orderBook.askPrice_Order[price].prevPrice = 0;\n', '                    orderBook.askPrice_Order[price].nextPrice = price0;\n', '                    orderBook.bestAskPrice = price;\n', '                }\n', '                else if (orderBook.askPrice_Order[price].firstId == 0)\n', '                {\n', '                    priceNext = price0;\n', '\n', '                    while (priceNext != 0 && priceNext < price)\n', '                    {\n', '                        price0 = priceNext;\n', '                        priceNext = orderBook.askPrice_Order[price0].nextPrice;\n', '                    }\n', '\n', '                    orderBook.askPrice_Order[price0].nextPrice = price;\n', '                    orderBook.askPrice_Order[price].prevPrice = price0;\n', '                    orderBook.askPrice_Order[price].nextPrice = priceNext;\n', '                    if (priceNext != 0)\n', '                    {\n', '                        orderBook.askPrice_Order[priceNext].prevPrice = price;\n', '                    }\n', '                }\n', '\n', '                OrderLink storage orderLink = orderBook.askPrice_Order[price];\n', '            }\n', '            else\n', '            {\n', '                price0 = orderBook.bestBidPrice;\n', '                if (price0 == 0)\n', '                {\n', '                    orderBook.bidPrice_Order[price].prevPrice = 0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = 0;\n', '                    orderBook.bestBidPrice = price;\n', '                }\n', '                else if (price > price0)\n', '                {\n', '                    orderBook.bidPrice_Order[price0].prevPrice = price;\n', '                    orderBook.bidPrice_Order[price].prevPrice = 0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = price0;\n', '                    orderBook.bestBidPrice = price;\n', '                }\n', '                else if (orderBook.bidPrice_Order[price].firstId == 0)\n', '                {\n', '                    priceNext = price0;\n', '\n', '                    while (priceNext != 0 && priceNext > price)\n', '                    {\n', '                        price0 = priceNext;\n', '                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;\n', '                    }\n', '\n', '                    orderBook.bidPrice_Order[price0].nextPrice = price;\n', '                    orderBook.bidPrice_Order[price].prevPrice = price0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = priceNext;\n', '                    if (priceNext != 0)\n', '                    {\n', '                        orderBook.bidPrice_Order[priceNext].prevPrice = price;\n', '                    }\n', '                }\n', '\n', '                orderLink = orderBook.bidPrice_Order[price];\n', '            }\n', '\n', '            if (lastOrderId != 0)\n', '            {\n', '                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;\n', '                if (orderLink.firstId != 0)\n', '                {\n', '                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;\n', '                }\n', '                else\n', '                {\n', '                    orderLink.id_orderList[lastOrderId].next = 0;\n', '                    orderLink.firstId = lastOrderId;\n', '                }\n', '                orderLink.lastId = lastOrderId;\n', '            }\n', '\n', '            AddOpenOrder(accountId, lastOrderId);\n', '            id_Order[lastOrderId] = order;\n', '        }\n', '\n', '        if (isSell == true && lastBestPrice != orderBook.bestAskPrice)\n', '        {\n', '            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);\n', '        }\n', '        if (isSell == false && lastBestPrice != orderBook.bestBidPrice)\n', '        {\n', '            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);\n', '        }\n', '\n', '        return lastOrderId;\n', '    }\n', '\n', '    function BalanceUpdateByLimitAfterTrade(Order order, uint104 qty, uint104 tradedQty) private\n', '    {\n', '        uint32 exId = order.exId;\n', '        uint32 accountId = order.accountId;\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        uint80 price = order.price;\n', '        uint104 orderQty = order.qty;\n', '\n', '        if (order.isSell)\n', '        {\n', '            Balance storage balance = exId_prCode_AccountId_Balance[exId][prTrade][accountId];\n', '            balance.available = Sub(balance.available, qty);\n', '\n', '            if (orderQty != 0)\n', '                balance.reserved = Add(balance.reserved, orderQty);\n', '        }\n', '        else\n', '        {\n', '            balance = exId_prCode_AccountId_Balance[exId][prBase][accountId];\n', '            if (orderQty != 0)\n', '            {\n', '                // prCode_productInfo[prBase].divider * qty * price < 2^60 * 2^80 * 2^104 < 2^256\n', '                uint256 temp = prCode_productInfo[prBase].divider * orderQty * price / basePrice / prCode_productInfo[prTrade].divider;\n', '                require (temp < maxQty); // temp < maxQty < 2^104\n', '                balance.available = Sub(balance.available, tradedQty + uint104(temp));\n', '                balance.reserved = Add(balance.reserved, uint104(temp));\n', '            }\n', '            else\n', '            {\n', '                balance.available = Sub(balance.available, tradedQty);\n', '            }\n', '            tradedQty = qty - orderQty;\n', '\n', '            prBase = prTrade;\n', '        }\n', '        if (tradedQty != 0)\n', '        {\n', '            uint104 takeFeeLocal = tradedQty * ownerId_takerFeeRateLocal[exId] / 10000;\n', '            exId_prCode_AccountId_Balance[exId][prBase][accountId].available += tradedQty - takeFeeLocal;\n', '            exId_prCode_AccountId_Balance[exId][prBase][ownerId_accountId[exId]].available += takeFeeLocal;\n', '        }\n', '    }\n', '\n', '    function IsPossibleLimit(uint32 exId, Order memory order) private view returns (bool)\n', '    {\n', '        if (order.isSell)\n', '        {\n', '            if (exId_prCode_AccountId_Balance[exId][order.prTrade][order.accountId].available >= order.qty)\n', '                return true;\n', '            else\n', '                return false;\n', '        }\n', '        else\n', '        {\n', '            if (exId_prCode_AccountId_Balance[exId][order.prBase][order.accountId].available >= prCode_productInfo[order.prBase].divider * order.qty * order.price / basePrice / prCode_productInfo[order.prTrade].divider)\n', '                return true;\n', '            else\n', '                return false;\n', '        }\n', '    }\n', "    // Heart of DexHI's onchain order matching algorithm\n", '    function matchOrder(OrderBook storage ob, Order memory order, uint32 id) private returns (uint104)\n', '    {\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        uint80 tradePrice;\n', '\n', '        if (order.isSell == true)\n', '            tradePrice = ob.bestBidPrice;\n', '        else\n', '            tradePrice = ob.bestAskPrice;\n', '\n', '        bool isBestPriceUpdate = false;\n', '\n', '        uint104 qtyBase = 0;\n', '        uint104 tradeAmount;\n', '\n', '        while (tradePrice != 0 && order.qty > 0 && ((order.isSell && order.price <= tradePrice) || (!order.isSell && order.price >= tradePrice)))\n', '        {\n', '            if (order.isSell == true)\n', '                OrderLink storage orderLink = ob.bidPrice_Order[tradePrice];\n', '            else\n', '                orderLink = ob.askPrice_Order[tradePrice];\n', '\n', '            uint32 orderId = orderLink.firstId;\n', '\n', '            while (orderLink.firstId != 0 && orderId != 0 && order.qty != 0)\n', '            {\n', '                Order storage matchingOrder = id_Order[orderId];\n', '                if (matchingOrder.qty >= order.qty)\n', '                {\n', '                    tradeAmount = order.qty;\n', '                    matchingOrder.qty -= order.qty; //matchingOrder.qty cannot be negative by (matchingOrder.qty >= order.qty\n', '                    order.qty = 0;\n', '                }\n', '                else\n', '                {\n', '                    tradeAmount = matchingOrder.qty;\n', '                    order.qty -= matchingOrder.qty;\n', '                    matchingOrder.qty = 0;\n', '                }\n', '\n', '                qtyBase += BalanceUpdateByTradeCp(order, matchingOrder, tradeAmount);\n', '                //return value of BalanceUpdateByTradeCp < maxqty < 2^100 so qtyBase < 2 * maxqty < 2 * 101 by below require(qtyBase < maxQty) -> qtyBase cannot be overflow\n', '                require(qtyBase < maxQty);\n', '\n', '                uint32 orderAccountID = order.accountId;\n', '\n', '                if (order.isSell == true)\n', '                    emit NewTrade(prTrade, prBase, orderId, id, matchingOrder.accountId, orderAccountID, true, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\n', '                else\n', '                    emit NewTrade(prTrade, prBase, id, orderId, orderAccountID, matchingOrder.accountId, false, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\n', '\n', '                if (matchingOrder.qty != 0)\n', '                {\n', '                    break;\n', '                }\n', '                else\n', '                {\n', '                    if (RemoveOrder(prTrade, prBase, matchingOrder.isSell, tradePrice, orderId) == true)\n', '                    {\n', '                        RemoveOpenOrder(matchingOrder.accountId, orderId);\n', '                    }\n', '                    orderId = orderLink.firstId;\n', '                }\n', '            }\n', '\n', '            if (orderLink.firstId == 0)\n', '            {\n', '                tradePrice = orderLink.nextPrice;\n', '                isBestPriceUpdate = true;\n', '            }\n', '        }\n', '\n', '        if (isBestPriceUpdate == true)\n', '        {\n', '            if (order.isSell)\n', '            {\n', '                ob.bestBidPrice = tradePrice;\n', '            }\n', '            else\n', '            {\n', '                ob.bestAskPrice = tradePrice;\n', '            }\n', '\n', '            emit NewBestBidAsk(prTrade, prBase, !order.isSell, tradePrice);\n', '        }\n', '\n', '        return qtyBase;\n', '    }\n', '\n', '    function BalanceUpdateByTradeCp(Order order, Order matchingOrder, uint104 tradeAmount) private returns (uint104)\n', '    {\n', '        uint32 accountId = matchingOrder.accountId;\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        require (tradeAmount < maxQty);\n', '        // qtyBase < 10 ^ 18 < 2^ 60 & tradedAmount < 2^104 & matching orderprice < 2^80 ->  prCode_productInfo[prBase].divider * tradeAmount * matchingOrder.price < 2^256\n', '        // so, below qtyBase cannot be overflow\n', '        uint256 qtyBase = prCode_productInfo[prBase].divider * tradeAmount * matchingOrder.price / basePrice / prCode_productInfo[prTrade].divider;\n', '        require (qtyBase < maxQty);\n', '\n', '        Balance storage balanceTrade = exId_prCode_AccountId_Balance[matchingOrder.exId][prTrade][accountId];\n', '        Balance storage balanceBase = exId_prCode_AccountId_Balance[matchingOrder.exId][prBase][accountId];\n', '\n', '        if (order.isSell == true)\n', '        {\n', '            balanceTrade.available = SafeMath.Add(balanceTrade.available, tradeAmount);\n', '            balanceBase.reserved = SafeMath.Sub(balanceBase.reserved, uint104(qtyBase));\n', '        }\n', '        else\n', '        {\n', '            balanceTrade.reserved = SafeMath.Sub(balanceTrade.reserved, tradeAmount);\n', '            balanceBase.available = SafeMath.Add(balanceBase.available, uint104(qtyBase));\n', '        }\n', '\n', '        return uint104(qtyBase); // return value < maxQty = 1000000000000000000000000000001 < 2^100 by require (qtyBase < maxQty);\n', '    }\n', '    // Internal functions to remove order\n', '    function RemoveOrder(uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint32 id) private returns (bool)\n', '    {\n', '        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\n', '\n', '        if (isSell == false)\n', '        {\n', '            OrderLink storage orderLink = ob.bidPrice_Order[price];\n', '        }\n', '        else\n', '        {\n', '            orderLink = ob.askPrice_Order[price];\n', '        }\n', '\n', '        if (id != 0)\n', '        {\n', '            ListItem memory removeItem = orderLink.id_orderList[id];\n', '            if (removeItem.next != 0)\n', '            {\n', '                orderLink.id_orderList[removeItem.next].prev = removeItem.prev;\n', '            }\n', '\n', '            if (removeItem.prev != 0)\n', '            {\n', '                orderLink.id_orderList[removeItem.prev].next = removeItem.next;\n', '            }\n', '\n', '            if (id == orderLink.lastId)\n', '            {\n', '                orderLink.lastId = removeItem.prev;\n', '            }\n', '\n', '            if (id == orderLink.firstId)\n', '            {\n', '                orderLink.firstId = removeItem.next;\n', '            }\n', '\n', '            delete orderLink.id_orderList[id];\n', '\n', '            if (orderLink.firstId == 0)\n', '            {\n', '                if (orderLink.nextPrice != 0)\n', '                {\n', '                    if (isSell == true)\n', '                        OrderLink storage replaceLink = ob.askPrice_Order[orderLink.nextPrice];\n', '                    else\n', '                        replaceLink = ob.bidPrice_Order[orderLink.nextPrice];\n', '\n', '                    replaceLink.prevPrice = orderLink.prevPrice;\n', '                }\n', '                if (orderLink.prevPrice != 0)\n', '                {\n', '                    if (isSell == true)\n', '                        replaceLink = ob.askPrice_Order[orderLink.prevPrice];\n', '                    else\n', '                        replaceLink = ob.bidPrice_Order[orderLink.prevPrice];\n', '\n', '                    replaceLink.nextPrice = orderLink.nextPrice;\n', '                }\n', '\n', '                if (price == ob.bestAskPrice)\n', '                {\n', '                    ob.bestAskPrice = orderLink.nextPrice;\n', '                }\n', '                if (price == ob.bestBidPrice)\n', '                {\n', '                    ob.bestBidPrice = orderLink.nextPrice;\n', '                }\n', '            }\n', '            return true;\n', '        }\n', '        else\n', '        {\n', '            return false;\n', '        }\n', '    }\n', '    // Cancel orders, keep eye on max block gas Fee\n', '    function cancelOrders(uint32 exId, uint32[] id) public\n', '    {\n', '        for (uint32 i = 0; i < id.length; i++)\n', '        {\n', '            cancelOrder(exId, id[i]);\n', '        }\n', '    }\n', '    //  Cancel order\n', '    function cancelOrder(uint32 exId, uint32 id) public returns (bool)\n', '    {\n', '        Order memory order = id_Order[id];\n', '        uint32 accountId = account_id[msg.sender];\n', '        require(order.accountId == accountId);\n', '\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        bool isSell = order.isSell;\n', '        uint80 price = order.price;\n', '        uint104 qty = order.qty;\n', '\n', '        if (RemoveOrder(prTrade, prBase, isSell, price, id) == false)\n', '            return false;\n', '        else\n', '        {\n', '            RemoveOpenOrder(accountId, id);\n', '        }\n', '\n', '        if (isSell)\n', '        {\n', '            Balance storage balance = exId_prCode_AccountId_Balance[exId][prTrade][accountId];\n', '            balance.available = SafeMath.Add(balance.available, qty);\n', '            balance.reserved = SafeMath.Sub(balance.reserved, qty);\n', '        }\n', '        else\n', '        {\n', '            balance = exId_prCode_AccountId_Balance[exId][prBase][accountId];\n', '            // prCode_productInfo[prBase].divider * qty * price < 2^60 * 2^80 * 2^104 < 2^256\n', '            uint256 temp = prCode_productInfo[prBase].divider * qty * price / basePrice / prCode_productInfo[prTrade].divider;\n', '            require (temp < maxQty); // temp < maxQty < 2^104 -> temp cannot be overflow\n', '            balance.available = SafeMath.Add(balance.available, uint104(temp));\n', '            balance.reserved = SafeMath.Sub(balance.reserved, uint104(temp));\n', '        }\n', '\n', '        emit NewCancel(prTrade, prBase, accountId, id, isSell, price, qty, lastNewOrderId++);\n', '        return true;\n', '    }\n', '    function checkAnnounceLV(uint32 accountId, uint8 LV) private view returns (bool)\n', '    {\n', '        require(accountId == account_id[msg.sender] || id_announceLV[accountId] >= LV || msg.sender == operator || owner_id[msg.sender] != 0);\n', '    }\n', '    // Get balance by acount id\n', '    function getBalance(uint32 exId, uint32[] prCode, uint32 accountId) view public returns (uint128[] available, uint128[] reserved)\n', '    {\n', '        if (accountId == 0)\n', '            accountId = account_id[msg.sender];\n', '        checkAnnounceLV(accountId, 2);\n', '\n', '        uint256 n = prCode.length;\n', '        available = new uint128[](n);\n', '        reserved = new uint128[](n);\n', '\n', '        for (uint32 i = 0; i < n; i++)\n', '        {\n', '            available[i] = exId_prCode_AccountId_Balance[exId][prCode[i]][accountId].available;\n', '            reserved[i] = exId_prCode_AccountId_Balance[exId][prCode[i]][accountId].reserved;\n', '        }\n', '    }\n', '    // Get balance by product\n', '    function getBalanceByProduct(uint32 exId, uint32 prCode, uint128 minQty) view public returns (uint32[] accountId, uint128[] balanceSum)\n', '    {\n', '        require (owner_id[msg.sender] != 0 || msg.sender == operator);\n', '        uint32 n = 0;\n', '        for (uint32 i = 1; i <= lastAcccountId; i++)\n', '        {\n', '            if (exId_prCode_AccountId_Balance[exId][prCode][i].available + exId_prCode_AccountId_Balance[exId][prCode][i].reserved > minQty)\n', '                n++;\n', '        }\n', '        accountId = new uint32[](n);\n', '        balanceSum = new uint128[](n);\n', '\n', '        n = 0;\n', '        uint128 temp;\n', '        for (i = 1; i <= lastAcccountId; i++)\n', '        {\n', '            temp = exId_prCode_AccountId_Balance[exId][prCode][i].available + exId_prCode_AccountId_Balance[exId][prCode][i].reserved;\n', '            if (temp >= minQty)\n', '            {\n', '                accountId[n] = i;\n', '                balanceSum[n++] = temp;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Get bestBidPrice and bestAskPrice of each orderbook\n', '    function getOrderBookInfo(uint32[] prTrade, uint32 prBase) view public returns (uint80[] bestBidPrice, uint80[] bestAskPrice)\n', '    {\n', '        uint256 n = prTrade.length;\n', '        bestBidPrice = new uint80[](n);\n', '        bestAskPrice = new uint80[](n);\n', '\n', '        for (uint256 i = 0; i < n; i++)\n', '        {\n', '            OrderBook memory orderBook = basePID_tradePID_orderBook[prBase][prTrade[i]];\n', '            bestBidPrice[i] = orderBook.bestBidPrice;\n', '            bestAskPrice[i] = orderBook.bestAskPrice;\n', '        }\n', '    }\n', '\n', '    // Get order information by order id\n', '    function getOrder(uint32 id) view public returns (uint32 prTrade, uint32 prBase, bool sell, uint80 price, uint104 qty, uint32 accountId)\n', '    {\n', '        Order memory order = id_Order[id];\n', '\n', '        accountId = order.accountId;\n', '        checkAnnounceLV(accountId, 4);\n', '\n', '        prTrade = order.prTrade;\n', '        prBase = order.prBase;\n', '        price = order.price;\n', '        sell = order.isSell;\n', '        qty = order.qty;\n', '    }\n', '\n', "    // Get message sender's open orders\n", '    function GetMyOrders(uint32 exId, uint32 accountId, uint16 orderN) view public returns (uint32[] orderId, uint32[] prTrade, uint32[] prBase, bool[] sells, uint80[] prices, uint104[] qtys)\n', '    {\n', '        if (accountId == 0)\n', '            accountId = account_id[msg.sender];\n', '\n', '        checkAnnounceLV(accountId, 4);\n', '\n', '        OpenOrder storage openOrder = accountId_OpenOrder[accountId];\n', '\n', '        orderId = new uint32[](orderN);\n', '        prTrade = new uint32[](orderN);\n', '        prBase = new uint32[](orderN);\n', '        qtys = new uint104[](orderN);\n', '        prices = new uint80[](orderN);\n', '        sells = new bool[](orderN);\n', '\n', '        uint32 id = openOrder.startId;\n', '        if (id != 0)\n', '        {\n', '            Order memory order;\n', '            uint32 i = 0;\n', '            while (id != 0 && i < orderN)\n', '            {\n', '                order = id_Order[id];\n', '\n', '                if (exId == order.exId)\n', '                {\n', '                    orderId[i] = id;\n', '                    prTrade[i] = order.prTrade;\n', '                    prBase[i] = order.prBase;\n', '                    qtys[i] = order.qty;\n', '                    prices[i] = order.price;\n', '                    sells[i++] = order.isSell;\n', '                }\n', '\n', '                id = openOrder.id_orderList[id].next;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Get all order id in each price\n', '    function GetHogaDetail(uint32 prTrade, uint32 prBase, uint80 price, bool isSell, uint16 orderN) view public returns (uint32[] orderIds)\n', '    {\n', '        if (isSell == false)\n', '        {\n', '            OrderLink storage orderLink = basePID_tradePID_orderBook[prBase][prTrade].bidPrice_Order[price];\n', '        }\n', '        else if (isSell == true)\n', '        {\n', '            orderLink = basePID_tradePID_orderBook[prBase][prTrade].askPrice_Order[price];\n', '        }\n', '        else\n', '        {\n', '            return;\n', '        }\n', '\n', '        orderIds = new uint32[](orderN);\n', '        uint16 n = 0;\n', '        uint32 id0 = orderLink.firstId;\n', '        while (id0 != 0 && orderN > n)\n', '        {\n', '            orderIds[n++] = id0;\n', '            id0 = orderLink.id_orderList[id0].next;\n', '        }\n', '    }\n', '\n', '    // Get orderbook screen\n', '    function GetHoga(uint32 prTrade, uint32 prBase, uint32 hogaN) public view returns (uint80[] priceB, uint104[] volumeB, uint80[] priceA, uint104[] volumeA)\n', '    {\n', '        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\n', '\n', '        (priceB, volumeB) = GetHoga(ob, hogaN, false);\n', '        (priceA, volumeA) = GetHoga(ob, hogaN, true);\n', '    }\n', '\n', '    // Get orderbook screen\n', '    function GetHoga(OrderBook storage ob, uint32 hogaN, bool isSell) private view returns (uint80[] prices, uint104[] volumes)\n', '    {\n', '        prices = new uint80[](hogaN);\n', '        volumes = new uint104[](hogaN);\n', '\n', '        uint32 n;\n', '        uint32 id0;\n', '        uint80 price;\n', '        uint104 sum;\n', '\n', '        if (isSell == false)\n', '            price = ob.bestBidPrice;\n', '        else\n', '            price = ob.bestAskPrice;\n', '\n', '        if (price != 0)\n', '        {\n', '            n = 0;\n', '            while (price != 0 && n < hogaN)\n', '            {\n', '                if (isSell == false)\n', '                    OrderLink storage orderLink = ob.bidPrice_Order[price];\n', '                else\n', '                    orderLink = ob.askPrice_Order[price];\n', '\n', '                id0 = orderLink.firstId;\n', '                sum = 0;\n', '                while (id0 != 0)\n', '                {\n', '                    sum += id_Order[id0].qty;\n', '                    id0 = orderLink.id_orderList[id0].next;\n', '                }\n', '                prices[n] = price;\n', '                volumes[n] = sum;\n', '                price = orderLink.nextPrice;\n', '                n++;\n', '            }\n', '\n', '            if (n > 0)\n', '            {\n', '                while (n < hogaN)\n', '                {\n', '                    if (isSell == true)\n', '                        prices[n] = GetNextTick(true, prices[n - 1] + 1, ob.tickSize);\n', '                    else\n', '                        prices[n] = GetNextTick(false, prices[n - 1] - 1, ob.tickSize);\n', '                    n++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']