['pragma solidity ^0.5.1;\n', '\n', '// This token latch uses buy and sell orders to operate\n', '\n', '// Follows the Tr100c protocol\n', '\n', 'contract ERC20 {\n', '\tfunction totalSupply() public view returns (uint);\n', '\tfunction balanceOf(address tokenOwner) public view returns (uint balance);\n', '\tfunction allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '\tfunction transfer(address to, uint tokens) public returns (bool success);\n', '\tfunction approve(address spender, uint tokens) public returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '\tevent Transfer(address indexed from, address indexed to, uint tokens);\n', '\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ERC20TokenLatch {\n', '    \n', '    uint64 trade_increment = 1;\n', '\t\n', '\tuint public fee;\t    \t\t// fee for trades\n', '\t\n', '\taddress payable public owner;\n', '    \n', '    address payable public latched_contract;\n', '    \n', '    mapping(uint32 => address payable) public buy_order_owners;\n', '    mapping(uint32 => uint256)   public  buy_order_qty;\n', '    mapping(uint32 => uint64)   public  buy_order_price;\n', '    uint32 public num_buy_orders = 0;\n', '    uint32 public max_buy_price_idx;\n', '    \n', '    mapping(uint32 => address payable) public sell_order_owners;\n', '    mapping(uint32 => uint256)   public  sell_order_qty;\n', '    mapping(uint32 => uint64)   public  sell_order_price;\n', '    uint32 public num_sell_orders = 0;\n', '    uint32 public min_sell_price_idx;\n', '    \n', '    function rmBuyOrder(uint32 idx) private {\n', '        buy_order_owners[idx]=buy_order_owners[num_buy_orders];\n', '        buy_order_qty[idx]=buy_order_qty[num_buy_orders];\n', '        buy_order_price[idx]=buy_order_price[num_buy_orders];\n', '        num_buy_orders--;\n', '        if(max_buy_price_idx==idx){\n', '            max_buy_price_idx=0;\n', '            for(uint32 i=1;i<num_buy_orders;i++){\n', '                if(buy_order_price[max_buy_price_idx]<buy_order_price[i])max_buy_price_idx=i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function rmSellOrder(uint32 idx) private {\n', '        sell_order_owners[idx]=sell_order_owners[num_sell_orders];\n', '        sell_order_qty[idx]=sell_order_qty[num_sell_orders];\n', '        sell_order_price[idx]=sell_order_price[num_sell_orders];\n', '        num_sell_orders--;\n', '        if(min_sell_price_idx==idx){\n', '            min_sell_price_idx=0;\n', '            for(uint32 i=1;i<num_sell_orders;i++){\n', '                if(sell_order_price[min_sell_price_idx]>sell_order_price[i])min_sell_price_idx=i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function addBuyOrder(address payable adr, uint256 qty, uint64 price) private {\n', '        buy_order_owners[num_buy_orders] = adr;\n', '        buy_order_qty[num_buy_orders] = qty;\n', '        buy_order_price[num_buy_orders] = price;\n', '        if(price>buy_order_price[max_buy_price_idx])max_buy_price_idx = num_buy_orders;\n', '        if(num_buy_orders==0)max_buy_price_idx = 0;\n', '        num_buy_orders++;\n', '    }\n', '    \n', '    function addSellOrder(address payable adr, uint256 qty, uint64 price) private {\n', '        sell_order_owners[num_sell_orders] = adr;\n', '        sell_order_qty[num_sell_orders] = qty;\n', '        sell_order_price[num_sell_orders] = price;\n', '        if(price<sell_order_price[min_sell_price_idx])min_sell_price_idx = num_sell_orders;\n', '        if(num_sell_orders==0)min_sell_price_idx = 0;\n', '        num_sell_orders++;\n', '    }\n', '    \n', '    function maxBuyPrice() public view returns (uint64 price){\n', '        return buy_order_price[max_buy_price_idx];\n', '    }\n', '    \n', '    function minSellPrice() public view returns (uint64 price){\n', '        return sell_order_price[min_sell_price_idx];\n', '    }\n', '    \n', '    function getPrice() public view returns (uint64){\n', '        if(num_sell_orders==0){\n', '            if(num_buy_orders==0)return 1000;\n', '            else return maxBuyPrice();\n', '        }else if(num_buy_orders==0) return minSellPrice();\n', '        return (minSellPrice()+maxBuyPrice())/2;\n', '    }\n', '    \n', '    constructor(address payable latch) public {\n', '        latched_contract=latch;\n', '        owner = msg.sender;\n', '\t\tfee = .0001 ether;\n', '    }\n', '    \n', '    function balanceOf(address tokenOwner) public view returns (uint balance){\n', '        return ERC20(latched_contract).balanceOf(tokenOwner);\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint){\n', '        return ERC20(latched_contract).totalSupply();\n', '    }\n', '    \n', '    function transfer(address target, uint qty) private{\n', '        ERC20(latched_contract).transfer(target, qty);\n', '    }\n', '    \n', '\tfunction getFee() public view returns (uint){\n', '\t\treturn fee;\n', '\t}\n', '\t\n', '\tfunction getBuyPrice() public view returns (uint64){\n', '\t    if(num_buy_orders>0)return maxBuyPrice()+trade_increment;\n', '\t    else return getPrice();\n', '\t}\n', '\t\n', '\tfunction getSellPrice() public view returns (uint64){\n', '\t    if(num_sell_orders>0)return minSellPrice()-trade_increment;\n', '\t    else return getPrice();\n', '\t}\n', '\t\n', '\tfunction getSellReturn(uint amount) public view returns (uint){\t// ether for selling amount tokens\n', "\t    // computing fees for selling is difficult and expensive, so I'm not doing it.  Not worth it.\n", '\t\treturn (getSellPrice()*amount)/10000;\n', '\t}\n', '\t\n', '\tfunction getBuyCost(uint amount) public view returns (uint){\t\t// ether cost for buying amount tokens\n', '\t    return ((amount*getBuyPrice())/10000) + fee;\n', '\t}\n', '\t\n', '\tfunction buy(uint tokens)public payable{\n', '\t\tplaceBuyOrder(tokens, getBuyPrice());\n', '\t}\n', '\t\n', '\tfunction placeBuyOrder(uint tokens, uint64 price10000) public payable{\n', '\t    uint cost = fee + ((tokens*price10000)/10000);\n', '\t    require(msg.value>=cost);\n', '\t\t\n', '\t\t// handle fee and any extra funds\n', '\t\tmsg.sender.transfer(msg.value-cost);\n', '\t\towner.transfer(fee);\n', '\t\t\n', '\t    uint left = tokens;\n', '\t    \n', '\t\t// now try to fulfill the order\n', '\t\tfor(uint32 i=0;i<num_sell_orders;i++){\n', '\t\t    if(price10000<minSellPrice())\n', '\t\t        break; // cannot fulfill order because there is not a sell order that would satisfy\n', '\t\t    \n', '\t\t    if(sell_order_price[i]<=price10000){\n', '\t\t        // we can trade some!\n', '\t\t        if(sell_order_qty[i]>left){\n', '\t\t            // we can trade all!\n', '\t\t            sell_order_qty[i]-=left;\n', '\t\t            sell_order_owners[i].transfer((sell_order_price[i]*left)/10000);\n', '\t\t            transfer(msg.sender, left);\n', '\t\t            \n', '\t\t            // send the owner any extra funds\n', '\t\t            owner.transfer(((price10000-sell_order_price[i])*left)/10000);\n', '\t\t            \n', '\t\t            // order fully fulfilled\n', '\t\t            return;\n', '\t\t        }else{\n', '    \t\t        // will complete a single sell order, but buy order will have some left over\n', '    \t\t        uint qty = sell_order_qty[i];\n', '    \t\t        left-=qty;\n', '    \t            sell_order_owners[i].transfer((sell_order_price[i]*qty)/10000);\n', '    \t            transfer(msg.sender, qty);\n', '    \t            \n', '    \t            // send the owner any extra funds\n', '    \t            owner.transfer(((price10000-sell_order_price[i])*qty)/10000);\n', '    \t            \n', '    \t            // delete the order that was completed\n', '    \t            rmSellOrder(i);\n', '    \t\t    }\n', '\t\t    }\n', '\t\t}\n', '\t\t\n', '\t\t// if we are here then some of the order is left.  Place the order in the queue.\n', '\t\taddBuyOrder(msg.sender, left, price10000);\n', '\t\t\n', '\t}\n', '\t\n', '\tfunction sell(uint tokens)public{\n', '\t    placeSellOrder(tokens, getSellPrice());\n', '\t}\n', '\t    \n', '\tfunction placeSellOrder(uint tokens, uint64 price10000) public payable{\n', '\t    require(ERC20(latched_contract).allowance(msg.sender, address(this))>=tokens);\n', '\t\t\n', '\t\t// handle fee and any extra funds\n', '\t\tERC20(latched_contract).transferFrom(msg.sender,address(this),tokens);\n', '\t\t\n', '\t\t// get info needed for trading\n', '\t    uint64 sell_price = price10000;\n', '\t    uint left = tokens;\n', '\t    \n', '\t\t// now try to fulfill the order\n', '\t\tfor(uint32 i=0;i<num_buy_orders;i++){\n', '\t\t    if(sell_price>maxBuyPrice())\n', '\t\t        break; // cannot fulfill order because there is not a buy order that would satisfy\n', '\t\t    \n', '\t\t    if(buy_order_price[i]>=sell_price){\n', '\t\t        // we can trade some!\n', '\t\t        if(buy_order_qty[i]>left){\n', '\t\t            // we can trade all!\n', '\t\t            buy_order_qty[i]-=left;\n', '\t\t            transfer(buy_order_owners[i],left);\n', '\t\t            msg.sender.transfer((sell_price*left)/10000);\n', '\t\t            \n', '\t\t            // send the owner any extra funds\n', '\t\t            owner.transfer(((buy_order_price[i]-sell_price)*left)/10000);\n', '\t\t            \n', '\t\t            // order fully fulfilled\n', '\t\t            return;\n', '\t\t        }else{\n', '    \t\t        // will complete a single sell order, but buy order will have some left over\n', '    \t\t        uint qty = buy_order_qty[i];\n', '    \t\t        left-=qty;\n', '    \t            \n', '\t\t            transfer(buy_order_owners[i],qty);\n', '    \t            msg.sender.transfer((sell_price*qty)/10000);\n', '    \t            \n', '    \t            // send the owner any extra funds\n', '    \t            owner.transfer(((buy_order_price[i]-sell_price)*qty)/10000);\n', '    \t            \n', '    \t            // delete the order that was completed\n', '    \t            rmBuyOrder(i);\n', '    \t\t    }\n', '\t\t    }\n', '\t\t}\n', '\t\t\n', '\t\t// if we are here then some of the order is left.  Place the order in the queue.\n', '\t\taddSellOrder(msg.sender, left, sell_price);\n', '\t}\n', '    \n', '    function canBuy(uint amount) public pure returns (bool possible){\t\t\t// returns true if this amount of token can be bought - does not account for Ethereum account balance\n', '        return true;\n', '    }\n', '    \n', '    function canSell(uint amount) public pure returns (bool possible){\t\t\t// returns true if this amount of token can be sold - does not account for token account balance\n', '\t    return true;\n', '    }\n', '\t\n', '\tfunction get_tradable() public view returns (uint){\n', '        return ERC20(latched_contract).totalSupply();\n', '    }\n', '\t\n', '\tfunction setFee(uint new_fee) public{\n', '\t    require(msg.sender==owner);\n', '\t    fee=new_fee;\n', '\t}\n', '\t\n', '\tfunction destroy() public {\n', '\t    require(msg.sender==owner);\n', '\t    require(address(this).balance<0.1 ether);\n', '\t    require(ERC20(latched_contract).balanceOf(address(this))==0);\n', '\t    selfdestruct(msg.sender);\n', '\t}\n', '}']