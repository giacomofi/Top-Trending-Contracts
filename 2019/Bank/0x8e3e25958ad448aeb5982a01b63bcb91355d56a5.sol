['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', 'pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'interface collectible {\n', '    function transfer(address receiver, uint amount) external;\n', '}\n', '\n', 'contract Swap {\n', '    address public beneficiary;\n', '    uint public amountRaised;\n', '    uint public price;\n', '    bool contractover = false;\n', '    collectible public swapaddress;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => bool) public check;\n', '\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constructor\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor(\n', '        address SendTo,\n', '        uint etherCostOfEachCollectible,\n', '        address addressOfCollectibleUsedAsReward\n', '    ) public {\n', '        beneficiary = SendTo;\n', '        price = etherCostOfEachCollectible * 1 szabo;\n', '        swapaddress = collectible(addressOfCollectibleUsedAsReward);\n', '    }\n', '\n', '    \n', '    function () payable external {\n', '        require(check[msg.sender] == false);\n', '        require(msg.value < 1000000000000000001 wei);\n', '        \n', '        uint amount = msg.value;\n', '        balanceOf[msg.sender] += amount;\n', '        amountRaised += amount;\n', '        uint copy = price;\n', '        uint second = price;\n', '        uint third = price;\n', '        \n', '        if (amountRaised <= 100 ether) {\n', '        uint newvalue = copy / 10;\n', '        swapaddress.transfer(msg.sender, amount / newvalue);\n', '        } else if (amountRaised <= 2100 ether) {\n', '        uint secondvalue = second / 2;\n', '        swapaddress.transfer(msg.sender, amount / secondvalue);\n', '        } else {\n', '        swapaddress.transfer(msg.sender, amount / third);\n', '        }\n', '        \n', '        beneficiary.send(msg.value);\n', '        emit FundTransfer(msg.sender, amount, true);\n', '        check[msg.sender] = true;\n', '    }\n', '\n', '}']
['pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'interface collectible {\n', '    function transfer(address receiver, uint amount) external;\n', '}\n', '\n', 'contract Swap {\n', '    address public beneficiary;\n', '    uint public amountRaised;\n', '    uint public price;\n', '    bool contractover = false;\n', '    collectible public swapaddress;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => bool) public check;\n', '\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constructor\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor(\n', '        address SendTo,\n', '        uint etherCostOfEachCollectible,\n', '        address addressOfCollectibleUsedAsReward\n', '    ) public {\n', '        beneficiary = SendTo;\n', '        price = etherCostOfEachCollectible * 1 szabo;\n', '        swapaddress = collectible(addressOfCollectibleUsedAsReward);\n', '    }\n', '\n', '    \n', '    function () payable external {\n', '        require(check[msg.sender] == false);\n', '        require(msg.value < 1000000000000000001 wei);\n', '        \n', '        uint amount = msg.value;\n', '        balanceOf[msg.sender] += amount;\n', '        amountRaised += amount;\n', '        uint copy = price;\n', '        uint second = price;\n', '        uint third = price;\n', '        \n', '        if (amountRaised <= 100 ether) {\n', '        uint newvalue = copy / 10;\n', '        swapaddress.transfer(msg.sender, amount / newvalue);\n', '        } else if (amountRaised <= 2100 ether) {\n', '        uint secondvalue = second / 2;\n', '        swapaddress.transfer(msg.sender, amount / secondvalue);\n', '        } else {\n', '        swapaddress.transfer(msg.sender, amount / third);\n', '        }\n', '        \n', '        beneficiary.send(msg.value);\n', '        emit FundTransfer(msg.sender, amount, true);\n', '        check[msg.sender] = true;\n', '    }\n', '\n', '}']
