['pragma solidity ^0.4.18;\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract usingEthereumV2Erc20Consts {\n', '    uint constant TOKEN_DECIMALS = 18;\n', '    uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n', '    uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n', '\n', '    uint constant TEAM_TOKENS =   0 * TOKEN_DECIMAL_MULTIPLIER;\n', '    uint constant BOUNTY_TOKENS = 0 * TOKEN_DECIMAL_MULTIPLIER;\n', '    uint constant PREICO_TOKENS = 0 * TOKEN_DECIMAL_MULTIPLIER;\n', '    uint constant MINIMAL_PURCHASE = 0.00001 ether;\n', '\n', '    address constant TEAM_ADDRESS = 0x78cd8f794686ee8f6644447e961ef52776edf0cb;\n', '    address constant BOUNTY_ADDRESS = 0xff823588500d3ecd7777a1cfa198958df4deea11;\n', '    address constant PREICO_ADDRESS = 0xff823588500d3ecd7777a1cfa198958df4deea11;\n', '    address constant COLD_WALLET = 0x439415b03708bde585856b46666f34b65af6a5c3;\n', '\n', '    string constant TOKEN_NAME = "Ethereum V2 Erc20";\n', '    bytes32 constant TOKEN_SYMBOL = "ETH20";\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) balances;\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // require (_value <= _allowance);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        }\n', '        else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '\n', '    event MintFinished();\n', '\n', '    bool public mintingFinished = false;\n', '\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() onlyOwner returns (bool) {\n', '        mintingFinished = true;\n', '        MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is StandardToken {\n', '\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', 'contract EthereumV2Erc20 is usingEthereumV2Erc20Consts, MintableToken, BurnableToken {\n', '    /**\n', '     * @dev Pause token transfer. After successfully finished crowdsale it becomes true.\n', '     */\n', '    bool public paused = false;\n', '    /**\n', '     * @dev Accounts who can transfer token even if paused. Works only during crowdsale.\n', '     */\n', '    mapping(address => bool) excluded;\n', '\n', '    function name() constant public returns (string _name) {\n', '        return TOKEN_NAME;\n', '    }\n', '\n', '    function symbol() constant public returns (bytes32 _symbol) {\n', '        return TOKEN_SYMBOL;\n', '    }\n', '\n', '    function decimals() constant public returns (uint8 _decimals) {\n', '        return TOKEN_DECIMALS_UINT8;\n', '    }\n', '\n', '    function crowdsaleFinished() onlyOwner {\n', '        paused = false;\n', '        finishMinting();\n', '    }\n', '\n', '    function addExcluded(address _toExclude) onlyOwner {\n', '        excluded[_toExclude] = true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '        require(!paused || excluded[_from]);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        require(!paused || excluded[msg.sender]);\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Burn tokens from the specified address.\n', '     * @param _from     address The address which you want to burn tokens from.\n', '     * @param _value    uint    The amount of tokens to be burned.\n', '     */\n', '    function burnFrom(address _from, uint256 _value) returns (bool) {\n', '        require(_value > 0);\n', '        var allowance = allowed[_from][msg.sender];\n', '        balances[_from] = balances[_from].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        allowed[_from][msg.sender] = allowance.sub(_value);\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', 'contract EthereumV2Erc20RateProviderI {\n', '    /**\n', '     * @dev Calculate actual rate using the specified parameters.\n', '     * @param buyer     Investor (buyer) address.\n', '     * @param totalSold Amount of sold tokens.\n', '     * @param amountWei Amount of wei to purchase.\n', '     * @return ETH to Token rate.\n', '     */\n', '    function getRate(address buyer, uint totalSold, uint amountWei) public constant returns (uint);\n', '\n', '    /**\n', '     * @dev rate scale (or divider), to support not integer rates.\n', '     * @return Rate divider.\n', '     */\n', '    function getRateScale() public constant returns (uint);\n', '\n', '    /**\n', '     * @return Absolute base rate.\n', '     */\n', '    function getBaseRate() public constant returns (uint);\n', '}\n', '\n', 'contract EthereumV2Erc20RateProvider is usingEthereumV2Erc20Consts, EthereumV2Erc20RateProviderI, Ownable {\n', '    // rate calculate accuracy\n', '    uint constant RATE_SCALE = 1;\n', '    // Start time: Human time (GMT): Sunday, May 5, 2019 5:05:05 PM\n', '    // End time: Human time (GMT): Saturday, May 5, 2029 5:05:05 PM\n', '    \n', '    // Guaranteed by 100% ETH. \n', '    // Contract to buy 100% token to burn off. \n', '    // Service fee 2%. 98% of the funds were bought back by all contracts and then burned.\n', '    \n', '    uint constant STEP_9 =         50000 * TOKEN_DECIMAL_MULTIPLIER;           // Start from  0.00001      to  1.49 ETH         Price 100000 ETH20 = 1 ETH\n', '    uint constant STEP_8 =        150000 * TOKEN_DECIMAL_MULTIPLIER;         // Continue the next 0.5        - 2.99 ETH         Price  99000 ETH20 = 1 ETH\n', '    uint constant STEP_7 =       1150000 * TOKEN_DECIMAL_MULTIPLIER;         // Continue the next 1.5       - 19.99 ETH         Price  90000 ETH20 = 1 ETH\n', '    uint constant STEP_6 =      11150000 * TOKEN_DECIMAL_MULTIPLIER;        // Continue the next 11.5      - 199.99 ETH         Price  50000 ETH20 = 1 ETH\n', '    uint constant STEP_5 =     111150000 * TOKEN_DECIMAL_MULTIPLIER;       // Continue the next 111.5     - 1999.99 ETH         Price  10000 ETH20 = 1 ETH\n', '    uint constant STEP_4 =    1111150000 * TOKEN_DECIMAL_MULTIPLIER;      // Continue the next 1111.5    - 19999.99 ETH         Price   1000 ETH20 = 1 ETH\n', '    uint constant STEP_3 =   11111150000 * TOKEN_DECIMAL_MULTIPLIER;     // Continue the next 11111.5   - 199999.99 ETH         Price    100 ETH20 = 1 ETH\n', '    uint constant STEP_2 =  111111150000 * TOKEN_DECIMAL_MULTIPLIER;    // Continue the next 111111.5  - 1999999.99 ETH         Price     10 ETH20 = 1 ETH\n', '    uint constant STEP_1 = 2000000000000 * TOKEN_DECIMAL_MULTIPLIER;   // Continue the next 1111111.99 -19999999.99 ETH         Price      1 ETH20 = 1 ETH\n', '    \n', '    uint constant RATE_9 =   100000 * RATE_SCALE; // Price increases 0 %                       // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_8 =    99000 * RATE_SCALE; // Price increases 1 %                       // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_7 =    90000 * RATE_SCALE; // Price increases 10 %                      // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_6 =    50000 * RATE_SCALE; // Price increases 100 % Increase by 2 times // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_5 =    10000 * RATE_SCALE; // Price increases by 10 times               // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_4 =    1000 * RATE_SCALE; // Price Increase by   100 times              // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_3 =    100 * RATE_SCALE; // Price increase by    1000  times            // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_2 =    10 * RATE_SCALE; // Price increase by     10000 times            // Redemption price 98 %  Buy back burned\n', '    uint constant RATE_1 =    1 * RATE_SCALE; // Price increase by      100000 times            // Redemption price 98 %  Buy back burned\n', '    \n', '    \n', '    uint constant BASE_RATE = 0 * RATE_SCALE;                                             // 1 ETH = 1 ETH20.  Standard price 0 %\n', '\n', '    struct ExclusiveRate {\n', '        // be careful, accuracies this about 1 minutes\n', '        uint32 workUntil;\n', '        // exclusive rate or 0\n', '        uint rate;\n', '        // rate bonus percent, which will be divided by 1000 or 0\n', '        uint16 bonusPercent1000;\n', '        // flag to check, that record exists\n', '        bool exists;\n', '    }\n', '\n', '    mapping(address => ExclusiveRate) exclusiveRate;\n', '\n', '    function getRateScale() public constant returns (uint) {\n', '        return RATE_SCALE;\n', '    }\n', '\n', '    function getBaseRate() public constant returns (uint) {\n', '        return BASE_RATE;\n', '    }\n', '    \n', '\n', '    function getRate(address buyer, uint totalSold, uint amountWei) public constant returns (uint) {\n', '        uint rate;\n', '        // apply sale\n', '        if (totalSold < STEP_9) {\n', '            rate = RATE_9;\n', '        }\n', '        else if (totalSold < STEP_8) {\n', '            rate = RATE_8;\n', '        }\n', '        else if (totalSold < STEP_7) {\n', '            rate = RATE_7;\n', '        }\n', '        else if (totalSold < STEP_6) {\n', '            rate = RATE_6;\n', '        }\n', '        else if (totalSold < STEP_5) {\n', '            rate = RATE_5;\n', '        }\n', '        else if (totalSold < STEP_4) {\n', '            rate = RATE_4;\n', '        }\n', '        else if (totalSold < STEP_3) {\n', '            rate = RATE_3;\n', '        }\n', '        else if (totalSold < STEP_2) {\n', '            rate = RATE_2;\n', '        }\n', '        else if (totalSold < STEP_1) {\n', '            rate = RATE_1;\n', '        }\n', '        else {\n', '            rate = BASE_RATE;\n', '        }\n', '    // apply bonus for amount\n', '        if (amountWei >= 100000 ether) {\n', '            rate += rate * 0 / 100;\n', '        }\n', '        else if (amountWei >= 10000 ether) {\n', '            rate += rate * 0 / 100;\n', '        }\n', '        else if (amountWei >= 1000 ether) {\n', '            rate += rate * 0 / 100;\n', '        }\n', '        else if (amountWei >= 100 ether) {\n', '            rate += rate * 0 / 100;\n', '        }\n', '        else if (amountWei >= 10 ether) {\n', '            rate += rate * 0 / 100;\n', '        }\n', '        else if (amountWei >= 1 ether) {\n', '            rate += rate * 0 / 1000;\n', '        }\n', '\n', '        ExclusiveRate memory eRate = exclusiveRate[buyer];\n', '        if (eRate.exists && eRate.workUntil >= now) {\n', '            if (eRate.rate != 0) {\n', '                rate = eRate.rate;\n', '            }\n', '            rate += rate * eRate.bonusPercent1000 / 1000;\n', '        }\n', '        return rate;\n', '    }\n', '\n', '    function setExclusiveRate(address _investor, uint _rate, uint16 _bonusPercent1000, uint32 _workUntil) onlyOwner {\n', '        exclusiveRate[_investor] = ExclusiveRate(_workUntil, _rate, _bonusPercent1000, true);\n', '    }\n', '\n', '    function removeExclusiveRate(address _investor) onlyOwner {\n', '        delete exclusiveRate[_investor];\n', '    }\n', '}\n', '/**\n', ' * @title Crowdsale \n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' *\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet \n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint;\n', '\n', '    // The token being sold\n', '    MintableToken public token;\n', '\n', '    // start and end timestamps where investments are allowed (both inclusive)\n', '    uint32 internal startTime;\n', '    uint32 internal endTime;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // amount of raised money in wei\n', '    uint public weiRaised;\n', '\n', '    /**\n', '     * @dev Amount of already sold tokens.\n', '     */\n', '    uint public soldTokens;\n', '\n', '    /**\n', '     * @dev Maximum amount of tokens to mint.\n', '     */\n', '    uint internal hardCap;\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint value, uint amount);\n', '\n', '    function Crowdsale(uint _startTime, uint _endTime, uint _hardCap, address _wallet) {\n', '        require(_endTime >= _startTime);\n', '        require(_wallet != 0x0);\n', '        require(_hardCap > 0);\n', '\n', '        token = createTokenContract();\n', '        startTime = uint32(_startTime);\n', '        endTime = uint32(_endTime);\n', '        hardCap = _hardCap;\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // creates the token to be sold.\n', '    // override this method to have crowdsale of a specific mintable token.\n', '    function createTokenContract() internal returns (MintableToken) {\n', '        return new MintableToken();\n', '    }\n', '\n', '    /**\n', '     * @dev this method might be overridden for implementing any sale logic.\n', '     * @return Actual rate.\n', '     */\n', '    function getRate(uint amount) internal constant returns (uint);\n', '\n', '    function getBaseRate() internal constant returns (uint);\n', '\n', '    /**\n', '     * @dev rate scale (or divider), to support not integer rates.\n', '     * @return Rate divider.\n', '     */\n', '    function getRateScale() internal constant returns (uint) {\n', '        return 1;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function() payable {\n', '        buyTokens(msg.sender, msg.value);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary, uint amountWei) internal {\n', '        require(beneficiary != 0x0);\n', '\n', '        // total minted tokens\n', '        uint totalSupply = token.totalSupply();\n', '\n', '        // actual token minting rate (with considering bonuses and discounts)\n', '        uint actualRate = getRate(amountWei);\n', '        uint rateScale = getRateScale();\n', '\n', '        require(validPurchase(amountWei, actualRate, totalSupply));\n', '\n', '        // calculate token amount to be created\n', '        uint tokens = amountWei.mul(actualRate).div(rateScale);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(amountWei);\n', '        soldTokens = soldTokens.add(tokens);\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, amountWei, tokens);\n', '\n', '        forwardFunds(amountWei);\n', '    }\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds(uint amountWei) internal {\n', '        wallet.transfer(amountWei);\n', '    }\n', '\n', '    /**\n', '     * @dev Check if the specified purchase is valid.\n', '     * @return true if the transaction can buy tokens\n', '     */\n', '    function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool nonZeroPurchase = _amountWei != 0;\n', '        bool hardCapNotReached = _totalSupply <= hardCap;\n', '\n', '        return withinPeriod && nonZeroPurchase && hardCapNotReached;\n', '    }\n', '\n', '    /**\n', '     * @dev Because of discount hasEnded might be true, but validPurchase returns false.\n', '     * @return true if crowdsale event has ended\n', '     */\n', '    function hasEnded() public constant returns (bool) {\n', '        return now > endTime || token.totalSupply() > hardCap;\n', '    }\n', '\n', '    /**\n', '     * @return true if crowdsale event has started\n', '     */\n', '    function hasStarted() public constant returns (bool) {\n', '        return now >= startTime;\n', '    }\n', '}\n', '\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    function FinalizableCrowdsale(uint _startTime, uint _endTime, uint _hardCap, address _wallet)\n', '            Crowdsale(_startTime, _endTime, _hardCap, _wallet) {\n', '    }\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', "     * work. Calls the contract's finalization function.\n", '     */\n', '    function finalize() onlyOwner notFinalized {\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overriden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '\n', '    modifier notFinalized() {\n', '        require(!isFinalized);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract EthereumV2Erc20Crowdsale is usingEthereumV2Erc20Consts, FinalizableCrowdsale {\n', '    EthereumV2Erc20RateProviderI public rateProvider;\n', '\n', '    function EthereumV2Erc20Crowdsale(\n', '            uint _startTime,\n', '            uint _endTime,\n', '            uint _hardCapTokens\n', '    )\n', '            FinalizableCrowdsale(_startTime, _endTime, _hardCapTokens * TOKEN_DECIMAL_MULTIPLIER, COLD_WALLET) {\n', '\n', '        token.mint(TEAM_ADDRESS, TEAM_TOKENS);\n', '        token.mint(BOUNTY_ADDRESS, BOUNTY_TOKENS);\n', '        token.mint(PREICO_ADDRESS, PREICO_TOKENS);\n', '\n', '        EthereumV2Erc20(token).addExcluded(TEAM_ADDRESS);\n', '        EthereumV2Erc20(token).addExcluded(BOUNTY_ADDRESS);\n', '        EthereumV2Erc20(token).addExcluded(PREICO_ADDRESS);\n', '\n', '        EthereumV2Erc20RateProvider provider = new EthereumV2Erc20RateProvider();\n', '        provider.transferOwnership(owner);\n', '        rateProvider = provider;\n', '    }\n', '\n', '    /**\n', '     * @dev override token creation to integrate with MyWill token.\n', '     */\n', '    function createTokenContract() internal returns (MintableToken) {\n', '        return new EthereumV2Erc20();\n', '    }\n', '\n', '    /**\n', '     * @dev override getRate to integrate with rate provider.\n', '     */\n', '    function getRate(uint _value) internal constant returns (uint) {\n', '        return rateProvider.getRate(msg.sender, soldTokens, _value);\n', '    }\n', '\n', '    function getBaseRate() internal constant returns (uint) {\n', '        return rateProvider.getRate(msg.sender, soldTokens, MINIMAL_PURCHASE);\n', '    }\n', '\n', '    /**\n', '     * @dev override getRateScale to integrate with rate provider.\n', '     */\n', '    function getRateScale() internal constant returns (uint) {\n', '        return rateProvider.getRateScale();\n', '    }\n', '\n', '    /**\n', '     * @dev Admin can set new rate provider.\n', '     * @param _rateProviderAddress New rate provider.\n', '     */\n', '    function setRateProvider(address _rateProviderAddress) onlyOwner {\n', '        require(_rateProviderAddress != 0);\n', '        rateProvider = EthereumV2Erc20RateProviderI(_rateProviderAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Admin can move end time.\n', '     * @param _endTime New end time.\n', '     */\n', '    function setEndTime(uint _endTime) onlyOwner notFinalized {\n', '        require(_endTime > startTime);\n', '        endTime = uint32(_endTime);\n', '    }\n', '\n', '    function setHardCap(uint _hardCapTokens) onlyOwner notFinalized {\n', '        require(_hardCapTokens * TOKEN_DECIMAL_MULTIPLIER > hardCap);\n', '        hardCap = _hardCapTokens * TOKEN_DECIMAL_MULTIPLIER;\n', '    }\n', '\n', '    function setStartTime(uint _startTime) onlyOwner notFinalized {\n', '        require(_startTime < endTime);\n', '        startTime = uint32(_startTime);\n', '    }\n', '\n', '    function addExcluded(address _address) onlyOwner notFinalized {\n', '        EthereumV2Erc20(token).addExcluded(_address);\n', '    }\n', '\n', '    function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) {\n', '        if (_amountWei < MINIMAL_PURCHASE) {\n', '            return false;\n', '        }\n', '        return super.validPurchase(_amountWei, _actualRate, _totalSupply);\n', '    }\n', '\n', '    function finalization() internal {\n', '        super.finalization();\n', '        token.finishMinting();\n', '        EthereumV2Erc20(token).crowdsaleFinished();\n', '        token.transferOwnership(owner);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '     * @dev Fallback function.\n', '     * Implemented entirely in `_fallback`.\n', '     */\n', '    function () payable external {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @return The Address of the implementation.\n', '     */\n', '    function _implementation() internal view returns (address);\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', "     * This is a low level function that doesn't return to its internal call site.\n", '     * It will return to the external caller whatever the implementation returns.\n', '     * @param implementation Address to delegate.\n', '     */\n', '    function _delegate(address implementation) internal {\n', '        assembly {\n', '        // Copy msg.data. We take full control of memory in this inline assembly\n', '        // block because it will not return to Solidity code. We overwrite the\n', '        // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '        // Call the implementation.\n', "        // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '        // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 { revert(0, returndatasize) }\n', '            default { return(0, returndatasize) }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function that is run as the first thing in the fallback function.\n', '     * Can be redefined in derived contracts to add functionality.\n', '     * Redefinitions must call super._willFallback().\n', '     */\n', '    function _willFallback() internal {\n', '    }\n', '\n', '    /**\n', '     * @dev fallback implementation.\n', '     * Extracted to enable manual triggering.\n', '     */\n', '    function _fallback() internal {\n', '        _willFallback();\n', '        _delegate(_implementation());\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param addr address to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', 'contract Promotion {\n', '    mapping(address => address[]) public referrals; // mapping of affiliate address to referral addresses\n', '    mapping(address => address) public affiliates; // mapping of referrals addresses to affiliate addresses\n', '    mapping(address => bool) public admins; // mapping of admin accounts\n', '    string[] public affiliateList;\n', '    address public owner;\n', '\n', '    function setOwner(address newOwner);\n', '    function setAdmin(address admin, bool isAdmin) public;\n', '    function assignReferral (address affiliate, address referral) public;\n', '\n', '    function getAffiliateCount() returns (uint);\n', '    function getAffiliate(address refferal) public returns (address);\n', '    function getReferrals(address affiliate) public returns (address[]);\n', '}\n', '\n', 'contract TokenList {\n', '    function isTokenInList(address tokenAddress) public constant returns (bool);\n', '}\n', '\n', '\n', 'contract BTC20Exchange {\n', '    function assert(bool assertion) {\n', '        if (!assertion) throw;\n', '    }\n', '    function safeMul(uint a, uint b) returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '    address public owner;\n', '    mapping (address => uint256) public invalidOrder;\n', '\n', '    event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    function setOwner(address newOwner) onlyOwner {\n', '        SetOwner(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    function getOwner() returns (address out) {\n', '        return owner;\n', '    }\n', '    function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin {\n', '        if (nonce < invalidOrder[user]) throw;\n', '        invalidOrder[user] = nonce;\n', '    }\n', '\n', '    mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\n', '\n', '    mapping (address => bool) public admins;\n', '    mapping (address => uint256) public lastActiveTransaction;\n', '    mapping (bytes32 => uint256) public orderFills;\n', '    address public feeAccount;\n', '    uint256 public feeAffiliate; // percentage times (1 ether)\n', '    uint256 public inactivityReleasePeriod;\n', '    mapping (bytes32 => bool) public traded;\n', '    mapping (bytes32 => bool) public withdrawn;\n', '    uint256 public makerFee; // fraction * 1 ether\n', '    uint256 public takerFee; // fraction * 1 ether\n', '    uint256 public affiliateFee; // fraction as proportion of 1 ether\n', '    uint256 public makerAffiliateFee; // wei deductible from makerFee\n', '    uint256 public takerAffiliateFee; // wei deductible form takerFee\n', '\n', '    mapping (address => address) public referrer;  // mapping of user addresses to their referrer addresses\n', '\n', '    address public affiliateContract;\n', '    address public tokenListContract;\n', '\n', '\n', '    enum Errors {\n', "        INVLID_PRICE,           // Order prices don't match\n", '        INVLID_SIGNATURE,       // Signature is invalid\n', "        TOKENS_DONT_MATCH,      // Maker/taker tokens don't match\n", '        ORDER_ALREADY_FILLED,   // Order was already filled\n', '        GAS_TOO_HIGH            // Too high gas fee\n', '    }\n', '\n', '    //event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    //event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(\n', '        address takerTokenBuy, uint256 takerAmountBuy,\n', '        address takerTokenSell, uint256 takerAmountSell,\n', '        address maker, address indexed taker,\n', '        uint256 makerFee, uint256 takerFee,\n', '        uint256 makerAmountTaken, uint256 takerAmountTaken,\n', '        bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash\n', '    );\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance, address indexed referrerAddress);\n', '    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 withdrawFee);\n', '    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee, uint256 indexed affiliateFee);\n', '    //event AffiliateFeeChange(uint256 newAffiliateFee);\n', '    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event CancelOrder(\n', '        bytes32 indexed cancelHash,\n', '        bytes32 indexed orderHash,\n', '        address indexed user,\n', '        address tokenSell,\n', '        uint256 amountSell,\n', '        uint256 cancelFee\n', '    );\n', '\n', '    function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) {\n', '        if (expiry > 1000000) throw;\n', '        inactivityReleasePeriod = expiry;\n', '        return true;\n', '    }\n', '\n', '    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_, address affiliateContract_, address tokenListContract_) {\n', '        owner = msg.sender;\n', '        feeAccount = feeAccount_;\n', '        inactivityReleasePeriod = 100000;\n', '        makerFee = makerFee_;\n', '        takerFee = takerFee_;\n', '        affiliateFee = affiliateFee_;\n', '\n', '\n', '\n', '        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\n', '        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\n', '\n', '        affiliateContract = affiliateContract_;\n', '        tokenListContract = tokenListContract_;\n', '    }\n', '\n', '    function setFees(uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_) onlyOwner {\n', '        require(makerFee_ < 10 finney && takerFee_ < 10 finney);\n', '        require(affiliateFee_ > affiliateFee);\n', '        makerFee = makerFee_;\n', '        takerFee = takerFee_;\n', '        affiliateFee = affiliateFee_;\n', '        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\n', '        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\n', '\n', '        FeeChange(makerFee, takerFee, affiliateFee_);\n', '    }\n', '\n', '    function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        if (msg.sender != owner && !admins[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    function() external {\n', '        throw;\n', '    }\n', '\n', '    function depositToken(address token, uint256 amount, address referrerAddress) {\n', '        //require(EthermiumTokenList(tokenListContract).isTokenInList(token));\n', '        if (referrerAddress == msg.sender) referrerAddress = address(0);\n', '        if (referrer[msg.sender] == address(0x0))   {\n', '            if (referrerAddress != address(0x0) && Promotion(affiliateContract).getAffiliate(msg.sender) == address(0))\n', '            {\n', '                referrer[msg.sender] = referrerAddress;\n', '                Promotion(affiliateContract).assignReferral(referrerAddress, msg.sender);\n', '            }\n', '            else\n', '            {\n', '                referrer[msg.sender] = Promotion(affiliateContract).getAffiliate(msg.sender);\n', '            }\n', '        }\n', '        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '        lastActiveTransaction[msg.sender] = block.number;\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n', '        Deposit(token, msg.sender, amount, tokens[token][msg.sender], referrer[msg.sender]);\n', '    }\n', '\n', '    function deposit(address referrerAddress) payable {\n', '        if (referrerAddress == msg.sender) referrerAddress = address(0);\n', '        if (referrer[msg.sender] == address(0x0))   {\n', '            if (referrerAddress != address(0x0) && Promotion(affiliateContract).getAffiliate(msg.sender) == address(0))\n', '            {\n', '                referrer[msg.sender] = referrerAddress;\n', '                Promotion(affiliateContract).assignReferral(referrerAddress, msg.sender);\n', '            }\n', '            else\n', '            {\n', '                referrer[msg.sender] = Promotion(affiliateContract).getAffiliate(msg.sender);\n', '            }\n', '        }\n', '        tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n', '        lastActiveTransaction[msg.sender] = block.number;\n', '        Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender], referrer[msg.sender]);\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) returns (bool success) {\n', '        if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw;\n', '        if (tokens[token][msg.sender] < amount) throw;\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        if (token == address(0)) {\n', '            if (!msg.sender.send(amount)) throw;\n', '        } else {\n', '            if (!Token(token).transfer(msg.sender, amount)) throw;\n', '        }\n', '        Withdraw(token, msg.sender, amount, tokens[token][msg.sender], 0);\n', '    }\n', '\n', '    function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal) onlyAdmin returns (bool success) {\n', '        bytes32 hash = keccak256(this, token, amount, user, nonce);\n', '        if (withdrawn[hash]) throw;\n', '        withdrawn[hash] = true;\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) != user) throw;\n', '        if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n', '        if (tokens[token][user] < amount) throw;\n', '        tokens[token][user] = safeSub(tokens[token][user], amount);\n', '        tokens[address(0)][user] = safeSub(tokens[address(0x0)][user], feeWithdrawal);\n', '        //tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n', '        tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount], feeWithdrawal);\n', '\n', '        //amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n', '        if (token == address(0)) {\n', '            if (!user.send(amount)) throw;\n', '        } else {\n', '            if (!Token(token).transfer(user, amount)) throw;\n', '        }\n', '        lastActiveTransaction[user] = block.number;\n', '        Withdraw(token, user, amount, tokens[token][user], feeWithdrawal);\n', '    }\n', '\n', '    function balanceOf(address token, address user) constant returns (uint256) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    struct OrderPair {\n', '        uint256 makerAmountBuy;\n', '        uint256 makerAmountSell;\n', '        uint256 makerNonce;\n', '        uint256 takerAmountBuy;\n', '        uint256 takerAmountSell;\n', '        uint256 takerNonce;\n', '        uint256 takerGasFee;\n', '\n', '        address makerTokenBuy;\n', '        address makerTokenSell;\n', '        address maker;\n', '        address takerTokenBuy;\n', '        address takerTokenSell;\n', '        address taker;\n', '\n', '        bytes32 makerOrderHash;\n', '        bytes32 takerOrderHash;\n', '    }\n', '\n', '    struct TradeValues {\n', '        uint256 qty;\n', '        uint256 invQty;\n', '        uint256 makerAmountTaken;\n', '        uint256 takerAmountTaken;\n', '        address makerReferrer;\n', '        address takerReferrer;\n', '    }\n', '\n', '\n', '\n', '\n', '    function trade(\n', '        uint8[2] v,\n', '        bytes32[4] rs,\n', '        uint256[7] tradeValues,\n', '        address[6] tradeAddresses\n', '    ) onlyAdmin returns (uint filledTakerTokenAmount)\n', '    {\n', '\n', '        /* tradeValues\n', '          [0] makerAmountBuy\n', '          [1] makerAmountSell\n', '          [2] makerNonce\n', '          [3] takerAmountBuy\n', '          [4] takerAmountSell\n', '          [5] takerNonce\n', '          [6] takerGasFee\n', '\n', '          tradeAddresses\n', '          [0] makerTokenBuy\n', '          [1] makerTokenSell\n', '          [2] maker\n', '          [3] takerTokenBuy\n', '          [4] takerTokenSell\n', '          [5] taker\n', '        */\n', '\n', '        OrderPair memory t  = OrderPair({\n', '            makerAmountBuy  : tradeValues[0],\n', '            makerAmountSell : tradeValues[1],\n', '            makerNonce      : tradeValues[2],\n', '            takerAmountBuy  : tradeValues[3],\n', '            takerAmountSell : tradeValues[4],\n', '            takerNonce      : tradeValues[5],\n', '            takerGasFee     : tradeValues[6],\n', '\n', '            makerTokenBuy   : tradeAddresses[0],\n', '            makerTokenSell  : tradeAddresses[1],\n', '            maker           : tradeAddresses[2],\n', '            takerTokenBuy   : tradeAddresses[3],\n', '            takerTokenSell  : tradeAddresses[4],\n', '            taker           : tradeAddresses[5],\n', '\n', '            makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]),\n', '            takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5])\n', '        });\n', '\n', '        //bytes32 makerOrderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]);\n', '        //bytes32 makerOrderHash = §\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\n', '        {\n', '            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '        //bytes32 takerOrderHash = keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5]);\n', '        //bytes32 takerOrderHash = keccak256(this, t.takerTokenBuy, t.takerAmountBuy, t.takerTokenSell, t.takerAmountSell, t.takerNonce, t.taker);\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\n', '        {\n', '            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy)\n', '        {\n', '            LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', "        } // tokens don't match\n", '\n', '        if (t.takerGasFee > 1 finney)\n', '        {\n', '            LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        } // takerGasFee too high\n', '\n', '\n', '\n', '        if (!(\n', '        (t.makerTokenBuy != address(0x0) && safeMul(t.makerAmountSell, 5 finney) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 5 finney) / t.takerAmountSell)\n', '        ||\n', '        (t.makerTokenBuy == address(0x0) && safeMul(t.makerAmountBuy, 5 finney) / t.makerAmountSell <= safeMul(t.takerAmountSell, 5 finney) / t.takerAmountBuy)\n', '        ))\n', '        {\n', '            LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash);\n', "            return 0; // prices don't match\n", '        }\n', '\n', '        TradeValues memory tv = TradeValues({\n', '            qty                 : 0,\n', '            invQty              : 0,\n', '            makerAmountTaken    : 0,\n', '            takerAmountTaken    : 0,\n', '            makerReferrer       : referrer[t.maker],\n', '            takerReferrer       : referrer[t.taker]\n', '        });\n', '\n', '        if (tv.makerReferrer == address(0x0)) tv.makerReferrer = feeAccount;\n', '        if (tv.takerReferrer == address(0x0)) tv.takerReferrer = feeAccount;\n', '\n', '\n', '\n', '        // maker buy, taker sell\n', '        if (t.makerTokenBuy != address(0x0))\n', '        {\n', '\n', '\n', '            tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy));\n', '            if (tv.qty == 0)\n', '            {\n', '                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '                return 0;\n', '            }\n', '\n', '            tv.invQty = safeMul(tv.qty, t.makerAmountSell) / t.makerAmountBuy;\n', '\n', '            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.invQty);\n', '            tv.makerAmountTaken                         = safeSub(tv.qty, safeMul(tv.qty, makerFee) / (1 ether));\n', '            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\n', '            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.qty,    makerAffiliateFee) / (1 ether));\n', '\n', '            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.qty);\n', '            tv.takerAmountTaken                         = safeSub(safeSub(tv.invQty, safeMul(tv.invQty, takerFee) / (1 ether)), safeMul(tv.invQty, t.takerGasFee) / (1 ether));\n', '            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\n', '            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.invQty, takerAffiliateFee) / (1 ether));\n', '\n', '            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.qty,    safeSub(makerFee, makerAffiliateFee)) / (1 ether));\n', '            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.invQty, safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether)));\n', '\n', '\n', '            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty);\n', '            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], safeMul(tv.qty, t.takerAmountBuy) / t.takerAmountSell);\n', '            lastActiveTransaction[t.maker]          = block.number;\n', '            lastActiveTransaction[t.taker]          = block.number;\n', '\n', '            Trade(\n', '                t.takerTokenBuy, tv.qty,\n', '                t.takerTokenSell, tv.invQty,\n', '                t.maker, t.taker,\n', '                makerFee, takerFee,\n', '                tv.makerAmountTaken , tv.takerAmountTaken,\n', '                t.makerOrderHash, t.takerOrderHash\n', '            );\n', '            return tv.qty;\n', '        }\n', '        // maker sell, taker buy\n', '        else\n', '        {\n', '\n', '            tv.qty = min(safeSub(t.makerAmountSell,  safeMul(orderFills[t.makerOrderHash], t.makerAmountSell) / t.makerAmountBuy), safeSub(t.takerAmountBuy, orderFills[t.takerOrderHash]));\n', '            if (tv.qty == 0)\n', '            {\n', '                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '                return 0;\n', '            }\n', '\n', '            tv.invQty = safeMul(tv.qty, t.makerAmountBuy) / t.makerAmountSell;\n', '\n', '            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.qty);\n', '            tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));\n', '            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\n', '            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.invQty, makerAffiliateFee) / (1 ether));\n', '\n', '            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.invQty);\n', '            tv.takerAmountTaken                         = safeSub(safeSub(tv.qty,    safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether));\n', '            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\n', '            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.qty,    takerAffiliateFee) / (1 ether));\n', '\n', '            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, safeSub(makerFee, makerAffiliateFee)) / (1 ether));\n', '            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.qty,    safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether)));\n', '\n', '            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.invQty);\n', '            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); //safeMul(qty, tradeValues[takerAmountBuy]) / tradeValues[takerAmountSell]);\n', '\n', '            lastActiveTransaction[t.maker]          = block.number;\n', '            lastActiveTransaction[t.taker]          = block.number;\n', '\n', '            Trade(\n', '                t.takerTokenBuy, tv.qty,\n', '                t.takerTokenSell, tv.invQty,\n', '                t.maker, t.taker,\n', '                makerFee, takerFee,\n', '                tv.makerAmountTaken , tv.takerAmountTaken,\n', '                t.makerOrderHash, t.takerOrderHash\n', '            );\n', '            return tv.qty;\n', '        }\n', '    }\n', '\n', '    function batchOrderTrade(\n', '        uint8[2][] v,\n', '        bytes32[4][] rs,\n', '        uint256[7][] tradeValues,\n', '        address[6][] tradeAddresses\n', '    )\n', '    {\n', '        for (uint i = 0; i < tradeAddresses.length; i++) {\n', '            trade(\n', '                v[i],\n', '                rs[i],\n', '                tradeValues[i],\n', '                tradeAddresses[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    function cancelOrder(\n', '\t\t/*\n', '\t\t[0] orderV\n', '\t\t[1] cancelV\n', '\t\t*/\n', '\t    uint8[2] v,\n', '\n', '\t\t/*\n', '\t\t[0] orderR\n', '\t\t[1] orderS\n', '\t\t[2] cancelR\n', '\t\t[3] cancelS\n', '\t\t*/\n', '\t    bytes32[4] rs,\n', '\n', '\t\t/*\n', '\t\t[0] orderAmountBuy\n', '\t\t[1] orderAmountSell\n', '\t\t[2] orderNonce\n', '\t\t[3] cancelNonce\n', '\t\t[4] cancelFee\n', '\t\t*/\n', '\t\tuint256[5] cancelValues,\n', '\n', '\t\t/*\n', '\t\t[0] orderTokenBuy\n', '\t\t[1] orderTokenSell\n', '\t\t[2] orderUser\n', '\t\t[3] cancelUser\n', '\t\t*/\n', '\t\taddress[4] cancelAddresses\n', '    ) public onlyAdmin {\n', '        // Order values should be valid and signed by order owner\n', '        bytes32 orderHash = keccak256(\n', '\t        this, cancelAddresses[0], cancelValues[0], cancelAddresses[1],\n', '\t        cancelValues[1], cancelValues[2], cancelAddresses[2]\n', '        );\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);\n', '\n', "        // Cancel action should be signed by cancel's initiator\n", '        bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);\n', '\n', "        // Order owner should be same as cancel's initiator\n", '        require(cancelAddresses[2] == cancelAddresses[3]);\n', '\n', '        // Do not allow to cancel already canceled or filled orders\n', '        require(orderFills[orderHash] != cancelValues[0]);\n', '\n', '        // Limit cancel fee\n', '        if (cancelValues[4] > 6 finney) {\n', '            cancelValues[4] = 6 finney;\n', '        }\n', '\n', '        // Take cancel fee\n', '        // This operation throw an error if fee amount is more than user balance\n', '        tokens[address(0)][cancelAddresses[3]] = safeSub(tokens[address(0)][cancelAddresses[3]], cancelValues[4]);\n', '\n', '        // Cancel order by filling it with amount buy value\n', '        orderFills[orderHash] = cancelValues[0];\n', '\n', '        // Emit cancel order\n', '        CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]);\n', '    }\n', '\n', '    function min(uint a, uint b) private pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token\n', ' * @dev Token interface necessary for working with tokens within the exchange contract.\n', ' */\n', 'contract IToken {\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    uint public decimals;\n', '    string public name;\n', '}\n', '\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library LSafeMath {\n', '\n', '    uint256 constant WAD = 1 ether;\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        if (c / a == b)\n', '            return c;\n', '        revert();\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b > 0) { \n', '            uint256 c = a / b;\n', '            return c;\n', '        }\n', '        revert();\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (b <= a)\n', '            return a - b;\n', '        revert();\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        if (c >= a) \n', '            return c;\n', '        revert();\n', '    }\n', '\n', '    function wmul(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, b), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint a, uint b) internal pure returns (uint256) {\n', '        return add(mul(a, WAD), b / 2) / b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Coinchangex\n', ' * @dev This is the main contract for the Coinchangex exchange.\n', ' */\n', 'contract Tokenchange {\n', '  \n', '  using LSafeMath for uint;\n', '  \n', '  struct SpecialTokenBalanceFeeTake {\n', '      bool exist;\n', '      address token;\n', '      uint256 balance;\n', '      uint256 feeTake;\n', '  }\n', '  \n', '  uint constant private MAX_SPECIALS = 10;\n', '\n', '  /// Variables\n', '  address public admin; // the admin address\n', '  address public feeAccount; // the account that will receive fees\n', '  uint public feeTake; // percentage times (1 ether)\n', '  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\n', '  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '  SpecialTokenBalanceFeeTake[] public specialFees;\n', '  \n', '\n', '  /// Logging Events\n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\n', '  modifier isAdmin() {\n', '      require(msg.sender == admin);\n', '      _;\n', '  }\n', '\n', '  /// Constructor function. This is only called on contract creation.\n', '  function Coinchangex(address admin_, address feeAccount_, uint feeTake_) public {\n', '    admin = admin_;\n', '    feeAccount = feeAccount_;\n', '    feeTake = feeTake_;\n', '    depositingTokenFlag = false;\n', '  }\n', '\n', '  /// The fallback function. Ether transfered into the contract is not accepted.\n', '  function() public {\n', '    revert();\n', '  }\n', '\n', '  /// Changes the official admin user address. Accepts Ethereum address.\n', '  function changeAdmin(address admin_) public isAdmin {\n', '    require(admin_ != address(0));\n', '    admin = admin_;\n', '  }\n', '\n', '  /// Changes the account address that receives trading fees. Accepts Ethereum address.\n', '  function changeFeeAccount(address feeAccount_) public isAdmin {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\n', '  function changeFeeTake(uint feeTake_) public isAdmin {\n', '    // require(feeTake_ <= feeTake);\n', '    feeTake = feeTake_;\n', '  }\n', '  \n', '  // add special promotion fee\n', '  function addSpecialFeeTake(address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      uint id = specialFees.push(SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      ));\n', '  }\n', '  \n', '  // chnage special promotion fee\n', '  function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {\n', '      require(id < specialFees.length);\n', '      specialFees[id] = SpecialTokenBalanceFeeTake(\n', '          true,\n', '          token,\n', '          balance,\n', '          feeTake\n', '      );\n', '  }\n', '  \n', '    // remove special promotion fee\n', '   function removeSpecialFeeTake(uint id) public isAdmin {\n', '       if (id >= specialFees.length) revert();\n', '\n', '        uint last = specialFees.length-1;\n', '        for (uint i = id; i<last; i++){\n', '            specialFees[i] = specialFees[i+1];\n', '        }\n', '        \n', '        delete specialFees[last];\n', '        specialFees.length--;\n', '  } \n', '  \n', '  //return total count promotion fees\n', '  function TotalSpecialFeeTakes() public constant returns(uint)  {\n', '      return specialFees.length;\n', '  }\n', '  \n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Deposits, Withdrawals, Balances\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * This function handles deposits of Ether into the contract.\n', '  * Emits a Deposit event.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function deposit() public payable {\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n', '    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles withdrawals of Ether from the contract.\n', '  * Verifies that the user has enough funds to cover the withdrawal.\n', '  * Emits a Withdraw event.\n', '  * @param amount uint of the amount of Ether the user wishes to withdraw\n', '  */\n', '  function withdraw(uint amount) public {\n', '    require(tokens[0][msg.sender] >= amount);\n', '    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n', '    msg.sender.transfer(amount);\n', '    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * This function handles deposits of Ethereum based tokens to the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Deposit event.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', ' }\n', '\n', '  /**\n', '  * This function provides a fallback solution as outlined in ERC223.\n', '  * If tokens are deposited through depositToken(), the transaction will continue.\n', '  * If tokens are sent directly to this contract, the transaction is reverted.\n', '  * @param sender Ethereum address of the sender of the token\n', '  * @param amount amount of the incoming tokens\n', '  * @param data attached data similar to msg.data of Ether transactions\n', '  */\n', '  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\n', '      if (depositingTokenFlag) {\n', '        // Transfer was initiated from depositToken(). User token balance will be updated there.\n', '        return true;\n', '      } else {\n', '        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\n', '        // with direct transfers of ECR20 and ETH.\n', '        revert();\n', '      }\n', '  }\n', '  \n', '  /**\n', '  * This function handles withdrawals of Ethereum based tokens from the contract.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Emits a Withdraw event.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param amount uint of the amount of the token the user wishes to withdraw\n', '  */\n', '  function withdrawToken(address token, uint amount) public {\n', '    require(token != 0);\n', '    require(tokens[token][msg.sender] >= amount);\n', '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '    require(IToken(token).transfer(msg.sender, amount));\n', '    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  /**\n', '  * Retrieves the balance of a token based on a user address and token address.\n', '  * @param token Ethereum contract address of the token or 0 for Ether\n', '  * @param user Ethereum address of the user\n', '  * @return the amount of tokens on the exchange for a given user address\n', '  */\n', '  function balanceOf(address token, address user) public constant returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Trading\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  /**\n', '  * Facilitates a trade from one user to another.\n', "  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\n", '  * Calls tradeBalances().\n', '  * Updates orderFills with the amount traded.\n', '  * Emits a Trade event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require((\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires &&\n', '      orderFills[user][hash].add(amount) <= amountGet\n', '    ));\n', '    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '    orderFills[user][hash] = orderFills[user][hash].add(amount);\n', '    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\n', '  }\n', '\n', '  /**\n', '  * This is a private function and is only being called from trade().\n', '  * Handles the movement of funds when a trade occurs.\n', '  * Takes fees.\n', '  * Updates token balances for both buyer and seller.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  */\n', '  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '    \n', '    uint256 feeTakeXfer = calculateFee(amount);\n', '    \n', '    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\n', '    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\n', '    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\n', '    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\n', '    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\n', '  }\n', '  \n', '  //calculate fee including special promotions\n', '  function calculateFee(uint amount) private constant returns(uint256)  {\n', '    uint256 feeTakeXfer = 0;\n', '    \n', '    uint length = specialFees.length;\n', '    bool applied = false;\n', '    for(uint i = 0; length > 0 && i < length; i++) {\n', '        SpecialTokenBalanceFeeTake memory special = specialFees[i];\n', '        if(special.exist && special.balance <= tokens[special.token][msg.sender]) {\n', '            applied = true;\n', '            feeTakeXfer = amount.mul(special.feeTake).div(1 ether);\n', '            break;\n', '        }\n', '        if(i >= MAX_SPECIALS)\n', '            break;\n', '    }\n', '    \n', '    if(!applied)\n', '        feeTakeXfer = amount.mul(feeTake).div(1 ether);\n', '    \n', '    \n', '    return feeTakeXfer;\n', '  }\n', '\n', '  /**\n', '  * This function is to test if a trade would go through.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * Note: amount is in amountGet / tokenGet terms.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @param amount uint amount in terms of tokenGet that will be "buy" in the trade\n', '  * @param sender Ethereum address of the user taking the order\n', '  * @return bool: true if the trade would be successful, false otherwise\n', '  */\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n', '    if (!(\n', '      tokens[tokenGet][sender] >= amount &&\n', '      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '      )) { \n', '      return false;\n', '    } else {\n', '      return true;\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the available volume for a given order.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\n', '  */\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    if (!(\n', '      (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == user) &&\n', '      block.number <= expires\n', '      )) {\n', '      return 0;\n', '    }\n', '    uint[2] memory available;\n', '    available[0] = amountGet.sub(orderFills[user][hash]);\n', '    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\n', '    if (available[0] < available[1]) {\n', '      return available[0];\n', '    } else {\n', '      return available[1];\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function checks the amount of an order that has already been filled.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param user Ethereum address of the user who placed the order\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    return orderFills[user][hash];\n', '  }\n', '\n', '  /**\n', '  * This function cancels a given order by editing its fill data to the full amount.\n', '  * Requires that the transaction is signed properly.\n', '  * Updates orderFills to the full amountGet\n', '  * Emits a Cancel event.\n', '  * Note: tokenGet & tokenGive can be the Ethereum contract address.\n', '  * @param tokenGet Ethereum contract address of the token to receive\n', '  * @param amountGet uint amount of tokens being received\n', '  * @param tokenGive Ethereum contract address of the token to give\n', '  * @param amountGive uint amount of tokens being given\n', '  * @param expires uint of block number when this order should expire\n', '  * @param nonce arbitrary random number\n', '  * @param v part of signature for the order hash as signed by user\n', '  * @param r part of signature for the order hash as signed by user\n', '  * @param s part of signature for the order hash as signed by user\n', '  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n', '  */\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '    require ((ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) == msg.sender));\n', '    orderFills[msg.sender][hash] = amountGet;\n', '    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '  }\n', '\n', '  \n', '  /**\n', '  * This function handles deposits of Ether into the contract, but allows specification of a user.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: With the payable modifier, this function accepts Ether.\n', '  */\n', '  function depositForUser(address user) public payable {\n', '    require(user != address(0));\n', '    require(msg.value > 0);\n', '    tokens[0][user] = tokens[0][user].add(msg.value);\n', '  }\n', '  \n', '  /**\n', '  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\n', '  * Does not allow Ether.\n', '  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n', '  * Note: This is generally used in migration of funds.\n', '  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '  * @param token Ethereum contract address of the token\n', '  * @param amount uint of the amount of the token the user wishes to deposit\n', '  */\n', '  function depositTokenForUser(address token, uint amount, address user) public {\n', '    require(token != address(0));\n', '    require(user != address(0));\n', '    require(amount > 0);\n', '    depositingTokenFlag = true;\n', '    require(IToken(token).transferFrom(msg.sender, this, amount));\n', '    depositingTokenFlag = false;\n', '    tokens[token][user] = tokens[token][user].add(amount);\n', '  }\n', '  \n', '}']