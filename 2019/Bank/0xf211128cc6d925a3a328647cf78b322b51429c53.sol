['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier - Full Stack Blockchain Developer\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   gibmireinbier@gmail.com\n', '*/\n', '\n', '/*\n', '    CHANGELOGS:\n', '    . Round 0: 10% bonus for old invester (with limit based on total dividends income in version 1) -- REMOVED by Seizo\n', '    . Round 0: start price 0.0014 ether, Min. duration 3 days, 30% to Pot, 70% hold for token selling -- REMOVED by Seizo\n', '    . Round 0: premine function, claim free tokens based on F2M v1 Dividends -- REMOVED by Seizo\n', '    . BEFORE_SLEEP_DURAION = 30 * ONE_DAY ( Last round must be greater than 28)\n', '\n', '    BUGS FIXED:\n', '    . SwapToken function : update credit after tokens selling\n', '    . Referral by token reinvest\n', '    . Tokenholders tracking on etherscan (emit transfer in mint-, burn-token functions)\n', '\n', '*/\n', '\n', 'contract F2m{\n', '    using SafeMath for *;\n', '\n', '    modifier onlyTokenHolders() {\n', '        require(balances[msg.sender] > 0, "not own any token");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyAdmin(){\n', '        require(msg.sender == devTeam, "admin required");\n', '        _;\n', '    }\n', '\n', '    modifier withdrawRight(){\n', '        require((msg.sender == address(bankContract)), "Bank Only");\n', '        _;\n', '    }\n', '\n', '    modifier swapNotActived() {\n', '        require(swapActived == false, "swap actived, stop minting new tokens");\n', '        _;\n', '    }\n', '\n', '    modifier buyable() {\n', '        require(buyActived == true, "token sale not ready");\n', '        _;\n', '    }\n', '\n', '    // modifier premineable() {\n', '    //     require(buyActived == false && investedAmount == 0, "token sale already");\n', '    //     _;\n', '    // }\n', '    \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/  \n', '    // ERC20\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    \n', '    /*=====================================\n', '    =                 ERC20               =\n', '    =====================================*/\n', '    uint256 public totalSupply;  \n', '    string public name;  \n', '    string public symbol;  \n', '    uint32 public decimals;\n', '    uint256 public unitRate;\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', ' \n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    \n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    CitizenInterface public citizenContract;\n', '    LotteryInterface public lotteryContract;\n', '    BankInterface public bankContract;\n', '    NewTokenInterface public newTokenContract;\n', '    WhitelistInterface public whitelistContract;\n', '\n', '    uint256 constant public ONE_HOUR= 3600;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR; // seconds\n', '    // uint256 constant public FIRST_POT_MAXIMUM = 200 ether;\n', '    // uint256 constant public ROUND0_MIN_DURATION = 3 * ONE_DAY; // minimum\n', '    uint256 constant public BEFORE_SLEEP_DURAION = 30 * ONE_DAY;\n', '\n', '    uint256 public HARD_TOTAL_SUPPLY = 8000000;\n', '\n', '    uint256 public refPercent = 15;\n', '    uint256 public divPercent = 10;\n', '    uint256 public fundPercent = 2;\n', '    // uint256 public potPercent = 30; // set to 0 in func disableRound0()\n', '\n', '    //Start Price\n', '    uint256 public startPrice = 0.0014 ether;\n', '    //Most Tolerable Break-Even Period (MTBEP)\n', '    uint256 constant public BEP = 30;\n', '\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => int256) public credit;\n', '    mapping(address => uint256) public withdrawnAmount;\n', '    mapping(address => uint256) public fromSellingAmount;\n', '\n', '    mapping(address => uint256) public lastActiveDay;\n', '    mapping(address => int256) public todayCredit;\n', '\n', '    mapping(address => uint256) public pInvestedSum;\n', '\n', '    uint256 public investedAmount;\n', '    uint256 public totalBuyVolume;\n', '    uint256 public totalSellVolume;\n', '    uint256 public totalDividends;\n', '    mapping(uint256 => uint256) public totalDividendsByRound;\n', '\n', '    //Profit Per Share \n', '    uint256 public pps = 0;\n', '\n', '    //log by round\n', '    mapping(uint256 => uint256) rPps;\n', '    mapping(address => mapping (uint256 => int256)) rCredit; \n', '\n', '    // uint256 public deployedTime;\n', '    uint256 public deployedDay;\n', '\n', '    // on/off auto buy Token\n', '    bool public autoBuy = false;\n', '\n', '    bool public round0 = false; //raise for first round\n', '\n', '    //pps added in day\n', '    mapping(uint256 => uint256) public ppsInDay; //Avarage pps in a day\n', '    mapping(uint256 => uint256) public divInDay;\n', '    mapping(uint256 => uint256) public totalBuyVolumeInDay;\n', '    mapping(uint256 => uint256) public totalSellVolumeInDay;\n', '\n', '    address public devTeam; //Smart contract address\n', '\n', '    uint256 public swapTime;\n', '    bool public swapActived = false;\n', '    bool public buyActived = false;\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        symbol = "F2M2";  \n', '        name = "Fomo2Moon2";  \n', '        decimals = 10;\n', '        unitRate = 10**uint256(decimals);\n', '        HARD_TOTAL_SUPPLY = HARD_TOTAL_SUPPLY * unitRate;\n', '        DevTeamInterface(_devTeam).setF2mAddress(address(this));\n', '        devTeam = _devTeam;\n', '        // manuell airdrops to old investers\n', '        uint256 _amount = 500000 * unitRate;\n', '        totalSupply += _amount;\n', '        balances[devTeam] = _amount;\n', '        emit Transfer(0x0, devTeam, _amount);\n', '        deployedDay = getToday();\n', '    }\n', '\n', '    // function premine() \n', '    //     public\n', '    //     premineable()\n', '    // {\n', '    //     address _sender = msg.sender;\n', '    //     require(balances[_sender] == 0, "already claimed");\n', '    //     uint256 _amount = whitelistContract.getPremintAmount(_sender);\n', '    //     totalSupply += _amount;\n', '    //     balances[_sender] = _amount;\n', '    //     emit Transfer(0x0, _sender, _amount);\n', '    // }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require(address(citizenContract) == 0x0, "already setup");\n', '        bankContract = BankInterface(_contract[1]);\n', '        citizenContract = CitizenInterface(_contract[2]);\n', '        lotteryContract = LotteryInterface(_contract[3]);\n', '        whitelistContract = WhitelistInterface(_contract[5]);\n', '    }\n', ' \n', '    function()\n', '        public\n', '        payable\n', '    {\n', '        // Thanks for Donation\n', '    }\n', '\n', '    // one time called, manuell called in case not reached 360ETH for totalPot\n', '/*     function disableRound0() \n', '        public \n', '        onlyAdmin() \n', '    {\n', '        require(buyActived && block.timestamp > ROUND0_MIN_DURATION.add(deployedTime), "too early to disable Round0");\n', '        firstRoundPrepare();\n', '    } */\n', '\n', '    function activeBuy()\n', '        public\n', '        onlyAdmin()\n', '    {\n', '        require(buyActived == false, "already actived");\n', '        buyActived = true;\n', '        deployedDay = getToday();\n', '    }\n', '\n', '    // Dividends from all sources (DApps, Donate ...)\n', '    function pushDividends() \n', '        public \n', '        payable \n', '    {\n', '        // shared to fund and dividends only\n', '        uint256 ethAmount = msg.value;\n', '        uint256 dividends = ethAmount * divPercent / (divPercent + fundPercent);\n', '        uint256 fund = ethAmount.sub(dividends);\n', '        uint256 _buyPrice = getBuyPrice();\n', '        // distributeTax(msg.sender, fund, dividends, 0, 0);\n', '        distributeTax(msg.sender, fund, dividends, 0);\n', '        if (autoBuy) devTeamAutoBuy(0, _buyPrice);\n', '    }\n', '\n', '    function addFund(uint256 _fund)\n', '        private\n', '    {\n', '        credit[devTeam] = credit[devTeam].sub(int256(_fund));\n', '    }\n', '\n', '    function addDividends(uint256 _dividends)\n', '        private\n', '    {\n', '        if (_dividends == 0) return;\n', '        totalDividends += _dividends;\n', '        uint256 today = getToday();\n', '        divInDay[today] = _dividends.add(divInDay[today]);\n', '\n', '        if (totalSupply == 0) {\n', '            addFund(_dividends);\n', '        } else {\n', '            // increased profit with each token\n', '            // gib mir n bier\n', '            addFund(_dividends % totalSupply);\n', '            uint256 deltaShare = _dividends / totalSupply;\n', '            pps = pps.add(deltaShare);\n', '\n', '            // logs\n', '            uint256 curRoundId = getCurRoundId();\n', '            rPps[curRoundId] += deltaShare;\n', '            totalDividendsByRound[curRoundId] += _dividends;\n', '            ppsInDay[today] = deltaShare + ppsInDay[today];\n', '        }\n', '    }\n', '\n', '    function addToRef(address _sender, uint256 _toRef)\n', '        private\n', '    {\n', '        if (_toRef == 0) return;\n', '        citizenContract.pushRefIncome.value(_toRef)(_sender);\n', '    }\n', '\n', '/*     function addToPot(uint256 _toPot)\n', '        private\n', '    {\n', '        if (_toPot == 0) return;\n', '        lotteryContract.pushToPot.value(_toPot)();\n', '        uint256 _totalPot = lotteryContract.getTotalPot();\n', '\n', '        // auto disable Round0 if reached 360ETH for first round\n', '        if (_totalPot >= FIRST_POT_MAXIMUM) {\n', '            firstRoundPrepare();\n', '        }\n', '    } */\n', '\n', '/*     function firstRoundPrepare()\n', '        private\n', '    {\n', '        round0 = false;\n', '        potPercent = 0;\n', '        refPercent = 15;\n', '        divPercent = 10;\n', '        fundPercent = 2;\n', '        startPrice = 0.002;\n', '    } */\n', '\n', '    function distributeTax(\n', '        address _sender,\n', '        uint256 _fund,\n', '        uint256 _dividends,\n', '        uint256 _toRef)\n', '        // uint256 _toPot)\n', '        private\n', '    {\n', '        addFund(_fund);\n', '        addDividends(_dividends);\n', '        addToRef(_sender, _toRef);\n', '        //addToPot(_toPot);\n', '    }\n', '\n', '    function updateCredit(address _owner, uint256 _currentEthAmount, uint256 _rDividends, uint256 _todayDividends) \n', '        private \n', '    {\n', '        // basicly to keep ethBalance not changed, after token balances changed (minted or burned)\n', '        // ethBalance = pps * tokens -credit\n', '        uint256 curRoundId = getCurRoundId();\n', '        credit[_owner] = int256(pps.mul(balances[_owner])).sub(int256(_currentEthAmount));\n', '        // logs\n', '        rCredit[_owner][curRoundId] = int256(rPps[curRoundId] * balances[_owner]) - int256(_rDividends);\n', '        todayCredit[_owner] = int256(ppsInDay[getToday()] * balances[_owner]) - int256(_todayDividends);\n', '    }\n', '\n', '    function mintToken(address _buyer, uint256 _taxedAmount, uint256 _buyPrice) \n', '        private \n', '        swapNotActived()\n', '        buyable()\n', '        returns(uint256) \n', '    {\n', '        uint256 revTokens = ethToToken(_taxedAmount, _buyPrice);\n', '        investedAmount = investedAmount.add(_taxedAmount);\n', '        // lottery ticket buy could be blocked without this\n', '        // the 1% from ticket buy will increases tokenSellPrice when totalSupply capped\n', '        if (revTokens + totalSupply > HARD_TOTAL_SUPPLY) \n', '            revTokens = HARD_TOTAL_SUPPLY.sub(totalSupply);\n', '        balances[_buyer] = balances[_buyer].add(revTokens);\n', '        totalSupply = totalSupply.add(revTokens);\n', '        emit Transfer(0x0, _buyer, revTokens);\n', '        return revTokens;\n', '    }\n', '\n', '    function burnToken(address _seller, uint256 _tokenAmount) \n', '        private \n', '        returns (uint256) \n', '    {\n', '        require(balances[_seller] >= _tokenAmount, "not enough to burn");\n', '        uint256 revEthAmount = tokenToEth(_tokenAmount);\n', '        investedAmount = investedAmount.sub(revEthAmount);\n', '        balances[_seller] = balances[_seller].sub(_tokenAmount);\n', '        totalSupply = totalSupply.sub(_tokenAmount);\n', '        emit Transfer(_seller, 0x0, _tokenAmount);\n', '        return revEthAmount;\n', '    }\n', '\n', '    function devTeamAutoBuy(uint256 _reserved, uint256 _buyPrice)\n', '        private\n', '    {\n', '        uint256 _refClaim = citizenContract.devTeamReinvest();\n', '        credit[devTeam] -= int256(_refClaim);\n', '        uint256 _ethAmount = ethBalance(devTeam);\n', '        if ((_ethAmount + _reserved) / _buyPrice + totalSupply > HARD_TOTAL_SUPPLY) return;\n', '\n', '        uint256 _rDividends = getRDividends(devTeam);\n', '        uint256 _todayDividends = getTodayDividendsByAddress(devTeam);\n', '        mintToken(devTeam, _ethAmount, _buyPrice);\n', '        updateCredit(devTeam, 0, _rDividends, _todayDividends);\n', '    }\n', '\n', '    function buy()\n', '        public\n', '        payable\n', '    {\n', '        address _buyer = msg.sender;\n', '        buyFor(_buyer);\n', '    }\n', '\n', '/*     function checkLimit(address _buyer)\n', '        private\n', '        view\n', '    {\n', '        require(!round0 || !whitelistContract.isLimited(_buyer, pInvestedSum[_buyer]), "Limited");\n', '    } */\n', '\n', '    function buyFor(address _buyer) \n', '        public \n', '        payable\n', '    {\n', '        //ADD Round0 WHITE LIST\n', '        // tax = fund + dividends + toRef + toPot;\n', '        updateLastActive(_buyer);\n', '        uint256 _buyPrice = getBuyPrice();\n', '        uint256 ethAmount = msg.value;\n', '        pInvestedSum[_buyer] += ethAmount;\n', '        // checkLimit(_buyer);\n', '        uint256 onePercent = ethAmount / 100;\n', '        uint256 fund = onePercent.mul(fundPercent);\n', '        uint256 dividends = onePercent.mul(divPercent);\n', '        uint256 toRef = onePercent.mul(refPercent);\n', '        // uint256 toPot = onePercent.mul(potPercent);\n', '        // uint256 tax = fund + dividends + toRef + toPot;\n', '        uint256 tax = fund + dividends + toRef;\n', '        uint256 taxedAmount = ethAmount.sub(tax);\n', '        \n', '        totalBuyVolume = totalBuyVolume + ethAmount;\n', '        totalBuyVolumeInDay[getToday()] += ethAmount;\n', '\n', '        // distributeTax(_buyer, fund, dividends, toRef, toPot);\n', '        distributeTax(_buyer, fund, dividends, toRef);\n', '        if (autoBuy) devTeamAutoBuy(taxedAmount, _buyPrice);\n', '\n', '        uint256 curEthBalance = ethBalance(_buyer);\n', '        uint256 _rDividends = getRDividends(_buyer);\n', '        uint256 _todayDividends = getTodayDividendsByAddress(_buyer);\n', '\n', '        mintToken(_buyer, taxedAmount, _buyPrice);\n', '        updateCredit(_buyer, curEthBalance, _rDividends, _todayDividends);\n', '    }\n', '\n', '    function sell(uint256 _tokenAmount)\n', '        public\n', '        onlyTokenHolders()\n', '    {\n', '        // tax = fund only\n', '        updateLastActive(msg.sender);\n', '        address seller = msg.sender;\n', '        uint256 curEthBalance = ethBalance(seller);\n', '        uint256 _rDividends = getRDividends(seller);\n', '        uint256 _todayDividends = getTodayDividendsByAddress(seller);\n', '\n', '        uint256 ethAmount = burnToken(seller, _tokenAmount);\n', '        uint256 fund = ethAmount.mul(fundPercent) / 100;\n', '        uint256 taxedAmount = ethAmount.sub(fund);\n', '\n', '        totalSellVolume = totalSellVolume + ethAmount;\n', '        totalSellVolumeInDay[getToday()] += ethAmount;\n', '        curEthBalance = curEthBalance.add(taxedAmount);\n', '        fromSellingAmount[seller] += taxedAmount;\n', '        \n', '        updateCredit(seller, curEthBalance, _rDividends, _todayDividends);\n', '        // distributeTax(msg.sender, fund, 0, 0, 0);\n', '        distributeTax(msg.sender, fund, 0, 0);\n', '    }\n', '\n', '    function devTeamWithdraw()\n', '        public\n', '        returns(uint256)\n', '    {\n', '        address sender = msg.sender;\n', '        require(sender == devTeam, "dev. Team only");\n', '        uint256 amount = ethBalance(sender);\n', '        if (amount == 0) return 0;\n', '        credit[sender] += int256(amount);\n', '        withdrawnAmount[sender] = amount.add(withdrawnAmount[sender]);\n', '        devTeam.transfer(amount);\n', '        return amount;\n', '    }\n', '\n', '    function withdrawFor(address sender)\n', '        public\n', '        withdrawRight()\n', '        returns(uint256)\n', '    {\n', '        uint256 amount = ethBalance(sender);\n', '        if (amount == 0) return 0;\n', '        credit[sender] = credit[sender].add(int256(amount));\n', '        withdrawnAmount[sender] = amount.add(withdrawnAmount[sender]);\n', '        bankContract.pushToBank.value(amount)(sender);\n', '        return amount;\n', '    }\n', '\n', '    function updateAllowed(address _from, address _to, uint256 _tokenAmount)\n', '        private\n', '    {\n', '        require(balances[_from] >= _tokenAmount, "not enough to transfer");\n', '        if (_from != msg.sender)\n', '        allowed[_from][_to] = allowed[_from][_to].sub(_tokenAmount);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _tokenAmount)\n', '        public\n', '        returns(bool)\n', '    {   \n', '        updateAllowed(_from, _to, _tokenAmount);\n', '        updateLastActive(_from);\n', '        updateLastActive(_to);\n', '\n', '        uint256 curEthBalance_from = ethBalance(_from);\n', '        uint256 _rDividends_from = getRDividends(_from);\n', '        uint256 _todayDividends_from = getTodayDividendsByAddress(_from);\n', '\n', '        uint256 curEthBalance_to = ethBalance(_to);\n', '        uint256 _rDividends_to = getRDividends(_to);\n', '        uint256 _todayDividends_to = getTodayDividendsByAddress(_to);\n', '\n', '        uint256 taxedTokenAmount = _tokenAmount;\n', '        balances[_from] -= taxedTokenAmount;\n', '        balances[_to] += taxedTokenAmount;\n', '        updateCredit(_from, curEthBalance_from, _rDividends_from, _todayDividends_from);\n', '        updateCredit(_to, curEthBalance_to, _rDividends_to, _todayDividends_to);\n', '        // fire event\n', '        emit Transfer(_from, _to, taxedTokenAmount);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenAmount)\n', '        public \n', '        returns (bool) \n', '    {\n', '        transferFrom(msg.sender, _to, _tokenAmount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) \n', '        public \n', '        returns (bool success) \n', '    {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function updateLastActive(address _sender) \n', '        private\n', '    {\n', '        if (lastActiveDay[_sender] != getToday()) {\n', '            lastActiveDay[_sender] = getToday();\n', '            todayCredit[_sender] = 0;\n', '        }\n', '    }\n', '    \n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '    function setAutoBuy() \n', '        public\n', '        onlyAdmin()\n', '    {\n', '        autoBuy = !autoBuy;\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    function totalEthBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function ethBalance(address _address)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (uint256) ((int256)(pps.mul(balances[_address])).sub(credit[_address]));\n', '    }\n', '\n', '    function getTotalDividendsByAddress(address _invester)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (ethBalance(_invester)) + (withdrawnAmount[_invester]) - (fromSellingAmount[_invester]);\n', '    }\n', '\n', '    function getTodayDividendsByAddress(address _invester)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        int256 _todayCredit = (getToday() == lastActiveDay[_invester]) ? todayCredit[_invester] : 0;\n', '        return (uint256) ((int256)(ppsInDay[getToday()] * balances[_invester]) - _todayCredit);\n', '    }\n', '    \n', '    /*==========================================\n', '    =            public FUNCTIONS            =\n', '    ==========================================*/\n', '\n', '    /**\n', '     * Return the sell price of 1 individual token.\n', '     */\n', '    function getSellPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        if (totalSupply == 0) {\n', '            return 0;\n', '        } else {\n', '            return investedAmount / totalSupply;\n', '        }\n', '    }\n', '\n', '    function getSellPriceAfterTax() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        uint256 _sellPrice = getSellPrice();\n', '        uint256 taxPercent = fundPercent;\n', '        return _sellPrice * (100 - taxPercent) / 100;\n', '    }\n', '    \n', '    /**\n', '     * Return the buy price of 1 individual token.\n', '     * Start Price + (7-day Average Dividend Payout) x BEP x HARD_TOTAL_SUPPLY / (Total No. of Circulating Tokens) / (HARD_TOTAL_SUPPLY - Total No. of Circulating Tokens + 1)\n', '     */\n', '    function getBuyPrice() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // average profit per share of a day in week\n', '        // uint256 taxPercent = fundPercent + potPercent + divPercent + refPercent;\n', '        uint256 taxPercent = fundPercent + divPercent + refPercent;\n', '        //if (round0) return startPrice * (100 - taxPercent) / 100 / unitRate;\n', '        uint256 avgPps = getAvgPps();\n', '        uint256 _sellPrice = getSellPrice();\n', '        uint256 _buyPrice = (startPrice / unitRate + avgPps * BEP * HARD_TOTAL_SUPPLY / (HARD_TOTAL_SUPPLY + unitRate - totalSupply)) * (100 - taxPercent) / 100;\n', '        uint256 _min = _sellPrice * 14 / 10;\n', '        if (_buyPrice < _min) return _min;\n', '        return _buyPrice;\n', '    }\n', '\n', '    function getBuyPriceAfterTax()\n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        // average profit per share of a day in week\n', '        uint256 _buyPrice = getBuyPrice();\n', '        // uint256 taxPercent = fundPercent + potPercent + divPercent + refPercent;\n', '        uint256 taxPercent = fundPercent + divPercent + refPercent;\n', '        return _buyPrice * 100 / (100 - taxPercent);\n', '    }\n', '\n', '    function ethToToken(uint256 _ethAmount, uint256 _buyPrice)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        // v1 limit _ethAmount > 1.001 * 0.7 = 0.7007 ether\n', '        // only v1 invester _ethAmount > 0.7007 (after tax), bonus 10% token\n', '        uint256 revToken = _ethAmount / _buyPrice;\n', '/*         if ((round0) && (_ethAmount > 0.7007 ether)) {\n', '            revToken = revToken * 11 / 10;\n', '        } */\n', '        return revToken;\n', '    }\n', '    \n', '    function tokenToEth(uint256 _tokenAmount)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 sellPrice = getSellPrice();\n', '        return _tokenAmount.mul(sellPrice);\n', '    }\n', '    \n', '    function getToday() \n', '        public \n', '        view \n', '        returns (uint256) \n', '    {\n', '        return (block.timestamp / ONE_DAY);\n', '    }\n', '\n', '    //Avarage Profit per Share in last 7 Days\n', '    function getAvgPps() \n', '        public \n', '        view \n', '        returns (uint256) \n', '    {\n', '        uint256 divSum = 0;\n', '        uint256 _today = getToday();\n', '        uint256 _fromDay = _today - 6;\n', '        if (_fromDay < deployedDay) _fromDay = deployedDay;\n', '        for (uint256 i = _fromDay; i <= _today; i++) {\n', '            divSum = divSum.add(divInDay[i]);\n', '        }\n', '        if (totalSupply == 0) return 0;\n', '        return divSum / (_today + 1 - _fromDay) / totalSupply;\n', '    }\n', '\n', '    function getTotalVolume() \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return totalBuyVolume + totalSellVolume;\n', '    }\n', '\n', '    function getWeeklyBuyVolume() \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _total = 0;\n', '        uint256 _today = getToday();\n', '        for (uint256 i = _today; i + 7 > _today; i--) {\n', '            _total = _total + totalBuyVolumeInDay[i];\n', '        }\n', '        return _total;\n', '    }\n', '\n', '    function getWeeklySellVolume() \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _total = 0;\n', '        uint256 _today = getToday();\n', '        for (uint256 i = _today; i + 7 > _today; i--) {\n', '            _total = _total + totalSellVolumeInDay[i];\n', '        }\n', '        return _total;\n', '    }\n', '\n', '    function getWeeklyVolume()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return getWeeklyBuyVolume() + getWeeklySellVolume();\n', '    }\n', '\n', '    function getTotalDividends()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return totalDividends;\n', '    }\n', '\n', '    function getRDividends(address _invester)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 curRoundId = getCurRoundId();\n', '        return uint256(int256(rPps[curRoundId] * balances[_invester]) - rCredit[_invester][curRoundId]);\n', '    }\n', '\n', '    function getWeeklyDividends()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 divSum = 0;\n', '        uint256 _today = getToday();\n', '        uint256 _fromDay = _today - 6;\n', '        if (_fromDay < deployedDay) _fromDay = deployedDay;\n', '        for (uint256 i = _fromDay; i <= _today; i++) {\n', '            divSum = divSum.add(divInDay[i]);\n', '        }\n', '        \n', '        return divSum;\n', '    }\n', '\n', '    function getMarketCap()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return totalSupply.mul(getBuyPriceAfterTax());\n', '    }\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function myBalance() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        return balances[msg.sender];\n', '    }\n', '\n', '    function myEthBalance() \n', '        public \n', '        view \n', '        returns(uint256) \n', '    {\n', '        return ethBalance(msg.sender);\n', '    }\n', '\n', '    function myCredit() \n', '        public \n', '        view \n', '        returns(int256) \n', '    {\n', '        return credit[msg.sender];\n', '    }\n', '\n', '/*     function getRound0MinDuration()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if (!round0) return 0;\n', '        if (block.timestamp > ROUND0_MIN_DURATION.add(deployedTime)) return 0;\n', '        return ROUND0_MIN_DURATION + deployedTime - block.timestamp;\n', '    }\n', ' */\n', '    // Lottery\n', '\n', '    function getCurRoundId()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return lotteryContract.getCurRoundId();\n', '    }\n', '\n', '    //SWAP TOKEN, PUBLIC SWAP_DURAION SECONDS BEFORE\n', '    function swapToken()\n', '        public\n', '        onlyTokenHolders()\n', '    {\n', '        require(swapActived, "swap not actived");\n', '        address _invester = msg.sender;\n', '        uint256 _tokenAmount = balances[_invester];\n', '        uint256 _ethAmount = ethBalance(_invester);\n', '        // burn all token\n', '        _ethAmount += burnToken(_invester, _tokenAmount);\n', '        updateCredit(_invester, 0, 0, 0);\n', '        // swapToken function in new contract accepts only sender = this old contract\n', '        newTokenContract.swapToken.value(_ethAmount)(_tokenAmount, _invester);\n', '    }\n', '\n', '    // start swapping, disable buy\n', '    function setNewToken(address _newTokenAddress)\n', '        public\n', '        onlyAdmin()\n', '    {\n', '        bool _isLastRound = lotteryContract.isLastRound();\n', '        require(_isLastRound, "too early");\n', '        require(swapActived == false, "already set");\n', '        swapTime = block.timestamp;\n', '        swapActived = true;\n', '        newTokenContract = NewTokenInterface(_newTokenAddress);\n', '        autoBuy = false;\n', '    }\n', '\n', '    // after 30 days from swapTime, devteam withdraw whole eth.\n', '    function sleep()\n', '        public\n', '    {\n', '        require(swapActived, "swap not actived");\n', '        require(swapTime + BEFORE_SLEEP_DURAION < block.timestamp, "too early");\n', '        uint256 _ethAmount = address(this).balance;\n', '        devTeam.transfer(_ethAmount);\n', '        //ICE\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface CitizenInterface {\n', ' \n', '    function joinNetwork(address[6] _contract) public;\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function devTeamWithdraw() public;\n', '\n', '    /*----------  WRITE FUNCTIONS  ----------*/\n', '    function updateUsername(string _sNewUsername) public;\n', '    //Sources: Token contract, DApps\n', '    function pushRefIncome(address _sender) public payable;\n', '    function withdrawFor(address _sender) public payable returns(uint256);\n', '    function devTeamReinvest() public returns(uint256);\n', '\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getRefWallet(address _address) public view returns(uint256);\n', '}\n', '\n', 'interface LotteryInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // call one time\n', '    function activeFirstRound() public;\n', '    // Core Functions\n', '    function pushToPot() public payable;\n', '    function finalizeable() public view returns(bool);\n', '    // bounty\n', '    function finalize() public;\n', '    function buy(string _sSalt) public payable;\n', '    function buyFor(string _sSalt, address _sender) public payable;\n', '    //function withdraw() public;\n', '    function withdrawFor(address _sender) public returns(uint256);\n', '\n', '    function getRewardBalance(address _buyer) public view returns(uint256);\n', '    function getTotalPot() public view returns(uint256);\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // included claimed amount\n', '    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    function getCurRoundId() public view returns(uint256);\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) public;\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n', '    function cashoutable(address _address) public view returns(bool);\n', '    function isLastRound() public view returns(bool);\n', '    function sBountyClaim(address _sBountyHunter) public returns(uint256);\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'interface BankInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    function pushToBank(address _player) public payable;\n', '}\n', '\n', 'interface NewTokenInterface {\n', '    function swapToken(uint256 _amount, address _invester) public payable;\n', '}\n', '\n', 'interface WhitelistInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // function getPremintAmount(address _address) public view returns(uint256);\n', '}']