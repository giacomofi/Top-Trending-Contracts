['// File: contracts/exchange/ownable.sol\n', '\n', 'pragma solidity 0.5.6;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/exchange/safe-math.sol\n', '\n', 'pragma solidity 0.5.6;\n', '\n', '/**\n', ' * @dev Math operations with safety checks that throw on error. This contract is based on the \n', ' * source code at: \n', ' * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\n', ' */\n', 'library SafeMath\n', '{\n', '\n', '  /**\n', '   * @dev Multiplies two numbers, reverts on overflow.\n', '   * @param _factor1 Factor number.\n', '   * @param _factor2 Factor number.\n', '   * @return The product of the two factors.\n', '   */\n', '  function mul(\n', '    uint256 _factor1,\n', '    uint256 _factor2\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 product)\n', '  {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_factor1 == 0)\n', '    {\n', '      return 0;\n', '    }\n', '\n', '    product = _factor1 * _factor2;\n', '    require(product / _factor1 == _factor2);\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\n', '   * @param _dividend Dividend number.\n', '   * @param _divisor Divisor number.\n', '   * @return The quotient.\n', '   */\n', '  function div(\n', '    uint256 _dividend,\n', '    uint256 _divisor\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 quotient)\n', '  {\n', '    // Solidity automatically asserts when dividing by 0, using all gas.\n', '    require(_divisor > 0);\n', '    quotient = _dividend / _divisor;\n', "    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\n", '  }\n', '\n', '  /**\n', '   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '   * @param _minuend Minuend number.\n', '   * @param _subtrahend Subtrahend number.\n', '   * @return Difference.\n', '   */\n', '  function sub(\n', '    uint256 _minuend,\n', '    uint256 _subtrahend\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 difference)\n', '  {\n', '    require(_subtrahend <= _minuend);\n', '    difference = _minuend - _subtrahend;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two numbers, reverts on overflow.\n', '   * @param _addend1 Number.\n', '   * @param _addend2 Number.\n', '   * @return Sum.\n', '   */\n', '  function add(\n', '    uint256 _addend1,\n', '    uint256 _addend2\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 sum)\n', '  {\n', '    sum = _addend1 + _addend2;\n', '    require(sum >= _addend1);\n', '  }\n', '\n', '  /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\n', '    * dividing by zero.\n', '    * @param _dividend Number.\n', '    * @param _divisor Number.\n', '    * @return Remainder.\n', '    */\n', '  function mod(\n', '    uint256 _dividend,\n', '    uint256 _divisor\n', '  )\n', '    internal\n', '    pure\n', '    returns (uint256 remainder) \n', '  {\n', '    require(_divisor != 0);\n', '    remainder = _dividend % _divisor;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/exchange/erc721-token-receiver.sol\n', '\n', 'pragma solidity 0.5.6;\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers. \n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721TokenReceiver\n', '{\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _operator The address which called `safeTransferFrom` function.\n', '   * @param _from The address which previously owned the token.\n', '   * @param _tokenId The NFT identifier which is being transferred.\n', '   * @param _data Additional data with no specified format.\n', '   * @return Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes calldata _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '\n', '\tfunction onERC721Received(\n', '    address _from, \n', '    uint256 _tokenId, \n', '    bytes calldata _data\n', '  ) \n', '  external \n', '  returns \n', '  (bytes4);\n', '\n', '}\n', '\n', '// File: contracts/exchange/ERC165Checker.sol\n', '\n', 'pragma solidity ^0.5.6;\n', '\n', '/**\n', ' * @title ERC165Checker\n', ' * @dev Use `using ERC165Checker for address`; to include this library\n', ' * https://eips.ethereum.org/EIPS/eip-165\n', ' */\n', 'library ERC165Checker {\n', '    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n', '    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /*\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', '     * @notice Query if a contract supports ERC165\n', '     * @param account The address of the contract to query for support of ERC165\n', '     * @return true if the contract at account implements ERC165\n', '     */\n', '    function _supportsERC165(address account) internal view returns (bool) {\n', '        // Any contract that implements ERC165 must explicitly indicate support of\n', '        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n', '        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\n', '            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n', '    }\n', '\n', '    /**\n', '     * @notice Query if a contract implements an interface, also checks support of ERC165\n', '     * @param account The address of the contract to query for support of an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @return true if the contract at account indicates support of the interface with\n', '     * identifier interfaceId, false otherwise\n', '     * @dev Interface identification is specified in ERC-165.\n', '     */\n', '    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n', '        // query support of both ERC165 as per the spec and support of _interfaceId\n', '        return _supportsERC165(account) &&\n', '            _supportsERC165Interface(account, interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @notice Query if a contract implements interfaces, also checks support of ERC165\n', '     * @param account The address of the contract to query for support of an interface\n', '     * @param interfaceIds A list of interface identifiers, as specified in ERC-165\n', '     * @return true if the contract at account indicates support all interfaces in the\n', '     * interfaceIds list, false otherwise\n', '     * @dev Interface identification is specified in ERC-165.\n', '     */\n', '    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n', '        // query support of ERC165 itself\n', '        if (!_supportsERC165(account)) {\n', '            return false;\n', '        }\n', '\n', '        // query support of each interface in _interfaceIds\n', '        for (uint256 i = 0; i < interfaceIds.length; i++) {\n', '            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        // all interfaces supported\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Query if a contract implements an interface, does not check ERC165 support\n', '     * @param account The address of the contract to query for support of an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @return true if the contract at account indicates support of the interface with\n', '     * identifier interfaceId, false otherwise\n', '     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n', '     * the behavior of this method is undefined. This precondition can be checked\n', '     * with the `supportsERC165` method in this library.\n', '     * Interface identification is specified in ERC-165.\n', '     */\n', '    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n', '        // success determines whether the staticcall succeeded and result determines\n', '        // whether the contract at account indicates support of _interfaceId\n', '        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\n', '\n', '        return (success && result);\n', '    }\n', '\n', '    /**\n', '     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\n', '     * @param account The address of the contract to query for support of an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @return success true if the STATICCALL succeeded, false otherwise\n', '     * @return result true if the STATICCALL succeeded and the contract at account\n', '     * indicates support of the interface with identifier interfaceId, false otherwise\n', '     */\n', '    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\n', '        private\n', '        view\n', '        returns (bool success, bool result)\n', '    {\n', '        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let encodedParams_data := add(0x20, encodedParams)\n', '            let encodedParams_size := mload(encodedParams)\n', '\n', '            let output := mload(0x40)    // Find empty storage location using "free memory pointer"\n', '            mstore(output, 0x0)\n', '\n', '            success := staticcall(\n', '                30000,                   // 30k gas\n', '                account,                 // To addr\n', '                encodedParams_data,\n', '                encodedParams_size,\n', '                output,\n', '                0x20                     // Outputs are 32 bytes long\n', '            )\n', '\n', '            result := mload(output)      // Load the result\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/exchange/exchange.sol\n', '\n', 'pragma solidity 0.5.6;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface to Interative with ERC-721 Contract.\n', ' */\n', 'contract Erc721Interface {\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '}\n', '\n', '/**\n', ' * @dev Interface to Interative with CryptoKitties Contract.\n', ' */\n', 'contract KittyInterface {\n', '    mapping (uint256 => address) public kittyIndexToApproved;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '}\n', '\n', '\n', 'contract Exchange is Ownable, ERC721TokenReceiver {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '    using ERC165Checker for address;\n', '\n', '    /**\n', '     * @dev CryptoKitties KittyCore Contract address.\n', '     */\n', '    address constant internal  CryptoKittiesAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n', '    \n', '    /**\n', '     * @dev Magic value of a smart contract that can recieve NFT.\n', '     * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '     */\n', '    bytes4 internal constant ERC721_RECEIVED_THREE_INPUT = 0xf0b9e5ba;\n', '\n', '    /**\n', '    * @dev Magic value of a smart contract that can recieve NFT.\n', '    * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '    */\n', '    bytes4 internal constant ERC721_RECEIVED_FOUR_INPUT = 0x150b7a02;\n', '\n', '    /**\n', '    * @dev A mapping from NFT ID to the owner address.\n', '    */\n', '    mapping (address => mapping (uint256 => address)) internal TokenToOwner;\n', '\n', '    /**\n', "    * @dev A mapping from owner address to specific contract address's all NFT IDs \n", '    */\n', '    mapping (address => mapping (address => uint256[])) internal OwnerToTokens;\n', '\n', '    /**\n', "    * @dev A mapping from specific contract address's NFT ID to its index in owner tokens array \n", '    */\n', '    mapping (address => mapping(uint256 => uint256)) internal TokenToIndex;\n', '\n', '    /**\n', '    * @dev A mapping from the address to all order it owns\n', '    */\n', '    mapping (address => bytes32[]) internal OwnerToOrders;\n', '\n', '    /**\n', '    * @dev A mapping from order to owner address\n', '    */\n', '    mapping (bytes32 => address) internal OrderToOwner;\n', '\n', '    /**\n', '    * @dev A mapping from order to its index in owner order array.\n', '    */\n', '    mapping (bytes32 => uint) internal OrderToIndex;\n', '\n', '    /**\n', '    * @dev A mapping from matchorder to owner address\n', '    */\n', '    mapping (bytes32 => address) internal MatchOrderToOwner;\n', '   \n', '    /**\n', '    * @dev A mapping from order to all matchorder it owns\n', '    */\n', '    mapping (bytes32 => bytes32[]) internal OrderToMatchOrders;\n', '\n', '    /**\n', "    * @dev A mapping from matchorder to its index in order's matchorder array\n", '    */\n', '    mapping (bytes32 => mapping(bytes32 => uint)) internal OrderToMatchOrderIndex;\n', '\n', '    /**\n', '    * @dev A mapping from order to confirm it exist or not\n', '    */\n', '    mapping (bytes32 => bool) internal OrderToExist;\n', '\n', '\n', '    /**\n', '    * @dev An array which contains all support NFT interface in Exchange\n', '    */\n', '    bytes4[] internal SupportNFTInterface;\n', '\n', '    /**\n', '    * @dev order and matchorder is equal to keccak256(contractAddress, tokenId, owner),\n', '    * because order is just a hash, so OrderObj is use to record details.\n', '    */\n', '    struct OrderObj {\n', "        // NFT's owner\n", '        address owner;\n', '\n', "        // NFT's contract address\n", '        address contractAddress;\n', '        \n', "        // NFT's id\n", '        uint256 tokenId;\n', '    }\n', '\n', '    /**\n', "    * @dev An mapping from order or matchorder's hash to it order obj\n", '    */\n', '    mapping (bytes32 => OrderObj) internal HashToOrderObj;\n', '\n', '    /**\n', '    * @dev This emits when someone called receiveErc721Token and success transfer NFT to \n', '    * exchange contract.\n', '    * @param _from Owner of NFT  \n', "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event ReceiveToken(\n', '        address indexed _from, \n', '        address _contractAddress, \n', '        uint256 _tokenId\n', '    );\n', '\n', '\n', '    /**\n', '    * @dev This emits when someone called SendBackToken and transfer NFT from\n', '    * exchange contract to it owner\n', '    * @param _owner Owner of NFT  \n', "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event SendBackToken(\n', '        address indexed _owner, \n', '        address _contractAddress, \n', '        uint256 _tokenId\n', '    );\n', '\n', '    /**\n', '    * @dev This emits when send NFT happened from exchange contract to other address\n', '    * @param _to exchange contract send address\n', "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event SendToken(\n', '        address indexed _to, \n', '        address _contractAddress, \n', '        uint256 _tokenId\n', '    );\n', '\n', '    /**\n', '    * @dev This emits when an OrderObj be created \n', "    * @param _hash order's hash\n", '    * @param _owner Owner of NFT  \n', "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event CreateOrderObj(\n', '        bytes32 indexed _hash,\n', '        address _owner,\n', '        address _contractAddress,\n', '        uint256 _tokenId   \n', '    );\n', '\n', '    /**\n', '    * @dev This emits when an order be created \n', "    * @param _from this order's owner\n", "    * @param _orderHash this order's hash\n", "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event CreateOrder(\n', '        address indexed _from,\n', '        bytes32 indexed _orderHash,\n', '        address _contractAddress,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    /**\n', '    * @dev This emits when an matchorder be created \n', "    * @param _from this order's owner\n", "    * @param _orderHash order's hash which matchorder pairing\n", "    * @param _matchOrderHash this matchorder's hash\n", "    * @param _contractAddress NFT's contract address\n", "    * @param _tokenId NFT's id\n", '    */\n', '    event CreateMatchOrder(\n', '        address indexed _from,\n', '        bytes32 indexed _orderHash,\n', '        bytes32 indexed _matchOrderHash,\n', '        address _contractAddress,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    /**\n', '    * @dev This emits when an order be deleted \n', "    * @param _from this order's owner\n", "    * @param _orderHash this order's hash\n", '    */\n', '    event DeleteOrder(\n', '        address indexed _from,\n', '        bytes32 indexed _orderHash\n', '    );\n', '\n', '    /**\n', '    * @dev This emits when an matchorder be deleted \n', "    * @param _from this matchorder's owner\n", '    * @param _orderHash order which matchorder pairing\n', '    * @param _matchOrderHash this matchorder\n', '    */\n', '    event DeleteMatchOrder(\n', '        address indexed _from,\n', '        bytes32 indexed _orderHash,\n', '        bytes32 indexed _matchOrderHash\n', '    );\n', '\n', '\n', '    /**\n', "    * @dev Function only be executed when massage sender is NFT's owner\n", "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", '    */\n', '    modifier onlySenderIsOriginalOwner(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    {\n', '        require(TokenToOwner[contractAddress][tokenId] == msg.sender, "original owner should be message sender");\n', '        _;\n', '    }\n', '\n', '    constructor () public {\n', '        //nf-token\n', '        SupportNFTInterface.push(0x80ac58cd);\n', '\n', '        //nf-token-metadata\n', '        SupportNFTInterface.push(0x780e9d63);\n', '\n', '        //nf-token-enumerable\n', '        SupportNFTInterface.push(0x5b5e139f);\n', '    }\n', '\n', '   /**\n', '   * @dev Add support NFT interface in Exchange\n', '   * @notice Only Exchange owner can do tihs\n', "   * @param interface_id Support NFT interface's interface_id\n", '   */\n', '    function addSupportNFTInterface(\n', '        bytes4 interface_id\n', '    )\n', '    external\n', '    onlyOwner()\n', '    {\n', '        SupportNFTInterface.push(interface_id);\n', '    }\n', '\n', '   /**\n', '   * @dev NFT contract will call when it use safeTransferFrom method\n', '   */\n', '    function onERC721Received(\n', '        address _from, \n', '        uint256 _tokenId, \n', '        bytes calldata _data\n', '    ) \n', '    external \n', '    returns (bytes4)\n', '    {\n', '        return ERC721_RECEIVED_THREE_INPUT;\n', '    }\n', '\n', '   /**\n', '   * @dev NFT contract will call when it use safeTransferFrom method\n', '   */\n', '    function onERC721Received(\n', '        address _operator,\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes calldata data\n', '    )\n', '    external\n', '    returns(bytes4)\n', '    {\n', '        return ERC721_RECEIVED_FOUR_INPUT;\n', '    }\n', '\n', '   /**\n', '   * @dev Create an order for your NFT and other people can pairing their NFT to exchange\n', '   * @notice You must call receiveErc721Token method first to send your NFT to exchange contract,\n', '   * if your NFT have matchorder pair with other order, then they will become Invalid until you\n', '   * delete this order.\n', "   * @param contractAddress NFT's contract address\n", "   * @param tokenId NFT's id\n", '   */\n', '    function createOrder(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    external \n', '    onlySenderIsOriginalOwner(\n', '        contractAddress, \n', '        tokenId\n', '    ) \n', '    {\n', '        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\n', '        require(OrderToOwner[orderHash] != msg.sender, "Order already exist");\n', '        _addOrder(msg.sender, orderHash);\n', '        emit CreateOrder(msg.sender, orderHash, contractAddress, tokenId);\n', '    }\n', '\n', '   /**\n', '   * @dev write order information to exchange contract.\n', "   * @param sender order's owner\n", "   * @param orderHash order's hash\n", '   */\n', '    function _addOrder(\n', '        address sender, \n', '        bytes32 orderHash\n', '    ) \n', '    internal \n', '    {\n', '        uint index = OwnerToOrders[sender].push(orderHash).sub(1);\n', '        OrderToOwner[orderHash] = sender;\n', '        OrderToIndex[orderHash] = index;\n', '        OrderToExist[orderHash] = true;\n', '    }\n', '\n', '   /**\n', "   * @dev Delete an order if you don't want exchange NFT to anyone, or you want get your NFT back.\n", "   * @param orderHash order's hash\n", '   */\n', '    function deleteOrder(\n', '        bytes32 orderHash\n', '    )\n', '    external\n', '    {\n', '        require(OrderToOwner[orderHash] == msg.sender, "this order hash not belongs to this address");\n', '        _removeOrder(msg.sender, orderHash);\n', '        emit DeleteOrder(msg.sender, orderHash);\n', '    }\n', '\n', '   /**\n', '   * @dev Remove order information on exchange contract \n', "   * @param sender order's owner\n", "   * @param orderHash order's hash\n", '   */\n', '    function _removeOrder(\n', '        address sender,\n', '        bytes32 orderHash\n', '    )\n', '    internal\n', '    {\n', '        OrderToExist[orderHash] = false;\n', '        delete OrderToOwner[orderHash];\n', '        uint256 orderIndex = OrderToIndex[orderHash];\n', '        uint256 lastOrderIndex = OwnerToOrders[sender].length.sub(1);\n', '        if (lastOrderIndex != orderIndex){\n', '            bytes32 lastOwnerOrder = OwnerToOrders[sender][lastOrderIndex];\n', '            OwnerToOrders[sender][orderIndex] = lastOwnerOrder;\n', '            OrderToIndex[lastOwnerOrder] = orderIndex;\n', '        }\n', '        OwnerToOrders[sender].length--;\n', '    }\n', '\n', '   /**\n', "   * @dev If your are interested in specfic order's NFT, create a matchorder and pair with it so order's owner\n", '   * can know and choose to exchange with you\n', '   * @notice You must call receiveErc721Token method first to send your NFT to exchange contract,\n', "   * if your NFT already create order, then you will be prohibit create matchorder until you delete this NFT's \n", '   * order.\n', "   * @param contractAddress NFT's contract address\n", "   * @param tokenId NFT's id\n", "   * @param orderHash order's hash which matchorder want to pair with \n", '   */\n', '    function createMatchOrder(\n', '        address contractAddress,\n', '        uint256 tokenId, \n', '        bytes32 orderHash\n', '    ) \n', '    external \n', '    onlySenderIsOriginalOwner(\n', '        contractAddress, \n', '        tokenId\n', '    ) \n', '    {\n', '        bytes32 matchOrderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\n', '        require(OrderToOwner[matchOrderHash] != msg.sender, "Order already exist");\n', '        _addMatchOrder(matchOrderHash, orderHash);\n', '        emit CreateMatchOrder(msg.sender, orderHash, matchOrderHash, contractAddress, tokenId);\n', '    }\n', '\n', '   /**\n', '   * @dev add matchorder information on exchange contract \n', "   * @param matchOrderHash matchorder's hash\n", "   * @param orderHash order's hash which matchorder pair with \n", '   */\n', '    function _addMatchOrder(\n', '        bytes32 matchOrderHash, \n', '        bytes32 orderHash\n', '    ) \n', '    internal \n', '    {\n', '        uint inOrderIndex = OrderToMatchOrders[orderHash].push(matchOrderHash).sub(1);\n', '        OrderToMatchOrderIndex[orderHash][matchOrderHash] = inOrderIndex;\n', '    }\n', '\n', '   /**\n', '   * @dev delete matchorder information on exchange contract \n', "   * @param matchOrderHash matchorder's hash\n", "   * @param orderHash order's hash which matchorder pair with \n", '   */\n', '    function deleteMatchOrder(\n', '        bytes32 matchOrderHash,\n', '        bytes32 orderHash\n', '    )\n', '    external\n', '    {\n', '        require(MatchOrderToOwner[matchOrderHash] == msg.sender, "match order doens\'t belong to this address" );\n', '        require(OrderToExist[orderHash] == true, "this order is not exist");\n', '        _removeMatchOrder(orderHash, matchOrderHash);\n', '        emit DeleteMatchOrder(msg.sender, orderHash, matchOrderHash);\n', '    }\n', '\n', '  /**\n', '   * @dev delete matchorder information on exchange contract \n', "   * @param orderHash order's hash which matchorder pair with \n", "   * @param matchOrderHash matchorder's hash\n", '   */\n', '    function _removeMatchOrder(\n', '        bytes32 orderHash,\n', '        bytes32 matchOrderHash\n', '    )\n', '    internal\n', '    {\n', '        uint256 matchOrderIndex = OrderToMatchOrderIndex[orderHash][matchOrderHash];\n', '        uint256 lastMatchOrderIndex = OrderToMatchOrders[orderHash].length.sub(1);\n', '        if (lastMatchOrderIndex != matchOrderIndex){\n', '            bytes32 lastMatchOrder = OrderToMatchOrders[orderHash][lastMatchOrderIndex];\n', '            OrderToMatchOrders[orderHash][matchOrderIndex] = lastMatchOrder;\n', '            OrderToMatchOrderIndex[orderHash][lastMatchOrder] = matchOrderIndex;\n', '        }\n', '        OrderToMatchOrders[orderHash].length--;\n', '    }\n', '\n', '    /**\n', "    * @dev order's owner can choose NFT to exchange from it's match order array, when function \n", '    * execute, order will be deleted, both NFT will be exchanged and send to corresponding address.\n', "    * @param order order's hash which matchorder pair with \n", "    * @param matchOrder matchorder's hash\n", '    */\n', '    function exchangeToken(\n', '        bytes32 order,\n', '        bytes32 matchOrder\n', '    ) \n', '    external \n', '    {\n', '        require(OrderToOwner[order] == msg.sender, "this order doesn\'t belongs to this address");\n', '        OrderObj memory orderObj = HashToOrderObj[order];\n', '        uint index = OrderToMatchOrderIndex[order][matchOrder];\n', '        require(OrderToMatchOrders[order][index] == matchOrder, "match order is not in this order");\n', '        require(OrderToExist[matchOrder] != true, "this match order\'s token have open order");\n', '        OrderObj memory matchOrderObj = HashToOrderObj[matchOrder];\n', '        _sendToken(matchOrderObj.owner, orderObj.contractAddress, orderObj.tokenId);\n', '        _sendToken(orderObj.owner, matchOrderObj.contractAddress, matchOrderObj.tokenId);\n', '        _removeMatchOrder(order, matchOrder);\n', '        _removeOrder(msg.sender, order);\n', '    }\n', '\n', '    /**\n', '    * @dev if you want to create order and matchorder on exchange contract, you must call this function\n', '    * to send your NFT to exchange contract, if your NFT is followed erc165 and erc721 standard, exchange\n', '    * contract will checked and execute sucessfully, then contract will record your information so you \n', "    * don't need worried about NFT lost.\n", "    * @notice because contract can't directly transfer your NFT, so you should call setApprovalForAll \n", '    * on NFT contract first, so this function can execute successfully.\n', "    * @param contractAddress NFT's Contract address\n", "    * @param tokenId NFT's id \n", '    */\n', '    function receiveErc721Token(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    external  \n', '    {\n', '        bool checkSupportErc165Interface = false;\n', '        if(contractAddress != CryptoKittiesAddress){\n', '            for(uint i = 0; i < SupportNFTInterface.length; i++){\n', '                if(contractAddress._supportsInterface(SupportNFTInterface[i]) == true){\n', '                    checkSupportErc165Interface = true;\n', '                }\n', '            }\n', '            require(checkSupportErc165Interface == true, "not supported Erc165 Interface");\n', '            Erc721Interface erc721Contract = Erc721Interface(contractAddress);\n', '            require(erc721Contract.isApprovedForAll(msg.sender,address(this)) == true, "contract doesn\'t have power to control this token id");\n', '            erc721Contract.transferFrom(msg.sender, address(this), tokenId);\n', '        }else {\n', '            KittyInterface kittyContract = KittyInterface(contractAddress);\n', '            require(kittyContract.kittyIndexToApproved(tokenId) == address(this), "contract doesn\'t have power to control this cryptoKitties\'s id");\n', '            kittyContract.transferFrom(msg.sender, address(this), tokenId);\n', '        }\n', '        _addToken(msg.sender, contractAddress, tokenId);\n', '        emit ReceiveToken(msg.sender, contractAddress, tokenId);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev add token and OrderObj information on exchange contract, because order hash and matchorder\n', '    * hash are same, so one NFT have mapping to one OrderObj\n', "    * @param sender NFT's owner\n", "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", '    */\n', '    function _addToken(\n', '        address sender, \n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    internal \n', '    {   \n', '        bytes32 matchOrderHash = keccak256(abi.encodePacked(contractAddress, tokenId, sender));\n', '        MatchOrderToOwner[matchOrderHash] = sender;\n', '        HashToOrderObj[matchOrderHash] = OrderObj(sender,contractAddress,tokenId);\n', '        TokenToOwner[contractAddress][tokenId] = sender;\n', '        uint index = OwnerToTokens[sender][contractAddress].push(tokenId).sub(1);\n', '        TokenToIndex[contractAddress][tokenId] = index;\n', '        emit CreateOrderObj(matchOrderHash, sender, contractAddress, tokenId);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev send your NFT back to address which you send token in, if your NFT still have open order,\n', '    * then order will be deleted\n', '    * @notice matchorder will not be deleted because cost too high, but they will be useless and other\n', "    * people can't choose your match order to exchange\n", "    * @param contractAddress NFT's Contract address\n", "    * @param tokenId NFT's id \n", '    */\n', '    function sendBackToken(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    external \n', '    onlySenderIsOriginalOwner(\n', '        contractAddress, \n', '        tokenId\n', '    ) \n', '    {\n', '        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\n', '        if(OrderToExist[orderHash] == true) {\n', '            _removeOrder(msg.sender, orderHash);\n', '        }\n', '        _sendToken(msg.sender, contractAddress, tokenId);\n', '        emit SendBackToken(msg.sender, contractAddress, tokenId);\n', '    }  \n', '\n', '\n', '    /**\n', '    * @dev Drive NFT contract to send NFT to corresponding address\n', '    * @notice because cryptokittes contract method are not the same as general NFT contract, so \n', '    * need treat it individually\n', "    * @param sendAddress NFT's owner\n", "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", '    */\n', '    function _sendToken(\n', '        address sendAddress,\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    )\n', '    internal\n', '    {   \n', '        if(contractAddress != CryptoKittiesAddress){\n', '            Erc721Interface erc721Contract = Erc721Interface(contractAddress);\n', '            require(erc721Contract.ownerOf(tokenId) == address(this), "exchange contract should have this token");\n', '            erc721Contract.transferFrom(address(this), sendAddress, tokenId);\n', '        }else{\n', '            KittyInterface kittyContract = KittyInterface(contractAddress);\n', '            require(kittyContract.ownerOf(tokenId) == address(this), "exchange contract should have this token");\n', '            kittyContract.transfer(sendAddress, tokenId);\n', '        }\n', '        _removeToken(contractAddress, tokenId);\n', '        emit SendToken(sendAddress, contractAddress, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev remove token and OrderObj information on exchange contract\n', "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", '    */\n', '    function _removeToken(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    internal \n', '    {\n', '        address owner = TokenToOwner[contractAddress][tokenId];\n', '        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, owner));\n', '        delete HashToOrderObj[orderHash];\n', '        delete MatchOrderToOwner[orderHash];\n', '        delete TokenToOwner[contractAddress][tokenId];\n', '        uint256 tokenIndex = TokenToIndex[contractAddress][tokenId];\n', '        uint256 lastOwnerTokenIndex = OwnerToTokens[owner][contractAddress].length.sub(1);\n', '        if (lastOwnerTokenIndex != tokenIndex){\n', '            uint256 lastOwnerToken = OwnerToTokens[owner][contractAddress][lastOwnerTokenIndex];\n', '            OwnerToTokens[owner][contractAddress][tokenIndex] = lastOwnerToken;\n', '            TokenToIndex[contractAddress][lastOwnerToken] = tokenIndex;\n', '        }\n', '        OwnerToTokens[owner][contractAddress].length--;\n', '    }\n', '\n', '    /**\n', '    * @dev get NFT owner address\n', "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", '    * @return NFT owner address\n', '    */\n', '    function getTokenOwner(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    external \n', '    view \n', '    returns (address)\n', '    {\n', '        return TokenToOwner[contractAddress][tokenId];\n', '    }\n', '    \n', '    /**\n', "    * @dev get owner's specfic contract address's all NFT array \n", '    * @param ownerAddress owner address\n', "    * @param contractAddress  NFT's contract address\n", "    * @return NFT's array\n", '    */\n', '    function getOwnerTokens(\n', '        address ownerAddress, \n', '        address contractAddress\n', '    ) \n', '    external \n', '    view \n', '    returns (uint256[] memory)\n', '    {\n', '        return OwnerToTokens[ownerAddress][contractAddress];\n', '    }\n', '\n', '    /**\n', "    * @dev get NFT's index in owner NFT's array \n", "    * @param contractAddress NFT's contract address\n", "    * @param tokenId NFT's id\n", "    * @return NFT's index\n", '    */\n', '    function getTokenIndex(\n', '        address contractAddress, \n', '        uint256 tokenId\n', '    ) \n', '    external \n', '    view\n', '    returns (uint256)\n', '    {\n', '        return TokenToIndex[contractAddress][tokenId];\n', '    }\n', '\n', '    /**\n', "    * @dev get owner address's all orders\n", '    * @param ownerAddress owner address\n', '    * @return orders array\n', '    */\n', '    function getOwnerOrders(\n', '        address ownerAddress\n', '    ) \n', '    external \n', '    view \n', '    returns (bytes32[] memory){\n', '        return OwnerToOrders[ownerAddress];\n', '    }\n', '\n', '    /**\n', "    * @dev get specfit order's owner address\n", "    * @param order order's hash\n", "    * @return order's owner address\n", '    */\n', '    function getOrderOwner(\n', '        bytes32 order\n', '    ) \n', '    external \n', '    view \n', '    returns (address)\n', '    {\n', '        return OrderToOwner[order];\n', '    }\n', '\n', '    /**\n', "    * @dev get order's index in owner orders array\n", "    * @param order order's hash\n", "    * @return order's index\n", '    */\n', '    function getOrderIndex(\n', '        bytes32 order\n', '    ) \n', '    external \n', '    view \n', '    returns (uint)\n', '    {\n', '        return OrderToIndex[order];\n', '    }\n', '\n', '    /**\n', '    * @dev get order exist or not in exchange contract\n', "    * @param order order's hash\n", '    * @return boolean to express order exist \n', '    */\n', '    function getOrderExist(\n', '        bytes32 order\n', '    )\n', '    external\n', '    view\n', '    returns (bool){\n', '        return OrderToExist[order];\n', '    }\n', '\n', '    /**\n', "    * @dev get specfit matchorder's owner address\n", "    * @param matchOrder matchorder's hash\n", "    * @return matchorder's owner address\n", '    */\n', '    function getMatchOrderOwner(\n', '        bytes32 matchOrder\n', '    ) \n', '    external \n', '    view \n', '    returns (address)\n', '    {\n', '        return MatchOrderToOwner[matchOrder];\n', '    }\n', '\n', '    /**\n', "    * @dev get matchorder's index in NFT order's matchorders array\n", "    * @param order matchorder's hash\n", "    * @return matchorder's index\n", '    */\n', '    function getOrderMatchOrderIndex(\n', '        bytes32 order,\n', '        bytes32 matchOrder\n', '    ) \n', '    external \n', '    view \n', '    returns (uint)\n', '    {\n', '        return OrderToMatchOrderIndex[order][matchOrder];\n', '    }\n', '\n', '    /**\n', "    * @dev get order's matchorder array\n", "    * @param order order's hash\n", '    * @return matchorder array\n', '    */\n', '    function getOrderMatchOrders(\n', '        bytes32 order\n', '    ) \n', '    external \n', '    view \n', '    returns (bytes32[] memory)\n', '    {\n', '        return OrderToMatchOrders[order];\n', '    }\n', '\n', '    /**\n', "    * @dev get mapping from order or matchorder's hash to OrderObj\n", "    * @param hashOrder order or matchorder's hash\n", '    * @return OrderObj\n', '    */\n', '    function getHashOrderObj(\n', '        bytes32 hashOrder\n', '    )\n', '    external\n', '    view\n', '    returns(\n', '        address, \n', '        address, \n', '        uint256\n', '    )\n', '    {\n', '        OrderObj memory orderObj = HashToOrderObj[hashOrder];\n', '        return(\n', '            orderObj.owner,\n', '            orderObj.contractAddress,\n', '            orderObj.tokenId\n', '        );\n', '    }\n', '}']