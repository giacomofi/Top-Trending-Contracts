['pragma solidity 0.4.25;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function decimals() public view returns (uint256);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/*\n', '    Modified Util contract as used by Kyber Network\n', '*/\n', '\n', 'library Utils {\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\n', '    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '    uint256 constant internal MAX_UINT = 2**256-1;\n', '\n', "    // Currently constants can't be accessed from other contracts, so providing functions to do that here\n", '    function precision() internal pure returns (uint256) { return PRECISION; }\n', '    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\n', '    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\n', '    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\n', '    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\n', '    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\n', '\n', '    /// @notice Retrieve the number of decimals used for a given ERC20 token\n', '    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\n', "    /// ensure that an exception doesn't cause transaction failure\n", '    /// @param token the token for which we should retrieve the decimals\n', '    /// @return decimals the number of decimals in the given token\n', '    function getDecimals(address token)\n', '        internal\n', '        view\n', '        returns (uint256 decimals)\n', '    {\n', '        bytes4 functionSig = bytes4(keccak256("decimals()"));\n', '\n', '        /// @dev Using assembly due to issues with current solidity `address.call()`\n', '        /// implementation: https://github.com/ethereum/solidity/issues/2884\n', '        assembly {\n', '            // Pointer to next free memory slot\n', '            let ptr := mload(0x40)\n', '            // Store functionSig variable at ptr\n', '            mstore(ptr,functionSig)\n', '            let functionSigLength := 0x04\n', '            let wordLength := 0x20\n', '\n', '            let success := call(\n', '                                5000, // Amount of gas\n', '                                token, // Address to call\n', '                                0, // ether to send\n', '                                ptr, // ptr to input data\n', '                                functionSigLength, // size of data\n', '                                ptr, // where to store output data (overwrite input)\n', '                                wordLength // size of output data (32 bytes)\n', '                               )\n', '\n', '            switch success\n', '            case 0 {\n', "                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\n", '            }\n', '            case 1 {\n', '                decimals := mload(ptr) // Set decimals to return data from call\n', '            }\n', '            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\n', '        }\n', '    }\n', '\n', '    /// @dev Checks that a given address has its token allowance and balance set above the given amount\n', '    /// @param tokenOwner the address which should have custody of the token\n', '    /// @param tokenAddress the address of the token to check\n', '    /// @param tokenAmount the amount of the token which should be set\n', '    /// @param addressToAllow the address which should be allowed to transfer the token\n', '    /// @return bool true if the allowance and balance is set, false if not\n', '    function tokenAllowanceAndBalanceSet(\n', '        address tokenOwner,\n', '        address tokenAddress,\n', '        uint256 tokenAmount,\n', '        address addressToAllow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\n', '            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\n', '        );\n', '    }\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint numerator;\n', '        uint denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns (uint) {\n', '        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns (uint) {\n', '        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n', '        internal pure returns (uint)\n', '    {\n', '        require(srcAmount <= MAX_QTY);\n', '        require(destAmount <= MAX_QTY);\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n', '        }\n', '    }\n', '\n', "    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\n", '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'library ERC20SafeTransfer {\n', '    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transfer(address,uint256)")), _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("approve(address,uint256)")), _spender, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function fetchReturnData() internal returns (bool success){\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 {\n', '                success := 1\n', '            }\n', '            case 32 {\n', '                returndatacopy(0, 0, 32)\n', '                success := mload(0)\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title A contract which is used to check and set allowances of tokens\n', '/// @dev In order to use this contract is must be inherited in the contract which is using\n', '/// its functionality\n', 'contract AllowanceSetter {\n', '    uint256 constant MAX_UINT = 2**256 - 1;\n', '\n', '    /// @notice A function which allows the caller to approve the max amount of any given token\n', '    /// @dev In order to function correctly, token allowances should not be set anywhere else in\n', '    /// the inheriting contract\n', '    /// @param addressToApprove the address which we want to approve to transfer the token\n', '    /// @param token the token address which we want to call approve on\n', '    function approveAddress(address addressToApprove, address token) internal {\n', '        if(ERC20(token).allowance(address(this), addressToApprove) == 0) {\n', '            require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract ErrorReporter {\n', '    function revertTx(string reason) public pure {\n', '        revert(reason);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/// @title A contract which can be used to ensure only the TotlePrimary contract can call\n', '/// some functions\n', '/// @dev Defines a modifier which should be used when only the totle contract should\n', '/// able able to call a function\n', 'contract TotleControl is Ownable {\n', '    mapping(address => bool) public authorizedPrimaries;\n', '\n', '    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\n', '    modifier onlyTotle() {\n', '        require(authorizedPrimaries[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /// @notice Contract constructor\n', '    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    constructor(address _totlePrimary) public {\n', '        authorizedPrimaries[_totlePrimary] = true;\n', '    }\n', '\n', '    /// @notice A function which allows only the owner to change the address of totlePrimary\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    function addTotle(\n', '        address _totlePrimary\n', '    ) external onlyOwner {\n', '        authorizedPrimaries[_totlePrimary] = true;\n', '    }\n', '\n', '    function removeTotle(\n', '        address _totlePrimary\n', '    ) external onlyOwner {\n', '        authorizedPrimaries[_totlePrimary] = false;\n', '    }\n', '}\n', '\n', '/// @title A contract which allows its owner to withdraw any ether which is contained inside\n', 'contract Withdrawable is Ownable {\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _token The address of the token that the user wants to withdraw\n', '    /// @param _amount The amount of tokens that the caller wants to withdraw\n', '    /// @return bool value indicating whether the transfer was successful\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\n', '        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\n', '    }\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _amount The amount of ether that the caller wants to withdraw\n', '    function withdrawETH(uint256 _amount) external onlyOwner {\n', '        owner.transfer(_amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool private _paused = false;\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "Contract is paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "Contract not paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    _paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    _paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', 'contract SelectorProvider {\n', '    bytes4 constant getAmountToGiveSelector = bytes4(keccak256("getAmountToGive(bytes)"));\n', '    bytes4 constant staticExchangeChecksSelector = bytes4(keccak256("staticExchangeChecks(bytes)"));\n', '    bytes4 constant performBuyOrderSelector = bytes4(keccak256("performBuyOrder(bytes,uint256)"));\n', '    bytes4 constant performSellOrderSelector = bytes4(keccak256("performSellOrder(bytes,uint256)"));\n', '\n', '    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\n', '}\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'contract ExchangeHandler is SelectorProvider, TotleControl, Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    ErrorReporter public errorReporter;\n', '    /* Logger public logger; */\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    /// @notice Constructor\n', '    /// @dev Calls the constructor of the inherited TotleControl\n', '    /// @param totlePrimary the address of the totlePrimary contract\n', '    constructor(\n', '        address totlePrimary,\n', '        address _errorReporter\n', '        /* ,address _logger */\n', '    )\n', '        TotleControl(totlePrimary)\n', '        public\n', '    {\n', '        require(_errorReporter != address(0x0));\n', '        /* require(_logger != address(0x0)); */\n', '        errorReporter = ErrorReporter(_errorReporter);\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /// @notice Gets the amount that Totle needs to give for this order\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return amountToGive amount taker needs to give in order to fill the order\n', '    function getAmountToGive(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 amountToGive)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.getAmountToGive.selector);\n', '\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            amountToGive := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform exchange-specific checks on the given order\n', '    /// @dev this should be called to check for payload errors\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return checksPassed value representing pass or fail\n', '    function staticExchangeChecks(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        returns (bool checksPassed)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.staticExchangeChecks.selector);\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            checksPassed := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a buy order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performBuyOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        payable\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.performBuyOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a sell order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performSellOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.performSellOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '}\n', '\n', 'interface EtherDelta {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 amount) external;\n', '    function depositToken(address token, uint256 amount) external;\n', '    function withdrawToken(address token, uint256 amount) external;\n', '    function trade(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s, uint256 amount) external;\n', '    function availableVolume(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s) external view returns (uint256);\n', '}\n', '\n', '/// @title EtherDeltaHandler\n', '/// @notice Handles the all EtherDelta trades for the primary contract\n', 'contract EtherDeltaHandler is ExchangeHandler, AllowanceSetter {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    EtherDelta public exchange;\n', '\n', '    /*\n', '    *   Types\n', '    */\n', '\n', '    struct OrderData {\n', '        address user;\n', '        address tokenGive;\n', '        address tokenGet;\n', '        uint256 amountGive;\n', '        uint256 amountGet;\n', '        uint256 expires;\n', '        uint256 nonce;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint256 exchangeFee;\n', '    }\n', '\n', '    /// @notice Constructor\n', '    /// @param _exchange Address of the EtherDelta exchange\n', '    /// @param totlePrimary the address of the totlePrimary contract\n', '    /// @param errorReporter the address of the error reporter contract\n', '    constructor(\n', '        address _exchange,\n', '        address totlePrimary,\n', '        address errorReporter\n', '        /* ,address logger */\n', '    )\n', '        ExchangeHandler(totlePrimary, errorReporter/*, logger*/)\n', '        public\n', '    {\n', '        require(_exchange != address(0x0));\n', '        exchange = EtherDelta(_exchange);\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    /// @notice Gets the amount that Totle needs to give for this order\n', '    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\n', '    /// should only be called from functions which are inherited from the ExchangeHandler\n', '    /// base contract\n', '    /// @param data OrderData struct containing order values\n', '    /// @return amountToGive amount taker needs to give in order to fill the order\n', '    function getAmountToGive(\n', '        OrderData data\n', '    )\n', '        public\n', '        view\n', '        onlyTotle\n', '        returns (uint256 amountToGive)\n', '    {\n', '        uint256 availableVolume = exchange.availableVolume(\n', '            data.tokenGet,\n', '            data.amountGet,\n', '            data.tokenGive,\n', '            data.amountGive,\n', '            data.expires,\n', '            data.nonce,\n', '            data.user,\n', '            data.v,\n', '            data.r,\n', '            data.s\n', '        );\n', '        /* logger.log("Getting available volume from Etherdelta", availableVolume); */\n', '        // Adds the exchange fee onto the available amount\n', '        amountToGive = SafeMath.add(SafeMath.mul(availableVolume, data.exchangeFee), availableVolume);\n', '\n', '        /* logger.log("Removing fee from amountToGive", amountToGive); */\n', '    }\n', '\n', '    /// @notice Perform exchange-specific checks on the given order\n', '    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\n', '    /// should only be called from functions which are inherited from the ExchangeHandler\n', '    /// base contract.\n', '    /// This should be called to check for payload errors.\n', '    /// @param data OrderData struct containing order values\n', '    /// @return checksPassed value representing pass or fail\n', '    function staticExchangeChecks(\n', '        OrderData data\n', '    )\n', '        public\n', '        view\n', '        onlyTotle\n', '        returns (bool checksPassed)\n', '    {\n', '        /* logger.log(block.number <= data.expires ? "Order isn\'t expired" : "Order is expired"); */\n', '        // Only one thing to check here\n', '        return block.number <= data.expires; // TODO - check if this is < or <=\n', '    }\n', '\n', '    /// @notice Perform a buy order at the exchange\n', '    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\n', '    /// should only be called from functions which are inherited from the ExchangeHandler\n', '    /// base contract\n', '    /// @param data OrderData struct containing order values\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performBuyOrder(\n', '        OrderData data,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        payable\n', '        onlyTotle\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        if (msg.value != amountToGiveForOrder) {\n', '            errorReporter.revertTx("msg.value != amountToGiveForOrder");\n', '        }\n', '        /* logger.log("Depositing eth to Etherdelta arg2: amountToGive, arg3: ethBalance", amountToGiveForOrder, address(this).balance); */\n', '        exchange.deposit.value(amountToGiveForOrder)();\n', '\n', '        uint256 amountToTrade;\n', '        uint256 fee;\n', '\n', '        (amountToTrade, fee) = substractFee(data.exchangeFee, amountToGiveForOrder);\n', '        /* logger.log("Removing fee from amountToGiveForOrder arg2: amountToGiveForOrder, arg3: amountToTrade, arg4: fee", amountToGiveForOrder, amountToTrade, fee); */\n', '        trade(data, amountToTrade);\n', '\n', '        amountSpentOnOrder = amountToGiveForOrder;\n', '        amountReceivedFromOrder = getPartialAmount(data.amountGive, data.amountGet, amountToTrade);\n', '        /* logger.log("Withdrawing tokens from EtherDelta arg2: amountReceivedFromOrder, arg3: amountSpentOnOrder", amountReceivedFromOrder, amountSpentOnOrder); */\n', '        exchange.withdrawToken(data.tokenGive, amountReceivedFromOrder);\n', '\n', '        if (!ERC20SafeTransfer.safeTransfer(data.tokenGive, msg.sender, amountReceivedFromOrder)) {\n', '            errorReporter.revertTx("Unable to transfer bought tokens to primary");\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a sell order at the exchange\n', '    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\n', '    /// should only be called from functions which are inherited from the ExchangeHandler\n', '    /// base contract\n', '    /// @param data OrderData struct containing order values\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performSellOrder(\n', '        OrderData data,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        onlyTotle\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        approveAddress(address(exchange), data.tokenGet);\n', '        /* logger.log("Depositing tokens to EtherDelta arg2: amountToGiveForOrder", amountToGiveForOrder); */\n', '        exchange.depositToken(data.tokenGet, amountToGiveForOrder);\n', '\n', '        uint256 amountToTrade;\n', '        uint256 fee;\n', '\n', '        (amountToTrade, fee) = substractFee(data.exchangeFee, amountToGiveForOrder);\n', '        /* logger.log("arg2: amountToTrade, arg3: fee", amountToTrade, fee); */\n', '\n', '        trade(data, amountToTrade);\n', '\n', '        amountSpentOnOrder = amountToGiveForOrder;\n', '        amountReceivedFromOrder = getPartialAmount(data.amountGive, data.amountGet, amountToTrade);\n', '\n', '        exchange.withdraw(amountReceivedFromOrder);\n', '        /* logger.log("Withdrawing ether arg2: amountReceived", amountReceivedFromOrder); */\n', '        msg.sender.transfer(amountReceivedFromOrder);\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '    /// @notice Performs the trade at the exchange\n', '    /// @dev It was necessary to separate this into a function due to limited stack space\n', '    /// @param data OrderData struct containing order values\n', '    /// @param amountToTrade amount that should be spent on this order\n', '    function trade(\n', '        OrderData data,\n', '        uint256 amountToTrade\n', '    )\n', '        internal\n', '    {\n', '        exchange.trade(\n', '            data.tokenGet,\n', '            data.amountGet,\n', '            data.tokenGive,\n', '            data.amountGive,\n', '            data.expires,\n', '            data.nonce,\n', '            data.user,\n', '            data.v,\n', '            data.r,\n', '            data.s,\n', '            amountToTrade\n', '        );\n', '    }\n', '\n', '    /// @notice Subtract fee percentage from the amount give\n', '    /// @param feePercentage the percentage fee to deduct\n', '    /// @param  amount the amount that we should deduct from\n', '    /// @return amountMinusFee the amount that would be spent on the order\n', '    /// @return fee the amount that was received from this order\n', '    function substractFee(\n', '        uint256 feePercentage,\n', '        uint256 amount\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256 amountMinusFee, uint256 fee)\n', '    {\n', '        fee = SafeMath.sub(amount, getPartialAmount(amount, SafeMath.add(feePercentage, 1 ether), 1 ether ));\n', '        amountMinusFee = SafeMath.sub(amount, fee);\n', '    }\n', '\n', '    /// @notice Calculate the result of ((numerator * target) / denominator)\n', '    /// @param numerator the numerator in the equation\n', '    /// @param denominator the denominator in the equation\n', '    /// @param target the target for the equations\n', '    /// @return partialAmount the resultant value\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\n', '    }\n', '\n', '    function getSelector(bytes4 genericSelector) public pure returns (bytes4) {\n', '        if (genericSelector == getAmountToGiveSelector) {\n', '            return bytes4(keccak256("getAmountToGive((address,address,address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32,uint256))"));\n', '        } else if (genericSelector == staticExchangeChecksSelector) {\n', '            return bytes4(keccak256("staticExchangeChecks((address,address,address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32,uint256))"));\n', '        } else if (genericSelector == performBuyOrderSelector) {\n', '            return bytes4(keccak256("performBuyOrder((address,address,address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32,uint256),uint256)"));\n', '        } else if (genericSelector == performSellOrderSelector) {\n', '            return bytes4(keccak256("performSellOrder((address,address,address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32,uint256),uint256)"));\n', '        } else {\n', '            return bytes4(0x0);\n', '        }\n', '    }\n', '\n', '    /*\n', '    *   Payable fallback function\n', '    */\n', '\n', '    /// @notice payable fallback to allow the exchange to return ether directly to this contract\n', '    /// @dev note that only the exchange should be able to send ether to this contract\n', '    function() public payable {\n', '        if (msg.sender != address(exchange)) {\n', '            errorReporter.revertTx("An address other than the exchange cannot send ether to EDHandler fallback");\n', '        }\n', '    }\n', '}']