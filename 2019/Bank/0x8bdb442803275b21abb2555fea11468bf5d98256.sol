['pragma solidity >=0.5.0;\n', '\n', 'library UintSafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BMToken\n', '{\n', '    function allowance(address src, address where) public pure returns (uint256);\n', '    function transferFrom(address src, address where, uint amount) public returns (bool);\n', '    function transfer(address where, uint amount) external returns (bool);\n', '}\n', '\n', 'contract BMT_Exchange {\n', '    using UintSafeMath for uint256;\n', '\n', '    BMToken contractTokens;\n', '    address payable public owner;\n', '\n', '    uint256 public tokenPrice;\n', '    uint256 public totalSupplay;\n', '    uint256 public ethPart;\n', '\n', '    mapping(address => uint256) public Holders;\n', '    mapping(address => uint256) public lastAccess;\n', '    uint256 lastUpdate;\n', '\n', '    uint256 constant distributionInterval = 5 days;\n', '\n', '    constructor() public {\n', '        contractTokens = BMToken(0xf028ADEe51533b1B47BEaa890fEb54a457f51E89);\n', '\n', '        owner = msg.sender;\n', '\n', '        tokenPrice = 0.0000765 ether;\n', '        totalSupplay = 0;\n', '        ethPart = 0 ether;\n', '    }\n', '\n', '    modifier isOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address payable new_owner) isOwner public {\n', '        assert(new_owner != owner);\n', '        assert(new_owner != address(0x0));\n', '\n', '        owner = new_owner;\n', '    }\n', '\n', '    // DO NOT SEND TOKENS TO CONTRACT - USE "APPROVE" FUNCTION\n', '    function transferTokens(uint256 _value) isOwner public{\n', '        contractTokens.transfer(owner, _value);\n', '    }\n', '\n', '    function setTokenPrice(uint256 new_price) isOwner public {\n', '        assert(new_price > 0);\n', '\n', '        tokenPrice = new_price;\n', '    }\n', '\n', '    function updateHolder(address[] calldata _holders, uint256[] calldata _amounts) isOwner external {\n', '        assert(_holders.length == _amounts.length);\n', '\n', '        for(uint256 i = 0; i < _holders.length; i++){\n', '            Holders[_holders[i]] = Holders[_holders[i]].add(_amounts[i]);\n', '            totalSupplay = totalSupplay.add(_amounts[i]);\n', '        }\n', '\n', '        updateTokenDistribution();\n', '    }\n', '\n', '    function deposit() isOwner payable public {\n', '        assert(msg.value > 0);\n', '        updateTokenDistribution();\n', '    }\n', '\n', '    function withdraw(uint256 amount) isOwner public {\n', '        assert(address(this).balance >= amount);\n', '\n', '        address(owner).transfer(amount);\n', '        updateTokenDistribution();\n', '\n', '    }\n', '    function updateTokenDistribution() internal {\n', '        if (totalSupplay > 0) {\n', '            ethPart = address(this).balance.mul(10**18).div(totalSupplay);\n', '            lastUpdate = now;\n', '        }\n', '    }\n', '\n', '    function secondsLeft(address addr) view public returns (uint256) {\n', '        if (now < lastAccess[addr]) return 0;\n', '        return now - lastAccess[addr];\n', '    }\n', '\n', '    function calculateAmounts(address addr) view public returns (uint256 tokenAmount, uint256 ethReturn) {\n', '        assert(Holders[addr] > 0);\n', '        assert(now - lastAccess[addr] > distributionInterval);\n', '\n', '        tokenAmount = ethPart.mul(Holders[addr]).div(tokenPrice).div(10**18).mul(10**18); // +round\n', '        assert(tokenAmount > 0);\n', '        assert(contractTokens.allowance(addr, address(this)) >= tokenAmount);\n', '        ethReturn = tokenAmount.mul(tokenPrice).div(10**18);\n', '    }\n', '\n', '    function () external {\n', '        if (now - lastUpdate > distributionInterval) updateTokenDistribution();\n', '        assert(tx.origin == msg.sender);\n', '\n', '        assert(Holders[msg.sender] > 0);\n', '        assert(now - lastAccess[msg.sender] > distributionInterval);\n', '\n', '        uint256 tokenAmount;\n', '        uint256 ethReturn;\n', '        (tokenAmount, ethReturn) = calculateAmounts(msg.sender);\n', '\n', '        contractTokens.transferFrom(msg.sender, owner, tokenAmount);\n', '        msg.sender.transfer(ethReturn);\n', '\n', '        Holders[msg.sender] = Holders[msg.sender].sub(tokenAmount);\n', '        totalSupplay = totalSupplay.sub(tokenAmount);\n', '        lastAccess[msg.sender] = now;\n', '    }\n', '}']