['pragma solidity 0.4.24;\n', '\n', 'contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n', '}\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "DSAuth::_ SENDER_NOT_AUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract Proxy {\n', '\n', '    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n', '    address masterCopy;\n', '\n', '    /// @dev Constructor function sets address of master copy contract.\n', '    /// @param _masterCopy Master copy address.\n', '    constructor(address _masterCopy)\n', '        public\n', '    {\n', '        require(_masterCopy != 0, "Invalid master copy address provided");\n', '        masterCopy = _masterCopy;\n', '    }\n', '\n', '    /// @dev Fallback function forwards all transactions and returns all received return data.\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n', '            calldatacopy(0, 0, calldatasize())\n', '            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\n', '            returndatacopy(0, 0, returndatasize())\n', '            if eq(success, 0) { revert(0, returndatasize()) }\n', '            return(0, returndatasize())\n', '        }\n', '    }\n', '\n', '    function implementation()\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return masterCopy;\n', '    }\n', '\n', '    function proxyType()\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2;\n', '    }\n', '}\n', '\n', '\n', 'contract ErrorUtils {\n', '\n', '    event LogError(string methodSig, string errMsg);\n', '    event LogErrorWithHintBytes32(bytes32 indexed bytes32Value, string methodSig, string errMsg);\n', '    event LogErrorWithHintAddress(address indexed addressValue, string methodSig, string errMsg);\n', '\n', '}\n', '\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    // custom : not in original DSMath, putting it here for consistency, copied from SafeMath\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract SelfAuthorized {\n', '    modifier authorized() {\n', '        require(msg.sender == address(this), "Method can only be called from this contract");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract Utils {\n', '\n', '    modifier addressValid(address _address) {\n', '        require(_address != address(0), "Utils::_ INVALID_ADDRESS");\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event  Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event  Deposit(address indexed _owner, uint _value);\n', '    event  Withdrawal(address indexed _owner, uint _value);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() public payable {\n', '        deposit();\n', '    }\n', '\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract DateTime {\n', '    /*\n', '        *  Date and Time utilities for ethereum contracts\n', '        *\n', '        */\n', '    struct _DateTime {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 minute;\n', '        uint8 second;\n', '        uint8 weekday;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint constant HOUR_IN_SECONDS = 3600;\n', '    uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) public pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '            return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '            return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) public pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '            return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '            return 29;\n', '        }\n', '        else {\n', '            return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        // Year\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        // Day\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '\n', '        // Hour\n', '        dt.hour = getHour(timestamp);\n', '\n', '        // Minute\n', '        dt.minute = getMinute(timestamp);\n', '\n', '        // Second\n', '        dt.second = getSecond(timestamp);\n', '\n', '        // Day of week.\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        // Year\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '            if (isLeapYear(uint16(year - 1))) {\n', '                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            }\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function getHour(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60 / 60) % 24);\n', '    }\n', '\n', '    function getMinute(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / 60) % 60);\n', '    }\n', '\n', '    function getSecond(uint timestamp) public pure returns (uint8) {\n', '        return uint8(timestamp % 60);\n', '    }\n', '\n', '    function getWeekday(uint timestamp) public pure returns (uint8) {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '        uint16 i;\n', '\n', '        // Year\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '            if (isLeapYear(i)) {\n', '                timestamp += LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                timestamp += YEAR_IN_SECONDS;\n', '            }\n', '        }\n', '\n', '        // Month\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '            monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '            monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        // Day\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '        // Hour\n', '        timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '        // Minute\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '        // Second\n', '        timestamp += second;\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '\n', '    function name() external view returns(string);\n', '    function symbol() external view returns(string);\n', '    function decimals() external view returns(uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract MasterCopy is SelfAuthorized {\n', '  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n', '  // It should also always be ensured that the address is stored alone (uses a full word)\n', '    address masterCopy;\n', '\n', '  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\n', '  /// @param _masterCopy New contract address.\n', '    function changeMasterCopy(address _masterCopy)\n', '        public\n', '        authorized\n', '    {\n', '        // Master copy address cannot be null.\n', '        require(_masterCopy != 0, "Invalid master copy address provided");\n', '        masterCopy = _masterCopy;\n', '    }\n', '}\n', '\n', '\n', 'contract Config is DSNote, DSAuth, Utils {\n', '\n', '    WETH9 public weth9;\n', '    mapping (address => bool) public isAccountHandler;\n', '    mapping (address => bool) public isAdmin;\n', '    address[] public admins;\n', '    bool public disableAdminControl = false;\n', '    \n', '    event LogAdminAdded(address indexed _admin, address _by);\n', '    event LogAdminRemoved(address indexed _admin, address _by);\n', '\n', '    constructor() public {\n', '        admins.push(msg.sender);\n', '        isAdmin[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyAdmin(){\n', '        require(isAdmin[msg.sender], "Config::_ SENDER_NOT_AUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    function setWETH9\n', '    (\n', '        address _weth9\n', '    ) \n', '        public\n', '        auth\n', '        note\n', '        addressValid(_weth9) \n', '    {\n', '        weth9 = WETH9(_weth9);\n', '    }\n', '\n', '    function setAccountHandler\n', '    (\n', '        address _accountHandler,\n', '        bool _isAccountHandler\n', '    )\n', '        public\n', '        auth\n', '        note\n', '        addressValid(_accountHandler)\n', '    {\n', '        isAccountHandler[_accountHandler] = _isAccountHandler;\n', '    }\n', '\n', '    function toggleAdminsControl() \n', '        public\n', '        auth\n', '        note\n', '    {\n', '        disableAdminControl = !disableAdminControl;\n', '    }\n', '\n', '    function isAdminValid(address _admin)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        if(disableAdminControl) {\n', '            return true;\n', '        } else {\n', '            return isAdmin[_admin];\n', '        }\n', '    }\n', '\n', '    function getAllAdmins()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return admins;\n', '    }\n', '\n', '    function addAdmin\n', '    (\n', '        address _admin\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_admin)\n', '    {   \n', '        require(!isAdmin[_admin], "Config::addAdmin ADMIN_ALREADY_EXISTS");\n', '\n', '        admins.push(_admin);\n', '        isAdmin[_admin] = true;\n', '\n', '        emit LogAdminAdded(_admin, msg.sender);\n', '    }\n', '\n', '    function removeAdmin\n', '    (\n', '        address _admin\n', '    ) \n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_admin)\n', '    {   \n', '        require(isAdmin[_admin], "Config::removeAdmin ADMIN_DOES_NOT_EXIST");\n', '        require(msg.sender != _admin, "Config::removeAdmin ADMIN_NOT_AUTHORIZED");\n', '\n', '        isAdmin[_admin] = false;\n', '\n', '        for (uint i = 0; i < admins.length - 1; i++) {\n', '            if (admins[i] == _admin) {\n', '                admins[i] = admins[admins.length - 1];\n', '                admins.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '\n', '        emit LogAdminRemoved(_admin, msg.sender);\n', '    }\n', '}\n', '\n', '\n', 'library ECRecovery {\n', '\n', '    function recover(bytes32 _hash, bytes _sig)\n', '        internal\n', '        pure\n', '    returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (_sig.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        assembly {\n', '            r := mload(add(_sig, 32))\n', '            s := mload(add(_sig, 64))\n', '            v := byte(0, mload(add(_sig, 96)))\n', '        }\n', '\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            return ecrecover(_hash, v, r, s);\n', '        }\n', '    }\n', '\n', '    function toEthSignedMessageHash(bytes32 _hash)\n', '        internal\n', '        pure\n', '    returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)\n', '        );\n', '    }\n', '}\n', '\n', '\n', 'contract Utils2 {\n', '    using ECRecovery for bytes32;\n', '    \n', '    function _recoverSigner(bytes32 _hash, bytes _signature) \n', '        internal\n', '        pure\n', '        returns(address _signer)\n', '    {\n', '        return _hash.toEthSignedMessageHash().recover(_signature);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract DSThing is DSNote, DSAuth, DSMath {\n', '\n', '    function S(string s) internal pure returns (bytes4) {\n', '        return bytes4(keccak256(s));\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract DSStop is DSNote, DSAuth {\n', '\n', '    bool public stopped = false;\n', '\n', '    modifier whenNotStopped {\n', '        require(!stopped, "DSStop::_ FEATURE_STOPPED");\n', '        _;\n', '    }\n', '\n', '    modifier whenStopped {\n', '        require(stopped, "DSStop::_ FEATURE_NOT_STOPPED");\n', '        _;\n', '    }\n', '\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Account is MasterCopy, DSNote, Utils, Utils2, ErrorUtils {\n', '\n', '    address[] public users;\n', '    mapping (address => bool) public isUser;\n', '    mapping (bytes32 => bool) public actionCompleted;\n', '\n', '    WETH9 public weth9;\n', '    Config public config;\n', '    bool public isInitialized = false;\n', '\n', '    event LogTransferBySystem(address indexed token, address indexed to, uint value, address by);\n', '    event LogTransferByUser(address indexed token, address indexed to, uint value, address by);\n', '    event LogUserAdded(address indexed user, address by);\n', '    event LogUserRemoved(address indexed user, address by);\n', '    event LogImplChanged(address indexed newImpl, address indexed oldImpl);\n', '\n', '    modifier initialized() {\n', '        require(isInitialized, "Account::_ ACCOUNT_NOT_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier notInitialized() {\n', '        require(!isInitialized, "Account::_ ACCOUNT_ALREADY_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier userExists(address _user) {\n', '        require(isUser[_user], "Account::_ INVALID_USER");\n', '        _;\n', '    }\n', '\n', '    modifier userDoesNotExist(address _user) {\n', '        require(!isUser[_user], "Account::_ USER_DOES_NOT_EXISTS");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(config.isAdminValid(msg.sender), "Account::_ INVALID_ADMIN_ACCOUNT");\n', '        _;\n', '    }\n', '\n', '    modifier onlyHandler(){\n', '        require(config.isAccountHandler(msg.sender), "Account::_ INVALID_ACC_HANDLER");\n', '        _;\n', '    }\n', '\n', '    function init(address _user, address _config)\n', '        public \n', '        notInitialized\n', '    {\n', '        users.push(_user);\n', '        isUser[_user] = true;\n', '        config = Config(_config);\n', '        weth9 = config.weth9();\n', '        isInitialized = true;\n', '    }\n', '    \n', '    function getAllUsers() public view returns (address[]) {\n', '        return users;\n', '    }\n', '\n', '    function balanceFor(address _token) public view returns (uint _balance){\n', '        _balance = ERC20(_token).balanceOf(this);\n', '    }\n', '    \n', '    function transferBySystem\n', '    (   \n', '        address _token,\n', '        address _to,\n', '        uint _value\n', '    ) \n', '        external \n', '        onlyHandler\n', '        note \n', '        initialized\n', '    {\n', '        require(ERC20(_token).balanceOf(this) >= _value, "Account::transferBySystem INSUFFICIENT_BALANCE_IN_ACCOUNT");\n', '        ERC20(_token).transfer(_to, _value);\n', '\n', '        emit LogTransferBySystem(_token, _to, _value, msg.sender);\n', '    }\n', '    \n', '    function transferByUser\n', '    (   \n', '        address _token,\n', '        address _to,\n', '        uint _value,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external\n', '        addressValid(_to)\n', '        note\n', '        initialized\n', '        onlyAdmin\n', '    {\n', '        bytes32 actionHash = _getTransferActionHash(_token, _to, _value, _salt);\n', '\n', '        if(actionCompleted[actionHash]) {\n', '            emit LogError("Account::transferByUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(_token).balanceOf(this) < _value){\n', '            emit LogError("Account::transferByUser", "INSUFFICIENT_BALANCE_IN_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::transferByUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '        \n', '        if (_token == address(weth9)) {\n', '            weth9.withdraw(_value);\n', '            _to.transfer(_value);\n', '        } else {\n', '            require(ERC20(_token).transfer(_to, _value), "Account::transferByUser TOKEN_TRANSFER_FAILED");\n', '        }\n', '\n', '        emit LogTransferByUser(_token, _to, _value, signer);\n', '    }\n', '\n', '    function addUser\n', '    (\n', '        address _user,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external \n', '        note \n', '        addressValid(_user)\n', '        userDoesNotExist(_user)\n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_user, "ADD_USER", _salt);\n', '        if(actionCompleted[actionHash])\n', '        {\n', '            emit LogError("Account::addUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::addUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '\n', '        users.push(_user);\n', '        isUser[_user] = true;\n', '\n', '        emit LogUserAdded(_user, signer);\n', '    }\n', '\n', '    function removeUser\n', '    (\n', '        address _user,\n', '        uint _salt,\n', '        bytes _signature\n', '    ) \n', '        external\n', '        note\n', '        userExists(_user) \n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_user, "REMOVE_USER", _salt);\n', '\n', '        if(actionCompleted[actionHash]) {\n', '            emit LogError("Account::removeUser", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '        \n', '        if(users.length == 1){\n', '            emit LogError("Account::removeUser",  "ACC_SHOULD_HAVE_ATLEAST_ONE_USER");\n', '            return;\n', '        }\n', '        \n', '        if(!isUser[signer]){\n', '            emit LogError("Account::removeUser", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '        \n', '        actionCompleted[actionHash] = true;\n', '\n', '        // should delete value from isUser map? delete isUser[_user]?\n', '        isUser[_user] = false;\n', '        for (uint i = 0; i < users.length - 1; i++) {\n', '            if (users[i] == _user) {\n', '                users[i] = users[users.length - 1];\n', '                users.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '\n', '        emit LogUserRemoved(_user, signer);\n', '    }\n', '\n', '    function _getTransferActionHash\n', '    ( \n', '        address _token,\n', '        address _to,\n', '        uint _value,\n', '        uint _salt\n', '    ) \n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _token,\n', '                _to,\n', '                _value,\n', '                _salt\n', '            )\n', '        );\n', '    }\n', '\n', '    function _getUserActionHash\n', '    ( \n', '        address _user,\n', '        string _action,\n', '        uint _salt\n', '    ) \n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _user,\n', '                _action,\n', '                _salt\n', '            )\n', '        );\n', '    }\n', '\n', '    // to directly send ether to contract\n', '    function() external payable {\n', '        require(msg.data.length == 0 && msg.value > 0, "Account::fallback INVALID_ETHER_TRANSFER");\n', '\n', '        if(msg.sender != address(weth9)){\n', '            weth9.deposit.value(msg.value)();\n', '        }\n', '    }\n', '\n', '    function changeImpl\n', '    (\n', '        address _to,\n', '        uint _salt,\n', '        bytes _signature\n', '    )\n', '        external \n', '        note \n', '        addressValid(_to)\n', '        initialized\n', '        onlyAdmin\n', '    {   \n', '        bytes32 actionHash = _getUserActionHash(_to, "CHANGE_ACCOUNT_IMPLEMENTATION", _salt);\n', '        if(actionCompleted[actionHash])\n', '        {\n', '            emit LogError("Account::changeImpl", "ACTION_ALREADY_PERFORMED");\n', '            return;\n', '        }\n', '\n', '        address signer = _recoverSigner(actionHash, _signature);\n', '\n', '        if(!isUser[signer]) {\n', '            emit LogError("Account::changeImpl", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        actionCompleted[actionHash] = true;\n', '\n', '        address oldImpl = masterCopy;\n', '        this.changeMasterCopy(_to);\n', '        \n', '        emit LogImplChanged(_to, oldImpl);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract AccountFactory is DSStop, Utils {\n', '    Config public config;\n', '    mapping (address => bool) public isAccount;\n', '    mapping (address => address[]) public userToAccounts;\n', '    address[] public accounts;\n', '\n', '    address public accountMaster;\n', '\n', '    constructor\n', '    (\n', '        Config _config, \n', '        address _accountMaster\n', '    ) \n', '    public \n', '    {\n', '        config = _config;\n', '        accountMaster = _accountMaster;\n', '    }\n', '\n', '    event LogAccountCreated(address indexed user, address indexed account, address by);\n', '\n', '    modifier onlyAdmin() {\n', '        require(config.isAdminValid(msg.sender), "AccountFactory::_ INVALID_ADMIN_ACCOUNT");\n', '        _;\n', '    }\n', '\n', '    function setConfig(Config _config) external note auth addressValid(_config) {\n', '        config = _config;\n', '    }\n', '\n', '    function setAccountMaster(address _accountMaster) external note auth addressValid(_accountMaster) {\n', '        accountMaster = _accountMaster;\n', '    }\n', '\n', '    function newAccount(address _user)\n', '        public\n', '        note\n', '        onlyAdmin\n', '        addressValid(config)\n', '        addressValid(accountMaster)\n', '        whenNotStopped\n', '        returns \n', '        (\n', '            Account _account\n', '        ) \n', '    {\n', '        address proxy = new Proxy(accountMaster);\n', '        _account = Account(proxy);\n', '        _account.init(_user, config);\n', '\n', '        accounts.push(_account);\n', '        userToAccounts[_user].push(_account);\n', '        isAccount[_account] = true;\n', '\n', '        emit LogAccountCreated(_user, _account, msg.sender);\n', '    }\n', '    \n', '    function batchNewAccount(address[] _users) public note onlyAdmin {\n', '        for (uint i = 0; i < _users.length; i++) {\n', '            newAccount(_users[i]);\n', '        }\n', '    }\n', '\n', '    function getAllAccounts() public view returns (address[]) {\n', '        return accounts;\n', '    }\n', '\n', '    function getAccountsForUser(address _user) public view returns (address[]) {\n', '        return userToAccounts[_user];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Escrow is DSNote, DSAuth {\n', '\n', '    event LogTransfer(address indexed token, address indexed to, uint value);\n', '    event LogTransferFromAccount(address indexed account, address indexed token, address indexed to, uint value);\n', '\n', '    function transfer\n', '    (\n', '        address _token,\n', '        address _to,\n', '        uint _value\n', '    )\n', '        public\n', '        note\n', '        auth\n', '    {\n', '        require(ERC20(_token).transfer(_to, _value), "Escrow::transfer TOKEN_TRANSFER_FAILED");\n', '        emit LogTransfer(_token, _to, _value);\n', '    }\n', '\n', '    function transferFromAccount\n', '    (\n', '        address _account,\n', '        address _token,\n', '        address _to,\n', '        uint _value\n', '    )\n', '        public\n', '        note\n', '        auth\n', '    {   \n', '        Account(_account).transferBySystem(_token, _to, _value);\n', '        emit LogTransferFromAccount(_account, _token, _to, _value);\n', '    }\n', '\n', '}\n', '\n', '// issue with deploying multiple instances of same type in truffle, hence the following two contracts\n', 'contract KernelEscrow is Escrow {\n', '\n', '}\n', '\n', 'contract ReserveEscrow is Escrow {\n', '    \n', '}\n', '\n', '\n', 'contract Reserve is DSStop, DSThing, Utils, Utils2, ErrorUtils {\n', '\n', '    Escrow public escrow;\n', '    AccountFactory public accountFactory;\n', '    DateTime public dateTime;\n', '    Config public config;\n', '    uint public deployTimestamp;\n', '\n', '    string constant public VERSION = "1.0.0";\n', '\n', '    uint public TIME_INTERVAL = 1 days;\n', '    //uint public TIME_INTERVAL = 1 hours;\n', '    \n', '    constructor\n', '    (\n', '        Escrow _escrow,\n', '        AccountFactory _accountFactory,\n', '        DateTime _dateTime,\n', '        Config _config\n', '    ) \n', '    public \n', '    {\n', '        escrow = _escrow;\n', '        accountFactory = _accountFactory;\n', '        dateTime = _dateTime;\n', '        config = _config;\n', '        deployTimestamp = now - (4 * TIME_INTERVAL);\n', '    }\n', '\n', '    function setEscrow(Escrow _escrow) \n', '        public \n', '        note \n', '        auth\n', '        addressValid(_escrow)\n', '    {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setAccountFactory(AccountFactory _accountFactory) \n', '        public \n', '        note \n', '        auth\n', '        addressValid(_accountFactory)\n', '    {\n', '        accountFactory = _accountFactory;\n', '    }\n', '\n', '    function setDateTime(DateTime _dateTime) \n', '        public \n', '        note \n', '        auth\n', '        addressValid(_dateTime)\n', '    {\n', '        dateTime = _dateTime;\n', '    }\n', '\n', '    function setConfig(Config _config) \n', '        public \n', '        note \n', '        auth\n', '        addressValid(_config)\n', '    {\n', '        config = _config;\n', '    }\n', '\n', '    struct Order {\n', '        address account;\n', '        address token;\n', '        address byUser;\n', '        uint value;\n', '        uint duration;\n', '        uint expirationTimestamp;\n', '        uint salt;\n', '        uint createdTimestamp;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    bytes32[] public orders;\n', '    mapping (bytes32 => Order) public hashToOrder;\n', '    mapping (bytes32 => bool) public isOrder;\n', '    mapping (address => bytes32[]) public accountToOrders;\n', '    mapping (bytes32 => bool) public cancelledOrders;\n', '\n', '    // per day\n', '    mapping (uint => mapping(address => uint)) public deposits;\n', '    mapping (uint => mapping(address => uint)) public withdrawals;\n', '    mapping (uint => mapping(address => uint)) public profits;\n', '    mapping (uint => mapping(address => uint)) public losses;\n', '\n', '    mapping (uint => mapping(address => uint)) public reserves;\n', '    mapping (address => uint) public lastReserveRuns;\n', '\n', '    mapping (address => mapping(address => uint)) public surplus;\n', '\n', '    mapping (bytes32 => CumulativeRun) public orderToCumulative;\n', '\n', '    struct CumulativeRun {\n', '        uint timestamp;\n', '        uint value;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(config.isAdminValid(msg.sender), "Reserve::_ INVALID_ADMIN_ACCOUNT");\n', '        _;\n', '    }\n', '\n', '    event LogOrderCreated(\n', '        bytes32 indexed orderHash,\n', '        address indexed account,\n', '        address indexed token,\n', '        address byUser,\n', '        uint value,\n', '        uint expirationTimestamp\n', '    );\n', '\n', '    event LogOrderCancelled(\n', '        bytes32 indexed orderHash,\n', '        address indexed by\n', '    );\n', '\n', '    event LogReserveValuesUpdated(\n', '        address indexed token, \n', '        uint indexed updatedTill,\n', '        uint reserve,\n', '        uint profit,\n', '        uint loss\n', '    );\n', '\n', '    event LogOrderCumulativeUpdated(\n', '        bytes32 indexed orderHash,\n', '        uint updatedTill,\n', '        uint value\n', '    );\n', '\n', '    event LogRelease(\n', '        address indexed token,\n', '        address indexed to,\n', '        uint value,\n', '        address by\n', '    );\n', '\n', '    event LogLock(\n', '        address indexed token,\n', '        address indexed from,\n', '        uint value,\n', '        uint profit,\n', '        uint loss,\n', '        address by\n', '    );\n', '\n', '    event LogLockSurplus(\n', '        address indexed forToken, \n', '        address indexed token,\n', '        address from,\n', '        uint value\n', '    );\n', '\n', '    event LogTransferSurplus(\n', '        address indexed forToken,\n', '        address indexed token,\n', '        address to, \n', '        uint value\n', '    );\n', '    \n', '    function createOrder\n', '    (\n', '        address[3] _orderAddresses,\n', '        uint[3] _orderValues,\n', '        bytes _signature\n', '    ) \n', '        public\n', '        note\n', '        onlyAdmin\n', '        whenNotStopped\n', '    {\n', '        Order memory order = _composeOrder(_orderAddresses, _orderValues);\n', '        address signer = _recoverSigner(order.orderHash, _signature);\n', '\n', '        if(signer != order.byUser){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "SIGNER_NOT_ORDER_CREATOR");\n', '            return;\n', '        }\n', '        \n', '        if(isOrder[order.orderHash]){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "ORDER_ALREADY_EXISTS");\n', '            return;\n', '        }\n', '\n', '        if(!accountFactory.isAccount(order.account)){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "INVALID_ORDER_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        if(!Account(order.account).isUser(signer)){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '                \n', '        if(!_isOrderValid(order)) {\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "INVALID_ORDER_PARAMETERS");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.token).balanceOf(order.account) < order.value){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::createOrder", "INSUFFICIENT_BALANCE_IN_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        escrow.transferFromAccount(order.account, order.token, address(escrow), order.value);\n', '        \n', '        orders.push(order.orderHash);\n', '        hashToOrder[order.orderHash] = order;\n', '        isOrder[order.orderHash] = true;\n', '        accountToOrders[order.account].push(order.orderHash);\n', '\n', '        uint dateTimestamp = _getDateTimestamp(now);\n', '\n', '        deposits[dateTimestamp][order.token] = add(deposits[dateTimestamp][order.token], order.value);\n', '        \n', '        orderToCumulative[order.orderHash].timestamp = _getDateTimestamp(order.createdTimestamp);\n', '        orderToCumulative[order.orderHash].value = order.value;\n', '\n', '        emit LogOrderCreated(\n', '            order.orderHash,\n', '            order.account,\n', '            order.token,\n', '            order.byUser,\n', '            order.value,\n', '            order.expirationTimestamp\n', '        );\n', '    }\n', '\n', '    function cancelOrder\n', '    (\n', '        bytes32 _orderHash,\n', '        bytes _signature\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '    {   \n', '        if(!isOrder[_orderHash]) {\n', '            emit LogErrorWithHintBytes32(_orderHash,"Reserve::createOrder", "ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(cancelledOrders[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash,"Reserve::createOrder", "ORDER_ALREADY_CANCELLED");\n', '            return;\n', '        }\n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '\n', '        bytes32 cancelOrderHash = _generateActionOrderHash(_orderHash, "CANCEL_RESERVE_ORDER");\n', '        address signer = _recoverSigner(cancelOrderHash, _signature);\n', '        \n', '        if(!Account(order.account).isUser(signer)){\n', '            emit LogErrorWithHintBytes32(_orderHash,"Reserve::createOrder", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '        \n', '        doCancelOrder(order);\n', '    }\n', '    \n', '    function processOrder\n', '    (\n', '        bytes32 _orderHash\n', '    ) \n', '        external \n', '        note\n', '        onlyAdmin\n', '    {\n', '        if(!isOrder[_orderHash]) {\n', '            emit LogErrorWithHintBytes32(_orderHash,"Reserve::processOrder", "ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(cancelledOrders[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash,"Reserve::processOrder", "ORDER_ALREADY_CANCELLED");\n', '            return;\n', '        }\n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '\n', '        if(now > _getDateTimestamp(order.expirationTimestamp)) {\n', '            doCancelOrder(order);\n', '        } else {\n', '            emit LogErrorWithHintBytes32(order.orderHash, "Reserve::processOrder", "ORDER_NOT_EXPIRED");\n', '        }\n', '    }\n', '\n', '    function doCancelOrder(Order _order) \n', '        internal\n', '    {   \n', '        uint valueToTransfer = orderToCumulative[_order.orderHash].value;\n', '\n', '        if(ERC20(_order.token).balanceOf(escrow) < valueToTransfer){\n', '            emit LogErrorWithHintBytes32(_order.orderHash, "Reserve::doCancel", "INSUFFICIENT_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        uint nowDateTimestamp = _getDateTimestamp(now);\n', '        cancelledOrders[_order.orderHash] = true;\n', '        withdrawals[nowDateTimestamp][_order.token] = add(withdrawals[nowDateTimestamp][_order.token], valueToTransfer);\n', '\n', '        escrow.transfer(_order.token, _order.account, valueToTransfer);\n', '        emit LogOrderCancelled(_order.orderHash, msg.sender);\n', '    }\n', '\n', '    function release(address _token, address _to, uint _value) \n', '        external\n', '        note\n', '        auth\n', '    {   \n', '        require(ERC20(_token).balanceOf(escrow) >= _value, "Reserve::release INSUFFICIENT_BALANCE_IN_ESCROW");\n', '        escrow.transfer(_token, _to, _value);\n', '        emit LogRelease(_token, _to, _value, msg.sender);\n', '    }\n', '\n', '    // _value includes profit/loss as well\n', '    function lock(address _token, address _from, uint _value, uint _profit, uint _loss)\n', '        external\n', '        note\n', '        auth\n', '    {   \n', '        require(!(_profit == 0 && _loss == 0), "Reserve::lock INVALID_PROFIT_LOSS_VALUES");\n', '        require(ERC20(_token).balanceOf(_from) >= _value, "Reserve::lock INSUFFICIENT_BALANCE");\n', '            \n', '        if(accountFactory.isAccount(_from)) {\n', '            escrow.transferFromAccount(_from, _token, address(escrow), _value);\n', '        } else {\n', '            Escrow(_from).transfer(_token, address(escrow), _value);\n', '        }\n', '        \n', '        uint dateTimestamp = _getDateTimestamp(now);\n', '\n', '        if (_profit > 0){\n', '            profits[dateTimestamp][_token] = add(profits[dateTimestamp][_token], _profit);\n', '        } else if (_loss > 0) {\n', '            losses[dateTimestamp][_token] = add(losses[dateTimestamp][_token], _loss);\n', '        }\n', '\n', '        emit LogLock(_token, _from, _value, _profit, _loss, msg.sender);\n', '    }\n', '\n', '    // to lock collateral if cannot be liquidated e.g. not enough reserves in kyber\n', '    function lockSurplus(address _from, address _forToken, address _token, uint _value) \n', '        external\n', '        note\n', '        auth\n', '    {\n', '        require(ERC20(_token).balanceOf(_from) >= _value, "Reserve::lockSurplus INSUFFICIENT_BALANCE_IN_ESCROW");\n', '\n', '        Escrow(_from).transfer(_token, address(escrow), _value);\n', '        surplus[_forToken][_token] = add(surplus[_forToken][_token], _value);\n', '\n', '        emit LogLockSurplus(_forToken, _token, _from, _value);\n', '    }\n', '\n', '    // to transfer surplus collateral out of the system to trade on other platforms and put back in terms of \n', '    // principal to reserve manually using an account or surplus escrow\n', '    // should work in tandem with lock method when transferring back principal\n', '    function transferSurplus(address _to, address _forToken, address _token, uint _value) \n', '        external\n', '        note\n', '        auth\n', '    {\n', '        require(ERC20(_token).balanceOf(escrow) >= _value, "Reserve::transferSurplus INSUFFICIENT_BALANCE_IN_ESCROW");\n', '        require(surplus[_forToken][_token] >= _value, "Reserve::transferSurplus INSUFFICIENT_SURPLUS");\n', '\n', '        surplus[_forToken][_token] = sub(surplus[_forToken][_token], _value);\n', '        escrow.transfer(_token, _to, _value);\n', '\n', '        emit LogTransferSurplus(_forToken, _token, _to, _value);\n', '    }\n', '\n', '    function updateReserveValues(address _token, uint _forDays)\n', '        public\n', '        note\n', '        onlyAdmin\n', '    {   \n', '        uint lastReserveRun = lastReserveRuns[_token];\n', '\n', '        if (lastReserveRun == 0) {\n', '            lastReserveRun = _getDateTimestamp(deployTimestamp) - TIME_INTERVAL;\n', '        }\n', '\n', '        uint nowDateTimestamp = _getDateTimestamp(now);\n', '        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastReserveRun) / TIME_INTERVAL;\n', '\n', '        if(updatesLeft == 0) {\n', '            emit LogErrorWithHintAddress(_token, "Reserve::updateReserveValues", "RESERVE_VALUES_UP_TO_DATE");\n', '            return;\n', '        }\n', '\n', '        uint counter = updatesLeft;\n', '\n', '        if(updatesLeft > _forDays && _forDays > 0) {\n', '            counter = _forDays;\n', '        }\n', '\n', '        for (uint i = 0; i < counter; i++) {\n', '            reserves[lastReserveRun + TIME_INTERVAL][_token] = sub(\n', '                sub(\n', '                    add(\n', '                        add(\n', '                            reserves[lastReserveRun][_token],\n', '                            deposits[lastReserveRun + TIME_INTERVAL][_token]\n', '                        ),\n', '                        profits[lastReserveRun + TIME_INTERVAL][_token]\n', '                    ),\n', '                    losses[lastReserveRun + TIME_INTERVAL][_token]\n', '                ),\n', '                withdrawals[lastReserveRun + TIME_INTERVAL][_token]\n', '            );\n', '            lastReserveRuns[_token] = lastReserveRun + TIME_INTERVAL;\n', '            lastReserveRun = lastReserveRuns[_token];\n', '            \n', '            emit LogReserveValuesUpdated(\n', '                _token,\n', '                lastReserveRun,\n', '                reserves[lastReserveRun][_token],\n', '                profits[lastReserveRun][_token],\n', '                losses[lastReserveRun][_token]\n', '            );\n', '            \n', '        }\n', '    }\n', '\n', '    function updateOrderCumulativeValueBatch(bytes32[] _orderHashes, uint[] _forDays) \n', '        public\n', '        note\n', '        onlyAdmin\n', '    {   \n', '        if(_orderHashes.length != _forDays.length) {\n', '            emit LogError("Reserve::updateOrderCumulativeValueBatch", "ARGS_ARRAYLENGTH_MISMATCH");\n', '            return;\n', '        }\n', '\n', '        for(uint i = 0; i < _orderHashes.length; i++) {\n', '            updateOrderCumulativeValue(_orderHashes[i], _forDays[i]);\n', '        }\n', '    }\n', '\n', '    function updateOrderCumulativeValue\n', '    (\n', '        bytes32 _orderHash, \n', '        uint _forDays\n', '    ) \n', '        public\n', '        note\n', '        onlyAdmin \n', '    {\n', '        if(!isOrder[_orderHash]) {\n', '            emit LogErrorWithHintBytes32(_orderHash, "Reserve::updateOrderCumulativeValue", "ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(cancelledOrders[_orderHash]) {\n', '            emit LogErrorWithHintBytes32(_orderHash, "Reserve::updateOrderCumulativeValue", "ORDER_ALREADY_CANCELLED");\n', '            return;\n', '        }\n', '        \n', '        Order memory order = hashToOrder[_orderHash];\n', '        CumulativeRun storage cumulativeRun = orderToCumulative[_orderHash];\n', '        \n', '        uint profitsAccrued = 0;\n', '        uint lossesAccrued = 0;\n', '        uint cumulativeValue = 0;\n', '        uint counter = 0;\n', '\n', '        uint lastOrderRun = cumulativeRun.timestamp;\n', '        uint nowDateTimestamp = _getDateTimestamp(now);\n', '\n', '        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastOrderRun) / TIME_INTERVAL;\n', '\n', '        if(updatesLeft == 0) {\n', '            emit LogErrorWithHintBytes32(_orderHash, "Reserve::updateOrderCumulativeValue", "ORDER_VALUES_UP_TO_DATE");\n', '            return;\n', '        }\n', '\n', '        counter = updatesLeft;\n', '\n', '        if(updatesLeft > _forDays && _forDays > 0) {\n', '            counter = _forDays;\n', '        }\n', '\n', '        for (uint i = 0; i < counter; i++){\n', '            cumulativeValue = cumulativeRun.value;\n', '            lastOrderRun = cumulativeRun.timestamp;\n', '\n', '            if(lastReserveRuns[order.token] < lastOrderRun) {\n', '                emit LogErrorWithHintBytes32(_orderHash, "Reserve::updateOrderCumulativeValue", "RESERVE_VALUES_NOT_UPDATED");\n', '                emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\n', '                return;\n', '            }\n', '\n', '            profitsAccrued = div(\n', '                mul(profits[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\n', '                reserves[lastOrderRun][order.token]\n', '            );\n', '                \n', '            lossesAccrued = div(\n', '                mul(losses[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\n', '                reserves[lastOrderRun][order.token]\n', '            );\n', '\n', '            cumulativeValue = sub(add(cumulativeValue, profitsAccrued), lossesAccrued);\n', '\n', '            cumulativeRun.timestamp = lastOrderRun + TIME_INTERVAL;\n', '            cumulativeRun.value = cumulativeValue;\n', '        }\n', '        \n', '        emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\n', '    }\n', '\n', '    function getAllOrders() \n', '        public\n', '        view \n', '        returns \n', '        (\n', '            bytes32[]\n', '        ) \n', '    {\n', '        return orders;\n', '    }\n', '\n', '    function getOrdersForAccount(address _account) \n', '        public\n', '        view \n', '        returns \n', '        (\n', '            bytes32[]\n', '        )\n', '    {\n', '        return accountToOrders[_account];\n', '    }\n', '\n', '    function getOrder(bytes32 _orderHash)\n', '        public \n', '        view \n', '        returns \n', '        (\n', '            address _account,\n', '            address _token,\n', '            address _byUser,\n', '            uint _value,\n', '            uint _expirationTimestamp,\n', '            uint _salt,\n', '            uint _createdTimestamp\n', '        )\n', '    {   \n', '        Order memory order = hashToOrder[_orderHash];\n', '        return (\n', '            order.account,\n', '            order.token,\n', '            order.byUser,\n', '            order.value,\n', '            order.expirationTimestamp,\n', '            order.salt,\n', '            order.createdTimestamp\n', '        );\n', '    }\n', '\n', '    function _isOrderValid(Order _order)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if(_order.account == address(0) || _order.byUser == address(0)\n', '         || _order.value <= 0\n', '         || _order.expirationTimestamp <= _order.createdTimestamp || _order.salt <= 0) {\n', '            return false;\n', '        }\n', '\n', '        if(isOrder[_order.orderHash]) {\n', '            return false;\n', '        }\n', '\n', '        if(cancelledOrders[_order.orderHash]) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function _composeOrder(address[3] _orderAddresses, uint[3] _orderValues)\n', '        internal\n', '        view\n', '        returns (Order _order)\n', '    {\n', '        Order memory order = Order({\n', '            account: _orderAddresses[0],\n', '            token: _orderAddresses[1],\n', '            byUser: _orderAddresses[2],\n', '            value: _orderValues[0],\n', '            createdTimestamp: now,\n', '            duration: _orderValues[1],\n', '            expirationTimestamp: add(now, _orderValues[1]),\n', '            salt: _orderValues[2],\n', '            orderHash: bytes32(0)\n', '        });\n', '\n', '        order.orderHash = _generateCreateOrderHash(order);\n', '\n', '        return order;\n', '    }\n', '\n', '    function _generateCreateOrderHash(Order _order)\n', '        internal\n', '        pure //view\n', '        returns (bytes32 _orderHash)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', ' //              address(this),\n', '                _order.account,\n', '                _order.token,\n', '                _order.value,\n', '                _order.duration,\n', '                _order.salt\n', '            )\n', '        );\n', '    }\n', '\n', '    function _generateActionOrderHash\n', '    (\n', '        bytes32 _orderHash,\n', '        string _action\n', '    )\n', '        internal\n', '        pure //view\n', '        returns (bytes32 _repayOrderHash)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '//                address(this),\n', '                _orderHash,\n', '                _action\n', '            )\n', '        );\n', '    }\n', '\n', '    function _getDateTimestamp(uint _timestamp) \n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        // 1 day\n', '        return dateTime.toTimestamp(dateTime.getYear(_timestamp), dateTime.getMonth(_timestamp), dateTime.getDay(_timestamp));\n', '        // 1 hour\n', '        //return dateTime.toTimestamp(dateTime.getYear(_timestamp), dateTime.getMonth(_timestamp), dateTime.getDay(_timestamp), dateTime.getHour(_timestamp));\n', '    } \n', '\n', '}\n', 'interface ExchangeConnector {\n', '\n', '    function tradeWithInputFixed\n', '    (   \n', '        Escrow _escrow,\n', '        address _srcToken,\n', '        address _destToken,\n', '        uint _srcTokenValue\n', '    )\n', '        external\n', '        returns (uint _destTokenValue, uint _srcTokenValueLeft);\n', '\n', '    function tradeWithOutputFixed\n', '    (   \n', '        Escrow _escrow,\n', '        address _srcToken,\n', '        address _destToken,\n', '        uint _srcTokenValue,\n', '        uint _maxDestTokenValue\n', '    )\n', '        external\n', '        returns (uint _destTokenValue, uint _srcTokenValueLeft);\n', '    \n', '\n', '    function getExpectedRate(address _srcToken, address _destToken, uint _srcTokenValue) \n', '        external\n', '        view\n', '        returns(uint _expectedRate, uint _slippageRate);\n', '    \n', '    function isTradeFeasible(address _srcToken, address _destToken, uint _srcTokenValue) \n', '        external\n', '        view\n', '        returns(bool);\n', '\n', '}\n', '\n', '\n', 'contract MKernel is DSStop, DSThing, Utils, Utils2, ErrorUtils {\n', '    \n', '    Escrow public escrow;\n', '    AccountFactory public accountFactory;\n', '    Reserve public reserve;\n', '    address public feeWallet;\n', '    Config public config;\n', '    \n', '    constructor\n', '    (\n', '        Escrow _escrow,\n', '        AccountFactory _accountFactory,\n', '        Reserve _reserve,\n', '        address _feeWallet,\n', '        Config _config\n', '    ) \n', '    public \n', '    {\n', '        escrow = _escrow;\n', '        accountFactory = _accountFactory;\n', '        reserve = _reserve;\n', '        feeWallet = _feeWallet;\n', '        config = _config;\n', '    }\n', '\n', '    function setEscrow(Escrow _escrow) \n', '        public \n', '        note \n', '        auth\n', '        addressValid(_escrow)\n', '    {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setAccountFactory(AccountFactory _accountFactory)\n', '        public \n', '        note \n', '        auth\n', '        addressValid(_accountFactory)\n', '    {\n', '        accountFactory = _accountFactory;\n', '    }\n', '\n', '    function setReserve(Reserve _reserve)\n', '        public \n', '        note \n', '        auth\n', '        addressValid(_reserve)\n', '    {\n', '        reserve = _reserve;\n', '    }\n', '\n', '    function setConfig(Config _config)\n', '        public \n', '        note \n', '        auth\n', '        addressValid(_config)\n', '    {\n', '        config = _config;\n', '    }\n', '\n', '    function setFeeWallet(address _feeWallet)\n', '        public \n', '        note \n', '        auth\n', '        addressValid(_feeWallet)\n', '    {\n', '        feeWallet = _feeWallet;\n', '    }\n', '    \n', '    event LogOrderCreated(\n', '        bytes32 indexed orderHash,\n', '        uint tradeAmount,\n', '        uint expirationTimestamp\n', '    );\n', '\n', '    event LogOrderLiquidatedByUser(\n', '        bytes32 indexed orderHash\n', '    );\n', '\n', '    event LogOrderStoppedAtProfit(\n', '        bytes32 indexed orderHash\n', '    );\n', '\n', '    event LogOrderDefaulted(\n', '        bytes32 indexed orderHash,\n', '        string reason\n', '    );\n', '\n', '    event LogNoActionPerformed(\n', '        bytes32 indexed orderHash\n', '    );\n', '\n', '    event LogOrderSettlement(\n', '        bytes32 indexed orderHash,\n', '        uint valueRepaid,\n', '        uint reserveProfit,\n', '        uint reserveLoss,\n', '        uint collateralLeft,\n', '        uint userProfit,\n', '        uint fee\n', '    );\n', '\n', '    struct Order {\n', '        address account;\n', '        address byUser;\n', '        address principalToken; \n', '        address collateralToken;\n', '        Trade trade;\n', '        uint principalAmount;\n', '        uint collateralAmount;\n', '        uint premium;\n', '        uint expirationTimestamp;\n', '        uint duration;\n', '        uint salt;\n', '        uint fee;\n', '        uint createdTimestamp;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    struct Trade {\n', '        address tradeToken;\n', '        address closingToken;\n', '        address exchangeConnector; //stores initial and then just used to pass around params\n', '        uint stopProfit;\n', '        uint stopLoss;\n', '    }\n', '\n', '    bytes32[] public orders;\n', '    mapping (bytes32 => Order) public hashToOrder;\n', '    mapping (bytes32 => bool) public isOrder;\n', '    mapping (address => bytes32[]) public accountToOrders;\n', '\n', '    mapping (bytes32 => uint) public initialTradeAmount;\n', '    mapping (bytes32 => bool) public isLiquidated;\n', '    mapping (bytes32 => bool) public isDefaulted;\n', '\n', '    modifier onlyAdmin() {\n', '        require(config.isAdminValid(msg.sender), "MKernel::_ INVALID_ADMIN_ACCOUNT");\n', '        _;\n', '    }\n', '\n', '\n', '    function createOrder\n', '    (\n', '        address[6] _orderAddresses,\n', '        uint[8] _orderValues,\n', '        address _exchangeConnector,\n', '        bytes _signature\n', '    )    \n', '        external\n', '        note\n', '        onlyAdmin\n', '        whenNotStopped\n', '        addressValid(_exchangeConnector)\n', '    {\n', '        Order memory order = _composeOrder(_orderAddresses, _orderValues);\n', '        address signer = _recoverSigner(order.orderHash, _signature);\n', '        order.trade.exchangeConnector = _exchangeConnector;\n', '\n', '        if(signer != order.byUser) {\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","SIGNER_NOT_ORDER_CREATOR");\n', '            return;\n', '        }\n', '\n', '        if(isOrder[order.orderHash]){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","ORDER_ALREADY_EXISTS");\n', '            return;\n', '        }\n', '\n', '        if(!accountFactory.isAccount(order.account)){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","INVALID_ORDER_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        if(!Account(order.account).isUser(signer)) {\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        if(!_isOrderValid(order)){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","INVALID_ORDER_PARAMETERS");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.collateralToken).balanceOf(order.account) < order.collateralAmount){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","INSUFFICIENT_COLLATERAL_IN_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.principalToken).balanceOf(reserve.escrow()) < order.principalAmount){\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","INSUFFICIENT_FUNDS_IN_RESERVE");\n', '            return;\n', '        }\n', '\n', '        if(!_isTradeFeasible(order, order.principalToken, order.trade.tradeToken, order.principalAmount))\n', '        {\n', '            emit LogErrorWithHintBytes32(order.orderHash, "MKernel::createOrder","TRADE_NOT_FEASIBLE");\n', '            return;\n', '        }        \n', '\n', '        \n', '        orders.push(order.orderHash);\n', '        hashToOrder[order.orderHash] = order;\n', '        isOrder[order.orderHash] = true;\n', '        accountToOrders[order.account].push(order.orderHash);\n', '\n', '        escrow.transferFromAccount(order.account, order.collateralToken, address(escrow), order.collateralAmount);\n', '        reserve.release(order.principalToken, address(escrow), order.principalAmount);\n', '    \n', '        (initialTradeAmount[order.orderHash],) = _tradeWithFixedInput(\n', '            order,\n', '            ERC20(order.principalToken),\n', '            ERC20(order.trade.tradeToken),\n', '            order.principalAmount\n', '        );\n', '\n', '        emit LogOrderCreated(\n', '            order.orderHash,\n', '            initialTradeAmount[order.orderHash],\n', '            order.expirationTimestamp\n', '        );\n', '        \n', '\n', '    }\n', '\n', '    function liquidateOrder\n', '    (\n', '        bytes32 _orderHash,\n', '        address _exchangeConnector,\n', '        bytes _signature\n', '    ) \n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_exchangeConnector)\n', '    {\n', '        if(!isOrder[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder","ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '        \n', '        if(isLiquidated[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder","ORDER_ALREADY_LIQUIDATED");\n', '            return;\n', '        }\n', '\n', '        if(isDefaulted[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder","ORDER_ALREADY_DEFAULTED");\n', '            return;\n', '        }\n', '\n', '        bytes32 liquidateOrderHash = _generateLiquidateOrderHash(_orderHash);\n', '        address signer = _recoverSigner(liquidateOrderHash, _signature);\n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '        order.trade.exchangeConnector = _exchangeConnector;\n', '        \n', '        if(!Account(order.account).isUser(signer)){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder", "SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder", "INSUFFICIENT_TRADE_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::liquidateOrder", "INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        isLiquidated[order.orderHash] = true;\n', '        _performOrderLiquidation(order);\n', '\n', '        emit LogOrderLiquidatedByUser(_orderHash);\n', '    }\n', '\n', '    function processTradeForExpiry\n', '    (\n', '        bytes32 _orderHash,\n', '        address _exchangeConnector\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_exchangeConnector)\n', '    {\n', '        if(!isOrder[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForExpiry","ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(isLiquidated[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForExpiry","ORDER_ALREADY_LIQUIDATED");\n', '            return;\n', '        }\n', '\n', '        if(isDefaulted[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForExpiry","ORDER_ALREADY_DEFAULTED");\n', '            return;\n', '        }\n', '        \n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '        order.trade.exchangeConnector = _exchangeConnector;\n', '\n', '        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForExpiry", "INSUFFICIENT_TRADE_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForExpiry", "INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(now > order.expirationTimestamp) {\n', '            isDefaulted[order.orderHash] = true;\n', '            _performOrderLiquidation(order);\n', '            emit LogOrderDefaulted(order.orderHash, "MKERNEL_DUE_DATE_PASSED");\n', '            return;\n', '        }\n', '\n', '        emit LogErrorWithHintBytes32(order.orderHash, "MKernel::processTradeForExpiry", "NO_ACTION_PERFORMED");\n', '    }\n', '\n', '\n', '    function processTradeForStopLoss\n', '    (\n', '        bytes32 _orderHash,\n', '        address _exchangeConnector,\n', '        uint[2] _tokenPrices,\n', '        uint _bufferInPrincipal\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_exchangeConnector)\n', '    {   \n', '        if(!isOrder[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopLoss","ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(isLiquidated[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopLoss","ORDER_ALREADY_LIQUIDATED");\n', '            return;\n', '        }\n', '\n', '        if(isDefaulted[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopLoss","ORDER_ALREADY_DEFAULTED");\n', '            return;\n', '        }\n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '        order.trade.exchangeConnector = _exchangeConnector;\n', '\n', '        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopLoss", "INSUFFICIENT_TRADE_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopLoss", "INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(!_isPositionAboveStopLoss(order, _tokenPrices, _bufferInPrincipal)) {\n', '            isDefaulted[order.orderHash] = true;\n', '            _performOrderLiquidation(order);\n', '            emit LogOrderDefaulted(order.orderHash, "MKERNEL_ORDER_UNSAFE");\n', '            return;\n', '        }\n', '\n', '        emit LogErrorWithHintBytes32(order.orderHash, "MKernel::processTradeForStopLoss", "NO_ACTION_PERFORMED");\n', '    }\n', '\n', '    function processTradeForStopProfit\n', '    (\n', '        bytes32 _orderHash,\n', '        address _exchangeConnector,\n', '        uint[2] _tokenPrices,\n', '        uint _bufferInPrincipal\n', '    )\n', '        external\n', '        note\n', '        onlyAdmin\n', '        addressValid(_exchangeConnector)\n', '    {   \n', '        if(!isOrder[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopProfit","ORDER_DOES_NOT_EXIST");\n', '            return;\n', '        }\n', '\n', '        if(isLiquidated[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopProfit","ORDER_ALREADY_LIQUIDATED");\n', '            return;\n', '        }\n', '\n', '        if(isDefaulted[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopProfit","ORDER_ALREADY_DEFAULTED");\n', '            return;\n', '        }\n', '\n', '        Order memory order = hashToOrder[_orderHash];\n', '        order.trade.exchangeConnector = _exchangeConnector;\n', '\n', '        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopProfit", "INSUFFICIENT_TRADE_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '\n', '        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\n', '            emit LogErrorWithHintBytes32(_orderHash, "MKernel::processTradeForStopProfit", "INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW");\n', '            return;\n', '        }\n', '        \n', '        if(_isPositionAboveStopProfit(order, _tokenPrices, _bufferInPrincipal)) {\n', '            isLiquidated[order.orderHash] = true;\n', '            _performOrderLiquidation(order);\n', '            emit LogOrderStoppedAtProfit(order.orderHash);\n', '            return;\n', '        }\n', '\n', '        emit LogErrorWithHintBytes32(order.orderHash, "MKernel::processTradeForStopProfit", "NO_ACTION_PERFORMED");\n', '    }\n', '\n', '    function _performOrderLiquidation(Order _order) \n', '        internal\n', '    {   \n', '        uint tradeAmount = initialTradeAmount[_order.orderHash];\n', '        uint valueToRepay = add(_order.principalAmount, _order.premium);\n', '        uint valueToRepayWithFee = add(valueToRepay, _order.fee);\n', '    \n', '        uint principalFromTrade = 0;\n', '        uint principalFromCollateral = 0;\n', '        uint principalNeededFromCollateral = 0;\n', '        uint collateralLeft = 0;\n', '        uint userProfit = 0;\n', '        uint totalPrincipalAcquired = 0;\n', '        uint orderFee = 0;\n', '        \n', '\n', '        \n', '            (principalFromTrade,) = _tradeWithFixedInput(_order, _order.trade.tradeToken, _order.principalToken, tradeAmount);\n', '\n', '            if(principalFromTrade >= valueToRepayWithFee) {\n', '                userProfit = sub(principalFromTrade, valueToRepayWithFee);\n', '                orderFee = _order.fee;\n', '                _performSettlement(_order, valueToRepay, _order.premium, 0, _order.collateralAmount, userProfit, orderFee);\n', '            } else {\n', '\n', '                principalNeededFromCollateral = sub(valueToRepayWithFee, principalFromTrade);\n', '\n', '                if (_order.collateralToken == _order.principalToken) {\n', '                    principalFromCollateral = principalNeededFromCollateral;\n', '\n', '                    if(_order.collateralAmount >= principalNeededFromCollateral) {\n', '                        collateralLeft = sub(_order.collateralAmount, principalNeededFromCollateral);\n', '                    }\n', '\n', '                } else {\n', '                    (principalFromCollateral, collateralLeft) = _tradeWithFixedOutput(_order, _order.collateralToken, _order.principalToken, _order.collateralAmount, principalNeededFromCollateral);    \n', '                }\n', '\n', '                if(principalFromCollateral >= principalNeededFromCollateral) {\n', '                    orderFee = _order.fee;\n', '                    _performSettlement(_order, valueToRepay, _order.premium, 0, collateralLeft, 0, orderFee);\n', '                } else {\n', '                    totalPrincipalAcquired = add(principalFromTrade, principalFromCollateral);\n', '                    _performSettlementAfterAllPossibleLiquidations(_order, totalPrincipalAcquired);\n', '                }\n', '            }\n', '                       \n', '    }\n', '\n', '    function _tradeWithFixedInput(Order _order, address _srcToken, address _destToken, uint _srcTokenValue)\n', '        internal\n', '        returns (uint _destTokenValue, uint _srcTokenValueLeft)\n', '    {\n', '        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\n', '        return exchangeConnector.tradeWithInputFixed(\n', '                    escrow,\n', '                    _srcToken,\n', '                    _destToken,\n', '                    _srcTokenValue\n', '        );\n', '    }\n', '\n', '    function _tradeWithFixedOutput(Order _order, address _srcToken, address _destToken, uint _srcTokenValue, uint _maxDestTokenValue)\n', '        internal\n', '        returns (uint _destTokenValue, uint _srcTokenValueLeft)\n', '    {\n', '        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\n', '        return exchangeConnector.tradeWithOutputFixed(\n', '                    escrow,\n', '                    _srcToken,\n', '                    _destToken,\n', '                    _srcTokenValue,\n', '                    _maxDestTokenValue\n', '        );\n', '    }\n', '\n', '    function _isTradeFeasible(Order _order, address _srcToken, address _destToken, uint _srcTokenValue)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {   \n', '        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\n', '        return exchangeConnector.isTradeFeasible(_srcToken, _destToken, _srcTokenValue);\n', '    }\n', '\n', '    function _performSettlementAfterAllPossibleLiquidations\n', '    (\n', '        Order _order,\n', '        uint _totalPrincipalAcquired\n', '    )\n', '        internal\n', '    {\n', '        uint valueToRepay = add(_order.principalAmount, _order.premium);\n', '\n', '        if(_totalPrincipalAcquired >= valueToRepay) {\n', '            _performSettlement(_order, valueToRepay, _order.premium, 0, 0, 0, sub(_totalPrincipalAcquired, valueToRepay));\n', '        } else if((_totalPrincipalAcquired < valueToRepay) && (_totalPrincipalAcquired >= _order.principalAmount)) {\n', '            _performSettlement(_order, _totalPrincipalAcquired, sub(_totalPrincipalAcquired, _order.principalAmount), 0, 0, 0, 0);\n', '        } else {\n', '            _performSettlement(_order, _totalPrincipalAcquired, 0, sub(_order.principalAmount, _totalPrincipalAcquired), 0, 0, 0);\n', '        }\n', '\n', '    }\n', '\n', '    function _performSettlement\n', '    (\n', '        Order _order,\n', '        uint _valueRepaid,\n', '        uint _reserveProfit,\n', '        uint _reserveLoss,\n', '        uint _collateralLeft,\n', '        uint _userProfit,\n', '        uint _fee\n', '    ) \n', '        internal \n', '    {\n', '        uint closingFromPrincipal = 0;\n', '        uint userEarnings = _userProfit;\n', '\n', '        if(_fee > 0){\n', '            escrow.transfer(_order.principalToken, feeWallet, _fee);\n', '        }\n', '        \n', '        reserve.lock(_order.principalToken, escrow, _valueRepaid, _reserveProfit, _reserveLoss);\n', '        \n', '        if(_collateralLeft > 0) {\n', '            escrow.transfer(_order.collateralToken, _order.account, _collateralLeft);    \n', '        }\n', '\n', '        if(_userProfit > 0) {\n', '            if(_order.trade.closingToken == _order.principalToken || !_isTradeFeasible(_order, _order.principalToken, _order.trade.closingToken, _userProfit)) {\n', '                escrow.transfer(_order.principalToken, _order.account, _userProfit);\n', '            } else {\n', '                (closingFromPrincipal,) = _tradeWithFixedInput(_order, _order.principalToken, _order.trade.closingToken, _userProfit);\n', '                escrow.transfer(_order.trade.closingToken, _order.account, closingFromPrincipal);\n', '                userEarnings = closingFromPrincipal;\n', '            }\n', '        }\n', '\n', '        emit LogOrderSettlement(_order.orderHash, _valueRepaid, _reserveProfit, _reserveLoss, _collateralLeft, userEarnings, _fee);\n', '    }\n', '\n', '    function _isPositionAboveStopLoss(Order _order, uint[2] _tokenPrices, uint _bufferInPrincipal)\n', '        internal \n', '        view\n', '        returns (bool)\n', '    {\n', '        uint principalPerCollateral = _tokenPrices[0]; \n', '        uint principalPerTrade = _tokenPrices[1];\n', '        uint tradeAmount = initialTradeAmount[_order.orderHash];\n', '\n', '        uint valueToRepayWithFee = add(add(_order.principalAmount, _order.premium), _order.fee);\n', '        uint totalCollateralValueInPrincipal = div(mul(_order.collateralAmount, principalPerCollateral), WAD);\n', '        uint totalTradeValueInPrincipal = div(mul(tradeAmount, principalPerTrade), WAD);\n', '\n', '        uint bufferValue = div(mul(_order.principalAmount, _bufferInPrincipal), WAD);\n', '        uint minValueReq = div(mul(_order.trade.stopLoss, totalCollateralValueInPrincipal), WAD);\n', '\n', '        if(add(valueToRepayWithFee, bufferValue) >= totalTradeValueInPrincipal && \n', '            sub(add(valueToRepayWithFee, bufferValue), totalTradeValueInPrincipal) >= minValueReq) \n', '        {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function _isPositionAboveStopProfit(Order _order, uint[2] _tokenPrices, uint _bufferInPrincipal)\n', '        internal \n', '        view\n', '        returns (bool)\n', '    {       \n', '        if(_order.trade.stopProfit == 0) {\n', '            return false;\n', '        } else {\n', '            uint principalPerTrade = _tokenPrices[1];\n', '            uint tradeAmount = initialTradeAmount[_order.orderHash];\n', '\n', '            uint valueToRepayWithFee = add(add(_order.principalAmount, _order.premium), _order.fee);\n', '            uint totalTradeValueInPrincipal = div(mul(tradeAmount, principalPerTrade), WAD);\n', '\n', '            uint stopProfitValue = div(mul(_order.principalAmount, _order.trade.stopProfit), WAD);\n', '            uint bufferValue = div(mul(_order.principalAmount, _bufferInPrincipal), WAD);\n', '\n', '            if(totalTradeValueInPrincipal >= add(add(valueToRepayWithFee, stopProfitValue), bufferValue)) {\n', '                return true;\n', '            }\n', '\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _generateLiquidateOrderHash\n', '    (\n', '        bytes32 _orderHash\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32 _liquidateOrderHash)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _orderHash,\n', '                "CANCEL_MKERNEL_ORDER"\n', '            )\n', '        );\n', '    }\n', '\n', '    function _isOrderValid(Order _order)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if(_order.account == address(0) || _order.byUser == address(0)\n', '         || _order.principalToken == address(0) || _order.collateralToken == address(0)\n', '         || _order.trade.closingToken == address(0)\n', '         || _order.trade.tradeToken == address(0)\n', '         || (_order.trade.tradeToken == _order.principalToken) || _order.trade.exchangeConnector == address(0)\n', '         || _order.principalAmount == 0 || _order.collateralAmount == 0\n', '         || _order.premium == 0\n', '         || _order.expirationTimestamp <= _order.createdTimestamp || _order.salt == 0) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function _composeOrder\n', '    (\n', '        address[6] _orderAddresses,\n', '        uint[8] _orderValues\n', '    )\n', '        internal\n', '        view\n', '        returns (Order _order)\n', '    {   \n', '        Trade memory trade = _composeTrade(_orderAddresses[4], _orderAddresses[5], _orderValues[6], _orderValues[7]);\n', '\n', '        Order memory order = Order({\n', '            account: _orderAddresses[0],\n', '            byUser: _orderAddresses[1],\n', '            principalToken: _orderAddresses[2],\n', '            collateralToken: _orderAddresses[3],\n', '            principalAmount: _orderValues[0],\n', '            collateralAmount: _orderValues[1],\n', '            premium: _orderValues[2],\n', '            duration: _orderValues[3],\n', '            expirationTimestamp: add(now, _orderValues[3]),\n', '            salt: _orderValues[4],\n', '            fee: _orderValues[5],\n', '            createdTimestamp: now,\n', '            orderHash: bytes32(0),\n', '            trade: trade\n', '        });\n', '\n', '        order.orderHash = _generateOrderHash(order);\n', '    \n', '        return order;\n', '    }\n', '\n', '    function _composeTrade\n', '    (\n', '        address _tradeToken,\n', '        address _closingToken,\n', '        uint _stopProfit,\n', '        uint _stopLoss\n', '    )\n', '        internal \n', '        pure\n', '        returns (Trade _trade)\n', '    {\n', '        _trade = Trade({\n', '            tradeToken: _tradeToken,\n', '            closingToken: _closingToken,\n', '            stopProfit: _stopProfit,\n', '            stopLoss: _stopLoss,\n', '            exchangeConnector: address(0)\n', '        });\n', '    }\n', '\n', '    function _generateOrderHash(Order _order)\n', '        internal\n', '        view\n', '        returns (bytes32 _orderHash)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _generateOrderHash1(_order),\n', '                _generateOrderHash2(_order)\n', '            )\n', '        );\n', '    }\n', '\n', '    function _generateOrderHash1(Order _order)\n', '        internal\n', '        view\n', '        returns (bytes32 _orderHash1) \n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _order.account,\n', '                _order.principalToken,\n', '                _order.collateralToken,\n', '                _order.principalAmount,\n', '                _order.collateralAmount,\n', '                _order.premium,\n', '                _order.duration,\n', '                _order.salt,\n', '                _order.fee\n', '            )\n', '        );\n', '    }\n', '\n', '    function _generateOrderHash2(Order _order)\n', '        internal\n', '        view\n', '        returns (bytes32 _orderHash2)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                _order.trade.tradeToken,\n', '                _order.trade.closingToken,\n', '                _order.trade.stopProfit,\n', '                _order.trade.stopLoss,\n', '                _order.salt\n', '            )\n', '        );\n', '    }\n', '\n', '    function getAllOrders()\n', '        public \n', '        view \n', '        returns \n', '        (\n', '            bytes32[]\n', '        )\n', '    {\n', '        return orders;\n', '    }\n', '\n', '    \n', '    function getOrder(bytes32 _orderHash)\n', '        public \n', '        view \n', '        returns \n', '        (\n', '            address _account,\n', '            address _byUser,\n', '            address _principalToken,\n', '            address _collateralToken,\n', '            uint _principalAmount,\n', '            uint _collateralAmount,\n', '            uint _premium,\n', '            uint _expirationTimestamp,\n', '            uint _salt,\n', '            uint _fee,\n', '            uint _createdTimestamp\n', '        )\n', '    {   \n', '        Order memory order = hashToOrder[_orderHash];\n', '        return (\n', '            order.account,\n', '            order.byUser,\n', '            order.principalToken,\n', '            order.collateralToken,\n', '            order.principalAmount,\n', '            order.collateralAmount,\n', '            order.premium,\n', '            order.expirationTimestamp,\n', '            order.salt,\n', '            order.fee,\n', '            order.createdTimestamp\n', '        );\n', '    }\n', '\n', '    function getTrade(bytes32 _orderHash)\n', '        public \n', '        view \n', '        returns \n', '        (\n', '            address _tradeToken,\n', '            address _closingToken,\n', '            address _initExchangeConnector,\n', '            uint _stopProfit,\n', '            uint _stopLoss\n', '        )\n', '    {   \n', '        Order memory order = hashToOrder[_orderHash];\n', '        return (\n', '            order.trade.tradeToken,\n', '            order.trade.closingToken,\n', '            order.trade.exchangeConnector,\n', '            order.trade.stopProfit,\n', '            order.trade.stopLoss\n', '        );\n', '    }\n', '\n', '    function getOrdersForAccount(address _account) \n', '        public\n', '        view \n', '        returns \n', '        (\n', '            bytes32[]\n', '        )\n', '    {\n', '        return accountToOrders[_account];\n', '    }\n', '\n', '}']