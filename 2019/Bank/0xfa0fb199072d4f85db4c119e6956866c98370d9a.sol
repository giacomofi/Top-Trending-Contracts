['pragma solidity ^0.4.25;\n', '\n', 'contract SafeMath {\n', '  function Sub(uint128 a, uint128 b) pure public returns (uint128) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function Add(uint128 a, uint128 b) pure public returns (uint128) {\n', '    uint128 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token { \n', '  function totalSupply() public view returns (uint256 supply);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract DEX is SafeMath\n', '{\n', '    uint32 public lastTransferId = 1;\n', '    event NewDeposit(uint32 indexed prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\n', '    event NewWithdraw(uint32 indexed prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\n', '    uint32 public lastNewOrderId = 1;\n', '    event NewOrder(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qty, uint32 lastNewOrderId);\n', '    event NewCancel(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qt, uint32 lastNewOrderId);\n', '    event NewBestBidAsk(uint32 indexed prTrade, uint32 indexed prBase, bool isBid, uint80 price);\n', '    uint32 public lastTradeId = 1;\n', '    event NewTrade(uint32 indexed prTrade, uint32 prBase, uint32 indexed bidId, uint32 indexed askId, uint32 accountIdBid, uint32 accountIdAsk, bool isSell, uint80 price, uint104 qty, uint32 lastTradeId, uint64 timestamp);\n', '    \n', '    uint256 public constant basePrice = 10000000000;\n', '    uint80 public constant maxPrice = 10000000000000000000001;\n', '    uint104 public constant maxQty = 1000000000000000000000000000001;\n', '    uint128 public constant maxBalance = 1000000000000000000000000000000000001;\n', '    bool public isContractUse;\n', '    \n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '        operator = owner;\n', '        AddOwner();\n', '        AddProduct(18, 0x0);\n', '        //lastProductId = 1; // productId == 1 -> ETH 0x0\n', '        isContractUse = true;\n', '    }\n', '    \n', '    address public owner;\n', '    // Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    address public operator;\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator);\n', '        _;\n', '    }\n', '    function transferOperator(address _operator) onlyOwner public {\n', '        operator = _operator;\n', '    }\n', '    \n', '    modifier onlyExOwner()  {\n', '        require(owner_id[msg.sender] != 0);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyContractUse {\n', '        require(isContractUse == true);\n', '        _;\n', '    }\n', '    function SetIsContractUse(bool _isContractUse) onlyOperator public \n', '    {\n', '        isContractUse = _isContractUse;\n', '    }\n', '    \n', '    uint32 public lastOwnerId;\n', '    uint256 public newOwnerFee;\n', '    mapping (uint32 => address) id_owner;\n', '    mapping (address => uint32) owner_id;\n', '    mapping (uint32 => uint8) ownerId_takerFeeRateLocal;\n', '    mapping (uint32 => uint32) ownerId_accountId;\n', '    \n', '    function DeleteOwner(uint32 orderId) onlyOperator public \n', '    {\n', '        require(lastOwnerId >= orderId && orderId > 0);\n', '        owner_id[id_owner[orderId]] = 0;\n', '    }\n', '    \n', '    function AddOwner() public payable \n', '    {\n', '        require(msg.value >= newOwnerFee);\n', '        require(owner_id[msg.sender] == 0);\n', '        \n', '        owner_id[msg.sender] = ++lastOwnerId;\n', '        id_owner[lastOwnerId] = msg.sender;\n', '        \n', '        ownerId_accountId[lastOwnerId] = FindOrAddAccount();\n', '        prCode_AccountId_Balance[1][ownerId_accountId[1]].available += uint128(msg.value);\n', '        //overflow safe: eth balance & trasnfer << 2^128\n', '    }\n', '    function SetOwnerFee(uint256 ownerFee) onlyOperator public\n', '    {\n', '        newOwnerFee = ownerFee;\n', '    }\n', '    function GetOwnerList() view public returns (address[] owners, uint32[] ownerIds)\n', '    {\n', '        owners = new address[](lastOwnerId);\n', '        ownerIds = new uint32[](lastOwnerId);\n', '        \n', '        for (uint32 i = 1; i <= lastOwnerId; i++)\n', '        {\n', '            owners[i - 1] = id_owner[i];\n', '            ownerIds[i - 1] = i;\n', '        }\n', '    }\n', '    function setTakerFeeRateLocal(uint8 _takerFeeRate) public\n', '    {\n', '        require (_takerFeeRate <= 100);\n', '        uint32 ownerId = owner_id[msg.sender];\n', '        require(ownerId != 0);\n', '        ownerId_takerFeeRateLocal[ownerId] = _takerFeeRate;//bp\n', '    }\n', '    function getTakerFeeRateLocal(uint32 ownerId) public view returns (uint8)/////\n', '    {\n', '        return ownerId_takerFeeRateLocal[ownerId];//bp\n', '    }\n', '    \n', '    function airDrop(uint32 prCode, uint32[] accountIds, uint104[] qtys) public\n', '    {\n', '        require(owner_id[msg.sender] != 0);\n', '        //uint32 ownerId = owner_id[msg.sender];\n', '        uint32 accountId = FindOrRevertAccount();// ownerId_accountId[owner_id[msg.sender]];\n', '        require(accountId_freeze[accountId] == false);\n', '        uint256 n = accountIds.length;\n', '        require(n == qtys.length);// && n <= 1000000);\n', '        \n', '        uint128 sum = 0;\n', '        for (uint32 i = 0; i < n; i++)\n', '        {\n', '            sum += qtys[i];\n', '        }\n', '        \n', '        prCode_AccountId_Balance[prCode][accountId].available = Sub(prCode_AccountId_Balance[prCode][accountId].available, sum); \n', '        \n', '        for (i = 0; i < n; i++)\n', '        {\n', '            prCode_AccountId_Balance[prCode][accountIds[i]].available += qtys[i];\n', '        }\n', '    }\n', '    \n', '    struct ProductInfo\n', '    {\n', '        uint256 divider;\n', '        bool isTradeBid;\n', '        bool isTradeAsk;\n', '        bool isDeposit;\n', '        bool isWithdraw;\n', '        uint32 ownerId;\n', '        uint104 minQty;\n', '    }\n', '    \n', '    uint32 public lastProductId;\n', '    uint256 public newProductFee;\n', '    mapping (uint32 => address) prCode_product;\n', '    mapping (address => uint32) product_prCode;\n', '    mapping (uint32 => ProductInfo) prCode_productInfo;\n', '    function AddProduct(uint256 decimals, address product) payable onlyExOwner public\n', '    {\n', '        require(msg.value >= newProductFee);\n', '        require(product_prCode[product] == 0);\n', '        require(decimals <= 18);\n', '        \n', '        product_prCode[product] = ++lastProductId;  \n', '        prCode_product[lastProductId] = product;\n', '        \n', '        ProductInfo memory productInfo;\n', '        productInfo.divider = 10 ** decimals; // max = 10 ^ 18\n', '        productInfo.ownerId = owner_id[msg.sender];\n', '        //productInfo.isDeposit = isDeposit;\n', '        prCode_productInfo[lastProductId] = productInfo;\n', '        \n', '        prCode_AccountId_Balance[1][ownerId_accountId[1]].available += uint128(msg.value);\n', '    }\n', '    function SetProductInfo(uint32 prCode, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint104 _minQty) public\n', '    {\n', '        ProductInfo storage prInfo = prCode_productInfo[prCode];\n', '        \n', '        require(msg.sender == operator || owner_id[msg.sender] == prInfo.ownerId );\n', '        \n', '        prInfo.isTradeBid = isTradeBid;\n', '        prInfo.isTradeAsk = isTradeAsk;\n', '        prInfo.isDeposit = isDeposit;\n', '        prInfo.isWithdraw = isWithdraw;\n', '        prInfo.minQty = _minQty;\n', '    }/*\n', '    function SetProductMinQty(uint32 prCode, uint104 _minQty) public\n', '    {\n', '        ProductInfo storage prInfo = prCode_productInfo[prCode];\n', '        require(msg.sender == operator || owner_id[msg.sender] == prInfo.ownerId );\n', '        \n', '        prInfo.minQty = _minQty;\n', '    }*/\n', '    function SetProductFee(uint256 productFee) onlyOperator public\n', '    {\n', '        newProductFee = productFee;\n', '    }\n', '    function GetProductList() view public returns (address[] products, uint32[] productIds)\n', '    {\n', '        products = new address[](lastProductId);\n', '        productIds = new uint32[](lastProductId);\n', '        \n', '        for (uint32 i = 1; i <= lastProductId; i++)\n', '        {\n', '            products[i - 1] = prCode_product[i];\n', '            productIds[i - 1] = i;\n', '        }\n', '    }\n', '    function GetProductInfo(address product) view public returns (uint32 prCode, uint256 divider, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint32 ownerId, uint104 minQty)\n', '    {\n', '        prCode = product_prCode[product];\n', '        require(prCode != 0);\n', '        \n', '        divider = prCode_productInfo[prCode].divider;\n', '        isTradeBid = prCode_productInfo[prCode].isTradeBid;\n', '        isTradeAsk = prCode_productInfo[prCode].isTradeAsk;\n', '        isDeposit = prCode_productInfo[prCode].isDeposit;\n', '        isWithdraw = prCode_productInfo[prCode].isWithdraw;\n', '        ownerId = prCode_productInfo[prCode].ownerId;\n', '        minQty = prCode_productInfo[prCode].minQty;\n', '    }/*\n', '    function AcceptProduct(uint32 prCode, bool isTrade) onlyOperator public\n', '    {\n', '        prCode_productInfo[prCode].isTrade = isTrade;\n', '    }*/\n', '    \n', '    uint32 public lastAcccountId;\n', '    mapping (uint32 => uint8) id_announceLV; //0: None, 1: Trade, 2:Balance, 3:DepositWithdrawal, 4:OpenOrder\n', '    mapping (uint32 => address) id_account;\n', '    mapping (uint32 => bool) accountId_freeze;\n', '    mapping (address => uint32) account_id;\n', '    \n', '    function FindOrAddAccount() private returns (uint32)\n', '    {\n', '        if (account_id[msg.sender] == 0)\n', '        {\n', '            account_id[msg.sender] = ++lastAcccountId;\n', '            id_account[lastAcccountId] = msg.sender;\n', '        }\n', '        return account_id[msg.sender];\n', '    }\n', '    function FindOrRevertAccount() private view returns (uint32)\n', '    {\n', '        uint32 accountId = account_id[msg.sender];\n', '        require(accountId != 0);\n', '        return accountId;\n', '    }\n', '    /*\n', '    function GetAccountList() view onlyOperator public returns (address[] owners)//, uint32[] Ids)// Delete Later`\n', '    {\n', '        owners = new address[](lastAcccountId);\n', '        //Ids = new uint32[](lastAcccountId);\n', '        \n', '        for (uint32 i = 1; i <= lastAcccountId; i++)\n', '        {\n', '            owners[i - 1] = id_account[i];\n', '            //Ids[i - 1] = i;\n', '        }\n', '    }*/\n', '    function GetMyAccountId() view public returns (uint32)\n', '    {\n', '        return account_id[msg.sender];\n', '    }\n', '    function GetAccountId(address account) view public returns (uint32)\n', '    {\n', '        return account_id[account];\n', '    }\n', '    function GetMyAnnounceLV() view public returns (uint32)\n', '    {\n', '        return id_announceLV[account_id[msg.sender]];\n', '    }\n', '    function ChangeAnnounceLV(uint8 announceLV) public\n', '    {\n', '        id_announceLV[FindOrRevertAccount()] = announceLV;\n', '    }\n', '    function SetFreezeByAddress(bool isFreeze, address account) onlyOperator public\n', '    {\n', '        uint32 accountId = account_id[account];\n', '        \n', '        if (accountId != 0)\n', '        {\n', '            accountId_freeze[accountId] = isFreeze;\n', '        }\n', '    }\n', '    \n', '    struct Balance\n', '    {\n', '        uint128 reserved;\n', '        uint128 available;\n', '    }\n', '    \n', '    struct ListItem\n', '    {\n', '        uint32 prev;\n', '        uint32 next;\n', '    }\n', '    \n', '    struct OrderLink\n', '    {\n', '        //uint32 orderN;\n', '        uint32 firstId;\n', '        uint32 lastId;\n', '        uint80 nextPrice;\n', '        uint80 prevPrice;\n', '        mapping (uint32 => ListItem) id_orderList;\n', '    }\n', '    \n', '    struct Order\n', '    {\n', '        uint32 ownerId;\n', '        uint32 accountId;\n', '        uint32 prTrade;\n', '        uint32 prBase;\n', '        uint104 qty;\n', '        uint80 price;\n', '        bool isSell;\n', '        //uint64 timestamp;\n', '    }\n', '\n', '    uint32 public lastOrderId;\n', '    mapping (uint32 => Order) id_Order;\n', '        \n', '    struct OrderBook\n', '    {\n', '        uint8 tickSize;\n', '        \n', '        uint80 bestBidPrice;\n', '        uint80 bestAskPrice;\n', '\n', '        mapping (uint80 => OrderLink) bidPrice_Order;\n', '        mapping (uint80 => OrderLink) askPrice_Order;\n', '    }\n', '    mapping (uint32 => mapping (uint32 => OrderBook)) basePID_tradePID_orderBook;\n', '    function SetOrderBookTickSize(uint32 prTrade, uint32 prBase, uint8 _tickSize) onlyOperator public\n', '    {\n', '        basePID_tradePID_orderBook[prBase][prTrade].tickSize = _tickSize;\n', '    }\n', '    \n', '    mapping (uint32 => mapping (uint32 => Balance)) prCode_AccountId_Balance;\n', '    \n', '    //trading fee\n', '    uint8 public takerFeeRateMain;\n', '    function setTakerFeeRateMain(uint8 _takerFeeRateMain) onlyOperator public\n', '    {\n', '        if (_takerFeeRateMain <= 100)\n', '            takerFeeRateMain = _takerFeeRateMain;//bp\n', '    }\n', '    \n', '    struct OpenOrder\n', '    {\n', '        uint32 startId;\n', '        mapping(uint32 => ListItem) id_orderList;\n', '    }\n', '    mapping(uint32 => OpenOrder) accountId_OpenOrder;\n', '    function AddOpenOrder(uint32 accountId, uint32 orderId) private\n', '    {\n', '        OpenOrder memory openOrder = accountId_OpenOrder[accountId];\n', '\n', '        if (openOrder.startId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[openOrder.startId].prev = orderId;\n', '            accountId_OpenOrder[accountId].id_orderList[orderId].next = openOrder.startId;\n', '        }\n', '        accountId_OpenOrder[accountId].startId = orderId;\n', '    }\n', '    function RemoveOpenOrder(uint32 accountId, uint32 orderId) private\n', '    {\n', '        OpenOrder memory openOrder = accountId_OpenOrder[accountId];\n', '\n', '        uint32 nextId = accountId_OpenOrder[accountId].id_orderList[orderId].next;\n', '        uint32 prevId = accountId_OpenOrder[accountId].id_orderList[orderId].prev;\n', '\n', '        if (nextId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[nextId].prev = prevId;\n', '        }\n', '\n', '        if (prevId != 0)\n', '        {\n', '            accountId_OpenOrder[accountId].id_orderList[prevId].next = nextId;\n', '        }\n', '        \n', '        if (openOrder.startId == orderId)\n', '        {\n', '            accountId_OpenOrder[accountId].startId = nextId;\n', '        }\n', '    }\n', '\n', '    struct DWrecord\n', '    {\n', '        uint32 prCode;\n', '        bool isDeposit;\n', '        uint128 qty;\n', '        uint64 timestamp;\n', '    }\n', '    \n', '    struct DWrecords\n', '    {\n', '        uint32 N;\n', '        mapping (uint32 => DWrecord) N_DWrecord;\n', '    }\n', '    mapping (uint32 => DWrecords) AccountId_DWrecords;\n', '    function RecordDW(uint32 accountId, uint32 prCode, bool isDeposit, uint128 qty) private\n', '    {\n', '        //DWrecords storage dWrecords = AccountId_DWrecords[accountId];\n', '\n', '        DWrecord memory dW;\n', '        dW.isDeposit = isDeposit;\n', '        dW.prCode = prCode;\n', '        dW.qty = qty;\n', '        dW.timestamp = uint64(now);\n', '\n', '        AccountId_DWrecords[accountId].N_DWrecord[++AccountId_DWrecords[accountId].N] = dW;\n', '        \n', '        if (isDeposit == true)\n', '            emit NewDeposit(prCode, accountId, qty, dW.timestamp, lastTransferId++);\n', '        else \n', '            emit NewWithdraw(prCode, accountId, qty, dW.timestamp, lastTransferId++);\n', '    }\n', '    function GetDWrecords(uint32 N, uint32 accountId) view public returns (uint32[] prCode, bool[] isDeposit, uint128[] qty, uint64[] timestamp)\n', '    {\n', '        //require (id_announceLV[accountId] > 2 || accountId == account_id[msg.sender]);\n', '        checkAnnounceLV(accountId, 3);\n', '        \n', '        DWrecords storage dWrecords = AccountId_DWrecords[accountId];\n', '        uint32 n = dWrecords.N;\n', '        \n', '        if (n > N)\n', '            n = N;\n', '            \n', '        prCode = new uint32[](n);\n', '        isDeposit = new bool[](n);\n', '        qty = new uint128[](n);\n', '        timestamp = new uint64[](n);\n', '\n', '        for (uint32 i = dWrecords.N; i > dWrecords.N - n; i--)\n', '        {\n', '            N = dWrecords.N - i;\n', '            prCode[N] = dWrecords.N_DWrecord[i].prCode;//Bug0309\n', '            isDeposit[N] = dWrecords.N_DWrecord[i].isDeposit;//Bug0309\n', '            qty[N] = dWrecords.N_DWrecord[i].qty;//Bug0309\n', '            timestamp[N] = dWrecords.N_DWrecord[i].timestamp;//Bug0309\n', '        }\n', '    }\n', '    \n', '/////////////////\n', '    function depositETH() payable public\n', '    {\n', '        uint32 accountId = FindOrAddAccount();\n', '        prCode_AccountId_Balance[1][accountId].available = Add(prCode_AccountId_Balance[1][accountId].available, uint128(msg.value));\n', '        RecordDW(accountId, 1, true, uint104(msg.value));\n', '    }\n', '\n', '    function withdrawETH(uint104 amount) public\n', '    {\n', '        uint32 accountId = FindOrRevertAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        prCode_AccountId_Balance[1][accountId].available = Sub(prCode_AccountId_Balance[1][accountId].available, amount);\n', '        require(msg.sender.send(amount));\n', '        RecordDW(accountId, 1, false,  amount);\n', '    }\n', '\n', '    function depositWithdrawToken(uint128 amount, bool isDeposit, address prAddress) public\n', '    {\n', '        uint32 prCode = product_prCode[prAddress];\n', '        require(amount < maxBalance && prCode != 0);\n', '        uint32 accountId = FindOrAddAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        //require(accountId != 0);\n', '        \n', '        if (isDeposit == true)\n', '        {\n', '            require(prCode_productInfo[prCode].isDeposit == true);//Bug0310\n', '            require(Token(prAddress).transferFrom(msg.sender, this, amount));\n', '            prCode_AccountId_Balance[prCode][accountId].available = Add(prCode_AccountId_Balance[prCode][accountId].available, amount);\n', '            require (prCode_AccountId_Balance[prCode][accountId].available < maxBalance);\n', '        }\n', '        else\n', '        {\n', '            require(prCode_productInfo[prCode].isWithdraw == true);//Bug0310\n', '            prCode_AccountId_Balance[prCode][accountId].available = Sub(prCode_AccountId_Balance[prCode][accountId].available, amount);\n', '            require(Token(prAddress).transfer(msg.sender, amount));    \n', '        }\n', '        RecordDW(accountId, prCode, isDeposit, amount);\n', '    }\n', '    \n', '    function emergencyWithdrawal(uint32 prCode, uint256 amount) onlyOwner public\n', '    {\n', '        require (isContractUse == false);//Added\n', '        if (prCode == 1)\n', '            require(msg.sender.send(amount));\n', '        else\n', '            Token(prCode_product[prCode]).transfer(msg.sender, amount);\n', '    }\n', ' /*\n', '    function withdrawToken(address prAddress, uint128 amount) public\n', '    {        \n', '        uint32 prCode = product_prCode[prAddress];\n', '        require(amount < maxBalance && prCode != 0);\n', '        uint32 accountId = account_id[msg.sender];\n', '        require(accountId != 0);\n', '        \n', '        //Balance storage balance = prCode_AccountId_Balance[prCode][accountId];\n', '        prCode_AccountId_Balance[prCode][accountId].available = SafeMath.Sub(prCode_AccountId_Balance[prCode][accountId].available, amount);\n', '        require(Token(prAddress).transfer(msg.sender, amount));\n', '        RecordDW(accountId, prCode, false, amount);\n', '    }\n', '    /*\n', '    function withdrawToken(address prAddress, uint128 amount, address toAddress) public\n', '    {        \n', '        uint32 prCode = product_prCode[prAddress];\n', '        require(amount < maxBalance && prCode != 0);\n', '        \n', '        uint32 accountId = account_id[msg.sender];\n', '        require(accountId != 0);\n', '        \n', '        //Balance storage balance = prCode_AccountId_Balance[prCode][accountId];\n', '        prCode_AccountId_Balance[prCode][accountId].available = SafeMath.Sub(prCode_AccountId_Balance[prCode][accountId].available, amount);\n', '        require(Token(prAddress).transfer(toAddress, amount));\n', '        RecordDW(accountId, prCode, false, amount);\n', '    }*/\n', '    /*\n', '    uint32 public maxOrderN;\n', '    function SetMaxOrderN(uint32 _maxOrderN) public onlyOwner\n', '    {\n', '        maxOrderN = _maxOrderN;\n', '    }*/\n', '    function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)\n', '    {\n', '        if (price > 0)\n', '        {\n', '            uint80 tick = GetTick(price, n);\n', '    \n', '            if (isAsk == true)\n', '                return (((price - 1) / tick) + 1) * tick;\n', '            else\n', '                return (price / tick) * tick;\n', '        }\n', '        else\n', '        {\n', '            return price;\n', '        }\n', '    }\n', '    \n', '    function GetTick(uint80 price, uint8 n)  public pure returns  (uint80)\n', '    {\n', '        if (n < 1)\n', '            n = 1;\n', '        \n', '        uint80 x = 1;\n', '        \n', '        for (uint8 i=1; i <= n / 2; i++)\n', '        {\n', '            x *= 10;\n', '        }\n', '        \n', '        if (price < 10 * x)\n', '            return 1;\n', '        else\n', '        {\n', '            uint80 tick = 10000;\n', '                \n', '            uint80 priceTenPercent = price / 10 / x;\n', '                \n', '            while (priceTenPercent > tick)\n', '            {\n', '                tick *= 10;\n', '            }\n', '    \n', '            while (priceTenPercent < tick)\n', '            {\n', '                tick /= 10;\n', '            }\n', '            \n', '            if (n % 2 == 1)\n', '            {\n', '                if (price >= 50 * tick * x)\n', '                {\n', '                    tick *= 5;\n', '                }\n', '            }\n', '            else\n', '            {\n', '                if (price < 50 * tick * x)\n', '                {\n', '                    tick *= 5;\n', '                }\n', '                else\n', '                {\n', '                    tick *= 10;\n', '                }\n', '                \n', '            }\n', '            \n', '            return tick;\n', '        }\n', '    }\n', '    /*\n', '    function LimitOrders(uint32 orderN, uint32 ownerId, uint32[] prTrade, uint32[] prBase, bool[] isSell, uint80[] price, uint104[] qty) public returns (uint32[])\n', '    {\n', '        require(orderN <= 10 &&  orderN == prTrade.length && orderN == prBase.length && orderN == isSell.length && orderN == price.length && orderN == qty.length);\n', '        \n', '        uint32[] memory orderId = new uint32[](orderN);\n', '        for (uint32 i = 0; i < orderN; i++)\n', '        {\n', '            orderId[i] = LimitOrder(ownerId, prTrade[i], prBase[i], isSell[i], price[i], qty[i]);\n', '        }\n', '        return orderId;\n', '    }\n', '    */\n', '    function LimitOrder(uint32 ownerId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)\n', '    {\n', '        uint32 accountId = FindOrRevertAccount();\n', '        require(accountId_freeze[accountId] == false);\n', '        uint80 lastBestPrice;\n', '        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];\n', '        require(price != 0 && price <= maxPrice && qty <= maxQty &&\n', '            ((isSell == false && prCode_productInfo[prTrade].isTradeBid == true && prCode_productInfo[prBase].isTradeAsk == true) \n', '            || (isSell == true && prCode_productInfo[prTrade].isTradeAsk == true && prCode_productInfo[prBase].isTradeBid == true)) \n', '            && prCode_productInfo[prTrade].minQty <= qty);\n', '        \n', '        if (isSell == true)\n', '        {\n', '            price = GetNextTick(true, price, orderBook.tickSize);\n', '            lastBestPrice = orderBook.bestAskPrice;\n', '        }\n', '        else\n', '        {\n', '            price = GetNextTick(false, price, orderBook.tickSize);\n', '            lastBestPrice = orderBook.bestBidPrice;\n', '        }\n', '        \n', '        Order memory order;\n', '        order.ownerId = ownerId;\n', '        order.isSell = isSell;\n', '        order.prTrade = prTrade;\n', '        order.prBase = prBase;\n', '        order.accountId = accountId;\n', '        order.price = price;\n', '        order.qty = qty;\n', '        //order.timestamp = uint64(now);\n', '        \n', '        require (IsPossibleLimit(order));\n', '        \n', '        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);\n', '\n', '        //uint104 tradedQty = matchOrder(orderBook, order, lastOrderId);\n', '        //BalanceUpdateByLimitAfterTrade(order, qty, tradedQty);\n', '\n', '        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));\n', '\n', '        if (order.qty != 0)\n', '        {\n', '            uint80 priceNext;\n', '            uint80 price0;\n', '            \n', '            if (isSell == true)\n', '            {\n', '                price0 = orderBook.bestAskPrice;\n', '                if (price0 == 0)\n', '                {\n', '                    orderBook.askPrice_Order[price].prevPrice = 0;\n', '                    orderBook.askPrice_Order[price].nextPrice = 0;\n', '                    orderBook.bestAskPrice = price;\n', '                }\n', '                else if(price < price0)\n', '                {\n', '                    orderBook.askPrice_Order[price0].prevPrice = price;\n', '                    orderBook.askPrice_Order[price].prevPrice = 0;\n', '                    orderBook.askPrice_Order[price].nextPrice = price0;\n', '                    orderBook.bestAskPrice = price;\n', '                }\n', '                else if (orderBook.askPrice_Order[price].firstId == 0)// .orderN == 0)\n', '                {\n', '                    priceNext = price0;\n', '                    \n', '                    while (priceNext != 0 && priceNext < price)\n', '                    {\n', '                        price0 = priceNext;\n', '                        priceNext = orderBook.askPrice_Order[price0].nextPrice;\n', '                    }\n', '                    \n', '                    orderBook.askPrice_Order[price0].nextPrice = price;\n', '                    orderBook.askPrice_Order[price].prevPrice = price0;\n', '                    orderBook.askPrice_Order[price].nextPrice = priceNext;\n', '                    if (priceNext != 0)\n', '                    {\n', '                        orderBook.askPrice_Order[priceNext].prevPrice = price;\n', '                    }\n', '                }\n', '                \n', '                OrderLink storage orderLink = orderBook.askPrice_Order[price];\n', '            }\n', '            else\n', '            {\n', '                price0 = orderBook.bestBidPrice;\n', '                if (price0 == 0)\n', '                {\n', '                    orderBook.bidPrice_Order[price].prevPrice = 0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = 0;\n', '                    orderBook.bestBidPrice = price;\n', '                }\n', '                else if (price > price0)\n', '                {\n', '                    orderBook.bidPrice_Order[price0].prevPrice = price;\n', '                    orderBook.bidPrice_Order[price].prevPrice = 0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = price0;\n', '                    orderBook.bestBidPrice = price;\n', '                }\n', '                else if (orderBook.bidPrice_Order[price].firstId == 0)// .orderN == 0)\n', '                {\n', '                    priceNext = price0;\n', '\n', '                    while (priceNext != 0 && priceNext > price)\n', '                    {\n', '                        price0 = priceNext;\n', '                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;\n', '                    }\n', '                    \n', '                    orderBook.bidPrice_Order[price0].nextPrice = price;\n', '                    orderBook.bidPrice_Order[price].prevPrice = price0;\n', '                    orderBook.bidPrice_Order[price].nextPrice = priceNext;\n', '                    if (priceNext != 0)\n', '                    {\n', '                        orderBook.bidPrice_Order[priceNext].prevPrice = price;\n', '                    }\n', '                }\n', '\n', '                orderLink = orderBook.bidPrice_Order[price];\n', '            }\n', '            \n', '            if (lastOrderId != 0)\n', '            {\n', '                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;// .firstID;\n', '                if (orderLink.firstId != 0)\n', '                {\n', '                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;\n', '                }\n', '                else\n', '                {\n', '                    orderLink.id_orderList[lastOrderId].next = 0;\n', '                    orderLink.firstId = lastOrderId;\n', '                }\n', '                orderLink.lastId = lastOrderId;\n', '            }\n', '\n', '            //orderLink.id_orderList.Add(id, listItem);\n', '            //id_Order.Add(id, order);\n', '            //orderLink.id_orderList[lastOrderId] = listItem;\n', '            \n', '            AddOpenOrder(accountId, lastOrderId);\n', '            //orderLink.orderN += 1;\n', '            id_Order[lastOrderId] = order;\n', '            //emit NewHogaChange(prTrade, prBase, isSell, price);\n', '            \n', '        }\n', '\n', '        if (isSell == true && lastBestPrice != orderBook.bestAskPrice)\n', '        {\n', '            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);\n', '        }\n', '        if (isSell == false && lastBestPrice != orderBook.bestBidPrice)\n', '        {\n', '            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);\n', '        }\n', '        \n', '        return lastOrderId;\n', '    }\n', '    \n', '    function BalanceUpdateByLimitAfterTrade(Order order, uint104 qty, uint104 tradedQty) private\n', '    {\n', '        uint32 ownerId = order.ownerId;\n', '        uint32 accountId = order.accountId;\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        uint80 price = order.price;\n', '        uint104 orderQty = order.qty;\n', '        \n', '        //require(qty >= orderQty);// && tradedQty < maxQty);\n', '        \n', '        //Balance storage balance;\n', '        uint32 prTemp;\n', '\n', '        if (order.isSell)\n', '        {\n', '            Balance storage balance = prCode_AccountId_Balance[prTrade][accountId];\n', '            balance.available = Sub(balance.available, qty);\n', '            \n', '            if (orderQty != 0)\n', '                balance.reserved = Add(balance.reserved, orderQty);\n', '\n', '            prTemp = prBase;\n', '        }\n', '        else\n', '        {\n', '            balance = prCode_AccountId_Balance[prBase][accountId];/////\n', '            if (orderQty != 0)\n', '            {\n', '                uint256 temp = prCode_productInfo[prBase].divider * orderQty * price / basePrice / prCode_productInfo[prTrade].divider;\n', '                require (temp < maxQty);\n', '                balance.available = Sub(balance.available, tradedQty + uint104(temp));\n', '                balance.reserved = Add(balance.reserved, uint104(temp));\n', '            }\n', '            else\n', '            {\n', '                balance.available = Sub(balance.available, tradedQty);///////\n', '            }\n', '            tradedQty = qty - orderQty;\n', '\n', '            prTemp = prTrade;\n', '        }\n', '        if (tradedQty != 0)\n', '        {\n', '            uint104 takeFeeMain = tradedQty * takerFeeRateMain / 10000;\n', '            uint104 takeFeeLocal = tradedQty * ownerId_takerFeeRateLocal[ownerId] / 10000;\n', '            prCode_AccountId_Balance[prTemp][accountId].available += tradedQty - takeFeeMain - takeFeeLocal;\n', '            prCode_AccountId_Balance[prTemp][ownerId_accountId[1]].available += takeFeeMain;\n', '            prCode_AccountId_Balance[prTemp][ownerId_accountId[ownerId]].available += takeFeeLocal;\n', '        }\n', '    }\n', '\n', '    function IsPossibleLimit(Order memory order) private view returns (bool)\n', '    {\n', '        if (order.isSell)\n', '        {\n', '            if (prCode_AccountId_Balance[order.prTrade][order.accountId].available >= order.qty)\n', '                return true;\n', '            else\n', '                return false;\n', '        }\n', '        else\n', '        {\n', '            if (prCode_AccountId_Balance[order.prBase][order.accountId].available >= prCode_productInfo[order.prBase].divider * order.qty * order.price / basePrice / prCode_productInfo[order.prTrade].divider)\n', '                return true;\n', '            else\n', '                return false;\n', '        }\n', '    }\n', '\n', '    function matchOrder(OrderBook storage ob, Order memory order, uint32 id) private returns (uint104)//, OrderBook storage orderBook, Order order, uint32 id) private returns (uint104)\n', '    {\n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase; \n', '        uint80 tradePrice;\n', '\n', '        if (order.isSell == true)\n', '            tradePrice = ob.bestBidPrice;\n', '        else\n', '            tradePrice = ob.bestAskPrice;\n', '\n', '        bool isBestPriceUpdate = false;\n', '\n', '        //OrderLink storage orderLink;// = price_OrderLink[tradePrice];\n', '        uint104 qtyBase = 0;\n', '        //Order storage matchingOrder;\n', '        uint104 tradeAmount;\n', '        \n', '        while (tradePrice != 0 && order.qty > 0 && ((order.isSell && order.price <= tradePrice) || (!order.isSell && order.price >= tradePrice)))\n', '        {\n', '            if (order.isSell == true)\n', '                OrderLink storage orderLink = ob.bidPrice_Order[tradePrice];\n', '            else\n', '                orderLink = ob.askPrice_Order[tradePrice];\n', '                \n', '            uint32 orderId = orderLink.firstId;\n', '            \n', '            while (orderLink.firstId != 0 && orderId != 0 && order.qty != 0)\n', '            {\n', '                Order storage matchingOrder = id_Order[orderId];\n', '                if (matchingOrder.qty >= order.qty)\n', '                {\n', '                    tradeAmount = order.qty;\n', '                    matchingOrder.qty -= order.qty;\n', '                    order.qty = 0;\n', '                }\n', '                else\n', '                {\n', '                    tradeAmount = matchingOrder.qty;\n', '                    order.qty -= matchingOrder.qty;\n', '                    matchingOrder.qty = 0;\n', '                }\n', '                \n', '                qtyBase += BalanceUpdateByTradeCp(order, matchingOrder, tradeAmount);\n', '                \n', '                uint32 orderAccountID = order.accountId;\n', '\n', '                if (order.isSell == true)\n', '                    emit NewTrade(prTrade, prBase, orderId, id, matchingOrder.accountId, orderAccountID, true, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\n', '                else\n', '                    emit NewTrade(prTrade, prBase, id, orderId, orderAccountID, matchingOrder.accountId, false, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\n', '                \n', '                if (matchingOrder.qty != 0)\n', '                {\n', '                    //id_Order[tradePrice] = matchingOrder;\n', '                    break;\n', '                }\n', '                else\n', '                {\n', '                    if (RemoveOrder(prTrade, prBase, matchingOrder.isSell, tradePrice, orderId) == true)\n', '                    {\n', '                        RemoveOpenOrder(matchingOrder.accountId, orderId);\n', '                    }\n', '                    orderId = orderLink.firstId;\n', '                }\n', '            }\n', '            \n', '            //emit NewHogaChange(prTrade, prBase, !order.isSell, tradePrice);\n', '\n', '            if (orderLink.firstId == 0)// .orderN == 0)\n', '            {\n', '                tradePrice = orderLink.nextPrice;\n', '                isBestPriceUpdate = true;\n', '            }\n', '        }\n', '        \n', '        if (isBestPriceUpdate == true)\n', '        {\n', '            if (order.isSell)\n', '            {\n', '                ob.bestBidPrice = tradePrice;\n', '            }\n', '            else\n', '            {\n', '                ob.bestAskPrice = tradePrice;\n', '            }\n', '            \n', '            emit NewBestBidAsk(prTrade, prBase, !order.isSell, tradePrice);\n', '        }\n', '\n', '        return qtyBase;\n', '    }\n', '    \n', '    function BalanceUpdateByTradeCp(Order order, Order matchingOrder, uint104 tradeAmount) private returns (uint104)\n', '    {\n', '        uint32 accountId = matchingOrder.accountId;\n', '        uint32 prTrade = order.prTrade; \n', '        uint32 prBase = order.prBase; \n', '        require (tradeAmount < maxQty);\n', '        uint256 qtyBase = prCode_productInfo[prBase].divider * tradeAmount * matchingOrder.price / basePrice / prCode_productInfo[prTrade].divider;\n', '        require (qtyBase < maxQty);\n', '        /*\n', '        if (order.isSell == true)\n', '        {\n', '            prCode_AccountId_Balance[prTrade][accountId].available = SafeMath.Add(prCode_AccountId_Balance[prTrade][accountId].available, tradeAmount);\n', '            prCode_AccountId_Balance[prBase][accountId].reserved = SafeMath.Sub(prCode_AccountId_Balance[prBase][accountId].reserved, uint104(qtyBase));\n', '        }\n', '        else\n', '        {\n', '            prCode_AccountId_Balance[prTrade][accountId].reserved = SafeMath.Sub(prCode_AccountId_Balance[prTrade][accountId].reserved, tradeAmount);\n', '            prCode_AccountId_Balance[prBase][accountId].available = SafeMath.Add(prCode_AccountId_Balance[prBase][accountId].available, uint104(qtyBase));\n', '        }\n', '        */\n', '        Balance storage balanceTrade = prCode_AccountId_Balance[prTrade][accountId];\n', '        Balance storage balanceBase = prCode_AccountId_Balance[prBase][accountId];\n', '        \n', '        if (order.isSell == true)\n', '        {\n', '            balanceTrade.available = SafeMath.Add(balanceTrade.available, tradeAmount);\n', '            balanceBase.reserved = SafeMath.Sub(balanceBase.reserved, uint104(qtyBase));\n', '        }\n', '        else\n', '        {\n', '            balanceTrade.reserved = SafeMath.Sub(balanceTrade.reserved, tradeAmount);\n', '            balanceBase.available = SafeMath.Add(balanceBase.available, uint104(qtyBase));\n', '        }\n', '\n', '        return uint104(qtyBase);\n', '    }\n', '    \n', '    function RemoveOrder(uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint32 id) private returns (bool)\n', '    {\n', '        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\n', '        \n', '        if (isSell == false)\n', '        {\n', '            OrderLink storage orderLink = ob.bidPrice_Order[price];\n', '        }\n', '        else\n', '        {\n', '            orderLink = ob.askPrice_Order[price];\n', '        }\n', '        \n', '        if (id != 0)\n', '        {\n', '            ListItem memory removeItem = orderLink.id_orderList[id];\n', '            if (removeItem.next != 0)\n', '            {\n', '                orderLink.id_orderList[removeItem.next].prev = removeItem.prev;\n', '            }\n', '\n', '            if (removeItem.prev != 0)\n', '            {\n', '                orderLink.id_orderList[removeItem.prev].next = removeItem.next;\n', '            }\n', '\n', '            if (id == orderLink.lastId)\n', '            {\n', '                orderLink.lastId = removeItem.prev;\n', '            }\n', '            \n', '            if (id == orderLink.firstId)\n', '            {\n', '                orderLink.firstId = removeItem.next;\n', '            }\n', '\n', '            delete orderLink.id_orderList[id];\n', '\n', '            if (orderLink.firstId == 0)\n', '            {\n', '                if (orderLink.nextPrice != 0)\n', '                {\n', '                    if (isSell == true)\n', '                        OrderLink storage replaceLink = ob.askPrice_Order[orderLink.nextPrice];\n', '                    else\n', '                        replaceLink = ob.bidPrice_Order[orderLink.nextPrice];\n', '\n', '                    replaceLink.prevPrice = orderLink.prevPrice;\n', '                }\n', '                if (orderLink.prevPrice != 0)\n', '                {\n', '                    if (isSell == true)\n', '                        replaceLink = ob.askPrice_Order[orderLink.prevPrice];\n', '                    else\n', '                        replaceLink = ob.bidPrice_Order[orderLink.prevPrice];\n', '\n', '                    replaceLink.nextPrice = orderLink.nextPrice;\n', '                }\n', '\n', '                if (price == ob.bestAskPrice)\n', '                {\n', '                    ob.bestAskPrice = orderLink.nextPrice;\n', '                }\n', '                if (price == ob.bestBidPrice)\n', '                {\n', '                    ob.bestBidPrice = orderLink.nextPrice;\n', '                }\n', '            }\n', '            return true;\n', '        }\n', '        else    \n', '        {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function cancelOrders(uint32[] id) public\n', '    {\n', '        for (uint32 i = 0; i < id.length; i++)\n', '        {\n', '            cancelOrder(id[i]);\n', '        }\n', '    }\n', '    \n', '    function cancelOrder(uint32 id) public returns (bool)\n', '    {\n', '        Order memory order = id_Order[id];\n', '        uint32 accountId = account_id[msg.sender];\n', '        require(order.accountId == accountId);\n', '        \n', '        uint32 prTrade = order.prTrade;\n', '        uint32 prBase = order.prBase;\n', '        bool isSell = order.isSell;\n', '        uint80 price = order.price;\n', '        uint104 qty = order.qty;\n', '        \n', '        if (RemoveOrder(prTrade, prBase, isSell, price, id) == false)\n', '            return false;\n', '        else\n', '        {\n', '            RemoveOpenOrder(accountId, id);\n', '        }\n', '\n', '        //Balance storage balance;\n', '        \n', '        if (isSell)\n', '        {\n', '            Balance storage balance = prCode_AccountId_Balance[prTrade][accountId];\n', '            balance.available = SafeMath.Add(balance.available, qty);\n', '            balance.reserved = SafeMath.Sub(balance.reserved, qty);\n', '        }\n', '        else\n', '        {\n', '            balance = prCode_AccountId_Balance[prBase][accountId];\n', '            uint256 temp = prCode_productInfo[prBase].divider * qty * price / basePrice / prCode_productInfo[prTrade].divider;\n', '            require (temp < maxQty);\n', '            balance.available = SafeMath.Add(balance.available, uint104(temp));\n', '            balance.reserved = SafeMath.Sub(balance.reserved, uint104(temp));\n', '        }\n', '\n', '        //RemoveOrder(prTrade, prBase, isSell, price, id);//, msg);\n', '        //emit NewHogaChange(prTrade, prBase, isSell, order.price);\n', '        \n', '        emit NewCancel(prTrade, prBase, accountId, id, isSell, price, qty, lastNewOrderId++);\n', '        return true;\n', '    }\n', '    function checkAnnounceLV(uint32 accountId, uint8 LV) private view\n', '    {\n', '        require(accountId == account_id[msg.sender] || id_announceLV[accountId] >= LV || msg.sender == operator || owner_id[msg.sender] != 0);\n', '    }\n', '    /*\n', '    function getBalance(uint32[] prCode) view public returns (uint128[] available, uint128[] reserved)\n', '    {\n', '        (available, reserved) = getBalance(prCode, msg.sender);\n', '    }\n', '      */\n', '    function getBalance(uint32[] prCode, uint32 accountId) view public returns (uint128[] available, uint128[] reserved)\n', '    {\n', '        if (accountId == 0)\n', '            accountId = account_id[msg.sender];\n', '        checkAnnounceLV(accountId, 2);\n', '        \n', '        uint256 n = prCode.length;\n', '        available = new uint128[](n);\n', '        reserved = new uint128[](n);\n', '        \n', '        for (uint32 i = 0; i < n; i++)\n', '        {\n', '            available[i] = prCode_AccountId_Balance[prCode[i]][accountId].available;\n', '            reserved[i] = prCode_AccountId_Balance[prCode[i]][accountId].reserved;\n', '        }\n', '    }\n', '    \n', '    function getBalanceByProduct(uint32 prCode, uint128 minQty) view public returns (uint32[] accountId, uint128[] balanceSum)\n', '    {\n', '        require (owner_id[msg.sender] != 0 || msg.sender == operator);\n', '        uint32 n = 0;\n', '        for (uint32 i = 1; i <= lastAcccountId; i++)//Bug0319\n', '        {\n', '            if (prCode_AccountId_Balance[prCode][i].available + prCode_AccountId_Balance[prCode][i].reserved >= minQty)\n', '                n++;\n', '        }\n', '        accountId = new uint32[](n);\n', '        balanceSum = new uint128[](n);\n', '        \n', '        n = 0;\n', '        uint128 temp;\n', '        for (i = 1; i <= lastAcccountId; i++)//Bug0319\n', '        {\n', '            temp = prCode_AccountId_Balance[prCode][i].available + prCode_AccountId_Balance[prCode][i].reserved;\n', '            if (temp >= minQty)//Bug0319\n', '            {\n', '                accountId[n] = i;\n', '                balanceSum[n++] = temp;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getOrderBookInfo(uint32[] prTrade, uint32 prBase) view public returns (uint80[] bestBidPrice, uint80[] bestAskPrice)\n', '    {\n', '        uint256 n = prTrade.length;\n', '        //require(n == prBase.length);\n', '        bestBidPrice = new uint80[](n);//prTrade.length);\n', '        bestAskPrice = new uint80[](n);//prTrade.length);\n', '        \n', '        for (uint256 i = 0; i < n; i++)\n', '        {\n', '            OrderBook memory orderBook = basePID_tradePID_orderBook[prBase][prTrade[i]];// iCode_OrderBook[prCode];\n', '            bestBidPrice[i] = orderBook.bestBidPrice;\n', '            bestAskPrice[i] = orderBook.bestAskPrice;\n', '        }\n', '    }\n', '    /*\n', '    function getOrder(uint32[] id) view public returns (uint32[] prTrade, uint32[] prBase, bool[] sell, uint80[] price, uint104[] qty)\n', '    {\n', '        uint256 n = id.length;\n', '        prTrade = new uint32[](n);\n', '        prBase = new uint32[](n);\n', '        sell = new bool[](n);\n', '        price = new uint80[](n);\n', '        qty = new uint104[](n);\n', '        \n', '        for (uint256 i = 0; i < n; i++)\n', '        {\n', '            Order memory order = id_Order[id[i]];\n', '            prTrade[i] = order.prTrade;\n', '            prBase[i] = order.prBase;\n', '            sell[i] = order.isSell;\n', '            price[i] = order.price;\n', '            qty[i] = order.qty;\n', '        }\n', '    }\n', '    */\n', '    \n', '    function getOrder(uint32 id) view public returns (uint32 prTrade, uint32 prBase, bool sell, uint80 price, uint104 qty, uint32 accountId)//, uint64 timestamp)\n', '    {\n', '        Order memory order = id_Order[id];\n', '        \n', '        accountId = order.accountId;\n', '        checkAnnounceLV(accountId, 4);\n', '        \n', '        prTrade = order.prTrade;\n', '        prBase = order.prBase;\n', '        price = order.price;\n', '        sell = order.isSell;\n', '        qty = order.qty;\n', '        //timestamp = order.timestamp;\n', '    }\n', '    \n', '    function GetMyOrders(uint32 accountId) view public returns (uint32[] orderId, uint32[] prTrade, uint32[] prBase, bool[] sells, uint80[] prices, uint104[] qtys)//, uint64[] timestamp)\n', '    {\n', '        if (accountId == 0)\n', '            accountId = account_id[msg.sender];\n', '        \n', '        checkAnnounceLV(accountId, 4);\n', '        \n', '        OpenOrder storage openOrder = accountId_OpenOrder[accountId];\n', '     \n', '        uint32 id = accountId_OpenOrder[accountId].startId;\n', '        uint32 orderN = 0;\n', '        while (id != 0)\n', '        {\n', '            id = openOrder.id_orderList[id].next;\n', '            orderN++;\n', '        }\n', '\n', '        orderId = new uint32[](orderN);\n', '        prTrade = new uint32[](orderN);\n', '        prBase = new uint32[](orderN);\n', '        qtys = new uint104[](orderN);\n', '        prices = new uint80[](orderN);\n', '        sells = new bool[](orderN);\n', '        //timestamp = new uint64[](orderN);\n', '        \n', '        id = openOrder.startId;\n', '        if (id != 0)\n', '        {\n', '            Order memory order;\n', '            uint32 i = 0;\n', '            while (id != 0)\n', '            {\n', '                order = id_Order[id];\n', '                \n', '                orderId[i] = id;\n', '                prTrade[i] = order.prTrade;\n', '                prBase[i] = order.prBase;\n', '                qtys[i] = order.qty;\n', '                prices[i] = order.price;\n', '                sells[i++] = order.isSell;\n', '                //timestamp[i++] = order.timestamp;\n', '\n', '                id = openOrder.id_orderList[id].next;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function GetHogaDetail(uint32 prTrade, uint32 prBase, uint80 price, bool isSell) view public returns (uint32[] orderIds)\n', '    {\n', '        if (isSell == false)\n', '        {\n', '            OrderLink storage orderLink = basePID_tradePID_orderBook[prBase][prTrade].bidPrice_Order[price];\n', '        }\n', '        else if (isSell == true)\n', '        {\n', '            orderLink = basePID_tradePID_orderBook[prBase][prTrade].askPrice_Order[price];\n', '        }\n', '        else\n', '        {\n', '            return;\n', '        }\n', '        \n', '        uint32 n = 0;\n', '        uint32 id0 = orderLink.firstId;\n', '        while (id0 != 0)\n', '        {\n', '            id0 = orderLink.id_orderList[id0].next;\n', '            n++;\n', '        }\n', '        \n', '        orderIds = new uint32[](n);\n', '        n = 0;\n', '        id0 = orderLink.firstId;\n', '        while (id0 != 0)\n', '        {\n', '            orderIds[n++] = id0;\n', '            id0 = orderLink.id_orderList[id0].next;\n', '        }\n', '    }\n', '    \n', '    function GetHoga(uint32 prTrade, uint32 prBase, uint32 hogaN) public view returns (uint80[] priceB, uint104[] volumeB, uint80[] priceA, uint104[] volumeA)\n', '    {\n', '        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\n', '        \n', '        (priceB, volumeB) = GetHoga(ob, hogaN, false);\n', '        (priceA, volumeA) = GetHoga(ob, hogaN, true);\n', '    }\n', '    \n', '    function GetHoga(OrderBook storage ob, uint32 hogaN, bool isSell) private view returns (uint80[] prices, uint104[] volumes)\n', '    {\n', '        prices = new uint80[](hogaN);\n', '        volumes = new uint104[](hogaN);\n', '        \n', '        uint32 n;\n', '        uint32 id0;\n', '        uint80 price;\n', '        uint104 sum;\n', '        \n', '        if (isSell == false)\n', '            price = ob.bestBidPrice;\n', '        else\n', '            price = ob.bestAskPrice;// .bestBidPrice;\n', '        \n', '        if (price != 0)\n', '        {\n', '            n = 0;\n', '            while (price != 0 && n < hogaN)\n', '            {\n', '                if (isSell == false)\n', '                    OrderLink storage orderLink = ob.bidPrice_Order[price];\n', '                else\n', '                    orderLink = ob.askPrice_Order[price];\n', '                \n', '                id0 = orderLink.firstId;\n', '                sum = 0;\n', '                while (id0 != 0)\n', '                {\n', '                    sum += id_Order[id0].qty;\n', '                    id0 = orderLink.id_orderList[id0].next;\n', '                }\n', '                prices[n] = price;\n', '                volumes[n] = sum;\n', '                price = orderLink.nextPrice;\n', '                n++;\n', '            }\n', '\n', '            if (n > 0)\n', '            {\n', '                while (n < hogaN)\n', '                {\n', '                    if (isSell == true)\n', '                        prices[n] = GetNextTick(true, prices[n - 1] + 1, ob.tickSize);\n', '                    else\n', '                        prices[n] = GetNextTick(false, prices[n - 1] - 1, ob.tickSize);\n', '                    n++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']