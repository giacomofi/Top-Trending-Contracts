['pragma solidity ^0.4.24;\n', '\n', '/*\n', '    _______       __    __     ________      __  \n', '   / ____(_)___ _/ /_  / /_   / ____/ /_  __/ /_ \n', '  / /_  / / __ `/ __ \\/ __/  / /   / / / / / __ \\\n', ' / __/ / / /_/ / / / / /_   / /___/ / /_/ / /_/ /\n', '/_/   /_/\\__, /_/ /_/\\__/   \\____/_/\\__,_/_.___/ \n', '        /____/                                   \n', '\n', '\n', 'Fight Club\n', '\n', 'https://ethfightclub.com\n', '\n', 'The Decentralized Ranking Site where YOU choose the winner\n', '\n', 'Promoters can add any two fighters for a fee\n', '\n', 'Enter the fighters names and image link\n', '\n', 'Image link should be in a format like this:   https://i.etsystatic.com/14392680/r/il/84f51c/1325571098/il_570xN.1325571098_p21w.jpg\n', '\n', 'Players can vote on either fighter\n', '\n', 'The winning fighter is the one who has the most votes when time runs out\n', '\n', 'The players who voted on the winning fighter receive \n', 'a portion of 20% of all vote fees for the winning fighter\n', '\n', 'Promoters receive 50% of all vote fees\n', '\n', '*/\n', '\n', '\n', 'contract fightclub {\n', '\n', '    event newvote(\n', '        uint rankid\n', '    );\n', '\n', '    mapping (uint => address[]) public voter1Add;\n', '    mapping (uint => address[]) public voter2Add;\n', '\n', '\n', '    //mapping (uint => string) categories;\n', '    mapping (uint => string) public fighter1Name;  \n', '    mapping (uint => string) public fighter2Name;  \n', '    mapping (uint => string) public fighter1Image;  \n', '    mapping (uint => string) public fighter2Image; \n', '    mapping (uint => uint) public fightEndTime; \n', '    mapping (uint => bool) public fightActive;\n', '\n', '    mapping(uint => uint) public voteCount1;\n', '    mapping(uint => uint) public voteCount2;\n', '\n', '    mapping(uint => address) public promoter;      //map promoter address to fight\n', '    mapping(uint => string) public promoterName;   //map promoter name to fight\n', '\n', '    mapping(address => uint) public accounts;      //player and promoter accounts for withdrawal\n', '    mapping(address => string) public playerName;      //players can enter an optional nickname\n', '    mapping(uint => uint) public fightPool;        //Reward Pool for each fight\n', ' \n', '\n', '    uint public votePrice = 0.001 ether;\n', '    uint public promotePrice = 0.05 ether;\n', '    \n', '    uint public ownerFeeRate = 15;\n', '    uint public promoterFeeRate = 15;\n', '    uint public playerFeeRate = 70;\n', '\n', '    uint public fightLength = 17700; //3 days\n', '\n', '    uint public fightCount = 0;\n', '    \n', '    uint public ownerAccount = 0;\n', '\n', '    address owner;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function vote(uint fightID, uint fighter) public payable\n', '    {\n', '\n', '        require(msg.value >= votePrice);\n', '        require(fighter == 1 || fighter == 2);\n', '        require(fightActive[fightID]);\n', '        uint ownerFee;\n', '        uint authorFee;\n', '        uint fightPoolFee;\n', '\n', '        ownerFee = SafeMath.div(SafeMath.mul(msg.value,ownerFeeRate),100);\n', '        authorFee = SafeMath.div(SafeMath.mul(msg.value,promoterFeeRate),100);\n', '        fightPoolFee = SafeMath.div(SafeMath.mul(msg.value,playerFeeRate),100);\n', '\n', '        accounts[owner] = SafeMath.add(accounts[owner], ownerFee);\n', '        accounts[promoter[fightID]] = SafeMath.add(accounts[promoter[fightID]], authorFee);\n', '        fightPool[fightID] = SafeMath.add(fightPool[fightID], fightPoolFee);\n', '\n', '        if (fighter == 1) {\n', '            //vote1[fightID].push(1);\n', '            //voter1[fightID][voteCount1] = 1;//msg.sender;\n', '            voter1Add[fightID].push(msg.sender);\n', '        } else {\n', '            //vote2[fightID].push(1);\n', '            //voter2[fightID][voter2[fightID].length] = msg.sender;\n', '            voter2Add[fightID].push(msg.sender);\n', '        }\n', '    }\n', '\n', '    function promoteFight(string _fighter1Name, string _fighter2Name, string _fighter1Image, string _fighter2Image) public payable\n', '    {\n', '        require(msg.value >= promotePrice || msg.sender == owner);\n', '        fightActive[fightCount] = true;\n', '        uint ownerFee;\n', '        ownerFee = msg.value;\n', '        accounts[owner] = SafeMath.add(accounts[owner], ownerFee);\n', '\n', '        promoter[fightCount] = msg.sender;\n', '\n', '        fightEndTime[fightCount] = block.number + fightLength;\n', '\n', '        fighter1Name[fightCount] = _fighter1Name;\n', '        fighter2Name[fightCount] = _fighter2Name;\n', '\n', '        fighter1Image[fightCount] = _fighter1Image;\n', '        fighter2Image[fightCount] = _fighter2Image;\n', '\n', '        fightCount += 1;\n', '\n', '\n', '    }\n', '\n', '    function endFight(uint fightID) public \n', '    {\n', '        require(block.number > fightEndTime[fightID] || msg.sender == owner);\n', '        require(fightActive[fightID]);\n', '        uint voterAmount;\n', '        uint payoutRemaining;\n', '\n', '        fightActive[fightID] = false;\n', '\n', '\n', '        //determine winner and distribute funds\n', '        if (voter1Add[fightID].length > voter2Add[fightID].length)\n', '        {\n', '            payoutRemaining = fightPool[fightID];\n', '            voterAmount = SafeMath.div(fightPool[fightID],voter1Add[fightID].length);\n', '            for (uint i1 = 0; i1 < voter1Add[fightID].length; i1++)\n', '                {\n', '                    if (payoutRemaining >= voterAmount)\n', '                    {\n', '                        accounts[voter1Add[fightID][i1]] = SafeMath.add(accounts[voter1Add[fightID][i1]], voterAmount);\n', '                        payoutRemaining = SafeMath.sub(payoutRemaining,voterAmount);\n', '                    } else {\n', '                        accounts[voter1Add[fightID][i1]] = SafeMath.add(accounts[voter1Add[fightID][i1]], payoutRemaining);\n', '                    }\n', '                    \n', '                }\n', '            \n', '        }\n', '\n', '        if (voter1Add[fightID].length < voter2Add[fightID].length)\n', '        {\n', '            payoutRemaining = fightPool[fightID];\n', '            voterAmount = SafeMath.div(fightPool[fightID],voter2Add[fightID].length);\n', '            for (uint i2 = 0; i2 < voter2Add[fightID].length; i2++)\n', '                {\n', '                    if (payoutRemaining >= voterAmount)\n', '                    {\n', '                        accounts[voter2Add[fightID][i2]] = SafeMath.add(accounts[voter2Add[fightID][i2]], voterAmount);\n', '                        payoutRemaining = SafeMath.sub(payoutRemaining,voterAmount);\n', '                    } else {\n', '                        accounts[voter2Add[fightID][i2]] = SafeMath.add(accounts[voter2Add[fightID][i2]], payoutRemaining);\n', '                    }\n', '                    \n', '                }\n', '        }\n', '\n', '        if (voter1Add[fightID].length == voter2Add[fightID].length)\n', '        {\n', '            payoutRemaining = fightPool[fightID];\n', '            voterAmount = SafeMath.div(fightPool[fightID],voter1Add[fightID].length + voter2Add[fightID].length);\n', '            for (uint i3 = 0; i3 < voter1Add[fightID].length; i3++)\n', '                {\n', '                    if (payoutRemaining >= voterAmount)\n', '                    {\n', '                        accounts[voter1Add[fightID][i3]] = SafeMath.add(accounts[voter1Add[fightID][i3]], voterAmount);\n', '                        accounts[voter2Add[fightID][i3]] = SafeMath.add(accounts[voter2Add[fightID][i3]], voterAmount);\n', '                        payoutRemaining = SafeMath.sub(payoutRemaining,voterAmount + voterAmount);\n', '                    }\n', '                    \n', '                }\n', '\n', '        }\n', '\n', '        \n', '\n', '    }\n', '\n', '\n', '    function ownerWithdraw() \n', '    {\n', '        require(msg.sender == owner);\n', '        uint tempAmount = ownerAccount;\n', '        ownerAccount = 0;\n', '        owner.transfer(tempAmount);\n', '    }\n', '\n', '    function withdraw() \n', '    {\n', '        uint tempAmount = accounts[msg.sender];\n', '        accounts[msg.sender] = 0;\n', '        msg.sender.transfer(tempAmount);\n', '    }\n', '\n', '    function getFightData(uint fightID) public view returns(string, string, string, string, uint, uint, uint)\n', '    {\n', '        return(fighter1Name[fightID], fighter2Name[fightID], fighter1Image[fightID], fighter2Image[fightID], voter1Add[fightID].length, voter2Add[fightID].length, fightEndTime[fightID]);\n', '    }\n', '\n', '    function setPrices(uint _votePrice, uint _promotePrice) public \n', '    {\n', '        require(msg.sender == owner);\n', '        votePrice = _votePrice;\n', '        promotePrice = _promotePrice;\n', '\n', '    }\n', '\n', '     function setFightLength(uint _fightLength) public \n', '    {\n', '        require(msg.sender == owner);\n', '        fightLength = _fightLength;\n', '\n', '    }\n', '\n', '    function setRates(uint _ownerRate, uint _promoterRate, uint _playerRate) public \n', '    {\n', '        require(msg.sender == owner);\n', '        require(_ownerRate + _promoterRate + _playerRate == 100);\n', '        ownerFeeRate = _ownerRate;\n', '        promoterFeeRate = _promoterRate;\n', '        playerFeeRate = _playerRate;\n', '\n', '    }\n', '\n', '    function setImages(uint _fightID, string _fighter1Image, string _fighter2Image) public \n', '    {\n', '        require(msg.sender == promoter[_fightID]);\n', '        fighter1Image[fightCount] = _fighter1Image;\n', '        fighter2Image[fightCount] = _fighter2Image;\n', '\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', ' \n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', ' \n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', ' \n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']