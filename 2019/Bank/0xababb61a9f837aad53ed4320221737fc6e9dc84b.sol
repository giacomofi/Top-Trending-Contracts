['pragma solidity >=0.5;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title DexStatus\n', ' * @dev Status for Dex  \n', ' */ \n', 'contract DexStatus {\n', '    string constant ONLY_RELAYER    = "ONLY_RELAYER";\n', '    string constant ONLY_AIRDROP    = "ONLY_AIRDROP"; \n', '    string constant ONLY_INACTIVITY = "ONLY_INACTIVITY";\n', '    string constant ONLY_WITHDRAWALAPPROVED = "ONLY_WITHDRAWALAPPROVED";\n', '\n', '    string constant INVALID_NONCE  = "INVALID_NONCE";  \n', '    string constant INVALID_PERIOD = "INVALID_PERIOD";\n', '    string constant INVALID_AMOUNT = "INVALID_AMOUNT";\n', '    string constant INVALID_TIME   = "INVALID_TIME";\n', '    string constant INVALID_GASTOKEN = "INVALID_GASTOKEN";\n', '\n', '    string constant TRANSFER_FAILED = "TRANSFER_FAILED";\n', '    string constant ECRECOVER_FAILED  = "ECRECOVER_FAILED";\n', '\n', '    string constant INSUFFICIENT_FOUND = "INSUFFICIENT";  \n', '    string constant TRADE_EXISTS       = "TRADED";\n', '    string constant WITHDRAW_EXISTS    = "WITHDRAWN";\n', '\n', '    string constant MAX_VALUE_LIMIT = "MAX_LIMIT";\n', '\n', '    string constant AMOUNT_EXCEEDED = "AMOUNT_EXCEEDED"; \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title IGasStorage\n', ' * @dev  GasStorage interface to burn and mint gastoken\n', ' */\n', 'interface IGasStorage\n', '{\n', '    function mint(uint256 value) external;\n', '    function burn(uint256 value) external;\n', '    function balanceOf() external view returns (uint256 balance);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = tx.origin;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/** \n', ' * @dev ERC20 interface\n', ' */\n', 'interface ERC20 {  \n', '    function balanceOf(address _owner) external view returns (uint256 balance); \n', '    function transfer(address _to, uint256 _value) external returns (bool success) ; \n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); \n', '    function approve(address _spender, uint256 _value) external returns (bool success); \n', '    function allowance(address _owner, address _spender) view external returns (uint256 remaining); \n', '}\n', ' \n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '  \n', ' \n', '\n', ' \n', '\n', '/**\n', ' * @title Dex\n', ' * @dev Smart contract for https://www.dex.io\n', ' */ \n', 'contract Dex is Ownable,DexStatus {  \n', '    using SafeMath for uint256;     \n', '    \n', '    struct Order\n', '    {\n', '        address token;\n', '        address baseToken; \n', '        address user;  \n', '        uint256 tokenAmount;\n', '        uint256 baseTokenAmount;\n', '        uint    nonce;\n', '        uint    expireTime;  \n', '        uint    maxGasFee;  \n', '        uint    timestamp;\n', '        address gasToken;  \n', '        bool    sell;\n', '        uint8   V;\n', '        bytes32 R;\n', '        bytes32 S;  \n', '        uint    signType;\n', '    } \n', '\n', '    struct TradeInfo {\n', '        uint256 tradeTokenAmount;   \n', '        uint256 tradeTakerFee;\n', '        uint256 tradeMakerFee;    \n', '        uint256 tradeGasFee;\n', '        uint    tradeNonce; \n', '        address tradeGasToken;  \n', '    }    \n', '\n', '    mapping (address => mapping (address => uint256)) public _balances;  \n', '\n', '    mapping (address => uint)     public _invalidOrderNonce;     \n', '\n', '    mapping (bytes32 => uint256)  public _orderFills;\n', '\n', '    mapping (address => bool)     public _relayers;\n', '\n', '    mapping (bytes32 => bool)     public _traded;\n', '    mapping (bytes32 => bool)     public _withdrawn;   \n', '     \n', '    mapping (bytes32 => uint256)  public _orderGasFee; \n', '  \n', '    mapping (address => uint)     public _withdrawalApplication;\n', '\n', '    address public       _feeAccount; \n', '    address public       _airdropContract;  \n', '    address public       _gasStorage;\n', '\n', '    uint256 public _withdrawalApplicationPeriod = 10 days;\n', ' \n', '    uint256 public _takerFeeRate   = 0.002 ether;\n', '    uint256 public _makerFeeRate   = 0.001 ether;    \n', ' \n', '    string  private constant EIP712DOMAIN_TYPE  = "EIP712Domain(string name)";\n', '    bytes32 private constant EIP712DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712DOMAIN_TYPE)); \n', '    bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH,keccak256(bytes("Dex.io"))));\n', ' \n', '    string  private constant  ORDER_TYPE = "Order(address token,address baseToken,uint256 tokenAmount,uint256 baseTokenAmount,uint256 nonce,bool sell,uint256 expireTime,uint256 maxGasFee,address gasToken,uint timestamp)";    \n', '    bytes32 private constant  ORDER_TYPEHASH = keccak256(abi.encodePacked(ORDER_TYPE)); \n', '    \n', '    string  private constant  WITHDRAW_TYPE = "Withdraw(address token,uint256 tokenAmount,address to,uint256 nonce,address feeToken,uint256 feeWithdrawal,uint timestamp)";    \n', '    bytes32 private constant  WITHDRAW_TYPEHASH = keccak256(abi.encodePacked(WITHDRAW_TYPE));\n', '\n', '    event Trade(bytes32 takerHash,bytes32 makerHash,uint256 tradeAmount,uint256 tradeBaseTokenAmount,uint256 tradeNonce,uint256 takerCostFee,\n', '          uint makerCostFee,bool sellerIsMaker,uint256 gasFee);\n', '\n', '    event Balance(uint256 takerBaseTokenBalance,uint256 takerTokenBalance,uint256 makerBaseTokenBalance,uint256 makerTokenBalance); \n', '\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '    event Withdraw(address indexed token,address indexed from,address indexed to, uint256 amount, uint256 balance); \n', '    event Transfer(address indexed token,address indexed from,address indexed to, uint256 amount, uint256 fromBalance,uint256 toBalance); \n', '    event Airdrop(address indexed to, address indexed token,uint256 amount); \n', '\n', '    event WithdrawalApplication(address user,uint timestamp);\n', '\n', '    modifier onlyRelayer {\n', '        if (msg.sender != owner && !_relayers[msg.sender]) revert(ONLY_RELAYER);\n', '        _;\n', '    } \n', '\n', '    modifier onlyAirdropContract {\n', '        if (msg.sender != _airdropContract) revert(ONLY_AIRDROP);\n', '        _;\n', '    }   \n', ' \n', '    /** \n', '    *  @dev approved in 10 days \n', '    */  \n', '    modifier onlyWithdrawalApplicationApproved  {\n', '        require (\n', '             _withdrawalApplication[msg.sender] != uint(0) &&\n', '             block.timestamp - _withdrawalApplicationPeriod > _withdrawalApplication[msg.sender],\n', '             ONLY_WITHDRAWALAPPROVED);\n', '        _;\n', '    }   \n', '\n', '  \n', '    /** \n', '    *  @param feeAccount  account to receive the fee\n', '    */  \n', '    constructor(address feeAccount) public { \n', '        _feeAccount = feeAccount;  \n', '    }\n', '\n', '    /** \n', '    *  @dev do no send eth to dex contract directly.\n', '    */\n', '    function() external {\n', '        revert();\n', '    }  \n', '  \n', '    /** \n', '    *  @dev set a relayer\n', '    */ \n', '    function setRelayer(address relayer, bool isRelayer) public onlyOwner {\n', '        _relayers[relayer] = isRelayer;\n', '    } \n', ' \n', '    /** \n', '    *  @dev check a relayer\n', '    */ \n', '    function isRelayer(address relayer) public view returns(bool)  {\n', '        return _relayers[relayer];\n', '    } \n', ' \n', '    /** \n', '    *  @dev set account that receive the fee\n', '    */ \n', '    function setFeeAccount(address feeAccount) public onlyOwner {\n', '        _feeAccount = feeAccount;\n', '    }\n', ' \n', '    /** \n', '    *  @dev set set maker and taker fee rate\n', "    *  @param makerFeeRate maker fee rate can't be more than 0.5%\n", "    *  @param takerFeeRate taker fee rate can't be more than 0.5%\n", '    */ \n', '    function setFee(uint256 makerFeeRate,uint256 takerFeeRate) public onlyOwner { \n', '\n', '        require(makerFeeRate <=  0.005 ether && takerFeeRate <=  0.005 ether,MAX_VALUE_LIMIT); \n', '\n', '        _makerFeeRate = makerFeeRate;\n', '        _takerFeeRate = takerFeeRate; \n', '    }   \n', '  \n', '    /** \n', '    *  @dev set gasStorage contract to save gas\n', '    */ \n', '    function setGasStorage(address gasStorage) public onlyOwner {\n', '        _gasStorage = gasStorage;\n', '    }\n', ' \n', '    /** \n', '    *  @dev set airdrop contract to implement airdrop function\n', '    */ \n', '    function setAirdrop(address airdrop) public onlyOwner{\n', '        _airdropContract = airdrop;\n', '    }\n', ' \n', '    /** \n', '    *  @dev set withdraw application period\n', "    *  @param period the period can't be more than 10 days\n", '    */ \n', '    function setWithdrawalApplicationPeriod(uint period) public onlyOwner {\n', '\n', '        if(period > 10 days ){\n', '            return;\n', '        }\n', '\n', '        _withdrawalApplicationPeriod = period; \n', '    }\n', ' \n', '    /** \n', '    *  @dev invalid the orders before nonce\n', '    */ \n', '    function invalidateOrdersBefore(address user, uint256 nonce) public onlyRelayer {\n', '        if (nonce < _invalidOrderNonce[user]) {\n', '            revert(INVALID_NONCE);   \n', '        }\n', '\n', '        _invalidOrderNonce[user] = nonce;\n', '    } \n', '  \n', '    /** \n', '    *  @dev deposit token \n', '    */ \n', '    function depositToken(address token, uint256 amount)  public {  \n', '        require(ERC20(token).transferFrom(msg.sender, address(this), amount),TRANSFER_FAILED); \n', '        _deposit(msg.sender,token,amount); \n', '    }\n', ' \n', '    /** \n', '    *  @dev deposit token from msg.sender to someone\n', '    */ \n', '    function depositTokenTo(address to,address token, uint256 amount)  public {  \n', '        require(ERC20(token).transferFrom(msg.sender, address(this), amount),TRANSFER_FAILED); \n', '        _deposit(to,token,amount); \n', '    }\n', '\n', '    /** \n', '    *  @dev deposit eth\n', '    */ \n', '    function deposit() public payable { \n', '        _deposit(msg.sender,address(0),msg.value); \n', '    }\n', ' \n', '    /** \n', '    *  @dev deposit eth from msg.sender to someone\n', '    */ \n', '    function depositTo(address to) public payable {\n', '        _deposit(to,address(0),msg.value);\n', '    } \n', ' \n', '    /** \n', '    *  @dev _deposit\n', '    */ \n', '    function _deposit(address user,address token,uint256 amount) internal {\n', '    \n', '        _balances[token][user] = _balances[token][user].add(amount);   \n', '        \n', '        emit Deposit(token, user, amount, _balances[token][user]);\n', '    } \n', '     \n', '    /** \n', '    *  @dev submit a withdrawal application, user can not place any orders after submit a withdrawal application\n', '    */ \n', '    function submitWithdrawApplication() public {\n', '        _withdrawalApplication[msg.sender] = block.timestamp;\n', '        emit WithdrawalApplication(msg.sender,block.timestamp);\n', '    }\n', ' \n', '    /** \n', '    *  @dev cancel withdraw application\n', '    */ \n', '    function cancelWithdrawApplication() public {\n', '        _withdrawalApplication[msg.sender] = 0; \n', '        emit WithdrawalApplication(msg.sender,0);\n', '    }\n', ' \n', '    /** \n', '    *  @dev check user withdraw application status\n', '    */ \n', '    function isWithdrawApplication(address user) view public returns(bool) {\n', '        if(_withdrawalApplication[user] == uint(0)) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }   \n', '\n', '    /** \n', '    *  @dev withdraw token \n', '    */ \n', '    function _withdraw(address from,address payable to,address token,uint256 amount) internal {    \n', '\n', '        if ( _balances[token][from] < amount) { \n', '            revert(INSUFFICIENT_FOUND);\n', '        }  \n', '        \n', '        _balances[token][from] = _balances[token][from].sub(amount);\n', '\n', '        if(token == address(0)) {  \n', '            to.transfer(amount);\n', '        }else{    \n', '            require(ERC20(token).transfer(to, amount),TRANSFER_FAILED); \n', '        }  \n', '\n', '        emit Withdraw(token, from, to, amount, _balances[token][from]);\n', '    }  \n', '\n', '\n', '    /** \n', '    *  @dev user withdraw token \n', '    */ \n', '    function withdraw(address token) public onlyWithdrawalApplicationApproved { \n', '        uint256 amount = _balances[token][msg.sender];\n', '        if(amount != 0){ \n', '            _withdraw(msg.sender,msg.sender,token,amount);\n', '        }\n', '    } \n', '         \n', '    /** \n', '    *  @dev user withdraw many tokens \n', '    */ \n', '    function withdrawAll(address[] memory tokens) public onlyWithdrawalApplicationApproved { \n', '        \n', '        for(uint256 i = 0; i< tokens.length ;i++){ \n', '\n', '            uint256 amount = _balances[tokens[i]][msg.sender];\n', '            \n', '            if(amount == 0){\n', '                continue;\n', '            }\n', '\n', '            _withdraw(msg.sender,msg.sender,tokens[i],amount); \n', '        }\n', '    }\n', '  \n', '    /** \n', "    *  @dev user send withdraw request with relayer's authorized signature \n", '    */ \n', '    function authorizedWithdraw(address payable to,address token,uint256 amount,\n', '            uint256 nonce,uint expiredTime,address relayer,uint8 v, bytes32 r,bytes32 s) public\n', '    {  \n', '        require(_withdrawalApplication[msg.sender] == uint(0));\n', '        require(expiredTime >= block.timestamp,INVALID_TIME);\n', '        require(_relayers[relayer] == true,ONLY_RELAYER);\n', '\n', '        bytes32 hash = keccak256(abi.encodePacked(msg.sender,to, token, amount, nonce, expiredTime));\n', '        \n', '        if (_withdrawn[hash]) {\n', '            revert(WITHDRAW_EXISTS);    \n', '        }   \n', '\n', '        _withdrawn[hash] = true;  \n', '\n', '        if (ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)), v, r, s) != relayer) {\n', '            revert(ECRECOVER_FAILED);\n', '        } \n', '\n', '        _withdraw(msg.sender,to,token,amount);  \n', '    }\n', ' \n', '    /** \n', '    *  @dev withdraw the token from Dex Wallet to Etheruem Wallet,signType [0 = signTypeDataV3, 1 = eth_sign] \n', '    */ \n', '    function adminWithdraw(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \n', '            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public onlyRelayer  { \n', '\n', '        bytes32 hash = ecrecoverWithdraw(from,to,token,amount,nonce,v,rs,feeToken,feeWithdrawal,timestamp,signType);     \n', '\n', '        if (_withdrawn[hash]) {\n', '            revert(WITHDRAW_EXISTS);    \n', '        }    \n', '\n', '        _withdrawn[hash] = true;   \n', '\n', '        _transfer(from,to,token,amount,feeToken,feeWithdrawal,false);\n', '    } \n', ' \n', '    /** \n', '    *  @dev transfer the token between Dex Wallet,signType [0 = signTypeDataV3, 1 = eth_sign] \n', '    */ \n', '    function adminTransfer(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \n', '            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public onlyRelayer  { \n', '\n', '        bytes32 hash = ecrecoverWithdraw(from,to,token,amount,nonce,v,rs,feeToken,feeWithdrawal,timestamp,signType);     \n', '\n', '        if (_withdrawn[hash]) {\n', '            revert(WITHDRAW_EXISTS);    \n', '        }    \n', '        _withdrawn[hash] = true;  \n', '\n', '\n', '        _transfer(from,to,token,amount,feeToken,feeWithdrawal,true);\n', '    }  \n', ' \n', '    /** \n', '    *  @dev   transfer the token \n', '    *  @param from   token sender\n', '    *  @param to     token receiver  \n', '    *  @param token   The address of token to transfer\n', '    *  @param amount   The amount to transfer \n', '    *  @param feeToken   The address of token  to pay the fee\n', '    *  @param feeWithdrawal  The amount of feeToken to pay the fee\n', '    *  @param isInternal  True is transfer token from a Dex Wallet to a Dex Wallet, False is transfer a token from Dex wallet to a Etheruem Wallet\n', '    */ \n', '    function _transfer(address from,address payable to,address token,uint256 amount, address feeToken,uint256 feeWithdrawal, bool isInternal) internal  { \n', '  \n', '        if (feeWithdrawal > 0)\n', '        { \n', '            require(_balances[feeToken][from] >= feeWithdrawal,  INSUFFICIENT_FOUND ); \n', '            _balances[feeToken][from]        = _balances[feeToken][from].sub(feeWithdrawal);\n', '            _balances[feeToken][_feeAccount] = _balances[feeToken][_feeAccount].add(feeWithdrawal); \n', '        }   \n', '\n', '        if ( _balances[token][from] < amount) {  revert(INSUFFICIENT_FOUND); }  \n', '        \n', '        _balances[token][from] = _balances[token][from].sub(amount);  \n', '        \n', '        if(isInternal)\n', '        {\n', '            _balances[token][to] = _balances[token][to].add(amount);\n', '\n', '            emit Transfer(token, from, to, amount, _balances[token][from], _balances[token][to]);\n', '\n', '        }else{\n', '            if(token == address(0)) {  \n', '                to.transfer(amount);\n', '            }else{    \n', '                require(ERC20(token).transfer(to, amount),TRANSFER_FAILED); \n', '            }  \n', '\n', '            emit Withdraw(token, from, to, amount, _balances[token][from]);\n', '        }  \n', '    }       \n', ' \n', '    /** \n', '    *  @dev  mirgate function will withdraw all user token balances to wallet\n', '    */ \n', '    function adminWithdrawAll(address payable user,address[] memory tokens) public onlyOwner { \n', '\n', '        for(uint256 i = 0; i< tokens.length ;i++){\n', '\n', '            address token = tokens[i];\n', '            uint256 amount = _balances[token][user];\n', '\n', '            if(amount == 0){\n', '                continue;\n', '            }\n', '\n', '            _withdraw(user,user,token,amount);\n', '        }\n', '    }\n', ' \n', '    /** \n', '    *  @dev  get the balance of the account \n', '    */  \n', '    function balanceOf(address token, address user) public view returns (uint256) {\n', '        return _balances[token][user];\n', '    }   \n', ' \n', '    /** \n', '    *  @dev  trade order only call by relayer, ti.signType: 0 = signTypeDataV3, 1 = eth_sign \n', '    */ \n', '    function tradeOrder(Order memory taker,Order memory maker, TradeInfo memory ti) public onlyRelayer \n', '    {\n', '        uint256 gasInitial = gasleft();\n', '\n', '        bytes32 takerHash = ecrecoverOrder(taker,taker.signType); \n', '        bytes32 makerHash = ecrecoverOrder(maker,maker.signType);\n', '    \n', '        bytes32 tradeHash = keccak256(abi.encodePacked(takerHash ,makerHash)); \n', '\n', '        require(_traded[tradeHash] == false,TRADE_EXISTS);  \n', '\n', '        _traded[tradeHash] = true;     \n', '\n', '        _tradeOrder(taker,maker,ti,takerHash,makerHash);     \n', '\n', '        uint256 gasUsed = gasInitial - gasleft();\n', '        \n', '        _burnGas(gasUsed);\n', '    }\n', ' \n', '    /** \n', '    *  @dev  trade order internal\n', '    */ \n', '    function _tradeOrder(Order memory taker,Order memory maker, TradeInfo memory ti, bytes32 takerHash,bytes32 makerHash) internal\n', '    {   \n', '        require(taker.baseToken == maker.baseToken && taker.token == maker.token);\n', '        require(ti.tradeTokenAmount > 0 , INVALID_AMOUNT );\n', '        require((block.timestamp <= taker.expireTime) && (block.timestamp <= maker.expireTime)  ,  INVALID_TIME ); \n', '        require( (_invalidOrderNonce[taker.user] < taker.nonce) &&(_invalidOrderNonce[maker.user] < maker.nonce),INVALID_NONCE) ; \n', '\n', '        require( (taker.tokenAmount.sub(_orderFills[takerHash]) >= ti.tradeTokenAmount) &&\n', '                (maker.tokenAmount.sub(_orderFills[makerHash]) >= ti.tradeTokenAmount), AMOUNT_EXCEEDED); \n', '\n', '        require(taker.gasToken == ti.tradeGasToken, INVALID_GASTOKEN);\n', '\n', '        uint256 tradeBaseTokenAmount = ti.tradeTokenAmount.mul(maker.baseTokenAmount).div(maker.tokenAmount);     \n', ' \n', '        (uint256 takerFee,uint256 makerFee) = calcMaxFee(ti,tradeBaseTokenAmount,maker.sell);    \n', '\n', '        uint  gasFee = ti.tradeGasFee;\n', '\n', '        if(gasFee != 0)\n', '        {  \n', '            if( taker.maxGasFee < _orderGasFee[takerHash].add(gasFee))\n', '            {\n', '                gasFee = taker.maxGasFee.sub(_orderGasFee[takerHash]);\n', '            } \n', '\n', '            if(gasFee != 0)\n', '            {\n', '                _orderGasFee[takerHash] = _orderGasFee[takerHash].add(gasFee); \n', '                _balances[taker.gasToken][taker.user]   = _balances[taker.gasToken][taker.user].sub(gasFee); \n', '            } \n', '        } \n', '         \n', '        if( maker.sell)\n', '        {  \n', '            //maker is seller \n', '            _updateOrderBalance(taker.user,maker.user,taker.baseToken,taker.token,\n', '                            tradeBaseTokenAmount,ti.tradeTokenAmount,takerFee,makerFee);\n', '        }else\n', '        {\n', '            //maker is buyer\n', '            _updateOrderBalance(maker.user,taker.user,taker.baseToken,taker.token,\n', '                            tradeBaseTokenAmount,ti.tradeTokenAmount,makerFee,takerFee); \n', '        }\n', '\n', '        //fill order\n', '        _orderFills[takerHash] = _orderFills[takerHash].add(ti.tradeTokenAmount);  \n', '        _orderFills[makerHash] = _orderFills[makerHash].add(ti.tradeTokenAmount);     \n', '\n', '        emit Trade(takerHash,makerHash,ti.tradeTokenAmount,tradeBaseTokenAmount,ti.tradeNonce,takerFee,makerFee, maker.sell ,gasFee);\n', ' \n', '        emit Balance(_balances[taker.baseToken][taker.user],_balances[taker.token][taker.user],_balances[maker.baseToken][maker.user],_balances[maker.token][maker.user]); \n', '    }  \n', '   \n', '    /** \n', '    *  @dev  update the balance after each order traded\n', '    */ \n', '    function _updateOrderBalance(address buyer,address seller,address base,address token,uint256 baseAmount,uint256 amount,uint256 buyFee,uint256 sellFee) internal\n', '    {\n', '        _balances[base][seller]    = _balances[base][seller].add(baseAmount.sub(sellFee));    \n', '        _balances[base][buyer]     = _balances[base][buyer].sub(baseAmount);\n', '\n', '        _balances[token][buyer]    = _balances[token][buyer].add(amount.sub(buyFee));  \n', '        _balances[token][seller]   = _balances[token][seller].sub(amount);    \n', '    \n', '        _balances[base][_feeAccount]    = _balances[base][_feeAccount].add(sellFee);  \n', '        _balances[token][_feeAccount]    = _balances[token][_feeAccount].add(buyFee);   \n', '    }\n', ' \n', '    /** \n', '    *  @dev  calc max fee for maker and taker\n', '    *  @return return a taker and maker fee limit by _takerFeeRate and _makerFeeRate\n', '    */ \n', '    function calcMaxFee(TradeInfo memory ti,uint256 tradeBaseTokenAmount,bool sellerIsMaker)  view public returns (uint256 takerFee,uint256 makerFee) { \n', '   \n', '        uint maxTakerFee;\n', '        uint maxMakerFee;\n', '\n', '        takerFee     = ti.tradeTakerFee;\n', '        makerFee      = ti.tradeMakerFee; \n', '        \n', '        if(sellerIsMaker)\n', '        { \n', '            // taker is buyer\n', '            maxTakerFee = (ti.tradeTokenAmount * _takerFeeRate) / 1 ether; \n', '            maxMakerFee = (tradeBaseTokenAmount * _makerFeeRate) / 1 ether; \n', '        }else{\n', '            // maker is buyer\n', '            maxTakerFee = (tradeBaseTokenAmount * _takerFeeRate) / 1 ether; \n', '            maxMakerFee = (ti.tradeTokenAmount  * _makerFeeRate) / 1 ether; \n', '        } \n', '\n', '        if(ti.tradeTakerFee > maxTakerFee)\n', '        {\n', '            takerFee = maxTakerFee;\n', '        }  \n', '\n', '        if(ti.tradeMakerFee > maxMakerFee)\n', '        {\n', '            makerFee = maxMakerFee;\n', '        }  \n', '    } \n', ' \n', '    /** \n', '    *  @dev  get fee Rate \n', '    */ \n', '    function getFeeRate() view public  returns(uint256 makerFeeRate,uint256 takerFeeRate)\n', '    {\n', '        return (_makerFeeRate,_takerFeeRate);\n', '    } \n', ' \n', '    /** \n', '    *  @dev get order filled amount\n', '    *  @param orderHash   the order hash  \n', '    *  @return return the filled amount for a order\n', '    */ \n', '    function getOrderFills(bytes32 orderHash) view public returns(uint256 filledAmount)\n', '    {\n', '        return _orderFills[orderHash];\n', '    }\n', '\n', '    ///@dev check orders traded\n', '    function isTraded(bytes32 buyOrderHash,bytes32 sellOrderHash) view public returns(bool traded)\n', '    {\n', '        return _traded[keccak256(abi.encodePacked(buyOrderHash, sellOrderHash))];\n', '    }   \n', ' \n', '    /** \n', "    *  @dev Airdrop the token directly to Dex user's walle,only airdrop contract can call this function.\n", '    *  @param to   the recipient\n', '    *  @param token  the ERC20 token to send  \n', '    *  @param amount  the token amount to send \n', '    */ \n', '    function airdrop(address to,address token,uint256 amount) public onlyAirdropContract  \n', '    {  \n', '        //Not EOA\n', '        require(tx.origin != msg.sender);\n', '        require(_balances[token][msg.sender] >= amount ,INSUFFICIENT_FOUND);\n', '\n', '        _balances[token][msg.sender] = _balances[token][msg.sender].sub(amount); \n', '        _balances[token][to] = _balances[token][to].add(amount);  \n', '\n', '        emit Airdrop(to,token,amount);\n', '    }   \n', '\n', '    /** \n', '    *  @dev ecreover the order sign   \n', '    *  @return return a order hash\n', '    */ \n', '    function ecrecoverOrder(Order memory order,uint signType) public pure returns (bytes32 orderHash) {  \n', ' \n', '        if(signType == 0 )\n', '        {\n', '            orderHash = keccak256(abi.encode(\n', '                ORDER_TYPEHASH,\n', '                order.token,order.baseToken,order.tokenAmount,order.baseTokenAmount,order.nonce,order.sell,order.expireTime,order.maxGasFee,order.gasToken,order.timestamp));\n', '            if (ecrecover(keccak256(abi.encodePacked("\\x19\\x01",DOMAIN_SEPARATOR,orderHash)),order.V,order.R, order.S) != order.user) {\n', '                    revert(ECRECOVER_FAILED);\n', '            }  \n', '        }else {   \n', '\n', '            orderHash = keccak256(abi.encodePacked(order.token,order.baseToken,order.tokenAmount,order.baseTokenAmount,order.nonce,order.sell,order.expireTime,order.maxGasFee,order.gasToken,order.timestamp)); \n', '            if(ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32",orderHash)),order.V,order.R, order.S) != order.user) {\n', '                revert(ECRECOVER_FAILED);\n', '            }  \n', '        } \n', '    }   \n', '\n', '    /** \n', '    *  @dev ecrecover the withdraw sign\n', '    *  @return return a withdraw hash\n', '    */\n', '    function ecrecoverWithdraw(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \n', '            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public pure returns (bytes32 orderHash) {  \n', '  \n', '        if(signType == 1 ) {\n', '\n', '            orderHash = keccak256(abi.encodePacked(token, amount, to, nonce,feeToken,feeWithdrawal,timestamp));\n', '\n', '            if (ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderHash)), v, rs[0], rs[1]) != from) {\n', '                revert(ECRECOVER_FAILED);\n', '            }\n', ' \n', '        } else {\n', '            orderHash = keccak256(abi.encode(WITHDRAW_TYPEHASH,token, amount, to, nonce,feeToken,feeWithdrawal,timestamp));\n', '\n', '            if (ecrecover(keccak256(abi.encodePacked("\\x19\\x01",DOMAIN_SEPARATOR,orderHash)), v, rs[0], rs[1]) != from) {\n', '                revert(ECRECOVER_FAILED);\n', '            }  \n', '        } \n', '    }  \n', '  \n', '    /**\n', '   * @dev burn the stored gastoken\n', '   * @param gasUsed The gas uesed to calc the gastoken to burn\n', '   */\n', '    function _burnGas(uint gasUsed) internal {\n', '\n', '        if(_gasStorage == address(0x0)){\n', '            return;\n', '        } \n', '\n', '        IGasStorage(_gasStorage).burn(gasUsed); \n', '    }\n', '\n', '}']