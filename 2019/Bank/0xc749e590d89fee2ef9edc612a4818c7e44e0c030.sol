['pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract _0xLTC_Sale {\n', '\n', '    using SafeMath for uint256;\n', '    address owner;\n', '    address selfdroptoken;\n', '    address[] public hugeetherinvest;\n', '\n', '    mapping (address => bool) public blacklist;\n', '\n', '    uint256 public rate = 0;\n', '    uint256 public totalRemaining;\n', '    uint256 public selfdropvalue;\n', '\n', '    event Distr(address indexed to, uint256 amount);\n', '    event DistrFinished();\n', '    event crowdsaleFinishedd();\n', '\n', '    bool public distributionFinished;\n', '    bool public crowdsaleFinished;\n', '    \n', '    modifier canDistr() {\n', '        require(!distributionFinished);\n', '        _;\n', '    }\n', '    modifier canDistrCS() {\n', '        require(!crowdsaleFinished);\n', '        _;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlynotblacklist() {\n', '        require(blacklist[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    function setselfdroptoken(address _selfdroptoken) public onlyOwner {\n', '        require (_selfdroptoken != address(0));\n', '        selfdroptoken = _selfdroptoken;\n', '        totalRemaining = ERC20(selfdroptoken).balanceOf(address(this));\n', '    } \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    function startsale() onlyOwner public returns (bool) {\n', '        distributionFinished = false;\n', '        return true;\n', '    }\n', '    function startcrowdsale() onlyOwner public returns (bool) {\n', '        crowdsaleFinished = false;\n', '        return true;\n', '    }\n', '    function finishselfdrop() onlyOwner canDistr public returns (bool) {\n', '        distributionFinished = true;\n', '        emit DistrFinished();\n', '        return true;\n', '    }\n', '    function finishcrowdsale() onlyOwner canDistrCS public returns (bool) {\n', '        crowdsaleFinished = true;\n', '        emit crowdsaleFinishedd();\n', '        return true;\n', '    }\n', '    \n', '    function distr(address _to, uint256 _amount) private returns (bool) {\n', '\n', '        totalRemaining = totalRemaining.sub(_amount);\n', '        ERC20(selfdroptoken).transfer(_to,_amount);\n', '        emit Distr(_to, _amount);\n', '        return true;\n', '        \n', '        if (totalRemaining == 0) {\n', '            distributionFinished = true;\n', '            crowdsaleFinished = true;\n', '        }\n', '    }\n', '    function setselfdropvalue(uint256 _value) public onlyOwner {\n', '        selfdropvalue = _value.mul(1e18);\n', '    }\n', '    function () external payable{\n', '        if(msg.value == 0){getTokenss();}else{getTokens();}         \n', '    }\n', '    function getTokenss() canDistr onlynotblacklist internal {\n', '        \n', '        require (selfdropvalue != 0);\n', '        \n', '        if (selfdropvalue > totalRemaining) {\n', '            selfdropvalue = totalRemaining;\n', '        }\n', '        \n', '        require(selfdropvalue <= totalRemaining);\n', '        \n', '        address investor = msg.sender;\n', '        uint256 toGive = selfdropvalue;\n', '        \n', '        distr(investor, toGive);\n', '        \n', '        if (toGive > 0) {\n', '            blacklist[investor] = true;\n', '        }\n', '    }\n', '    \n', '    function setethrate(uint _rate) onlyOwner public {\n', '        rate = _rate;\n', '    }\n', '    function getTokens() canDistrCS public payable {\n', '        \n', '        require(msg.value >= 0.001 ether);\n', '        require(rate > 0);\n', '        \n', '        uint256 value = msg.value.mul(rate);\n', '        \n', '        require(totalRemaining >= value);\n', '        \n', '        address investor = msg.sender;\n', '        uint256 toGive = value;\n', '        \n', '        distr(investor, toGive);\n', '        \n', '        if(msg.value >= 0.1 ether){\n', '            hugeetherinvest.push(msg.sender);\n', '        }\n', '    }\n', '    function withdrawfromcontract() public onlyOwner {\n', '        ERC20(selfdroptoken).transfer(owner,ERC20(selfdroptoken).balanceOf(address(this)));\n', '    }\n', '    function withdraw() public onlyOwner {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '}']