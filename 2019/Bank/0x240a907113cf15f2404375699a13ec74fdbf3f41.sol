['pragma solidity 0.4.20;\n', "// THIS IS THE TESTING SMART CONTRACT. DON'T DEPOSIT ANY FUND !!!!\n", ' /**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\n', '    uint _numerator  = numerator * 10 ** (precision+1);\n', '    uint _quotient =  ((_numerator / denominator) + 5) / 10;\n', '    return (value*_quotient/1000000000000000000);\n', '  }\n', '  \n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TDAPP24MAY {\n', '    \n', '    /*=====================================\n', '    =       CONTRACT CONFIGURABLES        =\n', '    =====================================*/\n', '    \n', '    // Token Details\n', '    string public name                                      = "TDAPP24MAY";\n', '    string public symbol                                    = "TDAPP";\n', '    uint8 constant public decimals                          = 18;\n', '    uint256 constant internal tokenPriceInitial             = 0.000000001 ether;\n', '    \n', '    // Token Price Increment & Decrement By 1Gwei\n', '    uint256 constant internal tokenPriceIncDec              = 0.000000001 ether;\n', '    \n', '    // Proof of Stake (Default at 1 Token)\n', '    uint256 public stakingReq                               = 1e18;\n', '    uint256 constant internal magnitude                     = 2**64;\n', '    \n', '    // Dividend/Distribution Percentage\n', '    uint8 constant internal referralFeePercent              = 5;\n', '    uint8 constant internal dividendFeePercent              = 10;\n', '    uint8 constant internal tradingFundWalletFeePercent     = 10;\n', '    uint8 constant internal communityWalletFeePercent       = 10;\n', '    \n', '    /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    \n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal sellingWithdrawBalance_;\n', '    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', '    mapping(address => string) internal contractTokenHolderAddresses;\n', '\n', '    uint256 internal tokenTotalSupply                       = 0;\n', '    uint256 internal calReferralPercentage                  = 0;\n', '    uint256 internal calDividendPercentage                  = 0;\n', '    uint256 internal calculatedPercentage                   = 0;\n', '    uint256 internal soldTokens                             = 0;\n', '    uint256 internal tempIncomingEther                      = 0;\n', '    uint256 internal tempProfitPerShare                     = 0;\n', '    uint256 internal tempIf                                 = 0;\n', '    uint256 internal tempCalculatedDividends                = 0;\n', '    uint256 internal tempReferall                           = 0;\n', '    uint256 internal tempSellingWithdraw                    = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    // When this is set to true, only ambassadors can purchase tokens\n', '    bool public onlyAmbassadors = false;\n', '    \n', '    // Community Wallet Address\n', '    address internal constant CommunityWalletAddr           = address(0x1e5A8DE394e3cbA8adAC8C58C7CF3d9ae042fC34);\n', '    // Trading Fund Wallet Address\n', '    address internal constant TradingWalletAddr             = address(0x9BB77a5f75aD4e17A350DBcc36ee543EdA11EED5);  \n', '\n', '    // Administrator of this contract                        \n', '    mapping(bytes32 => bool) public admin;\n', '    \n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    \n', '    // Only people with tokens\n', '    modifier onlybelievers() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // Only people with profits\n', '    modifier onlyhodler() {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '    \n', '    // Only people with sold token\n', '    modifier onlySelingholder() {\n', '        require(sellingWithdrawBalance_[msg.sender] > 0);\n', '        _;\n', '    }\n', '    \n', '    // Admin can do following things:\n', '    //  1. Change the name of contract.\n', '    //  2. Change the name of token.\n', '    //  3. Change the PoS difficulty .\n', '    // Admin CANNOT do following things:\n', '    //  1. Take funds out from contract.\n', '    //  2. Disable withdrawals.\n', '    //  3. Kill the smart contract.\n', '    //  4. Change the price of tokens.\n', '    modifier onlyAdmin() {\n', '        address _adminAddress = msg.sender;\n', '        require(admin[keccak256(_adminAddress)]);\n', '        _;\n', '    }\n', '    \n', '    /*===========================================\n', '    =       ADMINISTRATOR ONLY FUNCTIONS        =\n', '    ===========================================*/\n', '    \n', '    // Admin can manually disable the ambassador phase\n', '    function disableInitialStage() onlyAdmin() public {\n', '        onlyAmbassadors = false;\n', '    }\n', '    \n', '    function setAdmin(bytes32 _identifier, bool _status) onlyAdmin() public {\n', '        admin[_identifier]      = _status;\n', '    }\n', '    \n', '    function setStakingReq(uint256 _tokensAmount) onlyAdmin() public {\n', '        stakingReq              = _tokensAmount;\n', '    }\n', '    \n', '    function setName(string _tokenName) onlyAdmin() public {\n', '        name                    = _tokenName;\n', '    }\n', '    \n', '    function setSymbol(string _tokenSymbol) onlyAdmin() public {\n', '        symbol                  = _tokenSymbol;\n', '    }\n', '    \n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    \n', '    event onTokenPurchase (\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '    \n', '    event onTokenSell (\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned\n', '    );\n', '    \n', '    event onReinvestment (\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw (\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    event onSellingWithdraw (\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    \n', '    );\n', '    \n', '    event Transfer (\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    \n', '    function Treasure() public {\n', '        // Contract Admin\n', '        admin[0x13321a0b5634e9b7ef729599faca1aa51f0a45b5ad8a4e6e3ce8fe8ecdfc54a3] = true;\n', '    }\n', '    \n', '    // Check contract Ethereum Balance\n', '    function totalEthereumBalance() public view returns(uint) {\n', '        return this.balance;\n', '    }\n', '    \n', '    // Check tokens total supply\n', '    function totalSupply() public view returns(uint256) {\n', '        return tokenTotalSupply;\n', '    }\n', '    \n', '    // Check token balance owned by the caller\n', '    function myTokens() public view returns(uint256) {\n', '        address ownerAddress = msg.sender;\n', '        return tokenBalanceLedger_[ownerAddress];\n', '    }\n', '    \n', '    // Check sold tokens\n', '    function getSoldTokens() public view returns(uint256) {\n', '        return soldTokens;\n', '    }\n', '    \n', '    // Check dividends owned by the caller\n', '    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n', '    }\n', '    \n', '    // Check dividend balance of any single address\n', '    function dividendsOf(address _customerAddress) view public returns(uint256) {\n', '        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '    }\n', '    \n', '    // Check token balance of any address\n', '    function balanceOf(address ownerAddress) public view returns(uint256) {\n', '        return tokenBalanceLedger_[ownerAddress]; ///need to change\n', '    }\n', '    \n', '    // Check Selling Withdraw balance of address\n', '    function sellingWithdrawBalance() view public returns(uint256) {\n', '        address _customerAddress = msg.sender; \n', '        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // Get all balances\n', '        return  _sellingWithdraw;\n', '    }\n', '    \n', '    // Get Buy Price of 1 individual token\n', '    function sellPrice() public view returns(uint256) {\n', '        if(tokenTotalSupply == 0){\n', '            return tokenPriceInitial - tokenPriceIncDec;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            return _ethereum - SafeMath.percent(_ethereum,15,100,18);\n', '        }\n', '    }\n', '    \n', '    // Get Sell Price of 1 individual token\n', '    function buyPrice() public view returns(uint256) {\n', '        if(tokenTotalSupply == 0){\n', '            return tokenPriceInitial;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            return _ethereum;\n', '        }\n', '    }\n', '    \n', "    // Converts all of caller's dividends to tokens\n", '    function reinvest() onlyhodler() public {\n', '        address _customerAddress = msg.sender;\n', '        // Get dividends\n', '        uint256 _dividends                  = myDividends(true); // Retrieve Ref. Bonus later in the code\n', '        // Calculate 10% for distribution \n', '        uint256  TenPercentForDistribution  = SafeMath.percent(_dividends,10,100,18);\n', '        // Calculate 90% to reinvest into tokens\n', '        uint256  NinetyPercentToReinvest    = SafeMath.percent(_dividends,90,100,18);\n', '        // Dispatch a buy order with the calculatedPercentage \n', '        uint256 _tokens                     = purchaseTokens(NinetyPercentToReinvest, 0x0);\n', '        // Empty their  all dividends beacuse we are reinvesting them\n', '        payoutsTo_[_customerAddress]        +=  (int256) (SafeMath.sub(_dividends, referralBalance_[_customerAddress]) * magnitude);\n', '        referralBalance_[_customerAddress]  = 0;\n', '        \n', '        // Distribute to all users as per holdings\n', '        profitPerShare_ = SafeMath.add(profitPerShare_, (TenPercentForDistribution * magnitude) / tokenTotalSupply);\n', '        \n', '        // Fire Event\n', '        onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '    \n', '    // Alias of sell() & withdraw() function\n', '    function exit() public {\n', '        // Get token count for caller & sell them all\n', '        address _customerAddress            = msg.sender;\n', '        uint256 _tokens                     = tokenBalanceLedger_[_customerAddress];\n', '        if(_tokens > 0) sell(_tokens);\n', '    \n', '        withdraw();\n', '    }\n', '    \n', '    // Withdraw all of the callers earnings\n', '    function withdraw() onlyhodler() public {\n', '        address _customerAddress            = msg.sender;\n', '        // Calculate 20% of all Dividends and Transfer them to two communities\n', '        uint256 _dividends                  = myDividends(true); // get all dividends\n', '        // Calculate 10% for Trading Wallet\n', '        uint256 TenPercentForTradingWallet  = SafeMath.percent(_dividends,10,100,18);\n', '        // Calculate 10% for Community Wallet\n', '        uint256 TenPercentForCommunityWallet= SafeMath.percent(_dividends,10,100,18);\n', '\n', '        // Update Dividend Tracker\n', '        payoutsTo_[_customerAddress]        +=  (int256) (SafeMath.sub(_dividends, referralBalance_[_customerAddress]) * magnitude);\n', '        referralBalance_[_customerAddress]  = 0;\n', '       \n', '        // Delivery Service\n', '        address(CommunityWalletAddr).transfer(TenPercentForCommunityWallet);\n', '        \n', '        // Delivery Service\n', '        address(TradingWalletAddr).transfer(TenPercentForTradingWallet);\n', '        \n', '        // Calculate 80% for transfering it to Customer Address\n', '        uint256 EightyPercentForCustomer    = SafeMath.percent(_dividends,80,100,18);\n', '\n', '        // Delivery Service\n', '        address(_customerAddress).transfer(EightyPercentForCustomer);\n', '        \n', '        // Fire Event\n', '        onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    \n', '    // Withdraw all sellingWithdraw of the callers earnings\n', '    function sellingWithdraw() onlySelingholder() public {\n', '        address customerAddress             = msg.sender;\n', '        uint256 _sellingWithdraw            = sellingWithdrawBalance_[customerAddress];\n', '        \n', '        // Empty all sellingWithdraw beacuse we are giving them ETHs\n', '        sellingWithdrawBalance_[customerAddress] = 0;\n', '\n', '        // Delivery Service\n', '        address(customerAddress).transfer(_sellingWithdraw);\n', '        \n', '        // Fire Event\n', '        onSellingWithdraw(customerAddress, _sellingWithdraw);\n', '    }\n', '    \n', '    // Sell Tokens\n', "    // Remember there's a 10% fee for sell\n", '    function sell(uint256 _amountOfTokens) onlybelievers() public {\n', '        address customerAddress                 = msg.sender;\n', '        // Calculate 10% of tokens and distribute them \n', '        require(_amountOfTokens <= tokenBalanceLedger_[customerAddress] && _amountOfTokens > 1e18);\n', '        \n', '        uint256 _tokens                         = SafeMath.sub(_amountOfTokens, 1e18);\n', '        uint256 _ethereum                       = tokensToEthereum_(_tokens);\n', '        // Calculate 10% for distribution \n', '        uint256  TenPercentToDistribute         = SafeMath.percent(_ethereum,10,100,18);\n', '        // Calculate 90% for customer withdraw wallet\n', '        uint256  NinetyPercentToCustomer        = SafeMath.percent(_ethereum,90,100,18);\n', '        \n', '        // Burn Sold Tokens\n', '        tokenTotalSupply                        = SafeMath.sub(tokenTotalSupply, _tokens);\n', '        tokenBalanceLedger_[customerAddress]    = SafeMath.sub(tokenBalanceLedger_[customerAddress], _tokens);\n', '        \n', '        // Substract sold tokens from circulations of tokenTotalSupply\n', '        soldTokens                              = SafeMath.sub(soldTokens,_tokens);\n', '        \n', '        // Update sellingWithdrawBalance of customer \n', '        sellingWithdrawBalance_[customerAddress] += NinetyPercentToCustomer;   \n', '        \n', '        // Update dividends tracker\n', '        int256 _updatedPayouts                  = (int256) (profitPerShare_ * _tokens + (TenPercentToDistribute * magnitude));\n', '        payoutsTo_[customerAddress]             -= _updatedPayouts; \n', '        \n', '        // Distribute to all users as per holdings         \n', '        if (tokenTotalSupply > 0) {\n', '            // Update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(profitPerShare_, (TenPercentToDistribute * magnitude) / tokenTotalSupply);\n', '        }\n', '      \n', '        // Fire Event\n', '        onTokenSell(customerAddress, _tokens);\n', '    }\n', '    \n', '    // Transfer tokens from the caller to a new holder\n', "    // Remember there's a 5% fee here for transfer\n", '    function transfer(address _toAddress, uint256 _amountOfTokens) onlybelievers() public returns(bool) {\n', '        address customerAddress                 = msg.sender;\n', '        // Make sure user have the requested tokens\n', '        \n', '        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[customerAddress] && _amountOfTokens > 1e18);\n', '        \n', '        // Calculate 5% of total tokens\n', '        uint256  FivePercentOfTokens            = SafeMath.percent(_amountOfTokens,5,100,18);\n', '        // Calculate 95% of total tokens\n', '        uint256  NinetyFivePercentOfTokens      = SafeMath.percent(_amountOfTokens,95,100,18);\n', '        \n', '        // Burn the fee tokens\n', '        // Convert ETH to Tokens\n', '        tokenTotalSupply                        = SafeMath.sub(tokenTotalSupply,FivePercentOfTokens);\n', '        \n', '        // Substract 5% from community of tokens\n', '        soldTokens                              = SafeMath.sub(soldTokens, FivePercentOfTokens);\n', '\n', '        // Exchange Tokens\n', '        tokenBalanceLedger_[customerAddress]    = SafeMath.sub(tokenBalanceLedger_[customerAddress], _amountOfTokens);\n', '        tokenBalanceLedger_[_toAddress]         = SafeMath.add(tokenBalanceLedger_[_toAddress], NinetyFivePercentOfTokens) ;\n', '        \n', '        // Calculate value of all token to transfer to ETH\n', '        uint256 FivePercentToDistribute         = tokensToEthereum_(FivePercentOfTokens);\n', '        \n', '        // Update dividend trackers\n', '        payoutsTo_[customerAddress]             -= (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress]                  += (int256) (profitPerShare_ * NinetyFivePercentOfTokens);\n', '        \n', '        // Distribute to all users as per holdings \n', '        profitPerShare_                         = SafeMath.add(profitPerShare_, (FivePercentToDistribute * magnitude) / tokenTotalSupply);\n', '\n', '        // Fire Event\n', '        Transfer(customerAddress, _toAddress, NinetyFivePercentOfTokens);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    // Function to calculate actual value after Taxes\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {\n', '        // Calculate 15% for distribution \n', '        uint256  fifteen_percentToDistribute= SafeMath.percent(_ethereumToSpend,15,100,18);\n', '\n', '        uint256 _dividends = SafeMath.sub(_ethereumToSpend, fifteen_percentToDistribute);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_dividends);\n', '        \n', '        return _amountOfTokens;\n', '    }\n', '    \n', '    // Function to calculate received ETH\n', '    function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) {\n', '        require(_tokensToSell <= tokenTotalSupply);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        // Calculate 10% for distribution \n', '        uint256  ten_percentToDistribute= SafeMath.percent(_ethereum,10,100,18);\n', '        \n', '        uint256 _dividends = SafeMath.sub(_ethereum, ten_percentToDistribute);\n', '\n', '        return _dividends;\n', '    }\n', '    \n', '    // Convert all incoming ETH to Tokens for the caller and pass down the referral address (if any)\n', '    function buy(address referredBy) public payable {\n', '        purchaseTokens(msg.value, referredBy);\n', '    }\n', '    \n', '    // Fallback function to handle ETH that was sent straight to the contract\n', '    // Unfortunately we cannot use a referral address this way.\n', '    function() payable public {\n', '        purchaseTokens(msg.value, 0x0);\n', '    }\n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    \n', '    function purchaseTokens(uint256 incomingEthereum, address referredBy) internal returns(uint256) {\n', '        // Datasets\n', '        address customerAddress     = msg.sender;\n', '        tempIncomingEther           = incomingEthereum;\n', '\n', '        // Calculate Percentage for Referral (if any)\n', '        calReferralPercentage       = SafeMath.percent(incomingEthereum,referralFeePercent,100,18);\n', '        // Calculate Dividend\n', '        calDividendPercentage       = SafeMath.percent(incomingEthereum,dividendFeePercent,100,18);\n', '        // Calculate remaining amount\n', '        calculatedPercentage        = SafeMath.percent(incomingEthereum,85,100,18);\n', '        // Token will receive against the sent ETH\n', '        uint256 _amountOfTokens     = ethereumToTokens_(SafeMath.percent(incomingEthereum,85,100,18));  \n', '        uint256 _dividends          = 0;\n', '        uint256 minOneToken         = 1 * (10 ** decimals);\n', '        require(_amountOfTokens > minOneToken && (SafeMath.add(_amountOfTokens,tokenTotalSupply) > tokenTotalSupply));\n', '        \n', '        // If user referred by a Treasure Key\n', '        if(\n', '            // Is this a referred purchase?\n', '            referredBy  != 0x0000000000000000000000000000000000000000 &&\n', '            // No Cheating!!!!\n', '            referredBy  != customerAddress &&\n', '            // Does the referrer have at least X whole tokens?\n', '            tokenBalanceLedger_[referredBy] >= stakingReq\n', '        ) {\n', '            // Give 5 % to Referral User\n', '            referralBalance_[referredBy]    += SafeMath.percent(incomingEthereum,5,100,18);\n', '            _dividends              = calDividendPercentage;\n', '        } else {\n', '            // Add the referral bonus back to the global dividend\n', '            _dividends              = SafeMath.add(calDividendPercentage, calReferralPercentage);\n', '        }\n', '        \n', "        // We can't give people infinite ETH\n", '        if(tokenTotalSupply > 0) {\n', '            // Add tokens to the pool\n', '            tokenTotalSupply        = SafeMath.add(tokenTotalSupply, _amountOfTokens);\n', '            profitPerShare_         += (_dividends * magnitude / (tokenTotalSupply));\n', '        } else {\n', '            // Add tokens to the pool\n', '            tokenTotalSupply        = _amountOfTokens;\n', '        }\n', '        \n', '        // Update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[customerAddress] = SafeMath.add(tokenBalanceLedger_[customerAddress], _amountOfTokens);\n', '        \n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them\n", '        int256 _updatedPayouts      = (int256) (profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[customerAddress] += _updatedPayouts;\n', '        \n', '        // Fire Event\n', '        onTokenPurchase(customerAddress, incomingEthereum, _amountOfTokens, referredBy);\n', '        \n', '        // Calculate sold tokens here\n', '        soldTokens += _amountOfTokens;\n', '        \n', '        return _amountOfTokens;\n', '\n', '    }\n', '    \n', '    // Calculate token price based on an amount of incoming ETH\n', "    // It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '    // Some conversions occurred to prevent decimal errors or underflows/overflows in solidity code.\n', '    function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) {\n', '        uint256 _tokenPriceInitial  = tokenPriceInitial * 1e18;\n', '        uint256 _tokensReceived     = \n', '         (\n', '            (\n', '                SafeMath.sub(\n', '                    (SqRt\n', '                        (\n', '                            (_tokenPriceInitial**2)\n', '                            +\n', '                            (2*(tokenPriceIncDec * 1e18)*(_ethereum * 1e18))\n', '                            +\n', '                            (((tokenPriceIncDec)**2)*(tokenTotalSupply**2))\n', '                            +\n', '                            (2*(tokenPriceIncDec)*_tokenPriceInitial*tokenTotalSupply)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            )/(tokenPriceIncDec)\n', '        )-(tokenTotalSupply);\n', '        return _tokensReceived;\n', '    }\n', '    \n', '    // Calculate token sell value\n', "    // It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '    // Some conversions occurred to prevent decimal errors or underflows/overflows in solidity code.\n', '    function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) {\n', '        uint256 tokens_         = (_tokens + 1e18);\n', '        uint256 _tokenSupply    = (tokenTotalSupply + 1e18);\n', '        uint256 _etherReceived  =\n', '        (\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial + (tokenPriceIncDec * (_tokenSupply/1e18))\n', '                        )-tokenPriceIncDec\n', '                    )*(tokens_ - 1e18)\n', '                ),(tokenPriceIncDec*((tokens_**2-tokens_)/1e18))/2\n', '            )/1e18);\n', '        return _etherReceived;\n', '    }\n', '    \n', '    // This is where all your gas goes\n', '    function SqRt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '    \n', '}']