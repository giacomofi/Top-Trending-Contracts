['pragma solidity ^0.5.0;\n', '\n', 'interface PriceWatcherI\n', '{\n', '    function getUSDcentsPerETH() external view returns (uint256 _USDcentsPerETH);\n', '}\n', '\n', '\n', 'contract PriceWatcherPlaceholder is PriceWatcherI\n', '{\n', '    function getUSDcentsPerETH() external view returns (uint256 _USDcentsPerETH)\n', '    {\n', '        return 12345; // $123.45 per ETH\n', '    }\n', '}\n', '\n', 'contract Super100\n', '{\n', '    // Constants\n', '    uint256 public TOKEN_PRICE_USD_CENTS;\n', '    uint256 public totalSupply;\n', '    uint256 public AMOUNT_OF_FREE_TOKENS;\n', '    address payable public root;\n', '    address payable public bank;\n', '    uint256 public REFERRER_COMMISSION_PERCENTAGE;\n', '    uint256 public ROOT_COMMISSION_PERCENTAGE;\n', '    PriceWatcherI public priceWatcher;\n', '    \n', '    // State variables\n', '    mapping(address => uint256) private balances;\n', '    address[] public participants;\n', '    mapping(address => address payable) public address_to_referrer;\n', '    mapping(address => address[]) public address_to_referrals;\n', '    \n', '    constructor(address _priceWatcherContract, uint256 _tokenPriceUSDcents, uint256 _totalSupply, uint256 _amountOfFreeTokens, address payable _root, address payable _bank, uint256 _referrerCommissionPercentage, uint256 _rootCommissionPercentage) public\n', '    {\n', '        if (_priceWatcherContract == address(0x0))\n', '        {\n', '            priceWatcher = new PriceWatcherPlaceholder();\n', '        }\n', '        else\n', '        {\n', '            priceWatcher = PriceWatcherI(_priceWatcherContract);\n', '        }\n', '\n', '        TOKEN_PRICE_USD_CENTS = _tokenPriceUSDcents;\n', '        totalSupply = _totalSupply;\n', '        AMOUNT_OF_FREE_TOKENS = _amountOfFreeTokens;\n', '        root = _root;\n', '        bank = _bank;\n', '        REFERRER_COMMISSION_PERCENTAGE = _referrerCommissionPercentage;\n', '        ROOT_COMMISSION_PERCENTAGE = _rootCommissionPercentage;\n', '\n', '        // The root address is its own referrer\n', '        address_to_referrer[root] = root;\n', '\n', '        // Mint all the tokens and assign them to the root address\n', '        balances[root] = totalSupply;\n', '        emit Transfer(address(0x0), root, totalSupply);\n', '    }\n', '\n', '    function getTokenPriceETH() public view returns (uint256)\n', '    {\n', '        // Fetch the current ETH exchange rate\n', '        uint256 USDcentsPerETH = priceWatcher.getUSDcentsPerETH();\n', '\n', '        // Use the exchange rate to calculate the current token price in ETH\n', '        return (1 ether) * TOKEN_PRICE_USD_CENTS / USDcentsPerETH;\n', '    }\n', '    \n', '    function buyTokens(address payable _referrer) external payable\n', '    {\n', '        uint256 tokensBought;\n', '        uint256 totalValueOfTokensBought;\n', '\n', '        uint256 tokenPriceWei = getTokenPriceETH();\n', '        \n', '        // If there are still free tokens available\n', '        if (participants.length < AMOUNT_OF_FREE_TOKENS)\n', '        {\n', '            tokensBought = 1;\n', '            totalValueOfTokensBought = 0;\n', '\n', '            // Only 1 free token per address\n', '            require(address_to_referrer[msg.sender] == address(0x0));\n', '        }\n', '\n', '        // If there are no free tokens available\n', '        else\n', '        {\n', '            tokensBought = msg.value / tokenPriceWei;\n', '            \n', '            // Limit the bought tokens to the amount of tokens still for sale\n', '            if (tokensBought > balances[root])\n', '            {\n', '                tokensBought = balances[root];\n', '            }\n', '            \n', '            totalValueOfTokensBought = tokensBought * tokenPriceWei;\n', '        }\n', '        \n', '        // If 0 tokens are being purchased, cancel this transaction\n', '        require(tokensBought > 0);\n', '\n', '        // Return the change\n', '        msg.sender.transfer(msg.value - totalValueOfTokensBought);\n', '        \n', "        // If we haven't seen this buyer before\n", '        if (address_to_referrer[msg.sender] == address(0x0))\n', '        {\n', '            // Referrer must have owned at least 1 token\n', '            require(address_to_referrer[_referrer] != address(0x0));\n', '            \n', '            // Add them to the particpants list and the referral tree\n', '            address_to_referrer[msg.sender] = _referrer;\n', '            address_to_referrals[_referrer].push(msg.sender);\n', '            participants.push(msg.sender);\n', '        }\n', '        \n', '        // If we have seen this buyer before\n', '        else\n', '        {\n', '            // Referrer must be the same as their previous referrer\n', '            require(_referrer == address_to_referrer[msg.sender]);\n', '        }\n', '        \n', '        // Transfer the bought tokens from root to the buyer\n', '        balances[root] -= tokensBought;\n', '        balances[msg.sender] += tokensBought;\n', '        emit Transfer(root, msg.sender, tokensBought);\n', '        \n', '        // Transfer commission to the referrer\n', '        uint256 commissionForReferrer = totalValueOfTokensBought * REFERRER_COMMISSION_PERCENTAGE / 100;\n', '        _referrer.transfer(commissionForReferrer);\n', '        \n', '        // Transfer commission to the root\n', '        uint256 commissionForRoot = totalValueOfTokensBought * ROOT_COMMISSION_PERCENTAGE / 100;\n', '        root.transfer(commissionForRoot);\n', '        \n', '        // Transfer the remaining ETH to the bank\n', '        bank.transfer(totalValueOfTokensBought - commissionForReferrer - commissionForRoot);\n', '    }\n', '\n', '    function amountOfReferralsMade(address _byReferrer) external view returns (uint256)\n', '    {\n', '        return address_to_referrals[_byReferrer].length;\n', '    }\n', '    \n', '    function amountOfTokensForSale() external view returns (uint256)\n', '    {\n', '        return balances[root];\n', '    }\n', '\n', '    function amountOfFreeTokensAvailable() external view returns (uint256)\n', '    {\n', '        if (participants.length < AMOUNT_OF_FREE_TOKENS)\n', '        {\n', '            return AMOUNT_OF_FREE_TOKENS - participants.length;\n', '        }\n', '        else\n', '        {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    // ERC20 implementation\n', '    string public constant name = "Super100";\n', '    string public constant symbol = "S100";\n', '    uint8 public constant decimals = 0;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '\n', '    function balanceOf(address _who) external view returns (uint256)\n', '    {\n', '        return balances[_who];\n', '    }\n', '    function allowance(address _owner, address _spender) external view returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _amount) external returns (bool)\n', '    {\n', '        require(balances[msg.sender] >= _amount);\n', '        balances[msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool)\n', '    {\n', '        require(allowed[_from][msg.sender] >= _amount);\n', '        require(balances[_from] >= _amount);\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        emit Transfer(_from, _to, _amount);\n', '        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n', '        return true;\n', '    }\n', '    function approve(address _spender, uint256 _amount) external returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    function increaseAllowance(address _spender, uint256 _addedAmount) public returns (bool)\n', '    {\n', '        require(allowed[msg.sender][_spender] + _addedAmount >= _addedAmount);\n', '        allowed[msg.sender][_spender] += _addedAmount;\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    function decreaseAllowance(address _spender, uint256 _subtractedAmount) public returns (bool)\n', '    {\n', '        require(allowed[msg.sender][_spender] >= _subtractedAmount);\n', '        allowed[msg.sender][_spender] -= _subtractedAmount;\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}']