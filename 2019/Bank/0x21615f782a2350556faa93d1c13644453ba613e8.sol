['pragma solidity ^0.4.19;\n', '\n', '/* Interface for ERC20 Tokens */\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '// The DMEX base Contract\n', 'contract Exchange {\n', '    function assert(bool assertion) {\n', '        if (!assertion) throw;\n', '    }\n', '\n', '    // Safe Multiply Function - prevents integer overflow \n', '    function safeMul(uint a, uint b) returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    // Safe Subtraction Function - prevents integer overflow \n', '    function safeSub(uint a, uint b) returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // Safe Addition Function - prevents integer overflow \n', '    function safeAdd(uint a, uint b) returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    address public owner; // holds the address of the contract owner\n', '    mapping (address => bool) public admins; // mapping of admin addresses\n', '    mapping (address => bool) public futuresContracts; // mapping of connected futures contracts\n', '    mapping (address => uint256) public futuresContractsAddedBlock; // mapping of connected futures contracts and connection block numbers\n', '    event SetFuturesContract(address futuresContract, bool isFuturesContract);\n', '\n', '    // Event fired when the owner of the contract is changed\n', '    event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Changes the owner of the contract\n', '    function setOwner(address newOwner) onlyOwner {\n', '        SetOwner(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    // Owner getter function\n', '    function getOwner() returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    // Adds or disables an admin account\n', '    function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '\n', '    // Adds or disables a futuresContract address\n', '    function setFuturesContract(address futuresContract, bool isFuturesContract) onlyOwner {\n', '        futuresContracts[futuresContract] = isFuturesContract;\n', '        if (fistFuturesContract == address(0))\n', '        {\n', '            fistFuturesContract = futuresContract;\n', '        }\n', '        futuresContractsAddedBlock[futuresContract] = block.number;\n', '        emit SetFuturesContract(futuresContract, isFuturesContract);\n', '    }\n', '\n', '    // Allows for admins only to call the function\n', '    modifier onlyAdmin {\n', '        if (msg.sender != owner && !admins[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    // Allows for futures contracts only to call the function\n', '    modifier onlyFuturesContract {\n', '        if (!futuresContracts[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    function() external {\n', '        throw;\n', '    }\n', '\n', '    //mapping (address => mapping (address => uint256)) public tokens; // mapping of token addresses to mapping of balances  // tokens[token][user]\n', '    //mapping (address => mapping (address => uint256)) public reserve; // mapping of token addresses to mapping of reserved balances  // reserve[token][user]\n', '    mapping (address => mapping (address => uint256)) public balances; // mapping of token addresses to mapping of balances and reserve (bitwise compressed) // balances[token][user]\n', '\n', '    mapping (address => uint256) public lastActiveTransaction; // mapping of user addresses to last transaction block\n', '    mapping (bytes32 => uint256) public orderFills; // mapping of orders to filled qunatity\n', '    \n', '    mapping (address => mapping (address => bool)) public userAllowedFuturesContracts; // mapping of allowed futures smart contracts per user\n', '    mapping (address => uint256) public userFirstDeposits; // mapping of user addresses and block number of first deposit\n', '\n', '    address public feeAccount; // the account that receives the trading fees\n', '    address public EtmTokenAddress; // the address of the EtherMium token\n', '    address public fistFuturesContract; // 0x if there are no futures contracts set yet\n', '\n', '    uint256 public inactivityReleasePeriod; // period in blocks before a user can use the withdraw() function\n', '    mapping (bytes32 => bool) public withdrawn; // mapping of withdraw requests, makes sure the same withdrawal is not executed twice\n', '    uint256 public makerFee; // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '    uint256 public takerFee; // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\n', '\n', '    enum Errors {\n', "        INVLID_PRICE,           // Order prices don't match\n", '        INVLID_SIGNATURE,       // Signature is invalid\n', "        TOKENS_DONT_MATCH,      // Maker/taker tokens don't match\n", '        ORDER_ALREADY_FILLED,   // Order was already filled\n', '        GAS_TOO_HIGH            // Too high gas fee\n', '    }\n', '\n', '    // Trade event fired when a trade is executed\n', '    event Trade(\n', '        address takerTokenBuy, uint256 takerAmountBuy,\n', '        address takerTokenSell, uint256 takerAmountSell,\n', '        address maker, address indexed taker,\n', '        uint256 makerFee, uint256 takerFee,\n', '        uint256 makerAmountTaken, uint256 takerAmountTaken,\n', '        bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash\n', '    );\n', '\n', '    // Deposit event fired when a deposit took place\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n', '\n', '    // Withdraw event fired when a withdrawal was executed\n', '    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 withdrawFee);\n', '    event WithdrawTo(address indexed token, address indexed to, address indexed from, uint256 amount, uint256 balance, uint256 withdrawFee);\n', '\n', '    // Fee change event\n', '    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\n', '\n', '    // Log event, logs errors in contract execution (used for debugging)\n', '    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\n', '    event LogUint(uint8 id, uint256 value);\n', '    event LogBool(uint8 id, bool value);\n', '    event LogAddress(uint8 id, address value);\n', '\n', '    // Change inactivity release period event\n', '    event InactivityReleasePeriodChange(uint256 value);\n', '\n', '    // Order cancelation event\n', '    event CancelOrder(\n', '        bytes32 indexed cancelHash,\n', '        bytes32 indexed orderHash,\n', '        address indexed user,\n', '        address tokenSell,\n', '        uint256 amountSell,\n', '        uint256 cancelFee\n', '    );\n', '\n', '    // Sets the inactivity period before a user can withdraw funds manually\n', '    function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {\n', '        if (expiry > 1000000) throw;\n', '        inactivityReleasePeriod = expiry;\n', '\n', '        emit InactivityReleasePeriodChange(expiry);\n', '        return true;\n', '    }\n', '\n', '    // Constructor function, initializes the contract and sets the core variables\n', '    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {\n', '        owner = msg.sender;\n', '        feeAccount = feeAccount_;\n', '        inactivityReleasePeriod = inactivityReleasePeriod_;\n', '        makerFee = makerFee_;\n', '        takerFee = takerFee_;\n', '    }\n', '\n', '    // Changes the fees\n', '    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\n', '        require(makerFee_ < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\n', '        makerFee = makerFee_;\n', '        takerFee = takerFee_;\n', '\n', '        emit FeeChange(makerFee, takerFee);\n', '    }\n', '\n', '    \n', '\n', '\n', '\n', '    function updateBalanceAndReserve (address token, address user, uint256 balance, uint256 reserve) private\n', '    {\n', '        uint256 character = uint256(balance);\n', '        character |= reserve<<128;\n', '\n', '        balances[token][user] = character;\n', '    }\n', '\n', '    function updateBalance (address token, address user, uint256 balance) private returns (bool)\n', '    {\n', '        uint256 character = uint256(balance);\n', '        character |= getReserve(token, user)<<128;\n', '\n', '        balances[token][user] = character;\n', '        return true;\n', '    }\n', '\n', '    function updateReserve (address token, address user, uint256 reserve) private\n', '    {\n', '        uint256 character = uint256(balanceOf(token, user));\n', '        character |= reserve<<128;\n', '\n', '        balances[token][user] = character;\n', '    }\n', '\n', '    function decodeBalanceAndReserve (address token, address user) returns (uint256[2])\n', '    {\n', '        uint256 character = balances[token][user];\n', '        uint256 balance = uint256(uint128(character));\n', '        uint256 reserve = uint256(uint128(character>>128));\n', '\n', '        return [balance, reserve];\n', '    }\n', '\n', '    function futuresContractAllowed (address futuresContract, address user) returns (bool)\n', '    {\n', '        if (fistFuturesContract == futuresContract) return true;\n', '        if (userAllowedFuturesContracts[user][futuresContract] == true) return true;\n', '        if (futuresContractsAddedBlock[futuresContract] < userFirstDeposits[user]) return true;\n', '\n', '        return false;\n', '    }\n', '\n', '    // Returns the balance of a specific token for a specific user\n', '    function balanceOf(address token, address user) view returns (uint256) {\n', '        //return tokens[token][user];\n', '        return decodeBalanceAndReserve(token, user)[0];\n', '    }\n', '\n', '    // Returns the reserved amound of token for user\n', '    function getReserve(address token, address user) public view returns (uint256) { \n', '        //return reserve[token][user];  \n', '        return decodeBalanceAndReserve(token, user)[1];\n', '    }\n', '\n', '    // Sets reserved amount for specific token and user (can only be called by futures contract)\n', '    function setReserve(address token, address user, uint256 amount) onlyFuturesContract returns (bool success) { \n', '        if (!futuresContractAllowed(msg.sender, user)) throw;\n', '        if (availableBalanceOf(token, user) < amount) throw; \n', '        updateReserve(token, user, amount);\n', '        return true; \n', '    }\n', '\n', '    // Updates user balance (only can be used by futures contract)\n', '    function setBalance(address token, address user, uint256 amount) onlyFuturesContract returns (bool success)     {\n', '        if (!futuresContractAllowed(msg.sender, user)) throw;\n', '        updateBalance(token, user, amount);\n', '        return true;\n', '        \n', '    }\n', '\n', '    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) onlyFuturesContract returns (bool)\n', '    {\n', '        if (!futuresContractAllowed(msg.sender, user)) throw;\n', '        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeAdd(getReserve(token, user), addReserve));\n', '    }\n', '\n', '    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) onlyFuturesContract returns (bool)\n', '    {\n', '        if (!futuresContractAllowed(msg.sender, user)) throw;\n', '        updateBalanceAndReserve(token, user, safeAdd(balanceOf(token, user), addBalance), safeSub(getReserve(token, user), subReserve));\n', '    }\n', '\n', '    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) onlyFuturesContract returns (bool)\n', '    {\n', '        if (!futuresContractAllowed(msg.sender, user)) throw;\n', '        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeSub(getReserve(token, user), subReserve));\n', '    }\n', '\n', '    // Returns the available balance of a specific token for a specific user\n', '    function availableBalanceOf(address token, address user) view returns (uint256) {\n', '        return safeSub(balanceOf(token, user), getReserve(token, user));\n', '    }\n', '\n', '    // Returns the inactivity release perios\n', '    function getInactivityReleasePeriod() view returns (uint256)\n', '    {\n', '        return inactivityReleasePeriod;\n', '    }\n', '\n', '    // Increases the user balance\n', '    function addBalance(address token, address user, uint256 amount)\n', '    {\n', '        updateBalance(token, user, safeAdd(balanceOf(token, user), amount));\n', '    }\n', '\n', '    // Decreases user balance\n', '    function subBalance(address token, address user, uint256 amount)\n', '    {\n', '        if (availableBalanceOf(token, user) < amount) throw; \n', '        updateBalance(token, user, safeSub(balanceOf(token, user), amount));\n', '    }\n', '\n', '\n', '    // Deposit ETH to contract\n', '    function deposit() payable {\n', '        //tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); // adds the deposited amount to user balance\n', '        addBalance(address(0), msg.sender, msg.value); // adds the deposited amount to user balance\n', '        if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number;\n', '        lastActiveTransaction[msg.sender] = block.number; // sets the last activity block for the user\n', '        emit Deposit(address(0), msg.sender, msg.value, balanceOf(address(0), msg.sender)); // fires the deposit event\n', '    }\n', '\n', '    // Deposit token to contract\n', '    function depositToken(address token, uint128 amount) {\n', '        //tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); // adds the deposited amount to user balance\n', '        //if (amount != uint128(amount) || safeAdd(amount, balanceOf(token, msg.sender)) != uint128(amount)) throw;\n', '        addBalance(token, msg.sender, amount); // adds the deposited amount to user balance\n', '\n', '        if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number;\n', '        lastActiveTransaction[msg.sender] = block.number; // sets the last activity block for the user\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\n', '        emit Deposit(token, msg.sender, amount, balanceOf(token, msg.sender)); // fires the deposit event\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) returns (bool success) {\n', '        //if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw; // checks if the inactivity period has passed\n', '        //if (tokens[token][msg.sender] < amount) throw; // checks that user has enough balance\n', '        if (availableBalanceOf(token, msg.sender) < amount) throw;\n', '\n', '        //tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); \n', '        subBalance(token, msg.sender, amount); // subtracts the withdrawed amount from user balance\n', '\n', '        if (token == address(0)) { // checks if withdrawal is a token or ETH, ETH has address 0x00000... \n', '            if (!msg.sender.send(amount)) throw; // send ETH\n', '        } else {\n', '            if (!Token(token).transfer(msg.sender, amount)) throw; // Send token\n', '        }\n', '        emit Withdraw(token, msg.sender, amount, balanceOf(token, msg.sender), 0); // fires the Withdraw event\n', '    }\n', '\n', '    function userAllowFuturesContract(address futuresContract)\n', '    {\n', '        if (!futuresContracts[futuresContract]) throw;\n', '        userAllowedFuturesContracts[msg.sender][futuresContract] = true;\n', '    }\n', '\n', '    // Withdrawal function used by the server to execute withdrawals\n', '    function adminWithdraw(\n', '        address token, // the address of the token to be withdrawn\n', '        uint256 amount, // the amount to be withdrawn\n', '        address user, // address of the user\n', '        uint256 nonce, // nonce to make the request unique\n', '        uint8 v, // part of user signature\n', '        bytes32 r, // part of user signature\n', '        bytes32 s, // part of user signature\n', '        uint256 feeWithdrawal // the transaction gas fee that will be deducted from the user balance\n', '    ) onlyAdmin returns (bool success) {\n', '        bytes32 hash = keccak256(this, token, amount, user, nonce); // creates the hash for the withdrawal request\n', '        if (withdrawn[hash]) throw; // checks if the withdrawal was already executed, if true, throws an error\n', '        withdrawn[hash] = true; // sets the withdrawal as executed\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", hash), v, r, s) != user) throw; // checks that the provided signature is valid\n', '        if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney; // checks that the gas fee is not higher than 0.05 ETH\n', '\n', '\n', '        //if (tokens[token][user] < amount) throw; // checks that user has enough balance\n', '        if (availableBalanceOf(token, user) < amount) throw; // checks that user has enough balance\n', '\n', '        //tokens[token][user] = safeSub(tokens[token][user], amount); // subtracts the withdrawal amount from the user balance\n', '        subBalance(token, user, amount); // subtracts the withdrawal amount from the user balance\n', '\n', '        //tokens[address(0)][user] = safeSub(tokens[address(0x0)][user], feeWithdrawal); // subtracts the gas fee from the user ETH balance\n', '        subBalance(address(0), user, feeWithdrawal); // subtracts the gas fee from the user ETH balance\n', '\n', '        //tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount], feeWithdrawal); // moves the gas fee to the feeAccount\n', '        addBalance(address(0), feeAccount, feeWithdrawal); // moves the gas fee to the feeAccount\n', '\n', '        if (token == address(0)) { // checks if the withdrawal is in ETH or Tokens\n', '            if (!user.send(amount)) throw; // sends ETH\n', '        } else {\n', '            if (!Token(token).transfer(user, amount)) throw; // sends tokens\n', '        }\n', '        lastActiveTransaction[user] = block.number; // sets last user activity block\n', '        emit Withdraw(token, user, amount, balanceOf(token, user), feeWithdrawal); // fires the withdraw event\n', '    }\n', '\n', '    function batchAdminWithdraw(\n', '        address[] token, // the address of the token to be withdrawn\n', '        uint256[] amount, // the amount to be withdrawn\n', '        address[] user, // address of the user\n', '        uint256[] nonce, // nonce to make the request unique\n', '        uint8[] v, // part of user signature\n', '        bytes32[] r, // part of user signature\n', '        bytes32[] s, // part of user signature\n', '        uint256[] feeWithdrawal // the transaction gas fee that will be deducted from the user balance\n', '    ) onlyAdmin \n', '    {\n', '        for (uint i = 0; i < amount.length; i++) {\n', '            adminWithdraw(\n', '                token[i],\n', '                amount[i],\n', '                user[i],\n', '                nonce[i],\n', '                v[i],\n', '                r[i],\n', '                s[i],\n', '                feeWithdrawal[i]\n', '            );\n', '        }\n', '    }\n', '\n', ' \n', '\n', '    function getMakerTakerBalances(address token, address maker, address taker) view returns (uint256[4])\n', '    {\n', '        return [\n', '            balanceOf(token, maker),\n', '            balanceOf(token, taker),\n', '            getReserve(token, maker),\n', '            getReserve(token, taker)\n', '        ];\n', '    }\n', '\n', '    \n', '\n', '    // Structure that holds order values, used inside the trade() function\n', '    struct OrderPair {\n', '        uint256 makerAmountBuy;     // amount being bought by the maker\n', '        uint256 makerAmountSell;    // amount being sold by the maker\n', '        uint256 makerNonce;         // maker order nonce, makes the order unique\n', '        uint256 takerAmountBuy;     // amount being bought by the taker\n', '        uint256 takerAmountSell;    // amount being sold by the taker\n', '        uint256 takerNonce;         // taker order nonce\n', '        uint256 takerGasFee;        // taker gas fee, taker pays the gas\n', '        uint256 takerIsBuying;      // true/false taker is the buyer\n', '\n', '        address makerTokenBuy;      // token bought by the maker\n', '        address makerTokenSell;     // token sold by the maker\n', '        address maker;              // address of the maker\n', '        address takerTokenBuy;      // token bought by the taker\n', '        address takerTokenSell;     // token sold by the taker\n', '        address taker;              // address of the taker\n', '\n', '        bytes32 makerOrderHash;     // hash of the maker order\n', '        bytes32 takerOrderHash;     // has of the taker order\n', '    }\n', '\n', '    // Structure that holds trade values, used inside the trade() function\n', '    struct TradeValues {\n', '        uint256 qty;                // amount to be trade\n', '        uint256 invQty;             // amount to be traded in the opposite token\n', '        uint256 makerAmountTaken;   // final amount taken by the maker\n', '        uint256 takerAmountTaken;   // final amount taken by the taker\n', '    }\n', '\n', '    // Trades balances between user accounts\n', '    function trade(\n', '        uint8[2] v,\n', '        bytes32[4] rs,\n', '        uint256[8] tradeValues,\n', '        address[6] tradeAddresses\n', '    ) returns (uint filledTakerTokenAmount)\n', '    {\n', '\n', '        /* tradeValues\n', '          [0] makerAmountBuy\n', '          [1] makerAmountSell\n', '          [2] makerNonce\n', '          [3] takerAmountBuy\n', '          [4] takerAmountSell\n', '          [5] takerNonce\n', '          [6] takerGasFee\n', '          [7] takerIsBuying\n', '\n', '          tradeAddresses\n', '          [0] makerTokenBuy\n', '          [1] makerTokenSell\n', '          [2] maker\n', '          [3] takerTokenBuy\n', '          [4] takerTokenSell\n', '          [5] taker\n', '        */\n', '\n', '        OrderPair memory t  = OrderPair({\n', '            makerAmountBuy  : tradeValues[0],\n', '            makerAmountSell : tradeValues[1],\n', '            makerNonce      : tradeValues[2],\n', '            takerAmountBuy  : tradeValues[3],\n', '            takerAmountSell : tradeValues[4],\n', '            takerNonce      : tradeValues[5],\n', '            takerGasFee     : tradeValues[6],\n', '            takerIsBuying   : tradeValues[7],\n', '\n', '            makerTokenBuy   : tradeAddresses[0],\n', '            makerTokenSell  : tradeAddresses[1],\n', '            maker           : tradeAddresses[2],\n', '            takerTokenBuy   : tradeAddresses[3],\n', '            takerTokenSell  : tradeAddresses[4],\n', '            taker           : tradeAddresses[5],\n', '\n', '            //                                tokenBuy           amountBuy       tokenSell          amountSell      nonce           user\n', '            makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]),\n', '            takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5])\n', '        });\n', '\n', '        // Checks the signature for the maker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\n', '        {\n', '            emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '       \n', '       // Checks the signature for the taker order\n', '        if (ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\n', '        {\n', '            emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        }\n', '\n', '\n', '        // Checks that orders trade the right tokens\n', '        if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy)\n', '        {\n', '            emit LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', "        } // tokens don't match\n", '\n', '\n', '        // Cheks that gas fee is not higher than 10%\n', '        if (t.takerGasFee > 100 finney)\n', '        {\n', '            emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\n', '            return 0;\n', '        } // takerGasFee too high\n', '\n', '\n', '        // Checks that the prices match.\n', '        // Taker always pays the maker price. This part checks that the taker price is as good or better than the maker price\n', '        if (!(\n', '        (t.takerIsBuying == 0 && safeMul(t.makerAmountSell, 1 ether) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 1 ether) / t.takerAmountSell)\n', '        ||\n', '        (t.takerIsBuying > 0 && safeMul(t.makerAmountBuy, 1 ether) / t.makerAmountSell <= safeMul(t.takerAmountSell, 1 ether) / t.takerAmountBuy)\n', '        ))\n', '        {\n', '            emit LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash);\n', "            return 0; // prices don't match\n", '        }\n', '\n', '        // Initializing trade values structure\n', '        TradeValues memory tv = TradeValues({\n', '            qty                 : 0,\n', '            invQty              : 0,\n', '            makerAmountTaken    : 0,\n', '            takerAmountTaken    : 0\n', '        });\n', '        \n', '        // maker buy, taker sell\n', '        if (t.takerIsBuying == 0)\n', '        {\n', '            // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\n', '            tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy));\n', '            if (tv.qty == 0)\n', '            {\n', '                // order was already filled\n', '                emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '                return 0;\n', '            }\n', '\n', '            // the traded quantity in opposite token terms\n', '            tv.invQty = safeMul(tv.qty, t.makerAmountSell) / t.makerAmountBuy;\n', '\n', '           \n', '            // take fee from Token balance\n', '            tv.makerAmountTaken                         = safeSub(tv.qty, safeMul(tv.qty, makerFee) / (1 ether));                                       // net amount received by maker, excludes maker fee\n', '            //tokens[t.makerTokenBuy][feeAccount]         = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.qty, makerFee) / (1 ether));     // add maker fee to feeAccount\n', '            addBalance(t.makerTokenBuy, feeAccount, safeMul(tv.qty, makerFee) / (1 ether)); // add maker fee to feeAccount\n', '        \n', '\n', '        \n', '            // take fee from Token balance\n', '            tv.takerAmountTaken                         = safeSub(safeSub(tv.invQty, safeMul(tv.invQty, takerFee) / (1 ether)), safeMul(tv.invQty, t.takerGasFee) / (1 ether));                             // amount taken from taker minus taker fee\n', '            //tokens[t.takerTokenBuy][feeAccount]         = safeAdd(tokens[t.takerTokenBuy][feeAccount], safeAdd(safeMul(tv.invQty, takerFee) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether)));   // add taker fee to feeAccount\n', '            addBalance(t.takerTokenBuy, feeAccount, safeAdd(safeMul(tv.invQty, takerFee) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether))); // add taker fee to feeAccount\n', '\n', '\n', '            //tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.invQty);                              // subtract sold token amount from maker balance\n', '            subBalance(t.makerTokenSell, t.maker, tv.invQty); // subtract sold token amount from maker balance\n', '\n', '            //tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);                    // add bought token amount to maker\n', '            addBalance(t.makerTokenBuy, t.maker, tv.makerAmountTaken); // add bought token amount to maker\n', '\n', '            //tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.qty,    makerAffiliateFee) / (1 ether)); // add affiliate commission to maker affiliate balance\n', '\n', '\n', '            //tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.qty);                                 // subtract the sold token amount from taker\n', '            subBalance(t.takerTokenSell, t.taker, tv.qty); // subtract the sold token amount from taker\n', '\n', '            //tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);                    // amount received by taker, excludes taker fee\n', '            //tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.invQty, takerAffiliateFee) / (1 ether)); // add affiliate commission to taker affiliate balance\n', '            addBalance(t.takerTokenBuy, t.taker, tv.takerAmountTaken); // amount received by taker, excludes taker fee\n', '        \n', '            orderFills[t.makerOrderHash]                = safeAdd(orderFills[t.makerOrderHash], tv.qty);                                                // increase the maker order filled amount\n', '            orderFills[t.takerOrderHash]                = safeAdd(orderFills[t.takerOrderHash], safeMul(tv.qty, t.takerAmountBuy) / t.takerAmountSell); // increase the taker order filled amount\n', '            lastActiveTransaction[t.maker]              = block.number; // set last activity block number for maker\n', '            lastActiveTransaction[t.taker]              = block.number; // set last activity block number for taker\n', '\n', '            // fire Trade event\n', '            emit Trade(\n', '                t.takerTokenBuy, tv.qty,\n', '                t.takerTokenSell, tv.invQty,\n', '                t.maker, t.taker,\n', '                makerFee, takerFee,\n', '                tv.makerAmountTaken , tv.takerAmountTaken,\n', '                t.makerOrderHash, t.takerOrderHash\n', '            );\n', '            return tv.qty;\n', '        }\n', '        // maker sell, taker buy\n', '        else\n', '        {\n', '            // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\n', '            tv.qty = min(safeSub(t.makerAmountSell,  safeMul(orderFills[t.makerOrderHash], t.makerAmountSell) / t.makerAmountBuy), safeSub(t.takerAmountBuy, orderFills[t.takerOrderHash]));\n', '            if (tv.qty == 0)\n', '            {\n', '                // order was already filled\n', '                emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\n', '                return 0;\n', '            }            \n', '\n', '            // the traded quantity in opposite token terms\n', '            tv.invQty = safeMul(tv.qty, t.makerAmountBuy) / t.makerAmountSell;\n', '            \n', '           \n', '            // take fee from ETH balance\n', '            tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));                                 // net amount received by maker, excludes maker fee\n', '            //tokens[t.makerTokenBuy][feeAccount]         = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, makerFee) / (1 ether));  // add maker fee to feeAccount\n', '            addBalance(t.makerTokenBuy, feeAccount, safeMul(tv.invQty, makerFee) / (1 ether)); // add maker fee to feeAccount\n', '     \n', '\n', '            // process fees for taker\n', '            \n', '            // take fee from ETH balance\n', '            tv.takerAmountTaken                         = safeSub(safeSub(tv.qty, safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether));                                  // amount taken from taker minus taker fee\n', '            //tokens[t.takerTokenBuy][feeAccount]         = safeAdd(tokens[t.takerTokenBuy][feeAccount], safeAdd(safeMul(tv.qty, takerFee) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether)));     // add taker fee to feeAccount\n', '            addBalance(t.takerTokenBuy, feeAccount, safeAdd(safeMul(tv.qty, takerFee) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether))); // add taker fee to feeAccount\n', '\n', '\n', '\n', '            //tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.qty); // subtract sold token amount from maker balance\n', '            subBalance(t.makerTokenSell, t.maker, tv.qty); // subtract sold token amount from maker balance\n', '\n', '            //tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));   // net amount received by maker, excludes maker fee\n', '            //tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken); // add bought token amount to maker\n', '            addBalance(t.makerTokenBuy, t.maker, tv.makerAmountTaken); // add bought token amount to maker\n', '\n', '            //tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.invQty, makerAffiliateFee) / (1 ether)); // add affiliate commission to maker affiliate balance\n', '\n', '            //tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.invQty); // subtract the sold token amount from taker\n', '            subBalance(t.takerTokenSell, t.taker, tv.invQty);\n', '\n', '            //tv.takerAmountTaken                         = safeSub(safeSub(tv.qty,    safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether)); // amount taken from taker minus taker fee\n', '            //tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken); // amount received by taker, excludes taker fee\n', '            addBalance(t.takerTokenBuy, t.taker, tv.takerAmountTaken); // amount received by taker, excludes taker fee\n', '\n', '            //tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.qty,    takerAffiliateFee) / (1 ether)); // add affiliate commission to taker affiliate balance\n', '\n', '            //tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, safeSub(makerFee, makerAffiliateFee)) / (1 ether)); // add maker fee excluding affiliate commission to feeAccount\n', '            //tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.qty,    safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether))); // add taker fee excluding affiliate commission to feeAccount\n', '\n', '            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.invQty); // increase the maker order filled amount\n', '            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty);  // increase the taker order filled amount\n', '            lastActiveTransaction[t.maker]          = block.number; // set last activity block number for maker\n', '            lastActiveTransaction[t.taker]          = block.number; // set last activity block number for taker\n', '\n', '            // fire Trade event\n', '            emit Trade(\n', '                t.takerTokenBuy, tv.qty,\n', '                t.takerTokenSell, tv.invQty,\n', '                t.maker, t.taker,\n', '                makerFee, takerFee,\n', '                tv.makerAmountTaken , tv.takerAmountTaken,\n', '                t.makerOrderHash, t.takerOrderHash\n', '            );\n', '            return tv.qty;\n', '        }\n', '    }\n', '\n', '\n', '    // Executes multiple trades in one transaction, saves gas fees\n', '    function batchOrderTrade(\n', '        uint8[2][] v,\n', '        bytes32[4][] rs,\n', '        uint256[8][] tradeValues,\n', '        address[6][] tradeAddresses\n', '    ) \n', '    {\n', '        for (uint i = 0; i < tradeAddresses.length; i++) {\n', '            trade(\n', '                v[i],\n', '                rs[i],\n', '                tradeValues[i],\n', '                tradeAddresses[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    // Cancels order by setting amount filled to toal order amount\n', '    function cancelOrder(\n', '\t\t/*\n', '\t\t[0] orderV\n', '\t\t[1] cancelV\n', '\t\t*/\n', '\t    uint8[2] v,\n', '\n', '\t\t/*\n', '\t\t[0] orderR\n', '\t\t[1] orderS\n', '\t\t[2] cancelR\n', '\t\t[3] cancelS\n', '\t\t*/\n', '\t    bytes32[4] rs,\n', '\n', '\t\t/*\n', '\t\t[0] orderAmountBuy\n', '\t\t[1] orderAmountSell\n', '\t\t[2] orderNonce\n', '\t\t[3] cancelNonce\n', '\t\t[4] cancelFee\n', '\t\t*/\n', '\t\tuint256[5] cancelValues,\n', '\n', '\t\t/*\n', '\t\t[0] orderTokenBuy\n', '\t\t[1] orderTokenSell\n', '\t\t[2] orderUser\n', '\t\t[3] cancelUser\n', '\t\t*/\n', '\t\taddress[4] cancelAddresses\n', '    ) public {\n', '        // Order values should be valid and signed by order owner\n', '        bytes32 orderHash = keccak256(\n', '\t        this, cancelAddresses[0], cancelValues[0], cancelAddresses[1],\n', '\t        cancelValues[1], cancelValues[2], cancelAddresses[2]\n', '        );\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);\n', '\n', '        // Cancel action should be signed by order owner\n', '        bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]);\n', '        require(ecrecover(keccak256("\\x19Ethereum Signed Message:\\n32", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);\n', '\n', "        // Order owner should be the same as cancel's initiator\n", '        require(cancelAddresses[2] == cancelAddresses[3]);\n', '\n', '        // Do not allow to cancel already canceled or filled orders\n', '        require(orderFills[orderHash] != cancelValues[0]);\n', '\n', '        // Cancel gas fee cannot exceed 0.05 ETh\n', '        if (cancelValues[4] > 50 finney) {\n', '            cancelValues[4] = 50 finney;\n', '        }\n', '\n', '        // Take cancel fee\n', '        // This operation throws an error if fee amount is greater than the user balance\n', '        //tokens[address(0)][cancelAddresses[3]] = safeSub(tokens[address(0)][cancelAddresses[3]], cancelValues[4]);\n', '        subBalance(address(0), cancelAddresses[3], cancelValues[4]);\n', '\n', '        // Cancel order by setting amount filled to total order value, i.e. making the order filled\n', '        orderFills[orderHash] = cancelValues[0];\n', '\n', '        // Fire cancel order event\n', '        emit CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]);\n', '    }\n', '\n', '    // Returns the smaller of two values\n', '    function min(uint a, uint b) private pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}']