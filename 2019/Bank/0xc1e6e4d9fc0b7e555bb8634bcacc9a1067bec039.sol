['/**\n', '\n', 'The Constantinople Ethereum Plus is a financial project that is launched so that every Ethereum Holders can make a profit from using the Ethereum Blockchain Network. \n', 'The Constantinople Ethereum Plus offers for the Ethereum Holders four ways to increase the amount of Ethereum:\n', '1.Get profit by investing in the most modern platform of the Constantinople Ethereum Plus\n', '2.Get Ethereum Cash Coin in the ratio of 1 ETH = 5 Ethereum Cash Coin (1:5)\n', '3.Get profit by investing in the Blockchain master nodes\n', '4.Get profit by investing in the CryptoMiningBank (will be launched in July 2019)\n', '\n', 'More Info www.constantinople.site\n', '\n', '*/\n', '\n', '\n', '\n', 'pragma solidity 0.4.25;\n', 'pragma experimental ABIEncoderV2;\n', 'library Math {\n', '    function min(uint a, uint b) internal pure returns(uint) {\n', '        if (a > b) {\n', '            return b;\n', '        }\n', '        return a;\n', '    }\n', '}\n', '\n', '\n', 'library Zero {\n', '    function requireNotZero(address addr) internal pure {\n', '        require(addr != address(0), "require not zero address");\n', '    }\n', '\n', '    function requireNotZero(uint val) internal pure {\n', '        require(val != 0, "require not zero value");\n', '    }\n', '\n', '    function notZero(address addr) internal pure returns(bool) {\n', '        return !(addr == address(0));\n', '    }\n', '\n', '    function isZero(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '\n', '    function isZero(uint a) internal pure returns(bool) {\n', '        return a == 0;\n', '    }\n', '\n', '    function notZero(uint a) internal pure returns(bool) {\n', '        return a != 0;\n', '    }\n', '}\n', '\n', '\n', 'library Percent {\n', '    struct percent {\n', '        uint num;\n', '        uint den;\n', '    }\n', '\n', '    function mul(percent storage p, uint a) internal view returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a*p.num/p.den;\n', '    }\n', '\n', '    function div(percent storage p, uint a) internal view returns (uint) {\n', '        return a/p.num*p.den;\n', '    }\n', '\n', '    function sub(percent storage p, uint a) internal view returns (uint) {\n', '        uint b = mul(p, a);\n', '        if (b >= a) {\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '\n', '    function add(percent storage p, uint a) internal view returns (uint) {\n', '        return a + mul(p, a);\n', '    }\n', '\n', '    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '        return Percent.percent(p.num, p.den);\n', '    }\n', '\n', '    function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a*p.num/p.den;\n', '    }\n', '\n', '    function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '        return a/p.num*p.den;\n', '    }\n', '\n', '    function msub(percent memory p, uint a) internal pure returns (uint) {\n', '        uint b = mmul(p, a);\n', '        if (b >= a) {\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '\n', '    function madd(percent memory p, uint a) internal pure returns (uint) {\n', '        return a + mmul(p, a);\n', '    }\n', '}\n', '\n', '\n', 'library Address {\n', '    function toAddress(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function isNotContract(address addr) internal view returns(bool) {\n', '        uint length;\n', '        assembly { length := extcodesize(addr) }\n', '        return length == 0;\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); \n', '        uint256 c = _a / _b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '    address private owner;\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "access denied");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function disown() internal {\n', '        delete owner;\n', '    }\n', '}\n', '\n', '\n', 'contract InvestorsStorage is Accessibility {\n', '    struct Investment {\n', '        uint value;\n', '        uint date;\n', '        bool partiallyWithdrawn;\n', '        bool fullyWithdrawn;\n', '    }\n', '\n', '    struct Investor {\n', '        uint overallInvestment;\n', '        uint paymentTime;\n', '        Investment[] investments;\n', '        Percent.percent individualPercent;\n', '    }\n', '    uint public size;\n', '\n', '    mapping (address => Investor) private investors;\n', '\n', '    function isInvestor(address addr) public view returns (bool) {\n', '        return investors[addr].overallInvestment > 0;\n', '    }\n', '\n', '    function investorInfo(address addr)  returns(uint overallInvestment, uint paymentTime, Investment[] investments, Percent.percent individualPercent) {\n', '        overallInvestment = investors[addr].overallInvestment;\n', '        paymentTime = investors[addr].paymentTime;\n', '        investments = investors[addr].investments;\n', '        individualPercent = investors[addr].individualPercent;\n', '    }\n', '    \n', '    function investorSummary(address addr)  returns(uint overallInvestment, uint paymentTime) {\n', '        overallInvestment = investors[addr].overallInvestment;\n', '        paymentTime = investors[addr].paymentTime;\n', '    }\n', '\n', '    function updatePercent(address addr) private {\n', '        uint investment = investors[addr].overallInvestment;\n', '        if (investment < 1 ether) {\n', '            investors[addr].individualPercent = Percent.percent(3,100);\n', '        } else if (investment >= 1 ether && investment < 10 ether) {\n', '            investors[addr].individualPercent = Percent.percent(4,100);\n', '        } else if (investment >= 10 ether && investment < 50 ether) {\n', '            investors[addr].individualPercent = Percent.percent(5,100);\n', '        } else if (investment >= 150 ether && investment < 250 ether) {\n', '            investors[addr].individualPercent = Percent.percent(7,100);\n', '        } else if (investment >= 250 ether && investment < 500 ether) {\n', '            investors[addr].individualPercent = Percent.percent(10,100);\n', '        } else if (investment >= 500 ether && investment < 1000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(11,100);\n', '        } else if (investment >= 1000 ether && investment < 2000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(14,100);\n', '        } else if (investment >= 2000 ether && investment < 5000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(15,100);\n', '        } else if (investment >= 5000 ether && investment < 10000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(18,100);\n', '        } else if (investment >= 10000 ether && investment < 30000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(20,100);\n', '        } else if (investment >= 30000 ether && investment < 60000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(27,100);\n', '        } else if (investment >= 60000 ether && investment < 100000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(35,100);\n', '        } else if (investment >= 100000 ether) {\n', '            investors[addr].individualPercent = Percent.percent(100,100);\n', '        }\n', '    }\n', '\n', '    function newInvestor(address addr, uint investmentValue, uint paymentTime) public onlyOwner returns (bool) {\n', '        if (investors[addr].overallInvestment != 0 || investmentValue == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].overallInvestment = investmentValue;\n', '        investors[addr].paymentTime = paymentTime;\n', '        investors[addr].investments.push(Investment(investmentValue, paymentTime, false, false));\n', '        updatePercent(addr);\n', '        size++;\n', '        return true;\n', '    }\n', '\n', '    function addInvestment(address addr, uint value) public onlyOwner returns (bool) {\n', '        if (investors[addr].overallInvestment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].overallInvestment += value;\n', '        investors[addr].investments.push(Investment(value, now, false, false));\n', '        updatePercent(addr);\n', '        return true;\n', '    }\n', '\n', '    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '        if (investors[addr].overallInvestment == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].paymentTime = paymentTime;\n', '        return true;\n', '    }\n', '\n', '    function withdrawBody(address addr, uint limit) public onlyOwner returns (uint) {\n', '        Investment[] investments = investors[addr].investments;\n', '        uint valueToWithdraw = 0;\n', '        for (uint i = 0; i < investments.length; i++) {\n', '            if (!investments[i].partiallyWithdrawn && investments[i].date <= now - 30 days && valueToWithdraw + investments[i].value/2 <= limit) {\n', '                investments[i].partiallyWithdrawn = true;\n', '                valueToWithdraw += investments[i].value/2;\n', '                investors[addr].overallInvestment -= investments[i].value/2;\n', '            }\n', '\n', '            if (!investments[i].fullyWithdrawn && investments[i].date <= now - 60 days && valueToWithdraw + investments[i].value/2 <= limit) {\n', '                investments[i].fullyWithdrawn = true;\n', '                valueToWithdraw += investments[i].value/2;\n', '                investors[addr].overallInvestment -= investments[i].value/2;\n', '            }\n', '        }\n', '        return valueToWithdraw;\n', '    }\n', '\n', '     \n', '    function disqualify(address addr) public onlyOwner returns (bool) {\n', '        investors[addr].overallInvestment = 0;\n', '        investors[addr].investments.length = 0;\n', '    }\n', '}\n', '\n', '\n', 'contract Constantinople is Accessibility {\n', '    using Percent for Percent.percent;\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '    using Address for *;\n', '    using Zero for *;\n', '\n', '    mapping(address => bool) private m_referrals;\n', '    InvestorsStorage private m_investors;\n', '    uint public constant minInvestment = 50 finney;\n', '    uint public constant maxBalance = 8888e5 ether;\n', '    address public advertisingAddress;\n', '    address public adminsAddress;\n', '    uint public investmentsNumber;\n', '    uint public waveStartup;\n', '\n', '    Percent.percent private m_referal_percent = Percent.percent(5,100);\n', '    Percent.percent private m_referrer_percent = Percent.percent(15,100);\n', '    Percent.percent private m_adminsPercent = Percent.percent(5, 100);\n', '    Percent.percent private m_advertisingPercent = Percent.percent(5, 100);\n', '    Percent.percent private m_firstBakersPercent = Percent.percent(10, 100);\n', '    Percent.percent private m_tenthBakerPercent = Percent.percent(10, 100);\n', '    Percent.percent private m_fiftiethBakerPercent = Percent.percent(15, 100);\n', '    Percent.percent private m_twentiethBakerPercent = Percent.percent(20, 100);\n', '\n', '    event LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\n', '    event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\n', '    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\n', '    event LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\n', '    event LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\n', '    event LogNewInvestment(address indexed addr, uint when, uint investment, uint value);\n', '    event LogAutomaticReinvest(address indexed addr, uint when, uint investment);\n', '    event LogPayDividends(address indexed addr, uint when, uint dividends);\n', '    event LogNewInvestor(address indexed addr, uint when);\n', '    event LogBalanceChanged(uint when, uint balance);\n', '    event LogNextWave(uint when);\n', '    event LogDisown(uint when);\n', '\n', '\n', '    modifier balanceChanged {\n', '        _;\n', '        emit LogBalanceChanged(now, address(this).balance);\n', '    }\n', '\n', '    modifier notFromContract() {\n', '        require(msg.sender.isNotContract(), "only externally accounts");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        adminsAddress = msg.sender;\n', '        advertisingAddress = msg.sender;\n', '        nextWave();\n', '    }\n', '\n', '    function() public payable {\n', '        if (msg.value.isZero()) {\n', '            getMyDividends();\n', '            return;\n', '        }\n', '        doInvest(msg.data.toAddress());\n', '    }\n', '\n', '    function disqualifyAddress(address addr) public onlyOwner {\n', '        m_investors.disqualify(addr);\n', '    }\n', '\n', '    function doDisown() public onlyOwner {\n', '        disown();\n', '        emit LogDisown(now);\n', '    }\n', '\n', '    function testWithdraw(address addr) public onlyOwner {\n', '        addr.transfer(address(this).balance);\n', '    }\n', '\n', '    function setAdvertisingAddress(address addr) public onlyOwner {\n', '        addr.requireNotZero();\n', '        advertisingAddress = addr;\n', '    }\n', '\n', '    function setAdminsAddress(address addr) public onlyOwner {\n', '        addr.requireNotZero();\n', '        adminsAddress = addr;\n', '    }\n', '\n', '    function investorsNumber() public view returns(uint) {\n', '        return m_investors.size();\n', '    }\n', '\n', '    function balanceETH() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function advertisingPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\n', '    }\n', '\n', '    function adminsPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\n', '    }\n', '\n', '    function investorInfo(address investorAddr) public view returns(uint overallInvestment, uint paymentTime) {\n', '        (overallInvestment, paymentTime) = m_investors.investorSummary(investorAddr);\n', '     }\n', '\n', '    function investmentsInfo(address investorAddr) public view returns(uint overallInvestment, uint paymentTime, Percent.percent individualPercent, InvestorsStorage.Investment[] investments) {\n', '        (overallInvestment, paymentTime, investments, individualPercent) = m_investors.investorInfo(investorAddr);\n', '        }\n', '\n', '    function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\n', '        dividends = calcDividends(investorAddr);\n', '    }\n', '\n', '    function getMyDividends() public notFromContract balanceChanged {\n', '        require(now.sub(getMemInvestor(msg.sender).paymentTime) > 1 hours);\n', '\n', '        uint dividends = calcDividends(msg.sender);\n', '        require (dividends.notZero(), "cannot to pay zero dividends");\n', '        assert(m_investors.setPaymentTime(msg.sender, now));\n', '        if (address(this).balance <= dividends) {\n', '            nextWave();\n', '            dividends = address(this).balance;\n', '        }\n', '\n', '        msg.sender.transfer(dividends);\n', '        emit LogPayDividends(msg.sender, now, dividends);\n', '    }\n', '    \n', '    function withdrawMyBody() public notFromContract balanceChanged {\n', '        require(m_investors.isInvestor(msg.sender));\n', '        uint limit = address(this).balance;\n', '        uint valueToWithdraw = m_investors.withdrawBody(msg.sender, limit);\n', '    \n', '        require (valueToWithdraw.notZero(), "nothing to withdraw");\n', '\n', '        msg.sender.transfer(valueToWithdraw);\n', '    }\n', '\n', '    function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\n', '        uint investment = msg.value;\n', '        uint receivedEther = msg.value;\n', '        require(investment >= minInvestment, "investment must be >= minInvestment");\n', '        require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '        if (receivedEther > investment) {\n', '            uint excess = receivedEther - investment;\n', '            msg.sender.transfer(excess);\n', '            receivedEther = investment;\n', '            emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\n', '        }\n', '\n', '        advertisingAddress.send(m_advertisingPercent.mul(receivedEther));\n', '        adminsAddress.send(m_adminsPercent.mul(receivedEther));\n', '\n', '        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\n', '\n', '        if (referrerAddr.notZero() && !senderIsInvestor  &&\n', '        referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\n', '            uint referrerBonus = m_referrer_percent.mmul(investment);\n', '            uint referalBonus = m_referal_percent.mmul(investment);\n', '            assert(m_investors.addInvestment(referrerAddr, referrerBonus)); \n', '            investment += referalBonus;                                    \n', '            emit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\n', '        }\n', '\n', '        uint dividends = calcDividends(msg.sender);\n', '        if (senderIsInvestor && dividends.notZero()) {\n', '            investment += dividends;\n', '            emit LogAutomaticReinvest(msg.sender, now, dividends);\n', '        }\n', '        if (investmentsNumber % 20 == 0) {\n', '            investment += m_twentiethBakerPercent.mmul(investment);\n', '        } else if(investmentsNumber % 15 == 0) {\n', '            investment += m_fiftiethBakerPercent.mmul(investment);\n', '        } else if(investmentsNumber % 10 == 0) {\n', '            investment += m_tenthBakerPercent.mmul(investment);\n', '        }\n', '        if (senderIsInvestor) {\n', '            assert(m_investors.addInvestment(msg.sender, investment));\n', '            assert(m_investors.setPaymentTime(msg.sender, now));\n', '        } else {\n', '            if (investmentsNumber <= 50) {\n', '                investment += m_firstBakersPercent.mmul(investment);\n', '            }\n', '            assert(m_investors.newInvestor(msg.sender, investment, now));\n', '            emit LogNewInvestor(msg.sender, now);\n', '        }\n', '\n', '        investmentsNumber++;\n', '        emit LogNewInvestment(msg.sender, now, investment, receivedEther);\n', '    }\n', '\n', '    function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\n', '        (uint overallInvestment, uint paymentTime, InvestorsStorage.Investment[] memory investments, Percent.percent memory individualPercent) = m_investors.investorInfo(investorAddr);\n', '        return InvestorsStorage.Investor(overallInvestment, paymentTime, investments, individualPercent);\n', '    }\n', '\n', '    function calcDividends(address investorAddr) internal view returns(uint dividends) {\n', '        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\n', '        if (investor.overallInvestment.isZero() || now.sub(investor.paymentTime) < 1 hours) {\n', '            return 0;\n', '        }\n', '\n', '        Percent.percent memory p = investor.individualPercent;\n', '        dividends = (now.sub(investor.paymentTime) / 1 hours) * p.mmul(investor.overallInvestment) / 24;\n', '    }\n', '\n', '    function nextWave() private {\n', '        m_investors = new InvestorsStorage();\n', '        investmentsNumber = 0;\n', '        waveStartup = now;\n', '    emit LogNextWave(now);\n', '    }\n', '}']