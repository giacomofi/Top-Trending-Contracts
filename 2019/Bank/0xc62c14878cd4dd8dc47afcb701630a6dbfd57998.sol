['pragma solidity 0.4.25;\n', '\n', 'contract ERC20Interface {\n', '\n', '  function totalSupply() public constant returns(uint);\n', '\n', '  function balanceOf(address tokenOwner) public constant returns(uint balance);\n', '\n', '  function allowance(address tokenOwner, address spender) public constant returns(uint remaining);\n', '\n', '  function transfer(address to, uint tokens) public returns(bool success);\n', '\n', '  function approve(address spender, uint tokens) public returns(bool success);\n', '\n', '  function transferFrom(address from, address to, uint tokens) public returns(bool success);\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '}\n', '\n', 'contract _0xBitconnect {\n', '  using SafeMath\n', '  for uint;\n', '\n', '  /*=================================\n', '  =            MODIFIERS            =\n', '  =================================*/\n', '\n', '  modifier onlyHolders() {\n', '    require(myFrontEndTokens() > 0);\n', '    _;\n', '  }\n', '\n', '  modifier dividendHolder() {\n', '    require(myDividends(true) > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdministrator() {\n', '    address _customerAddress = msg.sender;\n', '    require(administrators[_customerAddress]);\n', '    _;\n', '  }\n', '\n', '  /*==============================\n', '  =            EVENTS            =\n', '  ==============================*/\n', '\n', '  event onTokenPurchase(\n', '    address indexed customerAddress,\n', '    uint incoming,\n', '    uint8 dividendRate,\n', '    uint tokensMinted,\n', '    address indexed referredBy\n', '  );\n', '\n', '  event UserDividendRate(\n', '    address user,\n', '    uint divRate\n', '  );\n', '\n', '  event onTokenSell(\n', '    address indexed customerAddress,\n', '    uint tokensBurned,\n', '    uint earned\n', '  );\n', '\n', '  event onReinvestment(\n', '    address indexed customerAddress,\n', '    uint reinvested,\n', '    uint tokensMinted\n', '  );\n', '\n', '  event onWithdraw(\n', '    address indexed customerAddress,\n', '    uint withdrawn\n', '  );\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens\n', '  );\n', '\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens\n', '  );\n', '\n', '  event Allocation(\n', '    uint toBankRoll,\n', '    uint toReferrer,\n', '    uint toTokenHolders,\n', '    uint toDivCardHolders,\n', '    uint forTokens\n', '  );\n', '\n', '  event Referral(\n', '    address referrer,\n', '    uint amountReceived\n', '  );\n', '\n', '  /*=====================================\n', '  =            CONSTANTS                =\n', '  =====================================*/\n', '\n', '  uint8 constant public decimals = 18;\n', '\n', '  uint constant internal magnitude = 2 ** 64;\n', '\n', '  uint constant internal MULTIPLIER = 1140;\n', '\n', '  uint constant internal MIN_TOK_BUYIN = 0.0001 ether;\n', '  uint constant internal MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n', '  uint constant internal MIN_TOKEN_TRANSFER = 1e10;\n', '  uint constant internal referrer_percentage = 25;\n', '  uint constant internal MAX_SUPPLY = 1e25;\n', '\n', '  ERC20Interface internal _0xBTC;\n', '\n', '  uint public stakingRequirement = 100e18;\n', '\n', '  /*================================\n', '   =          CONFIGURABLES         =\n', '   ================================*/\n', '\n', '  string public name = "0xBitconnect";\n', '  string public symbol = "0xBCC";\n', '\n', '  address internal bankrollAddress;\n', '\n', '  _0xBitconnectDividendCards divCardContract;\n', '\n', '  /*================================\n', '   =            DATASETS            =\n', '   ================================*/\n', '\n', '  // Tracks front & backend tokens\n', '  mapping(address => uint) internal frontTokenBalanceLedger_;\n', '  mapping(address => uint) internal dividendTokenBalanceLedger_;\n', '  mapping(address =>\n', '    mapping(address => uint))\n', '  public allowed;\n', '\n', '  // Tracks dividend rates for users\n', '  mapping(uint8 => bool) internal validDividendRates_;\n', '  mapping(address => bool) internal userSelectedRate;\n', '  mapping(address => uint8) internal userDividendRate;\n', '\n', '  // Payout tracking\n', '  mapping(address => uint) internal referralBalance_;\n', '  mapping(address => int256) internal payoutsTo_;\n', '\n', '  uint public current0xbtcInvested;\n', '\n', '  uint internal tokenSupply = 0;\n', '  uint internal divTokenSupply = 0;\n', '\n', '  uint internal profitPerDivToken;\n', '\n', '  mapping(address => bool) public administrators;\n', '\n', '  bool public regularPhase = false;\n', '\n', '  /*=======================================\n', '  =            PUBLIC FUNCTIONS           =\n', '  =======================================*/\n', '  constructor(address _bankrollAddress, address _divCardAddress, address _btcAddress)\n', '  public {\n', '    bankrollAddress = _bankrollAddress;\n', '    divCardContract = _0xBitconnectDividendCards(_divCardAddress);\n', '    _0xBTC = ERC20Interface(_btcAddress);\n', '\n', '    administrators[msg.sender] = true; // Helps with debugging!\n', '\n', '    validDividendRates_[10] = true;\n', '    validDividendRates_[20] = true;\n', '    validDividendRates_[30] = true;\n', '\n', '    userSelectedRate[bankrollAddress] = true;\n', '    userDividendRate[bankrollAddress] = 30;\n', '\n', '  /*=======================================\n', '  =             INITIAL HEAVEN            =\n', '  =======================================*/\n', '\n', '    uint initiallyAssigned = 3*10**24;\n', '\n', '    address heavenA = 0xA7cDc6cF8E8a4db39bc03ac675662D6E2F8F84f3;\n', '    address heavenB = 0xbC539A28e85c587987297da7039949eA23b51723;\n', '\n', '    userSelectedRate[heavenA] = true;\n', '    userDividendRate[heavenA] = 30;\n', '\n', '    userSelectedRate[heavenB] = true;\n', '    userDividendRate[heavenB] = 30;\n', '\n', '    tokenSupply = tokenSupply.add(initiallyAssigned);\n', '    divTokenSupply = divTokenSupply.add(initiallyAssigned.mul(30));\n', '\n', '    profitPerDivToken = profitPerDivToken.add((initiallyAssigned.mul(magnitude)).div(divTokenSupply));\n', '    \n', '    payoutsTo_[heavenA] += (int256)((profitPerDivToken * (initiallyAssigned.div(3)).mul(userDividendRate[heavenA])));\n', '    payoutsTo_[heavenB] += (int256)((profitPerDivToken * (initiallyAssigned.div(3)).mul(userDividendRate[heavenB])));\n', '    payoutsTo_[bankrollAddress] += (int256)((profitPerDivToken * (initiallyAssigned.div(3)).mul(userDividendRate[bankrollAddress])));\n', '\n', '\n', '    frontTokenBalanceLedger_[heavenA] = frontTokenBalanceLedger_[heavenA].add(initiallyAssigned.div(3));\n', '    dividendTokenBalanceLedger_[heavenA] = dividendTokenBalanceLedger_[heavenA].add((initiallyAssigned.div(3)).mul(userDividendRate[heavenA]));\n', '\n', '    frontTokenBalanceLedger_[heavenB] = frontTokenBalanceLedger_[heavenB].add(initiallyAssigned.div(3));\n', '    dividendTokenBalanceLedger_[heavenB] = dividendTokenBalanceLedger_[heavenB].add((initiallyAssigned.div(3)).mul(userDividendRate[heavenB]));\n', '\n', '    frontTokenBalanceLedger_[bankrollAddress] = frontTokenBalanceLedger_[bankrollAddress].add(initiallyAssigned.div(3));\n', '    dividendTokenBalanceLedger_[bankrollAddress] = dividendTokenBalanceLedger_[bankrollAddress].add((initiallyAssigned.div(3)).mul(userDividendRate[bankrollAddress]));\n', '\n', '\n', '  }\n', '\n', '  /**\n', '   * Same as buy, but explicitly sets your dividend percentage.\n', "   * If this has been called before, it will update your `default' dividend\n", '   *   percentage for regular buy transactions going forward.\n', '   */\n', '  function buyAndSetDivPercentage(uint _0xbtcAmount, address _referredBy, uint8 _divChoice, string providedUnhashedPass)\n', '  public\n', '  returns(uint) {\n', '\n', '    require(regularPhase);\n', '\n', '    // Dividend percentage should be a currently accepted value.\n', '    require(validDividendRates_[_divChoice]);\n', '\n', '    // Set the dividend fee percentage denominator.\n', '    userSelectedRate[msg.sender] = true;\n', '    userDividendRate[msg.sender] = _divChoice;\n', '    emit UserDividendRate(msg.sender, _divChoice);\n', '\n', '    // Finally, purchase tokens.\n', '    purchaseTokens(_0xbtcAmount, _referredBy, false);\n', '  }\n', '\n', '  // All buys except for the above one require regular phase.\n', '\n', '  function buy(uint _0xbtcAmount, address _referredBy)\n', '  public\n', '  returns(uint) {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    purchaseTokens(_0xbtcAmount, _referredBy, false);\n', '  }\n', '\n', '  function buyAndTransfer(uint _0xbtcAmount, address _referredBy, address target)\n', '  public {\n', '    bytes memory empty;\n', '    buyAndTransfer(_0xbtcAmount, _referredBy, target, empty, 20);\n', '  }\n', '\n', '  function buyAndTransfer(uint _0xbtcAmount, address _referredBy, address target, bytes _data)\n', '  public {\n', '    buyAndTransfer(_0xbtcAmount, _referredBy, target, _data, 20);\n', '  }\n', '\n', '  // Overload\n', '  function buyAndTransfer(uint _0xbtcAmount, address _referredBy, address target, bytes _data, uint8 divChoice)\n', '  public {\n', '    require(regularPhase);\n', '    address _customerAddress = msg.sender;\n', '    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n', '    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n', '      purchaseTokens(_0xbtcAmount, _referredBy, false);\n', '    } else {\n', '      buyAndSetDivPercentage(_0xbtcAmount, _referredBy, divChoice, "0x0");\n', '    }\n', '    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n', '    transferTo(msg.sender, target, difference, _data);\n', '  }\n', '\n', '  // No Fallback functionality\n', '  function () public {\n', '    revert();\n', '  }\n', '\n', '  function reinvest()\n', '  dividendHolder()\n', '  public {\n', '    require(regularPhase);\n', '    uint _dividends = myDividends(false);\n', '\n', "    // Pay out requisite `virtual' dividends.\n", '    address _customerAddress = msg.sender;\n', '    payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    uint _tokens = purchaseTokens(_dividends.div(1e10), address(0), true); //to 8 Decimals\n', '\n', '    // Fire logging event.\n', '    emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '  }\n', '\n', '  function exit()\n', '  public {\n', '    require(regularPhase);\n', '    // Retrieve token balance for caller, then sell them all.\n', '    address _customerAddress = msg.sender;\n', '    uint _tokens = frontTokenBalanceLedger_[_customerAddress];\n', '\n', '    if (_tokens > 0) sell(_tokens);\n', '\n', '    withdraw(_customerAddress);\n', '  }\n', '\n', '  function withdraw(address _recipient)\n', '  dividendHolder()\n', '  public {\n', '    require(regularPhase);\n', '    // Setup data\n', '    address _customerAddress = msg.sender;\n', '    uint _dividends = myDividends(false);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    if (_recipient == address(0x0)) {\n', '      _recipient = msg.sender;\n', '    }\n', '\n', '    _dividends = _dividends.div(1e10); //to 8 decimals\n', '    _0xBTC.transfer(_recipient, _dividends);\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_recipient, _dividends);\n', '  }\n', '\n', '  // Sells front-end tokens.\n', '  function sell(uint _amountOfTokens)\n', '  onlyHolders()\n', '  public {\n', '    require(regularPhase);\n', '\n', '    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '\n', '    uint _frontEndTokensToBurn = _amountOfTokens;\n', '\n', '    // Calculate how many dividend tokens this action burns.\n', "    // Computed as the caller's average dividend rate multiplied by the number of front-end tokens held.\n", '    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n', '    uint userDivRate = getUserAverageDividendRate(msg.sender);\n', '    require((2 * magnitude) <= userDivRate && (50 * magnitude) >= userDivRate);\n', '    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n', '\n', '    // Calculate 0xbtc received before dividends\n', '    uint _0xbtc = tokensTo0xbtc_(_frontEndTokensToBurn);\n', '\n', '    if (_0xbtc > current0xbtcInvested) {\n', "      // Well, congratulations, you've emptied the coffers.\n", '      current0xbtcInvested = 0;\n', '    } else {\n', '      current0xbtcInvested = current0xbtcInvested - _0xbtc;\n', '    }\n', '\n', '    // Calculate dividends generated from the sale.\n', '    uint _dividends = (_0xbtc.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n', '\n', '    // Calculate 0xbtc receivable net of dividends.\n', '    uint _taxed0xbtc = _0xbtc.sub(_dividends);\n', '\n', '    // Burn the sold tokens (both front-end and back-end variants).\n', '    tokenSupply = tokenSupply.sub(_frontEndTokensToBurn);\n', '    divTokenSupply = divTokenSupply.sub(_divTokensToBurn);\n', '\n', '    // Subtract the token balances for the seller\n', '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n', '\n', '    // Update dividends tracker\n', '    int256 _updatedPayouts = (int256)(profitPerDivToken * _divTokensToBurn + (_taxed0xbtc * magnitude));\n', '    payoutsTo_[msg.sender] -= _updatedPayouts;\n', '\n', "    // Let's avoid breaking arithmetic where we can, eh?\n", '    if (divTokenSupply > 0) {\n', '      // Update the value of each remaining back-end dividend token.\n', '      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxed0xbtc);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder.\n', "   * No charge incurred for the transfer. We'd make a terrible bank.\n", '   */\n', '  function transfer(address _toAddress, uint _amountOfTokens)\n', '  onlyHolders()\n', '  public\n', '  returns(bool) {\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER &&\n', '      _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n', '    bytes memory empty;\n', '    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n', '    return true;\n', '\n', '  }\n', '\n', '  function approve(address spender, uint tokens)\n', '  public\n', '  returns(bool) {\n', '    address _customerAddress = msg.sender;\n', '    allowed[_customerAddress][spender] = tokens;\n', '\n', '    // Fire logging event.\n', '    emit Approval(_customerAddress, spender, tokens);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n', "   * No charge incurred for the transfer. No seriously, we'd make a terrible bank.\n", '   */\n', '  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n', '  public\n', '  returns(bool) {\n', '    // Setup variables\n', '    address _customerAddress = _from;\n', '    bytes memory empty;\n', "    // Make sure we own the tokens we're transferring, are ALLOWED to transfer that many tokens,\n", '    // and are transferring at least one full token.\n', '    require(_amountOfTokens >= MIN_TOKEN_TRANSFER &&\n', '      _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress] &&\n', '      _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n', '\n', '    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n', '\n', '    // Good old ERC20.\n', '    return true;\n', '\n', '  }\n', '\n', '  function transferTo(address _from, address _to, uint _amountOfTokens, bytes _data)\n', '  public {\n', '    if (_from != msg.sender) {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER &&\n', '        _amountOfTokens <= frontTokenBalanceLedger_[_from] &&\n', '        _amountOfTokens <= allowed[_from][msg.sender]);\n', '    } else {\n', '      require(_amountOfTokens >= MIN_TOKEN_TRANSFER &&\n', '        _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n', '    }\n', '\n', '    transferFromInternal(_from, _to, _amountOfTokens, _data);\n', '  }\n', '\n', "  // Who'd have thought we'd need this thing floating around?\n", '  function totalSupply()\n', '  public\n', '  view\n', '  returns(uint256) {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '\n', '  function startRegularPhase()\n', '  onlyAdministrator\n', '  public {\n', '    regularPhase = true;\n', '  }\n', '\n', '  // The death of a great man demands the birth of a great son.\n', '  function setAdministrator(address _newAdmin, bool _status)\n', '  onlyAdministrator()\n', '  public {\n', '    administrators[_newAdmin] = _status;\n', '  }\n', '\n', '  function setStakingRequirement(uint _amountOfTokens)\n', '  onlyAdministrator()\n', '  public {\n', '    // This plane only goes one way, lads. Never below the initial.\n', '    require(_amountOfTokens >= 100e18);\n', '    stakingRequirement = _amountOfTokens;\n', '  }\n', '\n', '  function setName(string _name)\n', '  onlyAdministrator()\n', '  public {\n', '    name = _name;\n', '  }\n', '\n', '  function setSymbol(string _symbol)\n', '  onlyAdministrator()\n', '  public {\n', '    symbol = _symbol;\n', '  }\n', '\n', '  function changeBankroll(address _newBankrollAddress)\n', '  onlyAdministrator\n', '  public {\n', '    bankrollAddress = _newBankrollAddress;\n', '  }\n', '\n', '  /*----------  HELPERS AND CALCULATORS  ----------*/\n', '\n', '  function total0xbtcBalance()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return _0xBTC.balanceOf(address(this));\n', '  }\n', '\n', '  function total0xbtcReceived()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return current0xbtcInvested;\n', '  }\n', '\n', '  /**\n', '   * Retrieves your currently selected dividend rate.\n', '   */\n', '  function getMyDividendRate()\n', '  public\n', '  view\n', '  returns(uint8) {\n', '    address _customerAddress = msg.sender;\n', '    require(userSelectedRate[_customerAddress]);\n', '    return userDividendRate[_customerAddress];\n', '  }\n', '\n', '  /**\n', '   * Retrieve the total frontend token supply\n', '   */\n', '  function getFrontEndTokenSupply()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return tokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retreive the total dividend token supply\n', '   */\n', '  function getDividendTokenSupply()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return divTokenSupply;\n', '  }\n', '\n', '  /**\n', '   * Retrieve the frontend tokens owned by the caller\n', '   */\n', '  function myFrontEndTokens()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    address _customerAddress = msg.sender;\n', '    return getFrontEndTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  /**\n', '   * Retrieve the dividend tokens owned by the caller\n', '   */\n', '  function myDividendTokens()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    address _customerAddress = msg.sender;\n', '    return getDividendTokenBalanceOf(_customerAddress);\n', '  }\n', '\n', '  function myReferralDividends()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return myDividends(true) - myDividends(false);\n', '  }\n', '\n', '  function myDividends(bool _includeReferralBonus)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    address _customerAddress = msg.sender;\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', '  }\n', '\n', '  function getFrontEndTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint) {\n', '    return frontTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '  view\n', '  public\n', '  returns(uint) {\n', '    return getFrontEndTokenBalanceOf(_owner);\n', '  }\n', '\n', '  function getDividendTokenBalanceOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint) {\n', '    return dividendTokenBalanceLedger_[_customerAddress];\n', '  }\n', '\n', '  function dividendsOf(address _customerAddress)\n', '  view\n', '  public\n', '  returns(uint) {\n', '    return (uint)((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', '  }\n', '\n', "  // Get the sell price at the user's average dividend rate\n", '  function sellPrice()\n', '  public\n', '  view\n', '  returns(uint) {\n', '    uint price;\n', '\n', '    // Calculate the tokens received for 0.001 0xbtc.\n', '    // Divide to find the average, to calculate the price.\n', '    uint tokensReceivedFor0xbtc = btcToTokens_(0.001 ether);\n', '\n', '    price = (1e18 * 0.001 ether) / tokensReceivedFor0xbtc;\n', '\n', "    // Factor in the user's average dividend rate\n", '    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n', '\n', '    return theSellPrice;\n', '  }\n', '\n', '  // Get the buy price at a particular dividend rate\n', '  function buyPrice(uint dividendRate)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    uint price;\n', '\n', '    // Calculate the tokens received for 100 finney.\n', '    // Divide to find the average, to calculate the price.\n', '    uint tokensReceivedFor0xbtc = btcToTokens_(0.001 ether);\n', '\n', '    price = (1e18 * 0.001 ether) / tokensReceivedFor0xbtc;\n', '\n', "    // Factor in the user's selected dividend rate\n", '    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n', '\n', '    return theBuyPrice;\n', '  }\n', '\n', '  function calculateTokensReceived(uint _0xbtcToSpend)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    uint fixedAmount = _0xbtcToSpend.mul(1e10);\n', '    uint _dividends = (fixedAmount.mul(userDividendRate[msg.sender])).div(100);\n', '    uint _taxed0xbtc = fixedAmount.sub(_dividends);\n', '    uint _amountOfTokens = btcToTokens_(_taxed0xbtc);\n', '    return _amountOfTokens;\n', '  }\n', '\n', "  // When selling tokens, we need to calculate the user's current dividend rate.\n", '  // This is different from their selected dividend rate.\n', '  function calculate0xbtcReceived(uint _tokensToSell)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    require(_tokensToSell <= tokenSupply);\n', '    uint _0xbtc = tokensTo0xbtc_(_tokensToSell);\n', '    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n', '    uint _dividends = (_0xbtc.mul(userAverageDividendRate).div(100)).div(magnitude);\n', '    uint _taxed0xbtc = _0xbtc.sub(_dividends);\n', '    return _taxed0xbtc.div(1e10);\n', '  }\n', '\n', '  /*\n', "   * Get's a user's average dividend rate - which is just their divTokenBalance / tokenBalance\n", '   * We multiply by magnitude to avoid precision errors.\n', '   */\n', '\n', '  function getUserAverageDividendRate(address user) public view returns(uint) {\n', '    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n', '  }\n', '\n', '  function getMyAverageDividendRate() public view returns(uint) {\n', '    return getUserAverageDividendRate(msg.sender);\n', '  }\n', '\n', '  /*==========================================\n', '  =            INTERNAL FUNCTIONS            =\n', '  ==========================================*/\n', '\n', '  /* Purchase tokens with 0xbtc.\n', '     During normal operation:\n', '       0.5% should go to the master dividend card\n', '       0.5% should go to the matching dividend card\n', '       25% of dividends should go to the referrer, if any is provided. */\n', '  function purchaseTokens(uint _incoming, address _referredBy, bool _reinvest)\n', '  internal\n', '  returns(uint) {\n', '\n', '    require(_incoming.mul(1e10) >= MIN_TOK_BUYIN || msg.sender == bankrollAddress, "Tried to buy below the min 0xbtc buyin threshold.");\n', '\n', '    uint toReferrer;\n', '    uint toTokenHolders;\n', '    uint toDivCardHolders;\n', '\n', '    uint dividendAmount;\n', '\n', '    uint tokensBought;\n', '\n', '    uint remaining0xbtc = _incoming.mul(1e10);\n', '\n', '    uint fee;\n', '\n', '    // 1% for dividend card holders is taken off before anything else\n', '    if (regularPhase) {\n', '      toDivCardHolders = _incoming.mul(1e8);\n', '      remaining0xbtc = remaining0xbtc.sub(toDivCardHolders);\n', '    }\n', '\n', '    /* Next, we tax for dividends:\n', '       Dividends = (0xbtc * div%) / 100\n', '       Important note: the 1% sent to div-card holders\n', '                       is handled prior to any dividend taxes are considered. */\n', '\n', '    // Calculate the total dividends on this buy\n', '    dividendAmount = (remaining0xbtc.mul(userDividendRate[msg.sender])).div(100);\n', '\n', '    remaining0xbtc = remaining0xbtc.sub(dividendAmount);\n', '\n', '    // Calculate how many tokens to buy:\n', '    tokensBought = btcToTokens_(remaining0xbtc);\n', '\n', '    // This is where we actually mint tokens:\n', '    require(tokenSupply.add(tokensBought) <= MAX_SUPPLY);\n', '    tokenSupply = tokenSupply.add(tokensBought);\n', '    divTokenSupply = divTokenSupply.add(tokensBought.mul(userDividendRate[msg.sender]));\n', '\n', '    /* Update the total investment tracker\n', '       Note that this must be done AFTER we calculate how many tokens are bought -\n', '       because btcToTokens needs to know the amount *before* investment, not *after* investment. */\n', '\n', '    current0xbtcInvested = current0xbtcInvested + remaining0xbtc;\n', '\n', '    // Ccheck for referrals\n', '\n', '    // 25% goes to referrers, if set\n', '    // toReferrer = (dividends * 25)/100\n', '    if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n', '      _referredBy != msg.sender &&\n', '      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement) {\n', '      toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n', '      referralBalance_[_referredBy] += toReferrer;\n', '      emit Referral(_referredBy, toReferrer);\n', '    }\n', '\n', '    // The rest of the dividends go to token holders\n', '    toTokenHolders = dividendAmount.sub(toReferrer);\n', '\n', '    fee = toTokenHolders * magnitude;\n', '    fee = fee - (fee - (tokensBought.mul(userDividendRate[msg.sender]) * (toTokenHolders * magnitude / (divTokenSupply))));\n', '\n', '    // Finally, increase the divToken value\n', '    profitPerDivToken = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n', '    payoutsTo_[msg.sender] += (int256)((profitPerDivToken * tokensBought.mul(userDividendRate[msg.sender])) - fee);\n', '\n', "    // Update the buyer's token amounts\n", '    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n', '    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(tokensBought.mul(userDividendRate[msg.sender]));\n', '\n', '    if (_reinvest == false) {\n', '      //Lets receive the 0xbtc\n', '      _0xBTC.transferFrom(msg.sender, address(this), _incoming);\n', '    }\n', '\n', '    // Transfer to div cards\n', '    if (regularPhase) {\n', '      _0xBTC.approve(address(divCardContract), toDivCardHolders.div(1e10));\n', '      divCardContract.receiveDividends(toDivCardHolders.div(1e10), userDividendRate[msg.sender]);\n', '    }\n', '\n', '    // This event should help us track where all the 0xbtc is going\n', '    emit Allocation(0, toReferrer, toTokenHolders, toDivCardHolders, remaining0xbtc);\n', '\n', '    emit onTokenPurchase(msg.sender, _incoming, userDividendRate[msg.sender], tokensBought, _referredBy);\n', '\n', '    // Sanity checking\n', '    uint sum = toReferrer + toTokenHolders + toDivCardHolders + remaining0xbtc - _incoming.mul(1e10);\n', '    assert(sum == 0);\n', '  }\n', '\n', '  // How many tokens one gets from a certain amount of 0xbtc.\n', '  function btcToTokens_(uint _0xbtcAmount)\n', '  public\n', '  view\n', '  returns(uint) {\n', '\n', '    //0xbtcAmount expected as 18 decimals instead of 8\n', '\n', '    require(_0xbtcAmount > MIN_TOK_BUYIN, "Tried to buy tokens with too little 0xbtc.");\n', '\n', '    uint _0xbtcTowardsVariablePriceTokens = _0xbtcAmount;\n', '\n', '    uint varPriceTokens = 0;\n', '\n', '    if (_0xbtcTowardsVariablePriceTokens != 0) {\n', '\n', '      uint simulated0xbtcBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint simulated0xbtcAfterInvested = simulated0xbtcBeforeInvested + _0xbtcTowardsVariablePriceTokens;\n', '\n', '      uint tokensBefore = toPowerOfTwoThirds(simulated0xbtcBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '      uint tokensAfter = toPowerOfTwoThirds(simulated0xbtcAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n', '\n', '      /*  Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n', '         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n', '\n', '      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n', '    }\n', '\n', '    uint totalTokensReceived = varPriceTokens;\n', '\n', '    assert(totalTokensReceived > 0);\n', '    return totalTokensReceived;\n', '  }\n', '\n', '  // How much 0xBTC we get from selling N tokens\n', '  function tokensTo0xbtc_(uint _tokens)\n', '  public\n', '  view\n', '  returns(uint) {\n', '    require(_tokens >= MIN_TOKEN_SELL_AMOUNT, "Tried to sell too few tokens.");\n', '\n', '    /*\n', '     *  i = investment, p = price, t = number of tokens\n', '     *\n', '     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n', '     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n', '     *\n', '     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n', '     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n', '     */\n', '\n', '    uint tokensToSellAtVariablePrice = _tokens;\n', '\n', '    uint _0xbtcFromVarPriceTokens;\n', '\n', '    // Now, actually calculate:\n', '\n', '    if (tokensToSellAtVariablePrice != 0) {\n', '\n', '      /* Note: Unlike the sister function in btcToTokens, we don\'t have to calculate any "virtual" token count.\n', '\n', '         We have the equations for total investment above; note that this is for TOTAL.\n', '         To get the 0xbtc received from this sell, we calculate the new total investment after this sell.\n', '         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in btcToTokens. */\n', '\n', '      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '      uint investmentAfter = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n', '\n', '      _0xbtcFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n', '    }\n', '\n', '    uint _0xbtcReceived = _0xbtcFromVarPriceTokens;\n', '\n', '    assert(_0xbtcReceived > 0);\n', '    return _0xbtcReceived;\n', '  }\n', '\n', '  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n', '  internal {\n', '    require(regularPhase);\n', '    require(_toAddress != address(0x0));\n', '    address _customerAddress = _from;\n', '    uint _amountOfFrontEndTokens = _amountOfTokens;\n', '\n', '    // Withdraw all outstanding dividends first (including those generated from referrals).\n', '    if (theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n', '\n', '    // Calculate how many back-end dividend tokens to transfer.\n', "    // This amount is proportional to the caller's average dividend rate multiplied by the proportion of tokens being transferred.\n", '    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n', '\n', '    if (_customerAddress != msg.sender) {\n', '      // Update the allowed balance.\n', "      // Don't update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n", '      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n', '    }\n', '\n', '    // Exchange tokens\n', '    frontTokenBalanceLedger_[_customerAddress] = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n', '    frontTokenBalanceLedger_[_toAddress] = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n', '    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n', '    dividendTokenBalanceLedger_[_toAddress] = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n', '\n', '    // Recipient inherits dividend percentage if they have not already selected one.\n', '    if (!userSelectedRate[_toAddress]) {\n', '      userSelectedRate[_toAddress] = true;\n', '      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n', '    }\n', '\n', '    // Update dividend trackers\n', '    payoutsTo_[_customerAddress] -= (int256)(profitPerDivToken * _amountOfDivTokens);\n', '    payoutsTo_[_toAddress] += (int256)(profitPerDivToken * _amountOfDivTokens);\n', '\n', '    uint length;\n', '\n', '    assembly {\n', '      length: = extcodesize(_toAddress)\n', '    }\n', '\n', '    if (length > 0) {\n', '      // its a contract\n', '      // note: at ethereum update ALL addresses are contracts\n', '      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n', '      receiver.tokenFallback(_from, _amountOfTokens, _data);\n', '    }\n', '\n', '    // Fire logging event.\n', '    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n', '  }\n', '\n', '  // Called from transferFrom. Always checks if _customerAddress has dividends.\n', '  function withdrawFrom(address _customerAddress)\n', '  internal {\n', '    // Setup data\n', '    uint _dividends = theDividendsOf(false, _customerAddress);\n', '\n', '    // update dividend tracker\n', '    payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '    // add ref. bonus\n', '    _dividends += referralBalance_[_customerAddress];\n', '    referralBalance_[_customerAddress] = 0;\n', '\n', '    _dividends = _dividends.div(1e10); //to 8 decimals\n', '    _0xBTC.transfer(_customerAddress, _dividends); //8 decimals correction\n', '\n', '    // Fire logging event.\n', '    emit onWithdraw(_customerAddress, _dividends);\n', '  }\n', '\n', '  /*=======================\n', '   =   MATHS FUNCTIONS    =\n', '   ======================*/\n', '\n', '  function toPowerOfThreeHalves(uint x) public pure returns(uint) {\n', '    // m = 3, n = 2\n', '    // sqrt(x^3)\n', '    return sqrt(x ** 3);\n', '  }\n', '\n', '  function toPowerOfTwoThirds(uint x) public pure returns(uint) {\n', '    // m = 2, n = 3\n', '    // cbrt(x^2)\n', '    return cbrt(x ** 2);\n', '  }\n', '\n', '  function sqrt(uint x) public pure returns(uint y) {\n', '    uint z = (x + 1) / 2;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / z + z) / 2;\n', '    }\n', '  }\n', '\n', '  function cbrt(uint x) public pure returns(uint y) {\n', '    uint z = (x + 1) / 3;\n', '    y = x;\n', '    while (z < y) {\n', '      y = z;\n', '      z = (x / (z * z) + 2 * z) / 3;\n', '    }\n', '  }\n', '}\n', '\n', '/*=======================\n', ' =     INTERFACES       =\n', ' ======================*/\n', '\n', '\n', 'interface _0xBitconnectDividendCards {\n', '  function ownerOf(uint /*_divCardId*/ ) external pure returns(address);\n', '\n', '  function receiveDividends(uint amount, uint divCardRate) external;\n', '}\n', '\n', 'interface _0xBitconnectBankroll {\n', '  function receiveDividends(uint amount) external;\n', '}\n', '\n', '\n', 'interface ERC223Receiving {\n', '  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) external returns(bool);\n', '}\n', '\n', "// Think it's safe to say y'all know what this is.\n", '\n', 'library SafeMath {\n', '\n', '  function mul(uint a, uint b) internal pure returns(uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns(uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns(uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns(uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']