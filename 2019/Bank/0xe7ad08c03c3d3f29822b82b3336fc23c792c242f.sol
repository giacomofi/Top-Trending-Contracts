['pragma solidity 0.5.7;\n', '\n', '\n', 'library SafeMath \n', '{\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/******************************************/\n', '/*       nerveShares starts here          */\n', '/******************************************/\n', '\n', 'contract nerveShares {\n', '\n', '    string name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    uint256 public totalDividends;\n', '    uint256 internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) allowance;\n', '    mapping (address => uint256) internal lastDividends;\n', '    mapping (address => bool) public tradables;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Claim(address indexed _to, uint256 value);\n', '\n', '    using SafeMath for uint256;\n', '\n', '    constructor() public\n', '    {\n', '        decimals = 18;                              // decimals  \n', '        totalSupply = 1000000*10**18;               // initialSupply\n', '        name = "Nerve";                             // Set the name for display purposes\n', '        symbol = "NRV";                             // Set the symbol for display purposes\n', '\n', '        balanceOf[msg.sender] = totalSupply;\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '\n', '    /**\n', '    * @dev Get the dividends of a user. Take prior payoffs into account.\n', '    * @param account The address of the user.\n', '    */\n', '    function dividendBalanceOf(address account) public view returns (uint256) \n', '    {\n', '        uint256 newDividends = totalDividends.sub(lastDividends[account]);\n', '        uint256 product = balanceOf[account].mul(newDividends);\n', '        return product.div(totalSupply);\n', '    }   \n', '\n', '    /**\n', '    * @dev Get the dividends of a user. Take prior payoffs into account.\n', '    * @param account The address of the user.\n', '    */\n', '    function internalDividendBalanceOf(address account, uint256 tempLastDividends) internal view returns (uint256) \n', '    {\n', '        uint256 newDividends = totalDividends.sub(tempLastDividends);\n', '        uint256 product = balanceOf[account].mul(newDividends);\n', '        return product.div(totalSupply);\n', '    }   \n', '\n', '    /**\n', '    * @dev Claim dividends. Restrict dividends to new income.\n', '    */\n', '    function claimDividend() external \n', '    {\n', '        uint256 tempLastDividends = lastDividends[msg.sender];\n', '        lastDividends[msg.sender] = totalDividends;\n', '\n', '        uint256 owing = internalDividendBalanceOf(msg.sender, tempLastDividends);\n', '        require(owing > 0, "No dividends to claim.");\n', '\n', '        msg.sender.transfer(owing);\n', '        \n', '        emit Claim(msg.sender, owing);\n', '    }\n', '\n', '    /**\n', '    * @dev Claim dividends internally. Get called on addresses opened for trade.\n', '    */\n', '    function internalClaimDividend(address payable from) internal \n', '    {\n', '        uint256 owing = dividendBalanceOf(from);\n', '        if (owing > 0) {\n', '\n', '        lastDividends[from] = totalDividends;\n', '        from.transfer(owing);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Open or close sending address for trade.\n', '    * @param allow True -> open\n', '    */\n', '    function allowTrade(bool allow) external\n', '    {\n', '        tradables[msg.sender] = allow;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens\n', '    * @param to The address of the recipient\n', '    * @param value the amount to send\n', '    */\n', '    function transfer(address payable to, uint256 value) external returns(bool success)\n', '    {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens. Make sure that both participants have no open dividends left.\n', '    * @param to The address to transfer to.\n', '    * @param value The amount to be transferred.\n', '    */\n', '    function _transfer(address payable from, address payable to, uint256 value) internal\n', '    {   \n', '        require(value > 0, "Transferred value has to be grater than 0.");\n', '        require(to != address(0), "0x00 address not allowed.");\n', '        require(value <= balanceOf[from], "Not enough funds on sender address.");\n', '        require(balanceOf[to] + value >= balanceOf[to], "Overflow protection.");\n', ' \n', '        uint256 fromOwing = dividendBalanceOf(from);\n', '        uint256 toOwing = dividendBalanceOf(to);\n', '\n', '        if (tradables[from] == true && (tradables[to] == true || toOwing == 0)) \n', '        {\n', '\n', '            internalClaimDividend(from);\n', '            internalClaimDividend(to);\n', '        } else {\n', '            \n', '            require(fromOwing == 0 && toOwing == 0, "Unclaimed dividends on sender and/or receiver");\n', '        }\n', '        \n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', ' \n', '        lastDividends[to] = lastDividends[from];    // In case of new account, set lastDividends of receiver to totalDividends.\n', ' \n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '    * @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance.\n', '    * @param from Address to transfer from.\n', '    * @param to Address to transfer to.\n', '    * @param value Amount to transfer.\n', '    * @return Success of transfer.\n', '    */\n', '    function transferFrom(address payable from, address payable to, uint value) external returns (bool success)\n', '    {\n', '        uint256 allowanceTemp = allowance[from][msg.sender];\n', '        \n', '        require(allowanceTemp >= value, "Funds not approved."); \n', '        require(balanceOf[from] >= value, "Not enough funds on sender address.");\n', '        require(balanceOf[to] + value >= balanceOf[to], "Overflow protection.");\n', '\n', '        if (allowanceTemp < MAX_UINT) \n', '        {\n', '            allowance[from][msg.sender] -= value;\n', '        }\n', '        \n', '        _transfer(from, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev `msg.sender` approves `addr` to spend `value` tokens.\n', '    * @param spender The address of the account able to transfer the tokens.\n', '    * @param value The amount of wei to be approved for transfer.\n', '    */\n', '    function approve(address spender, uint value) external returns (bool) \n', '    {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Set unlimited allowance for other address\n', '    * @param target The address authorized to spend\n', '    */   \n', '    function giveAccess(address target) external\n', '    {\n', '        require(target != address(0), "0x00 address not allowed.");\n', '        allowance[msg.sender][target] = MAX_UINT;\n', '        emit Approval(msg.sender, target, MAX_UINT);\n', '    }\n', '\n', '    /**\n', '    * @dev Set allowance for other address to 0\n', '    * @param target The address authorized to spend\n', '    */   \n', '    function revokeAccess(address target) external\n', '    {\n', '        require(target != address(0), "0x00 address not allowed.");\n', '        allowance[msg.sender][target] = 0;\n', '    }\n', '    \n', '    /**\n', '    * @dev Get contract ETH amount. \n', '    */ \n', '    function contractBalance() external view returns(uint256 amount)\n', '    {\n', '        return (address(this).balance);\n', '    }\n', '    \n', '    /**\n', '    * @dev Receive ETH from CONTRACT and increase the total historic amount of dividend eligible earnings.\n', '    */\n', '    function receiveETH() external payable\n', '    {\n', '        totalDividends = totalDividends.add(msg.value);\n', '    }\n', '    \n', '    /**\n', '    * @dev Receive ETH and increase the total historic amount of dividend eligible earnings.\n', '    */\n', '    function () external payable \n', '    {\n', '        totalDividends = totalDividends.add(msg.value);\n', '    }\n', '    \n', '}']