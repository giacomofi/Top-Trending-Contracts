['pragma solidity 0.4.25;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'library ERC20SafeTransfer {\n', '    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transfer(address,uint256)")), _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, _to, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\n', '\n', '        require(_tokenAddress.call(bytes4(keccak256("approve(address,uint256)")), _spender, _value));\n', '\n', '        return fetchReturnData();\n', '    }\n', '\n', '    function fetchReturnData() internal returns (bool success){\n', '        assembly {\n', '            switch returndatasize()\n', '            case 0 {\n', '                success := 1\n', '            }\n', '            case 32 {\n', '                returndatacopy(0, 0, 32)\n', '                success := mload(0)\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title A contract which allows its owner to withdraw any ether which is contained inside\n', 'contract Withdrawable is Ownable {\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _token The address of the token that the user wants to withdraw\n', '    /// @param _amount The amount of tokens that the caller wants to withdraw\n', '    /// @return bool value indicating whether the transfer was successful\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\n', '        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\n', '    }\n', '\n', '    /// @notice Withdraw ether contained in this contract and send it back to owner\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _amount The amount of ether that the caller wants to withdraw\n', '    function withdrawETH(uint256 _amount) external onlyOwner {\n', '        owner.transfer(_amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function decimals() public view returns (uint256);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/*\n', '\n', '  Copyright 2018 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        emit LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        emit LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        require(ERC20SafeTransfer.safeTransferFrom(token, from, to, value));\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        view\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool private _paused = false;\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "Contract is paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "Contract not paused.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    _paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    _paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/*\n', '    Modified Util contract as used by Kyber Network\n', '*/\n', '\n', 'library Utils {\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\n', '    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n', '    uint256 constant internal MAX_DECIMALS = 18;\n', '    uint256 constant internal ETH_DECIMALS = 18;\n', '    uint256 constant internal MAX_UINT = 2**256-1;\n', '\n', "    // Currently constants can't be accessed from other contracts, so providing functions to do that here\n", '    function precision() internal pure returns (uint256) { return PRECISION; }\n', '    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\n', '    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\n', '    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\n', '    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\n', '    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\n', '\n', '    /// @notice Retrieve the number of decimals used for a given ERC20 token\n', '    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\n', "    /// ensure that an exception doesn't cause transaction failure\n", '    /// @param token the token for which we should retrieve the decimals\n', '    /// @return decimals the number of decimals in the given token\n', '    function getDecimals(address token)\n', '        internal\n', '        view\n', '        returns (uint256 decimals)\n', '    {\n', '        bytes4 functionSig = bytes4(keccak256("decimals()"));\n', '\n', '        /// @dev Using assembly due to issues with current solidity `address.call()`\n', '        /// implementation: https://github.com/ethereum/solidity/issues/2884\n', '        assembly {\n', '            // Pointer to next free memory slot\n', '            let ptr := mload(0x40)\n', '            // Store functionSig variable at ptr\n', '            mstore(ptr,functionSig)\n', '            let functionSigLength := 0x04\n', '            let wordLength := 0x20\n', '\n', '            let success := call(\n', '                                5000, // Amount of gas\n', '                                token, // Address to call\n', '                                0, // ether to send\n', '                                ptr, // ptr to input data\n', '                                functionSigLength, // size of data\n', '                                ptr, // where to store output data (overwrite input)\n', '                                wordLength // size of output data (32 bytes)\n', '                               )\n', '\n', '            switch success\n', '            case 0 {\n', "                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\n", '            }\n', '            case 1 {\n', '                decimals := mload(ptr) // Set decimals to return data from call\n', '            }\n', '            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\n', '        }\n', '    }\n', '\n', '    /// @dev Checks that a given address has its token allowance and balance set above the given amount\n', '    /// @param tokenOwner the address which should have custody of the token\n', '    /// @param tokenAddress the address of the token to check\n', '    /// @param tokenAmount the amount of the token which should be set\n', '    /// @param addressToAllow the address which should be allowed to transfer the token\n', '    /// @return bool true if the allowance and balance is set, false if not\n', '    function tokenAllowanceAndBalanceSet(\n', '        address tokenOwner,\n', '        address tokenAddress,\n', '        uint256 tokenAmount,\n', '        address addressToAllow\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\n', '            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\n', '        );\n', '    }\n', '\n', '    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint numerator;\n', '        uint denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns (uint) {\n', '        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns (uint) {\n', '        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n', '        internal pure returns (uint)\n', '    {\n', '        require(srcAmount <= MAX_QTY);\n', '        require(destAmount <= MAX_QTY);\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n', '            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n', '        }\n', '    }\n', '\n', "    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\n", '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract ErrorReporter {\n', '    function revertTx(string reason) public pure {\n', '        revert(reason);\n', '    }\n', '}\n', '\n', 'contract Affiliate{\n', '\n', '  address public affiliateBeneficiary;\n', '  uint256 public affiliatePercentage; //This is out of 1 ETH, e.g. 0.5 ETH is 50% of the fee\n', '\n', '  uint256 public companyPercentage;\n', '  address public companyBeneficiary;\n', '\n', '  function init(address _companyBeneficiary, uint256 _companyPercentage, address _affiliateBeneficiary, uint256 _affiliatePercentage) public {\n', '      require(companyBeneficiary == 0x0 && affiliateBeneficiary == 0x0);\n', '      companyBeneficiary = _companyBeneficiary;\n', '      companyPercentage = _companyPercentage;\n', '      affiliateBeneficiary = _affiliateBeneficiary;\n', '      affiliatePercentage = _affiliatePercentage;\n', '  }\n', '\n', '  function payout() public {\n', '      // Payout both the affiliate and the company at the same time\n', '      affiliateBeneficiary.transfer(SafeMath.div(SafeMath.mul(address(this).balance, affiliatePercentage), getTotalFeePercentage()));\n', '      companyBeneficiary.transfer(address(this).balance);\n', '  }\n', '\n', '  function() public payable {\n', '\n', '  }\n', '\n', '  function getTotalFeePercentage() public view returns (uint256){\n', '      return affiliatePercentage + companyPercentage;\n', '  }\n', '}\n', '\n', 'contract AffiliateRegistry is Ownable {\n', '\n', '  address target;\n', '  mapping(address => bool) affiliateContracts;\n', '  address public companyBeneficiary;\n', '  uint256 public companyPercentage;\n', '\n', '  event AffiliateRegistered(address affiliateContract);\n', '\n', '\n', '  constructor(address _target, address _companyBeneficiary, uint256 _companyPercentage) public {\n', '     target = _target;\n', '     companyBeneficiary = _companyBeneficiary;\n', '     companyPercentage = _companyPercentage;\n', '  }\n', '\n', '  function registerAffiliate(address affiliateBeneficiary, uint256 affiliatePercentage) external {\n', '      Affiliate newAffiliate = Affiliate(createClone());\n', '      newAffiliate.init(companyBeneficiary, companyPercentage, affiliateBeneficiary, affiliatePercentage);\n', '      affiliateContracts[address(newAffiliate)] = true;\n', '      emit AffiliateRegistered(address(newAffiliate));\n', '  }\n', '\n', '  function overrideRegisterAffiliate(address _companyBeneficiary, uint256 _companyPercentage, address affiliateBeneficiary, uint256 affiliatePercentage) external onlyOwner {\n', '      Affiliate newAffiliate = Affiliate(createClone());\n', '      newAffiliate.init(_companyBeneficiary, _companyPercentage, affiliateBeneficiary, affiliatePercentage);\n', '      affiliateContracts[address(newAffiliate)] = true;\n', '      emit AffiliateRegistered(address(newAffiliate));\n', '  }\n', '\n', '  function deleteAffiliate(address _affiliateAddress) public onlyOwner {\n', '      affiliateContracts[_affiliateAddress] = false;\n', '  }\n', '\n', '  function createClone() internal returns (address result) {\n', '      bytes20 targetBytes = bytes20(target);\n', '      assembly {\n', '          let clone := mload(0x40)\n', '          mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '          mstore(add(clone, 0x14), targetBytes)\n', '          mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '          result := create(0, clone, 0x37)\n', '      }\n', '  }\n', '\n', '  function isValidAffiliate(address affiliateContract) public view returns(bool) {\n', '      return affiliateContracts[affiliateContract];\n', '  }\n', '\n', '  function updateCompanyInfo(address newCompanyBeneficiary, uint256 newCompanyPercentage) public onlyOwner {\n', '      companyBeneficiary = newCompanyBeneficiary;\n', '      companyPercentage = newCompanyPercentage;\n', '  }\n', '}\n', '\n', '/// @title A contract which can be used to ensure only the TotlePrimary contract can call\n', '/// some functions\n', '/// @dev Defines a modifier which should be used when only the totle contract should\n', '/// able able to call a function\n', 'contract TotleControl is Ownable {\n', '    mapping(address => bool) public authorizedPrimaries;\n', '\n', '    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\n', '    modifier onlyTotle() {\n', '        require(authorizedPrimaries[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /// @notice Contract constructor\n', '    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    constructor(address _totlePrimary) public {\n', '        authorizedPrimaries[_totlePrimary] = true;\n', '    }\n', '\n', '    /// @notice A function which allows only the owner to change the address of totlePrimary\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param _totlePrimary the address of the contract to be set as totlePrimary\n', '    function addTotle(\n', '        address _totlePrimary\n', '    ) external onlyOwner {\n', '        authorizedPrimaries[_totlePrimary] = true;\n', '    }\n', '\n', '    function removeTotle(\n', '        address _totlePrimary\n', '    ) external onlyOwner {\n', '        authorizedPrimaries[_totlePrimary] = false;\n', '    }\n', '}\n', '\n', 'contract SelectorProvider {\n', '    bytes4 constant getAmountToGiveSelector = bytes4(keccak256("getAmountToGive(bytes)"));\n', '    bytes4 constant staticExchangeChecksSelector = bytes4(keccak256("staticExchangeChecks(bytes)"));\n', '    bytes4 constant performBuyOrderSelector = bytes4(keccak256("performBuyOrder(bytes,uint256)"));\n', '    bytes4 constant performSellOrderSelector = bytes4(keccak256("performSellOrder(bytes,uint256)"));\n', '\n', '    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\n', '}\n', '\n', '/// @title Interface for all exchange handler contracts\n', 'contract ExchangeHandler is SelectorProvider, TotleControl, Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    ErrorReporter public errorReporter;\n', '    /* Logger public logger; */\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    /// @notice Constructor\n', '    /// @dev Calls the constructor of the inherited TotleControl\n', '    /// @param totlePrimary the address of the totlePrimary contract\n', '    constructor(\n', '        address totlePrimary,\n', '        address _errorReporter\n', '        /* ,address _logger */\n', '    )\n', '        TotleControl(totlePrimary)\n', '        public\n', '    {\n', '        require(_errorReporter != address(0x0));\n', '        /* require(_logger != address(0x0)); */\n', '        errorReporter = ErrorReporter(_errorReporter);\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /// @notice Gets the amount that Totle needs to give for this order\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return amountToGive amount taker needs to give in order to fill the order\n', '    function getAmountToGive(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 amountToGive)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.getAmountToGive.selector);\n', '\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            amountToGive := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform exchange-specific checks on the given order\n', '    /// @dev this should be called to check for payload errors\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @return checksPassed value representing pass or fail\n', '    function staticExchangeChecks(\n', '        bytes genericPayload\n', '    )\n', '        public\n', '        view\n', '        returns (bool checksPassed)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.staticExchangeChecks.selector);\n', '        assembly {\n', '            let functionSelectorLength := 0x04\n', '            let functionSelectorOffset := 0x1C\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let bytesLength := mload(genericPayload)\n', '            let totalLength := add(functionSelectorLength, bytesLength)\n', '            let startOfNewData := add(genericPayload, functionSelectorOffset)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '            mstore(genericPayload, functionSelectorCorrect)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            wordLength // Length of return variable is one word\n', '                           )\n', '            checksPassed := mload(scratchSpace)\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a buy order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performBuyOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        payable\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.performBuyOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /// @notice Perform a sell order at the exchange\n', '    /// @param genericPayload the data for this order in a generic format\n', '    /// @param  amountToGiveForOrder amount that should be spent on this order\n', '    /// @return amountSpentOnOrder the amount that would be spent on the order\n', '    /// @return amountReceivedFromOrder the amount that was received from this order\n', '    function performSellOrder(\n', '        bytes genericPayload,\n', '        uint256 amountToGiveForOrder\n', '    )\n', '        public\n', '        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\n', '    {\n', '        bool success;\n', '        bytes4 functionSelector = getSelector(this.performSellOrder.selector);\n', '        assembly {\n', '            let callDataOffset := 0x44\n', '            let functionSelectorOffset := 0x1C\n', '            let functionSelectorLength := 0x04\n', '            let scratchSpace := 0x0\n', '            let wordLength := 0x20\n', '            let startOfFreeMemory := mload(0x40)\n', '\n', '            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\n', '\n', '            let bytesLength := mload(startOfFreeMemory)\n', '            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\n', '\n', '            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\n', '\n', '            let functionSelectorCorrect := mload(scratchSpace)\n', '\n', '            mstore(startOfFreeMemory, functionSelectorCorrect)\n', '\n', '            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\n', '\n', '            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\n', '\n', '            success := delegatecall(\n', '                            gas,\n', '                            address, // This address of the current contract\n', '                            startOfNewData, // Start data at the beginning of the functionSelector\n', '                            totalLength, // Total length of all data, including functionSelector\n', '                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\n', '                            mul(wordLength, 0x02) // Length of return variables is two words\n', '                          )\n', '            amountSpentOnOrder := mload(scratchSpace)\n', '            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\n', '            if eq(success, 0) { revert(0, 0) }\n', '        }\n', '    }\n', '}\n', '\n', '/// @title The primary contract for Totle\n', 'contract TotlePrimary is Withdrawable, Pausable {\n', '\n', '    /*\n', '    *   State Variables\n', '    */\n', '\n', '    mapping(address => bool) public handlerWhitelistMap;\n', '    address[] public handlerWhitelistArray;\n', '    AffiliateRegistry affiliateRegistry;\n', '    address public defaultFeeAccount;\n', '\n', '    TokenTransferProxy public tokenTransferProxy;\n', '    ErrorReporter public errorReporter;\n', '    /* Logger public logger; */\n', '\n', '    /*\n', '    *   Types\n', '    */\n', '\n', '    // Structs\n', '    struct Trade {\n', '        bool isSell;\n', '        address tokenAddress;\n', '        uint256 tokenAmount;\n', '        bool optionalTrade;\n', '        uint256 minimumExchangeRate;\n', '        uint256 minimumAcceptableTokenAmount;\n', '        Order[] orders;\n', '    }\n', '\n', '    struct Order {\n', '        address exchangeHandler;\n', '        bytes genericPayload;\n', '    }\n', '\n', '    struct TradeFlag {\n', '        bool ignoreTrade;\n', '        bool[] ignoreOrder;\n', '    }\n', '\n', '    struct CurrentAmounts {\n', '        uint256 amountSpentOnTrade;\n', '        uint256 amountReceivedFromTrade;\n', '        uint256 amountLeftToSpendOnTrade;\n', '    }\n', '\n', '    /*\n', '    *   Events\n', '    */\n', '\n', '    event LogRebalance(\n', '        bytes32 id\n', '    );\n', '\n', '    /*\n', '    *   Modifiers\n', '    */\n', '\n', '    modifier handlerWhitelisted(address handler) {\n', '        if (!handlerWhitelistMap[handler]) {\n', '            errorReporter.revertTx("Handler not in whitelist");\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier handlerNotWhitelisted(address handler) {\n', '        if (handlerWhitelistMap[handler]) {\n', '            errorReporter.revertTx("Handler already whitelisted");\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor\n', '    /// @param _tokenTransferProxy address of the TokenTransferProxy\n', '    /// @param _errorReporter the address of the error reporter contract\n', '    constructor (address _tokenTransferProxy, address _affiliateRegistry, address _errorReporter, address _defaultFeeAccount/*, address _logger*/) public {\n', '        /* require(_logger != address(0x0)); */\n', '        tokenTransferProxy = TokenTransferProxy(_tokenTransferProxy);\n', '        affiliateRegistry = AffiliateRegistry(_affiliateRegistry);\n', '        errorReporter = ErrorReporter(_errorReporter);\n', '        defaultFeeAccount = _defaultFeeAccount;\n', '        /* logger = Logger(_logger); */\n', '    }\n', '\n', '    /*\n', '    *   Public functions\n', '    */\n', '\n', '    /// @notice Update the default fee account\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param newDefaultFeeAccount new default fee account\n', '    function updateDefaultFeeAccount(address newDefaultFeeAccount) public onlyOwner {\n', '        defaultFeeAccount = newDefaultFeeAccount;\n', '    }\n', '\n', '    /// @notice Add an exchangeHandler address to the whitelist\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param handler Address of the exchange handler which permission needs adding\n', '    function addHandlerToWhitelist(address handler)\n', '        public\n', '        onlyOwner\n', '        handlerNotWhitelisted(handler)\n', '    {\n', '        handlerWhitelistMap[handler] = true;\n', '        handlerWhitelistArray.push(handler);\n', '    }\n', '\n', '    /// @notice Remove an exchangeHandler address from the whitelist\n', '    /// @dev onlyOwner modifier only allows the contract owner to run the code\n', '    /// @param handler Address of the exchange handler which permission needs removing\n', '    function removeHandlerFromWhitelist(address handler)\n', '        public\n', '        onlyOwner\n', '        handlerWhitelisted(handler)\n', '    {\n', '        delete handlerWhitelistMap[handler];\n', '        for (uint i = 0; i < handlerWhitelistArray.length; i++) {\n', '            if (handlerWhitelistArray[i] == handler) {\n', '                handlerWhitelistArray[i] = handlerWhitelistArray[handlerWhitelistArray.length - 1];\n', '                handlerWhitelistArray.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Performs the requested portfolio rebalance\n', '    /// @param trades A dynamic array of trade structs\n', '    function performRebalance(\n', '        Trade[] memory trades,\n', '        address feeAccount,\n', '        bytes32 id\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        if(!affiliateRegistry.isValidAffiliate(feeAccount)){\n', '            feeAccount = defaultFeeAccount;\n', '        }\n', '        Affiliate affiliate = Affiliate(feeAccount);\n', '        uint256 feePercentage = affiliate.getTotalFeePercentage();\n', '\n', '        emit LogRebalance(id);\n', '        /* logger.log("Starting Rebalance..."); */\n', '\n', '        TradeFlag[] memory tradeFlags = initialiseTradeFlags(trades);\n', '\n', '        staticChecks(trades, tradeFlags);\n', '\n', '        /* logger.log("Static checks passed."); */\n', '\n', '        transferTokens(trades, tradeFlags);\n', '\n', '        /* logger.log("Tokens transferred."); */\n', '\n', '        uint256 etherBalance = msg.value;\n', '        uint256 totalFee = 0;\n', '        /* logger.log("Ether balance arg2: etherBalance.", etherBalance); */\n', '\n', '        for (uint256 i; i < trades.length; i++) {\n', '            Trade memory thisTrade = trades[i];\n', '            TradeFlag memory thisTradeFlag = tradeFlags[i];\n', '\n', '            CurrentAmounts memory amounts = CurrentAmounts({\n', '                amountSpentOnTrade: 0,\n', '                amountReceivedFromTrade: 0,\n', '                amountLeftToSpendOnTrade: thisTrade.isSell ? thisTrade.tokenAmount : calculateMaxEtherSpend(thisTrade, etherBalance, feePercentage)\n', '            });\n', '            /* logger.log("Going to perform trade. arg2: amountLeftToSpendOnTrade", amounts.amountLeftToSpendOnTrade); */\n', '\n', '            performTrade(\n', '                thisTrade,\n', '                thisTradeFlag,\n', '                amounts\n', '            );\n', '            uint256 ethTraded;\n', '            uint256 ethFee;\n', '            if(thisTrade.isSell){\n', '                ethTraded = amounts.amountReceivedFromTrade;\n', '            } else {\n', '                ethTraded = amounts.amountSpentOnTrade;\n', '            }\n', '            ethFee = calculateFee(ethTraded, feePercentage);\n', '            totalFee = SafeMath.add(totalFee, ethFee);\n', '            /* logger.log("Finished performing trade arg2: amountReceivedFromTrade, arg3: amountSpentOnTrade.", amounts.amountReceivedFromTrade, amounts.amountSpentOnTrade); */\n', '\n', '            if (amounts.amountReceivedFromTrade == 0 && thisTrade.optionalTrade) {\n', '                /* logger.log("Received 0 from trade and this is an optional trade. Skipping."); */\n', '                continue;\n', '            }\n', '\n', '            /* logger.log(\n', '                "Going to check trade acceptable amounts arg2: amountSpentOnTrade, arg2: amountReceivedFromTrade.",\n', '                amounts.amountSpentOnTrade,\n', '                amounts.amountReceivedFromTrade\n', '            ); */\n', '\n', '            if (!checkIfTradeAmountsAcceptable(thisTrade, amounts.amountSpentOnTrade, amounts.amountReceivedFromTrade)) {\n', '                errorReporter.revertTx("Amounts spent/received in trade not acceptable");\n', '            }\n', '\n', '            /* logger.log("Trade passed the acceptable amounts check."); */\n', '\n', '            if (thisTrade.isSell) {\n', '                /* logger.log(\n', '                    "This is a sell trade, adding ether to our balance arg2: etherBalance, arg3: amountReceivedFromTrade",\n', '                    etherBalance,\n', '                    amounts.amountReceivedFromTrade\n', '                ); */\n', '                etherBalance = SafeMath.sub(SafeMath.add(etherBalance, ethTraded), ethFee);\n', '            } else {\n', '                /* logger.log(\n', '                    "This is a buy trade, deducting ether from our balance arg2: etherBalance, arg3: amountSpentOnTrade",\n', '                    etherBalance,\n', '                    amounts.amountSpentOnTrade\n', '                ); */\n', '                etherBalance = SafeMath.sub(SafeMath.sub(etherBalance, ethTraded), ethFee);\n', '            }\n', '\n', '            /* logger.log("Transferring tokens to the user arg:6 tokenAddress.", 0,0,0,0, thisTrade.tokenAddress); */\n', '\n', '            transferTokensToUser(\n', '                thisTrade.tokenAddress,\n', '                thisTrade.isSell ? amounts.amountLeftToSpendOnTrade : amounts.amountReceivedFromTrade\n', '            );\n', '\n', '        }\n', '        if(totalFee > 0){\n', '            feeAccount.transfer(totalFee);\n', '        }\n', '        if(etherBalance > 0) {\n', '            /* logger.log("Got a positive ether balance, sending to the user arg2: etherBalance.", etherBalance); */\n', '            msg.sender.transfer(etherBalance);\n', '        }\n', '    }\n', '\n', '    /// @notice Performs static checks on the rebalance payload before execution\n', '    /// @dev This function is public so a rebalance can be checked before performing a rebalance\n', '    /// @param trades A dynamic array of trade structs\n', '    /// @param tradeFlags A dynamic array of flags indicating trade and order status\n', '    function staticChecks(\n', '        Trade[] trades,\n', '        TradeFlag[] tradeFlags\n', '    )\n', '        public\n', '        view\n', '        whenNotPaused\n', '    {\n', '        bool previousBuyOccured = false;\n', '\n', '        for (uint256 i; i < trades.length; i++) {\n', '            Trade memory thisTrade = trades[i];\n', '            if (thisTrade.isSell) {\n', '                if (previousBuyOccured) {\n', '                    errorReporter.revertTx("A buy has occured before this sell");\n', '                }\n', '\n', '                if (!Utils.tokenAllowanceAndBalanceSet(msg.sender, thisTrade.tokenAddress, thisTrade.tokenAmount, address(tokenTransferProxy))) {\n', '                    if (!thisTrade.optionalTrade) {\n', '                        errorReporter.revertTx("Taker has not sent allowance/balance on a non-optional trade");\n', '                    }\n', '                    /* logger.log(\n', '                        "Attempt to sell a token without allowance or sufficient balance arg2: tokenAmount, arg6: tokenAddress . Otional trade, ignoring.",\n', '                        thisTrade.tokenAmount,\n', '                        0,\n', '                        0,\n', '                        0,\n', '                        thisTrade.tokenAddress\n', '                    ); */\n', '                    tradeFlags[i].ignoreTrade = true;\n', '                    continue;\n', '                }\n', '            } else {\n', '                previousBuyOccured = true;\n', '            }\n', '\n', '            /* logger.log("Checking that all the handlers are whitelisted."); */\n', '            for (uint256 j; j < thisTrade.orders.length; j++) {\n', '                Order memory thisOrder = thisTrade.orders[j];\n', '                if ( !handlerWhitelistMap[thisOrder.exchangeHandler] ) {\n', '                    /* logger.log(\n', '                        "Trying to use a handler that is not whitelisted arg6: exchangeHandler.",\n', '                        0,\n', '                        0,\n', '                        0,\n', '                        0,\n', '                        thisOrder.exchangeHandler\n', '                    ); */\n', '                    tradeFlags[i].ignoreOrder[j] = true;\n', '                    continue;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '    *   Internal functions\n', '    */\n', '\n', '    /// @notice Initialises the trade flag struct\n', '    /// @param trades the trades used to initialise the flags\n', '    /// @return tradeFlags the initialised flags\n', '    function initialiseTradeFlags(Trade[] trades)\n', '        internal\n', '        returns (TradeFlag[])\n', '    {\n', '        /* logger.log("Initializing trade flags."); */\n', '        TradeFlag[] memory tradeFlags = new TradeFlag[](trades.length);\n', '        for (uint256 i = 0; i < trades.length; i++) {\n', '            tradeFlags[i].ignoreOrder = new bool[](trades[i].orders.length);\n', '        }\n', '        return tradeFlags;\n', '    }\n', '\n', '    /// @notice Transfers the given amount of tokens back to the msg.sender\n', '    /// @param tokenAddress the address of the token to transfer\n', '    /// @param tokenAmount the amount of tokens to transfer\n', '    function transferTokensToUser(\n', '        address tokenAddress,\n', '        uint256 tokenAmount\n', '    )\n', '        internal\n', '    {\n', '        /* logger.log("Transfering tokens to the user arg2: tokenAmount, arg6: .tokenAddress", tokenAmount, 0, 0, 0, tokenAddress); */\n', '        if (tokenAmount > 0) {\n', '            if (!ERC20SafeTransfer.safeTransfer(tokenAddress, msg.sender, tokenAmount)) {\n', '                errorReporter.revertTx("Unable to transfer tokens to user");\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Executes the given trade\n', '    /// @param trade a struct containing information about the trade\n', '    /// @param tradeFlag a struct containing trade status information\n', '    /// @param amounts a struct containing information about amounts spent\n', '    /// and received in the rebalance\n', '    function performTrade(\n', '        Trade memory trade,\n', '        TradeFlag memory tradeFlag,\n', '        CurrentAmounts amounts\n', '    )\n', '        internal\n', '    {\n', '        /* logger.log("Performing trade"); */\n', '\n', '        for (uint256 j; j < trade.orders.length; j++) {\n', '\n', '            if(amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)){\n', '                return;\n', '            }\n', '\n', '            if((trade.isSell ? amounts.amountSpentOnTrade : amounts.amountReceivedFromTrade) >= trade.tokenAmount ) {\n', '                return;\n', '            }\n', '\n', '            if (tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0) {\n', '                /* logger.log(\n', '                    "Order ignore flag is set to true or have nothing left to spend arg2: amountLeftToSpendOnTrade",\n', '                    amounts.amountLeftToSpendOnTrade\n', '                ); */\n', '                continue;\n', '            }\n', '\n', '            uint256 amountSpentOnOrder = 0;\n', '            uint256 amountReceivedFromOrder = 0;\n', '\n', '            Order memory thisOrder = trade.orders[j];\n', '\n', '            /* logger.log("Setting order exchange handler arg6: exchangeHandler.", 0, 0, 0, 0, thisOrder.exchangeHandler); */\n', '            ExchangeHandler thisHandler = ExchangeHandler(thisOrder.exchangeHandler);\n', '\n', '            uint256 amountToGiveForOrder = Utils.min(\n', '                thisHandler.getAmountToGive(thisOrder.genericPayload),\n', '                amounts.amountLeftToSpendOnTrade\n', '            );\n', '\n', '            if (amountToGiveForOrder == 0) {\n', '                /* logger.log(\n', '                    "MASSIVE ERROR: amountToGiveForOrder was found to be 0, this hasn\'t been caught in preTradeChecks, which means dynamicExchangeChecks isnt written correctly!"\n', '                ); */\n', '                continue;\n', '            }\n', '\n', '            /* logger.log(\n', '                "Calculating amountToGiveForOrder arg2: amountToGiveForOrder, arg3: amountLeftToSpendOnTrade.",\n', '                amountToGiveForOrder,\n', '                amounts.amountLeftToSpendOnTrade\n', '            ); */\n', '\n', '            if( !thisHandler.staticExchangeChecks(thisOrder.genericPayload) ) {\n', '                /* logger.log("Order did not pass checks, skipping."); */\n', '                continue;\n', '            }\n', '\n', '            if (trade.isSell) {\n', '                /* logger.log("This is a sell.."); */\n', '                if (!ERC20SafeTransfer.safeTransfer(trade.tokenAddress,address(thisHandler), amountToGiveForOrder)) {\n', '                    if( !trade.optionalTrade ) errorReporter.revertTx("Unable to transfer tokens to handler");\n', '                    else {\n', '                        /* logger.log("Unable to transfer tokens to handler but the trade is optional"); */\n', '                        return;\n', '                    }\n', '                }\n', '\n', '                /* logger.log("Going to perform a sell order."); */\n', '                (amountSpentOnOrder, amountReceivedFromOrder) = thisHandler.performSellOrder(thisOrder.genericPayload, amountToGiveForOrder);\n', '                /* logger.log("Sell order performed arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */\n', '            } else {\n', '                /* logger.log("Going to perform a buy order."); */\n', '                (amountSpentOnOrder, amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload, amountToGiveForOrder);\n', '                /* logger.log("Buy order performed arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */\n', '            }\n', '\n', '\n', '            if (amountReceivedFromOrder > 0) {\n', '                amounts.amountLeftToSpendOnTrade = SafeMath.sub(amounts.amountLeftToSpendOnTrade, amountSpentOnOrder);\n', '                amounts.amountSpentOnTrade = SafeMath.add(amounts.amountSpentOnTrade, amountSpentOnOrder);\n', '                amounts.amountReceivedFromTrade = SafeMath.add(amounts.amountReceivedFromTrade, amountReceivedFromOrder);\n', '\n', '                /* logger.log(\n', '                    "Updated amounts arg2: amountLeftToSpendOnTrade, arg3: amountSpentOnTrade, arg4: amountReceivedFromTrade.",\n', '                    amounts.amountLeftToSpendOnTrade,\n', '                    amounts.amountSpentOnTrade,\n', '                    amounts.amountReceivedFromTrade\n', '                ); */\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    /// @notice Check if the amounts spent and gained on a trade are within the\n', '    /// user"s set limits\n', '    /// @param trade contains information on the given trade\n', '    /// @param amountSpentOnTrade the amount that was spent on the trade\n', '    /// @param amountReceivedFromTrade the amount that was received from the trade\n', '    /// @return bool whether the trade passes the checks\n', '    function checkIfTradeAmountsAcceptable(\n', '        Trade trade,\n', '        uint256 amountSpentOnTrade,\n', '        uint256 amountReceivedFromTrade\n', '    )\n', '        internal\n', '        view\n', '        returns (bool passed)\n', '    {\n', '        /* logger.log("Checking if trade amounts are acceptable."); */\n', '        uint256 tokenAmount = trade.isSell ? amountSpentOnTrade : amountReceivedFromTrade;\n', '        passed = tokenAmount >= trade.minimumAcceptableTokenAmount;\n', '\n', '        /*if( !passed ) {\n', '             logger.log(\n', '                "Received less than minimum acceptable tokens arg2: tokenAmount , arg3: minimumAcceptableTokenAmount.",\n', '                tokenAmount,\n', '                trade.minimumAcceptableTokenAmount\n', '            );\n', '        }*/\n', '\n', '        if (passed) {\n', '            uint256 tokenDecimals = Utils.getDecimals(ERC20(trade.tokenAddress));\n', '            uint256 srcDecimals = trade.isSell ? tokenDecimals : Utils.eth_decimals();\n', '            uint256 destDecimals = trade.isSell ? Utils.eth_decimals() : tokenDecimals;\n', '            uint256 actualRate = Utils.calcRateFromQty(amountSpentOnTrade, amountReceivedFromTrade, srcDecimals, destDecimals);\n', '            passed = actualRate >= trade.minimumExchangeRate;\n', '        }\n', '\n', '        /*if( !passed ) {\n', '             logger.log(\n', '                "Order rate was lower than minimum acceptable,  rate arg2: actualRate, arg3: minimumExchangeRate.",\n', '                actualRate,\n', '                trade.minimumExchangeRate\n', '            );\n', '        }*/\n', '    }\n', '\n', '    /// @notice Iterates through a list of token orders, transfer the SELL orders to this contract & calculates if we have the ether needed\n', '    /// @param trades A dynamic array of trade structs\n', '    /// @param tradeFlags A dynamic array of flags indicating trade and order status\n', '    function transferTokens(Trade[] trades, TradeFlag[] tradeFlags) internal {\n', '        for (uint256 i = 0; i < trades.length; i++) {\n', '            if (trades[i].isSell && !tradeFlags[i].ignoreTrade) {\n', '\n', '                /* logger.log(\n', '                    "Transfering tokens arg2: tokenAmount, arg5: tokenAddress.",\n', '                    trades[i].tokenAmount,\n', '                    0,\n', '                    0,\n', '                    0,\n', '                    trades[i].tokenAddress\n', '                ); */\n', '                if (\n', '                    !tokenTransferProxy.transferFrom(\n', '                        trades[i].tokenAddress,\n', '                        msg.sender,\n', '                        address(this),\n', '                        trades[i].tokenAmount\n', '                    )\n', '                ) {\n', '                    errorReporter.revertTx("TTP unable to transfer tokens to primary");\n', '                }\n', '           }\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates the maximum amount that should be spent on a given buy trade\n', '    /// @param trade the buy trade to return the spend amount for\n', '    /// @param etherBalance the amount of ether that we currently have to spend\n', '    /// @return uint256 the maximum amount of ether we should spend on this trade\n', '    function calculateMaxEtherSpend(Trade trade, uint256 etherBalance, uint256 feePercentage) internal view returns (uint256) {\n', '        /// @dev This function should never be called for a sell\n', '        assert(!trade.isSell);\n', '\n', '        uint256 tokenDecimals = Utils.getDecimals(ERC20(trade.tokenAddress));\n', '        uint256 srcDecimals = trade.isSell ? tokenDecimals : Utils.eth_decimals();\n', '        uint256 destDecimals = trade.isSell ? Utils.eth_decimals() : tokenDecimals;\n', '        uint256 maxSpendAtMinRate = Utils.calcSrcQty(trade.tokenAmount, srcDecimals, destDecimals, trade.minimumExchangeRate);\n', '\n', '        return Utils.min(removeFee(etherBalance, feePercentage), maxSpendAtMinRate);\n', '    }\n', '\n', '    // @notice Calculates the fee amount given a fee percentage and amount\n', '    // @param amount the amount to calculate the fee based on\n', '    // @param fee the percentage, out of 1 eth (e.g. 0.01 ETH would be 1%)\n', '    function calculateFee(uint256 amount, uint256 fee) internal view returns (uint256){\n', '        return SafeMath.div(SafeMath.mul(amount, fee), 1 ether);\n', '    }\n', '\n', '    // @notice Calculates the cost if amount=cost+fee\n', '    // @param amount the amount to calculate the base on\n', '    // @param fee the percentage, out of 1 eth (e.g. 0.01 ETH would be 1%)\n', '    function removeFee(uint256 amount, uint256 fee) internal view returns (uint256){\n', '        return SafeMath.div(SafeMath.mul(amount, 1 ether), SafeMath.add(fee, 1 ether));\n', '    }\n', '    /*\n', '    *   Payable fallback function\n', '    */\n', '\n', '    /// @notice payable fallback to allow handler or exchange contracts to return ether\n', '    /// @dev only accounts containing code (ie. contracts) can send ether to this contract\n', '    function() public payable whenNotPaused {\n', '        // Check in here that the sender is a contract! (to stop accidents)\n', '        uint256 size;\n', '        address sender = msg.sender;\n', '        assembly {\n', '            size := extcodesize(sender)\n', '        }\n', '        if (size == 0) {\n', '            errorReporter.revertTx("EOA cannot send ether to primary fallback");\n', '        }\n', '    }\n', '}']