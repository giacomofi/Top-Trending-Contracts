['pragma solidity ^0.4.25;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract NescrowExchangeService {\n', '\n', '    address owner = msg.sender;\n', '\n', '    uint256 public feeRateLimit = 200;//100/200 = 0.5% max fee\n', '    uint256 public takerFeeRate = 0;\n', '    uint256 public makerFeeRate = 0;\n', '    address public feeAddress;\n', '\n', '    mapping (address => bool) public admins;\n', '    mapping (bytes32 => uint256) public orderFills;\n', '    mapping (bytes32 => uint256) public orderPaymentFills;\n', '    mapping (bytes32 => bool) public withdrawn;\n', '    mapping (bytes32 => bool) public transfers;\n', '    mapping (address => mapping (address => uint256)) public balances;\n', '    mapping (address => uint256) public tradesLocked;\n', '    mapping (address => uint256) public disableFees;\n', '    mapping (address => uint256) public tokenDecimals;\n', '    mapping (address => bool) public tokenRegistered;\n', '\n', '    struct EIP712Domain {\n', '        string  name;\n', '        string  version;\n', '        uint256 chainId;\n', '        address verifyingContract;\n', '    }\n', '\n', '    event OrderPayment(address indexed user, address spendToken, uint256 spendAmount, address indexed merchant, address merchantReceiveToken, uint256 merchantReceiveAmount);\n', '    event TradesLock(address user);\n', '    event TradesUnlock(address user);\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner || admins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '    bytes32 constant ORDER_TYPEHASH = keccak256("Order(address fromToken,uint256 fromAmount,address toToken,uint256 toAmount,uint256 autoWithdraw,uint256 expires,uint256 nonce)");\n', '    bytes32 constant ORDER_WITH_TIPS_TYPEHASH = keccak256("OrderWithTips(address fromToken,uint256 fromAmount,address toToken,uint256 toAmount,uint256 autoWithdraw,uint256 expires,uint256 nonce,uint256 makerTips,uint256 takerTips)");\n', '    bytes32 constant ORDER_PAYMENT_TYPEHASH = keccak256("OrderPayment(address spendToken,uint256 spendAmount,address merchantReceiveToken,uint256 merchantReceiveAmount,address merchant,uint256 expires,uint256 nonce)");\n', '    bytes32 constant WITHDRAWAL_TYPEHASH = keccak256("Withdrawal(address withdrawToken,uint256 amount,uint256 nonce)");\n', '    bytes32 constant TIPS_TYPEHASH = keccak256("Tips(address tipsToken,uint256 amount,uint256 nonce)");\n', '    bytes32 constant TRANSFER_TYPEHASH = keccak256("Transfer(address transferToken,address to,uint256 amount,uint256 nonce)");\n', '    bytes32 DOMAIN_SEPARATOR;\n', '\n', '    function domainHash(EIP712Domain eip712Domain) internal pure returns (bytes32) {\n', '        return keccak256(abi.encode(\n', '                EIP712DOMAIN_TYPEHASH,\n', '                keccak256(bytes(eip712Domain.name)),\n', '                keccak256(bytes(eip712Domain.version)),\n', '                eip712Domain.chainId,\n', '                eip712Domain.verifyingContract\n', '            ));\n', '    }\n', '\n', '    constructor() public {\n', '        DOMAIN_SEPARATOR = domainHash(EIP712Domain({\n', '            name: "Nescrow Exchange",\n', '            version: &#39;2&#39;,\n', '            chainId: 1,\n', '            verifyingContract: this\n', '        }));\n', '\n', '        tokenRegistered[0x0] = true;\n', '        tokenDecimals[0x0] = 18;\n', '    }\n', '\n', '    function setOwner(address newOwner) external onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '\n', '    function getOwner() public view returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    function setAdmin(address admin, bool isAdmin) external onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '    function deposit() external payable {\n', '        uint amount = safeDiv(msg.value, 10**10);//wei to 8 decimals\n', '        require(amount > 0);\n', '        increaseBalance(msg.sender, address(0), amount);\n', '    }\n', '\n', '    function depositToken(address token, uint256 amount) external {\n', '        require(amount > 0);\n', '        require(token != 0x0);\n', '        require(safeTransferFrom(token, msg.sender, this, toTokenAmount(token, amount)));\n', '        increaseBalance(msg.sender, token, amount);\n', '    }\n', '\n', '    function depositTokenByAdmin(address user, address token, uint256 amount)\n', '        external onlyAdmin {\n', '        require(amount > 0);\n', '        require(token != 0x0);\n', '        require(safeTransferFrom(token, user, this, toTokenAmount(token, amount)));\n', '        increaseBalance(user, token, amount);\n', '    }\n', '\n', '    function sendTips() external payable {\n', '        uint amount = safeDiv(msg.value, 10**10);//wei to 8 decimals\n', '        require(amount > 0);\n', '        increaseBalance(feeAddress, address(0), amount);\n', '    }\n', '\n', '    function transferTips(address token, uint256 amount, address fromUser, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '\n', '        bytes32 hash = keccak256(abi.encode(TIPS_TYPEHASH, token, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == fromUser);\n', '\n', '        require(!transfers[hash]);\n', '        transfers[hash] = true;\n', '\n', '        require(reduceBalance(fromUser, token, amount));\n', '        increaseBalance(feeAddress, token, amount);\n', '    }\n', '\n', '    function transfer(address token, uint256 amount, address fromUser, address toUser, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '\n', '        bytes32 hash = keccak256(abi.encode(TRANSFER_TYPEHASH, token, toUser, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == fromUser);\n', '        transfers[hash] = true;\n', '\n', '        require(reduceBalance(fromUser, token, amount));\n', '        increaseBalance(toUser, token, amount);\n', '    }\n', '\n', '    function withdrawByAdmin(address token, uint256 amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '        bytes32 hash = keccak256(abi.encode(WITHDRAWAL_TYPEHASH, token, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == user);\n', '\n', '        require(!withdrawn[hash]);\n', '        withdrawn[hash] = true;\n', '\n', '        require(reduceBalance(user, token, amount));\n', '        require(sendToUser(user, token, amount));\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) external {\n', '\n', '        require(amount > 0);\n', '        require(tradesLocked[msg.sender] > block.number);\n', '        require(reduceBalance(msg.sender, token, amount));\n', '\n', '        require(sendToUser(msg.sender, token, amount));\n', '    }\n', '\n', '    function reduceBalance(address user, address token, uint256 amount) private returns(bool) {\n', '        if (balances[token][user] < amount) return false;\n', '        balances[token][user] = safeSub(balances[token][user], amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseBalanceOrWithdraw(address user, address token, uint256 amount, uint256 _withdraw) private returns(bool) {\n', '        if (_withdraw == 1) {\n', '            return sendToUser(user, token, amount);\n', '        } else {\n', '            return increaseBalance(user, token, amount);\n', '        }\n', '    }\n', '\n', '    function increaseBalance(address user, address token, uint256 amount) private returns(bool) {\n', '        balances[token][user] = safeAdd(balances[token][user], amount);\n', '        return true;\n', '    }\n', '\n', '    function sendToUser(address user, address token, uint256 amount) private returns(bool) {\n', '        if (token == address(0)) {\n', '            return user.send(toTokenAmount(address(0), amount));\n', '        } else {\n', '            return safeTransfer(token, user, toTokenAmount(token, amount));\n', '        }\n', '    }\n', '\n', '    function toTokenAmount(address token, uint256 amount) private view returns (uint256) {\n', '\n', '        require(tokenRegistered[token]);\n', '        uint256 decimals = token == address(0)\n', '            ? 18\n', '            : tokenDecimals[token];\n', '\n', '        if (decimals == 8) {\n', '            return amount;\n', '        }\n', '\n', '        if (decimals > 8) {\n', '            return safeMul(amount, 10**(decimals - 8));\n', '        } else {\n', '            return safeDiv(amount, 10**(8 - decimals));\n', '        }\n', '    }\n', '\n', '    function setTakerFeeRate(uint256 feeRate) external onlyAdmin {\n', '        require(feeRate == 0 || feeRate >= feeRateLimit);\n', '        takerFeeRate = feeRate;\n', '    }\n', '\n', '    function setMakerFeeRate(uint256 feeRate) external onlyAdmin {\n', '        require(feeRate == 0 || feeRate >= feeRateLimit);\n', '        makerFeeRate = feeRate;\n', '    }\n', '\n', '    function setFeeAddress(address _feeAddress) external onlyAdmin {\n', '        require(_feeAddress != address(0));\n', '        feeAddress = _feeAddress;\n', '    }\n', '\n', '    function disableFeesForUser(address user, uint256 timestamp) external onlyAdmin {\n', '        require(timestamp > block.timestamp);\n', '        disableFees[user] = timestamp;\n', '    }\n', '\n', '    function registerToken(address token, uint256 decimals) external onlyAdmin {\n', '        require(!tokenRegistered[token]);\n', '        tokenRegistered[token] = true;\n', '        tokenDecimals[token] = decimals;\n', '    }\n', '\n', '    function tradesLock(address user) external {\n', '        require(user == msg.sender);\n', '        tradesLocked[user] = block.number + 20000;\n', '        emit TradesLock(user);\n', '    }\n', '\n', '    function tradesUnlock(address user) external {\n', '        require(user == msg.sender);\n', '        tradesLocked[user] = 0;\n', '        emit TradesUnlock(user);\n', '    }\n', '\n', '    function isUserMakerFeeEnabled(address user, uint256 disableFee) private view returns(bool) {\n', '        return disableFee == 0 && makerFeeRate > 0 && disableFees[user] < block.timestamp;\n', '    }\n', '\n', '    function isUserTakerFeeEnabled(address user, uint256 disableFee) private view returns(bool) {\n', '        return disableFee == 0 && takerFeeRate > 0 && disableFees[user] < block.timestamp;\n', '    }\n', '\n', '    function calculateRate(uint256 offerAmount, uint256 wantAmount) private pure returns(uint256) {\n', '        return safeDiv(safeMul(10**8, wantAmount), offerAmount);\n', '    }\n', '\n', '    function trade(\n', '        uint256[10] amounts,\n', '        address[4] addresses,\n', '        uint256[6] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-offerAmount, 1-wantAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-maker, 1-taker, 2-offerToken, 3-wantToken\n', '            values: 2-withdrawMaker, 3-withdrawTaker, 4-disableMakerFee, 5-disableTakerFee\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = keccak256(abi.encode(ORDER_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderFills[orderHash2] = safeAdd(orderFills[orderHash2], amounts[9]);\n', '        require(orderFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        if (isUserMakerFeeEnabled(addresses[0], values[4])) {\n', '            require(increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], makerFeeRate)), values[2]));\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], makerFeeRate));\n', '        } else {\n', '            require(increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]));\n', '        }\n', '\n', '        if (isUserTakerFeeEnabled(addresses[1], values[5])) {\n', '            require(increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], takerFeeRate)), values[3]));\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], takerFeeRate));\n', '        } else {\n', '            require(increaseBalanceOrWithdraw(addresses[1], addresses[2], amounts[8], values[3]));\n', '        }\n', '    }\n', '\n', '    function exchangeAndPay(\n', '        uint256[10] amounts,\n', '        address[5] addresses,\n', '        uint256[4] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-merchantReceiveAmount, 1-spendAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-exchanger, 1-user, 2-merchantReceiveToken, 3-spendToken, 4-merchant\n', '            values: 2-withdrawExchanger, 3-withdrawMerchant\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[3], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = keccak256(abi.encode(ORDER_PAYMENT_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], addresses[4], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderPaymentFills[orderHash2] = safeAdd(orderPaymentFills[orderHash2], amounts[9]);\n', '        require(orderPaymentFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        require(increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]));\n', '        require(increaseBalanceOrWithdraw(addresses[4], addresses[2], amounts[8], values[3]));\n', '        //    event OrderPayment(address indexed user, address spendToken, uint256 spendAmount, address indexed merchant, address merchantReceiveToken, uint256 merchantReceiveAmount);\n', '        emit OrderPayment(addresses[1], addresses[1], amounts[9], addresses[4], addresses[2], amounts[2]);\n', '    }\n', '\n', '    function tradeWithTips(\n', '        uint256[10] amounts,\n', '        address[4] addresses,\n', '        uint256[10] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-offerAmount, 1-wantAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-maker, 1-taker, 2-offerToken, 3-wantToken\n', '            values: 2-withdrawMaker, 3-withdrawTaker, 4-orderMakerTips, 5-orderTakerTips, 6-orderMakerTips2, 7-orderTakerTips2, 8-disableMakerFee, 9-disableTakerFee\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = values[4] > 0 || values[5] > 0\n', '            ? keccak256(abi.encode(ORDER_WITH_TIPS_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3], values[4], values[5]))\n', '            : keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = values[6] > 0 || values[7] > 0\n', '            ? keccak256(abi.encode(ORDER_WITH_TIPS_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7], values[6], values[7]))\n', '            : keccak256(abi.encode(ORDER_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderFills[orderHash2] = safeAdd(orderFills[orderHash2], amounts[9]);\n', '        require(orderFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        if (values[4] > 0 && !isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], values[4])), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], values[4]));\n', '        } else if (values[4] == 0 && isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], makerFeeRate)), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], makerFeeRate));\n', '        } else if (values[4] > 0 && isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeAdd(safeDiv(amounts[9], values[4]), safeDiv(amounts[9], makerFeeRate))), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeAdd(safeDiv(amounts[9], values[4]), safeDiv(amounts[9], makerFeeRate)));\n', '        } else {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]);\n', '        }\n', '\n', '        if (values[7] > 0 && !isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], values[7])), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], values[7]));\n', '        } else if (values[7] == 0 && isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], takerFeeRate)), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], takerFeeRate));\n', '        } else if (values[7] > 0 && isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeAdd(safeDiv(amounts[8], values[7]), safeDiv(amounts[8], takerFeeRate))), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeAdd(safeDiv(amounts[8], values[7]), safeDiv(amounts[8], takerFeeRate)));\n', '        } else {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], amounts[8], values[3]);\n', '        }\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value)\n', '    private\n', '    returns (bool success)\n', '    {\n', '        // A transfer is successful when &#39;call&#39; is successful and depending on the token:\n', '        // - No value is returned: we assume a revert when the transfer failed (i.e. &#39;call&#39; returns false)\n', '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        success = token.call(0xa9059cbb, to, value);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value)\n', '    private\n', '    returns (bool success)\n', '    {\n', '        // A transferFrom is successful when &#39;call&#39; is successful and depending on the token:\n', '        // - No value is returned: we assume a revert when the transfer failed (i.e. &#39;call&#39; returns false)\n', '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '//         bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        success = token.call(0x23b872dd, from, to, value);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '    )\n', '    private\n', '    pure\n', '    returns (bool)\n', '    {\n', '        // A transfer/transferFrom is successful when &#39;call&#39; is successful and depending on the token:\n', '        // - No value is returned: we assume a revert when the transfer failed (i.e. &#39;call&#39; returns false)\n', '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', '                // Non-standard ERC20: nothing is returned so if &#39;call&#39; was successful we assume the transfer succeeded\n', '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract NescrowExchangeService {\n', '\n', '    address owner = msg.sender;\n', '\n', '    uint256 public feeRateLimit = 200;//100/200 = 0.5% max fee\n', '    uint256 public takerFeeRate = 0;\n', '    uint256 public makerFeeRate = 0;\n', '    address public feeAddress;\n', '\n', '    mapping (address => bool) public admins;\n', '    mapping (bytes32 => uint256) public orderFills;\n', '    mapping (bytes32 => uint256) public orderPaymentFills;\n', '    mapping (bytes32 => bool) public withdrawn;\n', '    mapping (bytes32 => bool) public transfers;\n', '    mapping (address => mapping (address => uint256)) public balances;\n', '    mapping (address => uint256) public tradesLocked;\n', '    mapping (address => uint256) public disableFees;\n', '    mapping (address => uint256) public tokenDecimals;\n', '    mapping (address => bool) public tokenRegistered;\n', '\n', '    struct EIP712Domain {\n', '        string  name;\n', '        string  version;\n', '        uint256 chainId;\n', '        address verifyingContract;\n', '    }\n', '\n', '    event OrderPayment(address indexed user, address spendToken, uint256 spendAmount, address indexed merchant, address merchantReceiveToken, uint256 merchantReceiveAmount);\n', '    event TradesLock(address user);\n', '    event TradesUnlock(address user);\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner || admins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '    bytes32 constant ORDER_TYPEHASH = keccak256("Order(address fromToken,uint256 fromAmount,address toToken,uint256 toAmount,uint256 autoWithdraw,uint256 expires,uint256 nonce)");\n', '    bytes32 constant ORDER_WITH_TIPS_TYPEHASH = keccak256("OrderWithTips(address fromToken,uint256 fromAmount,address toToken,uint256 toAmount,uint256 autoWithdraw,uint256 expires,uint256 nonce,uint256 makerTips,uint256 takerTips)");\n', '    bytes32 constant ORDER_PAYMENT_TYPEHASH = keccak256("OrderPayment(address spendToken,uint256 spendAmount,address merchantReceiveToken,uint256 merchantReceiveAmount,address merchant,uint256 expires,uint256 nonce)");\n', '    bytes32 constant WITHDRAWAL_TYPEHASH = keccak256("Withdrawal(address withdrawToken,uint256 amount,uint256 nonce)");\n', '    bytes32 constant TIPS_TYPEHASH = keccak256("Tips(address tipsToken,uint256 amount,uint256 nonce)");\n', '    bytes32 constant TRANSFER_TYPEHASH = keccak256("Transfer(address transferToken,address to,uint256 amount,uint256 nonce)");\n', '    bytes32 DOMAIN_SEPARATOR;\n', '\n', '    function domainHash(EIP712Domain eip712Domain) internal pure returns (bytes32) {\n', '        return keccak256(abi.encode(\n', '                EIP712DOMAIN_TYPEHASH,\n', '                keccak256(bytes(eip712Domain.name)),\n', '                keccak256(bytes(eip712Domain.version)),\n', '                eip712Domain.chainId,\n', '                eip712Domain.verifyingContract\n', '            ));\n', '    }\n', '\n', '    constructor() public {\n', '        DOMAIN_SEPARATOR = domainHash(EIP712Domain({\n', '            name: "Nescrow Exchange",\n', "            version: '2',\n", '            chainId: 1,\n', '            verifyingContract: this\n', '        }));\n', '\n', '        tokenRegistered[0x0] = true;\n', '        tokenDecimals[0x0] = 18;\n', '    }\n', '\n', '    function setOwner(address newOwner) external onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '\n', '    function getOwner() public view returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    function setAdmin(address admin, bool isAdmin) external onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '    function deposit() external payable {\n', '        uint amount = safeDiv(msg.value, 10**10);//wei to 8 decimals\n', '        require(amount > 0);\n', '        increaseBalance(msg.sender, address(0), amount);\n', '    }\n', '\n', '    function depositToken(address token, uint256 amount) external {\n', '        require(amount > 0);\n', '        require(token != 0x0);\n', '        require(safeTransferFrom(token, msg.sender, this, toTokenAmount(token, amount)));\n', '        increaseBalance(msg.sender, token, amount);\n', '    }\n', '\n', '    function depositTokenByAdmin(address user, address token, uint256 amount)\n', '        external onlyAdmin {\n', '        require(amount > 0);\n', '        require(token != 0x0);\n', '        require(safeTransferFrom(token, user, this, toTokenAmount(token, amount)));\n', '        increaseBalance(user, token, amount);\n', '    }\n', '\n', '    function sendTips() external payable {\n', '        uint amount = safeDiv(msg.value, 10**10);//wei to 8 decimals\n', '        require(amount > 0);\n', '        increaseBalance(feeAddress, address(0), amount);\n', '    }\n', '\n', '    function transferTips(address token, uint256 amount, address fromUser, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '\n', '        bytes32 hash = keccak256(abi.encode(TIPS_TYPEHASH, token, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == fromUser);\n', '\n', '        require(!transfers[hash]);\n', '        transfers[hash] = true;\n', '\n', '        require(reduceBalance(fromUser, token, amount));\n', '        increaseBalance(feeAddress, token, amount);\n', '    }\n', '\n', '    function transfer(address token, uint256 amount, address fromUser, address toUser, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '\n', '        bytes32 hash = keccak256(abi.encode(TRANSFER_TYPEHASH, token, toUser, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == fromUser);\n', '        transfers[hash] = true;\n', '\n', '        require(reduceBalance(fromUser, token, amount));\n', '        increaseBalance(toUser, token, amount);\n', '    }\n', '\n', '    function withdrawByAdmin(address token, uint256 amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s)\n', '        external onlyAdmin {\n', '\n', '        require(amount > 0);\n', '        bytes32 hash = keccak256(abi.encode(WITHDRAWAL_TYPEHASH, token, amount, nonce));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, hash)), v, r, s) == user);\n', '\n', '        require(!withdrawn[hash]);\n', '        withdrawn[hash] = true;\n', '\n', '        require(reduceBalance(user, token, amount));\n', '        require(sendToUser(user, token, amount));\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) external {\n', '\n', '        require(amount > 0);\n', '        require(tradesLocked[msg.sender] > block.number);\n', '        require(reduceBalance(msg.sender, token, amount));\n', '\n', '        require(sendToUser(msg.sender, token, amount));\n', '    }\n', '\n', '    function reduceBalance(address user, address token, uint256 amount) private returns(bool) {\n', '        if (balances[token][user] < amount) return false;\n', '        balances[token][user] = safeSub(balances[token][user], amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseBalanceOrWithdraw(address user, address token, uint256 amount, uint256 _withdraw) private returns(bool) {\n', '        if (_withdraw == 1) {\n', '            return sendToUser(user, token, amount);\n', '        } else {\n', '            return increaseBalance(user, token, amount);\n', '        }\n', '    }\n', '\n', '    function increaseBalance(address user, address token, uint256 amount) private returns(bool) {\n', '        balances[token][user] = safeAdd(balances[token][user], amount);\n', '        return true;\n', '    }\n', '\n', '    function sendToUser(address user, address token, uint256 amount) private returns(bool) {\n', '        if (token == address(0)) {\n', '            return user.send(toTokenAmount(address(0), amount));\n', '        } else {\n', '            return safeTransfer(token, user, toTokenAmount(token, amount));\n', '        }\n', '    }\n', '\n', '    function toTokenAmount(address token, uint256 amount) private view returns (uint256) {\n', '\n', '        require(tokenRegistered[token]);\n', '        uint256 decimals = token == address(0)\n', '            ? 18\n', '            : tokenDecimals[token];\n', '\n', '        if (decimals == 8) {\n', '            return amount;\n', '        }\n', '\n', '        if (decimals > 8) {\n', '            return safeMul(amount, 10**(decimals - 8));\n', '        } else {\n', '            return safeDiv(amount, 10**(8 - decimals));\n', '        }\n', '    }\n', '\n', '    function setTakerFeeRate(uint256 feeRate) external onlyAdmin {\n', '        require(feeRate == 0 || feeRate >= feeRateLimit);\n', '        takerFeeRate = feeRate;\n', '    }\n', '\n', '    function setMakerFeeRate(uint256 feeRate) external onlyAdmin {\n', '        require(feeRate == 0 || feeRate >= feeRateLimit);\n', '        makerFeeRate = feeRate;\n', '    }\n', '\n', '    function setFeeAddress(address _feeAddress) external onlyAdmin {\n', '        require(_feeAddress != address(0));\n', '        feeAddress = _feeAddress;\n', '    }\n', '\n', '    function disableFeesForUser(address user, uint256 timestamp) external onlyAdmin {\n', '        require(timestamp > block.timestamp);\n', '        disableFees[user] = timestamp;\n', '    }\n', '\n', '    function registerToken(address token, uint256 decimals) external onlyAdmin {\n', '        require(!tokenRegistered[token]);\n', '        tokenRegistered[token] = true;\n', '        tokenDecimals[token] = decimals;\n', '    }\n', '\n', '    function tradesLock(address user) external {\n', '        require(user == msg.sender);\n', '        tradesLocked[user] = block.number + 20000;\n', '        emit TradesLock(user);\n', '    }\n', '\n', '    function tradesUnlock(address user) external {\n', '        require(user == msg.sender);\n', '        tradesLocked[user] = 0;\n', '        emit TradesUnlock(user);\n', '    }\n', '\n', '    function isUserMakerFeeEnabled(address user, uint256 disableFee) private view returns(bool) {\n', '        return disableFee == 0 && makerFeeRate > 0 && disableFees[user] < block.timestamp;\n', '    }\n', '\n', '    function isUserTakerFeeEnabled(address user, uint256 disableFee) private view returns(bool) {\n', '        return disableFee == 0 && takerFeeRate > 0 && disableFees[user] < block.timestamp;\n', '    }\n', '\n', '    function calculateRate(uint256 offerAmount, uint256 wantAmount) private pure returns(uint256) {\n', '        return safeDiv(safeMul(10**8, wantAmount), offerAmount);\n', '    }\n', '\n', '    function trade(\n', '        uint256[10] amounts,\n', '        address[4] addresses,\n', '        uint256[6] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-offerAmount, 1-wantAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-maker, 1-taker, 2-offerToken, 3-wantToken\n', '            values: 2-withdrawMaker, 3-withdrawTaker, 4-disableMakerFee, 5-disableTakerFee\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = keccak256(abi.encode(ORDER_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderFills[orderHash2] = safeAdd(orderFills[orderHash2], amounts[9]);\n', '        require(orderFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        if (isUserMakerFeeEnabled(addresses[0], values[4])) {\n', '            require(increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], makerFeeRate)), values[2]));\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], makerFeeRate));\n', '        } else {\n', '            require(increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]));\n', '        }\n', '\n', '        if (isUserTakerFeeEnabled(addresses[1], values[5])) {\n', '            require(increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], takerFeeRate)), values[3]));\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], takerFeeRate));\n', '        } else {\n', '            require(increaseBalanceOrWithdraw(addresses[1], addresses[2], amounts[8], values[3]));\n', '        }\n', '    }\n', '\n', '    function exchangeAndPay(\n', '        uint256[10] amounts,\n', '        address[5] addresses,\n', '        uint256[4] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-merchantReceiveAmount, 1-spendAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-exchanger, 1-user, 2-merchantReceiveToken, 3-spendToken, 4-merchant\n', '            values: 2-withdrawExchanger, 3-withdrawMerchant\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[3], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = keccak256(abi.encode(ORDER_PAYMENT_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], addresses[4], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderPaymentFills[orderHash2] = safeAdd(orderPaymentFills[orderHash2], amounts[9]);\n', '        require(orderPaymentFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        require(increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]));\n', '        require(increaseBalanceOrWithdraw(addresses[4], addresses[2], amounts[8], values[3]));\n', '        //    event OrderPayment(address indexed user, address spendToken, uint256 spendAmount, address indexed merchant, address merchantReceiveToken, uint256 merchantReceiveAmount);\n', '        emit OrderPayment(addresses[1], addresses[1], amounts[9], addresses[4], addresses[2], amounts[2]);\n', '    }\n', '\n', '    function tradeWithTips(\n', '        uint256[10] amounts,\n', '        address[4] addresses,\n', '        uint256[10] values,\n', '        bytes32[4] rs\n', '    ) external onlyAdmin {\n', '        /**\n', '            amounts: 0-offerAmount, 1-wantAmount, 2-orderExpires, 3-orderNonce, 4-offerAmount2, 5-wantAmount2, 6-orderExpires2, 7-orderNonce2, 8-offerAmountToFill, 9-wantAmountToFill\n', '            addresses: 0-maker, 1-taker, 2-offerToken, 3-wantToken\n', '            values: 2-withdrawMaker, 3-withdrawTaker, 4-orderMakerTips, 5-orderTakerTips, 6-orderMakerTips2, 7-orderTakerTips2, 8-disableMakerFee, 9-disableTakerFee\n', '        */\n', '        require(tradesLocked[addresses[0]] < block.number);\n', '        require(block.timestamp <= amounts[2]);\n', '        bytes32 orderHash = values[4] > 0 || values[5] > 0\n', '            ? keccak256(abi.encode(ORDER_WITH_TIPS_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3], values[4], values[5]))\n', '            : keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[2], amounts[2], amounts[3]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n', '        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n', '        require(orderFills[orderHash] <= amounts[0]);\n', '\n', '        require(tradesLocked[addresses[1]] < block.number);\n', '        require(block.timestamp <= amounts[6]);\n', '        bytes32 orderHash2 = values[6] > 0 || values[7] > 0\n', '            ? keccak256(abi.encode(ORDER_WITH_TIPS_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7], values[6], values[7]))\n', '            : keccak256(abi.encode(ORDER_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], values[3], amounts[6], amounts[7]));\n', '        require(ecrecover(keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n', '\n', '        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n', '        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n', '        require(makerRate <= takerRate);\n', '        require(makerRate == calculateRate(amounts[8], amounts[9]));\n', '\n', '        orderFills[orderHash2] = safeAdd(orderFills[orderHash2], amounts[9]);\n', '        require(orderFills[orderHash2] <= amounts[4]);\n', '\n', '        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n', '        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n', '\n', '        if (values[4] > 0 && !isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], values[4])), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], values[4]));\n', '        } else if (values[4] == 0 && isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeDiv(amounts[9], makerFeeRate)), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeDiv(amounts[9], makerFeeRate));\n', '        } else if (values[4] > 0 && isUserMakerFeeEnabled(addresses[0], values[8])) {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], safeSub(amounts[9], safeAdd(safeDiv(amounts[9], values[4]), safeDiv(amounts[9], makerFeeRate))), values[2]);\n', '            increaseBalance(feeAddress, addresses[3], safeAdd(safeDiv(amounts[9], values[4]), safeDiv(amounts[9], makerFeeRate)));\n', '        } else {\n', '            increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]);\n', '        }\n', '\n', '        if (values[7] > 0 && !isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], values[7])), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], values[7]));\n', '        } else if (values[7] == 0 && isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeDiv(amounts[8], takerFeeRate)), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeDiv(amounts[8], takerFeeRate));\n', '        } else if (values[7] > 0 && isUserTakerFeeEnabled(addresses[1], values[9])) {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], safeSub(amounts[8], safeAdd(safeDiv(amounts[8], values[7]), safeDiv(amounts[8], takerFeeRate))), values[3]);\n', '            increaseBalance(feeAddress, addresses[2], safeAdd(safeDiv(amounts[8], values[7]), safeDiv(amounts[8], takerFeeRate)));\n', '        } else {\n', '            increaseBalanceOrWithdraw(addresses[1], addresses[2], amounts[8], values[3]);\n', '        }\n', '    }\n', '\n', '    function() public payable {\n', '        revert();\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value)\n', '    private\n', '    returns (bool success)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        success = token.call(0xa9059cbb, to, value);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value)\n', '    private\n', '    returns (bool success)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '//         bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        success = token.call(0x23b872dd, from, to, value);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '    )\n', '    private\n', '    pure\n', '    returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}']
