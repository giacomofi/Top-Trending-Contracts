['pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract SHT_Token \n', '{\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyTokenHolders() \n', '    {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '    \n', '    // only people with profits\n', '    modifier onlyDividendPositive() \n', '    {\n', '        require(myDividends() > 0);\n', '        _;\n', '    }\n', '\n', '    // only owner\n', '    modifier onlyOwner() \n', '    { \n', '        require (address(msg.sender) == owner); \n', '        _; \n', '    }\n', '    \n', '    // only founders if contract not live\n', '    modifier onlyFoundersIfNotPublic() \n', '    {\n', '        if(!openToThePublic)\n', '        {\n', '            require (founders[address(msg.sender)] == true);   \n', '        }\n', '        _;\n', '    }    \n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '    \n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '    \n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '    \n', '    event lotteryPayout(\n', '        address customerAddress, \n', '        uint256 lotterySupply\n', '    );\n', '    \n', '    event whaleDump(\n', '        uint256 amount\n', '    );\n', '    \n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '    \n', '    \n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "SHT Token";\n', '    string public symbol = "SHT";\n', '    bool public openToThePublic = false;\n', '    address public owner;\n', '    address public dev;\n', '    uint8 constant public decimals = 18;\n', '    uint8 constant internal dividendFee = 10;  //11% (total.. breakdown is 5% tokenholders, 2.5% OB2, 1.5% whale, 1% lottery, 1% dev)\n', '    uint8 constant internal lotteryFee = 5; \n', '    uint8 constant internal devFee = 5; \n', '    uint8 constant internal ob2Fee = 2;  \n', '    uint256 constant internal tokenPrice = 400000000000000;  //0.0004 ether\n', '    uint256 constant internal magnitude = 2**64;\n', '    Onigiri2 private ob2; \n', '   \n', '\n', '    \n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    mapping(address => uint256) internal publicTokenLedger;\n', '    mapping(address => uint256) public   whaleLedger;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => bool) internal founders;\n', '    address[] lotteryPlayers;\n', '    uint256 internal lotterySupply = 0;\n', '    uint256 internal tokenSupply = 0;\n', '    uint256 internal profitPerShare_;\n', '    \n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS --  \n', '    */\n', '    constructor()\n', '        public\n', '    {\n', '        // no admin, but the owner of the contract is the address used for whale\n', '        owner = address(msg.sender);\n', '\n', '        dev = address(0x7e474fe5Cfb720804860215f407111183cbc2f85); //some SHT Dev\n', '\n', "        // add founders here... Founders don't get any special priveledges except being first in line at launch day\n", '        founders[0x013f3B8C9F1c4f2f28Fd9cc1E1CF3675Ae920c76] = true; //Nomo\n', '        founders[0xF57924672D6dBF0336c618fDa50E284E02715000] = true; //Bungalogic\n', '        founders[0xE4Cf94e5D30FB4406A2B139CD0e872a1C8012dEf] = true; //Ivan\n', '\n', '        // link this contract to OB2 contract to send rewards\n', '        ob2 = Onigiri2(0xb8a68f9B8363AF79dEf5c5e11B12e8A258cE5be8); //MainNet\n', '    }\n', '    \n', '     \n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\n', '     */\n', '    function buy()\n', '        onlyFoundersIfNotPublic()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        require (msg.sender == tx.origin);\n', '         uint256 tokenAmount;\n', '\n', '        tokenAmount = purchaseTokens(msg.value); //redirects to purchaseTokens so same functionality\n', '\n', '        return tokenAmount;\n', '    }\n', '    \n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     */\n', '    function()\n', '        payable\n', '        public\n', '    {\n', '       buy();\n', '    }\n', '    \n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    function reinvest()\n', '        onlyDividendPositive()\n', '        public\n', '    {   \n', '        require (msg.sender == tx.origin);\n', '        \n', '        // fetch dividends\n', '        uint256 dividends = myDividends(); \n', '        \n', '        // pay out the dividends virtually\n', '        address customerAddress = msg.sender;\n', '        payoutsTo_[customerAddress] +=  int256(dividends * magnitude);\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(dividends);\n', '        \n', '        // fire event for logging \n', '        emit onReinvestment(customerAddress, dividends, _tokens);\n', '    }\n', '    \n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit()\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // get token count for caller & sell them all\n', '        address customerAddress = address(msg.sender);\n', '        uint256 _tokens = publicTokenLedger[customerAddress];\n', '        \n', '        if(_tokens > 0) \n', '        {\n', '            sell(_tokens);\n', '        }\n', '\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw()\n', '        onlyDividendPositive()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        \n', '        // setup data\n', '        address customerAddress = msg.sender;\n', '        uint256 dividends = myDividends(); \n', '        \n', '        // update dividend tracker\n', '        payoutsTo_[customerAddress] +=  int256(dividends * magnitude);\n', '        \n', '        customerAddress.transfer(dividends);\n', '        \n', '        // fire event for logging \n', '        emit onWithdraw(customerAddress, dividends);\n', '    }\n', '    \n', '    /**\n', '     * Liquifies tokens to ethereum.\n', '     */\n', '    function sell(uint256 _amountOfTokens)\n', '        onlyTokenHolders()\n', '        public\n', '    {\n', '        require (msg.sender == tx.origin);\n', '        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0));\n', '\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 ethereum = tokensToEthereum_(_tokens);\n', '\n', '        uint256 undividedDivs = SafeMath.div(ethereum, dividendFee);\n', '        \n', '        // from that 10%, divide for Community, Whale, Lottery, and OB2\n', '        uint256 communityDivs = SafeMath.div(undividedDivs, 2); //5%\n', '        uint256 ob2Divs = SafeMath.div(undividedDivs, 4); //2.5% \n', '        uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); // 1%\n', '        uint256 tip4Dev = lotteryDivs;\n', '        uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs));  // 1.5%\n', '\n', '\n', "        // let's deduct Whale, Lottery, and OB2 divs just to make sure our math is safe\n", '        uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs));\n', '\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, (undividedDivs + tip4Dev));\n', '\n', '        //add divs to whale\n', '        whaleLedger[owner] += whaleDivs;\n', '        \n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryDivs);\n', '\n', '        //send divs to OB2\n', '        ob2.fromGame.value(ob2Divs)();\n', '\n', '        //send tip to Dev\n', '        dev.transfer(tip4Dev);\n', '        \n', '        // burn the sold tokens\n', '        tokenSupply -=  _tokens;\n', '        publicTokenLedger[msg.sender] -= _tokens;\n', '        \n', '        \n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (taxedEthereum * magnitude));\n', '        payoutsTo_[msg.sender] -= _updatedPayouts;  \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply > 0) \n', '        {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ += ((dividends * magnitude) / tokenSupply);\n', '        }\n', '        \n', '        // fire event for logging \n', '        emit onTokenSell(msg.sender, _tokens, taxedEthereum);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyTokenHolders()\n', '        public\n', '        returns(bool)\n', '    {\n', '        assert(_toAddress != owner);\n', '        \n', '        // make sure we have the requested tokens\n', '        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 ));\n', '            // exchange tokens\n', '        publicTokenLedger[msg.sender] -= _amountOfTokens;\n', '        publicTokenLedger[_toAddress] += _amountOfTokens; \n', '        \n', '        // update dividend trackers\n', '        payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\n', '        payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \n', '            \n', '        // fire event for logging \n', '        emit Transfer(msg.sender, _toAddress, _amountOfTokens); \n', '\n', '        return true;     \n', '    }\n', '    \n', '    /*----------  OWNER ONLY FUNCTIONS  ----------*/\n', '\n', '    /**\n', '     * Want to prevent snipers from buying prior to launch\n', '     */\n', '    function goPublic() \n', '        onlyOwner()\n', '        public \n', '        returns(bool)\n', '\n', '    {\n', '        openToThePublic = true;\n', '        return openToThePublic;\n', '    }\n', '    \n', '    \n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     */\n', '    function totalEthereumBalance()\n', '        public\n', '        view\n', '        returns(uint)\n', '    {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return (tokenSupply + lotterySupply); //adds the tokens from ambassadors to the supply (but not to the dividends calculation which is based on the supply)\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balanceOf(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the balance of the whale.\n', '     */\n', '    function whaleBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return  whaleLedger[owner]; \n', '    }\n', '\n', '\n', '    /**\n', '     * Retrieve the balance of the whale.\n', '     */\n', '    function lotteryBalance()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return  lotterySupply; \n', '    }\n', '    \n', '    \n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     */ \n', '    function myDividends() \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        return dividendsOf(msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return publicTokenLedger[customerAddress];\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '      return (uint256) ((int256)(profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / magnitude;\n', '    }\n', '    \n', '    /**\n', '     * Return the buy and sell price of 1 individual token.\n', '     */\n', '    function buyAndSellPrice()\n', '    public\n', '    pure \n', '    returns(uint256)\n', '    {\n', '        uint256 ethereum = tokenPrice;\n', '        uint256 dividends = SafeMath.div((ethereum * dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 ethereumToSpend) \n', '        public \n', '        pure \n', '        returns(uint256)\n', '    {\n', '        require(ethereumToSpend >= tokenPrice);\n', '        uint256 dividends = SafeMath.div((ethereumToSpend * dividendFee), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends);\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price of sell orders.\n', '     */\n', '    function calculateEthereumReceived(uint256 tokensToSell) \n', '        public \n', '        view \n', '        returns(uint256)\n', '    {\n', '        require(tokensToSell <= tokenSupply);\n', '        uint256 ethereum = tokensToEthereum_(tokensToSell);\n', '        uint256 dividends = SafeMath.div((ethereum * dividendFee ), 100);\n', '        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\n', '        return taxedEthereum;\n', '    }\n', '    \n', '    \n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    \n', '    function purchaseTokens(uint256 incomingEthereum)\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        // take out 10% of incoming eth for divs\n', '        uint256 undividedDivs = SafeMath.div(incomingEthereum, dividendFee);\n', '        \n', '        // from that 10%, divide for Community, Whale, Lottery, and OB2\n', '        uint256 communityDivs = SafeMath.div(undividedDivs, 2); //5%\n', '        uint256 ob2Divs = SafeMath.div(undividedDivs, 4); //2.5% \n', '        uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); // 1%\n', '        uint256 tip4Dev = lotteryDivs;\n', '        uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs));  // 1.5%\n', '\n', "        // let's deduct Whale, Lottery, devfee, and OB2 divs just to make sure our math is safe\n", '        uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs));\n', '\n', '        uint256 taxedEthereum = SafeMath.sub(incomingEthereum, (undividedDivs + tip4Dev));\n', '        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\n', '\n', '        //add divs to whale\n', '        whaleLedger[owner] += whaleDivs;\n', '        \n', '        //add tokens to the lotterySupply\n', '        lotterySupply += ethereumToTokens_(lotteryDivs);\n', '        \n', '        //add entry to lottery\n', '        lotteryPlayers.push(msg.sender);\n', '\n', '        //send divs to OB2\n', '        ob2.fromGame.value(ob2Divs)();\n', '\n', '        //tip the dev\n', '        dev.transfer(tip4Dev);\n', '       \n', '        uint256 fee = dividends * magnitude;\n', ' \n', '        require(amountOfTokens > 0 && (amountOfTokens + tokenSupply) > tokenSupply);\n', '\n', '        uint256 payoutDividends = isWhalePaying();\n', '        \n', "        // we can't give people infinite ethereum\n", '        if(tokenSupply > 0)\n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply += amountOfTokens;\n', '            \n', '             // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += ((payoutDividends + dividends) * magnitude / (tokenSupply));\n', '            \n', '            // calculate the amount of tokens the customer receives over his purchase \n', '            fee -= fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)));\n', '        } else \n', '        {\n', '            // add tokens to the pool\n', '            tokenSupply = amountOfTokens;\n', '            \n', '            //if there are zero tokens prior to this buy, and the whale is triggered, send dividends back to whale\n', '            if(whaleLedger[owner] == 0)\n', '            {\n', '                whaleLedger[owner] = payoutDividends;\n', '            }\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        publicTokenLedger[msg.sender] += amountOfTokens;\n', '        \n', "        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n", '        int256 _updatedPayouts = int256((profitPerShare_ * amountOfTokens) - fee);\n', '        payoutsTo_[msg.sender] += _updatedPayouts;\n', '        \n', '     \n', '        // fire event for logging \n', '        emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens);\n', '        \n', '        return amountOfTokens;\n', '    }\n', '    \n', '    \n', '     /**\n', '     * Calculate token sell value.\n', "     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '    function isWhalePaying()\n', '    private\n', '    returns(uint256)\n', '    {\n', '        uint256 payoutDividends = 0;\n', '         // this is where we check for lottery winner\n', '        if(whaleLedger[owner] >= 1 ether)\n', '        {\n', '            if(lotteryPlayers.length > 0)\n', '            {\n', '                uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length;\n', '                \n', '                publicTokenLedger[lotteryPlayers[winner]] += lotterySupply;\n', '                emit lotteryPayout(lotteryPlayers[winner], lotterySupply);\n', '                tokenSupply += lotterySupply;\n', '                lotterySupply = 0;\n', '                delete lotteryPlayers;\n', '               \n', '            }\n', '            //whale pays out everyone its divs\n', '            payoutDividends = whaleLedger[owner];\n', '            whaleLedger[owner] = 0;\n', '            emit whaleDump(payoutDividends);\n', '        }\n', '        return payoutDividends;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', "     *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '    function ethereumToTokens_(uint256 ethereum)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 tokensReceived = ((ethereum / tokenPrice) * 1e18);\n', '               \n', '        return tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * Calculate token sell value.\n', "     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\n", '     */\n', '     function tokensToEthereum_(uint256 coin)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 ethReceived = tokenPrice * (SafeMath.div(coin, 1e18));\n', '        \n', '        return ethReceived;\n', '    }\n', '}\n', '\n', 'contract Onigiri2 \n', '{\n', '    function fromGame() external payable;\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '}']