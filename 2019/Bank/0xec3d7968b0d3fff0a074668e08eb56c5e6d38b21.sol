['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title Ownable contract - base contract with an owner\n', ' */\n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    assert(_newOwner != address(0));      \n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Accept transferOwnership.\n', '   */\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      emit OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SDADI - Interface\n', ' */\n', 'interface SDADI  {\t\n', '  function AddToken(address token) external;\n', '  function DelToken(address token) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title DAppDEXI - Interface \n', ' */\n', 'interface DAppDEXI {\n', '\n', '    function updateAgent(address _agent, bool _status) external;\n', '\n', '    function setAccountType(address user_, uint256 type_) external;\n', '    function getAccountType(address user_) external view returns(uint256);\n', '    function setFeeType(uint256 type_ , uint256 feeMake_, uint256 feeTake_) external;\n', '    function getFeeMake(uint256 type_ ) external view returns(uint256);\n', '    function getFeeTake(uint256 type_ ) external view returns(uint256);\n', '    function changeFeeAccount(address feeAccount_) external;\n', '    \n', '    function setWhitelistTokens(address token) external;\n', '    function setWhitelistTokens(address token, bool active, uint256 timestamp, bytes32 typeERC) external;\n', '    function depositToken(address token, uint amount) external;\n', '    function tokenFallback(address owner, uint256 amount, bytes data) external returns (bool success);\n', '\n', '    function withdraw(uint amount) external;\n', '    function withdrawToken(address token, uint amount) external;\n', '\n', '    function balanceOf(address token, address user) external view returns (uint);\n', '\n', '    function order(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce) external;\n', '    function trade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) external;    \n', '    function cancelOrder(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) external;\n', '    function testTrade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) external view returns(bool);\n', '    function availableVolume(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) external view returns(uint);\n', '    function amountFilled(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user) external view returns(uint);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20I {\n', '\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '  function transfer(address _to, uint256 _value) external returns (bool success);\n', '  \n', '  function allowance(address _owner, address _spender) external view returns (uint256);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '  function approve(address _spender, uint256 _value) external returns (bool success);\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow.\n', '    */\n', '    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        assert(y <= x);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x + y;\n', '        assert(z >= x);\n', '        return z;\n', '    }\n', '\t\n', '\t/**\n', '    * @dev Integer division of two numbers, reverts on division by zero.\n', '    */\n', '    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\t\n', '    function safeMul(uint256 x, uint256 y) internal pure returns (uint256) {    \n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '    \n', '        uint256 z = x * y;\n', '        assert(z / x == y);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the integer percentage of the number.\n', '    */\n', '    function safePerc(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        if (x == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        uint256 z = x * y;\n', '        assert(z / x == y);    \n', '        z = z / 10000; // percent to hundredths\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the minimum value of two numbers.\n', '    */\t\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x <= y ? x : y;\n', '        return z;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the maximum value of two numbers.\n', '    */\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x >= y ? x : y;\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Agent contract - base contract with an agent\n', ' */\n', 'contract Agent is Ownable {\n', '\n', '  address public defAgent;\n', '\n', '  mapping(address => bool) public Agents;\n', '  \n', '  constructor() public {    \n', '    Agents[msg.sender] = true;\n', '  }\n', '  \n', '  modifier onlyAgent() {\n', '    assert(Agents[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  function updateAgent(address _agent, bool _status) public onlyOwner {\n', '    assert(_agent != address(0));\n', '    Agents[_agent] = _status;\n', '  }  \n', '}\n', '\n', '\n', '/**\n', ' * @title DAppsDEX - Decentralized exchange for DApps\n', ' */\n', 'contract DAppDEX is DAppDEXI, SafeMath, Agent {\n', '    \n', '    address public feeAccount;\n', '    mapping (address => mapping (address => uint)) public tokens;\n', '    mapping (address => mapping (bytes32 => bool)) public orders;\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills;\n', '\n', '    uint public feeListing = 100; // 1.00%\n', '\n', '    struct whitelistToken {\n', '        bool active;\n', '        uint256 timestamp;\n', '    }\n', '    \n', '    struct Fee {\n', '        uint256 feeMake;\n', '        uint256 feeTake;\n', '    }\n', '    \n', '    mapping (address => whitelistToken) public whitelistTokens;\n', '    mapping (address => uint256) public accountTypes;\n', '    mapping (uint256 => Fee) public feeTypes;\n', '  \n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event PayFeeListing(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    event Order(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, bytes32 hash);\n', '    event Trade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, address user, address recipient, bytes32 hash, uint256 timestamp);\n', '    event WhitelistTokens(address token, bool active, uint256 timestamp, bytes32 typeERC);\n', '  \n', '    constructor (address feeAccount_) public {\n', '        feeAccount = feeAccount_;\n', '        feeTypes[0] = Fee(1000000000000000, 2000000000000000);\n', '        whitelistTokens[0] = whitelistToken(true, 1);\n', '        emit WhitelistTokens(0, true, 1, 0x0);\n', '    }\n', '\n', '    function setFeeListing(uint _feeListing) external onlyAgent {\n', '        feeListing = _feeListing;\n', '    }\n', '    \n', '    function setAccountType(address user_, uint256 type_) external onlyAgent {\n', '        accountTypes[user_] = type_;\n', '    }\n', '\n', '    function getAccountType(address user_) external view returns(uint256) {\n', '        return accountTypes[user_];\n', '    }\n', '  \n', '    function setFeeType(uint256 type_ , uint256 feeMake_, uint256 feeTake_) external onlyAgent {\n', '        feeTypes[type_] = Fee(feeMake_,feeTake_);\n', '    }\n', '\n', '    function getFeeMake(uint256 type_ ) external view returns(uint256) {\n', '        return (feeTypes[type_].feeMake);\n', '    }\n', '    \n', '    function getFeeTake(uint256 type_ ) external view returns(uint256) {\n', '        return (feeTypes[type_].feeTake);\n', '    }\n', '    \n', '    function changeFeeAccount(address feeAccount_) external onlyAgent {\n', '        require(feeAccount_ != address(0));\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function setWhitelistTokens(address token) external onlyOwner {\n', '        whitelistTokens[token].active = true;\n', '        whitelistTokens[token].timestamp = now;\n', '        SDADI(feeAccount).AddToken(token);\n', '        emit WhitelistTokens(token, true, now, "ERC20");\n', '    }    \n', '    \n', '    function setWhitelistTokens(address token, bool active, uint256 timestamp, bytes32 typeERC) external onlyAgent {\n', '        if (active) {\n', '            uint fee = safePerc(ERC20I(token).totalSupply(), feeListing);\n', '            require(fee > 0);\n', '            require(tokens[token][feeAccount] >= fee);\n', '            SDADI(feeAccount).AddToken(token);\n', '        } else {\n', '            SDADI(feeAccount).DelToken(token);\n', '        }\n', '        whitelistTokens[token].active = active;\n', '        whitelistTokens[token].timestamp = timestamp;\n', '        emit WhitelistTokens(token, active, timestamp, typeERC);\n', '    }\n', '    \n', '    /**\n', '    * deposit ETH\n', '    */\n', '    function() public payable {\n', '        require(msg.value > 0);\n', '        deposit(msg.sender);\n', '    }\n', '  \n', '    /**\n', '    * Make deposit.\n', '    *\n', '    * @param receiver The Ethereum address who make deposit\n', '    *\n', '    */\n', '    function deposit(address receiver) private {\n', '        tokens[0][receiver] = safeAdd(tokens[0][receiver], msg.value);\n', '        emit Deposit(0, receiver, msg.value, tokens[0][receiver]);\n', '    }\n', '  \n', '    /**\n', '    * Deposit token.\n', '    *\n', '    * @param token Token address\n', '    * @param amount Deposit amount\n', '    *\n', '    */\n', '    function depositToken(address token, uint amount) external {\n', '        require(token != address(0));\n', '        if (whitelistTokens[token].active) {\n', '            require(whitelistTokens[token].timestamp <= now);\n', '            require(ERC20I(token).transferFrom(msg.sender, this, amount));\n', '            tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '            emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '        } else {\n', '            require(ERC20I(token).transferFrom(msg.sender, this, amount));\n', '            tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], amount);\n', '            emit PayFeeListing(token, msg.sender, amount, tokens[msg.sender][feeAccount]);\n', '        }\n', '        \n', '    }\n', '\n', '    /**\n', '    * tokenFallback ERC223.\n', '    *\n', '    * @param owner owner token\n', '    * @param amount Deposit amount\n', '    * @param data payload  \n', '    *\n', '    */\n', '    function tokenFallback(address owner, uint256 amount, bytes data) external returns (bool success) {      \n', '\n', '        if (data.length == 0) {\n', '            assert(whitelistTokens[msg.sender].active && whitelistTokens[msg.sender].timestamp <= now);            \n', '            tokens[msg.sender][owner] = safeAdd(tokens[msg.sender][owner], amount);\n', '            emit Deposit(msg.sender, owner, amount, tokens[msg.sender][owner]);\n', '            return true;\n', '        } else {\n', '            tokens[msg.sender][feeAccount] = safeAdd(tokens[msg.sender][feeAccount], amount);\n', '            emit PayFeeListing(msg.sender, owner, amount, tokens[msg.sender][feeAccount]);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Withdraw deposit.\n', '    *\n', '    * @param amount Withdraw amount\n', '    *\n', '    */\n', '    function withdraw(uint amount) external {\n', '        require(tokens[0][msg.sender] >= amount);\n', '        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '        msg.sender.transfer(amount);\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }  \n', '    \n', '    /**\n', '    * Withdraw token.\n', '    *\n', '    * @param token Token address\n', '    * @param amount Withdraw amount\n', '    *\n', '    */\n', '    function withdrawToken(address token, uint amount) external {\n', '        require(token != address(0));\n', '        require(tokens[token][msg.sender] >= amount);\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        require(ERC20I(token).transfer(msg.sender, amount));\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '  \n', '    function balanceOf(address token, address user) external view returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '  \n', '    function order(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce) external {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender));\n', '        orders[msg.sender][hash] = true;\n', '        emit Order(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender);\n', '    }\n', '  \n', '    function trade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) external {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user));\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == user) &&\n', '            block.timestamp <= expires &&\n', '            safeAdd(orderFills[user][hash], amount) <= amountBuy\n', '        )) revert();\n', '        tradeBalances(tokenBuy, amountBuy, tokenSell, amountSell, user, amount);\n', '        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n', '        emit Trade(tokenBuy, amount, tokenSell, amountSell * amount / amountBuy, user, msg.sender, hash, block.timestamp);\n', '    }\n', '\n', '    function tradeBalances(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, address user, uint amount) private {\n', '        uint feeMakeXfer = safeMul(amount, feeTypes[accountTypes[user]].feeMake) / (10**18);\n', '        uint feeTakeXfer = safeMul(amount, feeTypes[accountTypes[msg.sender]].feeTake) / (10**18);\n', '        tokens[tokenBuy][msg.sender] = safeSub(tokens[tokenBuy][msg.sender], safeAdd(amount, feeTakeXfer));\n', '        tokens[tokenBuy][user] = safeAdd(tokens[tokenBuy][user], safeSub(amount, feeMakeXfer));\n', '        tokens[tokenBuy][feeAccount] = safeAdd(tokens[tokenBuy][feeAccount], safeAdd(feeMakeXfer, feeTakeXfer));\n', '        tokens[tokenSell][user] = safeSub(tokens[tokenSell][user], safeMul(amountSell, amount) / amountBuy);\n', '        tokens[tokenSell][msg.sender] = safeAdd(tokens[tokenSell][msg.sender], safeMul(amountSell, amount) / amountBuy);\n', '    }\n', '  \n', '    function cancelOrder(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) external {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender));\n', '        if (!(orders[msg.sender][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == msg.sender)) revert();\n', '        orderFills[msg.sender][hash] = amountBuy;\n', '        emit Cancel(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender, v, r, s, hash);\n', '    }\n', '  \n', '    function testTrade(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) external view returns(bool) {\n', '        if (!(\n', '            tokens[tokenBuy][sender] >= amount &&\n', '            availableVolume(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user, v, r, s) >= amount\n', '        )) return false;\n', '        return true;\n', '    }\n', '\n', '    function availableVolume(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public view returns(uint) {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user));\n', '        if (!(\n', '            (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == user) &&\n', '            block.timestamp <= expires\n', '        )) return 0;\n', '        uint available1 = safeSub(amountBuy, orderFills[user][hash]);\n', '        uint available2 = safeMul(tokens[tokenSell][user], amountBuy) / amountSell;\n', '        if (available1<available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenBuy, uint amountBuy, address tokenSell, uint amountSell, uint expires, uint nonce, address user) external view returns(uint) {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user));\n', '        return orderFills[user][hash];\n', '    }\n', '}']