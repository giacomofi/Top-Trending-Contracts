['pragma solidity ^0.5.2;\n', '\n', '// File: contracts/token/ERC20Basic.sol\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/token/BasicToken.sol\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '  mapping(address => uint256) balances;\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', '// File: contracts/token/ERC20.sol\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/token/StandardToken.sol\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  function increaseApproval (address _spender, uint _addedValue) external\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '  function decreaseApproval (address _spender, uint _subtractedValue) external\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/token/MintableToken.sol\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '  bool public mintingFinished = false;\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '  function finishMinting() onlyOwner public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '  function burnTokens(uint256 _unsoldTokens) onlyOwner public returns (bool) {\n', '    totalSupply = totalSupply.sub(_unsoldTokens);\n', '  }\n', '}\n', '\n', '// File: contracts/lifecycle/Pausable.sol\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '  bool public paused = false;\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/whitelist/Whitelist.sol\n', '\n', 'library Whitelist {\n', '  struct List {\n', '    mapping(address => bool) registry;\n', '  }\n', '  function add(List storage list, address beneficiary) internal {\n', '    list.registry[beneficiary] = true;\n', '  }\n', '  function remove(List storage list, address beneficiary) internal {\n', '    list.registry[beneficiary] = false;\n', '  }\n', '  function check(List storage list, address beneficiary) view internal returns (bool) {\n', '    return list.registry[beneficiary];\n', '  }\n', '}\n', '\n', '// File: contracts/whitelist/whitelisted.sol\n', '\n', 'contract Whitelisted is Ownable {\n', '  Whitelist.List private _list;\n', '  modifier onlyWhitelisted() {\n', '    require(Whitelist.check(_list, msg.sender) == true);\n', '    _;\n', '  }\n', '  event AddressAdded(address[] beneficiary);\n', '  event AddressRemoved(address[] beneficiary);\n', '\n', '  constructor() public {\n', '    Whitelist.add(_list, msg.sender);\n', '  }\n', '  function enable(address[] calldata _beneficiary) external onlyOwner {\n', '    for (uint256 i = 0; i < _beneficiary.length; i++) {\n', '      Whitelist.add(_list, _beneficiary[i]);\n', '    }\n', '    emit AddressAdded(_beneficiary);\n', '  }\n', '  function disable(address[] calldata _beneficiary) external onlyOwner {\n', '    for (uint256 i = 0; i < _beneficiary.length; i++) {\n', '      Whitelist.remove(_list, _beneficiary[i]);\n', '    }\n', '    emit AddressRemoved(_beneficiary);\n', '  }\n', '  function isListed(address _beneficiary) external view returns (bool){\n', '    return Whitelist.check(_list, _beneficiary);\n', '  }\n', '}\n', '\n', '// File: contracts/crowdsale/RefundVault.sol\n', '\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '  enum State { Active, Refunding, Closed }\n', '  mapping (address => uint256) public deposited;\n', '  State public state;\n', '  event Closed();\n', '  event RefundsEnabled();\n', '\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '  constructor() public {\n', '    state = State.Active;\n', '  }\n', '  function deposit(address _beneficiary) onlyOwner external payable {\n', '    require(state == State.Active);\n', '    deposited[_beneficiary] = deposited[_beneficiary].add(msg.value);\n', '  }\n', '  function close() onlyOwner external {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '  }\n', '  function withdrawFunds(uint256 _amount) onlyOwner external {\n', '     require(state == State.Closed);\n', '     msg.sender.transfer(_amount);\n', '  }\n', '  function enableRefunds() onlyOwner external {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '  function refund(address _beneficiary) external {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[_beneficiary];\n', '    deposited[_beneficiary] = 0;\n', '    emit Refunded(_beneficiary, depositedValue);\n', '    msg.sender.transfer(depositedValue);\n', '  }\n', '}\n', '\n', '// File: contracts/crowdsale/Crowdsale.sol\n', '\n', 'contract Crowdsale is Ownable, Pausable, Whitelisted {\n', '  using SafeMath for uint256;\n', '  MintableToken public token;\n', '  uint256 public minPurchase;\n', '  uint256 public maxPurchase;\n', '  uint256 public investorStartTime;\n', '  uint256 public investorEndTime;\n', '  uint256 public preStartTime;\n', '  uint256 public preEndTime;\n', '  uint256 public ICOstartTime;\n', '  uint256 public ICOEndTime;\n', '  uint256 public preICOBonus;\n', '  uint256 public firstWeekBonus;\n', '  uint256 public secondWeekBonus;\n', '  uint256 public thirdWeekBonus;\n', '  uint256 public forthWeekBonus;\n', '  uint256 public flashSaleStartTime;\n', '  uint256 public flashSaleEndTime;\n', '  uint256 public flashSaleBonus;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  uint256 public weekOne;\n', '  uint256 public weekTwo;\n', '  uint256 public weekThree;\n', '  uint256 public weekForth;\n', '  uint256 public totalSupply = 2500000000E18;\n', '  uint256 public preicoSupply = totalSupply.div(100).mul(30);\n', '  uint256 public icoSupply = totalSupply.div(100).mul(30);\n', '  uint256 public bountySupply = totalSupply.div(100).mul(5);\n', '  uint256 public teamSupply = totalSupply.div(100).mul(20);\n', '  uint256 public reserveSupply = totalSupply.div(100).mul(5);\n', '  uint256 public partnershipsSupply = totalSupply.div(100).mul(10);\n', '  uint256 public publicSupply = preicoSupply.add(icoSupply);\n', '  uint256 public teamTimeLock;\n', '  uint256 public partnershipsTimeLock;\n', '  uint256 public reserveTimeLock;\n', '  uint256 public cap;\n', '  bool public checkBurnTokens;\n', '  bool public upgradeICOSupply;\n', '\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  RefundVault public vault;\n', '  constructor(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap) public {\n', '    require(_startTime >= now);\n', '    require(_endTime >= _startTime);\n', '    require(_rate > 0);\n', '    require(_cap > 0);\n', '    cap = _cap;\n', '    token = createTokenContract();\n', '    investorStartTime = 0;\n', '    investorEndTime = 0;\n', '    preStartTime = _startTime;\n', '    preEndTime = preStartTime + 10 days;\n', '    ICOstartTime = preEndTime + 5 minutes;\n', '    ICOEndTime = _endTime;\n', '    rate = _rate;\n', '    preICOBonus = rate.mul(35).div(100);\n', '    firstWeekBonus = rate.mul(18).div(100);\n', '    secondWeekBonus = rate.mul(15).div(100);\n', '    thirdWeekBonus = rate.mul(10).div(100);\n', '    forthWeekBonus = rate.mul(5).div(100);\n', '    weekOne = ICOstartTime.add(6 days);\n', '    weekTwo = weekOne.add(6 days);\n', '    weekThree = weekTwo.add(6 days);\n', '    weekForth = weekThree.add(6 days);\n', '    teamTimeLock = ICOEndTime.add(180 days);\n', '    reserveTimeLock = ICOEndTime.add(180 days);\n', '    partnershipsTimeLock = preStartTime.add(3 minutes);\n', '    flashSaleStartTime = 0;\n', '    flashSaleEndTime = 0;\n', '    flashSaleBonus = 0;\n', '    checkBurnTokens = false;\n', '    upgradeICOSupply = false;\n', '    minPurchase = 1 ether;\n', '    maxPurchase = 50 ether;\n', '    vault = new RefundVault();\n', '  }\n', '  function createTokenContract() internal returns (MintableToken) {\n', '    return new MintableToken();\n', '  }\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  function buyTokens(address beneficiary) whenNotPaused onlyWhitelisted public payable {\n', '    require(beneficiary != address(0));\n', '    require(validPurchase());\n', '    uint256 weiAmount = msg.value;\n', '    uint256 accessTime = now;\n', '    uint256 tokens = 0;\n', '\n', '    if((accessTime >= flashSaleStartTime) && (accessTime < flashSaleEndTime))\n', '    {\n', '      tokens = tokens.add(weiAmount.mul(flashSaleBonus));\n', '      tokens = tokens.add(weiAmount.mul(rate));\n', '      icoSupply = icoSupply.sub(tokens);\n', '      publicSupply = publicSupply.sub(tokens);\n', '    }\n', '    else if((accessTime >= investorStartTime) && (accessTime < investorEndTime) && (accessTime < preStartTime))\n', '    {\n', '      tokens = tokens.add(weiAmount.mul(rate));\n', '      icoSupply = icoSupply.sub(tokens);\n', '      publicSupply = publicSupply.sub(tokens);\n', '    }\n', '    else if ((accessTime >= preStartTime) && (accessTime < preEndTime))\n', '    {\n', '      require(preicoSupply > 0);\n', '      tokens = tokens.add(weiAmount.mul(preICOBonus));\n', '      tokens = tokens.add(weiAmount.mul(rate));\n', '      require(preicoSupply >= tokens);\n', '      preicoSupply = preicoSupply.sub(tokens);\n', '      publicSupply = publicSupply.sub(tokens);\n', '    }\n', '    else if ((accessTime >= ICOstartTime) && (accessTime <= ICOEndTime))\n', '    {\n', '      if (!upgradeICOSupply)\n', '      {\n', '        icoSupply = icoSupply.add(preicoSupply);\n', '        upgradeICOSupply = true;\n', '      }\n', '      if (accessTime <= weekOne)\n', '      {\n', '        tokens = tokens.add(weiAmount.mul(firstWeekBonus));\n', '      }\n', '      else if (( accessTime <= weekTwo ) && (accessTime > weekOne))\n', '      {\n', '        tokens = tokens.add(weiAmount.mul(secondWeekBonus));\n', '      }\n', '      else if (( accessTime <= weekThree ) && (accessTime > weekTwo))\n', '      {\n', '        tokens = tokens.add(weiAmount.mul(thirdWeekBonus));\n', '      }\n', '      else if (( accessTime <= weekForth ) && (accessTime > weekThree))\n', '      {\n', '        tokens = tokens.add(weiAmount.mul(forthWeekBonus));\n', '      }\n', '      tokens = tokens.add(weiAmount.mul(rate));\n', '      icoSupply = icoSupply.sub(tokens);\n', '      publicSupply = publicSupply.sub(tokens);\n', '    }\n', '    else {\n', '      revert();\n', '    }\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    vault.deposit.value(weiAmount)(beneficiary);\n', '    token.mint(beneficiary, tokens);\n', '    emit TokenPurchase(beneficiary, beneficiary, weiAmount, tokens);\n', '  }\n', '  function validPurchase() internal returns (bool) {\n', '    require(withinCap(msg.value));\n', '    require(withinRange(msg.value));\n', '    return true;\n', '  }\n', '  function withinRange(uint256 weiAmount) internal view returns (bool) {\n', '    require(weiAmount >= minPurchase);\n', '    require(weiAmount <= maxPurchase);\n', '    return true;\n', '  }\n', '  function withinCap(uint256 weiAmount) internal view returns (bool) {\n', '    require(weiRaised.add(weiAmount) <= cap);\n', '    return true;\n', '  }\n', '  function hasEnded() public view returns (bool) {\n', '    return now > ICOEndTime;\n', '  }\n', '  function hardCapReached() public view returns (bool) {\n', '    return weiRaised >= cap;\n', '  }\n', '  function burnToken() onlyOwner external returns (bool) {\n', '    require(hasEnded());\n', '    require(!checkBurnTokens);\n', '    token.burnTokens(icoSupply);\n', '    totalSupply = totalSupply.sub(publicSupply);\n', '    preicoSupply = 0;\n', '    icoSupply = 0;\n', '    publicSupply = 0;\n', '    checkBurnTokens = true;\n', '    return true;\n', '  }\n', '  function updateDates(uint256 _preStartTime,uint256 _preEndTime,uint256 _ICOstartTime,uint256 _ICOEndTime) onlyOwner external {\n', '    require(_preEndTime > _preStartTime);\n', '    require(_ICOstartTime > _preEndTime);\n', '    require(_ICOEndTime > _ICOstartTime);\n', '    preEndTime = _preEndTime;\n', '    preStartTime = _preStartTime;\n', '    ICOstartTime = _ICOstartTime;\n', '    ICOEndTime = _ICOEndTime;\n', '    weekOne = ICOstartTime.add(6 days);\n', '    weekTwo = weekOne.add(6 days);\n', '    weekThree = weekTwo.add(6 days);\n', '    weekForth = weekThree.add(6 days);\n', '    teamTimeLock = ICOEndTime.add(180 days);\n', '    reserveTimeLock = ICOEndTime.add(180 days);\n', '    partnershipsTimeLock = preStartTime.add(3 minutes);\n', '  }\n', '  function flashSale(uint256 _flashSaleStartTime, uint256 _flashSaleEndTime, uint256 _flashSaleBonus) onlyOwner external {\n', '    flashSaleStartTime = _flashSaleStartTime;\n', '    flashSaleEndTime = _flashSaleEndTime;\n', '    flashSaleBonus = _flashSaleBonus;\n', '  }\n', '  function updateInvestorDates(uint256 _investorStartTime, uint256 _investorEndTime) onlyOwner external {\n', '    investorStartTime = _investorStartTime;\n', '    investorEndTime = _investorEndTime;\n', '  }\n', '  function updateMinMaxInvestment(uint256 _minPurchase, uint256 _maxPurchase) onlyOwner external {\n', '    require(_maxPurchase > _minPurchase);\n', '    require(_minPurchase > 0);\n', '    minPurchase = _minPurchase;\n', '    maxPurchase = _maxPurchase;\n', '  }\n', '  function transferFunds(address[] calldata recipients, uint256[] calldata values) onlyOwner external {\n', '    require(!checkBurnTokens);\n', '    for (uint256 i = 0; i < recipients.length; i++) {\n', '      if (publicSupply >= values[i]) {\n', '        publicSupply = publicSupply.sub(values[i]);\n', '        token.mint(recipients[i], values[i]);\n', '      }\n', '    }\n', '  }\n', '  function acceptEther() onlyOwner external payable {\n', '    weiRaised = weiRaised.add(msg.value.div(rate));\n', '  }\n', '  function bountyFunds(address[] calldata recipients, uint256[] calldata values) onlyOwner external {\n', '    require(!checkBurnTokens);\n', '    for (uint256 i = 0; i < recipients.length; i++) {\n', '      if (bountySupply >= values[i]) {\n', '        bountySupply = bountySupply.sub(values[i]);\n', '        token.mint(recipients[i], values[i]);\n', '      }\n', '    }\n', '  }\n', '  function transferPartnershipsTokens(address[] calldata recipients, uint256[] calldata values) onlyOwner external {\n', '    require(!checkBurnTokens);\n', '    require((reserveTimeLock < now));\n', '    for (uint256 i = 0; i < recipients.length; i++) {\n', '      if (partnershipsSupply >= values[i]) {\n', '        partnershipsSupply = partnershipsSupply.sub(values[i]);\n', '        token.mint(recipients[i], values[i]);\n', '      }\n', '    }\n', '  }\n', '  function transferReserveTokens(address[] calldata recipients, uint256[] calldata values) onlyOwner external {\n', '    require(!checkBurnTokens);\n', '    require((reserveTimeLock < now));\n', '    for (uint256 i = 0; i < recipients.length; i++) {\n', '      if (reserveSupply >= values[i]) {\n', '        reserveSupply = reserveSupply.sub(values[i]);\n', '        token.mint(recipients[i], values[i]);\n', '      }\n', '    }\n', '  }\n', '  function transferTeamTokens(address[] calldata recipients, uint256[] calldata values) onlyOwner external {\n', '    require(!checkBurnTokens);\n', '    require((now > teamTimeLock));\n', '    for (uint256 i = 0; i < recipients.length; i++) {\n', '      if (teamSupply >= values[i]) {\n', '        teamSupply = teamSupply.sub(values[i]);\n', '        token.mint(recipients[i], values[i]);\n', '      }\n', '    }\n', '  }\n', '  function getTokenAddress() onlyOwner external view returns (address) {\n', '    return address(token);\n', '  }\n', '}\n', '\n', '// File: contracts/crowdsale/RefundableCrowdsale.sol\n', '\n', 'contract RefundableCrowdsale is Crowdsale {\n', '  uint256 public goal;\n', '  bool public isFinalized;\n', '  event Finalized();\n', '\n', '  function finalizeCrowdsale() onlyOwner external {\n', '    require(!isFinalized);\n', '\n', '    if (goalReached()) {  \n', '      vault.close();\n', '    } else {\n', '      vault.enableRefunds();\n', '    }\n', '\n', '    isFinalized = true;\n', '    emit Finalized();\n', '  }\n', '\n', '  constructor(uint256 _goal) public {\n', '    require(_goal > 0);\n', '    isFinalized = false;\n', '    goal = _goal;\n', '  }\n', '\n', '  function openVaultForWithdrawal() onlyOwner external {\n', '    require(isFinalized);\n', '    require(goalReached());\n', '    vault.transferOwnership(msg.sender);\n', '  }\n', '  function claimRefund(address _beneficiary) public {\n', '    require(isFinalized);\n', '    require(!goalReached());\n', '    vault.refund(_beneficiary);\n', '  }\n', '  function goalReached() public view returns (bool) {\n', '    return weiRaised >= goal;\n', '  }\n', '  function getVaultAddress() onlyOwner external view returns (RefundVault) {\n', '    return vault;\n', '  }\n', '}\n', '\n', '// File: contracts/Dayta.sol\n', '\n', 'contract Dayta is MintableToken {\n', '  string public constant name = "DAYTA";\n', '  string public constant symbol = "DAYTA";\n', '  uint8 public constant decimals = 18;\n', '  uint256 public _totalSupply = 2500000000E18;\n', '  constructor() public {\n', '    totalSupply = _totalSupply;\n', '  }\n', '}\n', '\n', '// File: contracts\\DaytaCrowdsale.sol\n', '\n', 'contract DaytaCrowdsale is Crowdsale, RefundableCrowdsale {\n', '    constructor(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _goal) public\n', '    RefundableCrowdsale(_goal)\n', '    Crowdsale(_startTime, _endTime, _rate, _cap)\n', '    {\n', '    }\n', '    function createTokenContract() internal returns (MintableToken) {\n', '        return new Dayta();\n', '    }\n', '}']