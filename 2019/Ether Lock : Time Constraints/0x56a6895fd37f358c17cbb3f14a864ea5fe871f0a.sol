['pragma solidity 0.4.25;\n', '\n', '\n', 'interface IOrbsValidatorsRegistry {\n', '\n', '    event ValidatorLeft(address indexed validator);\n', '    event ValidatorRegistered(address indexed validator);\n', '    event ValidatorUpdated(address indexed validator);\n', '\n', '    /// @dev register a validator and provide registration data.\n', '    /// the new validator entry will be owned and identified by msg.sender.\n', '    /// if msg.sender is already registered as a validator in this registry the\n', '    /// transaction will fail.\n', '    /// @param name string The name of the validator\n', '    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\n', '    /// @param website string The website of the validator\n', '    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\n', '    function register(\n', '        string name,\n', '        bytes4 ipAddress,\n', '        string website,\n', '        bytes20 orbsAddress\n', '    )\n', '        external;\n', '\n', '    /// @dev update the validator registration data entry associated with msg.sender.\n', '    /// msg.sender must be registered in this registry contract.\n', '    /// @param name string The name of the validator\n', '    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\n', '    /// @param website string The website of the validator\n', '    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\n', '    function update(\n', '        string name,\n', '        bytes4 ipAddress,\n', '        string website,\n', '        bytes20 orbsAddress\n', '    )\n', '        external;\n', '\n', '    /// @dev deletes a validator registration entry associated with msg.sender.\n', '    function leave() external;\n', '\n', '    /// @dev returns validator registration data.\n', '    /// @param validator address address of the validator.\n', '    function getValidatorData(address validator)\n', '        external\n', '        view\n', '        returns (\n', '            string name,\n', '            bytes4 ipAddress,\n', '            string website,\n', '            bytes20 orbsAddress\n', '        );\n', '\n', '    /// @dev returns the blocks in which a validator was registered and last updated.\n', '    /// if validator does not designate a registered validator this method returns zero values.\n', '    /// @param validator address of a validator\n', '    function getRegistrationBlockNumber(address validator)\n', '        external\n', '        view\n', '        returns (uint registeredOn, uint lastUpdatedOn);\n', '\n', '    /// @dev Checks if validator is currently registered as a validator.\n', '    /// @param validator address address of the validator\n', '    /// @return true iff validator belongs to a registered validator\n', '    function isValidator(address validator) external view returns (bool);\n', '\n', '    /// @dev returns the orbs node public address of a specific validator.\n', '    /// @param validator address address of the validator\n', '    /// @return an Orbs node address\n', '    function getOrbsAddress(address validator)\n', '        external\n', '        view\n', '        returns (bytes20 orbsAddress);\n', '}\n', '\n', '\n', '/// @title Orbs Validators Registry smart contract.\n', 'contract OrbsValidatorsRegistry is IOrbsValidatorsRegistry {\n', '\n', '    // The validator registration data object.\n', '    struct ValidatorData {\n', '        string name;\n', '        bytes4 ipAddress;\n', '        string website;\n', '        bytes20 orbsAddress;\n', '        uint registeredOnBlock;\n', '        uint lastUpdatedOnBlock;\n', '    }\n', '\n', '    // The version of the current validators data registration smart contract.\n', '    uint public constant VERSION = 1;\n', '\n', "    // A mapping from validator's Ethereum address to registration data.\n", '    mapping(address => ValidatorData) internal validatorsData;\n', '\n', '    // Lookups for IP Address & Orbs Address for uniqueness checks. Useful also be used for as a public lookup index.\n', '    mapping(bytes4 => address) public lookupByIp;\n', '    mapping(bytes20 => address) public lookupByOrbsAddr;\n', '\n', '    /// @dev check that the caller is a validator.\n', '    modifier onlyValidator() {\n', '        require(isValidator(msg.sender), "You must be a registered validator");\n', '        _;\n', '    }\n', '\n', '    /// @dev register a validator and provide registration data.\n', '    /// the new validator entry will be owned and identified by msg.sender.\n', '    /// if msg.sender is already registered as a validator in this registry the\n', '    /// transaction will fail.\n', '    /// @param name string The name of the validator\n', '    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\n', '    /// @param website string The website of the validator\n', '    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\n', '    function register(\n', '        string name,\n', '        bytes4 ipAddress,\n', '        string website,\n', '        bytes20 orbsAddress\n', '    )\n', '        external\n', '    {\n', '        address sender = msg.sender;\n', '        require(bytes(name).length > 0, "Please provide a valid name");\n', '        require(bytes(website).length > 0, "Please provide a valid website");\n', '        require(!isValidator(sender), "Validator already exists");\n', '        require(ipAddress != bytes4(0), "Please pass a valid ip address represented as an array of exactly 4 bytes");\n', '        require(orbsAddress != bytes20(0), "Please provide a valid Orbs Address");\n', '        require(lookupByIp[ipAddress] == address(0), "IP address already in use");\n', '        require(lookupByOrbsAddr[orbsAddress] == address(0), "Orbs Address is already in use by another validator");\n', '\n', '        lookupByIp[ipAddress] = sender;\n', '        lookupByOrbsAddr[orbsAddress] = sender;\n', '\n', '        validatorsData[sender] = ValidatorData({\n', '            name: name,\n', '            ipAddress: ipAddress,\n', '            website: website,\n', '            orbsAddress: orbsAddress,\n', '            registeredOnBlock: block.number,\n', '            lastUpdatedOnBlock: block.number\n', '        });\n', '\n', '        emit ValidatorRegistered(sender);\n', '    }\n', '\n', '    /// @dev update the validator registration data entry associated with msg.sender.\n', '    /// msg.sender must be registered in this registry contract.\n', '    /// @param name string The name of the validator\n', '    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\n', '    /// @param website string The website of the validator\n', '    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\n', '    function update(\n', '        string name,\n', '        bytes4 ipAddress,\n', '        string website,\n', '        bytes20 orbsAddress\n', '    )\n', '        external\n', '        onlyValidator\n', '    {\n', '        address sender = msg.sender;\n', '        require(bytes(name).length > 0, "Please provide a valid name");\n', '        require(bytes(website).length > 0, "Please provide a valid website");\n', '        require(ipAddress != bytes4(0), "Please pass a valid ip address represented as an array of exactly 4 bytes");\n', '        require(orbsAddress != bytes20(0), "Please provide a valid Orbs Address");\n', '        require(isIpFreeToUse(ipAddress), "IP Address is already in use by another validator");\n', '        require(isOrbsAddressFreeToUse(orbsAddress), "Orbs Address is already in use by another validator");\n', '\n', '        ValidatorData storage data = validatorsData[sender];\n', '\n', '        // Remove previous key from lookup.\n', '        delete lookupByIp[data.ipAddress];\n', '        delete lookupByOrbsAddr[data.orbsAddress];\n', '\n', '        // Set new keys in lookup.\n', '        lookupByIp[ipAddress] = sender;\n', '        lookupByOrbsAddr[orbsAddress] = sender;\n', '\n', '        data.name = name;\n', '        data.ipAddress = ipAddress;\n', '        data.website = website;\n', '        data.orbsAddress = orbsAddress;\n', '        data.lastUpdatedOnBlock = block.number;\n', '\n', '        emit ValidatorUpdated(sender);\n', '    }\n', '\n', '    /// @dev deletes a validator registration entry associated with msg.sender.\n', '    function leave() external onlyValidator {\n', '        address sender = msg.sender;\n', '\n', '        ValidatorData storage data = validatorsData[sender];\n', '\n', '        delete lookupByIp[data.ipAddress];\n', '        delete lookupByOrbsAddr[data.orbsAddress];\n', '\n', '        delete validatorsData[sender];\n', '\n', '        emit ValidatorLeft(sender);\n', '    }\n', '\n', '    /// @dev returns the blocks in which a validator was registered and last updated.\n', '    /// if validator does not designate a registered validator this method returns zero values.\n', '    /// @param validator address of a validator\n', '    function getRegistrationBlockNumber(address validator)\n', '        external\n', '        view\n', '        returns (uint registeredOn, uint lastUpdatedOn)\n', '    {\n', '        require(isValidator(validator), "Unlisted Validator");\n', '\n', '        ValidatorData storage entry = validatorsData[validator];\n', '        registeredOn = entry.registeredOnBlock;\n', '        lastUpdatedOn = entry.lastUpdatedOnBlock;\n', '    }\n', '\n', '    /// @dev returns the orbs node public address of a specific validator.\n', '    /// @param validator address address of the validator\n', '    /// @return an Orbs node address\n', '    function getOrbsAddress(address validator)\n', '        external\n', '        view\n', '        returns (bytes20)\n', '    {\n', '        return validatorsData[validator].orbsAddress;\n', '    }\n', '\n', '    /// @dev returns validator registration data.\n', '    /// @param validator address address of the validator.\n', '    function getValidatorData(address validator)\n', '        public\n', '        view\n', '        returns (\n', '            string memory name,\n', '            bytes4 ipAddress,\n', '            string memory website,\n', '            bytes20 orbsAddress\n', '        )\n', '    {\n', '        ValidatorData storage entry = validatorsData[validator];\n', '        name = entry.name;\n', '        ipAddress = entry.ipAddress;\n', '        website = entry.website;\n', '        orbsAddress = entry.orbsAddress;\n', '    }\n', '\n', '    /// @dev Checks if validator is currently registered as a validator.\n', '    /// @param validator address address of the validator\n', '    /// @return true iff validator belongs to a registered validator\n', '    function isValidator(address validator) public view returns (bool) {\n', '        return validatorsData[validator].registeredOnBlock > 0;\n', '    }\n', '\n', '    /// @dev INTERNAL. Checks if ipAddress is currently available to msg.sender.\n', '    /// @param ipAddress bytes4 ip address to check for uniqueness\n', '    /// @return true iff ipAddress is currently not registered for any validator other than msg.sender.\n', '    function isIpFreeToUse(bytes4 ipAddress) internal view returns (bool) {\n', '        return\n', '            lookupByIp[ipAddress] == address(0) ||\n', '            lookupByIp[ipAddress] == msg.sender;\n', '    }\n', '\n', '    /// @dev INTERNAL. Checks if orbsAddress is currently available to msg.sender.\n', '    /// @param orbsAddress bytes20 ip address to check for uniqueness\n', '    /// @return true iff orbsAddress is currently not registered for a validator other than msg.sender.\n', '    function isOrbsAddressFreeToUse(bytes20 orbsAddress)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return\n', '            lookupByOrbsAddr[orbsAddress] == address(0) ||\n', '            lookupByOrbsAddr[orbsAddress] == msg.sender;\n', '    }\n', '}']