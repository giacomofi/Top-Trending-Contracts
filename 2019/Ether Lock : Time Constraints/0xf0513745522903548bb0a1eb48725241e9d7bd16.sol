['pragma solidity >0.4.99 <0.6.0;\n', '\n', 'interface token {\n', '    function balanceOf(address _owner) external returns (uint balance);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function transferFrom(address _from, address _to, uint256 _value) external;\n', '}\n', '\n', 'contract RewardAirdrop {\n', '    address public owner = msg.sender;\n', '    address tokenAddress = 0x46706C5e5B7dF0Afd54a7248F1E5788275B7FaC6;\n', '    token public tokenReward = token(tokenAddress);\n', '\n', '    address usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '\n', '    token public stableCoinReward = token(usdcAddress);\n', '\n', '    uint public stableCoinPrice = 10 ** 16;\n', '    uint public totalRewardBalance = 0;\n', '\n', '    // keeps track of rewards given\n', '    mapping (bytes32 => bool) public airdrops;\n', '    mapping(address => uint256) public rewardBalanceOf;\n', '\n', '    modifier onlyOwner() {require(msg.sender == owner); _;}\n', '\n', '    function() payable external {}\n', '\n', '    function airdropTokens(bytes32 _channelId, address[] memory _recipients, uint tokenAmount, uint weiAmount) public onlyOwner {\n', '        for(uint i = 0; i < _recipients.length; i++)\n', '        {\n', '            bytes32 channelHash = keccak256(\n', '                abi.encodePacked(_channelId, _recipients[i])\n', '            );\n', '\n', '            address payable currentRecipient = address(uint160(_recipients[i]));\n', '            \n', '            if (!airdrops[channelHash]) {\n', '                airdrops[channelHash] = true;\n', '                rewardBalanceOf[currentRecipient] += tokenAmount;\n', '                totalRewardBalance += tokenAmount;\n', '                tokenReward.transfer(currentRecipient, tokenAmount);\n', '                currentRecipient.transfer(weiAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function sendStableReward(address _from, address _destination, uint _tokenAmount, uint _stableCoinAmount) public onlyOwner{\n', '        require(rewardBalanceOf[_from]>= _tokenAmount);\n', '        tokenReward.transferFrom(_from, address(this), _tokenAmount);\n', '        rewardBalanceOf[_from] -= _tokenAmount;\n', '        totalRewardBalance -= _tokenAmount;\n', '        stableCoinReward.transfer(_destination, _stableCoinAmount);\n', '    }\n', '\n', '    function changeDollarPrice(uint _newPrice) public onlyOwner {\n', '        stableCoinPrice = _newPrice;\n', '    }\n', '\n', '    function withdraw(uint _weiAmount)\n', '      onlyOwner\n', '      public\n', '    {\n', '        address payable wallet = address(uint160(owner));\n', '\n', '        wallet.transfer(_weiAmount);\n', '    }\n', '\n', '    function withdrawTokens(uint _tokenAmount) onlyOwner public {\n', '\n', '        tokenReward.transfer(owner, _tokenAmount);\n', '    }\n', '\n', '     function withdrawAllEther()\n', '      onlyOwner\n', '      public\n', '    {\n', '        address payable wallet = address(uint160(owner));\n', '        address contractAddress = address(this);\n', '        wallet.transfer(contractAddress.balance);\n', '    }\n', '\n', '    function withdrawAllTokens() onlyOwner public {\n', '        uint tokenBalance = tokenReward.balanceOf(address(this));\n', '\n', '        tokenReward.transfer(owner, tokenBalance);\n', '    }\n', '\n', '    function destroy() onlyOwner public {\n', '        selfdestruct(address(this));\n', '    }\n', '}']