['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="701719121d190215191e1219150230171d11191c5e131f1d">[email&#160;protected]</a>\n', '*/\n', '\n', 'interface F2mInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // one time called\n', '    function disableRound0() public;\n', '    function activeBuy() public;\n', '    // Dividends from all sources (DApps, Donate ...)\n', '    function pushDividends() public payable;\n', '    /**\n', '     * Converts all of caller&#39;s dividends to tokens.\n', '     */\n', '    //function reinvest() public;\n', '    //function buy() public payable;\n', '    function buyFor(address _buyer) public payable;\n', '    function sell(uint256 _tokenAmount) public;\n', '    function exit() public;\n', '    function devTeamWithdraw() public returns(uint256);\n', '    function withdrawFor(address sender) public returns(uint256);\n', '    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function setAutoBuy() public;\n', '    /*==========================================\n', '    =            public FUNCTIONS            =\n', '    ==========================================*/\n', '    // function totalEthBalance() public view returns(uint256);\n', '    function ethBalance(address _address) public view returns(uint256);\n', '    function myBalance() public view returns(uint256);\n', '    function myEthBalance() public view returns(uint256);\n', '\n', '    function swapToken() public;\n', '    function setNewToken(address _newTokenAddress) public;\n', '}\n', '\n', 'interface CitizenInterface {\n', ' \n', '    function joinNetwork(address[6] _contract) public;\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function devTeamWithdraw() public;\n', '\n', '    /*----------  WRITE FUNCTIONS  ----------*/\n', '    function updateUsername(string _sNewUsername) public;\n', '    //Sources: Token contract, DApps\n', '    function pushRefIncome(address _sender) public payable;\n', '    function withdrawFor(address _sender) public payable returns(uint256);\n', '    function devTeamReinvest() public returns(uint256);\n', '\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getRefWallet(address _address) public view returns(uint256);\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'interface BankInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // Core functions\n', '    function pushToBank(address _player) public payable;\n', '}\n', '\n', 'interface RewardInterface {\n', '\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        public;\n', '        \n', '    function joinNetwork(address[6] _contract) public;\n', '    function pushBounty(uint256 _curRoundId) public payable;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Helper {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public SDIVIDER = 3450000;\n', '    uint256 constant public PDIVIDER = 3450000;\n', '    uint256 constant public RDIVIDER = 1580000;\n', '    // Starting LS price (SLP)\n', '    uint256 constant public SLP = 0.002 ether;\n', '    // Starting Added Time (SAT)\n', '    uint256 constant public SAT = 30; // seconds\n', '    // Price normalization (PN)\n', '    uint256 constant public PN = 777;\n', '    // EarlyIncome base\n', '    uint256 constant public PBASE = 13;\n', '    uint256 constant public PMULTI = 26;\n', '    uint256 constant public LBase = 15;\n', '\n', '    uint256 constant public ONE_HOUR = 3600;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    \n', '    function bytes32ToString (bytes32 data)\n', '        public\n', '        pure\n', '        returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(32);\n', '        for (uint j=0; j<32; j++) {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[j] = char;\n', '            }\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    \n', '    function uintToBytes32(uint256 n)\n', '        public\n', '        pure\n', '        returns (bytes32) \n', '    {\n', '        return bytes32(n);\n', '    }\n', '    \n', '    function bytes32ToUint(bytes32 n) \n', '        public\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        return uint256(n);\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) \n', '        public\n', '        pure\n', '        returns (bytes32 result) \n', '    {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    \n', '    function stringToUint(string memory source) \n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return bytes32ToUint(stringToBytes32(source));\n', '    }\n', '    \n', '    function uintToString(uint256 _uint) \n', '        public\n', '        pure\n', '        returns (string)\n', '    {\n', '        return bytes32ToString(uintToBytes32(_uint));\n', '    }\n', '\n', '/*     \n', '    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\n', '        bytes memory a = new bytes(end-begin+1);\n', '        for(uint i = 0; i <= end - begin; i++){\n', '            a[i] = bytes(text)[i + begin - 1];\n', '        }\n', '        return string(a);    \n', '    }\n', ' */\n', '    function validUsername(string _username)\n', '        public\n', '        pure\n', '        returns(bool)\n', '    {\n', '        uint256 len = bytes(_username).length;\n', '        // Im Raum [4, 18]\n', '        if ((len < 4) || (len > 18)) return false;\n', '        // Letzte Char != &#39; &#39;\n', '        if (bytes(_username)[len-1] == 32) return false;\n', '        // Erste Char != &#39;0&#39;\n', '        return uint256(bytes(_username)[0]) != 48;\n', '    }\n', '\n', '    // Lottery Helper\n', '\n', '    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\n', '    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        //Luppe = 10000 = 10^4\n', '        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        // div 10000^6\n', '        expo = expo / (10**24);\n', '\n', '        if (expo > SAT) return 0;\n', '        return (SAT - expo).mul(_tAmount);\n', '    }\n', '\n', '    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\n', '        uint256 timeout = _slideEndTime.sub(block.timestamp);\n', '        // timeout capped at TIMEOUT1\n', '        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\n', '        _slideEndTime = (block.timestamp).add(timeout);\n', '        // Capped at fixedEndTime\n', '        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\n', '        return _slideEndTime;\n', '    }\n', '\n', '    // get random in range [1, _range] with _seed\n', '    function getRandom(uint256 _seed, uint256 _range)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        if (_range == 0) return _seed;\n', '        return (_seed % _range) + 1;\n', '    }\n', '\n', '\n', '    function getEarlyIncomeMul(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\n', '        uint256 base = _ticketSum * ZOOM / RDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base); //^3\n', '        expo = expo.mul(expo) / (ZOOM**6); //^6\n', '        return (1 + PBASE / (1 + expo.mul(PMULTI)));\n', '    }\n', '\n', '    // get reveiced Tickets, based on current round ticketSum\n', '    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tPrice = getTPrice(_ticketSum);\n', '        return _ethAmount.div(_tPrice);\n', '    }\n', '\n', '    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\n', '    function getTMul(uint256 _ticketSum) // Unit Wei\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = _ticketSum * ZOOM / PDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base);\n', '        expo = expo.mul(expo); // ^6\n', '        return 1 + expo.mul(LBase) / (10**18);\n', '    }\n', '\n', '    // get ticket price, based on current round ticketSum\n', '    //unit in ETH, no need / zoom^6\n', '    function getTPrice(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        uint256 tPrice = SLP + expo / PN;\n', '        return tPrice;\n', '    }\n', '\n', '    // get weight of slot, chance to win grandPot\n', '    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = getTMul(_ticketSum);\n', '        return (_tAmount).mul(_tMul);\n', '    }\n', '\n', '    // used to draw grandpot results\n', '    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\n', '    // grandPot = initGrandPot + round investedSum(for grandPot)\n', '    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        //calculate round grandPot-investedSum\n', '        uint256 grandPotInvest = grandPot - initGrandPot;\n', '        if (grandPotInvest == 0) return 8;\n', '        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\n', '        uint256 weightRange = zoomMul * curRWeight / ZOOM;\n', '        if (weightRange < curRWeight) weightRange = curRWeight;\n', '        return weightRange;\n', '    }\n', '}\n', '\n', 'contract Lottery {\n', '    using SafeMath for uint256;\n', '\n', '    modifier withdrawRight(){\n', '        require(msg.sender == address(bankContract), "Bank only");\n', '        _;\n', '    }\n', '\n', '    modifier onlyDevTeam() {\n', '        require(msg.sender == devTeam, "only for development team");\n', '        _;\n', '    }\n', '\n', '    modifier buyable() {\n', '        require(block.timestamp > round[curRoundId].startTime, "not ready to sell Ticket");\n', '        require(block.timestamp < round[curRoundId].slideEndTime, "round over");\n', '        _;\n', '    }\n', '\n', '    enum RewardType {\n', '        Minor,\n', '        Major,\n', '        Grand,\n', '        Bounty\n', '    }\n', '\n', '    // 1 buy = 1 slot = _ethAmount => (tAmount, tMul) \n', '    struct Slot {\n', '        address buyer;\n', '        uint256 rId;\n', '        // ticket numbers in range and unique in all rounds\n', '        uint256 tNumberFrom;\n', '        uint256 tNumberTo;\n', '        // weight to, used for grandPot finalize\n', '        uint256 wTo;\n', '        uint256 ethAmount;\n', '        uint256 salt;\n', '    }\n', '\n', '    struct Round {\n', '        // earlyIncome weight sum\n', '        uint256 rEarlyIncomeWeight;\n', '        // blockNumber to get hash as random seed\n', '        uint256 keyBlockNr;\n', '        \n', '        mapping(address => uint256) pTicketSum;\n', '        mapping(address => uint256) pInvestedSum;\n', '\n', '        // early income weight by address\n', '        mapping(address => uint256) pEarlyIncomeWeight;\n', '        mapping(address => uint256) pEarlyIncomeCredit;\n', '        mapping(address => uint256) pEarlyIncomeClaimed;\n', '        // early income per weight\n', '        uint256 ppw;\n', '        // endTime increased every slot sold\n', '        // endTime limited by fixedEndTime\n', '        uint256 startTime;\n', '        uint256 slideEndTime;\n', '        uint256 fixedEndTime;\n', '\n', '        // ticketSum from round 1 to this round\n', '        uint256 ticketSum;\n', '        // investedSum from round 1 to this round\n', '        uint256 investedSum;\n', '        // number of slots from round 1 to this round\n', '        uint256 slotSum;\n', '    }\n', '\n', '    // round started with this grandPot amount,\n', '    // used to calculate the rate for grandPot results\n', '    // init in roundInit function\n', '    uint256 initGrandPot;\n', '\n', '    Slot[] slot;\n', '    // slotId logs by address\n', '    mapping( address => uint256[]) pSlot;\n', '    mapping( address => uint256) public pSlotSum;\n', '\n', '    // logs by address\n', '    mapping( address => uint256) public pTicketSum;\n', '    mapping( address => uint256) public pInvestedSum;\n', '\n', '    CitizenInterface public citizenContract;\n', '    F2mInterface public f2mContract;\n', '    BankInterface public bankContract;\n', '    RewardInterface public rewardContract;\n', '\n', '    address public devTeam;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public ONE_HOUR = 60 * 60;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\n', '    uint256 constant public FINALIZE_WAIT_DURATION = 60; // 60 Seconds\n', '    uint256 constant public NEWROUND_WAIT_DURATION = ONE_DAY; // 24 Hours\n', '\n', '    // 15 seconds on Ethereum, 12 seconds used instead to make sure blockHash unavaiable\n', '    // when slideEndTime reached\n', '    // keyBlockNumber will be estimated again after every slot buy\n', '    uint256 constant public BLOCK_TIME = 12;\n', '    uint256 constant public MAX_BLOCK_DISTANCE = 254;\n', '\n', '    uint256 constant public MAJOR_RATE = 1000;\n', '    uint256 constant public MINOR_RATE = 1000;\n', '    uint256 constant public MAJOR_MIN = 0.1 ether ;\n', '    uint256 constant public MINOR_MIN = 0.1 ether ;\n', '\n', '    //uint256 public toNextPotPercent = 27;\n', '    uint256 public grandRewardPercent = 20;\n', '    uint256 public jRewardPercent = 60;\n', '\n', '    uint256 public toTokenPercent = 12; // 10% dividends 2% fund\n', '    uint256 public toBuyTokenPercent = 1;\n', '    uint256 public earlyIncomePercent = 22;\n', '    uint256 public toRefPercent = 15;\n', '\n', '    // sum == 100% = toPotPercent/100 * investedSum\n', '    // uint256 public grandPercent = 68;\n', '    uint256 public majorPercent = 24;\n', '    uint256 public minorPercent = 8;\n', '\n', '    uint256 public grandPot;\n', '    uint256 public majorPot;\n', '    uint256 public minorPot;\n', '\n', '    uint256 public curRoundId;\n', '    uint256 public lastRoundId = 88888888;\n', '\n', '    uint256 constant public startPrice = 0.002 ether;\n', '\n', '    mapping (address => uint256) public rewardBalance;\n', '    // used to save gas on earlyIncome calculating, curRoundId never included\n', '    // only earlyIncome from round 1st to curRoundId-1 are fixed\n', '    mapping (address => uint256) public lastWithdrawnRound;\n', '    mapping (address => uint256) public earlyIncomeScannedSum;\n', '\n', '    mapping (uint256 => Round) public round;\n', '\n', '    // Current Round\n', '\n', '    // first SlotId in last Block to fire jackpot\n', '    uint256 public jSlot;\n', '    // jackpot results of all slots in same block will be drawed at the same time,\n', '    // by player, who buys the first slot in next block\n', '    uint256 public lastBlockNr;\n', '    // used to calculate grandPot results\n', '    uint256 public curRWeight;\n', '    // added by slot salt after every slot buy\n', '    // does not matter with overflow\n', '    uint256 public curRSalt;\n', '    // ticket sum of current round\n', '    uint256 public curRTicketSum;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // register address in network\n', '        DevTeamInterface(_devTeam).setLotteryAddress(address(this));\n', '        devTeam = _devTeam;\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require(address(citizenContract) == 0x0,"already setup");\n', '        f2mContract = F2mInterface(_contract[0]);\n', '        bankContract = BankInterface(_contract[1]);\n', '        citizenContract = CitizenInterface(_contract[2]);\n', '        //lotteryContract = LotteryInterface(lotteryAddress);\n', '        rewardContract = RewardInterface(_contract[4]);\n', '    }\n', '\n', '    function activeFirstRound()\n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(curRoundId == 0, "already activated");\n', '        initRound();\n', '    }\n', '\n', '    // Core Functions\n', '\n', '    function pushToPot() \n', '        public \n', '        payable\n', '    {\n', '        addPot(msg.value);\n', '    }\n', '\n', '    function checkpoint() \n', '        private\n', '    {\n', '        // dummy slot between every 2 rounds\n', '        // dummy slot never win jackpot cause of min 0.1 ETH\n', '        Slot memory _slot;\n', '        _slot.tNumberTo = round[curRoundId].ticketSum;\n', '        slot.push(_slot);\n', '\n', '        Round memory _round;\n', '        _round.startTime = NEWROUND_WAIT_DURATION.add(block.timestamp);\n', '        // started with 3 hours timeout\n', '        _round.slideEndTime = TIMEOUT0 + _round.startTime;\n', '        _round.fixedEndTime = TIMEOUT2 + _round.startTime;\n', '        _round.keyBlockNr = genEstKeyBlockNr(_round.slideEndTime);\n', '        _round.ticketSum = round[curRoundId].ticketSum;\n', '        _round.investedSum = round[curRoundId].investedSum;\n', '        _round.slotSum = slot.length;\n', '\n', '        curRoundId = curRoundId + 1;\n', '        round[curRoundId] = _round;\n', '\n', '        initGrandPot = grandPot;\n', '        curRWeight = 0;\n', '        curRTicketSum = 0;\n', '    }\n', '\n', '    // from round 18+ function\n', '    function isLastRound()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return (curRoundId == lastRoundId);\n', '    }\n', '\n', '    function goNext()\n', '        private\n', '    {\n', '        uint256 _totalPot = getTotalPot();\n', '        grandPot = 0;\n', '        majorPot = 0;\n', '        minorPot = 0;\n', '        f2mContract.pushDividends.value(_totalPot)();\n', '        // never start\n', '        round[curRoundId].startTime = block.timestamp * 10;\n', '        round[curRoundId].slideEndTime = block.timestamp * 10 + 1;\n', '    }\n', '\n', '    function initRound()\n', '        private\n', '    {\n', '        // update all Round Log\n', '        checkpoint();\n', '        if (isLastRound()) goNext();\n', '    }\n', '\n', '    function finalizeable() \n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        uint256 finalizeTime = FINALIZE_WAIT_DURATION.add(round[curRoundId].slideEndTime);\n', '        if (finalizeTime > block.timestamp) return false; // too soon to finalize\n', '        if (getEstKeyBlockNr(curRoundId) >= block.number) return false; //block hash not exist\n', '        return curRoundId > 0;\n', '    }\n', '\n', '    // bounty\n', '    function finalize()\n', '        public\n', '    {\n', '        require(finalizeable(), "Not ready to draw results");\n', '        // avoid txs blocked => curRTicket ==0 => die\n', '        require((round[curRoundId].pTicketSum[msg.sender] > 0) || (curRTicketSum == 0), "must buy at least 1 ticket");\n', '        endRound(msg.sender);\n', '        initRound();\n', '    }\n', '\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 _slotId,\n', '        uint256 _value,\n', '        RewardType _rewardType)\n', '        private\n', '    {\n', '        // add reward balance\n', '        rewardBalance[_lucker] = rewardBalance[_lucker].add(_value);\n', '        // reward log\n', '        rewardContract.mintReward(\n', '            _lucker,\n', '            curRoundId,\n', '            slot[_slotId].tNumberFrom,\n', '            slot[_slotId].tNumberTo,\n', '            _value,\n', '            uint256(_rewardType)\n', '        );\n', '    }\n', '\n', '    function jackpot()\n', '        private\n', '    {\n', '        // get blocknumber to get blockhash\n', '        uint256 keyBlockNr = getKeyBlockNr(lastBlockNr);//block.number;\n', '        // salt not effected by jackpot, too risk\n', '        uint256 seed = getSeed(keyBlockNr);\n', '        // slot numberic from 1 ... totalSlot(round)\n', '        // jackpot for all slot in last block, jSlot <= i <= lastSlotId (=slotSum - 1)\n', '        // _to = first Slot in new block\n', '        //uint256 _to = round[curRoundId].slotSum;\n', '\n', '        uint256 jReward;\n', '        uint256 toF2mAmount;\n', '        address winner;\n', '        // jackpot check for slots in last block\n', '        while (jSlot + 1 < round[curRoundId].slotSum) {\n', '            // majorPot\n', '            if ((seed % MAJOR_RATE == 6) &&\n', '                (slot[jSlot].ethAmount >= MAJOR_MIN)) {\n', '\n', '                winner = slot[jSlot].buyer;\n', '                jReward = majorPot / 100 * jRewardPercent;\n', '                mintReward(winner, jSlot, jReward, RewardType.Major);\n', '                toF2mAmount = majorPot / 100 * toTokenPercent;\n', '                f2mContract.pushDividends.value(toF2mAmount)();\n', '                majorPot = majorPot - jReward - toF2mAmount;\n', '            }\n', '\n', '            // minorPot\n', '            if (((seed + jSlot) % MINOR_RATE == 8) && \n', '                (slot[jSlot].ethAmount >= MINOR_MIN)) {\n', '\n', '                winner = slot[jSlot].buyer;\n', '                jReward = minorPot / 100 * jRewardPercent;\n', '                mintReward(winner, jSlot, jReward, RewardType.Minor);\n', '                toF2mAmount = minorPot / 100 * toTokenPercent;\n', '                f2mContract.pushDividends.value(toF2mAmount)();\n', '                minorPot = minorPot - jReward - toF2mAmount;\n', '            }\n', '            seed = seed + 1;\n', '            jSlot = jSlot + 1;\n', '        }\n', '    }\n', '\n', '    function endRound(address _bountyHunter)\n', '        private\n', '    {\n', '        uint256 _rId = curRoundId;\n', '        uint256 keyBlockNr = getKeyBlockNr(round[_rId].keyBlockNr);\n', '        uint256 _seed = getSeed(keyBlockNr) + curRSalt;\n', '        uint256 onePercent = grandPot / 100;\n', '        uint256 rGrandReward = onePercent * grandRewardPercent;\n', '\n', '        //PUSH DIVIDENDS\n', '        uint256 toF2mAmount = onePercent * toTokenPercent;\n', '        //uint256 _bountyAmount = onePercent * bountyPercent;\n', '        \n', '        grandPot = grandPot - toF2mAmount - onePercent;\n', '        f2mContract.pushDividends.value(toF2mAmount)();\n', '\n', '        // base on grand-intestedSum current grandPot\n', '        uint256 weightRange = getWeightRange();\n', '\n', '        // roll 3 turns\n', '        for (uint256 i = 0; i < 3; i++){\n', '            uint256 winNr = Helper.getRandom(_seed, weightRange);\n', '            // if winNr > curRoundWeight => no winner this turn\n', '            // win Slot : fromWeight <= winNr <= toWeight\n', '            // got winner this rolling turn\n', '            if (winNr <= curRWeight) {\n', '                grandPot -= rGrandReward;\n', '                uint256 _winSlot = getWinSlot(winNr);\n', '                address _winner = slot[_winSlot].buyer;\n', '                mintReward(_winner, _winSlot, rGrandReward, RewardType.Grand);\n', '                _seed = _seed + (_seed / 10);\n', '            }\n', '        }\n', '        mintReward(_bountyHunter, 0, onePercent * 3 / 10, RewardType.Bounty);\n', '        rewardContract.pushBounty.value(onePercent * 7 / 10)(curRoundId);\n', '    }\n', '\n', '    function buy(string _sSalt)\n', '        public\n', '        payable\n', '    {\n', '        buyFor(_sSalt, msg.sender);\n', '    }\n', '\n', '    function updateInvested(address _buyer, uint256 _ethAmount)\n', '        private\n', '    {\n', '        round[curRoundId].investedSum += _ethAmount;\n', '        round[curRoundId].pInvestedSum[_buyer] += _ethAmount;\n', '        pInvestedSum[_buyer] += _ethAmount;\n', '    }\n', '\n', '    function updateTicketSum(address _buyer, uint256 _tAmount)\n', '        private\n', '    {\n', '        round[curRoundId].ticketSum = round[curRoundId].ticketSum + _tAmount;\n', '        round[curRoundId].pTicketSum[_buyer] = round[curRoundId].pTicketSum[_buyer] + _tAmount;\n', '        curRTicketSum = curRTicketSum + _tAmount;\n', '        pTicketSum[_buyer] = pTicketSum[_buyer] + _tAmount;\n', '    }\n', '\n', '    function updateEarlyIncome(address _buyer, uint256 _pWeight)\n', '        private\n', '    {\n', '        round[curRoundId].rEarlyIncomeWeight = _pWeight.add(round[curRoundId].rEarlyIncomeWeight);\n', '        round[curRoundId].pEarlyIncomeWeight[_buyer] = _pWeight.add(round[curRoundId].pEarlyIncomeWeight[_buyer]);\n', '        round[curRoundId].pEarlyIncomeCredit[_buyer] = round[curRoundId].pEarlyIncomeCredit[_buyer].add(_pWeight.mul(round[curRoundId].ppw));\n', '    }\n', '\n', '    function buyFor(string _sSalt, address _sender) \n', '        public\n', '        payable\n', '        buyable()\n', '    {\n', '        uint256 _salt = Helper.stringToUint(_sSalt);\n', '        uint256 _ethAmount = msg.value;\n', '        uint256 _ticketSum = curRTicketSum;\n', '        require(_ethAmount >= Helper.getTPrice(_ticketSum), "not enough to buy 1 ticket");\n', '\n', '        // investedSum logs\n', '        updateInvested(_sender, _ethAmount);\n', '        // update salt\n', '        curRSalt = curRSalt + _salt;\n', '        // init new Slot, Slot Id = 1..curRSlotSum\n', '        Slot memory _slot;\n', '        _slot.rId = curRoundId;\n', '        _slot.buyer = _sender;\n', '        _slot.ethAmount = _ethAmount;\n', '        _slot.salt = _salt;\n', '        uint256 _tAmount = Helper.getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = Helper.getTMul(_ticketSum);\n', '        uint256 _pMul = Helper.getEarlyIncomeMul(_ticketSum);\n', '        uint256 _pWeight = _pMul.mul(_tAmount);\n', '        uint256 _toAddTime = Helper.getAddedTime(_ticketSum, _tAmount);\n', '        addTime(curRoundId, _toAddTime);\n', '\n', '        // update weight\n', '        uint256 _slotWeight = (_tAmount).mul(_tMul);\n', '        curRWeight = curRWeight.add(_slotWeight);\n', '        _slot.wTo = curRWeight;\n', '        uint256 lastSlot = slot.length - 1;\n', '        // update ticket params\n', '        _slot.tNumberFrom = slot[lastSlot].tNumberTo + 1;\n', '        _slot.tNumberTo = slot[lastSlot].tNumberTo + _tAmount;\n', '        updateTicketSum(_sender, _tAmount);\n', '\n', '        // EarlyIncome Weight\n', '        // ppw and credit zoomed x1000\n', '        // earlyIncome mul of each ticket in this slot\n', '        updateEarlyIncome(_sender, _pWeight);\n', '     \n', '        // add Slot and update round data\n', '        slot.push(_slot);\n', '        round[curRoundId].slotSum = slot.length;\n', '        // add slot to player logs\n', '        pSlot[_sender].push(slot.length - 1);\n', '\n', '        // first slot in this block draw jacpot results for \n', '        // all slot in last block\n', '        if (lastBlockNr != block.number) {\n', '            jackpot();\n', '            lastBlockNr = block.number;\n', '        }\n', '\n', '        distributeSlotBuy(_sender, curRoundId, _ethAmount);\n', '\n', '        round[curRoundId].keyBlockNr = genEstKeyBlockNr(round[curRoundId].slideEndTime);\n', '    }\n', '\n', '    function distributeSlotBuy(address _sender, uint256 _rId, uint256 _ethAmount)\n', '        private\n', '    {\n', '        uint256 onePercent = _ethAmount / 100;\n', '        uint256 toF2mAmount = onePercent * toTokenPercent; // 12\n', '        uint256 toRefAmount = onePercent * toRefPercent; // 10\n', '        uint256 toBuyTokenAmount = onePercent * toBuyTokenPercent; //1\n', '        uint256 earlyIncomeAmount = onePercent * earlyIncomePercent; //27\n', '        uint256 taxAmount = toF2mAmount + toRefAmount + toBuyTokenAmount + earlyIncomeAmount; // 50\n', '        uint256 taxedEthAmount = _ethAmount.sub(taxAmount); // 50\n', '        addPot(taxedEthAmount);\n', '        \n', '        // 10% Ref\n', '        citizenContract.pushRefIncome.value(toRefAmount)(_sender);\n', '        // 2% Fund + 10% Dividends \n', '        f2mContract.pushDividends.value(toF2mAmount)();\n', '        // 1% buy Token\n', '        f2mContract.buyFor.value(toBuyTokenAmount)(_sender);\n', '        // 27% Early\n', '        uint256 deltaPpw = (earlyIncomeAmount * ZOOM).div(round[_rId].rEarlyIncomeWeight);\n', '        round[_rId].ppw = deltaPpw.add(round[_rId].ppw);\n', '    }\n', '\n', '    function claimEarlyIncomebyAddress(address _buyer)\n', '        private\n', '    {\n', '        if (curRoundId == 0) return;\n', '        claimEarlyIncomebyAddressRound(_buyer, curRoundId);\n', '        uint256 _rId = curRoundId - 1;\n', '        while ((_rId > lastWithdrawnRound[_buyer]) && (_rId + 20 > curRoundId)) {\n', '            earlyIncomeScannedSum[_buyer] += claimEarlyIncomebyAddressRound(_buyer, _rId);\n', '            _rId = _rId - 1;\n', '        }\n', '    }\n', '\n', '    function claimEarlyIncomebyAddressRound(address _buyer, uint256 _rId)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = getCurEarlyIncomeByAddressRound(_buyer, _rId);\n', '        if (_amount == 0) return 0;\n', '        round[_rId].pEarlyIncomeClaimed[_buyer] = _amount.add(round[_rId].pEarlyIncomeClaimed[_buyer]);\n', '        rewardBalance[_buyer] = _amount.add(rewardBalance[_buyer]);\n', '        return _amount;\n', '    }\n', '\n', '    function withdrawFor(address _sender)\n', '        public\n', '        withdrawRight()\n', '        returns(uint256)\n', '    {\n', '        if (curRoundId == 0) return;\n', '        claimEarlyIncomebyAddress(_sender);\n', '        lastWithdrawnRound[_sender] = curRoundId - 1;\n', '        uint256 _amount = rewardBalance[_sender];\n', '        rewardBalance[_sender] = 0;\n', '        bankContract.pushToBank.value(_amount)(_sender);\n', '        return _amount;\n', '    }\n', '    \n', '    function addTime(uint256 _rId, uint256 _toAddTime)\n', '        private\n', '    {\n', '        round[_rId].slideEndTime = Helper.getNewEndTime(_toAddTime, round[_rId].slideEndTime, round[_rId].fixedEndTime);\n', '    }\n', '\n', '    // distribute to 3 pots Grand, Majorm Minor\n', '    function addPot(uint256 _amount)\n', '        private\n', '    {\n', '        uint256 onePercent = _amount / 100;\n', '        uint256 toMinor = onePercent * minorPercent;\n', '        uint256 toMajor = onePercent * majorPercent;\n', '        uint256 toGrand = _amount - toMinor - toMajor;\n', '\n', '        minorPot = minorPot + toMinor;\n', '        majorPot = majorPot + toMajor;\n', '        grandPot = grandPot + toGrand;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////////\n', '    // READ FUNCTIONS\n', '    //////////////////////////////////////////////////////////////////\n', '\n', '    function isWinSlot(uint256 _slotId, uint256 _keyNumber)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return (slot[_slotId - 1].wTo < _keyNumber) && (slot[_slotId].wTo >= _keyNumber);\n', '    }\n', '\n', '    function getWeightRange()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getWeightRange(grandPot, initGrandPot, curRWeight);\n', '    }\n', '\n', '    function getWinSlot(uint256 _keyNumber)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        // return 0 if not found\n', '        uint256 _to = slot.length - 1;\n', '        uint256 _from = round[curRoundId-1].slotSum + 1; // dummy slot ignore\n', '        uint256 _pivot;\n', '        //Slot memory _slot;\n', '        uint256 _pivotWTo;\n', '        // Binary search\n', '        while (_from <= _to) {\n', '            _pivot = (_from + _to) / 2;\n', '            //_slot = round[_rId].slot[_pivot];\n', '            _pivotWTo = slot[_pivot].wTo;\n', '            if (isWinSlot(_pivot, _keyNumber)) return _pivot;\n', '            if (_pivotWTo < _keyNumber) { // in right side\n', '                _from = _pivot + 1;\n', '            } else { // in left side\n', '                _to = _pivot - 1;\n', '            }\n', '        }\n', '        return _pivot; // never happens or smt gone wrong\n', '    }\n', '\n', '    // Key Block in future\n', '    function genEstKeyBlockNr(uint256 _endTime) \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if (block.timestamp >= _endTime) return block.number + 8; \n', '        uint256 timeDist = _endTime - block.timestamp;\n', '        uint256 estBlockDist = timeDist / BLOCK_TIME;\n', '        return block.number + estBlockDist + 8;\n', '    }\n', '\n', '    // get block hash of first block with blocktime > _endTime\n', '    function getSeed(uint256 _keyBlockNr)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Key Block not mined atm\n', '        if (block.number <= _keyBlockNr) return block.number;\n', '        return uint256(blockhash(_keyBlockNr));\n', '    }\n', '\n', '    // current reward balance\n', '    function getRewardBalance(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rewardBalance[_buyer];\n', '    } \n', '\n', '    // GET endTime\n', '    function getSlideEndTime(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(round[_rId].slideEndTime);\n', '    }\n', '\n', '    function getFixedEndTime(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(round[_rId].fixedEndTime);\n', '    }\n', '\n', '    function getTotalPot()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return grandPot + majorPot + minorPot;\n', '    }\n', '\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = earlyIncomeScannedSum[_buyer];\n', '        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\n', '        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\n', '        uint256 _rId = _fromRound;\n', '        while (_rId <= curRoundId) {\n', '            _sum = _sum + getEarlyIncomeByAddressRound(_buyer, _rId);\n', '            _rId++;\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    // included claimed amount\n', '    function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _pWeight = round[_rId].pEarlyIncomeWeight[_buyer];\n', '        uint256 _ppw = round[_rId].ppw;\n', '        uint256 _rCredit = round[_rId].pEarlyIncomeCredit[_buyer];\n', '        uint256 _rEarlyIncome = ((_ppw.mul(_pWeight)).sub(_rCredit)).div(ZOOM);\n', '        return _rEarlyIncome;\n', '    }\n', '\n', '    function getCurEarlyIncomeByAddress(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = 0;\n', '        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\n', '        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\n', '        uint256 _rId = _fromRound;\n', '        while (_rId <= curRoundId) {\n', '            _sum = _sum.add(getCurEarlyIncomeByAddressRound(_buyer, _rId));\n', '            _rId++;\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _rEarlyIncome = getEarlyIncomeByAddressRound(_buyer, _rId);\n', '        return _rEarlyIncome.sub(round[_rId].pEarlyIncomeClaimed[_buyer]);\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////\n', '\n', '    function getEstKeyBlockNr(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].keyBlockNr;\n', '    }\n', '\n', '    function getKeyBlockNr(uint256 _estKeyBlockNr)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        require(block.number > _estKeyBlockNr, "blockHash not avaiable");\n', '        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\n', '        return _estKeyBlockNr + jump;\n', '    }\n', '\n', '    // Logs\n', '    function getCurRoundId()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return curRoundId;\n', '    }\n', '\n', '    function getTPrice()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getTPrice(curRTicketSum);\n', '    }\n', '\n', '    function getTMul()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getTMul(curRTicketSum);\n', '    }\n', '\n', '    function getPMul()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getEarlyIncomeMul(curRTicketSum);\n', '    }\n', '\n', '    function getPTicketSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].pTicketSum[_buyer];\n', '    }\n', '\n', '    function getTicketSumToRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].ticketSum;\n', '    }\n', '\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].pInvestedSum[_buyer];\n', '    }\n', '\n', '    function getInvestedSumToRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].investedSum;\n', '    }\n', '\n', '    function getPSlotLength(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pSlot[_sender].length;\n', '    }\n', '\n', '    function getSlotLength()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return slot.length;\n', '    }\n', '\n', '    function getSlotId(address _sender, uint256 i)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pSlot[_sender][i];\n', '    }\n', '\n', '    function getSlotInfo(uint256 _slotId)\n', '        public\n', '        view\n', '        returns(address, uint256[4], string)\n', '    {\n', '        Slot memory _slot = slot[_slotId];\n', '        return (_slot.buyer,[_slot.rId, _slot.tNumberFrom, _slot.tNumberTo, _slot.ethAmount], Helper.uintToString(_slot.salt));\n', '    }\n', '\n', '    function cashoutable(address _address) \n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        // need 1 ticket or in waiting time to start new round\n', '        return (round[curRoundId].pTicketSum[_address] > 0) || (round[curRoundId].startTime > block.timestamp);\n', '    }\n', '\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) \n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(_lastRoundId >= 18 && _lastRoundId > curRoundId, "too early to end");\n', '        require(lastRoundId == 88888888, "already set");\n', '        lastRoundId = _lastRoundId;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   gibmireinbier@gmail.com\n', '*/\n', '\n', 'interface F2mInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // one time called\n', '    function disableRound0() public;\n', '    function activeBuy() public;\n', '    // Dividends from all sources (DApps, Donate ...)\n', '    function pushDividends() public payable;\n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    //function reinvest() public;\n', '    //function buy() public payable;\n', '    function buyFor(address _buyer) public payable;\n', '    function sell(uint256 _tokenAmount) public;\n', '    function exit() public;\n', '    function devTeamWithdraw() public returns(uint256);\n', '    function withdrawFor(address sender) public returns(uint256);\n', '    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function setAutoBuy() public;\n', '    /*==========================================\n', '    =            public FUNCTIONS            =\n', '    ==========================================*/\n', '    // function totalEthBalance() public view returns(uint256);\n', '    function ethBalance(address _address) public view returns(uint256);\n', '    function myBalance() public view returns(uint256);\n', '    function myEthBalance() public view returns(uint256);\n', '\n', '    function swapToken() public;\n', '    function setNewToken(address _newTokenAddress) public;\n', '}\n', '\n', 'interface CitizenInterface {\n', ' \n', '    function joinNetwork(address[6] _contract) public;\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function devTeamWithdraw() public;\n', '\n', '    /*----------  WRITE FUNCTIONS  ----------*/\n', '    function updateUsername(string _sNewUsername) public;\n', '    //Sources: Token contract, DApps\n', '    function pushRefIncome(address _sender) public payable;\n', '    function withdrawFor(address _sender) public payable returns(uint256);\n', '    function devTeamReinvest() public returns(uint256);\n', '\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getRefWallet(address _address) public view returns(uint256);\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'interface BankInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // Core functions\n', '    function pushToBank(address _player) public payable;\n', '}\n', '\n', 'interface RewardInterface {\n', '\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        public;\n', '        \n', '    function joinNetwork(address[6] _contract) public;\n', '    function pushBounty(uint256 _curRoundId) public payable;\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Helper {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public SDIVIDER = 3450000;\n', '    uint256 constant public PDIVIDER = 3450000;\n', '    uint256 constant public RDIVIDER = 1580000;\n', '    // Starting LS price (SLP)\n', '    uint256 constant public SLP = 0.002 ether;\n', '    // Starting Added Time (SAT)\n', '    uint256 constant public SAT = 30; // seconds\n', '    // Price normalization (PN)\n', '    uint256 constant public PN = 777;\n', '    // EarlyIncome base\n', '    uint256 constant public PBASE = 13;\n', '    uint256 constant public PMULTI = 26;\n', '    uint256 constant public LBase = 15;\n', '\n', '    uint256 constant public ONE_HOUR = 3600;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    \n', '    function bytes32ToString (bytes32 data)\n', '        public\n', '        pure\n', '        returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(32);\n', '        for (uint j=0; j<32; j++) {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[j] = char;\n', '            }\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    \n', '    function uintToBytes32(uint256 n)\n', '        public\n', '        pure\n', '        returns (bytes32) \n', '    {\n', '        return bytes32(n);\n', '    }\n', '    \n', '    function bytes32ToUint(bytes32 n) \n', '        public\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        return uint256(n);\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) \n', '        public\n', '        pure\n', '        returns (bytes32 result) \n', '    {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    \n', '    function stringToUint(string memory source) \n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return bytes32ToUint(stringToBytes32(source));\n', '    }\n', '    \n', '    function uintToString(uint256 _uint) \n', '        public\n', '        pure\n', '        returns (string)\n', '    {\n', '        return bytes32ToString(uintToBytes32(_uint));\n', '    }\n', '\n', '/*     \n', '    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\n', '        bytes memory a = new bytes(end-begin+1);\n', '        for(uint i = 0; i <= end - begin; i++){\n', '            a[i] = bytes(text)[i + begin - 1];\n', '        }\n', '        return string(a);    \n', '    }\n', ' */\n', '    function validUsername(string _username)\n', '        public\n', '        pure\n', '        returns(bool)\n', '    {\n', '        uint256 len = bytes(_username).length;\n', '        // Im Raum [4, 18]\n', '        if ((len < 4) || (len > 18)) return false;\n', "        // Letzte Char != ' '\n", '        if (bytes(_username)[len-1] == 32) return false;\n', "        // Erste Char != '0'\n", '        return uint256(bytes(_username)[0]) != 48;\n', '    }\n', '\n', '    // Lottery Helper\n', '\n', '    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\n', '    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        //Luppe = 10000 = 10^4\n', '        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        // div 10000^6\n', '        expo = expo / (10**24);\n', '\n', '        if (expo > SAT) return 0;\n', '        return (SAT - expo).mul(_tAmount);\n', '    }\n', '\n', '    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\n', '        uint256 timeout = _slideEndTime.sub(block.timestamp);\n', '        // timeout capped at TIMEOUT1\n', '        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\n', '        _slideEndTime = (block.timestamp).add(timeout);\n', '        // Capped at fixedEndTime\n', '        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\n', '        return _slideEndTime;\n', '    }\n', '\n', '    // get random in range [1, _range] with _seed\n', '    function getRandom(uint256 _seed, uint256 _range)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        if (_range == 0) return _seed;\n', '        return (_seed % _range) + 1;\n', '    }\n', '\n', '\n', '    function getEarlyIncomeMul(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\n', '        uint256 base = _ticketSum * ZOOM / RDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base); //^3\n', '        expo = expo.mul(expo) / (ZOOM**6); //^6\n', '        return (1 + PBASE / (1 + expo.mul(PMULTI)));\n', '    }\n', '\n', '    // get reveiced Tickets, based on current round ticketSum\n', '    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tPrice = getTPrice(_ticketSum);\n', '        return _ethAmount.div(_tPrice);\n', '    }\n', '\n', '    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\n', '    function getTMul(uint256 _ticketSum) // Unit Wei\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = _ticketSum * ZOOM / PDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base);\n', '        expo = expo.mul(expo); // ^6\n', '        return 1 + expo.mul(LBase) / (10**18);\n', '    }\n', '\n', '    // get ticket price, based on current round ticketSum\n', '    //unit in ETH, no need / zoom^6\n', '    function getTPrice(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        uint256 tPrice = SLP + expo / PN;\n', '        return tPrice;\n', '    }\n', '\n', '    // get weight of slot, chance to win grandPot\n', '    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = getTMul(_ticketSum);\n', '        return (_tAmount).mul(_tMul);\n', '    }\n', '\n', '    // used to draw grandpot results\n', '    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\n', '    // grandPot = initGrandPot + round investedSum(for grandPot)\n', '    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        //calculate round grandPot-investedSum\n', '        uint256 grandPotInvest = grandPot - initGrandPot;\n', '        if (grandPotInvest == 0) return 8;\n', '        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\n', '        uint256 weightRange = zoomMul * curRWeight / ZOOM;\n', '        if (weightRange < curRWeight) weightRange = curRWeight;\n', '        return weightRange;\n', '    }\n', '}\n', '\n', 'contract Lottery {\n', '    using SafeMath for uint256;\n', '\n', '    modifier withdrawRight(){\n', '        require(msg.sender == address(bankContract), "Bank only");\n', '        _;\n', '    }\n', '\n', '    modifier onlyDevTeam() {\n', '        require(msg.sender == devTeam, "only for development team");\n', '        _;\n', '    }\n', '\n', '    modifier buyable() {\n', '        require(block.timestamp > round[curRoundId].startTime, "not ready to sell Ticket");\n', '        require(block.timestamp < round[curRoundId].slideEndTime, "round over");\n', '        _;\n', '    }\n', '\n', '    enum RewardType {\n', '        Minor,\n', '        Major,\n', '        Grand,\n', '        Bounty\n', '    }\n', '\n', '    // 1 buy = 1 slot = _ethAmount => (tAmount, tMul) \n', '    struct Slot {\n', '        address buyer;\n', '        uint256 rId;\n', '        // ticket numbers in range and unique in all rounds\n', '        uint256 tNumberFrom;\n', '        uint256 tNumberTo;\n', '        // weight to, used for grandPot finalize\n', '        uint256 wTo;\n', '        uint256 ethAmount;\n', '        uint256 salt;\n', '    }\n', '\n', '    struct Round {\n', '        // earlyIncome weight sum\n', '        uint256 rEarlyIncomeWeight;\n', '        // blockNumber to get hash as random seed\n', '        uint256 keyBlockNr;\n', '        \n', '        mapping(address => uint256) pTicketSum;\n', '        mapping(address => uint256) pInvestedSum;\n', '\n', '        // early income weight by address\n', '        mapping(address => uint256) pEarlyIncomeWeight;\n', '        mapping(address => uint256) pEarlyIncomeCredit;\n', '        mapping(address => uint256) pEarlyIncomeClaimed;\n', '        // early income per weight\n', '        uint256 ppw;\n', '        // endTime increased every slot sold\n', '        // endTime limited by fixedEndTime\n', '        uint256 startTime;\n', '        uint256 slideEndTime;\n', '        uint256 fixedEndTime;\n', '\n', '        // ticketSum from round 1 to this round\n', '        uint256 ticketSum;\n', '        // investedSum from round 1 to this round\n', '        uint256 investedSum;\n', '        // number of slots from round 1 to this round\n', '        uint256 slotSum;\n', '    }\n', '\n', '    // round started with this grandPot amount,\n', '    // used to calculate the rate for grandPot results\n', '    // init in roundInit function\n', '    uint256 initGrandPot;\n', '\n', '    Slot[] slot;\n', '    // slotId logs by address\n', '    mapping( address => uint256[]) pSlot;\n', '    mapping( address => uint256) public pSlotSum;\n', '\n', '    // logs by address\n', '    mapping( address => uint256) public pTicketSum;\n', '    mapping( address => uint256) public pInvestedSum;\n', '\n', '    CitizenInterface public citizenContract;\n', '    F2mInterface public f2mContract;\n', '    BankInterface public bankContract;\n', '    RewardInterface public rewardContract;\n', '\n', '    address public devTeam;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public ONE_HOUR = 60 * 60;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\n', '    uint256 constant public FINALIZE_WAIT_DURATION = 60; // 60 Seconds\n', '    uint256 constant public NEWROUND_WAIT_DURATION = ONE_DAY; // 24 Hours\n', '\n', '    // 15 seconds on Ethereum, 12 seconds used instead to make sure blockHash unavaiable\n', '    // when slideEndTime reached\n', '    // keyBlockNumber will be estimated again after every slot buy\n', '    uint256 constant public BLOCK_TIME = 12;\n', '    uint256 constant public MAX_BLOCK_DISTANCE = 254;\n', '\n', '    uint256 constant public MAJOR_RATE = 1000;\n', '    uint256 constant public MINOR_RATE = 1000;\n', '    uint256 constant public MAJOR_MIN = 0.1 ether ;\n', '    uint256 constant public MINOR_MIN = 0.1 ether ;\n', '\n', '    //uint256 public toNextPotPercent = 27;\n', '    uint256 public grandRewardPercent = 20;\n', '    uint256 public jRewardPercent = 60;\n', '\n', '    uint256 public toTokenPercent = 12; // 10% dividends 2% fund\n', '    uint256 public toBuyTokenPercent = 1;\n', '    uint256 public earlyIncomePercent = 22;\n', '    uint256 public toRefPercent = 15;\n', '\n', '    // sum == 100% = toPotPercent/100 * investedSum\n', '    // uint256 public grandPercent = 68;\n', '    uint256 public majorPercent = 24;\n', '    uint256 public minorPercent = 8;\n', '\n', '    uint256 public grandPot;\n', '    uint256 public majorPot;\n', '    uint256 public minorPot;\n', '\n', '    uint256 public curRoundId;\n', '    uint256 public lastRoundId = 88888888;\n', '\n', '    uint256 constant public startPrice = 0.002 ether;\n', '\n', '    mapping (address => uint256) public rewardBalance;\n', '    // used to save gas on earlyIncome calculating, curRoundId never included\n', '    // only earlyIncome from round 1st to curRoundId-1 are fixed\n', '    mapping (address => uint256) public lastWithdrawnRound;\n', '    mapping (address => uint256) public earlyIncomeScannedSum;\n', '\n', '    mapping (uint256 => Round) public round;\n', '\n', '    // Current Round\n', '\n', '    // first SlotId in last Block to fire jackpot\n', '    uint256 public jSlot;\n', '    // jackpot results of all slots in same block will be drawed at the same time,\n', '    // by player, who buys the first slot in next block\n', '    uint256 public lastBlockNr;\n', '    // used to calculate grandPot results\n', '    uint256 public curRWeight;\n', '    // added by slot salt after every slot buy\n', '    // does not matter with overflow\n', '    uint256 public curRSalt;\n', '    // ticket sum of current round\n', '    uint256 public curRTicketSum;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // register address in network\n', '        DevTeamInterface(_devTeam).setLotteryAddress(address(this));\n', '        devTeam = _devTeam;\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require(address(citizenContract) == 0x0,"already setup");\n', '        f2mContract = F2mInterface(_contract[0]);\n', '        bankContract = BankInterface(_contract[1]);\n', '        citizenContract = CitizenInterface(_contract[2]);\n', '        //lotteryContract = LotteryInterface(lotteryAddress);\n', '        rewardContract = RewardInterface(_contract[4]);\n', '    }\n', '\n', '    function activeFirstRound()\n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(curRoundId == 0, "already activated");\n', '        initRound();\n', '    }\n', '\n', '    // Core Functions\n', '\n', '    function pushToPot() \n', '        public \n', '        payable\n', '    {\n', '        addPot(msg.value);\n', '    }\n', '\n', '    function checkpoint() \n', '        private\n', '    {\n', '        // dummy slot between every 2 rounds\n', '        // dummy slot never win jackpot cause of min 0.1 ETH\n', '        Slot memory _slot;\n', '        _slot.tNumberTo = round[curRoundId].ticketSum;\n', '        slot.push(_slot);\n', '\n', '        Round memory _round;\n', '        _round.startTime = NEWROUND_WAIT_DURATION.add(block.timestamp);\n', '        // started with 3 hours timeout\n', '        _round.slideEndTime = TIMEOUT0 + _round.startTime;\n', '        _round.fixedEndTime = TIMEOUT2 + _round.startTime;\n', '        _round.keyBlockNr = genEstKeyBlockNr(_round.slideEndTime);\n', '        _round.ticketSum = round[curRoundId].ticketSum;\n', '        _round.investedSum = round[curRoundId].investedSum;\n', '        _round.slotSum = slot.length;\n', '\n', '        curRoundId = curRoundId + 1;\n', '        round[curRoundId] = _round;\n', '\n', '        initGrandPot = grandPot;\n', '        curRWeight = 0;\n', '        curRTicketSum = 0;\n', '    }\n', '\n', '    // from round 18+ function\n', '    function isLastRound()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return (curRoundId == lastRoundId);\n', '    }\n', '\n', '    function goNext()\n', '        private\n', '    {\n', '        uint256 _totalPot = getTotalPot();\n', '        grandPot = 0;\n', '        majorPot = 0;\n', '        minorPot = 0;\n', '        f2mContract.pushDividends.value(_totalPot)();\n', '        // never start\n', '        round[curRoundId].startTime = block.timestamp * 10;\n', '        round[curRoundId].slideEndTime = block.timestamp * 10 + 1;\n', '    }\n', '\n', '    function initRound()\n', '        private\n', '    {\n', '        // update all Round Log\n', '        checkpoint();\n', '        if (isLastRound()) goNext();\n', '    }\n', '\n', '    function finalizeable() \n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        uint256 finalizeTime = FINALIZE_WAIT_DURATION.add(round[curRoundId].slideEndTime);\n', '        if (finalizeTime > block.timestamp) return false; // too soon to finalize\n', '        if (getEstKeyBlockNr(curRoundId) >= block.number) return false; //block hash not exist\n', '        return curRoundId > 0;\n', '    }\n', '\n', '    // bounty\n', '    function finalize()\n', '        public\n', '    {\n', '        require(finalizeable(), "Not ready to draw results");\n', '        // avoid txs blocked => curRTicket ==0 => die\n', '        require((round[curRoundId].pTicketSum[msg.sender] > 0) || (curRTicketSum == 0), "must buy at least 1 ticket");\n', '        endRound(msg.sender);\n', '        initRound();\n', '    }\n', '\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 _slotId,\n', '        uint256 _value,\n', '        RewardType _rewardType)\n', '        private\n', '    {\n', '        // add reward balance\n', '        rewardBalance[_lucker] = rewardBalance[_lucker].add(_value);\n', '        // reward log\n', '        rewardContract.mintReward(\n', '            _lucker,\n', '            curRoundId,\n', '            slot[_slotId].tNumberFrom,\n', '            slot[_slotId].tNumberTo,\n', '            _value,\n', '            uint256(_rewardType)\n', '        );\n', '    }\n', '\n', '    function jackpot()\n', '        private\n', '    {\n', '        // get blocknumber to get blockhash\n', '        uint256 keyBlockNr = getKeyBlockNr(lastBlockNr);//block.number;\n', '        // salt not effected by jackpot, too risk\n', '        uint256 seed = getSeed(keyBlockNr);\n', '        // slot numberic from 1 ... totalSlot(round)\n', '        // jackpot for all slot in last block, jSlot <= i <= lastSlotId (=slotSum - 1)\n', '        // _to = first Slot in new block\n', '        //uint256 _to = round[curRoundId].slotSum;\n', '\n', '        uint256 jReward;\n', '        uint256 toF2mAmount;\n', '        address winner;\n', '        // jackpot check for slots in last block\n', '        while (jSlot + 1 < round[curRoundId].slotSum) {\n', '            // majorPot\n', '            if ((seed % MAJOR_RATE == 6) &&\n', '                (slot[jSlot].ethAmount >= MAJOR_MIN)) {\n', '\n', '                winner = slot[jSlot].buyer;\n', '                jReward = majorPot / 100 * jRewardPercent;\n', '                mintReward(winner, jSlot, jReward, RewardType.Major);\n', '                toF2mAmount = majorPot / 100 * toTokenPercent;\n', '                f2mContract.pushDividends.value(toF2mAmount)();\n', '                majorPot = majorPot - jReward - toF2mAmount;\n', '            }\n', '\n', '            // minorPot\n', '            if (((seed + jSlot) % MINOR_RATE == 8) && \n', '                (slot[jSlot].ethAmount >= MINOR_MIN)) {\n', '\n', '                winner = slot[jSlot].buyer;\n', '                jReward = minorPot / 100 * jRewardPercent;\n', '                mintReward(winner, jSlot, jReward, RewardType.Minor);\n', '                toF2mAmount = minorPot / 100 * toTokenPercent;\n', '                f2mContract.pushDividends.value(toF2mAmount)();\n', '                minorPot = minorPot - jReward - toF2mAmount;\n', '            }\n', '            seed = seed + 1;\n', '            jSlot = jSlot + 1;\n', '        }\n', '    }\n', '\n', '    function endRound(address _bountyHunter)\n', '        private\n', '    {\n', '        uint256 _rId = curRoundId;\n', '        uint256 keyBlockNr = getKeyBlockNr(round[_rId].keyBlockNr);\n', '        uint256 _seed = getSeed(keyBlockNr) + curRSalt;\n', '        uint256 onePercent = grandPot / 100;\n', '        uint256 rGrandReward = onePercent * grandRewardPercent;\n', '\n', '        //PUSH DIVIDENDS\n', '        uint256 toF2mAmount = onePercent * toTokenPercent;\n', '        //uint256 _bountyAmount = onePercent * bountyPercent;\n', '        \n', '        grandPot = grandPot - toF2mAmount - onePercent;\n', '        f2mContract.pushDividends.value(toF2mAmount)();\n', '\n', '        // base on grand-intestedSum current grandPot\n', '        uint256 weightRange = getWeightRange();\n', '\n', '        // roll 3 turns\n', '        for (uint256 i = 0; i < 3; i++){\n', '            uint256 winNr = Helper.getRandom(_seed, weightRange);\n', '            // if winNr > curRoundWeight => no winner this turn\n', '            // win Slot : fromWeight <= winNr <= toWeight\n', '            // got winner this rolling turn\n', '            if (winNr <= curRWeight) {\n', '                grandPot -= rGrandReward;\n', '                uint256 _winSlot = getWinSlot(winNr);\n', '                address _winner = slot[_winSlot].buyer;\n', '                mintReward(_winner, _winSlot, rGrandReward, RewardType.Grand);\n', '                _seed = _seed + (_seed / 10);\n', '            }\n', '        }\n', '        mintReward(_bountyHunter, 0, onePercent * 3 / 10, RewardType.Bounty);\n', '        rewardContract.pushBounty.value(onePercent * 7 / 10)(curRoundId);\n', '    }\n', '\n', '    function buy(string _sSalt)\n', '        public\n', '        payable\n', '    {\n', '        buyFor(_sSalt, msg.sender);\n', '    }\n', '\n', '    function updateInvested(address _buyer, uint256 _ethAmount)\n', '        private\n', '    {\n', '        round[curRoundId].investedSum += _ethAmount;\n', '        round[curRoundId].pInvestedSum[_buyer] += _ethAmount;\n', '        pInvestedSum[_buyer] += _ethAmount;\n', '    }\n', '\n', '    function updateTicketSum(address _buyer, uint256 _tAmount)\n', '        private\n', '    {\n', '        round[curRoundId].ticketSum = round[curRoundId].ticketSum + _tAmount;\n', '        round[curRoundId].pTicketSum[_buyer] = round[curRoundId].pTicketSum[_buyer] + _tAmount;\n', '        curRTicketSum = curRTicketSum + _tAmount;\n', '        pTicketSum[_buyer] = pTicketSum[_buyer] + _tAmount;\n', '    }\n', '\n', '    function updateEarlyIncome(address _buyer, uint256 _pWeight)\n', '        private\n', '    {\n', '        round[curRoundId].rEarlyIncomeWeight = _pWeight.add(round[curRoundId].rEarlyIncomeWeight);\n', '        round[curRoundId].pEarlyIncomeWeight[_buyer] = _pWeight.add(round[curRoundId].pEarlyIncomeWeight[_buyer]);\n', '        round[curRoundId].pEarlyIncomeCredit[_buyer] = round[curRoundId].pEarlyIncomeCredit[_buyer].add(_pWeight.mul(round[curRoundId].ppw));\n', '    }\n', '\n', '    function buyFor(string _sSalt, address _sender) \n', '        public\n', '        payable\n', '        buyable()\n', '    {\n', '        uint256 _salt = Helper.stringToUint(_sSalt);\n', '        uint256 _ethAmount = msg.value;\n', '        uint256 _ticketSum = curRTicketSum;\n', '        require(_ethAmount >= Helper.getTPrice(_ticketSum), "not enough to buy 1 ticket");\n', '\n', '        // investedSum logs\n', '        updateInvested(_sender, _ethAmount);\n', '        // update salt\n', '        curRSalt = curRSalt + _salt;\n', '        // init new Slot, Slot Id = 1..curRSlotSum\n', '        Slot memory _slot;\n', '        _slot.rId = curRoundId;\n', '        _slot.buyer = _sender;\n', '        _slot.ethAmount = _ethAmount;\n', '        _slot.salt = _salt;\n', '        uint256 _tAmount = Helper.getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = Helper.getTMul(_ticketSum);\n', '        uint256 _pMul = Helper.getEarlyIncomeMul(_ticketSum);\n', '        uint256 _pWeight = _pMul.mul(_tAmount);\n', '        uint256 _toAddTime = Helper.getAddedTime(_ticketSum, _tAmount);\n', '        addTime(curRoundId, _toAddTime);\n', '\n', '        // update weight\n', '        uint256 _slotWeight = (_tAmount).mul(_tMul);\n', '        curRWeight = curRWeight.add(_slotWeight);\n', '        _slot.wTo = curRWeight;\n', '        uint256 lastSlot = slot.length - 1;\n', '        // update ticket params\n', '        _slot.tNumberFrom = slot[lastSlot].tNumberTo + 1;\n', '        _slot.tNumberTo = slot[lastSlot].tNumberTo + _tAmount;\n', '        updateTicketSum(_sender, _tAmount);\n', '\n', '        // EarlyIncome Weight\n', '        // ppw and credit zoomed x1000\n', '        // earlyIncome mul of each ticket in this slot\n', '        updateEarlyIncome(_sender, _pWeight);\n', '     \n', '        // add Slot and update round data\n', '        slot.push(_slot);\n', '        round[curRoundId].slotSum = slot.length;\n', '        // add slot to player logs\n', '        pSlot[_sender].push(slot.length - 1);\n', '\n', '        // first slot in this block draw jacpot results for \n', '        // all slot in last block\n', '        if (lastBlockNr != block.number) {\n', '            jackpot();\n', '            lastBlockNr = block.number;\n', '        }\n', '\n', '        distributeSlotBuy(_sender, curRoundId, _ethAmount);\n', '\n', '        round[curRoundId].keyBlockNr = genEstKeyBlockNr(round[curRoundId].slideEndTime);\n', '    }\n', '\n', '    function distributeSlotBuy(address _sender, uint256 _rId, uint256 _ethAmount)\n', '        private\n', '    {\n', '        uint256 onePercent = _ethAmount / 100;\n', '        uint256 toF2mAmount = onePercent * toTokenPercent; // 12\n', '        uint256 toRefAmount = onePercent * toRefPercent; // 10\n', '        uint256 toBuyTokenAmount = onePercent * toBuyTokenPercent; //1\n', '        uint256 earlyIncomeAmount = onePercent * earlyIncomePercent; //27\n', '        uint256 taxAmount = toF2mAmount + toRefAmount + toBuyTokenAmount + earlyIncomeAmount; // 50\n', '        uint256 taxedEthAmount = _ethAmount.sub(taxAmount); // 50\n', '        addPot(taxedEthAmount);\n', '        \n', '        // 10% Ref\n', '        citizenContract.pushRefIncome.value(toRefAmount)(_sender);\n', '        // 2% Fund + 10% Dividends \n', '        f2mContract.pushDividends.value(toF2mAmount)();\n', '        // 1% buy Token\n', '        f2mContract.buyFor.value(toBuyTokenAmount)(_sender);\n', '        // 27% Early\n', '        uint256 deltaPpw = (earlyIncomeAmount * ZOOM).div(round[_rId].rEarlyIncomeWeight);\n', '        round[_rId].ppw = deltaPpw.add(round[_rId].ppw);\n', '    }\n', '\n', '    function claimEarlyIncomebyAddress(address _buyer)\n', '        private\n', '    {\n', '        if (curRoundId == 0) return;\n', '        claimEarlyIncomebyAddressRound(_buyer, curRoundId);\n', '        uint256 _rId = curRoundId - 1;\n', '        while ((_rId > lastWithdrawnRound[_buyer]) && (_rId + 20 > curRoundId)) {\n', '            earlyIncomeScannedSum[_buyer] += claimEarlyIncomebyAddressRound(_buyer, _rId);\n', '            _rId = _rId - 1;\n', '        }\n', '    }\n', '\n', '    function claimEarlyIncomebyAddressRound(address _buyer, uint256 _rId)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = getCurEarlyIncomeByAddressRound(_buyer, _rId);\n', '        if (_amount == 0) return 0;\n', '        round[_rId].pEarlyIncomeClaimed[_buyer] = _amount.add(round[_rId].pEarlyIncomeClaimed[_buyer]);\n', '        rewardBalance[_buyer] = _amount.add(rewardBalance[_buyer]);\n', '        return _amount;\n', '    }\n', '\n', '    function withdrawFor(address _sender)\n', '        public\n', '        withdrawRight()\n', '        returns(uint256)\n', '    {\n', '        if (curRoundId == 0) return;\n', '        claimEarlyIncomebyAddress(_sender);\n', '        lastWithdrawnRound[_sender] = curRoundId - 1;\n', '        uint256 _amount = rewardBalance[_sender];\n', '        rewardBalance[_sender] = 0;\n', '        bankContract.pushToBank.value(_amount)(_sender);\n', '        return _amount;\n', '    }\n', '    \n', '    function addTime(uint256 _rId, uint256 _toAddTime)\n', '        private\n', '    {\n', '        round[_rId].slideEndTime = Helper.getNewEndTime(_toAddTime, round[_rId].slideEndTime, round[_rId].fixedEndTime);\n', '    }\n', '\n', '    // distribute to 3 pots Grand, Majorm Minor\n', '    function addPot(uint256 _amount)\n', '        private\n', '    {\n', '        uint256 onePercent = _amount / 100;\n', '        uint256 toMinor = onePercent * minorPercent;\n', '        uint256 toMajor = onePercent * majorPercent;\n', '        uint256 toGrand = _amount - toMinor - toMajor;\n', '\n', '        minorPot = minorPot + toMinor;\n', '        majorPot = majorPot + toMajor;\n', '        grandPot = grandPot + toGrand;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////////\n', '    // READ FUNCTIONS\n', '    //////////////////////////////////////////////////////////////////\n', '\n', '    function isWinSlot(uint256 _slotId, uint256 _keyNumber)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return (slot[_slotId - 1].wTo < _keyNumber) && (slot[_slotId].wTo >= _keyNumber);\n', '    }\n', '\n', '    function getWeightRange()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getWeightRange(grandPot, initGrandPot, curRWeight);\n', '    }\n', '\n', '    function getWinSlot(uint256 _keyNumber)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        // return 0 if not found\n', '        uint256 _to = slot.length - 1;\n', '        uint256 _from = round[curRoundId-1].slotSum + 1; // dummy slot ignore\n', '        uint256 _pivot;\n', '        //Slot memory _slot;\n', '        uint256 _pivotWTo;\n', '        // Binary search\n', '        while (_from <= _to) {\n', '            _pivot = (_from + _to) / 2;\n', '            //_slot = round[_rId].slot[_pivot];\n', '            _pivotWTo = slot[_pivot].wTo;\n', '            if (isWinSlot(_pivot, _keyNumber)) return _pivot;\n', '            if (_pivotWTo < _keyNumber) { // in right side\n', '                _from = _pivot + 1;\n', '            } else { // in left side\n', '                _to = _pivot - 1;\n', '            }\n', '        }\n', '        return _pivot; // never happens or smt gone wrong\n', '    }\n', '\n', '    // Key Block in future\n', '    function genEstKeyBlockNr(uint256 _endTime) \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if (block.timestamp >= _endTime) return block.number + 8; \n', '        uint256 timeDist = _endTime - block.timestamp;\n', '        uint256 estBlockDist = timeDist / BLOCK_TIME;\n', '        return block.number + estBlockDist + 8;\n', '    }\n', '\n', '    // get block hash of first block with blocktime > _endTime\n', '    function getSeed(uint256 _keyBlockNr)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Key Block not mined atm\n', '        if (block.number <= _keyBlockNr) return block.number;\n', '        return uint256(blockhash(_keyBlockNr));\n', '    }\n', '\n', '    // current reward balance\n', '    function getRewardBalance(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rewardBalance[_buyer];\n', '    } \n', '\n', '    // GET endTime\n', '    function getSlideEndTime(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(round[_rId].slideEndTime);\n', '    }\n', '\n', '    function getFixedEndTime(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return(round[_rId].fixedEndTime);\n', '    }\n', '\n', '    function getTotalPot()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return grandPot + majorPot + minorPot;\n', '    }\n', '\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = earlyIncomeScannedSum[_buyer];\n', '        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\n', '        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\n', '        uint256 _rId = _fromRound;\n', '        while (_rId <= curRoundId) {\n', '            _sum = _sum + getEarlyIncomeByAddressRound(_buyer, _rId);\n', '            _rId++;\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    // included claimed amount\n', '    function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _pWeight = round[_rId].pEarlyIncomeWeight[_buyer];\n', '        uint256 _ppw = round[_rId].ppw;\n', '        uint256 _rCredit = round[_rId].pEarlyIncomeCredit[_buyer];\n', '        uint256 _rEarlyIncome = ((_ppw.mul(_pWeight)).sub(_rCredit)).div(ZOOM);\n', '        return _rEarlyIncome;\n', '    }\n', '\n', '    function getCurEarlyIncomeByAddress(address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = 0;\n', '        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\n', '        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\n', '        uint256 _rId = _fromRound;\n', '        while (_rId <= curRoundId) {\n', '            _sum = _sum.add(getCurEarlyIncomeByAddressRound(_buyer, _rId));\n', '            _rId++;\n', '        }\n', '        return _sum;\n', '    }\n', '\n', '    function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _rEarlyIncome = getEarlyIncomeByAddressRound(_buyer, _rId);\n', '        return _rEarlyIncome.sub(round[_rId].pEarlyIncomeClaimed[_buyer]);\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////\n', '\n', '    function getEstKeyBlockNr(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].keyBlockNr;\n', '    }\n', '\n', '    function getKeyBlockNr(uint256 _estKeyBlockNr)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        require(block.number > _estKeyBlockNr, "blockHash not avaiable");\n', '        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\n', '        return _estKeyBlockNr + jump;\n', '    }\n', '\n', '    // Logs\n', '    function getCurRoundId()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return curRoundId;\n', '    }\n', '\n', '    function getTPrice()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getTPrice(curRTicketSum);\n', '    }\n', '\n', '    function getTMul()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getTMul(curRTicketSum);\n', '    }\n', '\n', '    function getPMul()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Helper.getEarlyIncomeMul(curRTicketSum);\n', '    }\n', '\n', '    function getPTicketSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].pTicketSum[_buyer];\n', '    }\n', '\n', '    function getTicketSumToRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].ticketSum;\n', '    }\n', '\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].pInvestedSum[_buyer];\n', '    }\n', '\n', '    function getInvestedSumToRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return round[_rId].investedSum;\n', '    }\n', '\n', '    function getPSlotLength(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pSlot[_sender].length;\n', '    }\n', '\n', '    function getSlotLength()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return slot.length;\n', '    }\n', '\n', '    function getSlotId(address _sender, uint256 i)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pSlot[_sender][i];\n', '    }\n', '\n', '    function getSlotInfo(uint256 _slotId)\n', '        public\n', '        view\n', '        returns(address, uint256[4], string)\n', '    {\n', '        Slot memory _slot = slot[_slotId];\n', '        return (_slot.buyer,[_slot.rId, _slot.tNumberFrom, _slot.tNumberTo, _slot.ethAmount], Helper.uintToString(_slot.salt));\n', '    }\n', '\n', '    function cashoutable(address _address) \n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        // need 1 ticket or in waiting time to start new round\n', '        return (round[curRoundId].pTicketSum[_address] > 0) || (round[curRoundId].startTime > block.timestamp);\n', '    }\n', '\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) \n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(_lastRoundId >= 18 && _lastRoundId > curRoundId, "too early to end");\n', '        require(lastRoundId == 88888888, "already set");\n', '        lastRoundId = _lastRoundId;\n', '    }\n', '}']
