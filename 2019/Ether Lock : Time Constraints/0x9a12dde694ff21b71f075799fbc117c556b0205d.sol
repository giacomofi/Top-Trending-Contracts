['pragma solidity ^0.5.1;\n', '\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '//This proxy contract is necessary because our oracle uses the Transfer event to detect incoming transfers, and can&#39;t distiguish between transfer and transferFrom&#39;\n', '//users call contribute on the proxy, and the proxy transfers UCASH from the user to itself, then transfers UCASH to the ucollateral contract\n', '//this allows us to differentiate between contributions that use approve and transfer from, and contributions that occur when ucash is sent directly to the ucollateral contract.\n', 'contract ProxyContributor{\n', '\n', '    UCOLLATERAL U;\n', '\n', '    address public UCASHAddress;\n', '\n', '    constructor (address _UCASHAddress) public{\n', '        U = UCOLLATERAL(msg.sender);\n', '        UCASHAddress = _UCASHAddress;\n', '    }\n', '\n', '    function contribute() public {\n', '        uint allowedAmount = ERC20(UCASHAddress).allowance(msg.sender,address(this));\n', '        ERC20(UCASHAddress).transferFrom(msg.sender,address(this),allowedAmount);\n', '        ERC20(UCASHAddress).transfer(address(U),allowedAmount);\n', '\n', '        U.contributeByProxyContract(msg.sender,allowedAmount);\n', '\n', '    }\n', '}\n', '\n', 'contract UCOLLATERAL {\n', '    uint public StageAmount = 10**6*10**8;  //1 million UCASH per stage\n', '    uint public RemainingInStage = StageAmount; //Amount remaining in current stage\n', '    uint BPNumerator = 21; // Bounty Percentage Numerator\n', '    uint BPDenominator = 10000; // Bounty Percentage Denominator\n', '    uint public StageValue = BPNumerator*BountyPool/BPDenominator;  // Total value allocated to current Stage\n', '    uint public BountyPool; //Total UCASH available in the Bounty Pool\n', '\n', '    uint periods = 91;              //how many periods this loan lasts\n', '    uint period = 1 days;       //period length\n', '\n', '    uint specialReclaimValue = 110000; //Special Value to send contract, that triggers reclaim of loan. currently 0.0011 UCASH or 110000 wei\n', '\n', '    uint recirculationIndex; //Index to keep track of which loans have been auto reclaimed. For lateFeesToBountyPool function. Loops back to 0 when it reaches the end of ListofLoans\n', '\n', '    address public UCASHAddress;\n', '    uint decimals = 8;\n', '\n', '    address public owner;\n', '    ProxyContributor P;\n', '    address public Proxy;\n', '\n', '\n', 'modifier onlyOwner()\n', '    {\n', '        require(msg.sender==owner);\n', '        _;\n', '    }\n', '\n', '    event Contribution(address contributor, uint amountContributed, uint amountBounty, uint maturationDate);\n', '    event Reclaimed(address contributor, uint amountReclaimed, uint amountPenalty);\n', '\n', 'struct Loan {\n', '    uint totalContribution;\n', '    uint bounty;\n', '    uint contractTime;\n', '    uint start;\n', '    uint recirculated;\n', '    uint arrayIndex;\n', '}\n', '\n', 'mapping(address=>Loan) public Loans;\n', 'address[] public ListofLoans;\n', '\n', 'constructor() public {\n', '    CalculateStageValue();\n', '    owner = msg.sender;\n', '    UCASHAddress = 0x92e52a1A235d9A103D970901066CE910AAceFD37;\n', '\n', '    P = new ProxyContributor(UCASHAddress);\n', '    Proxy = address(P);\n', '}\n', '\n', '//Reclaim your loan by sending a transaction\n', 'function() external payable{\n', '    if(loanMatured(msg.sender) || msg.value == specialReclaimValue){\n', '        reclaimInternal(msg.sender);\n', '    }\n', '}\n', '\n', 'function contributeByProxyContract(address contributor, uint contribution) public {\n', '    require(msg.sender==Proxy);\n', '    contributeInternal(contributor,contribution);\n', '}\n', '\n', '//oracle calls this function everytime a UCASH transfer is made to the contract address\n', 'function contributeByOracle(address contributor, uint contribution) public onlyOwner{\n', '    contributeInternal(contributor,contribution);\n', '}\n', 'function contributeInternal(address contributor, uint contribution) internal returns(bool){\n', '    if (loanMatured(contributor) || contribution == specialReclaimValue){\n', '        reclaimInternal(contributor);\n', '    }\n', '\n', '    Loan memory memLoan = Loans[contributor];\n', '\n', '    if (memLoan.start == 0){\n', '        memLoan.start = now;\n', '        memLoan.contractTime = periods * period;\n', '        memLoan.arrayIndex = ListofLoans.length;\n', '        ListofLoans.push(contributor);\n', '    }\n', '\n', '    uint timeElapsed = now - memLoan.start;\n', '    uint rollBackTime = timeElapsed*contribution/(memLoan.totalContribution+contribution);\n', '\n', '    uint Bounty;\n', '\n', '    uint amountMemory = contribution;\n', '\n', '    while(amountMemory > RemainingInStage){\n', '        Bounty += RemainingInStage*StageValue/StageAmount;\n', '        amountMemory -=RemainingInStage;\n', '        BountyPool -= RemainingInStage*StageValue/StageAmount;\n', '\n', '        CalculateStageValue();\n', '        RemainingInStage = StageAmount;\n', '    }\n', '\n', '    Bounty += amountMemory*StageValue/StageAmount;\n', '    RemainingInStage -= amountMemory;\n', '    BountyPool -= amountMemory*StageValue/StageAmount;\n', '\n', '    memLoan.totalContribution += contribution;\n', '    memLoan.bounty += Bounty;\n', '    memLoan.start += rollBackTime;\n', '    Loans[contributor] = memLoan;\n', '\n', '    emit Contribution(contributor, contribution, Bounty, memLoan.start+memLoan.contractTime);\n', '}\n', '\n', 'function reclaim() public{\n', '    reclaimInternal(msg.sender);\n', '}\n', '\n', 'function reclaimInternal(address contributor) internal{\n', '\n', '    uint UCASHtoSend;\n', '    uint penalty;\n', '\n', '    (UCASHtoSend,penalty) = ifClaimedNow(contributor);\n', '\n', '    transferUCASH(contributor,UCASHtoSend);\n', '\n', '    if(!loanMatured(contributor)){\n', '        BountyPool += Loans[contributor].bounty;\n', '    }\n', '\n', '    BountyPool += penalty;\n', '    BountyPool -= Loans[contributor].recirculated;\n', '\n', '    //re-arrange Array. Replace current element with last element, and delete last element.\n', '    uint currentArrayIndex = Loans[contributor].arrayIndex;\n', '    address replacingLoan = ListofLoans[ListofLoans.length - 1];\n', '    Loans[replacingLoan].arrayIndex = currentArrayIndex;\n', '    ListofLoans[currentArrayIndex] = replacingLoan;\n', '\n', '    delete Loans[contributor];\n', '    ListofLoans.length--;\n', '\n', '    CalculateStageValue();\n', '}\n', '\n', 'function ifClaimedNowPublic() public view returns(uint,uint){\n', '    return ifClaimedNow(msg.sender);\n', '}\n', '\n', 'function ifClaimedNow(address contributor) public view returns(uint ,uint){\n', '    Loan memory memLoan = Loans[contributor];\n', '    if (memLoan.start == 0){\n', '        return (0,0);\n', '    }\n', '\n', '    uint CancellationFee; //fraction out of 1000000\n', '    uint penalty;\n', '\n', '    if (!loanMatured(contributor)){\n', '         if((now - memLoan.start) <= 3 days){\n', '            CancellationFee = 0;\n', '       }else {\n', '            uint elapsedPeriods = (now-memLoan.start)/(period);\n', '            CancellationFee = 210000*(periods-elapsedPeriods)/periods;\n', '       }\n', '        penalty = (memLoan.totalContribution*CancellationFee)/1000000;\n', '        memLoan.bounty = 0;\n', '    } else{\n', '        penalty = getLateFee(contributor);\n', '    }\n', '\n', '    uint UCASHtoSend = memLoan.totalContribution + memLoan.bounty - penalty;\n', '    return (UCASHtoSend,penalty);\n', '}\n', '\n', 'function CalculateStageValue() internal{\n', '    StageValue = BPNumerator*BountyPool/BPDenominator;\n', '}\n', '\n', 'function loanMatured(address contributor) private view returns (bool){\n', '    if(Loans[contributor].start == 0){\n', '        return false;\n', '    }\n', '\n', '    if((now > (Loans[contributor].start+Loans[contributor].contractTime))){\n', '        return true;\n', '    } else {\n', '        return false;\n', '    }\n', '}\n', '\n', 'function contractBalance() public view returns(uint){\n', '    return ERC20(UCASHAddress).balanceOf(address(this));\n', '}\n', '\n', 'function secondsLeftPublic() public view returns(uint){\n', '    return secondsLeft(msg.sender);\n', '}\n', '\n', 'function secondsLeft(address contributor) public view returns(uint){\n', '    if(loanMatured(contributor)){\n', '        return 0;\n', '    } else if(Loans[contributor].start ==0) {\n', '        return 0;\n', '    } else{\n', '        return (Loans[contributor].start + Loans[contributor].contractTime - now);\n', '    }\n', '}\n', '\n', 'function getLateFee(address contributor) public view returns(uint){\n', '    require(loanMatured(contributor));\n', '    Loan memory memLoan = Loans[contributor];\n', '    uint totalReward = memLoan.totalContribution + memLoan.bounty;\n', '    uint endDate = memLoan.start + memLoan.contractTime;\n', '\n', '    uint periodsLateBy =  (now - endDate)/period;\n', '\n', '\n', '    uint totalPenalty;\n', '    uint periodPenalty;\n', '        if (periodsLateBy>=2000){\n', '            totalPenalty = totalReward;\n', '        } else if (periodsLateBy<=10){\n', '            return(0);\n', '        } else{\n', '        uint i;\n', '        while(i++<uint(periodsLateBy-10)){\n', '            periodPenalty = totalReward*7/1000;\n', '                totalPenalty += periodPenalty; //penalize 2.1% of remaining reward every month;\n', '                totalReward -= periodPenalty;\n', '        }\n', '        }\n', '\n', '        return(totalPenalty);\n', '}\n', '\n', 'function isLateBy(address contributor) public view returns(uint){\n', '    if(Loans[contributor].start == 0){\n', '        return 0;\n', '    }\n', '     uint endDate = Loans[contributor].start + Loans[contributor].contractTime;\n', '     if(now<endDate){\n', '        return 0;\n', '     }else{\n', '        return  (now - endDate)/period;\n', '     }\n', '\n', '}\n', '\n', 'function numLoans() public view returns (uint) {\n', '    return ListofLoans.length;\n', '}\n', '\n', 'function nowwww() public view  returns(uint){\n', '   return now;\n', '}\n', '\n', 'function calculateBounty(uint contribution) public view returns(uint){\n', '    uint Bounty;\n', '    uint _BountyPool = BountyPool;\n', '    uint _RemainingInStage = RemainingInStage;\n', '    uint _StageValue = StageValue;\n', '\n', '    while(contribution > _RemainingInStage){\n', '        Bounty += _RemainingInStage*_StageValue/StageAmount;\n', '        contribution -= _RemainingInStage;\n', '        _BountyPool -= _RemainingInStage*_StageValue/StageAmount;\n', '\n', '        _StageValue = BPNumerator*_BountyPool/BPDenominator;\n', '        _RemainingInStage = StageAmount;\n', '    }\n', '\n', '    Bounty += contribution*_StageValue/StageAmount;\n', '\n', '    return Bounty;\n', '}\n', '\n', '\n', '\n', 'function addFunds(uint _amount) public payable onlyOwner{\n', '    BountyPool+= _amount;\n', '    CalculateStageValue();\n', '}\n', '\n', 'function removeFunds(uint _amount) onlyOwner public {\n', '    BountyPool -= _amount;\n', '    transferUCASH(owner,_amount);\n', '    CalculateStageValue();\n', '}\n', '\n', '\n', 'function transferUCASH(address _recipient, uint _amount) private{\n', '    ERC20(UCASHAddress).transfer(_recipient,_amount);\n', '}\n', '\n', 'function calculateAllReclaimedNow() public view returns(uint){\n', '    uint total;\n', '    uint i;\n', '    for(i=0;i<ListofLoans.length;i++){\n', '        uint reclaimable;\n', '        (reclaimable,) = ifClaimedNow(ListofLoans[i]);\n', '        total += reclaimable;\n', '    }\n', '    return total;\n', '}\n', '\n', 'function CalculateAllocatedUcash() public view returns(uint){\n', '     uint total;\n', '    uint i;\n', '    for(i=0;i<ListofLoans.length;i++){\n', '        total += Loans[ListofLoans[i]].totalContribution + Loans[ListofLoans[i]].bounty;\n', '    }\n', '    return total;\n', '}\n', '\n', '\n', '\n', '//Recirculate All Late fees to the bountyPool, and AutoReclaim loans more than 100 periods late.\n', 'function recirculateLateFees(uint iterations) public {\n', '    if(recirculationIndex>=ListofLoans.length){\n', '        recirculationIndex = 0;\n', '    }\n', '    uint i = recirculationIndex;\n', '    uint j;\n', '    if (i+iterations>ListofLoans.length){\n', '        j = ListofLoans.length;\n', '    } else{\n', '        j = i + iterations;\n', '    }\n', '    for(i;i<j;i++){\n', '        address contributor = ListofLoans[i];\n', '        if(isLateBy(contributor)>=600){\n', '            reclaimInternal(contributor);       //autoreclaim the loan if the loan is late by more than 100 periods\n', '            //reclaimInternal deletes ListofLoans[i] and moves last element of ListofLoans into ListofLoans[i]\n', '            i--; j--;                           //shift the loop back by one interval, shorten loop by one interval.  Number of loops remains the same.\n', '        }else if(loanMatured(contributor)){\n', '             uint amountToRecirculate = getLateFee(contributor) - Loans[contributor].recirculated;\n', '             Loans[contributor].recirculated += amountToRecirculate;\n', '             BountyPool += amountToRecirculate;\n', '           }\n', '        }\n', '\n', '    recirculationIndex = j;\n', '}\n', '\n', '    function killswitch() public onlyOwner returns (bool){\n', '        uint i;\n', '        while (i++<500 && ListofLoans.length>0){\n', '            address contributor = ListofLoans[ListofLoans.length-1];\n', '            Loan memory memLoan = Loans[contributor];\n', '            ERC20(UCASHAddress).transfer(contributor, memLoan.totalContribution-memLoan.recirculated);\n', '            ListofLoans.length--;\n', '        }\n', '\n', '    if(ListofLoans.length==0){\n', '        ERC20(UCASHAddress).transfer(owner,contractBalance());\n', '        selfdestruct(address(this));\n', '\n', '    } else {\n', '        return false;\n', '    }\n', '}\n', '}']