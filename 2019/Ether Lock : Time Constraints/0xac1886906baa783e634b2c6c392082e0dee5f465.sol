['pragma solidity 0.5.4;\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    event NewOwner(address indexed old, address indexed current);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address _new)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_new != address(0));\n', '        owner = _new;\n', '        emit NewOwner(owner, _new);\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    \n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '    function safeMul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(\n', '            c / a == b,\n', '            "UINT256_OVERFLOW"\n', '        );\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(\n', '            b <= a,\n', '            "UINT256_UNDERFLOW"\n', '        );\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        require(\n', '            c >= a,\n', '            "UINT256_OVERFLOW"\n', '        );\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract ProgressiveUnlockWallet is Ownable, SafeMath {\n', '\n', '    mapping(address => VestingSchedule) public schedules;        // vesting schedules for given addresses\n', '    mapping(address => address) public addressChangeRequests;    // requested address changes\n', '\n', '    IERC20 vestingToken;\n', '\n', '    event VestingScheduleRegistered(\n', '        address indexed registeredAddress,\n', '        address depositor,\n', '        uint startTimeInSec,\n', '        uint cliffTimeInSec,\n', '        uint endTimeInSec,\n', '        uint totalAmount\n', '    );\n', '\n', '    event VestingScheduleConfirmed(\n', '        address indexed registeredAddress,\n', '        address depositor,\n', '        uint startTimeInSec,\n', '        uint cliffTimeInSec,\n', '        uint endTimeInSec,\n', '        uint totalAmount\n', '    );\n', '\n', '    event Withdrawal(\n', '        address indexed registeredAddress,\n', '        uint amountWithdrawn\n', '    );\n', '\n', '    event AddressChangeRequested(\n', '        address indexed oldRegisteredAddress,\n', '        address indexed newRegisteredAddress\n', '    );\n', '\n', '    event AddressChangeConfirmed(\n', '        address indexed oldRegisteredAddress,\n', '        address indexed newRegisteredAddress\n', '    );\n', '\n', '    struct VestingSchedule {\n', '        uint startTimeInSec;\n', '        uint cliffTimeInSec;\n', '        uint endTimeInSec;\n', '        uint totalAmount;\n', '        uint totalAmountWithdrawn;\n', '        address depositor;\n', '        bool isConfirmed;\n', '    }\n', '\n', '    modifier addressRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier addressNotRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier vestingScheduleConfirmed(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.isConfirmed);\n', '        _;\n', '    }\n', '\n', '    modifier vestingScheduleNotConfirmed(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(!vestingSchedule.isConfirmed);\n', '        _;\n', '    }\n', '\n', '    modifier pendingAddressChangeRequest(address target) {\n', '        require(addressChangeRequests[target] != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier pastCliffTime(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(block.timestamp > vestingSchedule.cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier validVestingScheduleTimes(uint startTimeInSec, uint cliffTimeInSec, uint endTimeInSec) {\n', '        require(cliffTimeInSec >= startTimeInSec);\n', '        require(endTimeInSec >= cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier addressNotNull(address target) {\n', '        require(target != address(0));\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a vesting token to the wallet.\n', '    /// @param _vestingToken Token that will be vested.\n', '    constructor(address _vestingToken) public {\n', '        vestingToken = IERC20(_vestingToken);\n', '    }\n', '\n', '    /// @dev Registers a vesting schedule to an address.\n', '    /// @param _addressToRegister The address that is allowed to withdraw vested tokens for this schedule.\n', '    /// @param _depositor Address that will be depositing vesting token.\n', '    /// @param _startTimeInSec The time in seconds that vesting began.\n', '    /// @param _cliffTimeInSec The time in seconds that tokens become withdrawable.\n', '    /// @param _endTimeInSec The time in seconds that vesting ends.\n', '    /// @param _totalAmount The total amount of tokens that the registered address can withdraw by the end of the vesting period.\n', '    function registerVestingSchedule(\n', '        address _addressToRegister,\n', '        address _depositor,\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount\n', '    )\n', '        public\n', '        onlyOwner\n', '        addressNotNull(_depositor)\n', '        vestingScheduleNotConfirmed(_addressToRegister)\n', '        validVestingScheduleTimes(_startTimeInSec, _cliffTimeInSec, _endTimeInSec)\n', '    {\n', '        schedules[_addressToRegister] = VestingSchedule({\n', '            startTimeInSec: _startTimeInSec,\n', '            cliffTimeInSec: _cliffTimeInSec,\n', '            endTimeInSec: _endTimeInSec,\n', '            totalAmount: _totalAmount,\n', '            totalAmountWithdrawn: 0,\n', '            depositor: _depositor,\n', '            isConfirmed: false\n', '        });\n', '\n', '        emit VestingScheduleRegistered(\n', '            _addressToRegister,\n', '            _depositor,\n', '            _startTimeInSec,\n', '            _cliffTimeInSec,\n', '            _endTimeInSec,\n', '            _totalAmount\n', '        );\n', '    }\n', '\n', '    /// @dev Confirms a vesting schedule and deposits necessary tokens. Throws if deposit fails or schedules do not match.\n', '    /// @param _startTimeInSec The time in seconds that vesting began.\n', '    /// @param _cliffTimeInSec The time in seconds that tokens become withdrawable.\n', '    /// @param _endTimeInSec The time in seconds that vesting ends.\n', '    /// @param _totalAmount The total amount of tokens that the registered address can withdraw by the end of the vesting period.\n', '    function confirmVestingSchedule(\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount\n', '    )\n', '        public\n', '        addressRegistered(msg.sender)\n', '        vestingScheduleNotConfirmed(msg.sender)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[msg.sender];\n', '\n', '        require(vestingSchedule.startTimeInSec == _startTimeInSec);\n', '        require(vestingSchedule.cliffTimeInSec == _cliffTimeInSec);\n', '        require(vestingSchedule.endTimeInSec == _endTimeInSec);\n', '        require(vestingSchedule.totalAmount == _totalAmount);\n', '\n', '        vestingSchedule.isConfirmed = true;\n', '        require(vestingToken.transferFrom(vestingSchedule.depositor, address(this), _totalAmount));\n', '\n', '        emit VestingScheduleConfirmed(\n', '            msg.sender,\n', '            vestingSchedule.depositor,\n', '            _startTimeInSec,\n', '            _cliffTimeInSec,\n', '            _endTimeInSec,\n', '            _totalAmount\n', '        );\n', '    }\n', '\n', '    /// @dev Allows a registered address to withdraw tokens that have already been vested.\n', '    function withdraw()\n', '        public\n', '        vestingScheduleConfirmed(msg.sender)\n', '        pastCliffTime(msg.sender)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[msg.sender];\n', '\n', '        uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '        uint amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '        vestingSchedule.totalAmountWithdrawn = totalAmountVested;\n', '\n', '        if (amountWithdrawable > 0) {\n', '            require(vestingToken.transfer(msg.sender, amountWithdrawable));\n', '            emit Withdrawal(msg.sender, amountWithdrawable);\n', '        }\n', '    }\n', '\n', '    /// @dev Allows a registered address to request an address change.\n', '    /// @param _newRegisteredAddress Desired address to update to.\n', '    function requestAddressChange(address _newRegisteredAddress)\n', '        public\n', '        vestingScheduleConfirmed(msg.sender)\n', '        addressNotRegistered(_newRegisteredAddress)\n', '        addressNotNull(_newRegisteredAddress)\n', '    {\n', '        addressChangeRequests[msg.sender] = _newRegisteredAddress;\n', '        emit AddressChangeRequested(msg.sender, _newRegisteredAddress);\n', '    }\n', '\n', '    /// @dev Confirm an address change and migrate vesting schedule to new address.\n', '    /// @param _oldRegisteredAddress Current registered address.\n', '    /// @param _newRegisteredAddress Address to migrate vesting schedule to.\n', '    function confirmAddressChange(address _oldRegisteredAddress, address _newRegisteredAddress)\n', '        public\n', '        onlyOwner\n', '        pendingAddressChangeRequest(_oldRegisteredAddress)\n', '        addressNotRegistered(_newRegisteredAddress)\n', '    {\n', '        address newRegisteredAddress = addressChangeRequests[_oldRegisteredAddress];\n', '        require(newRegisteredAddress == _newRegisteredAddress);    // prevents race condition\n', '\n', '        VestingSchedule memory vestingSchedule = schedules[_oldRegisteredAddress];\n', '        schedules[newRegisteredAddress] = vestingSchedule;\n', '\n', '        delete schedules[_oldRegisteredAddress];\n', '        delete addressChangeRequests[_oldRegisteredAddress];\n', '\n', '        emit AddressChangeConfirmed(_oldRegisteredAddress, _newRegisteredAddress);\n', '    }\n', '\n', '    /// @dev Calculates the total tokens that have been vested for a vesting schedule, assuming the schedule is past the cliff.\n', '    /// @param vestingSchedule Vesting schedule used to calculate vested tokens.\n', '    /// @return Total tokens vested for a vesting schedule.\n', '    function getTotalAmountVested(VestingSchedule memory vestingSchedule)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        if (block.timestamp >= vestingSchedule.endTimeInSec) return vestingSchedule.totalAmount;\n', '\n', '        uint timeSinceStartInSec = safeSub(block.timestamp, vestingSchedule.startTimeInSec);\n', '        uint totalVestingTimeInSec = safeSub(vestingSchedule.endTimeInSec, vestingSchedule.startTimeInSec);\n', '        uint totalAmountVested = safeDiv(\n', '            safeMul(timeSinceStartInSec, vestingSchedule.totalAmount),\n', '            totalVestingTimeInSec\n', '        );\n', '\n', '        return totalAmountVested;\n', '    }\n', '}']