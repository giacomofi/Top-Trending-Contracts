['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an account access to this role\n', '   */\n', '  function add(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(!has(role, account));\n', '\n', '    role.bearer[account] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an account's access to this role\n", '   */\n', '  function remove(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(has(role, account));\n', '\n', '    role.bearer[account] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an account has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address account)\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(account != address(0));\n', '    return role.bearer[account];\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract PauserRole {\n', '  using Roles for Roles.Role;\n', '\n', '  event PauserAdded(address indexed account);\n', '  event PauserRemoved(address indexed account);\n', '\n', '  Roles.Role private pausers;\n', '\n', '  constructor() internal {\n', '    _addPauser(msg.sender);\n', '  }\n', '\n', '  modifier onlyPauser() {\n', '    require(isPauser(msg.sender));\n', '    _;\n', '  }\n', '\n', '  function isPauser(address account) public view returns (bool) {\n', '    return pausers.has(account);\n', '  }\n', '\n', '  function addPauser(address account) public onlyPauser {\n', '    _addPauser(account);\n', '  }\n', '\n', '  function renouncePauser() public {\n', '    _removePauser(msg.sender);\n', '  }\n', '\n', '  function _addPauser(address account) internal {\n', '    pausers.add(account);\n', '    emit PauserAdded(account);\n', '  }\n', '\n', '  function _removePauser(address account) internal {\n', '    pausers.remove(account);\n', '    emit PauserRemoved(account);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '  event Paused(address account);\n', '  event Unpaused(address account);\n', '\n', '  bool private _paused;\n', '\n', '  constructor() internal {\n', '    _paused = false;\n', '  }\n', '\n', '  /**\n', '   * @return true if the contract is paused, false otherwise.\n', '   */\n', '  function paused() public view returns(bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyPauser whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyPauser whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Elliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECDSA {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes signature)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (signature.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(signature, 0x20))\n', '      s := mload(add(signature, 0x40))\n', '      v := byte(0, mload(add(signature, 0x60)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', '\n', 'contract BMng is Pausable, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum TokenStatus {\n', '    Unknown,\n', '    Active,\n', '    Suspended\n', '  }\n', '\n', '  struct Token {\n', '    TokenStatus status;\n', '    uint256 rewardRateNumerator;\n', '    uint256 rewardRateDenominator;\n', '    uint256 burned;\n', '    uint256 burnedAccumulator;\n', '    uint256 suspiciousVolume; // provided during registration\n', '  }\n', '\n', '  event Auth(\n', '    address indexed burner,\n', '    address indexed partner\n', '  );\n', '\n', '  event Burn(\n', '    address indexed token,\n', '    address indexed burner,\n', '    address partner,\n', '    uint256 value,\n', '    uint256 bValue,\n', '    uint256 bValuePartner\n', '  );\n', '\n', '  event DiscountUpdate(\n', '    uint256 discountNumerator,\n', '    uint256 discountDenominator,\n', '    uint256 balanceThreshold\n', '  );\n', '\n', '  address constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n', '\n', '  // Lifetime parameters (set on initialization)\n', '  string public name;\n', '  IERC20 bToken; // BurnToken address\n', '  uint256 discountNumeratorMul;\n', '  uint256 discountDenominatorMul;\n', '  uint256 bonusNumerator;\n', '  uint256 bonusDenominator;\n', '  uint256 public initialBlockNumber;\n', '\n', '  // Evolving parameters\n', '  uint256 discountNumerator;\n', '  uint256 discountDenominator;\n', '  uint256 balanceThreshold;\n', '\n', '  // Managable parameters \n', '  address registrator;\n', '  address defaultPartner;\n', '  uint256 partnerRewardRateNumerator;\n', '  uint256 partnerRewardRateDenominator;\n', '  bool permissionRequired;\n', '\n', '  mapping (address => Token) public tokens;\n', '  mapping (address => address) referalPartners; // Users associated with referrals\n', '  mapping (address => mapping (address => uint256)) burnedByTokenUser; // Counters\n', '  mapping (bytes6 => address) refLookup; // Reference codes\n', '  mapping (address => bool) public shouldGetBonus; // Bonuses\n', '  mapping (address => uint256) public nonces; // Nonces for permissions\n', '\n', '  constructor(\n', '    address bTokenAddress, \n', '    address _registrator, \n', '    address _defaultPartner,\n', '    uint256 initialBalance\n', '  ) \n', '  public \n', '  {\n', '    name = "Burn Token Management Contract v0.3";\n', '    registrator = _registrator;\n', '    defaultPartner = _defaultPartner;\n', '    bToken = IERC20(bTokenAddress);\n', '    initialBlockNumber = block.number;\n', '\n', '    // Initially no permission needed for each burn\n', '    permissionRequired = false;\n', '\n', '    // Formal referals for registrator and defaultPartner\n', '    referalPartners[registrator] = burnAddress;\n', '    referalPartners[defaultPartner] = burnAddress;\n', '\n', '    // Reward rate 15% for each referral burning\n', '    partnerRewardRateNumerator = 15;\n', '    partnerRewardRateDenominator = 100;\n', '\n', '    // 20% bonus for using referal link\n', '    bonusNumerator = 20;\n', '    bonusDenominator = 100;\n', '\n', '    // discount 5% each time when when 95% of the balance spent\n', '    discountNumeratorMul = 95;\n', '    discountDenominatorMul = 100;\n', '\n', '    discountNumerator = 1;\n', '    discountDenominator = 1;\n', '    balanceThreshold = initialBalance.mul(discountNumeratorMul).div(discountDenominatorMul);\n', '  }\n', '\n', '  // --------------------------------------------------------------------------\n', '  // Administration fuctionality\n', '  \n', '  function claimBurnTokensBack(address to) public onlyOwner {\n', '    // This is necessary to finalize the contract lifecicle \n', '    uint256 remainingBalance = bToken.balanceOf(address(this));\n', '    bToken.transfer(to, remainingBalance);\n', '  }\n', '\n', '  function registerToken(\n', '    address tokenAddress, \n', '    uint256 suspiciousVolume,\n', '    uint256 rewardRateNumerator,\n', '    uint256 rewardRateDenominator,\n', '    bool activate\n', '  ) \n', '    public \n', '    onlyOwner \n', '  {\n', '    // require(tokens[tokenAddress].status == TokenStatus.Unknown, "Cannot register more than one time");\n', '    Token memory token;\n', '    if (activate) {\n', '      token.status = TokenStatus.Active;\n', '    } else {\n', '      token.status = TokenStatus.Suspended;\n', '    }    \n', '    token.rewardRateNumerator = rewardRateNumerator;\n', '    token.rewardRateDenominator = rewardRateDenominator;\n', '    token.suspiciousVolume = suspiciousVolume;\n', '    tokens[tokenAddress] = token;\n', '  }\n', '\n', '  function changeRegistrator(address newRegistrator) public onlyOwner {\n', '    registrator = newRegistrator;\n', '  }\n', '\n', '  function changeDefaultPartnerAddress(address newDefaultPartner) public onlyOwner {\n', '    defaultPartner = newDefaultPartner;\n', '  }\n', '\n', '  \n', '  function setRewardRateForToken(\n', '    address tokenAddress,\n', '    uint256 rewardRateNumerator,\n', '    uint256 rewardRateDenominator\n', '  )\n', '    public \n', '    onlyOwner \n', '  {\n', '    require(tokens[tokenAddress].status != TokenStatus.Unknown, "Token should be registered first");\n', '    tokens[tokenAddress].rewardRateNumerator = rewardRateNumerator;\n', '    tokens[tokenAddress].rewardRateDenominator = rewardRateDenominator;\n', '  }\n', '  \n', '\n', '  function setPartnerRewardRate(\n', '    uint256 newPartnerRewardRateNumerator,\n', '    uint256 newPartnerRewardRateDenominator\n', '  )\n', '    public \n', '    onlyOwner \n', '  {\n', '    partnerRewardRateNumerator = newPartnerRewardRateNumerator;\n', '    partnerRewardRateDenominator = newPartnerRewardRateDenominator;\n', '  }\n', '\n', '  function setPermissionRequired(bool state) public onlyOwner {\n', '    permissionRequired = state;\n', '  }\n', '\n', '  function suspend(address tokenAddress) public onlyOwner {\n', '    require(tokens[tokenAddress].status != TokenStatus.Unknown, "Token should be registered first");\n', '    tokens[tokenAddress].status = TokenStatus.Suspended;\n', '  }\n', '\n', '  function unSuspend(address tokenAddress) public onlyOwner {\n', '    require(tokens[tokenAddress].status != TokenStatus.Unknown, "Token should be registered first");\n', '    tokens[tokenAddress].status = TokenStatus.Active;\n', '    tokens[tokenAddress].burnedAccumulator = 0;\n', '  }\n', '\n', '  function activate(address tokenAddress) public onlyOwner {\n', '    require(tokens[tokenAddress].status != TokenStatus.Unknown, "Token should be registered first");\n', '    tokens[tokenAddress].status = TokenStatus.Active;\n', '  }\n', '\n', '  // END of Administration fuctionality\n', '  // --------------------------------------------------------------------------\n', '\n', '  modifier whenNoPermissionRequired() {\n', '    require(!isPermissionRequired(), "Need a permission");\n', '    _;\n', '  }\n', '\n', '  function isPermissionRequired() public view returns (bool) {\n', '    // if burn can only occure by signed permission\n', '    return permissionRequired;\n', '  }\n', '\n', '  function isAuthorized(address user) public view whenNotPaused returns (bool) {\n', '    address partner = referalPartners[user];\n', '    return partner != address(0);\n', '  }\n', '\n', '  function amountBurnedTotal(address tokenAddress) public view returns (uint256) {\n', '    return tokens[tokenAddress].burned;\n', '  }\n', '\n', '  function amountBurnedByUser(address tokenAddress, address user) public view returns (uint256) {\n', '    return burnedByTokenUser[tokenAddress][user];\n', '  }\n', '\n', '  // Ref code\n', '  function getRefByAddress(address user) public pure returns (bytes6) {\n', '    /* \n', '      We use Base58 encoding and want refcode length to be 8 symbols \n', '      bits = log2(58) * 8 = 46.86384796102058 = 40 + 6.86384796102058\n', '      2^(40 + 6.86384796102058) = 0x100^5 * 116.4726943 ~ 0x100^5 * 116\n', '      CEIL(47 / 8) = 6\n', '      Output: bytes6 (48 bits)\n', '      In such case for 10^6 records we have 0.39% hash collision probability \n', '      (see: https://preshing.com/20110504/hash-collision-probabilities/)\n', '    */ \n', '    bytes32 dataHash = keccak256(abi.encodePacked(user, "BUTK"));\n', '    bytes32 tmp = bytes32(uint256(dataHash) % uint256(116 * 0x10000000000));\n', '    return bytes6(tmp << 26 * 8);\n', '  }\n', '\n', '  function getAddressByRef(bytes6 ref) public view returns (address) {\n', '    return refLookup[ref];\n', '  }\n', '\n', '  function saveRef(address user) private returns (bool) {\n', '    require(user != address(0), "Should not be zero address");\n', '    bytes6 ref = getRefByAddress(user);\n', '    refLookup[ref] = user;\n', '    return true;\n', '  }\n', '\n', '  function checkSignature(bytes memory sig, address user) public view returns (bool) {\n', '    bytes32 dataHash = keccak256(abi.encodePacked(user));\n', '    return (ECDSA.recover(dataHash, sig) == registrator);\n', '  }\n', '\n', '  function checkPermissionSignature(\n', '    bytes memory sig, \n', '    address user, \n', '    address tokenAddress,\n', '    uint256 value,\n', '    uint256 nonce\n', '  ) \n', '    public view returns (bool) \n', '  {\n', '    bytes32 dataHash = keccak256(abi.encodePacked(user, tokenAddress, value, nonce));\n', '    return (ECDSA.recover(dataHash, sig) == registrator);\n', '  }\n', '\n', '  function authorizeAddress(bytes memory authSignature, bytes6 ref) public whenNotPaused returns (bool) {\n', '    // require(false, "Test fail");\n', '    require(checkSignature(authSignature, msg.sender) == true, "Authorization should be signed by registrator");\n', '    require(isAuthorized(msg.sender) == false, "No need to authorize more then once");\n', '    address refAddress = getAddressByRef(ref);\n', '    address partner = (refAddress == address(0)) ? defaultPartner : refAddress;\n', '\n', '    // Create ref code (register as a partner)\n', '    saveRef(msg.sender);\n', '\n', '    referalPartners[msg.sender] = partner;\n', '\n', '    // Only if ref code is used authorized to get extra bonus\n', '    if (partner != defaultPartner) {\n', '      shouldGetBonus[msg.sender] = true;\n', '    }\n', '\n', '    emit Auth(msg.sender, partner);\n', '\n', '    return true;\n', '  }\n', '\n', '  function suspendIfNecessary(address tokenAddress) private returns (bool) {\n', '    // When 10% of totalSupply is burned suspend the token just in case \n', '    // there is a chance that its contract is broken\n', '    if (tokens[tokenAddress].burnedAccumulator > tokens[tokenAddress].suspiciousVolume) {\n', '      tokens[tokenAddress].status = TokenStatus.Suspended;\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  // Discount\n', '  function discountCorrectionIfNecessary(uint256 balance) private returns (bool) {\n', '    if (balance < balanceThreshold) {\n', '      // Update discountNumerator, discountDenominator and balanceThreshold\n', '      // we multiply discount coefficient by discountNumeratorMul / discountDenominatorMul\n', '      discountNumerator = discountNumerator.mul(discountNumeratorMul);\n', '      discountDenominator = discountDenominator.mul(discountDenominatorMul);\n', '      balanceThreshold = balanceThreshold.mul(discountNumeratorMul).div(discountDenominatorMul);\n', '      emit DiscountUpdate(discountNumerator, discountDenominator, balanceThreshold);\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  // Helpers\n', '  function getAllTokenData(\n', '    address tokenAddress,\n', '    address user\n', '  )\n', '    public view returns (uint256, uint256, uint256, uint256, bool) \n', '  {\n', '    IERC20 tokenContract = IERC20(tokenAddress);\n', '    uint256 balance = tokenContract.balanceOf(user);\n', '    uint256 allowance = tokenContract.allowance(user, address(this));\n', '    uint256 burnedByUser = amountBurnedByUser(tokenAddress, user);\n', '    uint256 burnedTotal = amountBurnedTotal(tokenAddress);\n', '    bool isActive = (tokens[tokenAddress].status == TokenStatus.Active);\n', '    return (balance, allowance, burnedByUser, burnedTotal, isActive);\n', '  }\n', '\n', '  function getBTokenValue(\n', '    address tokenAddress, \n', '    uint256 value\n', '  )\n', '    public view returns (uint256) \n', '  {\n', '    Token memory tokenRec = tokens[tokenAddress];\n', '    require(tokenRec.status == TokenStatus.Active, "Token should be in active state");\n', '    uint256 denominator = tokenRec.rewardRateDenominator;\n', '    require(denominator > 0, "Reward denominator should not be zero");\n', '    uint256 numerator = tokenRec.rewardRateNumerator;\n', '    uint256 bTokenValue = value.mul(numerator).div(denominator);\n', '    // Discount\n', '    uint256 discountedBTokenValue = bTokenValue.mul(discountNumerator).div(discountDenominator);\n', '    return discountedBTokenValue;\n', '  } \n', '\n', '  function getPartnerReward(uint256 bTokenValue) public view returns (uint256) {\n', '    return bTokenValue.mul(partnerRewardRateNumerator).div(partnerRewardRateDenominator);\n', '  }\n', '\n', '  function burn(\n', '    address tokenAddress, \n', '    uint256 value\n', '  )\n', '    public \n', '    whenNotPaused\n', '    whenNoPermissionRequired\n', '  {\n', '    _burn(tokenAddress, value);\n', '  }\n', '\n', '  function burnPermissioned(\n', '    address tokenAddress, \n', '    uint256 value,\n', '    uint256 nonce,\n', '    bytes memory permissionSignature\n', '  )\n', '    public \n', '    whenNotPaused\n', '  {\n', '    require(nonces[msg.sender] < nonce, "New nonce should be greater than previous");\n', '    bool signatureOk = checkPermissionSignature(permissionSignature, msg.sender, tokenAddress, value, nonce);\n', '    require(signatureOk, "Permission should have a correct signature");\n', '    nonces[msg.sender] = nonce;\n', '    _burn(tokenAddress, value);\n', '  }\n', '\n', '  function _burn(address tokenAddress, uint256 value) private {\n', '    address partner = referalPartners[msg.sender];\n', '    require(partner != address(0), "Burner should be registered");\n', '    \n', '    IERC20 tokenContract = IERC20(tokenAddress);\n', '    \n', '    require(tokenContract.allowance(msg.sender, address(this)) >= value, "Should be allowed");\n', ' \n', '    uint256 bTokenValueTotal; // total user reward including bonus if allowed\n', '    uint256 bTokenValue = getBTokenValue(tokenAddress, value);\n', '    uint256 currentBalance = bToken.balanceOf(address(this));\n', '    require(bTokenValue < currentBalance.div(100), "Cannot reward more than 1% of the balance");\n', '\n', '    uint256 bTokenPartnerReward = getPartnerReward(bTokenValue);\n', '    \n', '    // Update counters\n', '    tokens[tokenAddress].burned = tokens[tokenAddress].burned.add(value);\n', '    tokens[tokenAddress].burnedAccumulator = tokens[tokenAddress].burnedAccumulator.add(value);\n', '    burnedByTokenUser[tokenAddress][msg.sender] = burnedByTokenUser[tokenAddress][msg.sender].add(value);\n', '    \n', '    tokenContract.transferFrom(msg.sender, burnAddress, value); // burn shit-token\n', '    discountCorrectionIfNecessary(currentBalance.sub(bTokenValue).sub(bTokenPartnerReward));\n', '    \n', '    suspendIfNecessary(tokenAddress);\n', '\n', '    bToken.transfer(partner, bTokenPartnerReward);\n', '\n', '    if (shouldGetBonus[msg.sender]) {\n', '      // give 20% bonus once\n', '      shouldGetBonus[msg.sender] = false;\n', '      bTokenValueTotal = bTokenValue.add(bTokenValue.mul(bonusNumerator).div(bonusDenominator));\n', '    } else {\n', '      bTokenValueTotal = bTokenValue;\n', '    }\n', '\n', '    bToken.transfer(msg.sender, bTokenValueTotal);\n', '    emit Burn(tokenAddress, msg.sender, partner, value, bTokenValueTotal, bTokenPartnerReward);\n', '  }\n', '}']