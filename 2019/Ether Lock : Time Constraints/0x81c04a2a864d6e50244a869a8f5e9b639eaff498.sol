['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9cfbf5fef1f5eef9f5f2fef5f9eedcfbf1fdf5f0b2fff3f1">[email&#160;protected]</a>\n', '*/\n', '\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Helper {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public SDIVIDER = 3450000;\n', '    uint256 constant public PDIVIDER = 3450000;\n', '    uint256 constant public RDIVIDER = 1580000;\n', '    // Starting LS price (SLP)\n', '    uint256 constant public SLP = 0.002 ether;\n', '    // Starting Added Time (SAT)\n', '    uint256 constant public SAT = 30; // seconds\n', '    // Price normalization (PN)\n', '    uint256 constant public PN = 777;\n', '    // EarlyIncome base\n', '    uint256 constant public PBASE = 13;\n', '    uint256 constant public PMULTI = 26;\n', '    uint256 constant public LBase = 15;\n', '\n', '    uint256 constant public ONE_HOUR = 3600;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    \n', '    function bytes32ToString (bytes32 data)\n', '        public\n', '        pure\n', '        returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(32);\n', '        for (uint j=0; j<32; j++) {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[j] = char;\n', '            }\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    \n', '    function uintToBytes32(uint256 n)\n', '        public\n', '        pure\n', '        returns (bytes32) \n', '    {\n', '        return bytes32(n);\n', '    }\n', '    \n', '    function bytes32ToUint(bytes32 n) \n', '        public\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        return uint256(n);\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) \n', '        public\n', '        pure\n', '        returns (bytes32 result) \n', '    {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    \n', '    function stringToUint(string memory source) \n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return bytes32ToUint(stringToBytes32(source));\n', '    }\n', '    \n', '    function uintToString(uint256 _uint) \n', '        public\n', '        pure\n', '        returns (string)\n', '    {\n', '        return bytes32ToString(uintToBytes32(_uint));\n', '    }\n', '\n', '/*     \n', '    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\n', '        bytes memory a = new bytes(end-begin+1);\n', '        for(uint i = 0; i <= end - begin; i++){\n', '            a[i] = bytes(text)[i + begin - 1];\n', '        }\n', '        return string(a);    \n', '    }\n', ' */\n', '    function validUsername(string _username)\n', '        public\n', '        pure\n', '        returns(bool)\n', '    {\n', '        uint256 len = bytes(_username).length;\n', '        // Im Raum [4, 18]\n', '        if ((len < 4) || (len > 18)) return false;\n', '        // Letzte Char != &#39; &#39;\n', '        if (bytes(_username)[len-1] == 32) return false;\n', '        // Erste Char != &#39;0&#39;\n', '        return uint256(bytes(_username)[0]) != 48;\n', '    }\n', '\n', '    // Lottery Helper\n', '\n', '    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\n', '    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        //Luppe = 10000 = 10^4\n', '        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        // div 10000^6\n', '        expo = expo / (10**24);\n', '\n', '        if (expo > SAT) return 0;\n', '        return (SAT - expo).mul(_tAmount);\n', '    }\n', '\n', '    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\n', '        uint256 timeout = _slideEndTime.sub(block.timestamp);\n', '        // timeout capped at TIMEOUT1\n', '        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\n', '        _slideEndTime = (block.timestamp).add(timeout);\n', '        // Capped at fixedEndTime\n', '        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\n', '        return _slideEndTime;\n', '    }\n', '\n', '    // get random in range [1, _range] with _seed\n', '    function getRandom(uint256 _seed, uint256 _range)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        if (_range == 0) return _seed;\n', '        return (_seed % _range) + 1;\n', '    }\n', '\n', '\n', '    function getEarlyIncomeMul(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\n', '        uint256 base = _ticketSum * ZOOM / RDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base); //^3\n', '        expo = expo.mul(expo) / (ZOOM**6); //^6\n', '        return (1 + PBASE / (1 + expo.mul(PMULTI)));\n', '    }\n', '\n', '    // get reveiced Tickets, based on current round ticketSum\n', '    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tPrice = getTPrice(_ticketSum);\n', '        return _ethAmount.div(_tPrice);\n', '    }\n', '\n', '    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\n', '    function getTMul(uint256 _ticketSum) // Unit Wei\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = _ticketSum * ZOOM / PDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base);\n', '        expo = expo.mul(expo); // ^6\n', '        return 1 + expo.mul(LBase) / (10**18);\n', '    }\n', '\n', '    // get ticket price, based on current round ticketSum\n', '    //unit in ETH, no need / zoom^6\n', '    function getTPrice(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        uint256 tPrice = SLP + expo / PN;\n', '        return tPrice;\n', '    }\n', '\n', '    // get weight of slot, chance to win grandPot\n', '    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = getTMul(_ticketSum);\n', '        return (_tAmount).mul(_tMul);\n', '    }\n', '\n', '    // used to draw grandpot results\n', '    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\n', '    // grandPot = initGrandPot + round investedSum(for grandPot)\n', '    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        //calculate round grandPot-investedSum\n', '        uint256 grandPotInvest = grandPot - initGrandPot;\n', '        if (grandPotInvest == 0) return 8;\n', '        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\n', '        uint256 weightRange = zoomMul * curRWeight / ZOOM;\n', '        if (weightRange < curRWeight) weightRange = curRWeight;\n', '        return weightRange;\n', '    }\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'interface LotteryInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // call one time\n', '    function activeFirstRound() public;\n', '    // Core Functions\n', '    function pushToPot() public payable;\n', '    function finalizeable() public view returns(bool);\n', '    // bounty\n', '    function finalize() public;\n', '    function buy(string _sSalt) public payable;\n', '    function buyFor(string _sSalt, address _sender) public payable;\n', '    //function withdraw() public;\n', '    function withdrawFor(address _sender) public returns(uint256);\n', '\n', '    function getRewardBalance(address _buyer) public view returns(uint256);\n', '    function getTotalPot() public view returns(uint256);\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // included claimed amount\n', '    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurRoundId() public view returns(uint256);\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) public;\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n', '    function cashoutable(address _address) public view returns(bool);\n', '    function isLastRound() public view returns(bool);\n', '}\n', '\n', 'contract Reward {\n', '    using SafeMath for uint256;\n', '\n', '    event NewReward(address indexed _lucker, uint256[5] _info);\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == address(lotteryContract), "This is just log for lottery contract");\n', '        _;\n', '    }\n', '\n', '    modifier claimable() {\n', '        require(\n', '            rest > 1 && \n', '            block.number > lastBlock &&\n', '            lastRoundClaim[msg.sender] < lastRoundId,\n', '            "out of stock in this round, block or already claimed");\n', '        _;\n', '    }\n', '\n', '/*     \n', '    enum RewardType {\n', '        Minor, 0\n', '        Major, 1\n', '        Grand, 2\n', '        Bounty 3\n', '        SBounty 4 // smal bounty\n', '    } \n', '*/\n', '\n', '    struct Rewards {\n', '        address lucker;\n', '        uint256 time;\n', '        uint256 rId;\n', '        uint256 value;\n', '        uint256 winNumber;\n', '        uint256 rewardType;\n', '    }\n', '\n', '    Rewards[] public rewardList;\n', '    // reward array by address\n', '    mapping( address => uint256[]) public pReward;\n', '    // reward sum by address\n', '    mapping( address => uint256) public pRewardedSum;\n', '    // reward sum by address, round\n', '    mapping( address => mapping(uint256 => uint256)) public pRewardedSumPerRound;\n', '    // reward sum by round\n', '    mapping( uint256 => uint256) public rRewardedSum;\n', '    // reward sum all round, all addresses\n', '    uint256 public rewardedSum;\n', '    \n', '    // last claimed round by address to check timeout\n', '    // timeout balance will be pushed to dividends\n', '    mapping(address => uint256) lastRoundClaim;\n', '\n', '    LotteryInterface lotteryContract;\n', '\n', '    //////////////////////////////////////////////////////////\n', '    \n', '    // rest times for sBounty, small bountys free for all (round-players) after each round\n', '    uint256 public rest = 0;\n', '    // last block that sBounty claimed, to prevent 2 time claimed in same block\n', '    uint256 public lastBlock = 0;\n', '    // sBounty will be saved in logs of last round\n', '    // new round will be started after sBountys pushed\n', '    uint256 public lastRoundId;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // register address in network\n', '        DevTeamInterface(_devTeam).setRewardAddress(address(this));\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require((address(lotteryContract) == 0x0),"already setup");\n', '        lotteryContract = LotteryInterface(_contract[3]);\n', '    }\n', '\n', '    // sBounty program\n', '    // rules :\n', '    // 1. accept only eth from lottery contract\n', '    // 2. one claim per block\n', '    // 3. one claim per address (reset each round)\n', '\n', '    function getSBounty()\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256)\n', '    {\n', '        uint256 sBountyAmount = rest < 2 ? 0 : address(this).balance / (rest-1);\n', '        return (rest, sBountyAmount, lastRoundId);\n', '    }\n', '\n', '    // pushed from lottery contract only\n', '    function pushBounty(uint256 _curRoundId) \n', '        public \n', '        payable \n', '        onlyOwner() \n', '    {\n', '        rest = 8;\n', '        lastBlock = block.number;\n', '        lastRoundId = _curRoundId;\n', '    }\n', '\n', '    function claim()\n', '        public\n', '        claimable()\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 rInvested = lotteryContract.getPInvestedSumByRound(lastRoundId, _sender);\n', '        require(rInvested > 0, "sorry, not invested no bounty");\n', '        lastBlock = block.number;\n', '        lastRoundClaim[_sender] = lastRoundId;\n', '        rest = rest - 1;\n', '        uint256 claimAmount = address(this).balance / rest;\n', '        _sender.transfer(claimAmount);\n', '        mintRewardCore(\n', '            _sender,\n', '            lastRoundId,\n', '            0,\n', '            0,\n', '            claimAmount,\n', '            4\n', '        );\n', '    }\n', '\n', '    // rewards sealed by lottery contract\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 _curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        public\n', '        onlyOwner()\n', '    {\n', '        mintRewardCore(\n', '            _lucker,\n', '            _curRoundId,\n', '            _tNumberFrom,\n', '            _tNumberTo,\n', '            _value,\n', '            _rewardType);\n', '    }\n', '\n', '    // reward logs generator\n', '    function mintRewardCore(\n', '        address _lucker,\n', '        uint256 _curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        private\n', '    {\n', '        Rewards memory _reward;\n', '        _reward.lucker = _lucker;\n', '        _reward.time = block.timestamp;\n', '        _reward.rId = _curRoundId;\n', '        _reward.value = _value;\n', '\n', '        // get winning number if rewardType is not bounty or sBounty\n', '        // seed = rewardList.length to be sure that seed changed after\n', '        // every reward minting\n', '        if (_rewardType < 3)\n', '        _reward.winNumber = getWinNumberBySlot(_tNumberFrom, _tNumberTo);\n', '\n', '        _reward.rewardType = _rewardType;\n', '        rewardList.push(_reward);\n', '        pReward[_lucker].push(rewardList.length - 1);\n', '        // reward sum logs\n', '        pRewardedSum[_lucker] += _value;\n', '        rRewardedSum[_curRoundId] += _value;\n', '        rewardedSum += _value;\n', '        pRewardedSumPerRound[_lucker][_curRoundId] += _value;\n', '        emit NewReward(_reward.lucker, [_reward.time, _reward.rId, _reward.value, _reward.winNumber, uint256(_reward.rewardType)]);\n', '    }\n', '\n', '    function getWinNumberBySlot(uint256 _tNumberFrom, uint256 _tNumberTo)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        //uint256 _seed = uint256(keccak256(rewardList.length));\n', '        uint256 _seed = rewardList.length * block.number + block.timestamp;\n', '        // get random number in range (1, _to - _from + 1)\n', '        uint256 _winNr = Helper.getRandom(_seed, _tNumberTo + 1 - _tNumberFrom);\n', '        return _tNumberFrom + _winNr - 1;\n', '    }\n', '\n', '    function getPRewardLength(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pReward[_sender].length;\n', '    }\n', '\n', '    function getRewardListLength()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rewardList.length;\n', '    }\n', '\n', '    function getPRewardId(address _sender, uint256 i)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pReward[_sender][i];\n', '    }\n', '\n', '    function getPRewardedSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pRewardedSumPerRound[_buyer][_rId];\n', '    }\n', '\n', '    function getRewardedSumByRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rRewardedSum[_rId];\n', '    }\n', '\n', '    function getRewardInfo(uint256 _id)\n', '        public\n', '        view\n', '        returns(\n', '            address,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        Rewards memory _reward = rewardList[_id];\n', '        return (\n', '            _reward.lucker,\n', '            _reward.winNumber,\n', '            _reward.time,\n', '            _reward.rId,\n', '            _reward.value,\n', '            _reward.rewardType\n', '        );\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   gibmireinbier@gmail.com\n', '*/\n', '\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Helper {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant public ZOOM = 1000;\n', '    uint256 constant public SDIVIDER = 3450000;\n', '    uint256 constant public PDIVIDER = 3450000;\n', '    uint256 constant public RDIVIDER = 1580000;\n', '    // Starting LS price (SLP)\n', '    uint256 constant public SLP = 0.002 ether;\n', '    // Starting Added Time (SAT)\n', '    uint256 constant public SAT = 30; // seconds\n', '    // Price normalization (PN)\n', '    uint256 constant public PN = 777;\n', '    // EarlyIncome base\n', '    uint256 constant public PBASE = 13;\n', '    uint256 constant public PMULTI = 26;\n', '    uint256 constant public LBase = 15;\n', '\n', '    uint256 constant public ONE_HOUR = 3600;\n', '    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n', '    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n', '    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n', '    \n', '    function bytes32ToString (bytes32 data)\n', '        public\n', '        pure\n', '        returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(32);\n', '        for (uint j=0; j<32; j++) {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[j] = char;\n', '            }\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    \n', '    function uintToBytes32(uint256 n)\n', '        public\n', '        pure\n', '        returns (bytes32) \n', '    {\n', '        return bytes32(n);\n', '    }\n', '    \n', '    function bytes32ToUint(bytes32 n) \n', '        public\n', '        pure\n', '        returns (uint256) \n', '    {\n', '        return uint256(n);\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) \n', '        public\n', '        pure\n', '        returns (bytes32 result) \n', '    {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    \n', '    function stringToUint(string memory source) \n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return bytes32ToUint(stringToBytes32(source));\n', '    }\n', '    \n', '    function uintToString(uint256 _uint) \n', '        public\n', '        pure\n', '        returns (string)\n', '    {\n', '        return bytes32ToString(uintToBytes32(_uint));\n', '    }\n', '\n', '/*     \n', '    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\n', '        bytes memory a = new bytes(end-begin+1);\n', '        for(uint i = 0; i <= end - begin; i++){\n', '            a[i] = bytes(text)[i + begin - 1];\n', '        }\n', '        return string(a);    \n', '    }\n', ' */\n', '    function validUsername(string _username)\n', '        public\n', '        pure\n', '        returns(bool)\n', '    {\n', '        uint256 len = bytes(_username).length;\n', '        // Im Raum [4, 18]\n', '        if ((len < 4) || (len > 18)) return false;\n', "        // Letzte Char != ' '\n", '        if (bytes(_username)[len-1] == 32) return false;\n', "        // Erste Char != '0'\n", '        return uint256(bytes(_username)[0]) != 48;\n', '    }\n', '\n', '    // Lottery Helper\n', '\n', '    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\n', '    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        //Luppe = 10000 = 10^4\n', '        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        // div 10000^6\n', '        expo = expo / (10**24);\n', '\n', '        if (expo > SAT) return 0;\n', '        return (SAT - expo).mul(_tAmount);\n', '    }\n', '\n', '    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\n', '        uint256 timeout = _slideEndTime.sub(block.timestamp);\n', '        // timeout capped at TIMEOUT1\n', '        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\n', '        _slideEndTime = (block.timestamp).add(timeout);\n', '        // Capped at fixedEndTime\n', '        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\n', '        return _slideEndTime;\n', '    }\n', '\n', '    // get random in range [1, _range] with _seed\n', '    function getRandom(uint256 _seed, uint256 _range)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        if (_range == 0) return _seed;\n', '        return (_seed % _range) + 1;\n', '    }\n', '\n', '\n', '    function getEarlyIncomeMul(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\n', '        uint256 base = _ticketSum * ZOOM / RDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base); //^3\n', '        expo = expo.mul(expo) / (ZOOM**6); //^6\n', '        return (1 + PBASE / (1 + expo.mul(PMULTI)));\n', '    }\n', '\n', '    // get reveiced Tickets, based on current round ticketSum\n', '    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tPrice = getTPrice(_ticketSum);\n', '        return _ethAmount.div(_tPrice);\n', '    }\n', '\n', '    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\n', '    function getTMul(uint256 _ticketSum) // Unit Wei\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = _ticketSum * ZOOM / PDIVIDER;\n', '        uint256 expo = base.mul(base).mul(base);\n', '        expo = expo.mul(expo); // ^6\n', '        return 1 + expo.mul(LBase) / (10**18);\n', '    }\n', '\n', '    // get ticket price, based on current round ticketSum\n', '    //unit in ETH, no need / zoom^6\n', '    function getTPrice(uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\n', '        uint256 expo = base;\n', '        expo = expo.mul(expo).mul(expo); // ^3\n', '        expo = expo.mul(expo); // ^6\n', '        uint256 tPrice = SLP + expo / PN;\n', '        return tPrice;\n', '    }\n', '\n', '    // get weight of slot, chance to win grandPot\n', '    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\n', '        uint256 _tMul = getTMul(_ticketSum);\n', '        return (_tAmount).mul(_tMul);\n', '    }\n', '\n', '    // used to draw grandpot results\n', '    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\n', '    // grandPot = initGrandPot + round investedSum(for grandPot)\n', '    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\n', '        public\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        //calculate round grandPot-investedSum\n', '        uint256 grandPotInvest = grandPot - initGrandPot;\n', '        if (grandPotInvest == 0) return 8;\n', '        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\n', '        uint256 weightRange = zoomMul * curRWeight / ZOOM;\n', '        if (weightRange < curRWeight) weightRange = curRWeight;\n', '        return weightRange;\n', '    }\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'interface LotteryInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // call one time\n', '    function activeFirstRound() public;\n', '    // Core Functions\n', '    function pushToPot() public payable;\n', '    function finalizeable() public view returns(bool);\n', '    // bounty\n', '    function finalize() public;\n', '    function buy(string _sSalt) public payable;\n', '    function buyFor(string _sSalt, address _sender) public payable;\n', '    //function withdraw() public;\n', '    function withdrawFor(address _sender) public returns(uint256);\n', '\n', '    function getRewardBalance(address _buyer) public view returns(uint256);\n', '    function getTotalPot() public view returns(uint256);\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // included claimed amount\n', '    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurRoundId() public view returns(uint256);\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) public;\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n', '    function cashoutable(address _address) public view returns(bool);\n', '    function isLastRound() public view returns(bool);\n', '}\n', '\n', 'contract Reward {\n', '    using SafeMath for uint256;\n', '\n', '    event NewReward(address indexed _lucker, uint256[5] _info);\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == address(lotteryContract), "This is just log for lottery contract");\n', '        _;\n', '    }\n', '\n', '    modifier claimable() {\n', '        require(\n', '            rest > 1 && \n', '            block.number > lastBlock &&\n', '            lastRoundClaim[msg.sender] < lastRoundId,\n', '            "out of stock in this round, block or already claimed");\n', '        _;\n', '    }\n', '\n', '/*     \n', '    enum RewardType {\n', '        Minor, 0\n', '        Major, 1\n', '        Grand, 2\n', '        Bounty 3\n', '        SBounty 4 // smal bounty\n', '    } \n', '*/\n', '\n', '    struct Rewards {\n', '        address lucker;\n', '        uint256 time;\n', '        uint256 rId;\n', '        uint256 value;\n', '        uint256 winNumber;\n', '        uint256 rewardType;\n', '    }\n', '\n', '    Rewards[] public rewardList;\n', '    // reward array by address\n', '    mapping( address => uint256[]) public pReward;\n', '    // reward sum by address\n', '    mapping( address => uint256) public pRewardedSum;\n', '    // reward sum by address, round\n', '    mapping( address => mapping(uint256 => uint256)) public pRewardedSumPerRound;\n', '    // reward sum by round\n', '    mapping( uint256 => uint256) public rRewardedSum;\n', '    // reward sum all round, all addresses\n', '    uint256 public rewardedSum;\n', '    \n', '    // last claimed round by address to check timeout\n', '    // timeout balance will be pushed to dividends\n', '    mapping(address => uint256) lastRoundClaim;\n', '\n', '    LotteryInterface lotteryContract;\n', '\n', '    //////////////////////////////////////////////////////////\n', '    \n', '    // rest times for sBounty, small bountys free for all (round-players) after each round\n', '    uint256 public rest = 0;\n', '    // last block that sBounty claimed, to prevent 2 time claimed in same block\n', '    uint256 public lastBlock = 0;\n', '    // sBounty will be saved in logs of last round\n', '    // new round will be started after sBountys pushed\n', '    uint256 public lastRoundId;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // register address in network\n', '        DevTeamInterface(_devTeam).setRewardAddress(address(this));\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require((address(lotteryContract) == 0x0),"already setup");\n', '        lotteryContract = LotteryInterface(_contract[3]);\n', '    }\n', '\n', '    // sBounty program\n', '    // rules :\n', '    // 1. accept only eth from lottery contract\n', '    // 2. one claim per block\n', '    // 3. one claim per address (reset each round)\n', '\n', '    function getSBounty()\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256)\n', '    {\n', '        uint256 sBountyAmount = rest < 2 ? 0 : address(this).balance / (rest-1);\n', '        return (rest, sBountyAmount, lastRoundId);\n', '    }\n', '\n', '    // pushed from lottery contract only\n', '    function pushBounty(uint256 _curRoundId) \n', '        public \n', '        payable \n', '        onlyOwner() \n', '    {\n', '        rest = 8;\n', '        lastBlock = block.number;\n', '        lastRoundId = _curRoundId;\n', '    }\n', '\n', '    function claim()\n', '        public\n', '        claimable()\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 rInvested = lotteryContract.getPInvestedSumByRound(lastRoundId, _sender);\n', '        require(rInvested > 0, "sorry, not invested no bounty");\n', '        lastBlock = block.number;\n', '        lastRoundClaim[_sender] = lastRoundId;\n', '        rest = rest - 1;\n', '        uint256 claimAmount = address(this).balance / rest;\n', '        _sender.transfer(claimAmount);\n', '        mintRewardCore(\n', '            _sender,\n', '            lastRoundId,\n', '            0,\n', '            0,\n', '            claimAmount,\n', '            4\n', '        );\n', '    }\n', '\n', '    // rewards sealed by lottery contract\n', '    function mintReward(\n', '        address _lucker,\n', '        uint256 _curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        public\n', '        onlyOwner()\n', '    {\n', '        mintRewardCore(\n', '            _lucker,\n', '            _curRoundId,\n', '            _tNumberFrom,\n', '            _tNumberTo,\n', '            _value,\n', '            _rewardType);\n', '    }\n', '\n', '    // reward logs generator\n', '    function mintRewardCore(\n', '        address _lucker,\n', '        uint256 _curRoundId,\n', '        uint256 _tNumberFrom,\n', '        uint256 _tNumberTo,\n', '        uint256 _value,\n', '        uint256 _rewardType)\n', '        private\n', '    {\n', '        Rewards memory _reward;\n', '        _reward.lucker = _lucker;\n', '        _reward.time = block.timestamp;\n', '        _reward.rId = _curRoundId;\n', '        _reward.value = _value;\n', '\n', '        // get winning number if rewardType is not bounty or sBounty\n', '        // seed = rewardList.length to be sure that seed changed after\n', '        // every reward minting\n', '        if (_rewardType < 3)\n', '        _reward.winNumber = getWinNumberBySlot(_tNumberFrom, _tNumberTo);\n', '\n', '        _reward.rewardType = _rewardType;\n', '        rewardList.push(_reward);\n', '        pReward[_lucker].push(rewardList.length - 1);\n', '        // reward sum logs\n', '        pRewardedSum[_lucker] += _value;\n', '        rRewardedSum[_curRoundId] += _value;\n', '        rewardedSum += _value;\n', '        pRewardedSumPerRound[_lucker][_curRoundId] += _value;\n', '        emit NewReward(_reward.lucker, [_reward.time, _reward.rId, _reward.value, _reward.winNumber, uint256(_reward.rewardType)]);\n', '    }\n', '\n', '    function getWinNumberBySlot(uint256 _tNumberFrom, uint256 _tNumberTo)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        //uint256 _seed = uint256(keccak256(rewardList.length));\n', '        uint256 _seed = rewardList.length * block.number + block.timestamp;\n', '        // get random number in range (1, _to - _from + 1)\n', '        uint256 _winNr = Helper.getRandom(_seed, _tNumberTo + 1 - _tNumberFrom);\n', '        return _tNumberFrom + _winNr - 1;\n', '    }\n', '\n', '    function getPRewardLength(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pReward[_sender].length;\n', '    }\n', '\n', '    function getRewardListLength()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rewardList.length;\n', '    }\n', '\n', '    function getPRewardId(address _sender, uint256 i)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pReward[_sender][i];\n', '    }\n', '\n', '    function getPRewardedSumByRound(uint256 _rId, address _buyer)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return pRewardedSumPerRound[_buyer][_rId];\n', '    }\n', '\n', '    function getRewardedSumByRound(uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return rRewardedSum[_rId];\n', '    }\n', '\n', '    function getRewardInfo(uint256 _id)\n', '        public\n', '        view\n', '        returns(\n', '            address,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        Rewards memory _reward = rewardList[_id];\n', '        return (\n', '            _reward.lucker,\n', '            _reward.winNumber,\n', '            _reward.time,\n', '            _reward.rId,\n', '            _reward.value,\n', '            _reward.rewardType\n', '        );\n', '    }\n', '}']
