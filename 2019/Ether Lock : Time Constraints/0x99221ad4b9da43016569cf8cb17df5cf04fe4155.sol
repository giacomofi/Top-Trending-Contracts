['pragma solidity ^0.4.24;\n', '\n', '/*\n', '\n', '  /$$$$$$                                      /$$           /$$$$$$                                           /$$                                         /$$\n', ' /$$__  $$                                    | $$          |_  $$_/                                          | $$                                        | $$\n', '| $$  \\__/ /$$$$$$/$$$$   /$$$$$$   /$$$$$$  /$$$$$$          | $$   /$$$$$$$  /$$    /$$ /$$$$$$   /$$$$$$$ /$$$$$$   /$$$$$$/$$$$   /$$$$$$  /$$$$$$$  /$$$$$$   /$$$$$$$\n', '|  $$$$$$ | $$_  $$_  $$ |____  $$ /$$__  $$|_  $$_/          | $$  | $$__  $$|  $$  /$$//$$__  $$ /$$_____/|_  $$_/  | $$_  $$_  $$ /$$__  $$| $$__  $$|_  $$_/  /$$_____/\n', ' \\____  $$| $$ \\ $$ \\ $$  /$$$$$$$| $$  \\__/  | $$            | $$  | $$  \\ $$ \\  $$/$$/| $$$$$$$$|  $$$$$$   | $$    | $$ \\ $$ \\ $$| $$$$$$$$| $$  \\ $$  | $$   |  $$$$$$\n', ' /$$  \\ $$| $$ | $$ | $$ /$$__  $$| $$        | $$ /$$        | $$  | $$  | $$  \\  $$$/ | $$_____/ \\____  $$  | $$ /$$| $$ | $$ | $$| $$_____/| $$  | $$  | $$ /$$\\____  $$\n', '|  $$$$$$/| $$ | $$ | $$|  $$$$$$$| $$        |  $$$$/       /$$$$$$| $$  | $$   \\  $/  |  $$$$$$$ /$$$$$$$/  |  $$$$/| $$ | $$ | $$|  $$$$$$$| $$  | $$  |  $$$$//$$$$$$$/\n', ' \\______/ |__/ |__/ |__/ \\_______/|__/         \\___/        |______/|__/  |__/    \\_/    \\_______/|_______/    \\___/  |__/ |__/ |__/ \\_______/|__/  |__/   \\___/ |_______/\n', '\n', '*/\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    address public marketers = 0xccdbFb142F4444D31dd52F719CA78b6AD3459F90;\n', '    uint256 public constant marketersPercent = 14;\n', '\n', '    address public developers = 0x7E2EdCD2D7073286caeC46111dbE205A3523Eec5;\n', '    uint256 public constant developersPercent = 1;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event DevelopersChanged(address indexed previousDevelopers, address indexed newDevelopers);\n', '    event MarketersChanged(address indexed previousMarketers, address indexed newMarketers);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyThisOwner(address _owner) {\n', '        require(owner == _owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setDevelopers(address newDevelopers) public onlyOwner {\n', '        require(newDevelopers != address(0));\n', '        emit DevelopersChanged(developers, newDevelopers);\n', '        developers = newDevelopers;\n', '    }\n', '\n', '    function setMarketers(address newMarketers) public onlyOwner {\n', '        require(newMarketers != address(0));\n', '        emit MarketersChanged(marketers, newMarketers);\n', '        marketers = newMarketers;\n', '    }\n', '\n', '}\n', '\n', 'contract Investments {\n', '\n', '    struct InvestProgram {\n', '        uint256 minSum;     // min sum for program\n', '        uint256 income;     // income for one year\n', '    }\n', '\n', '    struct ReferralGroup {\n', '        uint256 minSum;\n', '        uint256 maxSum;\n', '        uint16[] percents;\n', '    }\n', '\n', '    uint256 public constant minSumRef = 0.01 ether;\n', '    uint256 public constant refLevelsTables = 3;\n', '    uint256 public constant refLevelsCount = 5;\n', '    ReferralGroup[] public refGroups;\n', '    uint256 public constant programsCount = 21;\n', '    InvestProgram[] public programs;\n', '\n', '    constructor() public {\n', '        ReferralGroup memory refGroupFirsty = ReferralGroup(minSumRef, 10 ether - 1 wei, new uint16[](refLevelsCount));\n', '        refGroupFirsty.percents[0] = 300;   // 3%\n', '        refGroupFirsty.percents[1] = 75;    // 0.75%\n', '        refGroupFirsty.percents[2] = 60;    // 0.6%\n', '        refGroupFirsty.percents[3] = 40;    // 0.4%\n', '        refGroupFirsty.percents[4] = 25;    // 0.25%\n', '        refGroups.push(refGroupFirsty);\n', '\n', '        ReferralGroup memory refGroupLoyalty = ReferralGroup(10 ether, 100 ether - 1 wei, new uint16[](refLevelsCount));\n', '        refGroupLoyalty.percents[0] = 500;  // 5%\n', '        refGroupLoyalty.percents[1] = 200;  // 2%\n', '        refGroupLoyalty.percents[2] = 150;  // 1.5%\n', '        refGroupLoyalty.percents[3] = 100;  // 1%\n', '        refGroupLoyalty.percents[4] = 50;   // 0.5%\n', '        refGroups.push(refGroupLoyalty);\n', '\n', '        ReferralGroup memory refGroupUltraPremium = ReferralGroup(100 ether, 2**256 - 1, new uint16[](refLevelsCount));\n', '        refGroupUltraPremium.percents[0] = 700; // 7%\n', '        refGroupUltraPremium.percents[1] = 300; // 3%\n', '        refGroupUltraPremium.percents[2] = 250; // 2.5%\n', '        refGroupUltraPremium.percents[3] = 150; // 1.5%\n', '        refGroupUltraPremium.percents[4] = 100; // 1%\n', '        refGroups.push(refGroupUltraPremium);\n', '\n', '        programs.push(InvestProgram(0.01    ether, 180));   // 180%\n', '        programs.push(InvestProgram(0.26    ether, 192));   // 192%\n', '        programs.push(InvestProgram(0.76    ether, 204));   // 204%\n', '        programs.push(InvestProgram(1.51    ether, 216));   // 216%\n', '        programs.push(InvestProgram(2.51    ether, 228));   // 228%\n', '        programs.push(InvestProgram(4.51    ether, 240));   // 240%\n', '        programs.push(InvestProgram(7.01    ether, 252));   // 252%\n', '        programs.push(InvestProgram(10.01   ether, 264));   // 264%\n', '        programs.push(InvestProgram(14.01   ether, 276));   // 276%\n', '        programs.push(InvestProgram(18.01   ether, 288));   // 288%\n', '        programs.push(InvestProgram(23.01   ether, 300));   // 300%\n', '        programs.push(InvestProgram(28.01   ether, 312));   // 312%\n', '        programs.push(InvestProgram(34.01   ether, 324));   // 324%\n', '        programs.push(InvestProgram(41.01   ether, 336));   // 336%\n', '        programs.push(InvestProgram(50      ether, 348));   // 348%\n', '        programs.push(InvestProgram(60      ether, 360));   // 360%\n', '        programs.push(InvestProgram(75      ether, 372));   // 372%\n', '        programs.push(InvestProgram(95      ether, 384));   // 384%\n', '        programs.push(InvestProgram(120     ether, 396));   // 396%\n', '        programs.push(InvestProgram(150     ether, 408));   // 408%\n', '        programs.push(InvestProgram(200     ether, 420));   // 420%\n', '    }\n', '\n', '    function getRefPercents(uint256 _sum) public view returns(uint16[] memory) {\n', '        for (uint i = 0; i < refLevelsTables; i++) {\n', '            ReferralGroup memory group = refGroups[i];\n', '            if (_sum >= group.minSum && _sum <= group.maxSum) return group.percents;\n', '        }\n', '    }\n', '\n', '    function getRefPercentsByIndex(uint256 _index) public view returns(uint16[] memory) {\n', '        return refGroups[_index].percents;\n', '    }\n', '\n', '    function getProgramInfo(uint256 _index) public view returns(uint256, uint256) {\n', '        return (programs[_index].minSum, programs[_index].income);\n', '    }\n', '\n', '    function getProgramPercent(uint256 _totalSum) public view returns(uint256) {\n', '        bool exist = false;\n', '        uint256 i = 0;\n', '        for (; i < programsCount; i++) {\n', '            if (_totalSum >= programs[i].minSum) exist = true;\n', '            else break;\n', '        }\n', '\n', '        if (exist) return programs[i - 1].income;\n', '\n', '        return 0;\n', '    }\n', '\n', '}\n', '\n', 'contract SmartInvestments is Ownable, Investments {\n', '    event InvestorRegister(address _addr, uint256 _id);\n', '    event ReferralRegister(address _addr, address _refferal);\n', '    event Deposit(address _addr, uint256 _value);\n', '    event ReferrerDistribute(uint256 _referrerId, uint256 _sum);\n', '    event Withdraw(address _addr, uint256 _sum);\n', '\n', '    struct Investor {\n', '        // public\n', '        uint256 lastWithdraw;\n', '        uint256 totalSum;                               // total deposits sum\n', '        uint256 totalWithdraw;\n', '        uint256 totalReferralIncome;\n', '        uint256[] referrersByLevel;                     // referrers ids\n', '        mapping (uint8 => uint256[]) referralsByLevel;  // all referrals ids\n', '\n', '        // private\n', '        uint256 witharawBuffer;\n', '    }\n', '\n', '    uint256 public globalDeposit;\n', '    uint256 public globalWithdraw;\n', '\n', '    Investor[] public investors;\n', '    mapping (address => uint256) addressToInvestorId;\n', '    mapping (uint256 => address) investorIdToAddress;\n', '\n', '    modifier onlyForExisting() {\n', '        require(addressToInvestorId[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    constructor() public payable {\n', '        globalDeposit = 0;\n', '        globalWithdraw = 0;\n', '        investors.push(Investor(0, 0, 0, 0, new uint256[](refLevelsCount), 0));\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value > 0) {\n', '            deposit(0);\n', '        } else {\n', '            withdraw();\n', '        }\n', '    }\n', '\n', '    function getInvestorInfo(uint256 _id) public view returns(uint256, uint256, uint256, uint256, uint256[] memory, uint256[] memory) {\n', '        Investor memory investor = investors[_id];\n', '        return (investor.lastWithdraw, investor.totalSum, investor.totalWithdraw, investor.totalReferralIncome, investor.referrersByLevel, investors[_id].referralsByLevel[uint8(0)]);\n', '    }\n', '\n', '    function getInvestorId(address _address) public view returns(uint256) {\n', '        return addressToInvestorId[_address];\n', '    }\n', '\n', '    function getInvestorAddress(uint256 _id) public view returns(address) {\n', '        return investorIdToAddress[_id];\n', '    }\n', '\n', '    function investorsCount() public view returns(uint256) {\n', '        return investors.length;\n', '    }\n', '\n', '    /// @notice update referrersByLevel and referralsByLevel of new investor\n', '    /// @param _newInvestorId the ID of the new investor\n', '    /// @param _refId the ID of the investor who gets the affiliate fee\n', '    function _updateReferrals(uint256 _newInvestorId, uint256 _refId) private {\n', '        if (_newInvestorId == _refId) return;\n', '        investors[_newInvestorId].referrersByLevel[0] = _refId;\n', '\n', '        for (uint i = 1; i < refLevelsCount; i++) {\n', '            uint256 refId = investors[_refId].referrersByLevel[i - 1];\n', '            investors[_newInvestorId].referrersByLevel[i] = refId;\n', '            investors[refId].referralsByLevel[uint8(i)].push(_newInvestorId);\n', '        }\n', '\n', '        investors[_refId].referralsByLevel[0].push(_newInvestorId);\n', '        emit ReferralRegister(investorIdToAddress[_newInvestorId], investorIdToAddress[_refId]);\n', '    }\n', '\n', '    /// @notice distribute value of tx to referrers of investor\n', '    /// @param _investor the investor object who gets the affiliate fee\n', '    /// @param _sum value of ethereum for distribute to referrers of investor\n', '    function _distributeReferrers(Investor memory _investor, uint256 _sum) private {\n', '        uint256[] memory referrers = _investor.referrersByLevel;\n', '\n', '        for (uint i = 0; i < refLevelsCount; i++)  {\n', '            uint256 referrerId = referrers[i];\n', '\n', '            if (referrers[i] == 0) break;\n', '            // if (investors[referrerId].totalSum < minSumReferral) continue;\n', '\n', '            uint16[] memory percents = getRefPercents(investors[referrerId].totalSum);\n', '            uint256 value = _sum * percents[i] / 10000;\n', '            if (investorIdToAddress[referrerId] != 0x0) {\n', '                investorIdToAddress[referrerId].transfer(value);\n', '                investors[referrerId].totalReferralIncome = investors[referrerId].totalReferralIncome + value;\n', '                globalWithdraw = globalWithdraw + value;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _distribute(Investor storage _investor, uint256 _sum) private {\n', '        _distributeReferrers(_investor, _sum);\n', '        developers.transfer(_sum * developersPercent / 100);\n', '        marketers.transfer(_sum * marketersPercent / 100);\n', '    }\n', '\n', '    function _registerIfNeeded(uint256 _refId) private returns(uint256) {\n', '        if (addressToInvestorId[msg.sender] != 0) return 0;\n', '\n', '        uint256 id = investors.push(Investor(now, 0, 0, 0, new uint256[](refLevelsCount), 0)) - 1;\n', '        addressToInvestorId[msg.sender] = id;\n', '        investorIdToAddress[id] = msg.sender;\n', '\n', '        if (_refId != 0)\n', '            _updateReferrals(id, _refId);\n', '\n', '        emit InvestorRegister(msg.sender, id);\n', '    }\n', '\n', '    function deposit(uint256 _refId) public payable returns(uint256) {\n', '        if (addressToInvestorId[msg.sender] == 0)\n', '            _registerIfNeeded(_refId);\n', '\n', '        Investor storage investor = investors[addressToInvestorId[msg.sender]];\n', '        uint256 amount = withdrawAmount();\n', '        investor.lastWithdraw = now;\n', '        investor.witharawBuffer = amount;\n', '        investor.totalSum = investor.totalSum + msg.value;\n', '\n', '        globalDeposit = globalDeposit + msg.value;\n', '\n', '        _distribute(investor, msg.value);\n', '\n', '        emit Deposit(msg.sender, msg.value);\n', '        return investor.totalSum;\n', '    }\n', '\n', '    function withdrawAmount() public view returns(uint256) {\n', '        Investor memory investor = investors[addressToInvestorId[msg.sender]];\n', '        return investor.totalSum * getProgramPercent(investor.totalSum) / 8760 * ((now - investor.lastWithdraw) / 3600) / 100 + investor.witharawBuffer;\n', '    }\n', '\n', '    function withdraw() public onlyForExisting returns(uint256) {\n', '        uint256 amount = withdrawAmount();\n', '\n', '        require(amount > 0);\n', '        require(amount < address(this).balance);\n', '\n', '        Investor storage investor = investors[addressToInvestorId[msg.sender]];\n', '        investor.totalWithdraw = investor.totalWithdraw + amount;\n', '        investor.lastWithdraw = now;\n', '        investor.witharawBuffer = 0;\n', '\n', '        globalWithdraw = globalWithdraw + amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit Withdraw(msg.sender, amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '\n', '  /$$$$$$                                      /$$           /$$$$$$                                           /$$                                         /$$\n', ' /$$__  $$                                    | $$          |_  $$_/                                          | $$                                        | $$\n', '| $$  \\__/ /$$$$$$/$$$$   /$$$$$$   /$$$$$$  /$$$$$$          | $$   /$$$$$$$  /$$    /$$ /$$$$$$   /$$$$$$$ /$$$$$$   /$$$$$$/$$$$   /$$$$$$  /$$$$$$$  /$$$$$$   /$$$$$$$\n', '|  $$$$$$ | $$_  $$_  $$ |____  $$ /$$__  $$|_  $$_/          | $$  | $$__  $$|  $$  /$$//$$__  $$ /$$_____/|_  $$_/  | $$_  $$_  $$ /$$__  $$| $$__  $$|_  $$_/  /$$_____/\n', ' \\____  $$| $$ \\ $$ \\ $$  /$$$$$$$| $$  \\__/  | $$            | $$  | $$  \\ $$ \\  $$/$$/| $$$$$$$$|  $$$$$$   | $$    | $$ \\ $$ \\ $$| $$$$$$$$| $$  \\ $$  | $$   |  $$$$$$\n', ' /$$  \\ $$| $$ | $$ | $$ /$$__  $$| $$        | $$ /$$        | $$  | $$  | $$  \\  $$$/ | $$_____/ \\____  $$  | $$ /$$| $$ | $$ | $$| $$_____/| $$  | $$  | $$ /$$\\____  $$\n', '|  $$$$$$/| $$ | $$ | $$|  $$$$$$$| $$        |  $$$$/       /$$$$$$| $$  | $$   \\  $/  |  $$$$$$$ /$$$$$$$/  |  $$$$/| $$ | $$ | $$|  $$$$$$$| $$  | $$  |  $$$$//$$$$$$$/\n', ' \\______/ |__/ |__/ |__/ \\_______/|__/         \\___/        |______/|__/  |__/    \\_/    \\_______/|_______/    \\___/  |__/ |__/ |__/ \\_______/|__/  |__/   \\___/ |_______/\n', '\n', '*/\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    address public marketers = 0xccdbFb142F4444D31dd52F719CA78b6AD3459F90;\n', '    uint256 public constant marketersPercent = 14;\n', '\n', '    address public developers = 0x7E2EdCD2D7073286caeC46111dbE205A3523Eec5;\n', '    uint256 public constant developersPercent = 1;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event DevelopersChanged(address indexed previousDevelopers, address indexed newDevelopers);\n', '    event MarketersChanged(address indexed previousMarketers, address indexed newMarketers);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyThisOwner(address _owner) {\n', '        require(owner == _owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setDevelopers(address newDevelopers) public onlyOwner {\n', '        require(newDevelopers != address(0));\n', '        emit DevelopersChanged(developers, newDevelopers);\n', '        developers = newDevelopers;\n', '    }\n', '\n', '    function setMarketers(address newMarketers) public onlyOwner {\n', '        require(newMarketers != address(0));\n', '        emit MarketersChanged(marketers, newMarketers);\n', '        marketers = newMarketers;\n', '    }\n', '\n', '}\n', '\n', 'contract Investments {\n', '\n', '    struct InvestProgram {\n', '        uint256 minSum;     // min sum for program\n', '        uint256 income;     // income for one year\n', '    }\n', '\n', '    struct ReferralGroup {\n', '        uint256 minSum;\n', '        uint256 maxSum;\n', '        uint16[] percents;\n', '    }\n', '\n', '    uint256 public constant minSumRef = 0.01 ether;\n', '    uint256 public constant refLevelsTables = 3;\n', '    uint256 public constant refLevelsCount = 5;\n', '    ReferralGroup[] public refGroups;\n', '    uint256 public constant programsCount = 21;\n', '    InvestProgram[] public programs;\n', '\n', '    constructor() public {\n', '        ReferralGroup memory refGroupFirsty = ReferralGroup(minSumRef, 10 ether - 1 wei, new uint16[](refLevelsCount));\n', '        refGroupFirsty.percents[0] = 300;   // 3%\n', '        refGroupFirsty.percents[1] = 75;    // 0.75%\n', '        refGroupFirsty.percents[2] = 60;    // 0.6%\n', '        refGroupFirsty.percents[3] = 40;    // 0.4%\n', '        refGroupFirsty.percents[4] = 25;    // 0.25%\n', '        refGroups.push(refGroupFirsty);\n', '\n', '        ReferralGroup memory refGroupLoyalty = ReferralGroup(10 ether, 100 ether - 1 wei, new uint16[](refLevelsCount));\n', '        refGroupLoyalty.percents[0] = 500;  // 5%\n', '        refGroupLoyalty.percents[1] = 200;  // 2%\n', '        refGroupLoyalty.percents[2] = 150;  // 1.5%\n', '        refGroupLoyalty.percents[3] = 100;  // 1%\n', '        refGroupLoyalty.percents[4] = 50;   // 0.5%\n', '        refGroups.push(refGroupLoyalty);\n', '\n', '        ReferralGroup memory refGroupUltraPremium = ReferralGroup(100 ether, 2**256 - 1, new uint16[](refLevelsCount));\n', '        refGroupUltraPremium.percents[0] = 700; // 7%\n', '        refGroupUltraPremium.percents[1] = 300; // 3%\n', '        refGroupUltraPremium.percents[2] = 250; // 2.5%\n', '        refGroupUltraPremium.percents[3] = 150; // 1.5%\n', '        refGroupUltraPremium.percents[4] = 100; // 1%\n', '        refGroups.push(refGroupUltraPremium);\n', '\n', '        programs.push(InvestProgram(0.01    ether, 180));   // 180%\n', '        programs.push(InvestProgram(0.26    ether, 192));   // 192%\n', '        programs.push(InvestProgram(0.76    ether, 204));   // 204%\n', '        programs.push(InvestProgram(1.51    ether, 216));   // 216%\n', '        programs.push(InvestProgram(2.51    ether, 228));   // 228%\n', '        programs.push(InvestProgram(4.51    ether, 240));   // 240%\n', '        programs.push(InvestProgram(7.01    ether, 252));   // 252%\n', '        programs.push(InvestProgram(10.01   ether, 264));   // 264%\n', '        programs.push(InvestProgram(14.01   ether, 276));   // 276%\n', '        programs.push(InvestProgram(18.01   ether, 288));   // 288%\n', '        programs.push(InvestProgram(23.01   ether, 300));   // 300%\n', '        programs.push(InvestProgram(28.01   ether, 312));   // 312%\n', '        programs.push(InvestProgram(34.01   ether, 324));   // 324%\n', '        programs.push(InvestProgram(41.01   ether, 336));   // 336%\n', '        programs.push(InvestProgram(50      ether, 348));   // 348%\n', '        programs.push(InvestProgram(60      ether, 360));   // 360%\n', '        programs.push(InvestProgram(75      ether, 372));   // 372%\n', '        programs.push(InvestProgram(95      ether, 384));   // 384%\n', '        programs.push(InvestProgram(120     ether, 396));   // 396%\n', '        programs.push(InvestProgram(150     ether, 408));   // 408%\n', '        programs.push(InvestProgram(200     ether, 420));   // 420%\n', '    }\n', '\n', '    function getRefPercents(uint256 _sum) public view returns(uint16[] memory) {\n', '        for (uint i = 0; i < refLevelsTables; i++) {\n', '            ReferralGroup memory group = refGroups[i];\n', '            if (_sum >= group.minSum && _sum <= group.maxSum) return group.percents;\n', '        }\n', '    }\n', '\n', '    function getRefPercentsByIndex(uint256 _index) public view returns(uint16[] memory) {\n', '        return refGroups[_index].percents;\n', '    }\n', '\n', '    function getProgramInfo(uint256 _index) public view returns(uint256, uint256) {\n', '        return (programs[_index].minSum, programs[_index].income);\n', '    }\n', '\n', '    function getProgramPercent(uint256 _totalSum) public view returns(uint256) {\n', '        bool exist = false;\n', '        uint256 i = 0;\n', '        for (; i < programsCount; i++) {\n', '            if (_totalSum >= programs[i].minSum) exist = true;\n', '            else break;\n', '        }\n', '\n', '        if (exist) return programs[i - 1].income;\n', '\n', '        return 0;\n', '    }\n', '\n', '}\n', '\n', 'contract SmartInvestments is Ownable, Investments {\n', '    event InvestorRegister(address _addr, uint256 _id);\n', '    event ReferralRegister(address _addr, address _refferal);\n', '    event Deposit(address _addr, uint256 _value);\n', '    event ReferrerDistribute(uint256 _referrerId, uint256 _sum);\n', '    event Withdraw(address _addr, uint256 _sum);\n', '\n', '    struct Investor {\n', '        // public\n', '        uint256 lastWithdraw;\n', '        uint256 totalSum;                               // total deposits sum\n', '        uint256 totalWithdraw;\n', '        uint256 totalReferralIncome;\n', '        uint256[] referrersByLevel;                     // referrers ids\n', '        mapping (uint8 => uint256[]) referralsByLevel;  // all referrals ids\n', '\n', '        // private\n', '        uint256 witharawBuffer;\n', '    }\n', '\n', '    uint256 public globalDeposit;\n', '    uint256 public globalWithdraw;\n', '\n', '    Investor[] public investors;\n', '    mapping (address => uint256) addressToInvestorId;\n', '    mapping (uint256 => address) investorIdToAddress;\n', '\n', '    modifier onlyForExisting() {\n', '        require(addressToInvestorId[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    constructor() public payable {\n', '        globalDeposit = 0;\n', '        globalWithdraw = 0;\n', '        investors.push(Investor(0, 0, 0, 0, new uint256[](refLevelsCount), 0));\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value > 0) {\n', '            deposit(0);\n', '        } else {\n', '            withdraw();\n', '        }\n', '    }\n', '\n', '    function getInvestorInfo(uint256 _id) public view returns(uint256, uint256, uint256, uint256, uint256[] memory, uint256[] memory) {\n', '        Investor memory investor = investors[_id];\n', '        return (investor.lastWithdraw, investor.totalSum, investor.totalWithdraw, investor.totalReferralIncome, investor.referrersByLevel, investors[_id].referralsByLevel[uint8(0)]);\n', '    }\n', '\n', '    function getInvestorId(address _address) public view returns(uint256) {\n', '        return addressToInvestorId[_address];\n', '    }\n', '\n', '    function getInvestorAddress(uint256 _id) public view returns(address) {\n', '        return investorIdToAddress[_id];\n', '    }\n', '\n', '    function investorsCount() public view returns(uint256) {\n', '        return investors.length;\n', '    }\n', '\n', '    /// @notice update referrersByLevel and referralsByLevel of new investor\n', '    /// @param _newInvestorId the ID of the new investor\n', '    /// @param _refId the ID of the investor who gets the affiliate fee\n', '    function _updateReferrals(uint256 _newInvestorId, uint256 _refId) private {\n', '        if (_newInvestorId == _refId) return;\n', '        investors[_newInvestorId].referrersByLevel[0] = _refId;\n', '\n', '        for (uint i = 1; i < refLevelsCount; i++) {\n', '            uint256 refId = investors[_refId].referrersByLevel[i - 1];\n', '            investors[_newInvestorId].referrersByLevel[i] = refId;\n', '            investors[refId].referralsByLevel[uint8(i)].push(_newInvestorId);\n', '        }\n', '\n', '        investors[_refId].referralsByLevel[0].push(_newInvestorId);\n', '        emit ReferralRegister(investorIdToAddress[_newInvestorId], investorIdToAddress[_refId]);\n', '    }\n', '\n', '    /// @notice distribute value of tx to referrers of investor\n', '    /// @param _investor the investor object who gets the affiliate fee\n', '    /// @param _sum value of ethereum for distribute to referrers of investor\n', '    function _distributeReferrers(Investor memory _investor, uint256 _sum) private {\n', '        uint256[] memory referrers = _investor.referrersByLevel;\n', '\n', '        for (uint i = 0; i < refLevelsCount; i++)  {\n', '            uint256 referrerId = referrers[i];\n', '\n', '            if (referrers[i] == 0) break;\n', '            // if (investors[referrerId].totalSum < minSumReferral) continue;\n', '\n', '            uint16[] memory percents = getRefPercents(investors[referrerId].totalSum);\n', '            uint256 value = _sum * percents[i] / 10000;\n', '            if (investorIdToAddress[referrerId] != 0x0) {\n', '                investorIdToAddress[referrerId].transfer(value);\n', '                investors[referrerId].totalReferralIncome = investors[referrerId].totalReferralIncome + value;\n', '                globalWithdraw = globalWithdraw + value;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _distribute(Investor storage _investor, uint256 _sum) private {\n', '        _distributeReferrers(_investor, _sum);\n', '        developers.transfer(_sum * developersPercent / 100);\n', '        marketers.transfer(_sum * marketersPercent / 100);\n', '    }\n', '\n', '    function _registerIfNeeded(uint256 _refId) private returns(uint256) {\n', '        if (addressToInvestorId[msg.sender] != 0) return 0;\n', '\n', '        uint256 id = investors.push(Investor(now, 0, 0, 0, new uint256[](refLevelsCount), 0)) - 1;\n', '        addressToInvestorId[msg.sender] = id;\n', '        investorIdToAddress[id] = msg.sender;\n', '\n', '        if (_refId != 0)\n', '            _updateReferrals(id, _refId);\n', '\n', '        emit InvestorRegister(msg.sender, id);\n', '    }\n', '\n', '    function deposit(uint256 _refId) public payable returns(uint256) {\n', '        if (addressToInvestorId[msg.sender] == 0)\n', '            _registerIfNeeded(_refId);\n', '\n', '        Investor storage investor = investors[addressToInvestorId[msg.sender]];\n', '        uint256 amount = withdrawAmount();\n', '        investor.lastWithdraw = now;\n', '        investor.witharawBuffer = amount;\n', '        investor.totalSum = investor.totalSum + msg.value;\n', '\n', '        globalDeposit = globalDeposit + msg.value;\n', '\n', '        _distribute(investor, msg.value);\n', '\n', '        emit Deposit(msg.sender, msg.value);\n', '        return investor.totalSum;\n', '    }\n', '\n', '    function withdrawAmount() public view returns(uint256) {\n', '        Investor memory investor = investors[addressToInvestorId[msg.sender]];\n', '        return investor.totalSum * getProgramPercent(investor.totalSum) / 8760 * ((now - investor.lastWithdraw) / 3600) / 100 + investor.witharawBuffer;\n', '    }\n', '\n', '    function withdraw() public onlyForExisting returns(uint256) {\n', '        uint256 amount = withdrawAmount();\n', '\n', '        require(amount > 0);\n', '        require(amount < address(this).balance);\n', '\n', '        Investor storage investor = investors[addressToInvestorId[msg.sender]];\n', '        investor.totalWithdraw = investor.totalWithdraw + amount;\n', '        investor.lastWithdraw = now;\n', '        investor.witharawBuffer = 0;\n', '\n', '        globalWithdraw = globalWithdraw + amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit Withdraw(msg.sender, amount);\n', '    }\n', '\n', '}']
