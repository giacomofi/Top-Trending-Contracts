['pragma solidity >= 0.4.24;\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external;\n', '\tfunction transferFrom(address from, address to, uint value) external;\n', '    function balanceOf(address tokenOwner) constant external returns (uint balance);\n', '    function allowance(address _owner, address _spender) constant external returns (uint remaining); \n', '}\n', '\n', 'contract againstTokenTransfer {\n', '    mapping(address => bool) public active;\n', '    mapping(address => bool) public exists;\n', '    mapping(address => uint) public index;\n', '    mapping(address => string) public tkname;\n', '    mapping(address => uint) public decimals;\n', '\tmapping(address => uint) public rate; //with 18 decimal places\n', '\tmapping(address => uint) public buyoffer; //in AGAINST\n', '\ttoken tokenReward = token(0xF7Be133620a7D944595683cE2B14156591EFe609); // Market Token\n', '\t\t\n', '    string public name = "AGAINST TKDEX";\n', '    string public symbol = "AGAINST";\n', '    string public comment = "AGAINST Token Market";\n', '    address internal owner;\n', '    uint public indexcount = 0;\n', '\t\n', '\tconstructor() public {\n', '       owner = address(msg.sender); \n', '    }\n', '\t\n', '\tfunction registerToken(address _token, string _name, uint _decimals, uint _rate, uint _buyoffer) public {\n', '\t   if (msg.sender == owner) {\n', '         if (!exists[_token]) {\n', '            exists[_token] = true;\n', '            indexcount = indexcount+1;\n', '            index[_token] = indexcount;\n', '            active[_token] = false;\n', '         }\t     \n', '\t\t tkname[_token] = _name;\n', '         decimals[_token] = _decimals;\n', '\t\t rate[_token] = _rate; //with 18 decimal places\n', '\t\t buyoffer[_token] = _buyoffer;\t//with 18 decimal places (decimals of token base)\t \n', '\t   }\n', '\t}\n', '\t\n', '\tfunction enableToken(address _token) public {\n', '\t   if (msg.sender == owner) {\n', '\t      active[_token] = true;\n', '\t   }\n', '\t}\t\n', '\t\n', '\tfunction disableToken(address _token) public {\n', '\t   if (msg.sender == owner) {\n', '\t      active[_token] = false;\n', '\t   }\n', '\t}\n', '\t\n', '\tfunction exchangeIt(address _token) public payable {\n', "\t   require(active[_token],'Token Disabled');\n", '       token swapToken = token(_token);\n', '       require(swapToken.allowance(msg.sender, address(this)) > 0);\n', '       uint tokenAmount = swapToken.allowance(msg.sender, address(this));\n', '       if (tokenAmount > swapToken.balanceOf(msg.sender)) { tokenAmount = swapToken.balanceOf(msg.sender);}\n', '       uint amount = (tokenAmount/(10**decimals[_token]))*rate[_token];\n', "\t   require(amount <= buyoffer[_token],'Too many coins');\n", "       require(tokenReward.balanceOf(address(this)) >= amount,'No contract Funds');\n", '       swapToken.transferFrom(msg.sender, owner, tokenAmount);\n', '\t   buyoffer[_token] = buyoffer[_token]-amount;\n', '\t   tokenReward.transfer(msg.sender, amount);\n', '\t}\n', '\t\n', '}']