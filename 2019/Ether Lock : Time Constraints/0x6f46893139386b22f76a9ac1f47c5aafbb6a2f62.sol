['pragma solidity ^0.4.24;\n', '\n', '// File: contracts\\utils\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  /**\n', '  * @dev gives square root of given x.\n', '  */\n', '  function sqrt(uint256 x)\n', '    internal\n', '    pure\n', '    returns (uint256 y)\n', '  {\n', '    uint256 z = ((add(x,1)) / 2);\n', '    y = x;\n', '    while (z < y)\n', '    {\n', '        y = z;\n', '        z = ((add((x / z),z)) / 2);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev gives square. multiplies x by x\n', '  */\n', '  function sq(uint256 x)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return (mul(x,x));\n', '  }\n', '\n', '  /**\n', '  * @dev x to the power of y\n', '  */\n', '  function pwr(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (x==0)\n', '        return (0);\n', '    else if (y==0)\n', '        return (1);\n', '    else\n', '    {\n', '        uint256 z = x;\n', '        for (uint256 i=1; i < y; i++)\n', '            z = mul(z,x);\n', '        return (z);\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts\\CKingCal.sol\n', '\n', 'library CKingCal {\n', '\n', '  using SafeMath for *;\n', '  /**\n', '  * @dev calculates number of keys received given X eth\n', '  * @param _curEth current amount of eth in contract\n', '  * @param _newEth eth being spent\n', '  * @return amount of ticket purchased\n', '  */\n', '  function keysRec(uint256 _curEth, uint256 _newEth)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n', '  }\n', '\n', '  /**\n', '  * @dev calculates amount of eth received if you sold X keys\n', '  * @param _curKeys current amount of keys that exist\n', '  * @param _sellKeys amount of keys you wish to sell\n', '  * @return amount of eth received\n', '  */\n', '  function ethRec(uint256 _curKeys, uint256 _sellKeys)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n', '  }\n', '\n', '  /**\n', '  * @dev calculates how many keys would exist with given an amount of eth\n', '  * @param _eth total ether received.\n', '  * @return number of keys that would exist\n', '  */\n', '  function keys(uint256 _eth)\n', '    internal\n', '    pure\n', '    returns(uint256)\n', '  {\n', '      // sqrt((eth*1 eth* 312500000000000000000000000)+5624988281256103515625000000000000000000000000000000000000000000) - 74999921875000000000000000000000) / 15625000\n', '      return ((((((_eth).mul(1000000000000000000)).mul(31250000000000000000000000)).add(56249882812561035156250000000000000000000000000000000000000000)).sqrt()).sub(7499992187500000000000000000000)) / (15625000);\n', '  }  \n', '\n', '  /**\n', '  * @dev calculates how much eth would be in contract given a number of keys\n', '  * @param _keys number of keys "in contract"\n', '  * @return eth that would exists\n', '  */\n', '  function eth(uint256 _keys)\n', '    internal\n', '    pure\n', '    returns(uint256)\n', '  {\n', '    // (149999843750000*keys*1 eth) + 78125000 * keys * keys) /2 /(sq(1 ether))\n', '    return ((7812500).mul(_keys.sq()).add(((14999984375000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n', '  }\n', '}\n', '\n', '// File: contracts\\utils\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\TowerCKing.sol\n', '\n', 'contract CKing is Ownable {\n', '  using SafeMath for *;\n', '  using CKingCal for uint256;\n', '\n', '\n', '  string constant public name = "Cryptower";\n', '  string constant public symbol = "CT";\n', '\n', '  // time constants;\n', '  uint256 constant private timeInit = 1 weeks; // 600; //1 week \n', '  uint256 constant private timeInc = 30 seconds; //60 ///////\n', '  uint256 constant private timeMax = 30 minutes; // 300\n', '\n', '  // profit distribution parameters\n', '  uint256 constant private fixRet = 46;\n', '  uint256 constant private extraRet = 10;\n', '  uint256 constant private affRet = 10;\n', '  uint256 constant private gamePrize = 12;\n', '  uint256 constant private groupPrize = 12;\n', '  uint256 constant private devTeam = 10;\n', '\n', '  // player data\n', '  struct Player {\n', '    address addr; // player address\n', '    string name; // playerName\n', '    uint256 aff;  // affliliate vault\n', '    uint256 affId; // affiliate id, who referered u\n', '    uint256 hretKeys; // number of high return keys\n', '    uint256 mretKeys; // number of medium return keys\n', '    uint256 lretKeys; // number of low return keys\n', '    uint256 eth;      // total eth spend for the keys\n', '    uint256 ethWithdraw; // earning withdrawed by user\n', '  }\n', '\n', '  mapping(uint256 => Player) public players; // player data\n', '  mapping(address => uint) public addrXpId; // player address => pId\n', '  uint public playerNum = 0;\n', '\n', '  // game info\n', '  uint256 public totalEther;     // total key sale revenue\n', '  uint256 public totalKeys;      // total number of keys.\n', '  uint256 private constant minPay = 1000000000; // minimum pay to buy keys or deposit in game;\n', '  uint256 public totalCommPot;   // total ether going to be distributed\n', '  uint256 private keysForGame;    // keys belongs to the game for profit distribution\n', '  uint256 private gamePot;        // ether need to be distributed based on the side chain game\n', '  uint256 public teamWithdrawed; // eth withdrawed by dev team. \n', '  uint256 public gameWithdrawed; // ether already been withdrawn from game pot \n', '  uint256 public endTime;        // main game end time\n', '  address public CFO;\n', '  address public COO; \n', '  address public fundCenter; \n', '  address public playerBook; \n', '\n', '\n', '\n', '  uint private stageId = 1;   // stageId start 1\n', '  uint private constant groupPrizeStartAt = 2000000000000000000000000; // 1000000000000000000000;\n', '  uint private constant groupPrizeStageGap = 100000000000000000000000; // 100000000000000000000\n', '  mapping(uint => mapping(uint => uint)) public stageInfo; // stageId => pID => keys purchased in this stage\n', '\n', '  // admin params\n', '  uint256 public startTime;  // admin set start\n', '  uint256 constant private coolDownTime = 2 days; // team is able to withdraw fund 2 days after game end.\n', '\n', '  modifier isGameActive() {\n', '    uint _now = now;\n', '    require(_now > startTime && _now < endTime);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyCOO() {\n', '    require(COO == msg.sender, "Only COO can operate.");\n', '    _; \n', '  }\n', '\n', '  // events\n', '  event BuyKey(uint indexed _pID, uint _affId, uint _keyType, uint _keyAmount);\n', '  event EarningWithdraw(uint indexed _pID, address _addr, uint _amount);\n', '\n', '\n', '  constructor(address _CFO, address _COO, address _fundCenter, address _playerBook) public {\n', '    CFO = _CFO;\n', '    COO = _COO; \n', '    fundCenter = _fundCenter; \n', '    playerBook = _playerBook; \n', '  }\n', '    \n', '  function setCFO(address _CFO) onlyOwner public {\n', '    CFO = _CFO; \n', '  }  \n', '  \n', '  function setCOO(address _COO) onlyOwner public {\n', '    COO = _COO; \n', '  }  \n', '  \n', '  function setContractAddress(address _fundCenter, address _playerBook) onlyCOO public {\n', '    fundCenter = _fundCenter; \n', '    playerBook = _playerBook; \n', '  }\n', '\n', '  function startGame(uint _startTime) onlyCOO public {\n', '    require(_startTime > now);\n', '    startTime = _startTime;\n', '    endTime = startTime.add(timeInit);\n', '  }\n', '  \n', '  function gameWithdraw(uint _amount) onlyCOO public {\n', '    // users may choose to withdraw eth from cryptower game, allow dev team to withdraw eth from this contract to fund center. \n', '    uint _total = getTotalGamePot(); \n', '    uint _remainingBalance = _total.sub(gameWithdrawed); \n', '    \n', '    if(_amount > 0) {\n', '      require(_amount <= _remainingBalance);\n', '    } else{\n', '      _amount = _remainingBalance;\n', '    }\n', '    \n', '    fundCenter.transfer(_amount); \n', '    gameWithdrawed = gameWithdrawed.add(_amount); \n', '  }\n', '\n', '\n', '  function teamWithdraw(uint _amount) onlyCOO public {\n', '    uint256 _now = now;\n', '    if(_now > endTime.add(coolDownTime)) {\n', '      // dev team have rights to withdraw all remaining balance 2 days after game end. \n', '      // if users does not claim their ETH within coolDown period, the team may withdraw their remaining balance. Users can go to crytower game to get their ETH back.\n', '      CFO.transfer(_amount);\n', '      teamWithdrawed = teamWithdrawed.add(_amount); \n', '    } else {\n', '        uint _total = totalEther.mul(devTeam).div(100); \n', '        uint _remainingBalance = _total.sub(teamWithdrawed); \n', '        \n', '        if(_amount > 0) {\n', '            require(_amount <= _remainingBalance);\n', '        } else{\n', '            _amount = _remainingBalance;\n', '        }\n', '        CFO.transfer(_amount);\n', '        teamWithdrawed = teamWithdrawed.add(_amount); \n', '    }\n', '  }\n', '  \n', '\n', '  function updateTimer(uint256 _keys) private {\n', '    uint256 _now = now;\n', '    uint256 _newTime;\n', '\n', '    if(endTime.sub(_now) < timeMax) {\n', '        _newTime = ((_keys) / (1000000000000000000)).mul(timeInc).add(endTime);\n', '        if(_newTime.sub(_now) > timeMax) {\n', '            _newTime = _now.add(timeMax);\n', '        }\n', '        endTime = _newTime;\n', '    }\n', '  }\n', '  \n', '  function receivePlayerInfo(address _addr, string _name) external {\n', '    require(msg.sender == playerBook, "must be from playerbook address"); \n', '    uint _pID = addrXpId[_addr];\n', '    if(_pID == 0) { // player not exist yet. create one \n', '        playerNum = playerNum + 1;\n', '        Player memory p; \n', '        p.addr = _addr;\n', '        p.name = _name; \n', '        players[playerNum] = p; \n', '        _pID = playerNum; \n', '        addrXpId[_addr] = _pID;\n', '    } else {\n', '        players[_pID].name = _name; \n', '    }\n', '  }\n', '\n', '  function buyByAddress(uint256 _affId, uint _keyType) payable isGameActive public {\n', '    uint _pID = addrXpId[msg.sender];\n', '    if(_pID == 0) { // player not exist yet. create one\n', '      playerNum = playerNum + 1;\n', '      Player memory p;\n', '      p.addr = msg.sender;\n', '      p.affId = _affId;\n', '      players[playerNum] = p;\n', '      _pID = playerNum;\n', '      addrXpId[msg.sender] = _pID;\n', '    }\n', '    buy(_pID, msg.value, _affId, _keyType);\n', '  }\n', '\n', '  function buyFromVault(uint _amount, uint256 _affId, uint _keyType) public isGameActive  {\n', '    uint _pID = addrXpId[msg.sender];\n', '    uint _earning = getPlayerEarning(_pID);\n', '    uint _newEthWithdraw = _amount.add(players[_pID].ethWithdraw);\n', '    require(_newEthWithdraw < _earning); // withdraw amount cannot bigger than earning\n', '    players[_pID].ethWithdraw = _newEthWithdraw; // update player withdraw\n', '    buy(_pID, _amount, _affId, _keyType);\n', '  }\n', '\n', '  function getKeyPrice(uint _keyAmount) public view returns(uint256) {\n', '    if(now > startTime) {\n', '      return totalKeys.add(_keyAmount).ethRec(_keyAmount);\n', '    } else { // copy fomo init price\n', '      return (7500000000000);\n', '    }\n', '  }\n', '\n', '  function buy(uint256 _pID, uint256 _eth, uint256 _affId, uint _keyType) private {\n', '\n', '    if (_eth > minPay) { // bigger than minimum pay\n', '      players[_pID].eth = _eth.add(players[_pID].eth);\n', '      uint _keys = totalEther.keysRec(_eth);\n', '      //bought at least 1 whole key\n', '      if(_keys >= 1000000000000000000) {\n', '        updateTimer(_keys);\n', '      }\n', '\n', '      //update total ether and total keys\n', '      totalEther = totalEther.add(_eth);\n', '      totalKeys = totalKeys.add(_keys);\n', '      // update game portion\n', '      uint256 _game = _eth.mul(gamePrize).div(100);\n', '      gamePot = _game.add(gamePot);\n', '\n', '\n', '      // update player keys and keysForGame\n', '      if(_keyType == 1) { // high return key\n', '        players[_pID].hretKeys  = _keys.add(players[_pID].hretKeys);\n', '      } else if (_keyType == 2) {\n', '        players[_pID].mretKeys = _keys.add(players[_pID].mretKeys);\n', '        keysForGame = keysForGame.add(_keys.mul(extraRet).div(fixRet+extraRet));\n', '      } else if (_keyType == 3) {\n', '        players[_pID].lretKeys = _keys.add(players[_pID].lretKeys);\n', '        keysForGame = keysForGame.add(_keys);\n', '      } else { // keytype unknown.\n', '        revert();\n', '      }\n', '      //update affliliate gain\n', '      if(_affId != 0 && _affId != _pID && _affId <= playerNum) { // udate players\n', '          uint256 _aff = _eth.mul(affRet).div(100);\n', '          players[_affId].aff = _aff.add(players[_affId].aff);\n', '          totalCommPot = (_eth.mul(fixRet+extraRet).div(100)).add(totalCommPot);\n', '      } else { // addId == 0 or _affId is self, put the fund into earnings per key\n', '          totalCommPot = (_eth.mul(fixRet+extraRet+affRet).div(100)).add(totalCommPot);\n', '      }\n', '      // update stage info\n', '      if(totalKeys > groupPrizeStartAt) {\n', '        updateStageInfo(_pID, _keys);\n', '      }\n', '      emit BuyKey(_pID, _affId, _keyType, _keys);\n', '    } else { // if contribute less than the minimum conntribution return to player aff vault\n', '      players[_pID].aff = _eth.add(players[_pID].aff);\n', '    }\n', '  }\n', '\n', '  function updateStageInfo(uint _pID, uint _keyAmount) private {\n', '    uint _stageL = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1));\n', '    uint _stageH = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId));\n', '    if(totalKeys > _stageH) { // game has been pushed to next stage\n', '      stageId = (totalKeys.sub(groupPrizeStartAt)).div(groupPrizeStageGap) + 1;\n', '      _keyAmount = (totalKeys.sub(groupPrizeStartAt)) % groupPrizeStageGap;\n', '      stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '    } else {\n', '      if(_keyAmount < totalKeys.sub(_stageL)) {\n', '        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '      } else {\n', '        _keyAmount = totalKeys.sub(_stageL);\n', '        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '      }\n', '    }\n', '  }\n', '\n', '  function withdrawEarning(uint256 _amount) public {\n', '    address _addr = msg.sender;\n', '    uint256 _pID = addrXpId[_addr];\n', '    require(_pID != 0);  // player must exist\n', '\n', '    uint _earning = getPlayerEarning(_pID);\n', '    uint _remainingBalance = _earning.sub(players[_pID].ethWithdraw);\n', '    if(_amount > 0) {\n', '      require(_amount <= _remainingBalance);\n', '    }else{\n', '      _amount = _remainingBalance;\n', '    }\n', '\n', '\n', '    _addr.transfer(_amount);  // transfer remaining balance to\n', '    players[_pID].ethWithdraw = players[_pID].ethWithdraw.add(_amount);\n', '  }\n', '\n', '  function getPlayerEarning(uint256 _pID) view public returns (uint256) {\n', '    Player memory p = players[_pID];\n', '    uint _gain = totalCommPot.mul(p.hretKeys.add(p.mretKeys.mul(fixRet).div(fixRet+extraRet))).div(totalKeys);\n', '    uint _total = _gain.add(p.aff);\n', '    _total = getWinnerPrize(_pID).add(_total);\n', '    return _total;\n', '  }\n', '\n', '  function getPlayerWithdrawEarning(uint _pid) public view returns(uint){\n', '    uint _earning = getPlayerEarning(_pid);\n', '    return _earning.sub(players[_pid].ethWithdraw);\n', '  }\n', '\n', '  function getWinnerPrize(uint256 _pID) view public returns (uint256) {\n', '    uint _keys;\n', '    uint _pKeys;\n', '    if(now < endTime) {\n', '      return 0;\n', '    } else if(totalKeys > groupPrizeStartAt) { // keys in the winner stage share the group prize\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      _pKeys = stageInfo[stageId][_pID];\n', '      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(_keys);\n', '    } else { // totalkeys does not meet the minimum group prize criteria, all keys share the group prize\n', '      Player memory p = players[_pID];\n', '      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\n', '      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(totalKeys);\n', '    }\n', '  }\n', '\n', '  function getWinningStageInfo() view public returns (uint256 _stageId, uint256 _keys, uint256 _amount) {\n', '    _amount = totalEther.mul(groupPrize).div(100);\n', '    if(totalKeys < groupPrizeStartAt) { // group prize is not activate yet\n', '      return (0, totalKeys, _amount);\n', '    } else {\n', '      _stageId = stageId;\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      return (_stageId, _keys, _amount);\n', '    }\n', '  }\n', '\n', '  function getPlayerStageKeys() view public returns (uint256 _stageId, uint _keys, uint _pKeys) {\n', '    uint _pID = addrXpId[msg.sender];\n', '    if(totalKeys < groupPrizeStartAt) {\n', '      Player memory p = players[_pID];\n', '      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\n', '      return (0, totalKeys, _pKeys);\n', '    } else {\n', '      _stageId = stageId;\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      _pKeys = stageInfo[_stageId][_pID];\n', '      return (_stageId, _keys, _pKeys);\n', '    }\n', '\n', '  }\n', '\n', '  function getTotalGamePot() view public returns (uint256) {\n', '    uint _gain = totalCommPot.mul(keysForGame).div(totalKeys);\n', '    uint _total = _gain.add(gamePot);\n', '    return _total;\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts\\utils\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  /**\n', '  * @dev gives square root of given x.\n', '  */\n', '  function sqrt(uint256 x)\n', '    internal\n', '    pure\n', '    returns (uint256 y)\n', '  {\n', '    uint256 z = ((add(x,1)) / 2);\n', '    y = x;\n', '    while (z < y)\n', '    {\n', '        y = z;\n', '        z = ((add((x / z),z)) / 2);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev gives square. multiplies x by x\n', '  */\n', '  function sq(uint256 x)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return (mul(x,x));\n', '  }\n', '\n', '  /**\n', '  * @dev x to the power of y\n', '  */\n', '  function pwr(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (x==0)\n', '        return (0);\n', '    else if (y==0)\n', '        return (1);\n', '    else\n', '    {\n', '        uint256 z = x;\n', '        for (uint256 i=1; i < y; i++)\n', '            z = mul(z,x);\n', '        return (z);\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts\\CKingCal.sol\n', '\n', 'library CKingCal {\n', '\n', '  using SafeMath for *;\n', '  /**\n', '  * @dev calculates number of keys received given X eth\n', '  * @param _curEth current amount of eth in contract\n', '  * @param _newEth eth being spent\n', '  * @return amount of ticket purchased\n', '  */\n', '  function keysRec(uint256 _curEth, uint256 _newEth)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n', '  }\n', '\n', '  /**\n', '  * @dev calculates amount of eth received if you sold X keys\n', '  * @param _curKeys current amount of keys that exist\n', '  * @param _sellKeys amount of keys you wish to sell\n', '  * @return amount of eth received\n', '  */\n', '  function ethRec(uint256 _curKeys, uint256 _sellKeys)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n', '  }\n', '\n', '  /**\n', '  * @dev calculates how many keys would exist with given an amount of eth\n', '  * @param _eth total ether received.\n', '  * @return number of keys that would exist\n', '  */\n', '  function keys(uint256 _eth)\n', '    internal\n', '    pure\n', '    returns(uint256)\n', '  {\n', '      // sqrt((eth*1 eth* 312500000000000000000000000)+5624988281256103515625000000000000000000000000000000000000000000) - 74999921875000000000000000000000) / 15625000\n', '      return ((((((_eth).mul(1000000000000000000)).mul(31250000000000000000000000)).add(56249882812561035156250000000000000000000000000000000000000000)).sqrt()).sub(7499992187500000000000000000000)) / (15625000);\n', '  }  \n', '\n', '  /**\n', '  * @dev calculates how much eth would be in contract given a number of keys\n', '  * @param _keys number of keys "in contract"\n', '  * @return eth that would exists\n', '  */\n', '  function eth(uint256 _keys)\n', '    internal\n', '    pure\n', '    returns(uint256)\n', '  {\n', '    // (149999843750000*keys*1 eth) + 78125000 * keys * keys) /2 /(sq(1 ether))\n', '    return ((7812500).mul(_keys.sq()).add(((14999984375000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n', '  }\n', '}\n', '\n', '// File: contracts\\utils\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\TowerCKing.sol\n', '\n', 'contract CKing is Ownable {\n', '  using SafeMath for *;\n', '  using CKingCal for uint256;\n', '\n', '\n', '  string constant public name = "Cryptower";\n', '  string constant public symbol = "CT";\n', '\n', '  // time constants;\n', '  uint256 constant private timeInit = 1 weeks; // 600; //1 week \n', '  uint256 constant private timeInc = 30 seconds; //60 ///////\n', '  uint256 constant private timeMax = 30 minutes; // 300\n', '\n', '  // profit distribution parameters\n', '  uint256 constant private fixRet = 46;\n', '  uint256 constant private extraRet = 10;\n', '  uint256 constant private affRet = 10;\n', '  uint256 constant private gamePrize = 12;\n', '  uint256 constant private groupPrize = 12;\n', '  uint256 constant private devTeam = 10;\n', '\n', '  // player data\n', '  struct Player {\n', '    address addr; // player address\n', '    string name; // playerName\n', '    uint256 aff;  // affliliate vault\n', '    uint256 affId; // affiliate id, who referered u\n', '    uint256 hretKeys; // number of high return keys\n', '    uint256 mretKeys; // number of medium return keys\n', '    uint256 lretKeys; // number of low return keys\n', '    uint256 eth;      // total eth spend for the keys\n', '    uint256 ethWithdraw; // earning withdrawed by user\n', '  }\n', '\n', '  mapping(uint256 => Player) public players; // player data\n', '  mapping(address => uint) public addrXpId; // player address => pId\n', '  uint public playerNum = 0;\n', '\n', '  // game info\n', '  uint256 public totalEther;     // total key sale revenue\n', '  uint256 public totalKeys;      // total number of keys.\n', '  uint256 private constant minPay = 1000000000; // minimum pay to buy keys or deposit in game;\n', '  uint256 public totalCommPot;   // total ether going to be distributed\n', '  uint256 private keysForGame;    // keys belongs to the game for profit distribution\n', '  uint256 private gamePot;        // ether need to be distributed based on the side chain game\n', '  uint256 public teamWithdrawed; // eth withdrawed by dev team. \n', '  uint256 public gameWithdrawed; // ether already been withdrawn from game pot \n', '  uint256 public endTime;        // main game end time\n', '  address public CFO;\n', '  address public COO; \n', '  address public fundCenter; \n', '  address public playerBook; \n', '\n', '\n', '\n', '  uint private stageId = 1;   // stageId start 1\n', '  uint private constant groupPrizeStartAt = 2000000000000000000000000; // 1000000000000000000000;\n', '  uint private constant groupPrizeStageGap = 100000000000000000000000; // 100000000000000000000\n', '  mapping(uint => mapping(uint => uint)) public stageInfo; // stageId => pID => keys purchased in this stage\n', '\n', '  // admin params\n', '  uint256 public startTime;  // admin set start\n', '  uint256 constant private coolDownTime = 2 days; // team is able to withdraw fund 2 days after game end.\n', '\n', '  modifier isGameActive() {\n', '    uint _now = now;\n', '    require(_now > startTime && _now < endTime);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyCOO() {\n', '    require(COO == msg.sender, "Only COO can operate.");\n', '    _; \n', '  }\n', '\n', '  // events\n', '  event BuyKey(uint indexed _pID, uint _affId, uint _keyType, uint _keyAmount);\n', '  event EarningWithdraw(uint indexed _pID, address _addr, uint _amount);\n', '\n', '\n', '  constructor(address _CFO, address _COO, address _fundCenter, address _playerBook) public {\n', '    CFO = _CFO;\n', '    COO = _COO; \n', '    fundCenter = _fundCenter; \n', '    playerBook = _playerBook; \n', '  }\n', '    \n', '  function setCFO(address _CFO) onlyOwner public {\n', '    CFO = _CFO; \n', '  }  \n', '  \n', '  function setCOO(address _COO) onlyOwner public {\n', '    COO = _COO; \n', '  }  \n', '  \n', '  function setContractAddress(address _fundCenter, address _playerBook) onlyCOO public {\n', '    fundCenter = _fundCenter; \n', '    playerBook = _playerBook; \n', '  }\n', '\n', '  function startGame(uint _startTime) onlyCOO public {\n', '    require(_startTime > now);\n', '    startTime = _startTime;\n', '    endTime = startTime.add(timeInit);\n', '  }\n', '  \n', '  function gameWithdraw(uint _amount) onlyCOO public {\n', '    // users may choose to withdraw eth from cryptower game, allow dev team to withdraw eth from this contract to fund center. \n', '    uint _total = getTotalGamePot(); \n', '    uint _remainingBalance = _total.sub(gameWithdrawed); \n', '    \n', '    if(_amount > 0) {\n', '      require(_amount <= _remainingBalance);\n', '    } else{\n', '      _amount = _remainingBalance;\n', '    }\n', '    \n', '    fundCenter.transfer(_amount); \n', '    gameWithdrawed = gameWithdrawed.add(_amount); \n', '  }\n', '\n', '\n', '  function teamWithdraw(uint _amount) onlyCOO public {\n', '    uint256 _now = now;\n', '    if(_now > endTime.add(coolDownTime)) {\n', '      // dev team have rights to withdraw all remaining balance 2 days after game end. \n', '      // if users does not claim their ETH within coolDown period, the team may withdraw their remaining balance. Users can go to crytower game to get their ETH back.\n', '      CFO.transfer(_amount);\n', '      teamWithdrawed = teamWithdrawed.add(_amount); \n', '    } else {\n', '        uint _total = totalEther.mul(devTeam).div(100); \n', '        uint _remainingBalance = _total.sub(teamWithdrawed); \n', '        \n', '        if(_amount > 0) {\n', '            require(_amount <= _remainingBalance);\n', '        } else{\n', '            _amount = _remainingBalance;\n', '        }\n', '        CFO.transfer(_amount);\n', '        teamWithdrawed = teamWithdrawed.add(_amount); \n', '    }\n', '  }\n', '  \n', '\n', '  function updateTimer(uint256 _keys) private {\n', '    uint256 _now = now;\n', '    uint256 _newTime;\n', '\n', '    if(endTime.sub(_now) < timeMax) {\n', '        _newTime = ((_keys) / (1000000000000000000)).mul(timeInc).add(endTime);\n', '        if(_newTime.sub(_now) > timeMax) {\n', '            _newTime = _now.add(timeMax);\n', '        }\n', '        endTime = _newTime;\n', '    }\n', '  }\n', '  \n', '  function receivePlayerInfo(address _addr, string _name) external {\n', '    require(msg.sender == playerBook, "must be from playerbook address"); \n', '    uint _pID = addrXpId[_addr];\n', '    if(_pID == 0) { // player not exist yet. create one \n', '        playerNum = playerNum + 1;\n', '        Player memory p; \n', '        p.addr = _addr;\n', '        p.name = _name; \n', '        players[playerNum] = p; \n', '        _pID = playerNum; \n', '        addrXpId[_addr] = _pID;\n', '    } else {\n', '        players[_pID].name = _name; \n', '    }\n', '  }\n', '\n', '  function buyByAddress(uint256 _affId, uint _keyType) payable isGameActive public {\n', '    uint _pID = addrXpId[msg.sender];\n', '    if(_pID == 0) { // player not exist yet. create one\n', '      playerNum = playerNum + 1;\n', '      Player memory p;\n', '      p.addr = msg.sender;\n', '      p.affId = _affId;\n', '      players[playerNum] = p;\n', '      _pID = playerNum;\n', '      addrXpId[msg.sender] = _pID;\n', '    }\n', '    buy(_pID, msg.value, _affId, _keyType);\n', '  }\n', '\n', '  function buyFromVault(uint _amount, uint256 _affId, uint _keyType) public isGameActive  {\n', '    uint _pID = addrXpId[msg.sender];\n', '    uint _earning = getPlayerEarning(_pID);\n', '    uint _newEthWithdraw = _amount.add(players[_pID].ethWithdraw);\n', '    require(_newEthWithdraw < _earning); // withdraw amount cannot bigger than earning\n', '    players[_pID].ethWithdraw = _newEthWithdraw; // update player withdraw\n', '    buy(_pID, _amount, _affId, _keyType);\n', '  }\n', '\n', '  function getKeyPrice(uint _keyAmount) public view returns(uint256) {\n', '    if(now > startTime) {\n', '      return totalKeys.add(_keyAmount).ethRec(_keyAmount);\n', '    } else { // copy fomo init price\n', '      return (7500000000000);\n', '    }\n', '  }\n', '\n', '  function buy(uint256 _pID, uint256 _eth, uint256 _affId, uint _keyType) private {\n', '\n', '    if (_eth > minPay) { // bigger than minimum pay\n', '      players[_pID].eth = _eth.add(players[_pID].eth);\n', '      uint _keys = totalEther.keysRec(_eth);\n', '      //bought at least 1 whole key\n', '      if(_keys >= 1000000000000000000) {\n', '        updateTimer(_keys);\n', '      }\n', '\n', '      //update total ether and total keys\n', '      totalEther = totalEther.add(_eth);\n', '      totalKeys = totalKeys.add(_keys);\n', '      // update game portion\n', '      uint256 _game = _eth.mul(gamePrize).div(100);\n', '      gamePot = _game.add(gamePot);\n', '\n', '\n', '      // update player keys and keysForGame\n', '      if(_keyType == 1) { // high return key\n', '        players[_pID].hretKeys  = _keys.add(players[_pID].hretKeys);\n', '      } else if (_keyType == 2) {\n', '        players[_pID].mretKeys = _keys.add(players[_pID].mretKeys);\n', '        keysForGame = keysForGame.add(_keys.mul(extraRet).div(fixRet+extraRet));\n', '      } else if (_keyType == 3) {\n', '        players[_pID].lretKeys = _keys.add(players[_pID].lretKeys);\n', '        keysForGame = keysForGame.add(_keys);\n', '      } else { // keytype unknown.\n', '        revert();\n', '      }\n', '      //update affliliate gain\n', '      if(_affId != 0 && _affId != _pID && _affId <= playerNum) { // udate players\n', '          uint256 _aff = _eth.mul(affRet).div(100);\n', '          players[_affId].aff = _aff.add(players[_affId].aff);\n', '          totalCommPot = (_eth.mul(fixRet+extraRet).div(100)).add(totalCommPot);\n', '      } else { // addId == 0 or _affId is self, put the fund into earnings per key\n', '          totalCommPot = (_eth.mul(fixRet+extraRet+affRet).div(100)).add(totalCommPot);\n', '      }\n', '      // update stage info\n', '      if(totalKeys > groupPrizeStartAt) {\n', '        updateStageInfo(_pID, _keys);\n', '      }\n', '      emit BuyKey(_pID, _affId, _keyType, _keys);\n', '    } else { // if contribute less than the minimum conntribution return to player aff vault\n', '      players[_pID].aff = _eth.add(players[_pID].aff);\n', '    }\n', '  }\n', '\n', '  function updateStageInfo(uint _pID, uint _keyAmount) private {\n', '    uint _stageL = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1));\n', '    uint _stageH = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId));\n', '    if(totalKeys > _stageH) { // game has been pushed to next stage\n', '      stageId = (totalKeys.sub(groupPrizeStartAt)).div(groupPrizeStageGap) + 1;\n', '      _keyAmount = (totalKeys.sub(groupPrizeStartAt)) % groupPrizeStageGap;\n', '      stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '    } else {\n', '      if(_keyAmount < totalKeys.sub(_stageL)) {\n', '        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '      } else {\n', '        _keyAmount = totalKeys.sub(_stageL);\n', '        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\n', '      }\n', '    }\n', '  }\n', '\n', '  function withdrawEarning(uint256 _amount) public {\n', '    address _addr = msg.sender;\n', '    uint256 _pID = addrXpId[_addr];\n', '    require(_pID != 0);  // player must exist\n', '\n', '    uint _earning = getPlayerEarning(_pID);\n', '    uint _remainingBalance = _earning.sub(players[_pID].ethWithdraw);\n', '    if(_amount > 0) {\n', '      require(_amount <= _remainingBalance);\n', '    }else{\n', '      _amount = _remainingBalance;\n', '    }\n', '\n', '\n', '    _addr.transfer(_amount);  // transfer remaining balance to\n', '    players[_pID].ethWithdraw = players[_pID].ethWithdraw.add(_amount);\n', '  }\n', '\n', '  function getPlayerEarning(uint256 _pID) view public returns (uint256) {\n', '    Player memory p = players[_pID];\n', '    uint _gain = totalCommPot.mul(p.hretKeys.add(p.mretKeys.mul(fixRet).div(fixRet+extraRet))).div(totalKeys);\n', '    uint _total = _gain.add(p.aff);\n', '    _total = getWinnerPrize(_pID).add(_total);\n', '    return _total;\n', '  }\n', '\n', '  function getPlayerWithdrawEarning(uint _pid) public view returns(uint){\n', '    uint _earning = getPlayerEarning(_pid);\n', '    return _earning.sub(players[_pid].ethWithdraw);\n', '  }\n', '\n', '  function getWinnerPrize(uint256 _pID) view public returns (uint256) {\n', '    uint _keys;\n', '    uint _pKeys;\n', '    if(now < endTime) {\n', '      return 0;\n', '    } else if(totalKeys > groupPrizeStartAt) { // keys in the winner stage share the group prize\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      _pKeys = stageInfo[stageId][_pID];\n', '      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(_keys);\n', '    } else { // totalkeys does not meet the minimum group prize criteria, all keys share the group prize\n', '      Player memory p = players[_pID];\n', '      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\n', '      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(totalKeys);\n', '    }\n', '  }\n', '\n', '  function getWinningStageInfo() view public returns (uint256 _stageId, uint256 _keys, uint256 _amount) {\n', '    _amount = totalEther.mul(groupPrize).div(100);\n', '    if(totalKeys < groupPrizeStartAt) { // group prize is not activate yet\n', '      return (0, totalKeys, _amount);\n', '    } else {\n', '      _stageId = stageId;\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      return (_stageId, _keys, _amount);\n', '    }\n', '  }\n', '\n', '  function getPlayerStageKeys() view public returns (uint256 _stageId, uint _keys, uint _pKeys) {\n', '    uint _pID = addrXpId[msg.sender];\n', '    if(totalKeys < groupPrizeStartAt) {\n', '      Player memory p = players[_pID];\n', '      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\n', '      return (0, totalKeys, _pKeys);\n', '    } else {\n', '      _stageId = stageId;\n', '      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\n', '      _pKeys = stageInfo[_stageId][_pID];\n', '      return (_stageId, _keys, _pKeys);\n', '    }\n', '\n', '  }\n', '\n', '  function getTotalGamePot() view public returns (uint256) {\n', '    uint _gain = totalCommPot.mul(keysForGame).div(totalKeys);\n', '    uint _total = _gain.add(gamePot);\n', '    return _total;\n', '  }\n', '  \n', '}']
