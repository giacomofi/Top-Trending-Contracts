['/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-04\n', '*/\n', '\n', '// File: ../3rdparty/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: ../3rdparty/openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: ../3rdparty/openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'contract Whitelist is Ownable{\n', '    mapping (uint256 => uint8) private _partners;\n', '    mapping (address => uint256) private _partner_ids;\n', '    mapping (uint256 => address) private _partner_address;\n', '    uint256 public partners_counter=1;\n', '    mapping (address => uint8) private _whitelist;\n', '    mapping (address => uint256) private _referrals;\n', '    mapping (uint256 => mapping(uint256=>address)) private _partners_referrals;\n', '    mapping (uint256 => uint256) _partners_referrals_counter;\n', '\n', '    uint8 public constant STATE_NEW = 0;\n', '    uint8 public constant STATE_WHITELISTED = 1;\n', '    uint8 public constant STATE_BLACKLISTED = 2;\n', '    uint8 public constant STATE_ONHOLD = 3;\n', '\n', '    event Whitelisted(address indexed partner, address indexed subscriber);\n', '    event AddPartner(address indexed partner, uint256 partner_id);\n', '\n', '    function _add_partner(address partner) private returns (bool){\n', '        _partner_ids[partner] = partners_counter;\n', '        _partner_address[partners_counter] = partner;\n', '        _partners[partners_counter] = STATE_WHITELISTED;\n', '        _whitelist[partner] = STATE_WHITELISTED;\n', '        emit AddPartner(partner, partners_counter);\n', '        partners_counter++;\n', '    }\n', '    \n', '    constructor () public {\n', '        _add_partner(msg.sender);\n', '    }\n', '\n', '    function getPartnerId(address partner) public view returns (uint256){\n', '        return _partner_ids[partner];\n', '    }\n', '\n', '    modifier onlyWhiteisted(){\n', '        require(_whitelist[msg.sender] == STATE_WHITELISTED, "Ownable: caller is not whitelisted");\n', '        _;\n', '    }\n', '\n', '    function isPartner() public view returns (bool){\n', '        return _partners[_partner_ids[msg.sender]] == STATE_WHITELISTED;\n', '    }\n', '\n', '    function partnerStatus(address partner) public view returns (uint8){\n', '        return _partners[_partner_ids[partner]];\n', '    }\n', '\n', '\n', '    modifier onlyPartnerOrOwner(){\n', '        require(isOwner() || isPartner(), "Ownable: caller is not the owner or partner");\n', '        _;\n', '    }\n', '\n', '    function setPartnerState(address partner, uint8 state) public onlyOwner returns(bool){\n', '        uint256 partner_id = getPartnerId(partner);\n', '        if( partner_id == 0 && state == STATE_WHITELISTED){\n', '            _add_partner(partner);\n', '        }else{\n', '            _partners[partner_id] = state;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function addPartner(address partner) public onlyOwner returns(bool){\n', '        _add_partner(partner);\n', '        return true;\n', '    }\n', '\n', '    function whitelist(address referral) public onlyPartnerOrOwner returns (bool){\n', '        require(_whitelist[referral] == STATE_NEW, "Referral is already whitelisted");\n', '        uint256 partner_id = getPartnerId(msg.sender);\n', '        require(partner_id != 0, "Partner not found");\n', '        _whitelist[referral] = STATE_WHITELISTED;\n', '        _referrals[referral] = partner_id;\n', '        _partners_referrals[partner_id][_partners_referrals_counter[partner_id]] = referral;\n', '        _partners_referrals_counter[partner_id] ++;\n', '        emit Whitelisted(msg.sender, referral);\n', '\n', '    }\n', '\n', '    function setWhitelistState(address referral, uint8 state) public onlyOwner returns (bool){\n', '        require(_whitelist[referral] != STATE_NEW, "Referral is not in list");\n', '        _whitelist[referral] = state;\n', '    }\n', '\n', '    function getWhitelistState(address referral) public view returns (uint8){\n', '        return _whitelist[referral];\n', '    }\n', '\n', '    function getPartner(address referral) public view returns (address){\n', '        return _partner_address[_referrals[referral]];\n', '    }\n', '\n', '    function setPartnersAddress(uint256 partner_id, address new_partner) public onlyOwner returns (bool){\n', '        _partner_address[partner_id] = new_partner;\n', '        _partner_ids[new_partner] = partner_id;\n', '        return true;\n', '    }\n', '\n', '    function bulkWhitelist(address[] memory address_list) public returns(bool){\n', '        for(uint256 i = 0; i < address_list.length; i++){\n', '            whitelist(address_list[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Periods.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'contract Periods is Ownable{\n', '    uint16 private _current_period;\n', '    uint16 private _total_periods;\n', '    mapping (uint16=>uint256) _periods;\n', '    bool _adjustable;\n', '\n', '    constructor() public{\n', '        _adjustable = true;\n', '    }\n', '\n', '    function getPeriodsCounter() public view returns(uint16){\n', '        return _total_periods;\n', '    }\n', '\n', '    function getCurrentPeriod() public view returns(uint16){\n', '        return _checkCurrentPeriod();\n', '    }\n', '\n', '    function getCurrentTime() public view returns(uint256){\n', '        return now;\n', '    }\n', '\n', '\n', '    function getCurrentPeriodTimestamp() public view returns(uint256){\n', '        return _periods[_current_period];\n', '    }\n', '\n', '    function getPeriodTimestamp(uint16 period) public view returns(uint256){\n', '        return _periods[period];\n', '    }\n', '\n', '    \n', '    function setCurrentPeriod(uint16 period) public onlyOwner returns (bool){\n', '        require(period < _total_periods, "Do not have timestamp for that period");\n', '        _current_period = period;\n', '        return true;\n', '    }\n', '\n', '\n', '    function addPeriodTimestamp(uint256 timestamp) public onlyOwner returns (bool){\n', '//        require(_total_periods - _current_period < 50, "Cannot add more that 50 periods from now");\n', '//        require((_current_period == 0) || (timestamp - _periods[_total_periods-1] > 28 days && (timestamp - _periods[_total_periods-1] < 32 days )), "Incorrect period)");\n', '        _periods[_total_periods] = timestamp;\n', '        _total_periods++;\n', '        return true;\n', '    }\n', '\n', '    function _checkCurrentPeriod() private view returns (uint16){\n', '        uint16 current_period = _current_period;\n', '        while( current_period < _total_periods-1){\n', '            if( now < _periods[current_period] ){\n', '                break;\n', '            }\n', '            current_period ++;\n', '        }\n', '        return current_period;\n', '    }\n', '\n', '    function adjustCurrentPeriod( ) public returns (uint16){\n', '        if(!_adjustable){\n', '            return _current_period;\n', '        }\n', '        require(_total_periods > 1, "Periods are not set");\n', '        require(_current_period < _total_periods, "Last period reached");\n', '        //require(_total_periods - _current_period < 50, "Adjust more that 50 periods from now");\n', '        uint16 current_period = _checkCurrentPeriod();\n', '        if(current_period > _current_period){\n', '            _current_period = current_period;\n', '        }\n', '        return current_period;\n', '    }\n', '\n', '    function addPeriodTimestamps(uint256[] memory timestamps) public onlyOwner returns(bool){\n', '        //require(timestamps.length < 50, "Cannot set more than 50 periods");\n', '        for(uint16 current_timestamp = 0; current_timestamp < timestamps.length; current_timestamp ++){\n', '            addPeriodTimestamp(timestamps[current_timestamp]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function setLastPeriod(uint16 period) public onlyOwner returns(bool){\n', '        require(period < _total_periods-1, "Incorrect period");\n', '        require(period > _current_period, "Cannot change passed periods");\n', '        _total_periods = period;\n', '        return true;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/Subscriptions.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', '\n', '\n', 'contract Subscriptions is Ownable, Periods {\n', '    using SafeMath for uint256;\n', '\n', '    uint8 STATE_MISSING = 0;\n', '    uint8 STATE_ACTIVE = 1;\n', '    uint8 STATE_WITHDRAWN = 2;\n', '    uint8 STATE_PAID = 3;\n', '\n', '    uint256 ROUNDING = 1000;\n', '\n', '    struct Subscription{\n', '        uint256 subscriber_id;\n', '        uint256 subscription;\n', '        uint256 certificates;\n', '        uint256 certificate_rate;\n', '        uint256 certificate_partners_rate;\n', '        uint16 period;\n', '        uint16 lockout_period;\n', '        uint16 total_periods;\n', '        uint256 certificates_redeemed;\n', '        uint256 redemption;\n', '        uint256 payout;\n', '        uint256 deposit;\n', '        uint256 commission;\n', '        uint256 paid_to_partner;\n', '        uint256 redeem_requested;\n', '        uint256 redeem_delivered;\n', '    }\n', '\n', '    mapping (address=>uint256) private _subscribers;\n', '    mapping (uint256=>address) private _subscribers_id;\n', '    uint256 private _subscribers_counter=1;\n', '\n', '    mapping (uint256=>Subscription) private _subscriptions;\n', '    mapping (uint256=>mapping(uint256=>uint256)) private _subscribers_subscriptions;\n', '    mapping (uint256=>mapping(uint16=>uint256)) private _subscribers_subscriptions_by_period;\n', '    mapping (uint256=>uint16) private _subscribers_subscriptions_recent;\n', '    uint256 private _subscriptions_counter=1;\n', '    mapping (uint256=>uint256) private _subscribers_subscriptions_counter;\n', '\n', '    uint256 private _commission;\n', '\n', '    uint256 private _total_subscription=0;\n', '    uint16 private _lockout_period;\n', '    uint16 private _max_period;\n', '\n', '    event Subscribe(address subscriber, uint256 subscription, uint256 certs );\n', '    event Topup(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Payout(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event RedemptionPartner(address indexed partner, address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event AmountCertNickelWireReceived(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '\n', '    constructor() public{\n', '        _lockout_period = 3;\n', '        _max_period = 24;\n', '        _commission = 1000;\n', '    }\n', '\n', '    function floor(uint a, uint m) internal pure returns (uint256 ) {\n', '        return ((a ) / m) * m;\n', '    }\n', '\n', '    function ceil(uint a, uint m) internal pure returns (uint256 ) {\n', '        return ((a + m + 1) / m) * m;\n', '    }\n', '\n', '\n', '    function get_subscriber_id(address subscriber_address) public view returns (uint256){\n', '        return _subscribers[subscriber_address];\n', '    }\n', '\n', '    function get_subscriber_address(uint256 subscriber_id) public view returns (address){\n', '        return _subscribers_id[subscriber_id];\n', '    }\n', '\n', '    function lockoutPeriod() public view returns(uint16){\n', '        return _lockout_period;\n', '    }\n', '\n', '    function setLockoutPeriod(uint16 period) public returns (bool){\n', '        _lockout_period = period;\n', '        return true;\n', '    }\n', '\n', '    function maxPeriod() public view returns(uint16){\n', '        return _max_period;\n', '    }\n', '\n', '    function setMaxPeriod(uint16 period) public onlyOwner returns(bool){\n', '        _max_period = period;\n', '        return true;\n', '    }\n', '\n', '    function commission() public view returns(uint256){\n', '        return _commission;\n', '    }\n', '\n', '    function setCommission(uint256 value) public onlyOwner returns(bool){\n', '        _commission = value;\n', '        return true;\n', '    }\n', '\n', '\n', '    function _new_subscription(uint256 subscriber_id, uint16 period, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate) private returns(bool){\n', '            Subscription memory subscription = Subscription(\n', '                subscriber_id,\n', '                amount, // subscription\n', '                units, // certificates\n', '                unit_rate, // certificate_rate\n', '                partners_rate, // certificate_partners_rate\n', '                period, // period\n', '                _lockout_period, // lockout_period\n', '                _max_period, // total_periods\n', '                0, // certificates_redeemed\n', '                0, // redemption\n', '                0, // redemption\n', '                0, // deposit\n', '                0, // commission\n', '                0,  // paidtopartner\n', '                0, // redemptiuon requested\n', '                0 // redeemption delivered\n', '                );\n', '\n', '            uint256 subscription_id = _subscriptions_counter;\n', '            _subscriptions[subscription_id] = subscription;\n', '            uint256 subscribers_subscriptions_counter = _subscribers_subscriptions_counter[subscriber_id];\n', '            _subscribers_subscriptions[subscriber_id][subscribers_subscriptions_counter] = subscription_id;\n', '            _subscribers_subscriptions_by_period[subscriber_id][period] = subscription_id;\n', '            if(_subscribers_subscriptions_recent[subscriber_id] < period){\n', '                _subscribers_subscriptions_recent[subscriber_id] = period;\n', '            }\n', '            _subscribers_subscriptions_counter[subscriber_id]++;\n', '            _subscriptions_counter++;\n', '    }\n', '\n', '\n', '    function _subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate ) private returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        uint16 current_period = getCurrentPeriod();\n', '        if( subscriber_id == 0 ){\n', '            subscriber_id = _subscribers_counter;\n', '            _subscribers[subscriber] = subscriber_id;\n', '            _subscribers_id[subscriber_id] = subscriber;\n', '            _subscribers_counter ++;\n', '        }\n', '\n', '        if(_subscribers_subscriptions_counter[subscriber_id] == 0){\n', '            _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\n', '        }else{\n', '            Subscription storage subscription = _subscriptions[_subscribers_subscriptions_by_period[subscriber_id][_subscribers_subscriptions_recent[subscriber_id]]];\n', '            if( subscription.period == current_period){\n', '                subscription.subscription = subscription.subscription.add(amount);\n', '                if(units != 0){\n', '                    subscription.certificate_rate = subscription.certificate_rate.mul(subscription.certificates).add(units.mul(unit_rate)).div(subscription.certificates.add(units));\n', '                    subscription.certificate_partners_rate = subscription.certificate_partners_rate.mul(subscription.certificates).add(units.mul(partners_rate)).div(subscription.certificates.add(units));\n', '                    subscription.certificates = subscription.certificates.add(units);\n', '                }\n', '            }else{\n', '                _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\n', '            }\n', '        }\n', '        emit Subscribe(subscriber, amount, units);\n', '        return true;\n', '    }\n', '\n', '    function _payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        uint subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 total_payout = subscription.payout.add(amount);\n', '        require (subscription.subscription >= total_payout, "Payout exceeds subscription");\n', '        subscription.payout = total_payout;\n', '        return true;\n', '    }\n', '\n', '    function _return_payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        uint subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 total_payout = subscription.payout.sub(amount);\n', '        require(total_payout <= subscription.subscription, "Cannot return more than initial subscription");\n', '        subscription.payout = total_payout;\n', '        return true;\n', '    }\n', '\n', '\n', '    function _redeem(uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require( subscription.certificates.sub(subscription.certificates_redeemed) >= amount, "Not enough certificates");\n', '\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\n', '        }\n', '\n', '        uint256 subscription_required = floor(amount.mul(subscription.certificate_rate.add(pay_to_partner_rate).add(commission())), ROUNDING);\n', '\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '\n', '        require(subscription_debit > subscription_credit, "Too much credited");\n', '        require(subscription_required <= subscription_debit.sub(subscription_credit), "Not enough funds");\n', '\n', '        uint256 redemption_total = floor(amount.mul(subscription.certificate_rate), ROUNDING);\n', '\n', '        subscription.certificates_redeemed = subscription.certificates_redeemed.add(amount);\n', '        subscription.redemption = subscription.redemption.add( redemption_total);\n', '        subscription.paid_to_partner = subscription.paid_to_partner.add( _get_partners_payout(subscriber_id, subscription_id, amount) );\n', '        subscription.commission = floor(subscription.commission.add( amount.mul(commission())), ROUNDING);\n', '        return true;\n', '    }\n', '\n', '    function _partners_redeem(uint256 partners_subscriber_id, uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        Subscription storage partners_subscription = _subscriptions[_subscribers_subscriptions_by_period[partners_subscriber_id][subscription.period]]; \n', '\n', '        uint256 redemption_total = amount.mul(subscription.certificate_partners_rate);\n', '        partners_subscription.redemption = partners_subscription.redemption.add( redemption_total);\n', '        partners_subscription.deposit = partners_subscription.deposit.add( _get_partners_payout(subscriber_id, subscription_id, amount ));\n', '        return true;\n', '    }\n', '\n', '    function _get_subscriptions_count(uint256 subscriber_id) private view returns(uint256){\n', '        return _subscribers_subscriptions_counter[subscriber_id];\n', '    }\n', '\n', '\n', '    function getSubscriptionsCountAll() public view returns(uint256) {\n', '        return _subscriptions_counter;\n', '    }\n', '\n', '    function getSubscriptionsCount(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _get_subscriptions_count(subscriber_id);\n', '    }\n', '\n', '    function _getSubscription(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.subscription;\n', '\n', '    }\n', '\n', '    function _getPayout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.payout;\n', '\n', '    }\n', '\n', '\n', '    function _getCertificates(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.certificates;\n', '\n', '    }\n', '\n', ' \n', '\n', '\n', '    function subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partner_rate) internal returns(bool){\n', '        _subscribe(subscriber, amount, units, unit_rate, partner_rate);\n', '        return true;\n', '    }\n', '\n', '    function _getCertificatesAvailable(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '        if( subscription_credit >= subscription_debit){\n', '            return 0;\n', '        }\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\n', '        }\n', '        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\n', '        return ( subscription_debit.sub(subscription_credit).div( floor(cert_rate, ROUNDING)) );\n', '    }    \n', '\n', '    function _getTopupAmount(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require( amount <= subscription.certificates - subscription.certificates_redeemed, "Cannot calculate for amount greater than available");\n', '        uint256 calc_amount = amount;\n', '        if( amount == 0){\n', '            calc_amount = subscription.certificates - subscription.certificates_redeemed;\n', '        }\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = floor(subscription.certificate_partners_rate.\n', '                                    mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).\n', '                                    div(subscription.total_periods-subscription.lockout_period), ROUNDING);\n', '        }\n', '        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\n', '        uint256 required_amount = cert_rate.mul(calc_amount);\n', '\n', '        if( required_amount <= subscription_debit.sub(subscription_credit) ) return 0;\n', '\n', '        return ( ceil(required_amount.sub(subscription_debit.sub(subscription_credit)), 1000));\n', '    }\n', '\n', '\n', '    function _get_available_payout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint16 periods_passed = getCurrentPeriod() - subscription.period;\n', '        if( periods_passed <= subscription.lockout_period) {\n', '            return 0;\n', '        }\n', '        if( periods_passed > subscription.total_periods) {\n', '            return subscription.subscription.add(subscription.deposit).sub(subscription.payout).\n', '                sub(subscription.redemption).sub(subscription.commission).sub(subscription.paid_to_partner);\n', '        }\n', '        uint256 debit = subscription.subscription.sub(subscription.redemption).\n', '            div(subscription.total_periods - subscription.lockout_period).mul(periods_passed - subscription.lockout_period).add(subscription.deposit);\n', '        uint256 credit = subscription.paid_to_partner.add(subscription.payout).add(subscription.commission);\n', '        //if (credit >= debit) return 0;\n', '        return floor(debit.sub(credit), 1000);\n', '    }\n', '\n', '    function get_available(address subscriber, uint256 subscription_id) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_available_payout(subscriber_id, subscription_id));\n', '    }\n', '\n', '    function get_available_certs(address subscriber, uint256 subscription_id) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_available_payout(subscriber_id, subscription_id));\n', '    }\n', '    function _get_partners_payout(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint16 periods_passed = getCurrentPeriod() - subscription.period;\n', '        if( periods_passed <= subscription.lockout_period) {\n', '            return 0;\n', '        }\n', '        if( periods_passed > subscription.total_periods) {\n', '            return floor(amount.mul(subscription.certificate_partners_rate), ROUNDING);\n', '        }\n', '        uint256 partners_payout = floor(amount.mul(subscription.certificate_partners_rate).\n', '                                        div(subscription.total_periods - subscription.lockout_period).\n', '                                        mul(periods_passed - subscription.lockout_period), ROUNDING);\n', '        return partners_payout;\n', '    }\n', '\n', '    function get_partners_payout(address subscriber, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_partners_payout(subscriber_id, subscription_id, amount));\n', '    }\n', '\n', '    function payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 available = get_available(subscriber, subscription_id);\n', '        require(available >= amount, "Not enough funds for withdrawal");\n', '        _payout(subscriber, subscription_id, amount);\n', '        emit Payout(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function redeem(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        _redeem(subscriber_id, subscription_id, amount);\n', '        emit Redemption(subscriber, subscription_id, amount);\n', '\n', '    }\n', '\n', '    function partners_redeem(address partner, address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 partners_subscriber_id = get_subscriber_id(partner);\n', '        require(partners_subscriber_id != 0, "No subscriber id found");\n', '        _partners_redeem(partners_subscriber_id, subscriber_id, subscription_id, amount);\n', '        emit RedemptionPartner(partner, subscriber, subscription_id, amount);\n', '    }\n', '\n', '    function return_payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        _return_payout(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function getAvailable(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        return get_available(subscriber, subscription_id);\n', '    }\n', '\n', '    function _changeSubscriptionOwner(address old_subscriber_address, address new_subscriber_address) internal returns (bool){\n', '        uint256 subscriber_id = get_subscriber_id(old_subscriber_address);\n', '        require(getSubscriptionsCount(new_subscriber_address) == 0, "New subscriber has subscriptions");\n', '        _subscribers[new_subscriber_address] = subscriber_id;\n', '        _subscribers_id[subscriber_id] = new_subscriber_address;\n', '        return true;\n', '    }\n', '\n', '    function _get_subscription(uint256 subscriber_id, uint256 subscription_id) private view returns(Subscription memory){\n', '        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '    }\n', '\n', '\n', '\n', '    function get_subscription(address subscriber, uint256 subscription_id) internal view returns(Subscription memory){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '    }\n', '\n', '    function get_global_subscription(uint256 subscription_id) internal view returns(Subscription memory){\n', '        return  _subscriptions[subscription_id];\n', '    }\n', '\n', '\n', '    function _top(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private returns(bool){\n', '        Subscription storage subscription =  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        subscription.deposit = subscription.deposit.add(amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function top(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        //require(_getTopupAmount(subscriber_id, subscription_id, 0) >= amount, "Cannot topup more that available");\n', '        _top(subscriber_id, subscription_id, amount);\n', '        emit Topup(subscriber,subscription_id,amount);\n', '    }\n', '\n', '\n', '    function getCertSubscriptionStartDate(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return getPeriodTimestamp(subscription.period);\n', '    }\n', '\n', '    function getNWXgrantedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.subscription;\n', '    }\n', '\n', '    function getNWXgrantedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return _get_partners_payout(subscriber_id, subscription_id, subscription.certificates.sub(subscription.certificates_redeemed) ).add(subscription.paid_to_partner);\n', '    }\n', '\n', '    function getNWXpayedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.payout;\n', '    }\n', '\n', '    function getNWXpayedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.paid_to_partner;\n', '    }\n', '\n', '\n', '    function  getAmountCertRedemptionRequested(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.certificates_redeemed;\n', '    }\n', '\n', '    function  getAmountCertNickelWireReceived(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.redeem_delivered;\n', '    }\n', '\n', '    function  setAmountCertNickelWireReceived(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=amount, "Not enough redeemed certs");\n', '        subscription.redeem_delivered = amount;\n', '        emit AmountCertNickelWireReceived(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '    /*\n', '    function  setAmountCertRedemptionRequested(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=amount, "Not enough redeemed certs");\n', '        subscription.redeem_requested = amount;\n', '        return true;\n', '    }\n', '    */\n', '    /*\n', '    function  requestRedemption(uint256 subscription_id, uint256 amount ) public returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(msg.sender);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=subscription.redeem_requested.add(amount), "Not enough redeemed certs");\n', '        subscription.redeem_requested = subscription.redeem_requested.add(amount);\n', '        return true;\n', '    }\n', '    */\n', '\n', '   function getTopupAmount(address subscriber, uint256 subscription_id, uint256 amount) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getTopupAmount(subscriber_id, subscription_id, amount);\n', '    }\n', '\n', '\n', '    function getSubscription(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getSubscription(subscriber_id, subscription_id);\n', '    }\n', '\n', '    function getPayout(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getPayout(subscriber_id, subscription_id);\n', '    }\n', '\n', '\n', '    function getSubscriptionAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_subscription = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_subscription = total_subscription.add(_getSubscription(subscriber_id, subscription_id));\n', '        }\n', '        return total_subscription;\n', '    }\n', '\n', '\n', '    function getCertificatesRedeemedQty(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.certificates_redeemed;\n', '    }\n', '\n', '\n', '    function getCertificatesQty(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getCertificates(subscriber_id, subscription_id);\n', '    }\n', '\n', '\n', '    function getCertificatesQtyAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_certificates = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_certificates = total_certificates.add(_getCertificates(subscriber_id, subscription_id));\n', '        }\n', '        return total_certificates;\n', '    }\n', '\n', '\n', '\n', '    function getCertificatesQtyAvailable(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getCertificatesAvailable(subscriber_id, subscription_id);\n', '    }\n', '\n', '    function getCertificatesQtyAvailableAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_certificates = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_certificates = total_certificates.add(_getCertificatesAvailable(subscriber_id, subscription_id));\n', '        }\n', '        return total_certificates;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/INIWIX.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'interface INIWIX {\n', '    function tokenFallback( address from, uint256 value ) external returns(bool);\n', '}\n', '\n', '// File: contracts/Cert.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Cert is Ownable, Whitelist, Subscriptions{\n', '    using SafeMath for uint256;\n', '\n', '    string private _name;\n', '\n', '    IERC20 _niwix;\n', '    IERC20 _euron;\n', '\n', '    uint256 private _deposit_niwix_rate;\n', '    uint256 private _subscription_niwix_rate;\n', '    uint256 private _subscription_partner_rate;\n', '    uint256 private _subscription_unit_rate;\n', '\n', '    uint public n;\n', '    address public sender;\n', '\n', '    event TokenFallbackCert(address indexed where, address indexed sender, address indexed from, uint256 value);\n', '    event DepositTo(address indexed where, address indexed sender, address indexed to, uint256 value);\n', '    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event ChangeSubscriber(address indexed from, address indexed to);\n', '    event Withdraw(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Deposit(address indexed subscriber, uint256 amount);\n', '    event SetNIWIXRate(uint256 rate);\n', '    event SetUnitPrice(uint256 rate);\n', '    event SetSubscriptionPartnerRate(uint256 rate);\n', '\n', '    mapping (uint256=>uint256) paper_certificate;\n', '\n', '    function tokenFallback( address from, uint256 value ) public returns(bool){\n', '        if( msg.sender == address(_euron)){\n', '            if( from != address(_niwix) )\n', '            {\n', '                _euron.transfer(address(_niwix), value);\n', '                INIWIX(address(_niwix)).tokenFallback(from, value);\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    constructor() public {\n', '        _name = "NiwixCert";\n', '        _deposit_niwix_rate = 1000 * 10 ** 8;\n', '        _subscription_niwix_rate = 10000 * 10 ** 8;\n', '        _subscription_unit_rate = 100 * 10 ** 8;\n', '    }\n', '\n', '    function name() public view returns(string memory){\n', '        return _name;\n', '    }\n', '\n', '    function setNiwix(address contract_address) public onlyOwner returns(bool){\n', '        _niwix = IERC20(contract_address);\n', '        return true;\n', '    }\n', '\n', '    function setEURON(address contract_address) public onlyOwner returns(bool){\n', '        _euron = IERC20(contract_address);\n', '        return true;\n', '    }\n', '\n', '    function depositNiwixRate() public view returns(uint256){\n', '        return _deposit_niwix_rate;\n', '    }\n', '\n', '    function setDepositNiwixRate(uint256 value) public onlyOwner returns(uint256){\n', '        _deposit_niwix_rate = value;\n', '    }\n', '\n', '    function setSubscriptionUnitRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_unit_rate = value;\n', '    }\n', '\n', '    function setSubscriptionNiwixRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_niwix_rate = value;\n', '    }\n', '\n', '    function getSubscriptionUnitRate() public view returns(uint256){\n', '        return(_subscription_unit_rate);\n', '    }\n', '\n', '\n', '    function getDepositNiwixValue(uint256 euron_amount) public view returns(uint256){\n', '        return euron_amount.div(_subscription_unit_rate).mul(depositNiwixRate());\n', '    }\n', '\n', '\n', '    function setSubscriptionParnerRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_partner_rate = value;\n', '    }\n', '\n', '    function subscriptionPartnerRate() public view returns(uint256){\n', '        return _subscription_partner_rate;\n', '    }\n', '\n', '    function _get_subscription_units(uint256 value) public view returns (uint256){\n', '        return value.div(_subscription_unit_rate);\n', '    }\n', '\n', '    function _get_subscription_change(uint256 value) public view returns (uint256){\n', '        uint256 units = value.div(_subscription_unit_rate);\n', '        uint256 subscription = units.mul(_subscription_unit_rate);\n', '        return value.sub(subscription);\n', '    }\n', '\n', '    function get_subscription_value(uint256 value) public view returns (uint256, uint256, uint256){\n', '        uint256 units = _get_subscription_units(value);\n', '        uint256 subscription = units.mul(_subscription_unit_rate);\n', '        return (units, subscription, value.sub(subscription));\n', '    }\n', '\n', '\n', '    function _deposit(address euron_address, uint256 euron_amount, address niwix_address ) private returns (uint256 subscription_value){\n', '        _euron.transferFrom(euron_address, address(this), euron_amount);\n', '        uint256 subscription_change;\n', '        uint256 subscription_units;\n', '        (subscription_units, subscription_value, subscription_change) = get_subscription_value(euron_amount);\n', '        uint256 niwix_amount = getDepositNiwixValue(euron_amount);\n', '\n', '        if(niwix_amount>0){\n', '            _niwix.transferFrom(niwix_address, address(this), niwix_amount);\n', '        }\n', '        if(subscription_change > 0 ){\n', '            _euron.transfer(niwix_address, subscription_change);\n', '        }\n', '        address partner = getPartner(niwix_address);\n', '        if (partner != address(0)){\n', '            subscribe(partner, subscription_units.mul(_subscription_partner_rate), 0, 0, 0);\n', '        }\n', '\n', '        subscribe(niwix_address, subscription_units.mul(_subscription_niwix_rate), subscription_units, _subscription_niwix_rate, _subscription_partner_rate );\n', '    }\n', '\n', '    function depositTo(address address_to, uint256 value) public returns (bool){\n', '        require(getWhitelistState(address_to) == Whitelist.STATE_WHITELISTED, "Address needs to be whitelisted");\n', '        require(partnerStatus(address_to) == Whitelist.STATE_NEW, "Cannot deposit to partner");\n', '        emit DepositTo(address(this), msg.sender, address_to, value);\n', '        _deposit(msg.sender, value, address_to);\n', '        emit Deposit(address_to, value);\n', '        return true;\n', '    }\n', '\n', '    function deposit(uint256 value) public returns (bool){\n', '        require(getWhitelistState(msg.sender) == Whitelist.STATE_WHITELISTED, "You need to be whitelisted");\n', '        require(partnerStatus(msg.sender) == Whitelist.STATE_NEW, "Partner cannot deposit");\n', '        uint256 amount = value;\n', '        if(value == 0){\n', '            amount = _euron.allowance(msg.sender, address(this));\n', '        }\n', '        _deposit(msg.sender, amount, msg.sender);\n', '        emit Deposit(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 subscription_id, uint256 value) public returns (bool){\n', '        uint256 amount = value;\n', '        if(value == 0){\n', '            amount = getAvailable(msg.sender, subscription_id);\n', '        }\n', '        require(amount > 0, "Wrong value or no funds availabe for withdrawal");\n', '\n', '        payout(msg.sender, subscription_id, amount);\n', '        _niwix.transfer(msg.sender, amount);\n', '        emit Withdraw(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '    /*\n', '    function return_withdrawal(uint256 subscription_id, uint256 value ) public returns (bool){\n', '        _niwix.transferFrom(msg.sender, address(this), value);\n', '        return_payout(msg.sender, subscription_id, value);\n', '        emit ReturnRedemption(msg.sender, subscription_id, value);\n', '        return true;\n', '    }\n', '    */\n', '    function change_subscribers_address(address from, address to) public onlyOwner returns (bool){\n', '        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, "To address must be whitelisted");\n', '\n', '        _changeSubscriptionOwner(from, to);\n', '        emit ChangeSubscriber(from, to);\n', '        return true;\n', '    }\n', '\n', '    function change_address( address to) public returns (bool){\n', '        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, "To address must be whitelisted");\n', '        _changeSubscriptionOwner(msg.sender, to);\n', '        emit ChangeSubscriber(msg.sender, to);\n', '        return true;\n', '    }\n', '\n', '\n', '    function redemption(uint256 subscription_id, uint256 amount) public  returns (bool){\n', '        address partner = getPartner(msg.sender);\n', '        if (partner != address(0)){\n', '           partners_redeem(partner, msg.sender, subscription_id, amount);\n', '        }\n', '\n', '        redeem(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function topup(uint256 subscription_id, uint256 amount) public  returns (bool){\n', '        _niwix.transferFrom(msg.sender, address(this), amount);\n', '        top(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function topupOwner(address to, uint256 subscription_id, uint256 amount) public onlyOwner  returns (bool){\n', '        top(to, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transfer(address to, uint256 subscription_id, uint256 amount) public returns (bool)\n', '    {\n', '//        Subscription memory subscription = get_subscription(msg.sender, subscription_id);\n', '//        uint256 subscription_certificates = subscription.certificates;\n', '        redemption(subscription_id, amount);\n', '        subscribe(to, amount.mul(_subscription_niwix_rate), amount, _subscription_niwix_rate, _subscription_partner_rate );\n', '        address partner = getPartner(to);\n', '        if (partner != address(0)){\n', '            subscribe(partner, amount.mul(_subscription_partner_rate), 0, 0, 0);\n', '        }\n', '\n', '    }\n', '\n', '    function viewSubscription(address subscriber, uint256 subscription_id) public view returns(Subscription memory){\n', '        if( subscriber == address(0) )\n', '        {\n', '            return get_global_subscription( subscription_id );\n', '        }\n', '        return get_subscription(subscriber, subscription_id);\n', '    }\n', '\n', '\n', '    function reclaimEther(address payable _to) external onlyOwner {\n', '        _to.transfer(address(this).balance);\n', '    }\n', '\n', '    function reclaimToken(IERC20 token, address _to) external onlyOwner {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(_to, balance);\n', '    }\n', '\n', '}']
['// File: ../3rdparty/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: ../3rdparty/openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: ../3rdparty/openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'contract Whitelist is Ownable{\n', '    mapping (uint256 => uint8) private _partners;\n', '    mapping (address => uint256) private _partner_ids;\n', '    mapping (uint256 => address) private _partner_address;\n', '    uint256 public partners_counter=1;\n', '    mapping (address => uint8) private _whitelist;\n', '    mapping (address => uint256) private _referrals;\n', '    mapping (uint256 => mapping(uint256=>address)) private _partners_referrals;\n', '    mapping (uint256 => uint256) _partners_referrals_counter;\n', '\n', '    uint8 public constant STATE_NEW = 0;\n', '    uint8 public constant STATE_WHITELISTED = 1;\n', '    uint8 public constant STATE_BLACKLISTED = 2;\n', '    uint8 public constant STATE_ONHOLD = 3;\n', '\n', '    event Whitelisted(address indexed partner, address indexed subscriber);\n', '    event AddPartner(address indexed partner, uint256 partner_id);\n', '\n', '    function _add_partner(address partner) private returns (bool){\n', '        _partner_ids[partner] = partners_counter;\n', '        _partner_address[partners_counter] = partner;\n', '        _partners[partners_counter] = STATE_WHITELISTED;\n', '        _whitelist[partner] = STATE_WHITELISTED;\n', '        emit AddPartner(partner, partners_counter);\n', '        partners_counter++;\n', '    }\n', '    \n', '    constructor () public {\n', '        _add_partner(msg.sender);\n', '    }\n', '\n', '    function getPartnerId(address partner) public view returns (uint256){\n', '        return _partner_ids[partner];\n', '    }\n', '\n', '    modifier onlyWhiteisted(){\n', '        require(_whitelist[msg.sender] == STATE_WHITELISTED, "Ownable: caller is not whitelisted");\n', '        _;\n', '    }\n', '\n', '    function isPartner() public view returns (bool){\n', '        return _partners[_partner_ids[msg.sender]] == STATE_WHITELISTED;\n', '    }\n', '\n', '    function partnerStatus(address partner) public view returns (uint8){\n', '        return _partners[_partner_ids[partner]];\n', '    }\n', '\n', '\n', '    modifier onlyPartnerOrOwner(){\n', '        require(isOwner() || isPartner(), "Ownable: caller is not the owner or partner");\n', '        _;\n', '    }\n', '\n', '    function setPartnerState(address partner, uint8 state) public onlyOwner returns(bool){\n', '        uint256 partner_id = getPartnerId(partner);\n', '        if( partner_id == 0 && state == STATE_WHITELISTED){\n', '            _add_partner(partner);\n', '        }else{\n', '            _partners[partner_id] = state;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function addPartner(address partner) public onlyOwner returns(bool){\n', '        _add_partner(partner);\n', '        return true;\n', '    }\n', '\n', '    function whitelist(address referral) public onlyPartnerOrOwner returns (bool){\n', '        require(_whitelist[referral] == STATE_NEW, "Referral is already whitelisted");\n', '        uint256 partner_id = getPartnerId(msg.sender);\n', '        require(partner_id != 0, "Partner not found");\n', '        _whitelist[referral] = STATE_WHITELISTED;\n', '        _referrals[referral] = partner_id;\n', '        _partners_referrals[partner_id][_partners_referrals_counter[partner_id]] = referral;\n', '        _partners_referrals_counter[partner_id] ++;\n', '        emit Whitelisted(msg.sender, referral);\n', '\n', '    }\n', '\n', '    function setWhitelistState(address referral, uint8 state) public onlyOwner returns (bool){\n', '        require(_whitelist[referral] != STATE_NEW, "Referral is not in list");\n', '        _whitelist[referral] = state;\n', '    }\n', '\n', '    function getWhitelistState(address referral) public view returns (uint8){\n', '        return _whitelist[referral];\n', '    }\n', '\n', '    function getPartner(address referral) public view returns (address){\n', '        return _partner_address[_referrals[referral]];\n', '    }\n', '\n', '    function setPartnersAddress(uint256 partner_id, address new_partner) public onlyOwner returns (bool){\n', '        _partner_address[partner_id] = new_partner;\n', '        _partner_ids[new_partner] = partner_id;\n', '        return true;\n', '    }\n', '\n', '    function bulkWhitelist(address[] memory address_list) public returns(bool){\n', '        for(uint256 i = 0; i < address_list.length; i++){\n', '            whitelist(address_list[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Periods.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'contract Periods is Ownable{\n', '    uint16 private _current_period;\n', '    uint16 private _total_periods;\n', '    mapping (uint16=>uint256) _periods;\n', '    bool _adjustable;\n', '\n', '    constructor() public{\n', '        _adjustable = true;\n', '    }\n', '\n', '    function getPeriodsCounter() public view returns(uint16){\n', '        return _total_periods;\n', '    }\n', '\n', '    function getCurrentPeriod() public view returns(uint16){\n', '        return _checkCurrentPeriod();\n', '    }\n', '\n', '    function getCurrentTime() public view returns(uint256){\n', '        return now;\n', '    }\n', '\n', '\n', '    function getCurrentPeriodTimestamp() public view returns(uint256){\n', '        return _periods[_current_period];\n', '    }\n', '\n', '    function getPeriodTimestamp(uint16 period) public view returns(uint256){\n', '        return _periods[period];\n', '    }\n', '\n', '    \n', '    function setCurrentPeriod(uint16 period) public onlyOwner returns (bool){\n', '        require(period < _total_periods, "Do not have timestamp for that period");\n', '        _current_period = period;\n', '        return true;\n', '    }\n', '\n', '\n', '    function addPeriodTimestamp(uint256 timestamp) public onlyOwner returns (bool){\n', '//        require(_total_periods - _current_period < 50, "Cannot add more that 50 periods from now");\n', '//        require((_current_period == 0) || (timestamp - _periods[_total_periods-1] > 28 days && (timestamp - _periods[_total_periods-1] < 32 days )), "Incorrect period)");\n', '        _periods[_total_periods] = timestamp;\n', '        _total_periods++;\n', '        return true;\n', '    }\n', '\n', '    function _checkCurrentPeriod() private view returns (uint16){\n', '        uint16 current_period = _current_period;\n', '        while( current_period < _total_periods-1){\n', '            if( now < _periods[current_period] ){\n', '                break;\n', '            }\n', '            current_period ++;\n', '        }\n', '        return current_period;\n', '    }\n', '\n', '    function adjustCurrentPeriod( ) public returns (uint16){\n', '        if(!_adjustable){\n', '            return _current_period;\n', '        }\n', '        require(_total_periods > 1, "Periods are not set");\n', '        require(_current_period < _total_periods, "Last period reached");\n', '        //require(_total_periods - _current_period < 50, "Adjust more that 50 periods from now");\n', '        uint16 current_period = _checkCurrentPeriod();\n', '        if(current_period > _current_period){\n', '            _current_period = current_period;\n', '        }\n', '        return current_period;\n', '    }\n', '\n', '    function addPeriodTimestamps(uint256[] memory timestamps) public onlyOwner returns(bool){\n', '        //require(timestamps.length < 50, "Cannot set more than 50 periods");\n', '        for(uint16 current_timestamp = 0; current_timestamp < timestamps.length; current_timestamp ++){\n', '            addPeriodTimestamp(timestamps[current_timestamp]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function setLastPeriod(uint16 period) public onlyOwner returns(bool){\n', '        require(period < _total_periods-1, "Incorrect period");\n', '        require(period > _current_period, "Cannot change passed periods");\n', '        _total_periods = period;\n', '        return true;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/Subscriptions.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', '\n', '\n', 'contract Subscriptions is Ownable, Periods {\n', '    using SafeMath for uint256;\n', '\n', '    uint8 STATE_MISSING = 0;\n', '    uint8 STATE_ACTIVE = 1;\n', '    uint8 STATE_WITHDRAWN = 2;\n', '    uint8 STATE_PAID = 3;\n', '\n', '    uint256 ROUNDING = 1000;\n', '\n', '    struct Subscription{\n', '        uint256 subscriber_id;\n', '        uint256 subscription;\n', '        uint256 certificates;\n', '        uint256 certificate_rate;\n', '        uint256 certificate_partners_rate;\n', '        uint16 period;\n', '        uint16 lockout_period;\n', '        uint16 total_periods;\n', '        uint256 certificates_redeemed;\n', '        uint256 redemption;\n', '        uint256 payout;\n', '        uint256 deposit;\n', '        uint256 commission;\n', '        uint256 paid_to_partner;\n', '        uint256 redeem_requested;\n', '        uint256 redeem_delivered;\n', '    }\n', '\n', '    mapping (address=>uint256) private _subscribers;\n', '    mapping (uint256=>address) private _subscribers_id;\n', '    uint256 private _subscribers_counter=1;\n', '\n', '    mapping (uint256=>Subscription) private _subscriptions;\n', '    mapping (uint256=>mapping(uint256=>uint256)) private _subscribers_subscriptions;\n', '    mapping (uint256=>mapping(uint16=>uint256)) private _subscribers_subscriptions_by_period;\n', '    mapping (uint256=>uint16) private _subscribers_subscriptions_recent;\n', '    uint256 private _subscriptions_counter=1;\n', '    mapping (uint256=>uint256) private _subscribers_subscriptions_counter;\n', '\n', '    uint256 private _commission;\n', '\n', '    uint256 private _total_subscription=0;\n', '    uint16 private _lockout_period;\n', '    uint16 private _max_period;\n', '\n', '    event Subscribe(address subscriber, uint256 subscription, uint256 certs );\n', '    event Topup(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Payout(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event RedemptionPartner(address indexed partner, address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event AmountCertNickelWireReceived(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '\n', '    constructor() public{\n', '        _lockout_period = 3;\n', '        _max_period = 24;\n', '        _commission = 1000;\n', '    }\n', '\n', '    function floor(uint a, uint m) internal pure returns (uint256 ) {\n', '        return ((a ) / m) * m;\n', '    }\n', '\n', '    function ceil(uint a, uint m) internal pure returns (uint256 ) {\n', '        return ((a + m + 1) / m) * m;\n', '    }\n', '\n', '\n', '    function get_subscriber_id(address subscriber_address) public view returns (uint256){\n', '        return _subscribers[subscriber_address];\n', '    }\n', '\n', '    function get_subscriber_address(uint256 subscriber_id) public view returns (address){\n', '        return _subscribers_id[subscriber_id];\n', '    }\n', '\n', '    function lockoutPeriod() public view returns(uint16){\n', '        return _lockout_period;\n', '    }\n', '\n', '    function setLockoutPeriod(uint16 period) public returns (bool){\n', '        _lockout_period = period;\n', '        return true;\n', '    }\n', '\n', '    function maxPeriod() public view returns(uint16){\n', '        return _max_period;\n', '    }\n', '\n', '    function setMaxPeriod(uint16 period) public onlyOwner returns(bool){\n', '        _max_period = period;\n', '        return true;\n', '    }\n', '\n', '    function commission() public view returns(uint256){\n', '        return _commission;\n', '    }\n', '\n', '    function setCommission(uint256 value) public onlyOwner returns(bool){\n', '        _commission = value;\n', '        return true;\n', '    }\n', '\n', '\n', '    function _new_subscription(uint256 subscriber_id, uint16 period, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate) private returns(bool){\n', '            Subscription memory subscription = Subscription(\n', '                subscriber_id,\n', '                amount, // subscription\n', '                units, // certificates\n', '                unit_rate, // certificate_rate\n', '                partners_rate, // certificate_partners_rate\n', '                period, // period\n', '                _lockout_period, // lockout_period\n', '                _max_period, // total_periods\n', '                0, // certificates_redeemed\n', '                0, // redemption\n', '                0, // redemption\n', '                0, // deposit\n', '                0, // commission\n', '                0,  // paidtopartner\n', '                0, // redemptiuon requested\n', '                0 // redeemption delivered\n', '                );\n', '\n', '            uint256 subscription_id = _subscriptions_counter;\n', '            _subscriptions[subscription_id] = subscription;\n', '            uint256 subscribers_subscriptions_counter = _subscribers_subscriptions_counter[subscriber_id];\n', '            _subscribers_subscriptions[subscriber_id][subscribers_subscriptions_counter] = subscription_id;\n', '            _subscribers_subscriptions_by_period[subscriber_id][period] = subscription_id;\n', '            if(_subscribers_subscriptions_recent[subscriber_id] < period){\n', '                _subscribers_subscriptions_recent[subscriber_id] = period;\n', '            }\n', '            _subscribers_subscriptions_counter[subscriber_id]++;\n', '            _subscriptions_counter++;\n', '    }\n', '\n', '\n', '    function _subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate ) private returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        uint16 current_period = getCurrentPeriod();\n', '        if( subscriber_id == 0 ){\n', '            subscriber_id = _subscribers_counter;\n', '            _subscribers[subscriber] = subscriber_id;\n', '            _subscribers_id[subscriber_id] = subscriber;\n', '            _subscribers_counter ++;\n', '        }\n', '\n', '        if(_subscribers_subscriptions_counter[subscriber_id] == 0){\n', '            _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\n', '        }else{\n', '            Subscription storage subscription = _subscriptions[_subscribers_subscriptions_by_period[subscriber_id][_subscribers_subscriptions_recent[subscriber_id]]];\n', '            if( subscription.period == current_period){\n', '                subscription.subscription = subscription.subscription.add(amount);\n', '                if(units != 0){\n', '                    subscription.certificate_rate = subscription.certificate_rate.mul(subscription.certificates).add(units.mul(unit_rate)).div(subscription.certificates.add(units));\n', '                    subscription.certificate_partners_rate = subscription.certificate_partners_rate.mul(subscription.certificates).add(units.mul(partners_rate)).div(subscription.certificates.add(units));\n', '                    subscription.certificates = subscription.certificates.add(units);\n', '                }\n', '            }else{\n', '                _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\n', '            }\n', '        }\n', '        emit Subscribe(subscriber, amount, units);\n', '        return true;\n', '    }\n', '\n', '    function _payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        uint subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 total_payout = subscription.payout.add(amount);\n', '        require (subscription.subscription >= total_payout, "Payout exceeds subscription");\n', '        subscription.payout = total_payout;\n', '        return true;\n', '    }\n', '\n', '    function _return_payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        uint subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 total_payout = subscription.payout.sub(amount);\n', '        require(total_payout <= subscription.subscription, "Cannot return more than initial subscription");\n', '        subscription.payout = total_payout;\n', '        return true;\n', '    }\n', '\n', '\n', '    function _redeem(uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require( subscription.certificates.sub(subscription.certificates_redeemed) >= amount, "Not enough certificates");\n', '\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\n', '        }\n', '\n', '        uint256 subscription_required = floor(amount.mul(subscription.certificate_rate.add(pay_to_partner_rate).add(commission())), ROUNDING);\n', '\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '\n', '        require(subscription_debit > subscription_credit, "Too much credited");\n', '        require(subscription_required <= subscription_debit.sub(subscription_credit), "Not enough funds");\n', '\n', '        uint256 redemption_total = floor(amount.mul(subscription.certificate_rate), ROUNDING);\n', '\n', '        subscription.certificates_redeemed = subscription.certificates_redeemed.add(amount);\n', '        subscription.redemption = subscription.redemption.add( redemption_total);\n', '        subscription.paid_to_partner = subscription.paid_to_partner.add( _get_partners_payout(subscriber_id, subscription_id, amount) );\n', '        subscription.commission = floor(subscription.commission.add( amount.mul(commission())), ROUNDING);\n', '        return true;\n', '    }\n', '\n', '    function _partners_redeem(uint256 partners_subscriber_id, uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\n', '\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        Subscription storage partners_subscription = _subscriptions[_subscribers_subscriptions_by_period[partners_subscriber_id][subscription.period]]; \n', '\n', '        uint256 redemption_total = amount.mul(subscription.certificate_partners_rate);\n', '        partners_subscription.redemption = partners_subscription.redemption.add( redemption_total);\n', '        partners_subscription.deposit = partners_subscription.deposit.add( _get_partners_payout(subscriber_id, subscription_id, amount ));\n', '        return true;\n', '    }\n', '\n', '    function _get_subscriptions_count(uint256 subscriber_id) private view returns(uint256){\n', '        return _subscribers_subscriptions_counter[subscriber_id];\n', '    }\n', '\n', '\n', '    function getSubscriptionsCountAll() public view returns(uint256) {\n', '        return _subscriptions_counter;\n', '    }\n', '\n', '    function getSubscriptionsCount(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _get_subscriptions_count(subscriber_id);\n', '    }\n', '\n', '    function _getSubscription(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.subscription;\n', '\n', '    }\n', '\n', '    function _getPayout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.payout;\n', '\n', '    }\n', '\n', '\n', '    function _getCertificates(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        return subscription.certificates;\n', '\n', '    }\n', '\n', ' \n', '\n', '\n', '    function subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partner_rate) internal returns(bool){\n', '        _subscribe(subscriber, amount, units, unit_rate, partner_rate);\n', '        return true;\n', '    }\n', '\n', '    function _getCertificatesAvailable(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '        if( subscription_credit >= subscription_debit){\n', '            return 0;\n', '        }\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\n', '        }\n', '        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\n', '        return ( subscription_debit.sub(subscription_credit).div( floor(cert_rate, ROUNDING)) );\n', '    }    \n', '\n', '    function _getTopupAmount(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require( amount <= subscription.certificates - subscription.certificates_redeemed, "Cannot calculate for amount greater than available");\n', '        uint256 calc_amount = amount;\n', '        if( amount == 0){\n', '            calc_amount = subscription.certificates - subscription.certificates_redeemed;\n', '        }\n', '        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\n', '        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\n', '\n', '        uint256 pay_to_partner_rate = 0;\n', '        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\n', '             pay_to_partner_rate = floor(subscription.certificate_partners_rate.\n', '                                    mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).\n', '                                    div(subscription.total_periods-subscription.lockout_period), ROUNDING);\n', '        }\n', '        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\n', '        uint256 required_amount = cert_rate.mul(calc_amount);\n', '\n', '        if( required_amount <= subscription_debit.sub(subscription_credit) ) return 0;\n', '\n', '        return ( ceil(required_amount.sub(subscription_debit.sub(subscription_credit)), 1000));\n', '    }\n', '\n', '\n', '    function _get_available_payout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint16 periods_passed = getCurrentPeriod() - subscription.period;\n', '        if( periods_passed <= subscription.lockout_period) {\n', '            return 0;\n', '        }\n', '        if( periods_passed > subscription.total_periods) {\n', '            return subscription.subscription.add(subscription.deposit).sub(subscription.payout).\n', '                sub(subscription.redemption).sub(subscription.commission).sub(subscription.paid_to_partner);\n', '        }\n', '        uint256 debit = subscription.subscription.sub(subscription.redemption).\n', '            div(subscription.total_periods - subscription.lockout_period).mul(periods_passed - subscription.lockout_period).add(subscription.deposit);\n', '        uint256 credit = subscription.paid_to_partner.add(subscription.payout).add(subscription.commission);\n', '        //if (credit >= debit) return 0;\n', '        return floor(debit.sub(credit), 1000);\n', '    }\n', '\n', '    function get_available(address subscriber, uint256 subscription_id) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_available_payout(subscriber_id, subscription_id));\n', '    }\n', '\n', '    function get_available_certs(address subscriber, uint256 subscription_id) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_available_payout(subscriber_id, subscription_id));\n', '    }\n', '    function _get_partners_payout(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        uint16 periods_passed = getCurrentPeriod() - subscription.period;\n', '        if( periods_passed <= subscription.lockout_period) {\n', '            return 0;\n', '        }\n', '        if( periods_passed > subscription.total_periods) {\n', '            return floor(amount.mul(subscription.certificate_partners_rate), ROUNDING);\n', '        }\n', '        uint256 partners_payout = floor(amount.mul(subscription.certificate_partners_rate).\n', '                                        div(subscription.total_periods - subscription.lockout_period).\n', '                                        mul(periods_passed - subscription.lockout_period), ROUNDING);\n', '        return partners_payout;\n', '    }\n', '\n', '    function get_partners_payout(address subscriber, uint256 subscription_id, uint256 amount) private view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return(_get_partners_payout(subscriber_id, subscription_id, amount));\n', '    }\n', '\n', '    function payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 available = get_available(subscriber, subscription_id);\n', '        require(available >= amount, "Not enough funds for withdrawal");\n', '        _payout(subscriber, subscription_id, amount);\n', '        emit Payout(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function redeem(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        _redeem(subscriber_id, subscription_id, amount);\n', '        emit Redemption(subscriber, subscription_id, amount);\n', '\n', '    }\n', '\n', '    function partners_redeem(address partner, address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 partners_subscriber_id = get_subscriber_id(partner);\n', '        require(partners_subscriber_id != 0, "No subscriber id found");\n', '        _partners_redeem(partners_subscriber_id, subscriber_id, subscription_id, amount);\n', '        emit RedemptionPartner(partner, subscriber, subscription_id, amount);\n', '    }\n', '\n', '    function return_payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        _return_payout(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function getAvailable(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        return get_available(subscriber, subscription_id);\n', '    }\n', '\n', '    function _changeSubscriptionOwner(address old_subscriber_address, address new_subscriber_address) internal returns (bool){\n', '        uint256 subscriber_id = get_subscriber_id(old_subscriber_address);\n', '        require(getSubscriptionsCount(new_subscriber_address) == 0, "New subscriber has subscriptions");\n', '        _subscribers[new_subscriber_address] = subscriber_id;\n', '        _subscribers_id[subscriber_id] = new_subscriber_address;\n', '        return true;\n', '    }\n', '\n', '    function _get_subscription(uint256 subscriber_id, uint256 subscription_id) private view returns(Subscription memory){\n', '        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '    }\n', '\n', '\n', '\n', '    function get_subscription(address subscriber, uint256 subscription_id) internal view returns(Subscription memory){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '    }\n', '\n', '    function get_global_subscription(uint256 subscription_id) internal view returns(Subscription memory){\n', '        return  _subscriptions[subscription_id];\n', '    }\n', '\n', '\n', '    function _top(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private returns(bool){\n', '        Subscription storage subscription =  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        subscription.deposit = subscription.deposit.add(amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function top(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        //require(_getTopupAmount(subscriber_id, subscription_id, 0) >= amount, "Cannot topup more that available");\n', '        _top(subscriber_id, subscription_id, amount);\n', '        emit Topup(subscriber,subscription_id,amount);\n', '    }\n', '\n', '\n', '    function getCertSubscriptionStartDate(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return getPeriodTimestamp(subscription.period);\n', '    }\n', '\n', '    function getNWXgrantedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.subscription;\n', '    }\n', '\n', '    function getNWXgrantedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return _get_partners_payout(subscriber_id, subscription_id, subscription.certificates.sub(subscription.certificates_redeemed) ).add(subscription.paid_to_partner);\n', '    }\n', '\n', '    function getNWXpayedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.payout;\n', '    }\n', '\n', '    function getNWXpayedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.paid_to_partner;\n', '    }\n', '\n', '\n', '    function  getAmountCertRedemptionRequested(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.certificates_redeemed;\n', '    }\n', '\n', '    function  getAmountCertNickelWireReceived(address subscriber, uint256 subscription_id) public view returns(uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.redeem_delivered;\n', '    }\n', '\n', '    function  setAmountCertNickelWireReceived(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=amount, "Not enough redeemed certs");\n', '        subscription.redeem_delivered = amount;\n', '        emit AmountCertNickelWireReceived(subscriber, subscription_id, amount);\n', '        return true;\n', '    }\n', '    /*\n', '    function  setAmountCertRedemptionRequested(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=amount, "Not enough redeemed certs");\n', '        subscription.redeem_requested = amount;\n', '        return true;\n', '    }\n', '    */\n', '    /*\n', '    function  requestRedemption(uint256 subscription_id, uint256 amount ) public returns(bool){\n', '        uint256 subscriber_id = get_subscriber_id(msg.sender);\n', '        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\n', '        require(subscription.certificates_redeemed>=subscription.redeem_requested.add(amount), "Not enough redeemed certs");\n', '        subscription.redeem_requested = subscription.redeem_requested.add(amount);\n', '        return true;\n', '    }\n', '    */\n', '\n', '   function getTopupAmount(address subscriber, uint256 subscription_id, uint256 amount) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getTopupAmount(subscriber_id, subscription_id, amount);\n', '    }\n', '\n', '\n', '    function getSubscription(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getSubscription(subscriber_id, subscription_id);\n', '    }\n', '\n', '    function getPayout(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getPayout(subscriber_id, subscription_id);\n', '    }\n', '\n', '\n', '    function getSubscriptionAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_subscription = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_subscription = total_subscription.add(_getSubscription(subscriber_id, subscription_id));\n', '        }\n', '        return total_subscription;\n', '    }\n', '\n', '\n', '    function getCertificatesRedeemedQty(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        Subscription memory subscription = get_subscription(subscriber, subscription_id);\n', '        return subscription.certificates_redeemed;\n', '    }\n', '\n', '\n', '    function getCertificatesQty(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getCertificates(subscriber_id, subscription_id);\n', '    }\n', '\n', '\n', '    function getCertificatesQtyAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_certificates = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_certificates = total_certificates.add(_getCertificates(subscriber_id, subscription_id));\n', '        }\n', '        return total_certificates;\n', '    }\n', '\n', '\n', '\n', '    function getCertificatesQtyAvailable(address subscriber, uint256 subscription_id) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        return _getCertificatesAvailable(subscriber_id, subscription_id);\n', '    }\n', '\n', '    function getCertificatesQtyAvailableAll(address subscriber) public view returns (uint256){\n', '        uint256 subscriber_id = get_subscriber_id(subscriber);\n', '        require(subscriber_id != 0, "No subscriber id found");\n', '        uint256 total_certificates = 0;\n', '        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\n', '            total_certificates = total_certificates.add(_getCertificatesAvailable(subscriber_id, subscription_id));\n', '        }\n', '        return total_certificates;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/INIWIX.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', '\n', '\n', 'interface INIWIX {\n', '    function tokenFallback( address from, uint256 value ) external returns(bool);\n', '}\n', '\n', '// File: contracts/Cert.sol\n', '\n', 'pragma solidity >=0.4.25 <0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Cert is Ownable, Whitelist, Subscriptions{\n', '    using SafeMath for uint256;\n', '\n', '    string private _name;\n', '\n', '    IERC20 _niwix;\n', '    IERC20 _euron;\n', '\n', '    uint256 private _deposit_niwix_rate;\n', '    uint256 private _subscription_niwix_rate;\n', '    uint256 private _subscription_partner_rate;\n', '    uint256 private _subscription_unit_rate;\n', '\n', '    uint public n;\n', '    address public sender;\n', '\n', '    event TokenFallbackCert(address indexed where, address indexed sender, address indexed from, uint256 value);\n', '    event DepositTo(address indexed where, address indexed sender, address indexed to, uint256 value);\n', '    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event ChangeSubscriber(address indexed from, address indexed to);\n', '    event Withdraw(address indexed subscriber, uint256 subscription_id, uint256 amount);\n', '    event Deposit(address indexed subscriber, uint256 amount);\n', '    event SetNIWIXRate(uint256 rate);\n', '    event SetUnitPrice(uint256 rate);\n', '    event SetSubscriptionPartnerRate(uint256 rate);\n', '\n', '    mapping (uint256=>uint256) paper_certificate;\n', '\n', '    function tokenFallback( address from, uint256 value ) public returns(bool){\n', '        if( msg.sender == address(_euron)){\n', '            if( from != address(_niwix) )\n', '            {\n', '                _euron.transfer(address(_niwix), value);\n', '                INIWIX(address(_niwix)).tokenFallback(from, value);\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    constructor() public {\n', '        _name = "NiwixCert";\n', '        _deposit_niwix_rate = 1000 * 10 ** 8;\n', '        _subscription_niwix_rate = 10000 * 10 ** 8;\n', '        _subscription_unit_rate = 100 * 10 ** 8;\n', '    }\n', '\n', '    function name() public view returns(string memory){\n', '        return _name;\n', '    }\n', '\n', '    function setNiwix(address contract_address) public onlyOwner returns(bool){\n', '        _niwix = IERC20(contract_address);\n', '        return true;\n', '    }\n', '\n', '    function setEURON(address contract_address) public onlyOwner returns(bool){\n', '        _euron = IERC20(contract_address);\n', '        return true;\n', '    }\n', '\n', '    function depositNiwixRate() public view returns(uint256){\n', '        return _deposit_niwix_rate;\n', '    }\n', '\n', '    function setDepositNiwixRate(uint256 value) public onlyOwner returns(uint256){\n', '        _deposit_niwix_rate = value;\n', '    }\n', '\n', '    function setSubscriptionUnitRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_unit_rate = value;\n', '    }\n', '\n', '    function setSubscriptionNiwixRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_niwix_rate = value;\n', '    }\n', '\n', '    function getSubscriptionUnitRate() public view returns(uint256){\n', '        return(_subscription_unit_rate);\n', '    }\n', '\n', '\n', '    function getDepositNiwixValue(uint256 euron_amount) public view returns(uint256){\n', '        return euron_amount.div(_subscription_unit_rate).mul(depositNiwixRate());\n', '    }\n', '\n', '\n', '    function setSubscriptionParnerRate(uint256 value) public onlyOwner returns(uint256){\n', '        _subscription_partner_rate = value;\n', '    }\n', '\n', '    function subscriptionPartnerRate() public view returns(uint256){\n', '        return _subscription_partner_rate;\n', '    }\n', '\n', '    function _get_subscription_units(uint256 value) public view returns (uint256){\n', '        return value.div(_subscription_unit_rate);\n', '    }\n', '\n', '    function _get_subscription_change(uint256 value) public view returns (uint256){\n', '        uint256 units = value.div(_subscription_unit_rate);\n', '        uint256 subscription = units.mul(_subscription_unit_rate);\n', '        return value.sub(subscription);\n', '    }\n', '\n', '    function get_subscription_value(uint256 value) public view returns (uint256, uint256, uint256){\n', '        uint256 units = _get_subscription_units(value);\n', '        uint256 subscription = units.mul(_subscription_unit_rate);\n', '        return (units, subscription, value.sub(subscription));\n', '    }\n', '\n', '\n', '    function _deposit(address euron_address, uint256 euron_amount, address niwix_address ) private returns (uint256 subscription_value){\n', '        _euron.transferFrom(euron_address, address(this), euron_amount);\n', '        uint256 subscription_change;\n', '        uint256 subscription_units;\n', '        (subscription_units, subscription_value, subscription_change) = get_subscription_value(euron_amount);\n', '        uint256 niwix_amount = getDepositNiwixValue(euron_amount);\n', '\n', '        if(niwix_amount>0){\n', '            _niwix.transferFrom(niwix_address, address(this), niwix_amount);\n', '        }\n', '        if(subscription_change > 0 ){\n', '            _euron.transfer(niwix_address, subscription_change);\n', '        }\n', '        address partner = getPartner(niwix_address);\n', '        if (partner != address(0)){\n', '            subscribe(partner, subscription_units.mul(_subscription_partner_rate), 0, 0, 0);\n', '        }\n', '\n', '        subscribe(niwix_address, subscription_units.mul(_subscription_niwix_rate), subscription_units, _subscription_niwix_rate, _subscription_partner_rate );\n', '    }\n', '\n', '    function depositTo(address address_to, uint256 value) public returns (bool){\n', '        require(getWhitelistState(address_to) == Whitelist.STATE_WHITELISTED, "Address needs to be whitelisted");\n', '        require(partnerStatus(address_to) == Whitelist.STATE_NEW, "Cannot deposit to partner");\n', '        emit DepositTo(address(this), msg.sender, address_to, value);\n', '        _deposit(msg.sender, value, address_to);\n', '        emit Deposit(address_to, value);\n', '        return true;\n', '    }\n', '\n', '    function deposit(uint256 value) public returns (bool){\n', '        require(getWhitelistState(msg.sender) == Whitelist.STATE_WHITELISTED, "You need to be whitelisted");\n', '        require(partnerStatus(msg.sender) == Whitelist.STATE_NEW, "Partner cannot deposit");\n', '        uint256 amount = value;\n', '        if(value == 0){\n', '            amount = _euron.allowance(msg.sender, address(this));\n', '        }\n', '        _deposit(msg.sender, amount, msg.sender);\n', '        emit Deposit(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 subscription_id, uint256 value) public returns (bool){\n', '        uint256 amount = value;\n', '        if(value == 0){\n', '            amount = getAvailable(msg.sender, subscription_id);\n', '        }\n', '        require(amount > 0, "Wrong value or no funds availabe for withdrawal");\n', '\n', '        payout(msg.sender, subscription_id, amount);\n', '        _niwix.transfer(msg.sender, amount);\n', '        emit Withdraw(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '    /*\n', '    function return_withdrawal(uint256 subscription_id, uint256 value ) public returns (bool){\n', '        _niwix.transferFrom(msg.sender, address(this), value);\n', '        return_payout(msg.sender, subscription_id, value);\n', '        emit ReturnRedemption(msg.sender, subscription_id, value);\n', '        return true;\n', '    }\n', '    */\n', '    function change_subscribers_address(address from, address to) public onlyOwner returns (bool){\n', '        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, "To address must be whitelisted");\n', '\n', '        _changeSubscriptionOwner(from, to);\n', '        emit ChangeSubscriber(from, to);\n', '        return true;\n', '    }\n', '\n', '    function change_address( address to) public returns (bool){\n', '        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, "To address must be whitelisted");\n', '        _changeSubscriptionOwner(msg.sender, to);\n', '        emit ChangeSubscriber(msg.sender, to);\n', '        return true;\n', '    }\n', '\n', '\n', '    function redemption(uint256 subscription_id, uint256 amount) public  returns (bool){\n', '        address partner = getPartner(msg.sender);\n', '        if (partner != address(0)){\n', '           partners_redeem(partner, msg.sender, subscription_id, amount);\n', '        }\n', '\n', '        redeem(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function topup(uint256 subscription_id, uint256 amount) public  returns (bool){\n', '        _niwix.transferFrom(msg.sender, address(this), amount);\n', '        top(msg.sender, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '    function topupOwner(address to, uint256 subscription_id, uint256 amount) public onlyOwner  returns (bool){\n', '        top(to, subscription_id, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transfer(address to, uint256 subscription_id, uint256 amount) public returns (bool)\n', '    {\n', '//        Subscription memory subscription = get_subscription(msg.sender, subscription_id);\n', '//        uint256 subscription_certificates = subscription.certificates;\n', '        redemption(subscription_id, amount);\n', '        subscribe(to, amount.mul(_subscription_niwix_rate), amount, _subscription_niwix_rate, _subscription_partner_rate );\n', '        address partner = getPartner(to);\n', '        if (partner != address(0)){\n', '            subscribe(partner, amount.mul(_subscription_partner_rate), 0, 0, 0);\n', '        }\n', '\n', '    }\n', '\n', '    function viewSubscription(address subscriber, uint256 subscription_id) public view returns(Subscription memory){\n', '        if( subscriber == address(0) )\n', '        {\n', '            return get_global_subscription( subscription_id );\n', '        }\n', '        return get_subscription(subscriber, subscription_id);\n', '    }\n', '\n', '\n', '    function reclaimEther(address payable _to) external onlyOwner {\n', '        _to.transfer(address(this).balance);\n', '    }\n', '\n', '    function reclaimToken(IERC20 token, address _to) external onlyOwner {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(_to, balance);\n', '    }\n', '\n', '}']
