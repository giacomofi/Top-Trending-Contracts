['pragma solidity 0.4.25;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract EtherWinAccessControl {\n', '    event GamePaused();\n', '    event GameResumed();\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    address public owner;\n', '    address public manager;\n', '\n', '    address public dividendManagerAddress;\n', '    address public wallet;\n', '\n', '    bool public paused = false;\n', '    bool public locked = false;\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == owner || msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    modifier whenUnlocked() {\n', '        require(!locked);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        manager = msg.sender;\n', '        wallet = msg.sender;\n', '    }\n', '\n', '\n', '    function setManager(address _managerAddress) onlyManager external {\n', '        require(_managerAddress != address(0));\n', '        manager = _managerAddress;\n', '    }\n', '\n', '\n', '    function setWallet(address _newWallet) onlyManager external {\n', '        require(_newWallet != address(0));\n', '        wallet = _newWallet;\n', '    }\n', '\n', '\n', '    function setDividendManager(address _dividendManagerAddress) whenUnlocked onlyManager external  {\n', '        require(_dividendManagerAddress != address(0));\n', '        dividendManagerAddress = _dividendManagerAddress;\n', '    }\n', '\n', '\n', '    function pause() onlyManager whenNotPaused public {\n', '        paused = true;\n', '        emit GamePaused();\n', '    }\n', '\n', '\n', '    function unpause() onlyManager whenPaused public {\n', '        paused = false;\n', '        emit GameResumed();\n', '    }\n', '\n', '\n', '    function lock() onlyOwner whenUnlocked external {\n', '        locked = true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function ownerTransfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract DividendManagerInterface {\n', '    function depositDividend() external payable;\n', '}\n', '\n', '\n', 'contract EtherWin is EtherWinAccessControl {\n', '    using SafeMath for uint256;\n', '\n', '    event NewTicket(address indexed owner, uint indexed blockNum, address indexed referrer, uint value);\n', '    event NewPrice(uint minWei,uint maxWei);\n', '    event NewWeiPerBlock(uint newWeiPerBlock);\n', '    event SendPrize(address indexed owner, uint indexed blockNum, uint value);\n', '    event FundsTransferred(address dividendManager, uint value);\n', '    event WinBlockAdded(uint indexed blockNum);\n', '\n', '    uint public minWei = 5000000000000000;\n', '    uint public maxWei = 50000000000000000;\n', '    uint public maxWeiPerBlock = 500000000000000000;\n', '    uint public ownersWeis;  // reserved weis for owners\n', '    uint public depositWeis;  // reserved weis for return deposit\n', '    uint public prizePercent = 91875;\n', '    uint public ownersPercent = 8125;\n', '    uint public refPercent = 1000;\n', '\n', '\n', '    struct Ticket {\n', '        uint value;\n', '        bool executed;\n', '    }\n', '\n', '    struct WinBlock {\n', '        bool exists;\n', '        uint8 lastByte;\n', '        uint8 rate;\n', '        bool jp;\n', '        uint value;\n', '    }\n', '\n', '    mapping (address => mapping (uint => Ticket)) public tickets; // user addr -> block number -> ticket\n', '\n', '    mapping (uint => uint) public blocks; //blicknum -> weis in block\n', '    mapping (uint8 => uint8) rates;\n', '\n', '    mapping (uint => WinBlock) public winBlocks;\n', '\n', '    uint public allTicketsPrice;\n', '    mapping (uint => uint) public allTicketsForBlock; //block num -> allTicketsPrice needs for JP\n', '    uint[] public JPBlocks;\n', '    mapping (address => uint) public refs;\n', '    mapping (address => address) public userRefs;\n', '\n', '\n', '    uint divider = 5;\n', '    uint public lastPayout;\n', '\n', '\n', '    constructor() public {\n', '        rates[10] = 15; //a\n', '        rates[11] = 15; //b\n', '        rates[12] = 15; //c\n', '\n', '        rates[13] = 20; //d\n', '        rates[14] = 20; //e\n', '\n', '        rates[15] = 30; //f\n', '\n', '        rates[153] = 99; //99\n', '    }\n', '\n', '\n', '    function () public payable {\n', '        play(address(0));\n', '    }\n', '\n', '\n', '    function play(address _ref) whenNotPaused public payable {\n', '        Ticket storage t = tickets[msg.sender][block.number];\n', '\n', '        require(t.value.add(msg.value) >= minWei && t.value.add(msg.value) <= maxWei);\n', '        require(blocks[block.number].add(msg.value) <= maxWeiPerBlock);\n', '\n', '        t.value = t.value.add(msg.value);\n', '\n', '        blocks[block.number] = blocks[block.number].add(msg.value);\n', '\n', '        if (_ref != address(0) && _ref != msg.sender) {\n', '            userRefs[msg.sender] = _ref;\n', '        }\n', '\n', '        //need for JP\n', '        allTicketsPrice = allTicketsPrice.add(msg.value);\n', '        allTicketsForBlock[block.number] = allTicketsPrice;\n', '\n', '        if (userRefs[msg.sender] != address(0)) {\n', '            refs[_ref] = refs[_ref].add(valueFromPercent(msg.value, refPercent));\n', '            ownersWeis = ownersWeis.add(valueFromPercent(msg.value, ownersPercent.sub(refPercent)));\n', '        } else {\n', '            ownersWeis = ownersWeis.add(valueFromPercent(msg.value,ownersPercent));\n', '        }\n', '\n', '        emit NewTicket(msg.sender, block.number, _ref, t.value);\n', '    }\n', '\n', '\n', '    function addWinBlock(uint _blockNum) public  {\n', '        require( (_blockNum.add(12) < block.number) && (_blockNum > block.number - 256) );\n', '        require(!winBlocks[_blockNum].exists);\n', '        require(blocks[_blockNum-1] > 0);\n', '\n', '        bytes32 bhash = blockhash(_blockNum);\n', '        uint8 lastByte = uint8(bhash[31]);\n', '\n', '        require( ((rates[lastByte % 16]) > 0) || (rates[lastByte] > 0) );\n', '\n', '        _addWinBlock(_blockNum, lastByte);\n', '    }\n', '\n', '\n', '    function _addWinBlock(uint _blockNum, uint8 _lastByte) internal {\n', '        WinBlock storage wBlock = winBlocks[_blockNum];\n', '        wBlock.exists = true;\n', '        wBlock.lastByte = _lastByte;\n', '        wBlock.rate = rates[_lastByte % 16];\n', '\n', '        //JP\n', '        if (_lastByte == 153) {\n', '            wBlock.jp = true;\n', '\n', '            if (JPBlocks.length > 0) {\n', '                wBlock.value = allTicketsForBlock[_blockNum-1].sub(allTicketsForBlock[JPBlocks[JPBlocks.length-1]-1]);\n', '            } else {\n', '                wBlock.value = allTicketsForBlock[_blockNum-1];\n', '            }\n', '\n', '            JPBlocks.push(_blockNum);\n', '        }\n', '\n', '        emit WinBlockAdded(_blockNum);\n', '    }\n', '\n', '\n', '    function getPrize(uint _blockNum) public {\n', '        Ticket storage t = tickets[msg.sender][_blockNum-1];\n', '        require(t.value > 0);\n', '        require(!t.executed);\n', '\n', '        if (!winBlocks[_blockNum].exists) {\n', '            addWinBlock(_blockNum);\n', '        }\n', '\n', '        require(winBlocks[_blockNum].exists);\n', '\n', '        uint winValue = 0;\n', '\n', '        if (winBlocks[_blockNum].jp) {\n', '            winValue = getJPValue(_blockNum,t.value);\n', '        } else {\n', '            winValue = t.value.mul(winBlocks[_blockNum].rate).div(10);\n', '        }\n', '\n', '\n', '        require(address(this).balance >= winValue);\n', '\n', '        t.executed = true;\n', '        msg.sender.transfer(winValue);\n', '        emit SendPrize(msg.sender, _blockNum, winValue);\n', '    }\n', '\n', '\n', '    function minJackpotValue(uint _blockNum) public view returns (uint){\n', '        uint value = 0;\n', '        if (JPBlocks.length > 0) {\n', '            value = allTicketsForBlock[_blockNum].sub(allTicketsForBlock[JPBlocks[JPBlocks.length-1]-1]);\n', '        } else {\n', '            value = allTicketsForBlock[_blockNum];\n', '        }\n', '\n', '        return _calcJP(minWei, minWei, value);\n', '    }\n', '\n', '\n', '    function jackpotValue(uint _blockNum, uint _ticketPrice) public view returns (uint){\n', '        uint value = 0;\n', '        if (JPBlocks.length > 0) {\n', '            value = allTicketsForBlock[_blockNum].sub(allTicketsForBlock[JPBlocks[JPBlocks.length-1]-1]);\n', '        } else {\n', '            value = allTicketsForBlock[_blockNum];\n', '        }\n', '\n', '        return _calcJP(_ticketPrice, _ticketPrice, value);\n', '    }\n', '\n', '\n', '    function getJPValue(uint _blockNum, uint _ticketPrice) internal view returns (uint) {\n', '        return _calcJP(_ticketPrice, blocks[_blockNum-1], winBlocks[_blockNum].value);\n', '    }\n', '\n', '\n', '    function _calcJP(uint _ticketPrice, uint _varB, uint _varX) internal view returns (uint) {\n', '        uint varA = _ticketPrice;\n', '        uint varB = _varB; //blocks[blockNum-1]\n', '        uint varX = _varX; //winBlocks[blockNum].value\n', '\n', '        uint varL = varA.mul(1000).div(divider).div(1000000000000000000);\n', '        uint minjp = minWei.mul(25);\n', '        varL = varL.mul(minjp);\n', '\n', '        uint varR = varA.mul(10000).div(varB);\n', '        uint varX1 = varX.mul(1023);\n', '        varR = varR.mul(varX1).div(100000000);\n', '\n', '        return varL.add(varR);\n', '    }\n', '\n', '\n', '    function changeTicketWeiLimit(uint _minWei, uint _maxWei, uint _divider) onlyManager public {\n', '        minWei = _minWei;\n', '        maxWei = _maxWei;\n', '        divider = _divider;\n', '        emit NewPrice(minWei,maxWei);\n', '    }\n', '\n', '\n', '    function changeWeiPerBlock(uint _value) onlyManager public {\n', '        maxWeiPerBlock = _value;\n', '        emit NewWeiPerBlock(maxWeiPerBlock);\n', '    }\n', '\n', '\n', '    function returnDeposit() onlyManager public {\n', '        require(address(this).balance >= depositWeis);\n', '        uint deposit = depositWeis;\n', '        depositWeis = 0;\n', '        wallet.transfer(deposit);\n', '    }\n', '\n', '\n', '    function transferEthersToDividendManager() public {\n', '        require(now >= lastPayout.add(7 days) );\n', '        require(address(this).balance >= ownersWeis);\n', '        require(ownersWeis > 0);\n', '        lastPayout = now;\n', '        uint dividends = ownersWeis;\n', '        ownersWeis = 0;\n', '\n', '        wallet.transfer(valueFromPercent(dividends,15000));\n', '\n', '        DividendManagerInterface dividendManager = DividendManagerInterface(dividendManagerAddress);\n', '        dividendManager.depositDividend.value(valueFromPercent(dividends,85000))();\n', '\n', '        emit FundsTransferred(dividendManagerAddress, dividends);\n', '    }\n', '\n', '\n', '    function addEth() public payable {\n', '        depositWeis = depositWeis.add(msg.value);\n', '    }\n', '\n', '\n', '    function fromHexChar(uint8 _c) internal pure returns (uint8) {\n', '        return _c - (_c < 58 ? 48 : (_c < 97 ? 55 : 87));\n', '    }\n', '\n', '\n', '    function getByte(bytes res) internal pure returns (uint8) {\n', '        return fromHexChar(uint8(res[62])) << 4 | fromHexChar(uint8(res[63]));\n', '    }\n', '\n', '\n', '    function withdrawRefsPercent() external {\n', '        require(refs[msg.sender] > 0);\n', '        require(address(this).balance >= refs[msg.sender]);\n', '        uint val = refs[msg.sender];\n', '        refs[msg.sender] = 0;\n', '        msg.sender.transfer(val);\n', '    }\n', '\n', '\n', '    function valueFromPercent(uint _value, uint _percent) internal pure returns(uint quotient) {\n', '        uint _quotient = _value.mul(_percent).div(100000);\n', '        return ( _quotient);\n', '    }\n', '\n', '    /// @notice This method can be used by the owner to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) onlyManager external {\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(owner, balance);\n', '    }\n', '}']