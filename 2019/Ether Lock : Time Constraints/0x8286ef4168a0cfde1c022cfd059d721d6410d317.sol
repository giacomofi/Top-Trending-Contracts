['pragma solidity ^0.5.0;\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TokenDistribution {\n', '\n', '    mapping (address => Investor) private _investors;\n', '    address[] investorAddresses;\n', '\n', '    struct Investor {\n', '        uint256 total;\n', '        uint256 released;\n', '    }\n', '\n', '    uint256 public initTimestamp;\n', '    uint256 public totalAmount;\n', '    IERC20 token;\n', '\n', '    // fraction of tokens to be distributed every month.\n', '    // we use 140 as denominator of a fraction.\n', '    // if monthlyFraction[0] = 5 this means that 5/140 of total is to be distributed \n', '    // in "month 1".\n', '    // note that numbers in this array sum up to 140, which means that after 17 months\n', '    // 140/140 of total will be distributed.\n', '    uint16[17] monthlyFraction = [\n', '        5,   // 1\n', '        15,  // 2\n', '        20,  // 3\n', '        5,   // 4\n', '        5,   // 5\n', '        5,   // 6\n', '        5,   // 7\n', '        5,   // 8\n', '        5,   // 9\n', '        5,   // 10\n', '        5,   // 11\n', '        5,   // 12\n', '        5,   // 13\n', '        5,   // 14\n', '        5,   // 15\n', '        20,  // 16\n', '        20  // 17\n', '    ];\n', '\n', '    constructor(address _token, address[] memory investors, uint256[] memory tokenAmounts) public {\n', '        token = IERC20(_token);\n', '        initTimestamp = block.timestamp;\n', '        require(investors.length == tokenAmounts.length);\n', '    \n', '        for (uint i = 0; i < investors.length; i++) {\n', '            address investor_address = investors[i];\n', '            investorAddresses.push(investor_address);\n', '            require(_investors[investor_address].total == 0); // prevent duplicate addresses\n', '            _investors[investor_address].total = tokenAmounts[i] * 1000000;\n', '            _investors[investor_address].released = 0;\n', '            totalAmount += tokenAmounts[i];\n', '        }\n', '    }\n', '\n', '    function fractionToAmount(uint256 total, uint256 numerator) internal pure returns (uint256) {\n', '        return (total * numerator) / 140;\n', '    }\n', '\n', '    function computeUnlockedAmount(Investor storage inv) internal view returns (uint256) {\n', '        uint256 total = inv.total;\n', '        // first month is immediately unlocked\n', '        uint256 unlocked = fractionToAmount(total, monthlyFraction[0]);\n', '        uint256 daysPassed = getDaysPassed();\n', '        if (daysPassed > 510) {\n', '            return total; // after 17 months we unlock all tokens\n', '        }\n', '\n', '        uint256 monthsPassed = daysPassed / 30;\n', '        if (monthsPassed >= 17) {\n', '            return total;\n', '        }\n', '\n', '        // unlock up until the current month.\n', '        // E.g. monthsPassed == 1 then this loop is not executed\n', '        // if monthsPassed == 2 then this loop is executed once with m=1 and so on.\n', '        for (uint m = 1; m < monthsPassed; m++) {\n', '            unlocked += fractionToAmount(total, monthlyFraction[m]);\n', '        }\n', '    \n', '        // do daily unlock starting from second month\n', '        if (monthsPassed > 0) {\n', '            uint256 daysSinceStartOfAMonth = daysPassed - monthsPassed * 30;\n', '            if (daysSinceStartOfAMonth > 30)\n', '            daysSinceStartOfAMonth = 30;\n', '            uint256 unlockedThisMonths = fractionToAmount(total, monthlyFraction[monthsPassed]);\n', '            unlocked += (unlockedThisMonths * daysSinceStartOfAMonth) / 30;\n', '        }\n', '        \n', '        if (unlocked > total) {\n', '            return total;\n', '        } \n', '        else return unlocked;\n', '    }\n', '\n', '    function distributedTokensFor(address account) public {\n', '        Investor storage inv = _investors[account];\n', '        uint256 unlocked = computeUnlockedAmount(inv);\n', '        if (unlocked > inv.released) {\n', '            uint256 delta = unlocked - inv.released;\n', '            inv.released = unlocked;\n', '            token.transfer(account, delta);\n', '        }\n', '    }\n', '    \n', '    function distributedTokens() public {\n', '        for (uint i = 0; i < investorAddresses.length; i++) {\n', '            distributedTokensFor(investorAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function amountOfTokensToUnlock(address account) external view returns (uint256) {\n', '        Investor storage inv = _investors[account];\n', '        uint256 unlocked = computeUnlockedAmount(inv);\n', '        return (unlocked - inv.released);\n', '    }\n', '    \n', '    function getDaysPassed() public view returns (uint) {\n', '        return (block.timestamp - initTimestamp) / 86400;\n', '    }\n', '\n', '}']