['pragma solidity 0.4.24;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/lottodaotoken.sol\n', '\n', 'contract LottodaoTemplate {\n', '    function fund(uint256 withdrawn) public payable;\n', '    function redeem(address account, uint256 amount) public;\n', '}\n', '\n', 'contract LottodaoToken is BasicToken {\n', '    string public name = "Lottodao Token";\n', '    string public symbol = "LDAO";\n', '    uint8 public decimals = 0;\n', '    uint256 public cap = 5000000;\n', '\n', '    uint256 public raised;\n', '    \n', '    address public owner;\n', '    uint256 public initialTokenPrice;\n', '\n', '    uint256 public ethBalance;\n', '    address private _lottodaoAddress;\n', '    uint256 private _withdrawLimit = 80 ether;\n', '    uint256 private _withdrawn;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event TokenPurchase(address indexed to, uint256 units);\n', '    event Redeem(address indexed to, uint256 units);\n', '\n', '    constructor (address _owner, uint256 _initialTokenPrice) public {\n', '        initialTokenPrice = _initialTokenPrice;\n', '        owner = _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '        require(totalSupply_ + _amount <= cap);\n', '\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) private returns (bool) {\n', '        require(_amount>0 && totalSupply_ + _amount <= cap);\n', '\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setLottodaoAddress(address lottodaoAddress) public onlyOwner {\n', '        _lottodaoAddress = lottodaoAddress;\n', '    }\n', '\n', '    /*\n', '        transfer funds to Lottodo smart contract\n', '    */\n', '    function transferFundsToContract() public onlyOwner {\n', '        require(_lottodaoAddress!=0x0000000000000000000000000000000000000000 && ethBalance>0);\n', '        LottodaoTemplate t = LottodaoTemplate(_lottodaoAddress);\n', '        uint256 bal = ethBalance;\n', '        ethBalance = 0;\n', '        t.fund.value(bal)(_withdrawn);\n', '    }\n', '\n', '    function getWithdrawalLimit() public view returns (uint256){\n', '        uint8 tranch = getTranch(totalSupply_);\n', '        uint256 max = _withdrawLimit.mul(tranch);\n', '        uint256 bal = max-_withdrawn;\n', '        if(bal>ethBalance){\n', '            bal = ethBalance;\n', '        }\n', '        return bal;\n', '    }\n', '\n', '    function withdrawFunds(address to, uint256 amount) public onlyOwner {\n', '        uint256 available = getWithdrawalLimit();\n', '        require(amount<=available);\n', '        _withdrawn = _withdrawn.add(amount);\n', '        ethBalance = ethBalance.sub(amount);\n', '        to.transfer(amount);\n', '    }\n', '\n', '\n', '    function redeem(address account) public{\n', '        require(_lottodaoAddress!=0x0000000000000000000000000000000000000000 && (msg.sender==owner || msg.sender==account) && balances[account]>0);\n', '        uint256 bal = balances[account];\n', '        balances[account] = 0;\n', '        balances[_lottodaoAddress].add(bal);\n', '        LottodaoTemplate t = LottodaoTemplate(_lottodaoAddress);\n', '        t.redeem(account, bal);\n', '        emit Redeem(account, bal);\n', '    }\n', '\n', ' \n', '    function getTranchEnd(uint8 tranch) public view returns (uint256){\n', '        if(tranch==1){\n', '            return cap.div(2).add(cap.div(8));\n', '        }\n', '        else if(tranch==2){\n', '            return cap.div(8).add(getTranchEnd(1));\n', '        }\n', '        else if(tranch==3){\n', '            return cap.div(8).add(getTranchEnd(2));\n', '        }\n', '        else{\n', '            return cap;\n', '        }\n', '    }\n', '\n', '    function getTranch(uint256 units) public view returns (uint8){\n', '        if(units<getTranchEnd(1)){\n', '            return 1;\n', '        }\n', '        else if(units<getTranchEnd(2)){\n', '            return 2;\n', '        }\n', '        else if(units<getTranchEnd(3)){\n', '            return 3;\n', '        }\n', '        else{\n', '            return 4;\n', '        }\n', '    }\n', '\n', '    function getTokenPriceForTranch(uint8 tranch) public view returns (uint256){\n', '        \n', '        if(tranch==1){\n', '            return initialTokenPrice;\n', '        }\n', '        else if(tranch==2){\n', '            return initialTokenPrice.mul(5).div(10).add(getTokenPriceForTranch(1));\n', '        }\n', '        else if(tranch==3){\n', '             return initialTokenPrice.mul(5).div(10).add(getTokenPriceForTranch(2));\n', '        }\n', '        else{\n', '             return initialTokenPrice.mul(5).div(10).add(getTokenPriceForTranch(3));\n', '        }\n', '    }\n', '\n', '    function getNumTokensForEth(uint256 eth) public view returns (uint256 units, uint256 balance){\n', '       uint8 tranch = getTranch(totalSupply_);\n', '       uint256 start = totalSupply_;\n', '       uint256 _units = 0;\n', '       uint256 bal = eth;\n', '       while(tranch<=4 && bal>0){\n', '            uint256 tranchEnd = getTranchEnd(tranch);\n', '            uint256 unitLimit = tranchEnd.sub(start);\n', '            uint256 price = getTokenPriceForTranch(tranch);\n', '            uint256 tranchUnits = bal.div(price);\n', '            if(tranchUnits>unitLimit){\n', '                tranchUnits = unitLimit;\n', '            }\n', '            _units = _units.add(tranchUnits);\n', '            bal = bal.sub(tranchUnits.mul(price));\n', '            start = tranchEnd;\n', '            tranch += 1;\n', '       }\n', '       units = _units;\n', '       balance = bal;\n', '       \n', '       if(_units.add(totalSupply_)<=cap){\n', '            units = _units;\n', '            balance = bal;\n', '       }\n', '       else{\n', '           uint256 dif = _units.add(totalSupply_).sub(cap);\n', '           units = _units.sub(dif);\n', '           balance = bal.add(dif);\n', '       }\n', '       \n', '\n', '    }\n', '\n', '    function purchase() public payable{\n', '        (uint256 units, uint256 remainder) = getNumTokensForEth(msg.value);\n', '        if(units>0){\n', '            _mint(msg.sender,units);\n', '            if(remainder>0){\n', '                uint256 amnt = msg.value.sub(remainder);\n', '                ethBalance = ethBalance.add(amnt);\n', '                raised = raised.add(amnt);\n', '                msg.sender.transfer(remainder);\n', '            }\n', '            else{\n', '                ethBalance = ethBalance.add(msg.value);\n', '                raised = raised.add(msg.value);\n', '            }\n', '        }\n', '        else{\n', '            if(remainder>0){\n', '                msg.sender.transfer(remainder);\n', '            }\n', '        }\n', '        \n', '    }\n', '\n', '    function() public payable {\n', '        ethBalance.add(msg.value);\n', '    }\n', '}']