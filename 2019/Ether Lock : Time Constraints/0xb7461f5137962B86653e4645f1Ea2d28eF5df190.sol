['pragma solidity 0.5.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./RewardContract.sol";\n', 'import "./Adbank.sol";\n', '\n', 'contract AdbankRewardClaimContract is RewardContract {\n', '    using SafeMath for uint256;\n', '\n', "    // Stop contract from executing it's main logic\n", '    bool public suspended;\n', '\n', '    // Limit the size of incoming requests (assignRewards and claimRewards functions)\n', '    uint8 public batchLimit;\n', '\n', '    address public owner;\n', '    mapping(bytes32 => uint256) public balances;\n', '    uint256 public totalReward;\n', '\n', '    // AdBank contract that is used for the actual transfers\n', '    Adbank public adbankContract;\n', '\n', '    // Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Functions with this modifier can only be executed if execution is not suspended\n', '    modifier notSuspended() {\n', '        require (suspended == false);\n', '        _;\n', '    }\n', '\n', '    constructor(address _adbankContract, uint8 _batchLimit) public {\n', '        owner = msg.sender;\n', '        suspended = false;\n', '        totalReward = 0;\n', '        adbankContract = Adbank(_adbankContract);\n', '        batchLimit = _batchLimit;\n', '    }\n', '\n', '    // Suspend / resume the execution of contract methods\n', '    function suspend(bool _suspended) external onlyOwner {\n', '        suspended = _suspended;\n', '    }\n', '\n', '    // Change owner\n', '    function changeOwner(address _newOwner) external onlyOwner {\n', '        require(_newOwner != address(0x0));\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // Drain all funds. Returns tokens to the contract owner\n', '    function drain() external onlyOwner {\n', '        uint256 contractBalance = adbankContract.balanceOf(address(this));\n', '        require(contractBalance > 0);\n', '\n', '        require(transferReward(owner, contractBalance));\n', '        suspended = true;\n', '    }\n', '\n', '    // Change the requests limit\n', '    function setBatchLimit(uint8 newLimit) onlyOwner external {\n', '        require(newLimit > 0);\n', '        batchLimit = newLimit;\n', '    }\n', '\n', '    // Change the Adbank contract\n', '    function setAdbankContract(address _adbankContract) onlyOwner external {\n', '        require(_adbankContract != address(0x0));\n', '        adbankContract = Adbank(_adbankContract);\n', '    }\n', '\n', "    // Get user balance according to user's blade id\n", '    function balanceOf(bytes32 _bladeId) public view returns (uint256 balance) {\n', '        return balances[_bladeId];\n', '    }\n', '\n', "    // Assign rewards according to user's blade ids.\n", '    // The size of incoming data is limited to be in (0;batchLimit] range\n', '    // Requires this contract to have token balance to cover the incoming rewards\n', '    function assignRewards(bytes32[] calldata _bladeIds, uint256[] calldata _rewards) notSuspended onlyOwner external {\n', '        require(_bladeIds.length > 0 && _bladeIds.length <= batchLimit);\n', '        require(_bladeIds.length == _rewards.length);\n', '\n', '        for (uint8 i = 0; i < _bladeIds.length; i++) {\n', '            balances[_bladeIds[i]] = (balances[_bladeIds[i]]).add(_rewards[i]);\n', '            totalReward = (totalReward).add(_rewards[i]);\n', '            emit RewardAssigned(_bladeIds[i], _rewards[i]);\n', '        }\n', '\n', '        require(hasEnoughBalance());\n', '    }\n', '\n', "    // Claim rewards according to user's blade ids.\n", '    // The size of incoming data is limited to be in (0;batchLimit] range\n', '    // Requires this contract to have token balance to cover the rewards\n', '    function claimRewards(bytes32[] calldata _bladeIds, address[] calldata _wallets) notSuspended onlyOwner external {\n', '        require(_bladeIds.length > 0 && _bladeIds.length <= batchLimit);\n', '        require(_bladeIds.length == _wallets.length);\n', '\n', '        require(hasEnoughBalance());\n', '\n', '        for (uint8 i = 0; i < _bladeIds.length; i++) {\n', '            processReward(_bladeIds[i], _wallets[i], false);\n', '        }\n', '    }\n', '\n', '    // Claim reward for the specified user\n', '    function claimReward(bytes32 _bladeId, address _to) notSuspended onlyOwner external returns (bool ok) {\n', '        return processReward(_bladeId, _to, true);\n', '    }\n', '\n', '    // Send the reward and return result.\n', '    // Will throw exception or skip the execution depending on the _requireValid param\n', '    function processReward(bytes32 _bladeId, address _to, bool _requireValid) notSuspended onlyOwner internal returns (bool ok) {\n', '        bool valid = validAddressAndBalance(_to, _bladeId);\n', '\n', '        if (_requireValid) {\n', '            require(valid);\n', '        } else if (!valid) {\n', '            return false;\n', '        }\n', '\n', '        uint256 rewardToSend = balances[_bladeId];\n', '\n', '        balances[_bladeId] = 0;\n', '        totalReward = (totalReward).sub(rewardToSend);\n', '\n', '        bool transferStatus = transferReward(_to, rewardToSend);\n', '        emit RewardClaimed(_bladeId, _to, rewardToSend);\n', '        return transferStatus;\n', '    }\n', '\n', '    // Do the actual transfer of the reward to the specified address\n', '    function transferReward(address _to, uint256 _amount) onlyOwner internal returns (bool ok) {\n', '        bool result = adbankContract.transfer(_to, _amount);\n', '        require(result);\n', '        return result;\n', '    }\n', '\n', '    // Check that address is valid, user has balance and contract has enough balance\n', '    function validAddressAndBalance(address _address, bytes32 _bladeId) internal view returns (bool valid) {\n', '        if (_address != address(0x0) && balances[_bladeId] > 0) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    // Check that contract has enough tokens to cover transactions with rewards\n', '    function hasEnoughBalance() public view returns (bool enoughBalance) {\n', '        return adbankContract.balanceOf(address(this)) >= totalReward;\n', '    }\n', '}']