['pragma solidity 0.4.25;\n', '\n', 'contract Auth {\n', '\n', '  address internal mainAdmin;\n', '  address internal contractAdmin;\n', '\n', '  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '  constructor(\n', '    address _mainAdmin,\n', '    address _contractAdmin\n', '  )\n', '  internal\n', '  {\n', '    mainAdmin = _mainAdmin;\n', '    contractAdmin = _contractAdmin;\n', '  }\n', '\n', '  modifier onlyAdmin() {\n', '    require(isMainAdmin() || isContractAdmin(), "onlyAdmin");\n', '    _;\n', '  }\n', '\n', '  modifier onlyMainAdmin() {\n', '    require(isMainAdmin(), "onlyMainAdmin");\n', '    _;\n', '  }\n', '\n', '  modifier onlyContractAdmin() {\n', '    require(isContractAdmin(), "onlyContractAdmin");\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) onlyContractAdmin internal {\n', '    require(_newOwner != address(0x0));\n', '    contractAdmin = _newOwner;\n', '    emit OwnershipTransferred(msg.sender, _newOwner);\n', '  }\n', '\n', '  function isMainAdmin() public view returns (bool) {\n', '    return msg.sender == mainAdmin;\n', '  }\n', '\n', '  function isContractAdmin() public view returns (bool) {\n', '    return msg.sender == contractAdmin;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' */\n', 'library SafeMath {\n', '  /**\n', '   * @dev Multiplies two unsigned integers, reverts on overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0);\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two unsigned integers, reverts on overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '   * reverts when dividing by zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'interface ICitizen {\n', '\n', '  function addF1DepositedToInviter(address _invitee, uint _amount) external;\n', '\n', '  function addNetworkDepositedToInviter(address _inviter, uint _amount, uint _source, uint _sourceAmount) external;\n', '\n', '  function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\n', '\n', '  function getF1Deposited(address _investor) external view returns (uint);\n', '\n', '  function getId(address _investor) external view returns (uint);\n', '\n', '  function getInvestorCount() external view returns (uint);\n', '\n', '  function getInviter(address _investor) external view returns (address);\n', '\n', '  function getDirectlyInvitee(address _investor) external view returns (address[]);\n', '\n', '  function getDirectlyInviteeHaveJoinedPackage(address _investor) external view returns (address[]);\n', '\n', '  function getNetworkDeposited(address _investor) external view returns (uint);\n', '\n', '  function getRank(address _investor) external view returns (uint);\n', '\n', '  function getRankBonus(uint _index) external view returns (uint);\n', '\n', '  function getUserAddresses(uint _index) external view returns (address);\n', '\n', '  function getSubscribers(address _investor) external view returns (uint);\n', '\n', '  function increaseInviterF1HaveJoinedPackage(address _invitee) external;\n', '\n', '  function isCitizen(address _user) view external returns (bool);\n', '\n', '  function register(address _user, string _userName, address _inviter) external returns (uint);\n', '\n', '  function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[], uint, uint, uint, uint);\n', '}\n', '\n', 'interface IReserveFund {\n', '\n', '  function getLockedStatus(address _investor) view external returns (uint8);\n', '\n', '  function getTransferDifficulty() view external returns (uint);\n', '}\n', '\n', 'contract Wallet is Auth {\n', '  using SafeMath for uint;\n', '\n', '  struct Balance {\n', '    // NOTE: balance is counted in mili-dollar (1/1000 dollar)\n', '    uint totalDeposited; // Treasury package\n', '    uint[] deposited;\n', '    uint profitableBalance; // Green wallet\n', '    uint profitSourceBalance; // Gold wallet\n', '    uint profitBalance; // Mining wallet\n', '    uint totalProfited;\n', '    uint amountToMineToken;\n', '    uint ethWithdrew;\n', '  }\n', '\n', '  IReserveFund private reserveFundContract;\n', '  ICitizen private citizen;\n', '\n', '  uint public ethWithdrew;\n', '  uint private profitPaid;\n', '  uint private f11RewardCondition = 200000000; // 200k\n', '\n', '  mapping (address => Balance) private userWallets;\n', '\n', '  modifier onlyReserveFundContract() {\n', '    require(msg.sender == address(reserveFundContract), "onlyReserveFundContract");\n', '    _;\n', '  }\n', '\n', '  modifier onlyCitizenContract() {\n', '    require(msg.sender == address(citizen), "onlyCitizenContract");\n', '    _;\n', '  }\n', '\n', '  event ProfitBalanceTransferred(address from, address to, uint amount);\n', '  event RankBonusSent(address investor, uint rank, uint amount);\n', '  // source: 0-eth 1-token 2-usdt\n', '  event ProfitSourceBalanceChanged(address investor, int amount, address from, uint8 source);\n', '  event ProfitableBalanceChanged(address investor, int amount, address from, uint8 source);\n', '  // source: 0-profit paid 1-active user\n', '  event ProfitBalanceChanged(address from, address to, int amount, uint8 source);\n', '\n', '  constructor (address _mainAdmin, address _citizen)\n', '  Auth(_mainAdmin, msg.sender)\n', '  public\n', '  {\n', '    citizen = ICitizen(_citizen);\n', '  }\n', '\n', '  // ONLY-MAIN-ADMIN-FUNCTIONS\n', '  function getProfitPaid() onlyMainAdmin public view returns(uint) {\n', '    return profitPaid;\n', '  }\n', '\n', '  // ONLY-CONTRACT-ADMIN FUNCTIONS\n', '\n', '  function setDABankContract(address _reserveFundContract) onlyContractAdmin public {\n', '    reserveFundContract = IReserveFund(_reserveFundContract);\n', '  }\n', '\n', '  function makeDailyProfit(address[] _userAddresses) onlyContractAdmin public {\n', '    require(_userAddresses.length > 0, "Invalid input");\n', '    uint investorCount = citizen.getInvestorCount();\n', '    uint dailyPercent;\n', '    uint dailyProfit;\n', '    uint8 lockProfit = 1;\n', '    uint id;\n', '    address userAddress;\n', '    for (uint i = 0; i < _userAddresses.length; i++) {\n', '      id = citizen.getId(_userAddresses[i]);\n', '      require(investorCount > id, "Invalid userId");\n', '      userAddress = _userAddresses[i];\n', '      if (reserveFundContract.getLockedStatus(userAddress) != lockProfit) {\n', '        Balance storage balance = userWallets[userAddress];\n', '        dailyPercent = (balance.totalProfited == 0 || balance.totalProfited < balance.totalDeposited) ? 5 : (balance.totalProfited < 4 * balance.totalDeposited) ? 4 : 3;\n', '        dailyProfit = balance.profitableBalance.mul(dailyPercent).div(1000);\n', '\n', '        balance.profitableBalance = balance.profitableBalance.sub(dailyProfit);\n', '        balance.profitBalance = balance.profitBalance.add(dailyProfit);\n', '        balance.totalProfited = balance.totalProfited.add(dailyProfit);\n', '        profitPaid = profitPaid.add(dailyProfit);\n', '        emit ProfitBalanceChanged(address(0x0), userAddress, int(dailyProfit), 0);\n', '      }\n', '    }\n', '  }\n', '\n', '  // ONLY-DABANK-CONTRACT FUNCTIONS\n', '  // _source: 0-eth 1-token 2-usdt\n', '  function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount) onlyReserveFundContract public {\n', '    require(_to != address(0x0), "User address can not be empty");\n', '    require(_deposited > 0, "Package value must be > 0");\n', '\n', '    Balance storage balance = userWallets[_to];\n', '    bool firstDeposit = balance.deposited.length == 0;\n', '    balance.deposited.push(_deposited);\n', '    uint profitableIncreaseAmount = _deposited * (firstDeposit ? 2 : 1);\n', '    uint profitSourceIncreaseAmount = _deposited * 8;\n', '    balance.totalDeposited = balance.totalDeposited.add(_deposited);\n', '    balance.profitableBalance = balance.profitableBalance.add(profitableIncreaseAmount);\n', '    balance.profitSourceBalance = balance.profitSourceBalance.add(_deposited * 8);\n', '    if (_source == 2) {\n', '      if (_to == tx.origin) {\n', '        // self deposit\n', '        balance.profitBalance = balance.profitBalance.sub(_deposited);\n', '      } else {\n', '        // deposit to another\n', '        Balance storage senderBalance = userWallets[tx.origin];\n', '        senderBalance.profitBalance = senderBalance.profitBalance.sub(_deposited);\n', '      }\n', '      emit ProfitBalanceChanged(tx.origin, _to, int(_deposited) * -1, 1);\n', '    }\n', '    citizen.addF1DepositedToInviter(_to, _deposited);\n', '    addRewardToInviters(_to, _deposited, _source, _sourceAmount);\n', '\n', '    if (firstDeposit) {\n', '      citizen.increaseInviterF1HaveJoinedPackage(_to);\n', '    }\n', '\n', '    if (profitableIncreaseAmount > 0) {\n', '      emit ProfitableBalanceChanged(_to, int(profitableIncreaseAmount), _to, _source);\n', '      emit ProfitSourceBalanceChanged(_to, int(profitSourceIncreaseAmount), _to, _source);\n', '    }\n', '  }\n', '\n', '  function bonusForAdminWhenUserBuyPackageViaDollar(uint _amount, address _admin) onlyReserveFundContract public {\n', '    Balance storage adminBalance = userWallets[_admin];\n', '    adminBalance.profitBalance = adminBalance.profitBalance.add(_amount);\n', '  }\n', '\n', '  function increaseETHWithdrew(uint _amount) onlyReserveFundContract public {\n', '    ethWithdrew = ethWithdrew.add(_amount);\n', '  }\n', '\n', '  function mineToken(address _from, uint _amount) onlyReserveFundContract public {\n', '    Balance storage userBalance = userWallets[_from];\n', '    userBalance.profitBalance = userBalance.profitBalance.sub(_amount);\n', '    userBalance.amountToMineToken = userBalance.amountToMineToken.add(_amount);\n', '  }\n', '\n', '  function validateCanMineToken(uint _tokenAmount, address _from) onlyReserveFundContract public view {\n', '    Balance storage userBalance = userWallets[_from];\n', '    require(userBalance.amountToMineToken.add(_tokenAmount) <= 4 * userBalance.totalDeposited, "You can only mine maximum 4x of your total deposited");\n', '  }\n', '\n', '  // ONLY-CITIZEN-CONTRACT FUNCTIONS\n', '\n', '  function bonusNewRank(address _investorAddress, uint _currentRank, uint _newRank) onlyCitizenContract public {\n', '    require(_newRank > _currentRank, "Invalid ranks");\n', '    Balance storage balance = userWallets[_investorAddress];\n', '    for (uint8 i = uint8(_currentRank) + 1; i <= uint8(_newRank); i++) {\n', '      uint rankBonusAmount = citizen.getRankBonus(i);\n', '      balance.profitBalance = balance.profitBalance.add(rankBonusAmount);\n', '      if (rankBonusAmount > 0) {\n', '        emit RankBonusSent(_investorAddress, i, rankBonusAmount);\n', '      }\n', '    }\n', '  }\n', '\n', '  // PUBLIC FUNCTIONS\n', '\n', '  function getUserWallet(address _investor)\n', '  public\n', '  view\n', '  returns (uint, uint[], uint, uint, uint, uint, uint)\n', '  {\n', '    if (msg.sender != address(reserveFundContract) && msg.sender != contractAdmin && msg.sender != mainAdmin) {\n', '      require(_investor != mainAdmin, "You can not see admin account");\n', '    }\n', '    Balance storage balance = userWallets[_investor];\n', '    return (\n', '      balance.totalDeposited,\n', '      balance.deposited,\n', '      balance.profitableBalance,\n', '      balance.profitSourceBalance,\n', '      balance.profitBalance,\n', '      balance.totalProfited,\n', '      balance.ethWithdrew\n', '    );\n', '  }\n', '\n', '  function getInvestorLastDeposited(address _investor) public view returns (uint) {\n', '    return userWallets[_investor].deposited.length == 0 ? 0 : userWallets[_investor].deposited[userWallets[_investor].deposited.length - 1];\n', '  }\n', '\n', '  function transferProfitWallet(uint _amount, address _to) public {\n', '    require(_amount >= reserveFundContract.getTransferDifficulty(), "Amount must be >= minimumTransferProfitBalance");\n', '    Balance storage senderBalance = userWallets[msg.sender];\n', '    require(citizen.isCitizen(msg.sender), "Please register first");\n', '    require(citizen.isCitizen(_to), "You can only transfer to an exists member");\n', '    require(senderBalance.profitBalance >= _amount, "You have not enough balance");\n', '    bool inTheSameTree = citizen.checkInvestorsInTheSameReferralTree(msg.sender, _to);\n', '    require(inTheSameTree, "This user isn\'t in your referral tree");\n', '    Balance storage receiverBalance = userWallets[_to];\n', '    senderBalance.profitBalance = senderBalance.profitBalance.sub(_amount);\n', '    receiverBalance.profitBalance = receiverBalance.profitBalance.add(_amount);\n', '    emit ProfitBalanceTransferred(msg.sender, _to, _amount);\n', '  }\n', '\n', '  function getProfitBalance(address _investor) public view returns (uint) {\n', '    return userWallets[_investor].profitBalance;\n', '  }\n', '\n', '  // PRIVATE FUNCTIONS\n', '\n', '  function addRewardToInviters(address _invitee, uint _amount, uint8 _source, uint _sourceAmount) private {\n', '    address inviter;\n', '    uint16 referralLevel = 1;\n', '    do {\n', '      inviter = citizen.getInviter(_invitee);\n', '      if (inviter != address(0x0)) {\n', '        citizen.addNetworkDepositedToInviter(inviter, _amount, _source, _sourceAmount);\n', '        checkAddReward(_invitee, inviter, referralLevel, _source, _amount);\n', '        _invitee = inviter;\n', '        referralLevel += 1;\n', '      }\n', '    } while (inviter != address(0x0));\n', '  }\n', '\n', '  function checkAddReward(address _invitee,address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\n', '    uint f1Deposited = citizen.getF1Deposited(_inviter);\n', '    uint networkDeposited = citizen.getNetworkDeposited(_inviter);\n', '    uint directlyInviteeCount = citizen.getDirectlyInviteeHaveJoinedPackage(_inviter).length;\n', '    uint rank = citizen.getRank(_inviter);\n', '    if (_referralLevel == 1) {\n', '      moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\n', '    } else if (_referralLevel > 1 && _referralLevel < 11) {\n', '      bool condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3 : false;\n', '      bool condition2 = directlyInviteeCount >= _referralLevel;\n', '      if (condition1 && condition2) {\n', '        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\n', '      }\n', '    } else {\n', '      condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3: false;\n', '      condition2 = directlyInviteeCount >= 10;\n', '      bool condition3 = networkDeposited >= f11RewardCondition;\n', '      bool condition4 = rank >= 3;\n', '      if (condition1 && condition2 && condition3 && condition4) {\n', '        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\n', '      }\n', '    }\n', '  }\n', '\n', '  function moveBalanceForInvitingSuccessful(address _invitee, address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\n', '    uint divider = (_referralLevel == 1) ? 2 : (_referralLevel > 1 && _referralLevel < 11) ? 10 : 20;\n', '    Balance storage balance = userWallets[_inviter];\n', '    uint willMoveAmount = _amount / divider;\n', '    if (balance.profitSourceBalance > willMoveAmount) {\n', '      balance.profitableBalance = balance.profitableBalance.add(willMoveAmount);\n', '      balance.profitSourceBalance = balance.profitSourceBalance.sub(willMoveAmount);\n', '      if (willMoveAmount > 0) {\n', '        emit ProfitableBalanceChanged(_inviter, int(willMoveAmount), _invitee, _source);\n', '        emit ProfitSourceBalanceChanged(_inviter, int(willMoveAmount) * -1, _invitee, _source);\n', '      }\n', '    } else {\n', '      if (balance.profitSourceBalance > 0) {\n', '        emit ProfitableBalanceChanged(_inviter, int(balance.profitSourceBalance), _invitee, _source);\n', '        emit ProfitSourceBalanceChanged(_inviter, int(balance.profitSourceBalance) * -1, _invitee, _source);\n', '      }\n', '      balance.profitableBalance = balance.profitableBalance.add(balance.profitSourceBalance);\n', '      balance.profitSourceBalance = 0;\n', '    }\n', '  }\n', '}']