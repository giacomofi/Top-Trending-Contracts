['pragma solidity ^0.5.3;\n', '\n', 'contract Operator {\n', '    uint256 public ONE_DAY = 86400;\n', '    uint256 public MIN_DEP = 1 ether;\n', '    uint256 public MAX_DEP = 100 ether;\n', '    address public admin;\n', '    address public admin2;\n', '    address public querierAddress;\n', '    uint256 public depositedAmountGross = 0;\n', '    uint256 public paySystemCommissionTimes = 1;\n', '    uint256 public payDailyIncomeTimes = 1;\n', '    uint256 public lastPaySystemCommission = now;\n', '    uint256 public lastPayDailyIncome = now;\n', '    uint256 public contractStartAt = now;\n', '    uint256 public lastReset = now;\n', '    address payable public operationFund = 0xa4048772583220896ec93316616778B4EbC70F9d;\n', '    address[] public investorAddresses;\n', '    bytes32[] public investmentIds;\n', '    bytes32[] public withdrawalIds;\n', '    bytes32[] public maxOutIds;\n', '    mapping (address => Investor) investors;\n', '    mapping (bytes32 => Investment) public investments;\n', '    mapping (bytes32 => Withdrawal) public withdrawals;\n', '    mapping (bytes32 => MaxOut) public maxOuts;\n', '    mapping (address => WithdrawAccount) public withdrawAccounts;\n', '    uint256 additionNow = 0;\n', '\n', '    uint256 public maxLevelsAddSale = 200;\n', '    uint256 public maximumMaxOutInWeek = 2;\n', '    bool public importing = true;\n', '\n', '    Vote public currentVote;\n', '\n', '    struct WithdrawAccount {\n', '        address initialAddress;\n', '        address currentWithdrawalAddress;\n', '        address requestingWithdrawalAddress;\n', '    }\n', '\n', '    struct Vote {\n', '        uint256 startTime;\n', '        string reason;\n', '        mapping (address => uint8) votes;\n', '        address payable emergencyAddress;\n', '        uint256 yesPoint;\n', '        uint256 noPoint;\n', '        uint256 totalPoint;\n', '    }\n', '\n', '    struct Investment {\n', '        bytes32 id;\n', '        uint256 at;\n', '        uint256 amount;\n', '        address investor;\n', '        address nextInvestor;\n', '        bool nextBranch;\n', '    }\n', '\n', '    struct Withdrawal {\n', '        bytes32 id;\n', '        uint256 at;\n', '        uint256 amount;\n', '        address investor;\n', '        address presentee;\n', '        uint256 reason;\n', '        uint256 times;\n', '    }\n', '\n', '    struct Investor {\n', '        address parent;\n', '        address leftChild;\n', '        address rightChild;\n', '        address presenter;\n', '        uint256 generation;\n', '        uint256 depositedAmount;\n', '        uint256 withdrewAmount;\n', '        bool isDisabled;\n', '        uint256 lastMaxOut;\n', '        uint256 maxOutTimes;\n', '        uint256 maxOutTimesInWeek;\n', '        uint256 totalSell;\n', '        uint256 sellThisMonth;\n', '        uint256 rightSell;\n', '        uint256 leftSell;\n', '        uint256 reserveCommission;\n', '        uint256 dailyIncomeWithrewAmount;\n', '        uint256 registerTime;\n', '        uint256 minDeposit;\n', '        bytes32[] investments;\n', '        bytes32[] withdrawals;\n', '    }\n', '\n', '    struct MaxOut {\n', '        bytes32 id;\n', '        address investor;\n', '        uint256 times;\n', '        uint256 at;\n', '    }\n', '\n', '    constructor () public { admin = msg.sender; }\n', '    \n', '    modifier mustBeAdmin() {\n', '        require(msg.sender == admin || msg.sender == querierAddress || msg.sender == admin2);\n', '        _;\n', '    }\n', '\n', '    modifier mustBeImporting() { require(importing); require(msg.sender == querierAddress || msg.sender == admin); _; }\n', '    \n', '    function () payable external { deposit(); }\n', '\n', '    function getNow() internal view returns(uint256) {\n', '        return additionNow + now;\n', '    }\n', '\n', '    function depositProcess(address sender) internal {\n', '        Investor storage investor = investors[sender];\n', '        require(investor.generation != 0);\n', '        if (investor.depositedAmount == 0) require(msg.value >= investor.minDeposit);\n', '        require(investor.maxOutTimesInWeek < maximumMaxOutInWeek);\n', '        require(investor.maxOutTimes < 50);\n', '        require(investor.maxOutTimes == 0 || getNow() - investor.lastMaxOut < ONE_DAY * 7 || investor.depositedAmount != 0);\n', '        depositedAmountGross += msg.value;\n', '        bytes32 id = keccak256(abi.encodePacked(block.number, getNow(), sender, msg.value));\n', '        uint256 investmentValue = investor.depositedAmount + msg.value <= MAX_DEP ? msg.value : MAX_DEP - investor.depositedAmount;\n', '        if (investmentValue == 0) return;\n', '        bool nextBranch = investors[investor.parent].leftChild == sender; \n', '        Investment memory investment = Investment({ id: id, at: getNow(), amount: investmentValue, investor: sender, nextInvestor: investor.parent, nextBranch: nextBranch  });\n', '        investments[id] = investment;\n', '        processInvestments(id);\n', '        investmentIds.push(id);\n', '    }\n', '\n', '    function pushNewMaxOut(address investorAddress, uint256 times, uint256 depositedAmount) internal {\n', '        bytes32 id = keccak256(abi.encodePacked(block.number, getNow(), investorAddress, times));\n', '        MaxOut memory maxOut = MaxOut({ id: id, at: getNow(), investor: investorAddress, times: times });\n', '        maxOutIds.push(id);\n', '        maxOuts[id] = maxOut;\n', '        investors[investorAddress].minDeposit = depositedAmount;\n', '    }\n', '    \n', '    function deposit() payable public { depositProcess(msg.sender); }\n', '    \n', '    function processInvestments(bytes32 investmentId) internal {\n', '        Investment storage investment = investments[investmentId];\n', '        uint256 amount = investment.amount;\n', '        Investor storage investor = investors[investment.investor];\n', '        investor.investments.push(investmentId);\n', '        investor.depositedAmount += amount;\n', '        address payable presenterAddress = address(uint160(investor.presenter));\n', '        Investor storage presenter = investors[presenterAddress];\n', '        if (presenterAddress != address(0)) {\n', '            presenter.totalSell += amount;\n', '            presenter.sellThisMonth += amount;\n', '        }\n', '        if (presenter.depositedAmount >= MIN_DEP && !presenter.isDisabled) {\n', '            sendEtherForInvestor(presenterAddress, amount / 10, 1, investment.investor, 0);\n', '        }\n', '    }\n', '\n', '    function getWithdrawAddress(address payable initialAddress) public view returns (address payable) {\n', '        WithdrawAccount memory withdrawAccount = withdrawAccounts[initialAddress];\n', '        address withdrawAddress = withdrawAccount.currentWithdrawalAddress;\n', '        if (withdrawAddress != address(0)) return address(uint160(withdrawAddress));\n', '        return initialAddress;\n', '    }\n', '\n', '    function requestChangeWithdrawAddress(address newAddress) public {\n', '        require(investors[msg.sender].depositedAmount > 0);\n', '        WithdrawAccount storage currentWithdrawAccount = withdrawAccounts[msg.sender];\n', '        if (currentWithdrawAccount.initialAddress != address(0)) {\n', '            currentWithdrawAccount.requestingWithdrawalAddress = newAddress;\n', '            return;\n', '        }\n', '        WithdrawAccount memory withdrawAccount = WithdrawAccount({\n', '            initialAddress: msg.sender,\n', '            currentWithdrawalAddress: msg.sender,\n', '            requestingWithdrawalAddress: newAddress\n', '        });\n', '        withdrawAccounts[msg.sender] = withdrawAccount;\n', '    }\n', '\n', '    function acceptChangeWithdrawAddress(address initialAddress, address requestingWithdrawalAddress) public mustBeAdmin {\n', '        WithdrawAccount storage withdrawAccount = withdrawAccounts[initialAddress];\n', '        require(withdrawAccount.requestingWithdrawalAddress == requestingWithdrawalAddress);\n', '        withdrawAccount.requestingWithdrawalAddress = address(0);\n', '        withdrawAccount.currentWithdrawalAddress = requestingWithdrawalAddress;\n', '    }\n', '\n', '    function addSellForParents(bytes32 investmentId) public mustBeAdmin {\n', '        Investment storage investment = investments[investmentId];\n', '        require(investment.nextInvestor != address(0));\n', '        uint256 amount = investment.amount;\n', '        uint256 loopCount = 0;\n', '        while (investment.nextInvestor != address(0) && loopCount < maxLevelsAddSale) {\n', '            Investor storage investor = investors[investment.nextInvestor];\n', '            if (investment.nextBranch) investor.leftSell += amount;\n', '            else investor.rightSell += amount;\n', '            investment.nextBranch = investors[investor.parent].leftChild == investment.nextInvestor;\n', '            investment.nextInvestor = investor.parent;\n', '            loopCount++;\n', '        }\n', '    }\n', '\n', '    function sendEtherForInvestor(address payable investorAddress, uint256 value, uint256 reason, address presentee, uint256 times) internal {\n', '        if (value == 0 && reason != 100) return;\n', '        if (investorAddress == address(0)) return;\n', '        Investor storage investor = investors[investorAddress];\n', '        uint256 unpaidSystemCommission = getUnpaidSystemCommission(investorAddress);\n', '        uint256 totalPaidAfterThisTime = investor.reserveCommission + getDailyIncomeForUser(investorAddress) + unpaidSystemCommission;\n', '        if (reason == 1) totalPaidAfterThisTime += value;\n', '        if (totalPaidAfterThisTime + investor.withdrewAmount >= 3 * investor.depositedAmount) {\n', '            payWithMaxOut(totalPaidAfterThisTime, investorAddress, unpaidSystemCommission);\n', '            return;\n', '        }\n', '        if (investor.reserveCommission > 0) payWithNoMaxOut(investor.reserveCommission, investorAddress, 4, address(0), 0);\n', '        payWithNoMaxOut(value, investorAddress, reason, presentee, times);\n', '    }\n', '    \n', '    function payWithNoMaxOut(uint256 amountToPay, address payable investorAddress, uint256 reason, address presentee, uint256 times) internal {\n', '        investors[investorAddress].withdrewAmount += amountToPay;\n', '        if (reason == 4) investors[investorAddress].reserveCommission = 0;\n', '        if (reason == 3) resetSystemCommision(investorAddress, times);\n', '        if (reason == 2) investors[investorAddress].dailyIncomeWithrewAmount += amountToPay;\n', '        pay(amountToPay, investorAddress, reason, presentee, times);\n', '    }\n', '    \n', '    function payWithMaxOut(uint256 totalPaidAfterThisTime, address payable investorAddress, uint256 unpaidSystemCommission) internal {\n', '        Investor storage investor = investors[investorAddress];\n', '        uint256 amountToPay = investor.depositedAmount * 3 - investor.withdrewAmount;\n', '        uint256 amountToReserve = totalPaidAfterThisTime - amountToPay;\n', '        if (unpaidSystemCommission > 0) resetSystemCommision(investorAddress, 0);\n', '        investor.maxOutTimes++;\n', '        investor.maxOutTimesInWeek++;\n', '        uint256 oldDepositedAmount = investor.depositedAmount;\n', '        investor.depositedAmount = 0;\n', '        investor.withdrewAmount = 0;\n', '        investor.lastMaxOut = getNow();\n', '        investor.dailyIncomeWithrewAmount = 0;\n', '        investor.reserveCommission = amountToReserve;\n', '        pushNewMaxOut(investorAddress, investor.maxOutTimes, oldDepositedAmount);\n', '        pay(amountToPay, investorAddress, 0, address(0), 0);\n', '    }\n', '\n', '    function pay(uint256 amountToPay, address payable investorAddress, uint256 reason, address presentee, uint256 times) internal {\n', '        if (amountToPay == 0) return;\n', '        address payable withdrawAddress = getWithdrawAddress(investorAddress);\n', '        withdrawAddress.transfer(amountToPay / 100 * 90);\n', '        operationFund.transfer(amountToPay / 100 * 10);\n', '        bytes32 id = keccak256(abi.encodePacked(block.difficulty, getNow(), investorAddress, amountToPay, reason));\n', '        Withdrawal memory withdrawal = Withdrawal({ id: id, at: getNow(), amount: amountToPay, investor: investorAddress, presentee: presentee, times: times, reason: reason });\n', '        withdrawals[id] = withdrawal;\n', '        investors[investorAddress].withdrawals.push(id);\n', '        withdrawalIds.push(id);\n', '    }\n', '\n', '    function getAllIncomeTilNow(address investorAddress) internal view returns(uint256 allIncome) {\n', '        Investor memory investor = investors[investorAddress];\n', '        uint256 unpaidDailyIncome = getDailyIncomeForUser(investorAddress);\n', '        uint256 withdrewAmount = investor.withdrewAmount;\n', '        uint256 unpaidSystemCommission = getUnpaidSystemCommission(investorAddress);\n', '        uint256 allIncomeNow = unpaidDailyIncome + withdrewAmount + unpaidSystemCommission;\n', '        return allIncomeNow;\n', '    }\n', '\n', '    function putPresentee(address presenterAddress, address presenteeAddress, address parentAddress, bool isLeft) public mustBeAdmin {\n', '        Investor storage presenter = investors[presenterAddress];\n', '        Investor storage parent = investors[parentAddress];\n', '        if (investorAddresses.length != 0) {\n', '            require(presenter.generation != 0);\n', '            require(parent.generation != 0);\n', '            if (isLeft) {\n', '                require(parent.leftChild == address(0)); \n', '            } else {\n', '                require(parent.rightChild == address(0)); \n', '            }\n', '        }\n', '        Investor memory investor = Investor({\n', '            parent: parentAddress,\n', '            leftChild: address(0),\n', '            rightChild: address(0),\n', '            presenter: presenterAddress,\n', '            generation: parent.generation + 1,\n', '            depositedAmount: 0,\n', '            withdrewAmount: 0,\n', '            isDisabled: false,\n', '            lastMaxOut: getNow(),\n', '            maxOutTimes: 0,\n', '            maxOutTimesInWeek: 0,\n', '            totalSell: 0,\n', '            sellThisMonth: 0,\n', '            registerTime: getNow(),\n', '            investments: new bytes32[](0),\n', '            withdrawals: new bytes32[](0),\n', '            minDeposit: MIN_DEP,\n', '            rightSell: 0,\n', '            leftSell: 0,\n', '            reserveCommission: 0,\n', '            dailyIncomeWithrewAmount: 0\n', '        });\n', '        investors[presenteeAddress] = investor;\n', '       \n', '        investorAddresses.push(presenteeAddress);\n', '        if (parent.generation == 0) return;\n', '        if (isLeft) {\n', '            parent.leftChild = presenteeAddress;\n', '        } else {\n', '            parent.rightChild = presenteeAddress;\n', '        }\n', '    }\n', '\n', '    function getDailyIncomeForUser(address investorAddress) internal view returns(uint256 amount) {\n', '        Investor memory investor = investors[investorAddress];\n', '        uint256 investmentLength = investor.investments.length;\n', '        uint256 dailyIncome = 0;\n', '        for (uint256 i = 0; i < investmentLength; i++) {\n', '            Investment memory investment = investments[investor.investments[i]];\n', '            if (investment.at < investor.lastMaxOut) continue; \n', '            if (getNow() - investment.at >= ONE_DAY) {\n', '                uint256 numberOfDay = (getNow() - investment.at) / ONE_DAY;\n', '                uint256 totalDailyIncome = numberOfDay * investment.amount / 100 * 2 / 3;\n', '                dailyIncome = totalDailyIncome + dailyIncome;\n', '            }\n', '        }\n', '        return dailyIncome - investor.dailyIncomeWithrewAmount;\n', '    }\n', '    \n', '    function payDailyIncomeForInvestor(address payable investorAddress, uint256 times) public mustBeAdmin {\n', '        uint256 dailyIncome = getDailyIncomeForUser(investorAddress);\n', '        Investor storage investor = investors[investorAddress];\n', '        if (times > ONE_DAY) {\n', '            uint256 investmentLength = investor.investments.length;\n', '            bytes32 lastInvestmentId = investor.investments[investmentLength - 1];\n', '            investments[lastInvestmentId].at -= times;\n', '            investors[investorAddress].lastMaxOut = investments[lastInvestmentId].at;\n', '            return;\n', '        }\n', '        if (investor.isDisabled) return;\n', '        sendEtherForInvestor(investorAddress, dailyIncome, 2, address(0), times);\n', '    }\n', '    \n', '    function payDailyIncomeByIndex(uint256 from, uint256 to) public mustBeAdmin{\n', '        for(uint256 i = from; i <= to; i++) {\n', '            payDailyIncomeForInvestor(address(uint160(investorAddresses[i])), payDailyIncomeTimes);\n', '        }\n', '    }\n', '\n', '    function getUnpaidSystemCommission(address investorAddress) public view returns(uint256 unpaid) {\n', '        Investor memory investor = investors[investorAddress];\n', '        uint256 depositedAmount = investor.depositedAmount;\n', '        uint256 totalSell = investor.totalSell;\n', '        uint256 leftSell = investor.leftSell;\n', '        uint256 rightSell = investor.rightSell;\n', '        uint256 sellThisMonth = investor.sellThisMonth;\n', '        uint256 sellToPaySystemCommission = rightSell < leftSell ? rightSell : leftSell;\n', '        uint256 commission = sellToPaySystemCommission * getPercentage(depositedAmount, totalSell, sellThisMonth) / 100;\n', '        return commission;\n', '    }\n', '    \n', '    function paySystemCommissionInvestor(address payable investorAddress, uint256 times) public mustBeAdmin {\n', '        Investor storage investor = investors[investorAddress];\n', '        if (investor.isDisabled) return;\n', '        uint256 systemCommission = getUnpaidSystemCommission(investorAddress);\n', '        sendEtherForInvestor(investorAddress, systemCommission, 3, address(0), times);\n', '    }\n', '\n', '    function resetSystemCommision(address investorAddress, uint256 times) internal {\n', '        Investor storage investor = investors[investorAddress];\n', '        if (paySystemCommissionTimes > 3 && times != 0) {\n', '            investor.rightSell = 0;\n', '            investor.leftSell = 0;\n', '        } else if (investor.rightSell >= investor.leftSell) {\n', '            investor.rightSell = investor.rightSell - investor.leftSell;\n', '            investor.leftSell = 0;\n', '        } else {\n', '            investor.leftSell = investor.leftSell - investor.rightSell;\n', '            investor.rightSell = 0;\n', '        }\n', '        if (times != 0) investor.sellThisMonth = 0;\n', '    }\n', '\n', '    function paySystemCommissionByIndex(uint256 from, uint256 to) public mustBeAdmin {\n', '         require(from >= 0 && to < investorAddresses.length);\n', '        if (getNow() <= 30 * ONE_DAY + contractStartAt) return;\n', '        for(uint256 i = from; i <= to; i++) {\n', '            paySystemCommissionInvestor(address(uint160(investorAddresses[i])), paySystemCommissionTimes);\n', '        }\n', '    }\n', '    \n', '    function finishPayDailyIncome() public mustBeAdmin {\n', '        lastPayDailyIncome = getNow();\n', '        payDailyIncomeTimes++;\n', '    }\n', '    \n', '    function finishPaySystemCommission() public mustBeAdmin {\n', '        lastPaySystemCommission = getNow();\n', '        paySystemCommissionTimes++;\n', '    }\n', '    \n', '    function resetGame(uint256 from, uint256 to) public mustBeAdmin {\n', '        require(from >= 0 && to < investorAddresses.length);\n', '        require(currentVote.startTime != 0);\n', '        require(getNow() - currentVote.startTime > 3 * ONE_DAY);\n', '        require(currentVote.yesPoint > currentVote.totalPoint / 2);\n', '        require(currentVote.emergencyAddress == address(0));\n', '        lastReset = getNow();\n', '        for (uint256 i = from; i < to; i++) {\n', '            address investorAddress = investorAddresses[i];\n', '            Investor storage investor = investors[investorAddress];\n', '            uint256 currentVoteValue = currentVote.votes[investorAddress] != 0 ? currentVote.votes[investorAddress] : 2;\n', '            if (currentVoteValue == 2) {\n', '                if (investor.maxOutTimes > 0 || (investor.withdrewAmount >= investor.depositedAmount && investor.withdrewAmount != 0)) {\n', '                    investor.lastMaxOut = getNow();\n', '                    investor.depositedAmount = 0;\n', '                    investor.withdrewAmount = 0;\n', '                    investor.dailyIncomeWithrewAmount = 0;\n', '                }\n', '                investor.reserveCommission = 0;\n', '                investor.rightSell = 0;\n', '                investor.leftSell = 0;\n', '                investor.totalSell = 0;\n', '                investor.sellThisMonth = 0;\n', '            } else {\n', '                if (investor.maxOutTimes > 0 || (investor.withdrewAmount >= investor.depositedAmount && investor.withdrewAmount != 0)) {\n', '                    investor.isDisabled = true;\n', '                    investor.reserveCommission = 0;\n', '                    investor.lastMaxOut = getNow();\n', '                    investor.depositedAmount = 0;\n', '                    investor.withdrewAmount = 0;\n', '                    investor.dailyIncomeWithrewAmount = 0;\n', '                }\n', '                investor.reserveCommission = 0;\n', '                investor.rightSell = 0;\n', '                investor.leftSell = 0;\n', '                investor.totalSell = 0;\n', '                investor.sellThisMonth = 0;\n', '            }\n', '            \n', '        }\n', '    }\n', '\n', '    function stopGame(uint256 percent, uint256 from, uint256 to) mustBeAdmin public {\n', '        require(currentVote.startTime != 0);\n', '        require(getNow() - currentVote.startTime > 3 * ONE_DAY);\n', '        require(currentVote.noPoint > currentVote.totalPoint / 2);\n', '        require(currentVote.emergencyAddress == address(0));\n', '        require(percent <= 50);\n', '        require(from >= 0 && to < investorAddresses.length);\n', '        for (uint256 i = from; i <= to; i++) {\n', '            address payable investorAddress = address(uint160(investorAddresses[i]));\n', '            Investor storage investor = investors[investorAddress];\n', '            if (investor.maxOutTimes > 0) continue;\n', '            if (investor.isDisabled) continue;\n', '            uint256 depositedAmount = investor.depositedAmount;\n', '            uint256 withdrewAmount = investor.withdrewAmount;\n', '            if (withdrewAmount >= depositedAmount / 2) continue;\n', '            sendEtherForInvestor(investorAddress, depositedAmount * percent / 100 - withdrewAmount, 6, address(0), 0);\n', '        }\n', '    }\n', '    \n', '    function revivalInvestor(address investor) public mustBeAdmin { investors[investor].lastMaxOut = getNow(); }\n', '\n', '    function payToReachMaxOut(address payable investorAddress) public mustBeAdmin {\n', '        uint256 unpaidSystemCommissions = getUnpaidSystemCommission(investorAddress);\n', '        uint256 unpaidDailyIncomes = getDailyIncomeForUser(investorAddress);\n', '        uint256 withdrewAmount = investors[investorAddress].withdrewAmount;\n', '        uint256 depositedAmount = investors[investorAddress].depositedAmount;\n', '        uint256 reserveCommission = investors[investorAddress].reserveCommission;\n', '        require(depositedAmount > 0  && withdrewAmount + unpaidSystemCommissions + unpaidDailyIncomes + reserveCommission >= 3 * depositedAmount);\n', '        sendEtherForInvestor(investorAddress, 0, 100, address(0), 0);\n', '    }\n', '\n', '    function resetMaxOutInWeek(uint256 from, uint256 to) public mustBeAdmin {\n', '        require(from >= 0 && to < investorAddresses.length);\n', '        for (uint256 i = from; i < to; i++) {\n', '            address investorAddress = investorAddresses[i];\n', '            if (investors[investorAddress].maxOutTimesInWeek == 0) continue;\n', '            investors[investorAddress].maxOutTimesInWeek = 0;\n', '        }\n', '    }\n', '\n', '    function setMaximumMaxOutTimes(address investorAddress, uint256 times) public mustBeAdmin{ investors[investorAddress].maxOutTimes = times; }\n', '\n', '    function disableInvestor(address investorAddress) public mustBeAdmin {\n', '        Investor storage investor = investors[investorAddress];\n', '        investor.isDisabled = true;\n', '    }\n', '    \n', '    function enableInvestor(address investorAddress) public mustBeAdmin {\n', '        Investor storage investor = investors[investorAddress];\n', '        investor.isDisabled = false;\n', '    }\n', '    \n', '    function donate() payable public { depositedAmountGross += msg.value; }\n', '\n', '    function getTotalSellLevel(uint256 totalSell) internal pure returns (uint256 level){\n', '        if (totalSell < 30 ether) return 0;\n', '        if (totalSell < 60 ether) return 1;\n', '        if (totalSell < 90 ether) return 2;\n', '        if (totalSell < 120 ether) return 3;\n', '        if (totalSell < 150 ether) return 4;\n', '        return 5;\n', '    }\n', '\n', '    function getSellThisMonthLevel(uint256 sellThisMonth) internal pure returns (uint256 level){\n', '        if (sellThisMonth < 2 ether) return 0;\n', '        if (sellThisMonth < 4 ether) return 1;\n', '        if (sellThisMonth < 6 ether) return 2;\n', '        if (sellThisMonth < 8 ether) return 3;\n', '        if (sellThisMonth < 10 ether) return 4;\n', '        return 5;\n', '    }\n', '    \n', '    function getDepositLevel(uint256 depositedAmount) internal pure returns (uint256 level){\n', '        if (depositedAmount < 2 ether) return 0;\n', '        if (depositedAmount < 4 ether) return 1;\n', '        if (depositedAmount < 6 ether) return 2;\n', '        if (depositedAmount < 8 ether) return 3;\n', '        if (depositedAmount < 10 ether) return 4;\n', '        return 5;\n', '    }\n', '    \n', '    function getPercentage(uint256 depositedAmount, uint256 totalSell, uint256 sellThisMonth) internal pure returns(uint256 level) {\n', '        uint256 totalSellLevel = getTotalSellLevel(totalSell);\n', '        uint256 depLevel = getDepositLevel(depositedAmount);\n', '        uint256 sellThisMonthLevel = getSellThisMonthLevel(sellThisMonth);\n', '        uint256 min12 = totalSellLevel < depLevel ? totalSellLevel : depLevel;\n', '        uint256 minLevel = sellThisMonthLevel < min12 ? sellThisMonthLevel : min12;\n', '        return minLevel * 2;\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) return 0x0;\n', '        assembly { result := mload(add(source, 32)) }\n', '    }\n', '    \n', '    function getInvestor(address investorAddress) view public returns (address[] memory addresses, bool isDisabled, uint256[] memory numbers) {\n', '        addresses = new address[](4);\n', '        numbers = new uint256[](16);\n', '        Investor memory investor = investors[investorAddress];\n', '        addresses[0] = investor.parent;\n', '        addresses[1] = investor.leftChild;\n', '        addresses[2] = investor.rightChild;\n', '        addresses[3] = investor.presenter;\n', '        numbers[0] = investor.generation;\n', '        numbers[1] = investor.depositedAmount;\n', '        numbers[2] = investor.withdrewAmount;\n', '        numbers[3] = investor.lastMaxOut;\n', '        numbers[4] = investor.maxOutTimes;\n', '        numbers[5] = investor.maxOutTimesInWeek;\n', '        numbers[6] = investor.totalSell;\n', '        numbers[7] = investor.sellThisMonth;\n', '        numbers[8] = investor.rightSell;\n', '        numbers[9] = investor.leftSell;\n', '        numbers[10] = investor.reserveCommission;\n', '        numbers[11] = investor.dailyIncomeWithrewAmount;\n', '        numbers[12] = investor.registerTime;\n', '        numbers[13] = getUnpaidSystemCommission(investorAddress);\n', '        numbers[14] = getDailyIncomeForUser(investorAddress);\n', '        numbers[15] = investor.minDeposit;\n', '        return (addresses, investor.isDisabled, numbers);\n', '    }\n', '\n', '    function getInvestorLength() view public returns(uint256) { return investorAddresses.length; }\n', '\n', '    function getMaxOutsLength() view public returns(uint256) { return maxOutIds.length; }\n', '    \n', '    function getNodesAddresses(address rootNodeAddress) public view returns(address[] memory){\n', '        uint256 maxLength = investorAddresses.length;\n', '        address[] memory nodes = new address[](maxLength);\n', '        nodes[0] = rootNodeAddress;\n', '        uint256 processIndex = 0;\n', '        uint256 nextIndex = 1;\n', '        while (processIndex != nextIndex) {\n', '            Investor memory currentInvestor = investors[nodes[processIndex++]];\n', '            if (currentInvestor.leftChild != address(0)) nodes[nextIndex++] = currentInvestor.leftChild;\n', '            if (currentInvestor.rightChild != address(0)) nodes[nextIndex++] = currentInvestor.rightChild;\n', '        }\n', '        return nodes;\n', '    }\n', '    \n', '    function getInvestmentsLength () public view returns(uint256 length) { return investmentIds.length; }\n', '    \n', '    function getWithdrawalsLength() public view returns(uint256 length) { return withdrawalIds.length; }\n', '    \n', '    function importInvestor(address[] memory addresses, bool isDisabled, uint256[] memory numbers) public mustBeImporting {\n', '        if (investors[addresses[4]].generation != 0) return;\n', '        Investor memory investor = Investor({\n', '            isDisabled: isDisabled,\n', '            parent: addresses[0],\n', '            leftChild: addresses[1],\n', '            rightChild: addresses[2],\n', '            presenter: addresses[3],\n', '            generation: numbers[0],\n', '            depositedAmount: numbers[1],\n', '            withdrewAmount: numbers[2],\n', '            lastMaxOut: numbers[3],\n', '            maxOutTimes: numbers[4],\n', '            maxOutTimesInWeek: numbers[5],\n', '            totalSell: numbers[6],\n', '            sellThisMonth: numbers[7],\n', '            investments: new bytes32[](0),\n', '            withdrawals: new bytes32[](0),\n', '            rightSell: numbers[8],\n', '            leftSell: numbers[9],\n', '            reserveCommission: numbers[10],\n', '            dailyIncomeWithrewAmount: numbers[11],\n', '            registerTime: numbers[12],\n', '            minDeposit: MIN_DEP\n', '        });\n', '        investors[addresses[4]] = investor;\n', '        investorAddresses.push(addresses[4]);\n', '    }\n', '    \n', '    function importInvestments(bytes32 id, uint256 at, uint256 amount, address investorAddress) public mustBeImporting {\n', '        if (investments[id].at != 0) return;\n', '        Investment memory investment = Investment({ id: id, at: at, amount: amount, investor: investorAddress, nextInvestor: address(0), nextBranch: false });\n', '        investments[id] = investment;\n', '        investmentIds.push(id);\n', '        Investor storage investor = investors[investorAddress];\n', '        investor.investments.push(id);\n', '        depositedAmountGross += amount;\n', '    }\n', '    \n', '    function importWithdrawals(bytes32 id, uint256 at, uint256 amount, address investorAddress, address presentee, uint256 reason, uint256 times) public mustBeImporting {\n', '        if (withdrawals[id].at != 0) return;\n', '        Withdrawal memory withdrawal = Withdrawal({ id: id, at: at, amount: amount, investor: investorAddress, presentee: presentee, times: times, reason: reason });\n', '        withdrawals[id] = withdrawal;\n', '        Investor storage investor = investors[investorAddress];\n', '        investor.withdrawals.push(id);\n', '        withdrawalIds.push(id);\n', '    }\n', '    \n', '    function finishImporting() public mustBeAdmin { importing = false; }\n', '\n', '    function finalizeVotes(uint256 from, uint256 to, bool isRemoving) public mustBeAdmin {\n', '        require(getNow() - currentVote.startTime > 3 * ONE_DAY);\n', '        for (uint256 index = from; index < to; index++) {\n', '            address investorAddress = investorAddresses[index];\n', '            if (isRemoving && currentVote.votes[investorAddress] == 3) {\n', '                currentVote.votes[investorAddress] = 0;\n', '                continue;\n', '            }\n', '            if (currentVote.votes[investorAddress] == 0) {\n', '                currentVote.yesPoint += 1;\n', '            }\n', '            currentVote.votes[investorAddress] = 3;\n', '        }\n', '    }\n', '\n', '    function createVote(string memory reason, address payable emergencyAddress) public mustBeAdmin {\n', '        require(currentVote.startTime == 0);\n', '        currentVote = Vote({\n', '            startTime: getNow(),\n', '            reason: reason,\n', '            emergencyAddress: emergencyAddress,\n', '            yesPoint: 0,\n', '            noPoint: 0,\n', '            totalPoint: investorAddresses.length\n', '        });\n', '    }\n', '\n', '    function removeVote() public mustBeAdmin {\n', '        currentVote = Vote({\n', '            startTime: 0,\n', "            reason: '',\n", '            emergencyAddress: address(0),\n', '            yesPoint: 0,\n', '            noPoint: 0,\n', '            totalPoint: 0\n', '        });\n', '    }\n', '    \n', '    function sendEtherToNewContract() public mustBeAdmin {\n', '        require(currentVote.startTime != 0);\n', '        require(getNow() - currentVote.startTime > 3 * ONE_DAY);\n', '        require(currentVote.yesPoint > currentVote.totalPoint / 2);\n', '        require(currentVote.emergencyAddress != address(0));\n', '        bool isTransferSuccess = false;\n', '        (isTransferSuccess, ) = currentVote.emergencyAddress.call.value(address(this).balance)("");\n', '        if (!isTransferSuccess) revert();\n', '    }\n', '\n', '    function voteProcess(address investor, bool isYes) internal {\n', '        require(investors[investor].depositedAmount > 0);\n', '        require(!investors[investor].isDisabled);\n', '        require(getNow() - currentVote.startTime < 3 * ONE_DAY);\n', '        uint8 newVoteValue = isYes ? 2 : 1;\n', '        uint8 currentVoteValue = currentVote.votes[investor];\n', '        require(newVoteValue != currentVoteValue);\n', '        updateVote(isYes);\n', '        if (currentVoteValue == 0) return;\n', '        if (isYes) {\n', '            currentVote.noPoint -= getVoteShare();\n', '        } else {\n', '            currentVote.yesPoint -= getVoteShare();\n', '        }\n', '    }\n', '    \n', '    function vote(bool isYes) public { voteProcess(msg.sender, isYes); }\n', '    \n', '    function updateVote(bool isYes) internal {\n', '        currentVote.votes[msg.sender] = isYes ? 2 : 1;\n', '        if (isYes) {\n', '            currentVote.yesPoint += getVoteShare();\n', '        } else {\n', '            currentVote.noPoint += getVoteShare();\n', '        }\n', '    }\n', '    \n', '    function getVoteShare() public view returns(uint256) {\n', '        if (investors[msg.sender].generation >= 3) return 1;\n', '        if (currentVote.totalPoint > 40) return currentVote.totalPoint / 20;\n', '        return 2;\n', '    }\n', '    \n', '    function setQuerier(address _querierAddress) public mustBeAdmin {\n', '        querierAddress = _querierAddress;\n', '    }\n', '\n', '    function setAdmin2(address _admin2) public mustBeAdmin {\n', '        admin2 = _admin2;\n', '    }\n', '\n', '    function setInitialValue(uint256 _paySystemCommissionTimes, uint256 _payDailyIncomeTimes, uint256 _lastPaySystemCommission, uint256 _lastPayDailyIncome, uint256 _contractStartAt, uint256 _lastReset) public mustBeImporting {\n', '        paySystemCommissionTimes = _paySystemCommissionTimes;\n', '        payDailyIncomeTimes = _payDailyIncomeTimes;\n', '        lastPaySystemCommission = _lastPaySystemCommission;\n', '        lastPayDailyIncome = _lastPayDailyIncome;\n', '        contractStartAt = _contractStartAt;\n', '        lastReset = _lastReset;\n', '    }\n', '\n', '    function depositFor(address investor) public payable mustBeAdmin {\n', '        depositProcess(investor);\n', '    }\n', '}\n', '\n', '\n', 'contract Querier {\n', '    Operator public operator;\n', '    address public querierAdmin;\n', '\n', '    constructor () public { querierAdmin = msg.sender; }\n', '\n', '    modifier mustBeAdmin() {\n', '        require(msg.sender == querierAdmin);\n', '        _;\n', '    }\n', '    function setOperator(address payable operatorAddress) public mustBeAdmin {\n', '        operator = Operator(operatorAddress);\n', '    }\n', '    \n', '    function getContractInfo() public view returns (address admin, uint256 depositedAmountGross, uint256 investorsCount, address operationFund, uint256 balance, uint256 paySystemCommissionTimes, uint256 maximumMaxOutInWeek) {\n', '        depositedAmountGross = operator.depositedAmountGross();\n', '        admin = operator.admin();\n', '        operationFund = operator.operationFund();\n', '        balance = address(operator).balance;\n', '        paySystemCommissionTimes = operator.paySystemCommissionTimes();\n', '        maximumMaxOutInWeek = operator.maximumMaxOutInWeek();\n', '        return (admin, depositedAmountGross, operator.getInvestorLength(), operationFund, balance, paySystemCommissionTimes, maximumMaxOutInWeek);\n', '    }\n', '\n', '    function getContractTime() public view returns (uint256 contractStartAt, uint256 lastReset, uint256 oneDay, uint256 lastPayDailyIncome, uint256 lastPaySystemCommission) {\n', '        return (operator.contractStartAt(), operator.lastReset(), operator.ONE_DAY(), operator.lastPayDailyIncome(), operator.lastPaySystemCommission());\n', '    }\n', '    \n', '    function getMaxOuts() public view returns (bytes32[] memory ids, address[] memory investors, uint256[] memory times, uint256[] memory ats) {\n', '        uint256 length = operator.getMaxOutsLength();\n', '        ids = new bytes32[] (length);\n', '        investors = new address[] (length);\n', '        times = new uint256[] (length);\n', '        ats = new uint256[] (length);\n', '        for (uint256 i = 0; i < length; i++) {\n', '            bytes32 id = operator.maxOutIds(i);\n', '            address investor;\n', '            uint256 time;\n', '            uint256 at;\n', '            (id, investor, time, at) = operator.maxOuts(id);\n', '            ids[i] = id;\n', '            times[i] = time;\n', '            investors[i] = investor;\n', '            ats[i] = at;\n', '        }\n', '        return (ids, investors, times, ats);\n', '    }\n', '\n', '    function getInvestmentById(bytes32 investmentId) public view returns (bytes32 id, uint256 at, uint256 amount, address investor, address nextInvestor, bool nextBranch) {\n', '        return operator.investments(investmentId);\n', '    }\n', '    \n', '    function getWithdrawalById(bytes32 withdrawalId) public view returns (bytes32 id, uint256 at, uint256 amount, address investor, address presentee, uint256 reason, uint256 times) {\n', '        return operator.withdrawals(withdrawalId);\n', '    }\n', '    \n', '    function getInvestorsByIndex(uint256 from, uint256 to) public view returns (address[] memory investors, address[] memory addresses, bool[] memory isDisableds, uint256[] memory numbers) {\n', '        uint256 length = operator.getInvestorLength();\n', '        from = from < 0 ? 0 : from;\n', '        to = to > length - 1 ? length - 1 : to; \n', '        uint256 baseArrayLength = to - from + 1;\n', '        addresses = new address[](baseArrayLength * 5);\n', '        isDisableds = new bool[](baseArrayLength);\n', '        numbers = new uint256[](baseArrayLength * 16);\n', '        investors = new address[](baseArrayLength);\n', '        for (uint256 i = 0; i < baseArrayLength; i++) {\n', '            address investorAddress = operator.investorAddresses(i + from);\n', '            address[] memory oneAddresses;\n', '            uint256[] memory oneNumbers;\n', '            bool isDisabled;\n', '            (oneAddresses, isDisabled, oneNumbers) = operator.getInvestor(investorAddress);\n', '            for (uint256 a = 0; a < oneAddresses.length; a++) {\n', '                addresses[i * 5 + a] = oneAddresses[a];\n', '            }\n', '            addresses[i * 5 + 4] = investorAddress;\n', '            for (uint256 b = 0; b < oneNumbers.length; b++) {\n', '                numbers[i * 16 + b] = oneNumbers[b];\n', '            }\n', '            isDisableds[i] = isDisabled;\n', '            investors[i] = investorAddress;\n', '        }\n', '        return (investors, addresses, isDisableds, numbers);\n', '    }\n', '\n', '    function getInvestmentsByIndex(uint256 from, uint256 to) public view returns(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, address[] memory investors, address[] memory nextInvestors) {\n', '        uint256 length = operator.getInvestmentsLength();\n', '        from = from < 0 ? 0 : from;\n', '        to = to > length - 1 ? length - 1 : to; \n', '        uint256 arrayLength = to - from + 1;\n', '        ids = new bytes32[](arrayLength);\n', '        ats = new uint256[](arrayLength);\n', '        amounts = new uint256[](arrayLength);\n', '        investors = new address[](arrayLength);\n', '        nextInvestors = new address[](arrayLength);\n', '        for (uint256 i = 0; i < arrayLength; i++) {\n', '            bytes32 id = operator.investmentIds(i + from);\n', '            uint256 at;\n', '            uint256 amount;\n', '            address investor;\n', '            address nextInvestor;\n', '            (id, at, amount, investor, nextInvestor,) = getInvestmentById(id);\n', '            ids[i] = id;\n', '            ats[i] = at;\n', '            amounts[i] = amount;\n', '            investors[i] = investor;\n', '            nextInvestors[i] = nextInvestor;\n', '        }\n', '        return (ids, ats, amounts, investors, nextInvestors);\n', '    }\n', '\n', '    function getWithdrawalsByIndex(uint256 from, uint256 to) public view returns(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, address[] memory investors, address[] memory presentees, uint256[] memory reasons, uint256[] memory times) {\n', '        uint256 length = operator.getWithdrawalsLength();\n', '        from = from < 0 ? 0 : from;\n', '        to = to > length - 1 ? length - 1 : to; \n', '        uint256 arrayLength = to - from + 1;\n', '        ids = new bytes32[](arrayLength);\n', '        ats = new uint256[](arrayLength);\n', '        amounts = new uint256[](arrayLength);\n', '        investors = new address[](arrayLength);\n', '        presentees = new address[](arrayLength);\n', '        reasons = new uint256[](arrayLength);\n', '        times = new uint256[](arrayLength);\n', '        putWithdrawalsPart1(from, arrayLength, ids, ats, amounts, investors);\n', '        putWithdrawalsPart2(from, arrayLength, presentees, reasons, times);\n', '        return (ids, ats, amounts, investors, presentees, reasons, times);\n', '    }\n', '\n', '    function putWithdrawalsPart1(uint256 from, uint256 length, bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, address[] memory investors) internal view {\n', '        for (uint256 i = 0; i < length; i++) {\n', '            bytes32 id = operator.withdrawalIds(i + from);\n', '            uint256 at;\n', '            uint256 amount;\n', '            address investor;\n', '            (id, at, amount, investor, , , ) = getWithdrawalById(id);\n', '            ids[i] = id;\n', '            ats[i] = at;\n', '            amounts[i] = amount;\n', '            investors[i] = investor;\n', '        }\n', '    }\n', '    \n', '    function putWithdrawalsPart2(uint256 from, uint256 length, address[] memory presentees, uint256[] memory reasons, uint256[] memory times) internal view {\n', '        for (uint256 i = 0; i < length; i++) {\n', '            bytes32 id = operator.withdrawalIds(i + from);\n', '            uint256 reason;\n', '            uint256 time;\n', '            address presentee;\n', '            uint256 at;\n', '            (, at, , , presentee, reason, time) = getWithdrawalById(id);\n', '            reasons[i] = reason;\n', '            times[i] = time;\n', '            presentees[i] = presentee;\n', '        }\n', '    }\n', '\n', '    function getCurrentVote() public view returns(uint256 startTime, string memory reason, address payable emergencyAddress, uint256 yesPoint, uint256 noPoint, uint256 totalPoint) {\n', '        (startTime, reason, emergencyAddress, yesPoint, noPoint, totalPoint) = operator.currentVote();\n', '        return (startTime, reason, emergencyAddress, yesPoint, noPoint, totalPoint);\n', '    }\n', '    \n', '    function importMoreInvestors(address[] memory addresses, bool[] memory isDisableds, uint256[] memory numbers) public mustBeAdmin {\n', '        for (uint256 index = 0; index < isDisableds.length; index++) {\n', '            address[] memory adds = splitAddresses(addresses, index * 5, index * 5 + 4);\n', '            uint256[] memory nums = splitNumbers(numbers, index * 13, index * 13 + 12);\n', '            operator.importInvestor(adds, isDisableds[index], nums);\n', '        }\n', '    }\n', '\n', '    function importMoreInvestments(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, address[] memory investorAddresses) public mustBeAdmin {\n', '        for (uint256 index = 0; index < ids.length; index++) {\n', '            operator.importInvestments(ids[index], ats[index], amounts[index], investorAddresses[index]);\n', '        }\n', '    }\n', '\n', '    function importMoreWithdrawals(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, address[] memory investorAddresses, address[] memory presentees, uint256[] memory reasons, uint256[] memory times) public mustBeAdmin {\n', '        for (uint256 index = 0; index < ids.length; index++) {\n', '            operator.importWithdrawals(ids[index], ats[index], amounts[index], investorAddresses[index], presentees[index], reasons[index], times[index]);\n', '        }\n', '    }\n', '\n', '    function splitAddresses(address[] memory addresses, uint256 from, uint256 to) internal pure returns(address[] memory output) {\n', '        output = new address[](to - from + 1);\n', '        for (uint256 i = from; i <= to; i++) {\n', '            output[i - from] = addresses[i];\n', '        }\n', '        return output;\n', '    }\n', '\n', '    function splitNumbers(uint256[] memory numbers, uint256 from, uint256 to) internal pure returns(uint256[] memory output) {\n', '        output = new uint256[](to - from + 1);\n', '        for (uint256 i = from; i <= to; i++) {\n', '            output[i - from] = numbers[i];\n', '        }\n', '        return output;\n', '    }\n', '\n', '    function disableInvestors(address[] memory investorAddresses) public mustBeAdmin {\n', '        for (uint256 i = 0; i < investorAddresses.length; i++) {\n', '            operator.disableInvestor(investorAddresses[i]);\n', '        }\n', '    }\n', '}']