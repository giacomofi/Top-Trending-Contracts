['pragma solidity ^0.5.0;\n', '\n', 'interface ICustodian {\n', '\tfunction users(uint) external returns(address);\n', '\tfunction totalUsers() external returns (uint);\n', '\tfunction totalSupplyA() external returns (uint);\n', '\tfunction totalSupplyB() external returns (uint);\n', '\tfunction balanceOf(uint, address) external returns (uint);\n', '\tfunction allowance(uint, address, address) external returns (uint);\n', '\tfunction transfer(uint, address, address, uint) external returns (bool);\n', '\tfunction transferFrom(uint, address, address, address, uint) external returns (bool);\n', '\tfunction approve(uint, address, address, uint) external returns (bool);\n', '}\n', '\n', '/// @title Esplanade - coordinate multiple custodians, oracles and other contracts.\n', '/// @author duo.network\n', 'contract Esplanade {\n', '\n', '\t/*\n', '     * Constants\n', '     */\n', '\tuint constant WEI_DENOMINATOR = 1000000000000000000;\n', '\tuint constant BP_DENOMINATOR = 10000;\n', '\tuint constant MIN_POOL_SIZE = 5;\n', '\tuint constant VOTE_TIME_OUT = 2 hours;\n', '\tuint constant COLD_POOL_IDX = 0;\n', '\tuint constant HOT_POOL_IDX = 1;\n', '\tuint constant NEW_STATUS = 0;\n', '\tuint constant IN_COLD_POOL_STATUS = 1;\n', '\tuint constant IN_HOT_POOL_STATUS = 2;\n', '\tuint constant USED_STATUS = 3;\n', '\tenum VotingStage {\n', '        NotStarted,\n', '\t\tModerator,\n', '\t\tContract\n', '    }\n', '\t/*\n', '     * Storage\n', '     */\n', '\tVotingStage public votingStage;\n', '\taddress public moderator;\n', '\t// 0 is cold\n', '\t// 1 is hot\n', '\taddress [][] public addrPool =[   \n', '\t\t[\n', '\t\t\t0xAc31E7Bc5F730E460C6B2b50617F421050265ece,\n', '            0x39426997B2B5f0c8cad0C6e571a2c02A6510d67b,\n', '            0x292B0E0060adBa58cCA9148029a79D5496950c9D,\n', '            0x835B8D6b7b62240000491f7f0B319204BD5dDB25,\n', '            0x8E0E4DE505ee21ECA63fAF762B48D774E8BB8f51,\n', '            0x8750A35A4FB67EE5dE3c02ec35d5eA59193034f5,\n', '            0x8849eD77E94B075D89bB67D8ef98D80A8761d913,\n', '            0x2454Da2d95FBA41C3a901D8ce69D0fdC8dA8274e,\n', '            0x56F08EE15a4CBB8d35F82a44d288D08F8b924c8b\n', '\t\t],\n', '\t\t[\n', '            0x709494F5766a7e280A24cF15e7feBA9fbadBe7F5,\n', '            0xF7029296a1dA0388b0b637127F241DD11901f2af,\n', '            0xE266581CDe8468915D9c9F42Be3DcEd51db000E0,\n', '            0x37c521F852dbeFf9eC93991fFcE91b2b836Ad549,\n', '            0x2fEF2469937EeA7B126bC888D8e02d762D8c7e16,\n', '            0x249c1daD9c31475739fBF08C95C2DCB137135957,\n', '            0x8442Dda926BFb4Aeba526D4d1e8448c762cf4A0c,\n', '            0xe71DA90BC3cb2dBa52bacfBbA7b973260AAAFc05,\n', '            0xd3FA38302b0458Bf4E1405D209F30db891eBE038\n', '\t\t]\n', '\t];\n', '\t// 0 is new address\n', '\t// 1 in cold pool\n', '\t// 2 in hot pool\n', '\t// 3 is used\n', '\tmapping(address => uint) public addrStatus; \n', '\taddress[] public custodianPool;\n', '\tmapping(address => bool) public existingCustodians;\n', '\taddress[] public otherContractPool;\n', '\tmapping(address => bool) public existingOtherContracts;\n', '\tuint public operatorCoolDown = 1 hours;\n', '\tuint public lastOperationTime;\n', '\tbool public started;\n', '\n', '\taddress public candidate;\n', '\tmapping(address => bool) public passedContract;\n', '\tmapping(address => bool) public voted;\n', '\tuint public votedFor;\n', '\tuint public votedAgainst;\n', '\tuint public voteStartTimestamp;\n', '\n', '\t/*\n', '     *  Modifiers\n', '     */\n', '\tmodifier only(address addr) {\n', '\t\trequire(msg.sender == addr);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier inColdAddrPool() {\n', '\t\trequire(addrStatus[msg.sender] == IN_COLD_POOL_STATUS);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier inHotAddrPool() {\n', '\t\trequire(addrStatus[msg.sender] == IN_HOT_POOL_STATUS);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier isValidRequestor(address origin) {\n', '\t\taddress requestorAddr = msg.sender;\n', '\t\trequire((existingCustodians[requestorAddr] \n', '\t\t|| existingOtherContracts[requestorAddr]) \n', '\t\t&& addrStatus[origin] == IN_COLD_POOL_STATUS);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier inUpdateWindow() {\n', '\t\tuint currentTime = getNowTimestamp();\n', '\t\tif (started)\n', '\t\t\trequire(currentTime - lastOperationTime >= operatorCoolDown);\n', '\t\t_;\n', '\t\tlastOperationTime = currentTime;\n', '\t}\n', '\n', '\tmodifier inVotingStage(VotingStage _stage) {\n', '\t\trequire(votingStage == _stage);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier allowedToVote() {\n', '\t\taddress voterAddr = msg.sender;\n', '\t\trequire(!voted[voterAddr] && addrStatus[voterAddr] == 1);\n', '\t\t_;\n', '\t}\n', '\n', '\t/*\n', '     *  Events\n', '     */\n', '\tevent AddAddress(uint poolIndex, address added1, address added2);\n', '\tevent RemoveAddress(uint poolIndex, address addr);\n', '\tevent ProvideAddress(uint poolIndex, address requestor, address origin, address addr);\n', '\tevent AddCustodian(address newCustodianAddr);\n', '\tevent AddOtherContract(address newContractAddr);\n', '\tevent StartContractVoting(address proposer, address newContractAddr);\n', '\tevent TerminateContractVoting(address terminator, address currentCandidate);\n', '\tevent StartModeratorVoting(address proposer);\n', '\tevent TerminateByTimeOut(address candidate);\n', '\tevent Vote(address voter, address candidate, bool voteFor, uint votedFor, uint votedAgainst);\n', '\tevent CompleteVoting(bool isContractVoting, address newAddress);\n', '\tevent ReplaceModerator(address oldModerator, address newModerator);\n', '\n', '\t/*\n', '     * Constructor\n', '     */\n', '\t/// @dev Contract constructor sets operation cool down and set address pool status.\n', '\t/// @param optCoolDown operation cool down time.\n', '\tconstructor(uint optCoolDown) public \n', '\t{\t\n', '\t\tvotingStage = VotingStage.NotStarted;\n', '\t\tmoderator = msg.sender;\n', '\t\taddrStatus[moderator] = USED_STATUS;\n', '\t\tfor (uint i = 0; i < addrPool[COLD_POOL_IDX].length; i++) \n', '\t\t\taddrStatus[addrPool[COLD_POOL_IDX][i]] = IN_COLD_POOL_STATUS;\n', '\t\tfor (uint j = 0; j < addrPool[HOT_POOL_IDX].length; j++) \n', '\t\t\taddrStatus[addrPool[HOT_POOL_IDX][j]] = IN_HOT_POOL_STATUS;\n', '\t\toperatorCoolDown = optCoolDown;\n', '\t}\n', '\n', '\t/*\n', '     * MultiSig Management\n', '     */\n', '\t/// @dev proposeNewManagerContract function.\n', '\t/// @param addr new manager contract address proposed.\n', '\tfunction startContractVoting(address addr) \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinVotingStage(VotingStage.NotStarted) \n', '\treturns (bool) {\n', '\t\trequire(addrStatus[addr] == NEW_STATUS);\n', '\t\tcandidate = addr;\n', '\t\taddrStatus[addr] = USED_STATUS;\n', '\t\tvotingStage = VotingStage.Contract;\n', '\t\treplaceModerator();\n', '\t\tstartVoting();\n', '\t\temit StartContractVoting(moderator, addr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev terminateVoting function.\n', '\tfunction terminateContractVoting() \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinVotingStage(VotingStage.Contract) \n', '\treturns (bool) {\n', '\t\tvotingStage = VotingStage.NotStarted;\n', '\t\temit TerminateContractVoting(moderator, candidate);\n', '\t\treplaceModerator();\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev terminateVoting voting if timeout\n', '\tfunction terminateByTimeout() public returns (bool) {\n', '\t\trequire(votingStage != VotingStage.NotStarted);\n', '\t\tuint nowTimestamp = getNowTimestamp();\n', '\t\tif (nowTimestamp > voteStartTimestamp && nowTimestamp - voteStartTimestamp > VOTE_TIME_OUT) {\n', '\t\t\tvotingStage = VotingStage.NotStarted;\n', '\t\t\temit TerminateByTimeOut(candidate);\n', '\t\t\treturn true;\n', '\t\t} else\n', '\t\t\treturn false;\n', '\t}\n', '\n', '\t/// @dev proposeNewModerator function.\n', '\tfunction startModeratorVoting() public inColdAddrPool() returns (bool) {\n', '\t\tcandidate = msg.sender;\n', '\t\tvotingStage = VotingStage.Moderator;\n', '\t\tremoveFromPoolByAddr(COLD_POOL_IDX, candidate);\n', '\t\tstartVoting();\n', '\t\temit StartModeratorVoting(candidate);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev proposeNewModerator function.\n', '\tfunction vote(bool voteFor) \n', '\t\tpublic \n', '\t\tallowedToVote() \n', '\treturns (bool) {\n', '\t\taddress voter = msg.sender;\n', '\t\tif (voteFor)\n', '\t\t\tvotedFor = votedFor + 1;\n', '\t\telse\n', '\t\t\tvotedAgainst += 1;\n', '\t\tvoted[voter] = true;\n', '\t\tuint threshold = addrPool[COLD_POOL_IDX].length / 2;\n', '\t\temit Vote(voter, candidate, voteFor, votedFor, votedAgainst);\n', '\t\tif (votedFor > threshold || votedAgainst > threshold) {\n', '\t\t\tif (votingStage == VotingStage.Contract) {\n', '\t\t\t\tpassedContract[candidate] = true;\n', '\t\t\t\temit CompleteVoting(true, candidate);\n', '\t\t\t}\n', '\t\t\telse {\n', '\t\t\t\temit CompleteVoting(false, candidate);\n', '\t\t\t\tmoderator = candidate;\n', '\t\t\t}\n', '\t\t\tvotingStage = VotingStage.NotStarted;\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/*\n', '     * Moderator Public functions\n', '     */\n', '\t/// @dev start roleManagerContract.\n', '\tfunction startManager() public only(moderator) returns (bool) {\n', '\t\trequire(!started && custodianPool.length > 0);\n', '\t\tstarted = true;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev addCustodian function.\n', '\t/// @param custodianAddr custodian address to add.\n', '\tfunction addCustodian(address custodianAddr) \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinUpdateWindow() \n', '\treturns (bool success) {\n', '\t\trequire(!existingCustodians[custodianAddr] && !existingOtherContracts[custodianAddr]);\n', '\t\tICustodian custodian = ICustodian(custodianAddr);\n', '\t\trequire(custodian.totalUsers() >= 0);\n', '\t\t// custodian.users(0);\n', '\t\tuint custodianLength = custodianPool.length;\n', '\t\tif (custodianLength > 0) \n', '\t\t\treplaceModerator();\n', '\t\telse if (!started) {\n', '\t\t\tuint index = getNextAddrIndex(COLD_POOL_IDX, custodianAddr);\n', '\t\t\taddress oldModerator = moderator;\n', '\t\t\tmoderator = addrPool[COLD_POOL_IDX][index];\n', '\t\t\temit ReplaceModerator(oldModerator, moderator);\n', '\t\t\tremoveFromPool(COLD_POOL_IDX, index);\n', '\t\t}\n', '\t\texistingCustodians[custodianAddr] = true;\n', '\t\tcustodianPool.push(custodianAddr);\n', '\t\taddrStatus[custodianAddr] = USED_STATUS;\n', '\t\temit AddCustodian(custodianAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev addOtherContracts function.\n', '\t/// @param contractAddr other contract address to add.\n', '\tfunction addOtherContracts(address contractAddr) \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinUpdateWindow() \n', '\treturns (bool success) {\n', '\t\trequire(!existingCustodians[contractAddr] && !existingOtherContracts[contractAddr]);\t\t\n', '\t\texistingOtherContracts[contractAddr] = true;\n', '\t\totherContractPool.push(contractAddr);\n', '\t\taddrStatus[contractAddr] = USED_STATUS;\n', '\t\treplaceModerator();\n', '\t\temit AddOtherContract(contractAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev add two addreess into pool function.\n', '\t/// @param addr1 the first address\n', '\t/// @param addr2 the second address.\n', '\t/// @param poolIndex indicate adding to hot or cold.\n', '\tfunction addAddress(address addr1, address addr2, uint poolIndex) \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinUpdateWindow() \n', '\treturns (bool success) {\n', '\t\trequire(addrStatus[addr1] == NEW_STATUS \n', '\t\t\t&& addrStatus[addr2] == NEW_STATUS \n', '\t\t\t&& addr1 != addr2 \n', '\t\t\t&& poolIndex < 2);\n', '\t\treplaceModerator();\n', '\t\taddrPool[poolIndex].push(addr1);\n', '\t\taddrStatus[addr1] = poolIndex + 1;\n', '\t\taddrPool[poolIndex].push(addr2);\n', '\t\taddrStatus[addr2] = poolIndex + 1;\n', '\t\temit AddAddress(poolIndex, addr1, addr2);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev removeAddress function.\n', '\t/// @param addr the address to remove from\n', '\t/// @param poolIndex the pool to remove from.\n', '\tfunction removeAddress(address addr, uint poolIndex) \n', '\t\tpublic \n', '\t\tonly(moderator) \n', '\t\tinUpdateWindow() \n', '\treturns (bool success) {\n', '\t\trequire(addrPool[poolIndex].length > MIN_POOL_SIZE \n', '\t\t\t&& addrStatus[addr] == poolIndex + 1 \n', '\t\t\t&& poolIndex < 2);\n', '\t\tremoveFromPoolByAddr(poolIndex, addr);\n', '\t\treplaceModerator();\n', '\t\temit RemoveAddress(poolIndex, addr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/// @dev provide address to other contracts, such as custodian, oracle and others.\n', '\t/// @param origin the origin who makes request\n', '\t/// @param poolIndex the pool to request address from.\n', '\tfunction provideAddress(address origin, uint poolIndex) \n', '\t\tpublic \n', '\t\tisValidRequestor(origin) \n', '\t\tinUpdateWindow() \n', '\treturns (address) {\n', '\t\trequire(addrPool[poolIndex].length > MIN_POOL_SIZE \n', '\t\t\t&& poolIndex < 2 \n', '\t\t\t&& custodianPool.length > 0);\n', '\t\tremoveFromPoolByAddr(COLD_POOL_IDX, origin);\n', '\t\taddress requestor = msg.sender;\n', '\t\tuint index = 0;\n', '\t\t// is custodian\n', '\t\tif (existingCustodians[requestor])\n', '\t\t\tindex = getNextAddrIndex(poolIndex, requestor);\n', '\t\telse // is other contract;\n', '\t\t\tindex = getNextAddrIndex(poolIndex, custodianPool[custodianPool.length - 1]);\n', '\t\taddress addr = addrPool[poolIndex][index];\n', '\t\tremoveFromPool(poolIndex, index);\n', '\n', '\t\temit ProvideAddress(poolIndex, requestor, origin, addr);\n', '\t\treturn addr;\n', '\t}\n', '\n', '\t/*\n', '     * Internal functions\n', '     */\n', '\t \n', '\tfunction startVoting() internal {\n', '\t\taddress[] memory coldPool = addrPool[COLD_POOL_IDX];\n', '\t\tfor (uint i = 0; i < coldPool.length; i++) \n', '\t\t\tvoted[coldPool[i]] = false;\n', '\t\tvotedFor = 0;\n', '\t\tvotedAgainst = 0;\n', '\t\tvoteStartTimestamp = getNowTimestamp();\n', '\t}\n', '\t\n', '\tfunction replaceModerator() internal {\n', '\t\trequire(custodianPool.length > 0);\n', '\t\tuint index = getNextAddrIndex(COLD_POOL_IDX, custodianPool[custodianPool.length - 1]);\n', '\t\taddress oldModerator = moderator;\n', '\t\tmoderator = addrPool[COLD_POOL_IDX][index];\n', '\t\temit ReplaceModerator(oldModerator, moderator);\n', '\t\tremoveFromPool(COLD_POOL_IDX, index);\n', '\t}\n', '\n', '\t/// @dev removeFromPool Function.\n', '\t/// @param poolIndex the pool to request from removal.\n', '\t/// @param addr the address to remove\n', '\tfunction removeFromPoolByAddr(uint poolIndex, address addr) internal {\n', '\t \taddress[] memory subPool = addrPool[poolIndex];\n', '\t\tfor (uint i = 0; i < subPool.length; i++) {\n', '\t\t\tif (subPool[i] == addr) {\n', '\t\t\t\tremoveFromPool(poolIndex, i);\n', '\t\t\t\tbreak;\n', '            }\n', '\t\t}\n', '\t}\n', '\n', '\t/// @dev removeFromPool Function.\n', '\t/// @param poolIndex the pool to request from removal.\n', '\t/// @param idx the index of address to remove\n', '\tfunction removeFromPool(uint poolIndex, uint idx) internal {\n', '\t \taddress[] memory subPool = addrPool[poolIndex];\n', '\t\taddrStatus[subPool[idx]] = USED_STATUS;\n', '\t\tif (idx < subPool.length - 1)\n', '\t\t\taddrPool[poolIndex][idx] = addrPool[poolIndex][subPool.length-1];\n', '\t\tdelete addrPool[poolIndex][subPool.length - 1];\n', '\t\t// emit RemoveFromPool(poolIndex, addrPool[poolIndex][idx]);\n', '\t\taddrPool[poolIndex].length--;\n', '\t}\n', '\n', '\t/// @dev getNextAddrIndex Function.\n', '\t/// @param poolIndex the pool to request address from.\n', '\t/// @param custodianAddr the index of custodian contract address for randomeness generation\n', '\tfunction getNextAddrIndex(uint poolIndex, address custodianAddr) internal returns (uint) {\n', '\t\tuint prevHashNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n', '\t\tICustodian custodian = ICustodian(custodianAddr);\n', '\t\tuint userLength = custodian.totalUsers();\n', '\t\tif(userLength > 255) {\n', '\t\t\taddress randomUserAddress = custodian.users(prevHashNumber % userLength);\n', '\t\t\treturn uint256(keccak256(abi.encodePacked(randomUserAddress))) % addrPool[poolIndex].length;\n', '\t\t} else \n', '\t\t\treturn prevHashNumber % addrPool[poolIndex].length;\n', '\t}\n', '\n', '\t/// @dev get Ethereum blockchain current timestamp\n', '\tfunction getNowTimestamp() internal view returns (uint) {\n', '\t\treturn now;\n', '\t}\n', '\n', '\t/// @dev get addressPool size\n', '\tfunction getAddressPoolSizes() public view returns (uint, uint) {\n', '\t\treturn (addrPool[COLD_POOL_IDX].length, addrPool[HOT_POOL_IDX].length);\n', '\t}\n', '\n', '\t/// @dev get contract pool size\n', '\tfunction getContractPoolSizes() public view returns (uint, uint) {\n', '\t\treturn (custodianPool.length, otherContractPool.length);\n', '\t}\n', '}']