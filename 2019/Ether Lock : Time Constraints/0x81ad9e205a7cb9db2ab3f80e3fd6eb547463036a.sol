['pragma solidity ^0.4.24;\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = false;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '    \n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'interface EtheremonDataBase {\n', '    function getMonsterObj(uint64 _objId) constant external returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n', '}\n', '\n', 'interface EtheremonMonsterNFTInterface {\n', '    function burnMonster(uint64 _tokenId) external;\n', '}\n', '\n', 'interface EtheremonTradeInterface {\n', '    function isOnTrading(uint64 _objId) constant external returns(bool);\n', '}\n', '\n', 'contract EtheremonBurnReward is BasicAccessControl {\n', '    \n', '    struct MonsterObjAcc {\n', '        uint64 monsterId;\n', '        uint32 classId;\n', '        address trainer;\n', '        string name;\n', '        uint32 exp;\n', '        uint32 createIndex;\n', '        uint32 lastClaimIndex;\n', '        uint createTime;\n', '    }\n', '    \n', '    // address\n', '    mapping(uint => uint) public requests; // mapping burn_id => monster_id\n', '    address public tradeContract;\n', '    address public dataContract;\n', '    address public monsterNFTContract;\n', '    \n', '    function setContract(address _monsterNFTContract, address _dataContract, address _tradeContract) onlyModerators public {\n', '        monsterNFTContract = _monsterNFTContract;\n', '        dataContract = _dataContract;\n', '        tradeContract = _tradeContract;\n', '    }\n', '    \n', '    // public api\n', '    function burnForReward(uint64 _monsterId, uint _burnId) isActive external {\n', '        if (_burnId == 0 || _monsterId == 0 || requests[_burnId] > 0) revert();\n', '        \n', '        EtheremonDataBase data = EtheremonDataBase(dataContract);\n', '        MonsterObjAcc memory obj;\n', '        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\n', '        if (obj.trainer == address(0) || obj.trainer != msg.sender) revert();\n', '        \n', '        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n', '        if (trade.isOnTrading(_monsterId)) revert();\n', '        \n', '        EtheremonMonsterNFTInterface monsterNFT = EtheremonMonsterNFTInterface(monsterNFTContract);\n', '        monsterNFT.burnMonster(_monsterId);\n', '        \n', '        requests[_burnId] = _monsterId;\n', '    }\n', '    \n', '    function getBurnInfo(uint _burnId) constant external returns(uint) {\n', '        return requests[_burnId];\n', '    }\n', '}']