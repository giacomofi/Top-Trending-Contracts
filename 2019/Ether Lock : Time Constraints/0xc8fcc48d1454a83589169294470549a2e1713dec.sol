['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) view public returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) view public returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0x0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0x0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0x0);\n', '    }\n', '}\n', '\n', '\n', '/// @title Long-Team Holding Incentive Program\n', '/// @author Daniel Wang - <daniel@loopring.org>, Kongliang Zhong - <kongliang@loopring.org>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract NewLRCLongTermHoldingContract is Claimable {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '\n', '    // During the first 60 days of deployment, this contract opens for deposit of LRC.\n', '    uint public constant DEPOSIT_PERIOD             = 60 days; // = 2 months\n', '\n', '    // 18 months after deposit, user can withdrawal all or part of his/her LRC with bonus.\n', "    // The bonus is this contract's initial LRC balance.\n", '    uint public constant WITHDRAWAL_DELAY           = 540 days; // = 1 year and 6 months\n', '\n', '    // Send 0.001ETH per 10000 LRC partial withdrawal, or 0 for a once-for-all withdrawal.\n', '    // All ETH will be returned.\n', '    uint public constant WITHDRAWAL_SCALE           = 1E7; // 1ETH for withdrawal of 10,000,000 LRC.\n', '\n', '    // Ower can drain all remaining LRC after 3 years.\n', '    uint public constant DRAIN_DELAY                = 1080 days; // = 3 years.\n', '\n', '    address public lrcTokenAddress;\n', '\n', '    uint public lrcDeposited        = 0;\n', '    uint public depositStartTime    = 1504076273;\n', '    uint public depositStopTime     = 1509260273;\n', '\n', '    struct Record {\n', '        uint lrcAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) public records;\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted when all LRC are drained.\n', '    event Drained(uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _lrcAmount);\n', '\n', '    /// @dev Initialize the contract\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    constructor(address _lrcTokenAddress) public {\n', '        require(_lrcTokenAddress != address(0));\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /* /// @dev start the program. */\n', '    /* function start() public onlyOwner { */\n', '    /*     require(depositStartTime == 0); */\n', '\n', '    /*     depositStartTime = now; */\n', '    /*     depositStopTime  = depositStartTime + DEPOSIT_PERIOD; */\n', '\n', '    /*     Started(depositStartTime); */\n', '    /* } */\n', '\n', '\n', '    /// @dev drain LRC.\n', '    function drain() onlyOwner public {\n', '        require(depositStartTime > 0 && now >= depositStartTime + DRAIN_DELAY);\n', '\n', '        uint balance = lrcBalance();\n', '        require(balance > 0);\n', '\n', '        require(Token(lrcTokenAddress).transfer(owner, balance));\n', '\n', '        emit Drained(balance);\n', '    }\n', '\n', '    function () payable external {\n', '        require(depositStartTime > 0);\n', '\n', '        if (now >= depositStartTime && now <= depositStopTime) {\n', '            depositLRC();\n', '        } else if (now > depositStopTime){\n', '            withdrawLRC();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @return Current LRC balance.\n', '    function lrcBalance() public view returns (uint) {\n', '        return Token(lrcTokenAddress).balanceOf(address(this));\n', '    }\n', '\n', '    function batchAddDepositRecordsByOwner(address[] calldata users, uint[] calldata lrcAmounts, uint[] calldata timestamps) external onlyOwner {\n', '        require(users.length == lrcAmounts.length);\n', '        require(users.length == timestamps.length);\n', '        for (uint i = 0; i < users.length; i++) {\n', '            require(users[i] != address(0));\n', '            require(timestamps[i] >= depositStartTime && timestamps[i] <= depositStopTime);\n', '            Record memory record = Record(lrcAmounts[i], timestamps[i]);\n', '            records[users[i]] = record;\n', '\n', '            lrcDeposited += lrcAmounts[i];\n', '\n', '            emit Deposit(depositId++, users[i], lrcAmounts[i]);\n', '        }\n', '    }\n', '\n', '    /// @dev Deposit LRC.\n', '    function depositLRC() payable public {\n', '        require(depositStartTime > 0, "program not started");\n', '        require(msg.value == 0, "no ether should be sent");\n', '        require(now >= depositStartTime && now <= depositStopTime, "beyond deposit time period");\n', '\n', '        Token lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken\n', '            .balanceOf(msg.sender)\n', '            .min256(lrcToken.allowance(msg.sender, address(this)));\n', '\n', '        require(lrcAmount > 0, "lrc allowance is zero");\n', '\n', '        Record memory record = records[msg.sender];\n', '        record.lrcAmount += lrcAmount;\n', '        record.timestamp = now;\n', '        records[msg.sender] = record;\n', '\n', '        lrcDeposited += lrcAmount;\n', '\n', '        emit Deposit(depositId++, msg.sender, lrcAmount);\n', '\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount), "lrc transfer failed");\n', '    }\n', '\n', '    /// @dev Withdrawal LRC.\n', '    function withdrawLRC() payable public {\n', '        require(depositStartTime > 0);\n', '        require(lrcDeposited > 0);\n', '\n', '        Record memory record = records[msg.sender];\n', '        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n', '        require(record.lrcAmount > 0);\n', '\n', '        uint lrcWithdrawalBase = record.lrcAmount;\n', '        if (msg.value > 0) {\n', '            lrcWithdrawalBase = lrcWithdrawalBase\n', '                .min256(msg.value.mul(WITHDRAWAL_SCALE));\n', '        }\n', '\n', '        uint lrcBonus = getBonus(lrcWithdrawalBase);\n', '        uint balance = lrcBalance();\n', '        uint lrcAmount = balance.min256(lrcWithdrawalBase + lrcBonus);\n', '\n', '        lrcDeposited -= lrcWithdrawalBase;\n', '        record.lrcAmount -= lrcWithdrawalBase;\n', '\n', '        if (record.lrcAmount == 0) {\n', '            delete records[msg.sender];\n', '        } else {\n', '            records[msg.sender] = record;\n', '        }\n', '\n', '        emit Withdrawal(withdrawId++, msg.sender, lrcAmount);\n', '\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '        if (msg.value > 0) {\n', '            msg.sender.transfer(msg.value);\n', '        }\n', '    }\n', '\n', '    function getBonus(uint _lrcWithdrawalBase) view public returns (uint) {\n', '        return internalCalculateBonus(lrcBalance() - lrcDeposited,lrcDeposited, _lrcWithdrawalBase);\n', '    }\n', '\n', '    function internalCalculateBonus(uint _totalBonusRemaining, uint _lrcDeposited, uint _lrcWithdrawalBase) internal pure returns (uint) {\n', '        require(_lrcDeposited > 0);\n', '        require(_totalBonusRemaining >= 0);\n', '\n', '        // The bonus is non-linear function to incentivize later withdrawal.\n', '        // bonus = _totalBonusRemaining * power(_lrcWithdrawalBase/_lrcDeposited, 1.0625)\n', '        return _totalBonusRemaining\n', '            .mul(_lrcWithdrawalBase.mul(sqrt(sqrt(sqrt(sqrt(_lrcWithdrawalBase))))))\n', '            .div(_lrcDeposited.mul(sqrt(sqrt(sqrt(sqrt(_lrcDeposited))))));\n', '    }\n', '\n', '    function sqrt(uint x) internal pure returns (uint) {\n', '        uint y = x;\n', '        while (true) {\n', '            uint z = (y + (x / y)) / 2;\n', '            uint w = (z + (x / z)) / 2;\n', '            if (w == y) {\n', '                if (w < y) return w;\n', '                else return y;\n', '            }\n', '            y = w;\n', '        }\n', '    }\n', '}']