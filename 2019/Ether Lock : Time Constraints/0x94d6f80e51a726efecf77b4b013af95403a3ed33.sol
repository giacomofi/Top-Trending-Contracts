['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract AltcoinToken {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract NafCoin is ERC20, Owned {\n', '    \n', '    using SafeMath for uint256;\n', '    address owner = msg.sender;\n', '\t\t\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;    \n', '\n', '    string public constant name = "NafCoin";\n', '    string public constant symbol = "NFC";\n', '    uint public constant decimals = 18;\n', '    \n', '    uint256 public totalSupply =  1000000000000000000000000000;\n', '    uint256 public totalDistributed = 0; \n', '    uint256 public totalIcoDistributed = 0;\n', '    uint256 public constant minContribution = 1 ether / 100; // 0.01 Eth\n', '\t\n', '\t\n', '\tuint256 public tokensPerEth = 0;\n', '\t\n', '\t// ------------------------------\n', '    // Token Distribution and Address\n', '    // ------------------------------\n', '    \n', '   // saleable 90%\n', '    uint256 public constant totalIco = 900000000000000000000000000;\n', '    uint256 public totalIcoDist = 0;\n', '    address storageIco = owner;\n', '    \n', '    // airdrop 5%\n', '    uint256 public constant totalAirdrop = 50000000000000000000000000;\n', '    address private storageAirdrop = 0x57D2EE2E359c08DfFeD715A0bd305FE513657822;\n', '    \n', '    // developer 5%\n', '    uint256 public constant totalDeveloper = 50000000000000000000000000;\n', '    address private storageDeveloper = 0xdcc89F6793285C2cAcFb558B5bE840ec8149F47D;\n', '    \n', '    // ---------------------\n', '    // sale start  price and bonus\n', '    // ---------------------\n', '    \n', '    // presale\n', '\tuint public presaleStartTime = 1544979600; // Monday, 17 December 2018 00:00:00 GMT+07:00\n', '    uint256 public presalePerEth = 1366000000000000000000;\n', '    \n', '    // ico\n', '    uint public icoStartTime = 1546189200; // Tuesday, 15 January 2019 00:00:00 GMT+07:00\n', '    uint256 public icoPerEth = 1366000000000000000000;\n', '    \n', '    // ico1\n', '    uint public ico1StartTime = 1547398800; // Wednesday, 30 January 2019 00:00:00 GMT+07:00\n', '    uint256 public ico1PerEth = 1366000000000000000000;\n', '    \n', '    \n', '    // ico2\n', '    uint public ico2StartTime = 1548608400; // Wednesday, 13 February 2019 00:00:00 GMT+07:00\n', '    uint256 public ico2PerEth = 1366000000000000000000;\n', '    \n', '    \n', '    //ico start and end\n', '    uint public icoOpenTime = presaleStartTime;\n', '    uint public icoEndTime = 1549818000; // Thursday, 28 February 2019 00:00:00 GMT+07:00\n', '    \n', '\t// -----------------------\n', '\t// events\n', '\t// -----------------------\n', '\t\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    event Distr(address indexed to, uint256 amount);\n', '    event DistrFinished();\n', '\n', '    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n', '\n', '    event TokensPerEthUpdated(uint _tokensPerEth);\n', '    \n', '    event Burn(address indexed burner, uint256 value);\n', '\t\n', '\tevent Sent(address from, address to, uint amount);\n', '\t\n', '\t\n', '\t// -------------------\n', '\t// STATE\n', '\t// ---------------------\n', '    bool public icoOpen = false; \n', '    bool public icoFinished = false;\n', '    bool public distributionFinished = false;\n', '    \n', '    \n', '    // -----\n', '    // temp\n', '    // -----\n', '    uint256 public tTokenPerEth = 0;\n', '    uint256 public tAmount = 0;\n', '    uint i = 0;\n', '    bool private tIcoOpen = false;\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {        \n', '        balances[owner] = totalIco;\n', '        balances[storageAirdrop] = totalAirdrop;\n', '        balances[storageDeveloper] = totalDeveloper;       \n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    modifier canDistr() {\n', '        require(!distributionFinished);\n', '        _;\n', '    }\n', '\t\n', '\tfunction startDistribution() onlyOwner canDistr public returns (bool) {\n', '        icoOpen = true;\n', '        presaleStartTime = now;\n', '        icoOpenTime = now;\n', '        return true;\n', '    }\n', '    \n', '    function finishDistribution() onlyOwner canDistr public returns (bool) {\n', '        distributionFinished = true;\n', '        icoFinished = true;\n', '        emit DistrFinished();\n', '        return true;\n', '    }\n', '    \n', '    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n', '        totalDistributed = totalDistributed.add(_amount);        \n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\t\n', '\tfunction send(address receiver, uint amount) public {\n', '        if (balances[msg.sender] < amount) return;\n', '        balances[msg.sender] -= amount;\n', '        balances[receiver] += amount;\n', '        emit Sent(msg.sender, receiver, amount);\n', '    }\n', '    \n', '   \n', '    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n', '        tokensPerEth = _tokensPerEth;\n', '        emit TokensPerEthUpdated(_tokensPerEth);\n', '    }\n', '           \n', '    function () external payable {\n', '\t\t\t\t\n', '\t\t//owner withdraw \n', '\t\tif (msg.sender == owner && msg.value == 0){\n', '\t\t\twithdraw();\n', '\t\t}\n', '\t\t\n', '\t\tif(msg.sender != owner){\n', '\t\t\tif ( now < icoOpenTime ){\n', '\t\t\t\trevert(&#39;ICO does not open yet&#39;);\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t//is Open\n', '\t\t\tif ( ( now >= icoOpenTime ) && ( now <= icoEndTime ) ){\n', '\t\t\t\ticoOpen = true;\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( now > icoEndTime ){\n', '\t\t\t\ticoOpen = false;\n', '\t\t\t\ticoFinished = true;\n', '\t\t\t\tdistributionFinished = true;\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( icoFinished == true ){\n', '\t\t\t\trevert(&#39;ICO has finished&#39;);\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( distributionFinished == true ){\n', '\t\t\t\trevert(&#39;Token distribution has finished&#39;);\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( icoOpen == true ){\n', '\t\t\t\tif ( now >= presaleStartTime && now < icoStartTime){ tTokenPerEth = presalePerEth; }\n', '\t\t\t\tif ( now >= icoStartTime && now < ico1StartTime){ tTokenPerEth = icoPerEth; }\n', '\t\t\t\tif ( now >= ico1StartTime && now < ico2StartTime){ tTokenPerEth = ico1PerEth; }\n', '\t\t\t\tif ( now >= ico2StartTime && now < icoEndTime){ tTokenPerEth = ico2PerEth; }\n', '\t\t\t\t\n', '\t\t\t\ttokensPerEth = tTokenPerEth;\t\t\t\t\n', '\t\t\t\tgetTokens();\n', '\t\t\t\t\n', '\t\t\t}\n', '\t\t}\n', '     }\n', '    \n', '    function getTokens() payable canDistr  public {\n', '        uint256 tokens = 0;\n', '\n', '        require( msg.value >= minContribution );\n', '\n', '        require( msg.value > 0 );\n', '        \n', '        tokens = tokensPerEth.mul(msg.value) / 1 ether;\n', '        address investor = msg.sender;\n', '        \n', '        \n', '        if ( icoFinished == true ){\n', '\t\t\trevert(&#39;ICO Has Finished&#39;);\n', '\t\t}\n', '        \n', '        if( balances[owner] < tokens ){\n', '\t\t\trevert(&#39;Insufficient Token Balance or Sold Out.&#39;);\n', '\t\t}\n', '        \n', '        if (tokens < 0){\n', '\t\t\trevert();\n', '\t\t}\n', '        \n', '        totalIcoDistributed += tokens;\n', '        \n', '        if (tokens > 0) {\n', '           distr(investor, tokens);           \n', '        }\n', '\n', '        if (totalIcoDistributed >= totalIco) {\n', '            distributionFinished = true;\n', '        }\n', '    }\n', '\t\n', '\t\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // mitigates the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '\n', '        require(_to != address(0));\n', '        require(_amount <= balances[msg.sender]);\n', '        \n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '\n', '        require(_to != address(0));\n', '        require(_amount <= balances[_from]);\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        // mitigates the ERC20 spend/approval race condition\n', '        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) constant public returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n', '        AltcoinToken t = AltcoinToken(tokenAddress);\n', '        uint bal = t.balanceOf(who);\n', '        return bal;\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        address myAddress = this;\n', '        uint256 etherBalance = myAddress.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    \n', '    function burn(uint256 _amount) onlyOwner public {\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        totalDistributed = totalDistributed.sub(_amount);\n', '        emit Burn(owner, _amount);\n', '    }\n', '    \n', '  \n', '    \n', '    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n', '        AltcoinToken token = AltcoinToken(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(owner, amount);\n', '    }\n', '    \n', '    function dist_privateSale(address _to, uint256 _amount) onlyOwner public {\n', '\t\t\n', '\t\trequire(_amount <= balances[owner]);\n', '\t\trequire(_amount > 0);\n', '\t\t\n', '\t\ttotalDistributed = totalDistributed.add(_amount);        \n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        tAmount = 0;\n', '\t}\n', '\t\n', '\tfunction dist_airdrop(address _to, uint256 _amount) onlyOwner public {\t\t\n', '\t\trequire(_amount <= balances[storageAirdrop]);\n', '\t\trequire(_amount > 0);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[storageAirdrop] = balances[storageAirdrop].sub(_amount);\n', '        emit Airdrop(_to, _amount, balances[_to]);\n', '        emit Transfer(address(0), _to, _amount);\n', '\t}\n', '\t\n', '\tfunction dist_multiple_airdrop(address[] _participants, uint256 _amount) onlyOwner public {\n', '\t\ttAmount = 0;\n', '\t\t\n', '\t\tfor ( i = 0; i < _participants.length; i++){\n', '\t\t\ttAmount = tAmount.add(_amount);\n', '\t\t}\n', '\t\t\n', '\t\trequire(tAmount <= balances[storageAirdrop]);\n', '\t\t\n', '\t\tfor ( i = 0; i < _participants.length; i++){\n', '\t\t\tdist_airdrop(_participants[i], _amount);\n', '\t\t}\n', '\t\t\n', '\t\ttAmount = 0;\n', '\t}    \n', '    \n', '    function dist_developer(address _to, uint256 _amount) onlyOwner public {\n', '\t\trequire(_amount <= balances[storageDeveloper]);\n', '\t\trequire(_amount > 0);\n', '\t\tbalances[_to] = balances[_to].add(_amount);\n', '        balances[storageDeveloper] = balances[storageDeveloper].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        tAmount = 0;\n', '\t}\n', '\t\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    \n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract AltcoinToken {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract NafCoin is ERC20, Owned {\n', '    \n', '    using SafeMath for uint256;\n', '    address owner = msg.sender;\n', '\t\t\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;    \n', '\n', '    string public constant name = "NafCoin";\n', '    string public constant symbol = "NFC";\n', '    uint public constant decimals = 18;\n', '    \n', '    uint256 public totalSupply =  1000000000000000000000000000;\n', '    uint256 public totalDistributed = 0; \n', '    uint256 public totalIcoDistributed = 0;\n', '    uint256 public constant minContribution = 1 ether / 100; // 0.01 Eth\n', '\t\n', '\t\n', '\tuint256 public tokensPerEth = 0;\n', '\t\n', '\t// ------------------------------\n', '    // Token Distribution and Address\n', '    // ------------------------------\n', '    \n', '   // saleable 90%\n', '    uint256 public constant totalIco = 900000000000000000000000000;\n', '    uint256 public totalIcoDist = 0;\n', '    address storageIco = owner;\n', '    \n', '    // airdrop 5%\n', '    uint256 public constant totalAirdrop = 50000000000000000000000000;\n', '    address private storageAirdrop = 0x57D2EE2E359c08DfFeD715A0bd305FE513657822;\n', '    \n', '    // developer 5%\n', '    uint256 public constant totalDeveloper = 50000000000000000000000000;\n', '    address private storageDeveloper = 0xdcc89F6793285C2cAcFb558B5bE840ec8149F47D;\n', '    \n', '    // ---------------------\n', '    // sale start  price and bonus\n', '    // ---------------------\n', '    \n', '    // presale\n', '\tuint public presaleStartTime = 1544979600; // Monday, 17 December 2018 00:00:00 GMT+07:00\n', '    uint256 public presalePerEth = 1366000000000000000000;\n', '    \n', '    // ico\n', '    uint public icoStartTime = 1546189200; // Tuesday, 15 January 2019 00:00:00 GMT+07:00\n', '    uint256 public icoPerEth = 1366000000000000000000;\n', '    \n', '    // ico1\n', '    uint public ico1StartTime = 1547398800; // Wednesday, 30 January 2019 00:00:00 GMT+07:00\n', '    uint256 public ico1PerEth = 1366000000000000000000;\n', '    \n', '    \n', '    // ico2\n', '    uint public ico2StartTime = 1548608400; // Wednesday, 13 February 2019 00:00:00 GMT+07:00\n', '    uint256 public ico2PerEth = 1366000000000000000000;\n', '    \n', '    \n', '    //ico start and end\n', '    uint public icoOpenTime = presaleStartTime;\n', '    uint public icoEndTime = 1549818000; // Thursday, 28 February 2019 00:00:00 GMT+07:00\n', '    \n', '\t// -----------------------\n', '\t// events\n', '\t// -----------------------\n', '\t\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    event Distr(address indexed to, uint256 amount);\n', '    event DistrFinished();\n', '\n', '    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n', '\n', '    event TokensPerEthUpdated(uint _tokensPerEth);\n', '    \n', '    event Burn(address indexed burner, uint256 value);\n', '\t\n', '\tevent Sent(address from, address to, uint amount);\n', '\t\n', '\t\n', '\t// -------------------\n', '\t// STATE\n', '\t// ---------------------\n', '    bool public icoOpen = false; \n', '    bool public icoFinished = false;\n', '    bool public distributionFinished = false;\n', '    \n', '    \n', '    // -----\n', '    // temp\n', '    // -----\n', '    uint256 public tTokenPerEth = 0;\n', '    uint256 public tAmount = 0;\n', '    uint i = 0;\n', '    bool private tIcoOpen = false;\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {        \n', '        balances[owner] = totalIco;\n', '        balances[storageAirdrop] = totalAirdrop;\n', '        balances[storageDeveloper] = totalDeveloper;       \n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    modifier canDistr() {\n', '        require(!distributionFinished);\n', '        _;\n', '    }\n', '\t\n', '\tfunction startDistribution() onlyOwner canDistr public returns (bool) {\n', '        icoOpen = true;\n', '        presaleStartTime = now;\n', '        icoOpenTime = now;\n', '        return true;\n', '    }\n', '    \n', '    function finishDistribution() onlyOwner canDistr public returns (bool) {\n', '        distributionFinished = true;\n', '        icoFinished = true;\n', '        emit DistrFinished();\n', '        return true;\n', '    }\n', '    \n', '    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n', '        totalDistributed = totalDistributed.add(_amount);        \n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\t\n', '\tfunction send(address receiver, uint amount) public {\n', '        if (balances[msg.sender] < amount) return;\n', '        balances[msg.sender] -= amount;\n', '        balances[receiver] += amount;\n', '        emit Sent(msg.sender, receiver, amount);\n', '    }\n', '    \n', '   \n', '    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n', '        tokensPerEth = _tokensPerEth;\n', '        emit TokensPerEthUpdated(_tokensPerEth);\n', '    }\n', '           \n', '    function () external payable {\n', '\t\t\t\t\n', '\t\t//owner withdraw \n', '\t\tif (msg.sender == owner && msg.value == 0){\n', '\t\t\twithdraw();\n', '\t\t}\n', '\t\t\n', '\t\tif(msg.sender != owner){\n', '\t\t\tif ( now < icoOpenTime ){\n', "\t\t\t\trevert('ICO does not open yet');\n", '\t\t\t}\n', '\t\t\t\n', '\t\t\t//is Open\n', '\t\t\tif ( ( now >= icoOpenTime ) && ( now <= icoEndTime ) ){\n', '\t\t\t\ticoOpen = true;\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( now > icoEndTime ){\n', '\t\t\t\ticoOpen = false;\n', '\t\t\t\ticoFinished = true;\n', '\t\t\t\tdistributionFinished = true;\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( icoFinished == true ){\n', "\t\t\t\trevert('ICO has finished');\n", '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( distributionFinished == true ){\n', "\t\t\t\trevert('Token distribution has finished');\n", '\t\t\t}\n', '\t\t\t\n', '\t\t\tif ( icoOpen == true ){\n', '\t\t\t\tif ( now >= presaleStartTime && now < icoStartTime){ tTokenPerEth = presalePerEth; }\n', '\t\t\t\tif ( now >= icoStartTime && now < ico1StartTime){ tTokenPerEth = icoPerEth; }\n', '\t\t\t\tif ( now >= ico1StartTime && now < ico2StartTime){ tTokenPerEth = ico1PerEth; }\n', '\t\t\t\tif ( now >= ico2StartTime && now < icoEndTime){ tTokenPerEth = ico2PerEth; }\n', '\t\t\t\t\n', '\t\t\t\ttokensPerEth = tTokenPerEth;\t\t\t\t\n', '\t\t\t\tgetTokens();\n', '\t\t\t\t\n', '\t\t\t}\n', '\t\t}\n', '     }\n', '    \n', '    function getTokens() payable canDistr  public {\n', '        uint256 tokens = 0;\n', '\n', '        require( msg.value >= minContribution );\n', '\n', '        require( msg.value > 0 );\n', '        \n', '        tokens = tokensPerEth.mul(msg.value) / 1 ether;\n', '        address investor = msg.sender;\n', '        \n', '        \n', '        if ( icoFinished == true ){\n', "\t\t\trevert('ICO Has Finished');\n", '\t\t}\n', '        \n', '        if( balances[owner] < tokens ){\n', "\t\t\trevert('Insufficient Token Balance or Sold Out.');\n", '\t\t}\n', '        \n', '        if (tokens < 0){\n', '\t\t\trevert();\n', '\t\t}\n', '        \n', '        totalIcoDistributed += tokens;\n', '        \n', '        if (tokens > 0) {\n', '           distr(investor, tokens);           \n', '        }\n', '\n', '        if (totalIcoDistributed >= totalIco) {\n', '            distributionFinished = true;\n', '        }\n', '    }\n', '\t\n', '\t\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // mitigates the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '\n', '        require(_to != address(0));\n', '        require(_amount <= balances[msg.sender]);\n', '        \n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '\n', '        require(_to != address(0));\n', '        require(_amount <= balances[_from]);\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        // mitigates the ERC20 spend/approval race condition\n', '        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) constant public returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n', '        AltcoinToken t = AltcoinToken(tokenAddress);\n', '        uint bal = t.balanceOf(who);\n', '        return bal;\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        address myAddress = this;\n', '        uint256 etherBalance = myAddress.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    \n', '    function burn(uint256 _amount) onlyOwner public {\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        totalDistributed = totalDistributed.sub(_amount);\n', '        emit Burn(owner, _amount);\n', '    }\n', '    \n', '  \n', '    \n', '    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n', '        AltcoinToken token = AltcoinToken(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(owner, amount);\n', '    }\n', '    \n', '    function dist_privateSale(address _to, uint256 _amount) onlyOwner public {\n', '\t\t\n', '\t\trequire(_amount <= balances[owner]);\n', '\t\trequire(_amount > 0);\n', '\t\t\n', '\t\ttotalDistributed = totalDistributed.add(_amount);        \n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[owner] = balances[owner].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        tAmount = 0;\n', '\t}\n', '\t\n', '\tfunction dist_airdrop(address _to, uint256 _amount) onlyOwner public {\t\t\n', '\t\trequire(_amount <= balances[storageAirdrop]);\n', '\t\trequire(_amount > 0);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[storageAirdrop] = balances[storageAirdrop].sub(_amount);\n', '        emit Airdrop(_to, _amount, balances[_to]);\n', '        emit Transfer(address(0), _to, _amount);\n', '\t}\n', '\t\n', '\tfunction dist_multiple_airdrop(address[] _participants, uint256 _amount) onlyOwner public {\n', '\t\ttAmount = 0;\n', '\t\t\n', '\t\tfor ( i = 0; i < _participants.length; i++){\n', '\t\t\ttAmount = tAmount.add(_amount);\n', '\t\t}\n', '\t\t\n', '\t\trequire(tAmount <= balances[storageAirdrop]);\n', '\t\t\n', '\t\tfor ( i = 0; i < _participants.length; i++){\n', '\t\t\tdist_airdrop(_participants[i], _amount);\n', '\t\t}\n', '\t\t\n', '\t\ttAmount = 0;\n', '\t}    \n', '    \n', '    function dist_developer(address _to, uint256 _amount) onlyOwner public {\n', '\t\trequire(_amount <= balances[storageDeveloper]);\n', '\t\trequire(_amount > 0);\n', '\t\tbalances[_to] = balances[_to].add(_amount);\n', '        balances[storageDeveloper] = balances[storageDeveloper].sub(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        tAmount = 0;\n', '\t}\n', '\t\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    \n', '}']
