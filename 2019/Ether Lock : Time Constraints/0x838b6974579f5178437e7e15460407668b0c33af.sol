['pragma solidity >0.4.99 <0.6.0;\n', '\n', '\n', 'library Zero {\n', '    function requireNotZero(address addr) internal pure {\n', '        require(addr != address(0), "require not zero address");\n', '    }\n', '\n', '    function requireNotZero(uint val) internal pure {\n', '        require(val != 0, "require not zero value");\n', '    }\n', '\n', '    function notZero(address addr) internal pure returns(bool) {\n', '        return !(addr == address(0));\n', '    }\n', '\n', '    function isZero(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '\n', '    function isZero(uint a) internal pure returns(bool) {\n', '        return a == 0;\n', '    }\n', '\n', '    function notZero(uint a) internal pure returns(bool) {\n', '        return a != 0;\n', '    }\n', '}\n', '\n', '\n', 'library Percent {\n', '    struct percent {\n', '        uint num;\n', '        uint den;\n', '    }\n', '\n', '    function mul(percent storage p, uint a) internal view returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a*p.num/p.den;\n', '    }\n', '\n', '    function div(percent storage p, uint a) internal view returns (uint) {\n', '        return a/p.num*p.den;\n', '    }\n', '\n', '    function sub(percent storage p, uint a) internal view returns (uint) {\n', '        uint b = mul(p, a);\n', '        if (b >= a) {\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '\n', '    function add(percent storage p, uint a) internal view returns (uint) {\n', '        return a + mul(p, a);\n', '    }\n', '\n', '    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '        return Percent.percent(p.num, p.den);\n', '    }\n', '\n', '    function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        return a*p.num/p.den;\n', '    }\n', '\n', '    function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '        return a/p.num*p.den;\n', '    }\n', '\n', '    function msub(percent memory p, uint a) internal pure returns (uint) {\n', '        uint b = mmul(p, a);\n', '        if (b >= a) {\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '\n', '    function madd(percent memory p, uint a) internal pure returns (uint) {\n', '        return a + mmul(p, a);\n', '    }\n', '}\n', '\n', '\n', 'library Address {\n', '    function toAddress(bytes memory source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '\n', '    function isNotContract(address addr) internal view returns(bool) {\n', '        uint length;\n', '        assembly { length := extcodesize(addr) }\n', '        return length == 0;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '    address private owner;\n', '    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "access denied");\n', '        _;\n', '    }\n', '\t\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        emit OwnerChanged(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract InvestorsStorage is Accessibility {\n', '    using SafeMath for uint;\n', '\n', '    struct Investor {\n', '        uint paymentTime;\n', '        uint fundDepositType_1;\n', '        uint fundDepositType_2;\n', '        uint fundDepositType_3;\n', '        uint referrerBonus;\n', '        uint numberReferral;\n', '    }\n', '    uint public size;\n', '\n', '    mapping (address => Investor) private investors;\n', '\n', '    function isInvestor(address addr) public view returns (bool) {\n', '        uint fundDeposit = investors[addr].fundDepositType_1.add(investors[addr].fundDepositType_2).add(investors[addr].fundDepositType_3);\n', '        return fundDeposit > 0;\n', '    }\n', '\n', '    function investorInfo(address addr) public view returns(uint paymentTime,\n', '        uint fundDepositType_1, uint fundDepositType_2, uint fundDepositType_3,\n', '        uint referrerBonus, uint numberReferral) {\n', '        paymentTime = investors[addr].paymentTime;\n', '        fundDepositType_1 = investors[addr].fundDepositType_1;\n', '        fundDepositType_2 = investors[addr].fundDepositType_2;\n', '        fundDepositType_3 = investors[addr].fundDepositType_3;\n', '        referrerBonus = investors[addr].referrerBonus;\n', '        numberReferral = investors[addr].numberReferral;\n', '    }\n', '\n', '    function newInvestor(address addr, uint investment, uint paymentTime, uint typeDeposit) public onlyOwner returns (bool) {\n', '        Investor storage inv = investors[addr];\n', '        uint fundDeposit = inv.fundDepositType_1.add(inv.fundDepositType_2).add(inv.fundDepositType_3);\n', '        if (fundDeposit != 0 || investment == 0) {\n', '            return false;\n', '        }\n', '        if (typeDeposit < 0 || typeDeposit > 2) {\n', '            return false;\n', '        }\n', '\n', '        if (typeDeposit == 0) {\n', '            inv.fundDepositType_1 = investment;\n', '        } else if (typeDeposit == 1) {\n', '            inv.fundDepositType_2 = investment;\n', '        } else if (typeDeposit == 2) {\n', '            inv.fundDepositType_3 = investment;\n', '        }\n', '\n', '        inv.paymentTime = paymentTime;\n', '        size++;\n', '        return true;\n', '    }\n', '\n', '    function checkSetZeroFund(address addr, uint currentTime) public onlyOwner {\n', '        uint numberDays = currentTime.sub(investors[addr].paymentTime) / 1 days;\n', '\n', '        if (investors[addr].fundDepositType_1 > 0 && numberDays > 30) {\n', '            investors[addr].fundDepositType_1 = 0;\n', '        }\n', '        if (investors[addr].fundDepositType_2 > 0 && numberDays > 90) {\n', '            investors[addr].fundDepositType_2 = 0;\n', '        }\n', '        if (investors[addr].fundDepositType_3 > 0 && numberDays > 180) {\n', '            investors[addr].fundDepositType_3 = 0;\n', '        }\n', '    }\n', '\n', '    function addInvestment(address addr, uint investment, uint typeDeposit) public onlyOwner returns (bool) {\n', '        if (typeDeposit == 0) {\n', '            investors[addr].fundDepositType_1 = investors[addr].fundDepositType_1.add(investment);\n', '        } else if (typeDeposit == 1) {\n', '            investors[addr].fundDepositType_2 = investors[addr].fundDepositType_2.add(investment);\n', '        } else if (typeDeposit == 2) {\n', '            investors[addr].fundDepositType_3 = investors[addr].fundDepositType_3.add(investment);\n', '        } else if (typeDeposit == 10) {\n', '            investors[addr].referrerBonus = investors[addr].referrerBonus.add(investment);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function addReferral(address addr) public onlyOwner {\n', '        investors[addr].numberReferral++;\n', '    }\n', '\n', '    function getCountReferral(address addr) public view onlyOwner returns (uint) {\n', '        return investors[addr].numberReferral;\n', '    }\n', '\n', '    function getReferrerBonus(address addr) public onlyOwner returns (uint) {\n', '        uint referrerBonus = investors[addr].referrerBonus;\n', '        investors[addr].referrerBonus = 0;\n', '        return referrerBonus;\n', '    }\n', '\n', '    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '        uint fundDeposit = investors[addr].fundDepositType_1.add(investors[addr].fundDepositType_2).add(investors[addr].fundDepositType_3);\n', '        if (fundDeposit == 0) {\n', '            return false;\n', '        }\n', '        investors[addr].paymentTime = paymentTime;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Ethbank is Accessibility {\n', '    using Percent for Percent.percent;\n', '    using SafeMath for uint;\n', '\n', '    // easy read for investors\n', '    using Address for *;\n', '    using Zero for *;\n', '\n', '    bool public isDemo;\n', '\tuint public simulateDate;\n', '\n', '    mapping(address => bool) private m_referrals;\n', '    InvestorsStorage private m_investors;\n', '\n', '    // automatically generates getters\n', '    uint public constant minInvesment = 10 finney;\n', '    address payable public advertisingAddress;\n', '    uint public investmentsNumber;\n', '    uint public totalEthRaised;\n', '\n', '\n', '    // percents tariff\n', '    Percent.percent private m_1_percent = Percent.percent(1,100);            // 1/100 *100% = 1%\n', '    Percent.percent private m_2_percent = Percent.percent(2,100);            // 2/100 *100% = 2%\n', '    Percent.percent private m_3_percent = Percent.percent(3,100);            // 3/100 *100% = 3%\n', '\n', '    // percents referal\n', '    Percent.percent private m_3_referal_percent = Percent.percent(3,100);        // 3/100 *100% = 3%\n', '    Percent.percent private m_3_referrer_percent = Percent.percent(3,100);       // 3/100 *100% = 3%\n', '\n', '    Percent.percent private m_5_referal_percent = Percent.percent(5,100);        // 5/100 *100% = 5%\n', '    Percent.percent private m_4_referrer_percent = Percent.percent(4,100);       // 4/100 *100% = 4%\n', '\n', '    Percent.percent private m_10_referal_percent = Percent.percent(10,100);      // 10/100 *100% = 10%\n', '    Percent.percent private m_5_referrer_percent = Percent.percent(5,100);       // 5/100 *100% = 5%\n', '\n', '    // percents advertising\n', '    Percent.percent private m_advertisingPercent = Percent.percent(10, 100);      // 10/100  *100% = 10%\n', '\n', '    // more events for easy read from blockchain\n', '    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint referralBonus);\n', '    event LogNewInvesment(address indexed addr, uint when, uint investment, uint typeDeposit);\n', '    event LogAutomaticReinvest(address indexed addr, uint when, uint investment, uint typeDeposit);\n', '    event LogPayDividends(address indexed addr, uint when, uint dividends);\n', '    event LogPayReferrerBonus(address indexed addr, uint when, uint referrerBonus);\n', '    event LogNewInvestor(address indexed addr, uint when, uint typeDeposit);\n', '    event LogBalanceChanged(uint when, uint balance);\n', '    event ChangeTime(uint256 _newDate, uint256 simulateDate);\n', '\n', '    modifier balanceChanged {\n', '        _;\n', '        emit LogBalanceChanged(getCurrentDate(), address(this).balance);\n', '    }\n', '\n', '    modifier notFromContract() {\n', '        require(msg.sender.isNotContract(), "only externally accounts");\n', '        _;\n', '    }\n', '\n', '    constructor(address payable _advertisingAddress) public {\n', '        advertisingAddress = _advertisingAddress;\n', '        m_investors = new InvestorsStorage();\n', '        investmentsNumber = 0;\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value.isZero()) {\n', '            getMyDividends();\n', '            return;\n', '        } else {\n', '\t\t\tdoInvest(msg.data.toAddress(), 0);\n', '\t\t}\n', '    }\n', '\n', '    function setAdvertisingAddress(address payable addr) public onlyOwner {\n', '        addr.requireNotZero();\n', '        advertisingAddress = addr;\n', '    }\n', '\n', '    function investorsNumber() public view returns(uint) {\n', '        return m_investors.size();\n', '    }\n', '\n', '    function balanceETH() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function advertisingPercent() public view returns(uint numerator, uint denominator) {\n', '        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\n', '    }\n', '\n', '    function investorInfo(address investorAddr) public view returns(uint paymentTime, bool isReferral,\n', '                        uint fundDepositType_1, uint fundDepositType_2, uint fundDepositType_3,\n', '                        uint referrerBonus, uint numberReferral) {\n', '        (paymentTime, fundDepositType_1, fundDepositType_2, fundDepositType_3, referrerBonus, numberReferral) = m_investors.investorInfo(investorAddr);\n', '        isReferral = m_referrals[investorAddr];\n', '    }\n', '\n', '    function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\n', '        dividends = calcDividends(investorAddr);\n', '    }\n', '\n', '    function doInvest(address referrerAddr, uint typeDeposit) public payable notFromContract balanceChanged {\n', '        uint investment = msg.value;\n', '        require(investment >= minInvesment, "investment must be >= minInvesment");\n', '        require(typeDeposit >= 0 && typeDeposit < 3, "wrong deposit type");\n', '\n', '        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\n', '\n', '        if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\n', '        referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\n', '\n', '            m_referrals[msg.sender] = true;\n', '            m_investors.addReferral(referrerAddr);\n', '            uint countReferral = m_investors.getCountReferral(referrerAddr);\n', '            uint referrerBonus = 0;\n', '            uint referralBonus = 0;\n', '\n', '            if (countReferral <= 9) {\n', '                referrerBonus = m_3_referrer_percent.mmul(investment);\n', '                referralBonus = m_3_referal_percent.mmul(investment);\n', '            }\n', '            if (countReferral > 9 && countReferral <= 29) {\n', '                referrerBonus = m_4_referrer_percent.mmul(investment);\n', '                referralBonus = m_5_referal_percent.mmul(investment);\n', '            }\n', '            if (countReferral > 29) {\n', '                referrerBonus = m_5_referrer_percent.mmul(investment);\n', '                referralBonus = m_10_referal_percent.mmul(investment);\n', '            }\n', '\n', '            assert(m_investors.addInvestment(referrerAddr, referrerBonus, 10)); // add referrer bonus\n', '            assert(m_investors.addInvestment(msg.sender, referralBonus, 10)); // add referral bonus\n', '            emit LogNewReferral(msg.sender, referrerAddr, getCurrentDate(), referralBonus);\n', '        } else {\n', '            // commission\n', '            advertisingAddress.transfer(m_advertisingPercent.mul(investment));\n', '        }\n', '\n', '        // automatic reinvest - prevent burning dividends\n', '        uint dividends = calcDividends(msg.sender);\n', '        if (senderIsInvestor && dividends.notZero()) {\n', '            investment = investment.add(dividends);\n', '            emit LogAutomaticReinvest(msg.sender, getCurrentDate(), dividends, typeDeposit);\n', '        }\n', '\n', '        if (senderIsInvestor) {\n', '            // update existing investor\n', '            assert(m_investors.addInvestment(msg.sender, investment, typeDeposit));\n', '            assert(m_investors.setPaymentTime(msg.sender, getCurrentDate()));\n', '        } else {\n', '            // create new investor\n', '            assert(m_investors.newInvestor(msg.sender, investment, getCurrentDate(), typeDeposit));\n', '            emit LogNewInvestor(msg.sender, getCurrentDate(), typeDeposit);\n', '        }\n', '\n', '        investmentsNumber++;\n', '        totalEthRaised = totalEthRaised.add(msg.value);\n', '        emit LogNewInvesment(msg.sender, getCurrentDate(), investment, typeDeposit);\n', '    }\n', '\n', '    function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\n', '        (uint paymentTime,\n', '        uint fundDepositType_1, uint fundDepositType_2,\n', '        uint fundDepositType_3, uint referrerBonus, uint numberReferral) = m_investors.investorInfo(investorAddr);\n', '        return InvestorsStorage.Investor(paymentTime, fundDepositType_1, fundDepositType_2, fundDepositType_3, referrerBonus, numberReferral);\n', '    }\n', '\n', '    function getMyDividends() public payable notFromContract balanceChanged {\n', '        address payable investor = msg.sender;\n', '        require(investor.notZero(), "require not zero address");\n', '        uint currentTime = getCurrentDate();\n', '\n', '        uint receivedEther = msg.value;\n', '        require(receivedEther.isZero(), "amount ETH must be 0");\n', '\n', '        //check if 1 day passed after last payment\n', '        require(currentTime.sub(getMemInvestor(investor).paymentTime) > 24 hours, "must pass 24 hours after the investment");\n', '\n', '        // calculate dividends\n', '        uint dividends = calcDividends(msg.sender);\n', '        require (dividends.notZero(), "cannot to pay zero dividends");\n', '\n', '        m_investors.checkSetZeroFund(investor, currentTime);\n', '\n', '        // update investor payment timestamp\n', '        assert(m_investors.setPaymentTime(investor, currentTime));\n', '\n', '        // transfer dividends to investor\n', '        investor.transfer(dividends);\n', '        emit LogPayDividends(investor, currentTime, dividends);\n', '    }\n', '\n', '    function getMyReferrerBonus() public notFromContract balanceChanged {\n', '        uint referrerBonus = m_investors.getReferrerBonus(msg.sender);\n', '        require (referrerBonus.notZero(), "cannot to pay zero referrer bonus");\n', '\n', '        // transfer referrer bonus to investor\n', '        msg.sender.transfer(referrerBonus);\n', '        emit LogPayReferrerBonus(msg.sender, getCurrentDate(), referrerBonus);\n', '    }\n', '\n', '    function calcDividends(address investorAddress) internal view returns(uint dividends) {\n', '        InvestorsStorage.Investor memory inv = getMemInvestor(investorAddress);\n', '        dividends = 0;\n', '        uint fundDeposit = inv.fundDepositType_1.add(inv.fundDepositType_2).add(inv.fundDepositType_3);\n', '        uint numberDays = getCurrentDate().sub(inv.paymentTime) / 1 days;\n', '\n', '        // safe gas if dividends will be 0\n', '        if (fundDeposit.isZero() || numberDays.isZero()) {\n', '            return 0;\n', '        }\n', '\n', '        if (inv.fundDepositType_1 > 0) {\n', '            if (numberDays > 30) {\n', '                dividends = 30 * m_1_percent.mmul(inv.fundDepositType_1);\n', '                dividends = dividends.add(inv.fundDepositType_1);\n', '            } else {\n', '                dividends = numberDays * m_1_percent.mmul(inv.fundDepositType_1);\n', '            }\n', '        }\n', '        if (inv.fundDepositType_2 > 0) {\n', '            if (numberDays > 90) {\n', '                dividends = dividends.add(90 * m_2_percent.mmul(inv.fundDepositType_2));\n', '                dividends = dividends.add(inv.fundDepositType_2);\n', '            } else {\n', '                dividends = dividends.add(numberDays * m_2_percent.mmul(inv.fundDepositType_2));\n', '            }\n', '        }\n', '        if (inv.fundDepositType_3 > 0) {\n', '            if (numberDays > 180) {\n', '                dividends = dividends.add(180 * m_3_percent.mmul(inv.fundDepositType_3));\n', '                dividends = dividends.add(inv.fundDepositType_3);\n', '            } else {\n', '                dividends = dividends.add(numberDays * m_3_percent.mmul(inv.fundDepositType_3));\n', '            }\n', '        }\n', '    }\n', '\n', '    function getCurrentDate() public view returns (uint) {\n', '        if (isDemo) {\n', '            return simulateDate;\n', '        }\n', '        return now;\n', '    }\n', '\t\n', '    function setSimulateDate(uint256 _newDate) public onlyOwner {\n', '        if (isDemo) {\n', '            require(_newDate > simulateDate);\n', '            emit ChangeTime(_newDate, simulateDate);\n', '            simulateDate = _newDate;\n', '        } \n', '    }\n', '\n', '    function setDemo() public onlyOwner {\n', '        if (investorsNumber() == 0) {\n', '            isDemo = true;\n', '        }\n', '    }\n', '\n', '\n', '}']