['pragma solidity ^0.4.24;\n', '\n', 'interface IDRCWalletMgrParams {\n', '    function singleWithdrawMin() external returns (uint256); // min value of single withdraw\n', '    function singleWithdrawMax() external returns (uint256); // Max value of single withdraw\n', '    function dayWithdraw() external returns (uint256); // Max value of one day of withdraw\n', '    function monthWithdraw() external returns (uint256); // Max value of one month of withdraw\n', '    function dayWithdrawCount() external returns (uint256); // Max number of withdraw counting\n', '\n', '    function chargeFee() external returns (uint256); // the charge fee for withdraw\n', '    function chargeFeePool() external returns (address); // the address that will get the returned charge fees.\n', '}\n', '\n', 'interface IDRCWalletStorage {\n', '    // get the deposit address for this _wallet address\n', '    function walletDeposits(address _wallet) external view returns (address);\n', '\n', '    // get frozen status for the deposit address\n', '    function frozenDeposits(address _deposit) external view returns (bool);\n', '\n', '    // get a wallet address by the deposit address and the index\n', '    function wallet(address _deposit, uint256 _ind) external view returns (address);\n', '\n', '    // get a wallet name by the deposit address and the index\n', '    function walletName(address _deposit, uint256 _ind) external view returns (bytes32);\n', '\n', '    // get the wallets number of a deposit address\n', '    function walletsNumber(address _deposit) external view returns (uint256);\n', '\n', '    // get the frozen amount of the deposit address\n', '    function frozenAmount(address _deposit) external view returns (uint256);\n', '\n', '    // get the balance of the deposit address\n', '    function balanceOf(address _deposit) external view returns (uint256);\n', '\n', '    // get the deposit address by index\n', '    function depositAddressByIndex(uint256 _ind) external view returns (address);\n', '\n', '    // get the frozen amount of the deposit address\n', '    function size() external view returns (uint256);\n', '\n', '    // judge if the _deposit address exsisted.\n', '    function isExisted(address _deposit) external view returns (bool);\n', '\n', '    // add one deposit address for that wallet\n', '    function addDeposit(address _wallet, address _depositAddr) external returns (bool);\n', '\n', '    // change the default wallet address for the deposit address\n', '    function changeDefaultWallet(address _oldWallet, address _newWallet) external returns (bool);\n', '\n', '    // freeze or release the tokens that has been deposited in the deposit address.\n', '    function freezeTokens(address _deposit, bool _freeze, uint256 _value) external returns (bool);\n', '\n', '    // increase balance of this deposit address\n', '    function increaseBalance(address _deposit, uint256 _value) external returns (bool);\n', '\n', '    // decrease balance of this deposit address\n', '    function decreaseBalance(address _deposit, uint256 _value) external returns (bool);\n', '\n', '    // add withdraw address for one deposit addresss\n', '    function addWithdraw(address _deposit, bytes32 _name, address _withdraw) external returns (bool);\n', '\n', '    // change the withdraw wallet name\n', '    function changeWalletName(address _deposit, bytes32 _newName, address _wallet) external returns (bool);\n', '\n', '    // remove deposit contract address from storage\n', '    function removeDeposit(address _depositAddr) external returns (bool);\n', '\n', '    // withdraw tokens from this contract\n', '    function withdrawToken(address _token, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '    event ReceiveEther(address _from, uint256 _value);\n', '    event WithdrawEther(address _to, uint256 _value);\n', '    event WithdrawToken(address _token, address _to, uint256 _value);\n', '\n', '    /**\n', '         * @dev recording receiving ether from msn.sender\n', '         */\n', '    function () payable public {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw,send ether to target\n', '         * @param _to is where the ether will be sent to\n', '         *        _amount is the number of the ether\n', '         */\n', '    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        _to.transfer(_amount);\n', '        emit WithdrawEther(_to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '         * @param _to is where the tokens will be sent to\n', '         *        _value is the number of the token\n', '         */\n', '    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        tk.transfer(_to, _value);\n', '        emit WithdrawToken(_token, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, and then gain the tokens,\n', '     *      then take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n', '    //     require(_token != address(0));\n', '    //     require(_from != address(0));\n', '\n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.transferFrom(_from, this, _value));\n', '\n', '    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    // }\n', '}\n', '\n', 'contract TokenDestructible is Ownable {\n', '\n', '  constructor() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @param _tokens List of addresses of ERC20 or ERC20Basic token contracts to\n', '   refund.\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy(address[] _tokens) public onlyOwner {\n', '\n', '    // Transfer tokens to owner\n', '    for (uint256 i = 0; i < _tokens.length; i++) {\n', '      ERC20Basic token = ERC20Basic(_tokens[i]);\n', '      uint256 balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '    }\n', '\n', '    // Transfer Eth to owner and terminate contract\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract DepositWithdraw is Claimable, Withdrawable, TokenDestructible {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * transaction record\n', '     */\n', '    struct TransferRecord {\n', '        uint256 timeStamp;\n', '        address account;\n', '        uint256 value;\n', '    }\n', '\n', '    /**\n', '     * accumulated transferring amount record\n', '     */\n', '    struct accumulatedRecord {\n', '        uint256 mul;\n', '        uint256 count;\n', '        uint256 value;\n', '    }\n', '\n', '    TransferRecord[] deposRecs; // record all the deposit tx data\n', '    TransferRecord[] withdrRecs; // record all the withdraw tx data\n', '\n', '    accumulatedRecord dayWithdrawRec; // accumulated amount record for one day\n', '    accumulatedRecord monthWithdrawRec; // accumulated amount record for one month\n', '\n', '    address wallet; // the binded withdraw address\n', '\n', '    event ReceiveDeposit(address _from, uint256 _value, address _token, bytes _extraData);\n', '\n', '    /**\n', '     * @dev constructor of the DepositWithdraw contract\n', '     * @param _wallet the binded wallet address to this depositwithdraw contract\n', '     */\n', '    constructor(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '         * @dev set the default wallet address\n', '         * @param _wallet the default wallet address binded to this deposit contract\n', '         */\n', '    function setWithdrawWallet(address _wallet) onlyOwner public returns (bool) {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev util function to change bytes data to bytes32 data\n', '         * @param _data the bytes data to be converted\n', '         */\n', '    function bytesToBytes32(bytes _data) public pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(_data, 32))\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev receive approval from an ERC20 token contract, take a record\n', '     *\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _value uint256 the amounts of tokens to be sent\n', '     * @param _token address the ERC20 token address\n', '     * @param _extraData bytes the extra data for the record\n', '     */\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) onlyOwner public {\n', '        require(_token != address(0));\n', '        require(_from != address(0));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        require(tk.transferFrom(_from, this, _value));\n', '        bytes32 timestamp = bytesToBytes32(_extraData);\n', '        deposRecs.push(TransferRecord(uint256(timestamp), _from, _value));\n', '        emit ReceiveDeposit(_from, _value, _token, _extraData);\n', '    }\n', '\n', '    // function authorize(address _token, address _spender, uint256 _value) onlyOwner public returns (bool) {\n', '    //     ERC20 tk = ERC20(_token);\n', '    //     require(tk.approve(_spender, _value));\n', '\n', '    //     return true;\n', '    // }\n', '\n', '    /**\n', '     * @dev record withdraw into this contract\n', '     *\n', '     * @param _time the timstamp of the withdraw time\n', '     * @param _to is where the tokens will be sent to\n', '     * @param _value is the number of the token\n', '     */\n', '    function recordWithdraw(uint256 _time, address _to, uint256 _value) onlyOwner public {\n', '        withdrRecs.push(TransferRecord(_time, _to, _value));\n', '    }\n', '\n', '    /**\n', '     * @dev check if withdraw amount is not valid\n', '     *\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _value is the number of the token\n', '     * @param _time the timstamp of the withdraw time\n', '     */\n', '    function checkWithdrawAmount(address _params, uint256 _value, uint256 _time) public returns (bool) {\n', '        IDRCWalletMgrParams params = IDRCWalletMgrParams(_params);\n', '        require(_value <= params.singleWithdrawMax());\n', '        require(_value >= params.singleWithdrawMin());\n', '\n', '        uint256 daysCount = _time.div(86400); // one day of seconds\n', '        if (daysCount <= dayWithdrawRec.mul) {\n', '            dayWithdrawRec.count = dayWithdrawRec.count.add(1);\n', '            dayWithdrawRec.value = dayWithdrawRec.value.add(_value);\n', '            require(dayWithdrawRec.count <= params.dayWithdrawCount());\n', '            require(dayWithdrawRec.value <= params.dayWithdraw());\n', '        } else {\n', '            dayWithdrawRec.mul = daysCount;\n', '            dayWithdrawRec.count = 1;\n', '            dayWithdrawRec.value = _value;\n', '        }\n', '\n', '        uint256 monthsCount = _time.div(86400 * 30);\n', '        if (monthsCount <= monthWithdrawRec.mul) {\n', '            monthWithdrawRec.count = monthWithdrawRec.count.add(1);\n', '            monthWithdrawRec.value = monthWithdrawRec.value.add(_value);\n', '            require(monthWithdrawRec.value <= params.monthWithdraw());\n', '        } else {\n', '            monthWithdrawRec.mul = monthsCount;\n', '            monthWithdrawRec.count = 1;\n', '            monthWithdrawRec.value = _value;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timstamp of the withdraw time\n', '         * @param _to is where the tokens will be sent to\n', '         *        _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        _tokenReturn is the address that return back the tokens of the _fee\n', '         */\n', '    function withdrawToken(address _token, address _params, uint256 _time, address _to, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        require(_to != address(0));\n', '        require(_token != address(0));\n', '        require(_value > _fee);\n', '        // require(_tokenReturn != address(0));\n', '\n', '        require(checkWithdrawAmount(_params, _value, _time));\n', '\n', '        ERC20 tk = ERC20(_token);\n', '        uint256 realAmount = _value.sub(_fee);\n', '        require(tk.transfer(_to, realAmount));\n', '        if (_tokenReturn != address(0) && _fee > 0) {\n', '            require(tk.transfer(_tokenReturn, _fee));\n', '        }\n', '\n', '        recordWithdraw(_time, _to, realAmount);\n', '        emit WithdrawToken(_token, _to, realAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target default wallet\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _params the limitation parameters for withdraw\n', '     * @param _time the timestamp occur the withdraw record\n', '         * @param _value is the number of the token\n', '     *        _fee is the amount of the transferring costs\n', '     *        â€”tokenReturn is the address that return back the tokens of the _fee\n', '         */\n', '    function withdrawTokenToDefault(address _token, address _params, uint256 _time, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\n', '        return withdrawToken(_token, _params, _time, wallet, _value, _fee, _tokenReturn);\n', '    }\n', '\n', '    /**\n', '         * @dev get the Deposit records number\n', '     *\n', '     */\n', '    function getDepositNum() public view returns (uint256) {\n', '        return deposRecs.length;\n', '    }\n', '\n', '    /**\n', '         * @dev get the one of the Deposit records\n', '     *\n', '     * @param _ind the deposit record index\n', '     */\n', '    function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < deposRecs.length);\n', '\n', '        return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value);\n', '    }\n', '\n', '    /**\n', '         * @dev get the withdraw records number\n', '     *\n', '     */\n', '    function getWithdrawNum() public view returns (uint256) {\n', '        return withdrRecs.length;\n', '    }\n', '\n', '    /**\n', '         * @dev get the one of the withdraw records\n', '     *\n', '     * @param _ind the withdraw record index\n', '     */\n', '    function getOneWithdrawRec(uint256 _ind) public view returns (uint256, address, uint256) {\n', '        require(_ind < withdrRecs.length);\n', '\n', '        return (withdrRecs[_ind].timeStamp, withdrRecs[_ind].account, withdrRecs[_ind].value);\n', '    }\n', '}\n', '\n', 'contract DelayedClaimable is Claimable {\n', '\n', '  uint256 public end;\n', '  uint256 public start;\n', '\n', '  /**\n', '   * @dev Used to specify the time period during which a pending\n', '   * owner can claim ownership.\n', '   * @param _start The earliest time ownership can be claimed.\n', '   * @param _end The latest time ownership can be claimed.\n', '   */\n', '  function setLimits(uint256 _start, uint256 _end) public onlyOwner {\n', '    require(_start <= _end);\n', '    end = _end;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\n', '   * the specified start and end time.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    require((block.number <= end) && (block.number >= start));\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '    end = 0;\n', '  }\n', '\n', '}\n', '\n', 'contract OwnerContract is DelayedClaimable {\n', '    Claimable public ownedContract;\n', '    address public pendingOwnedOwner;\n', '    // address internal origOwner;\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        // origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        if (ownedContract.owner() != address(this)) {\n', '            ownedContract.claimOwnership();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one.\n', '     *\n', '     */\n', '    // function transferOwnershipBack() onlyOwner public {\n', '    //     ownedContract.transferOwnership(origOwner);\n', '    //     ownedContract = Claimable(address(0));\n', '    //     origOwner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnershipto(address _nextOwner)  onlyOwner public {\n', '        require(ownedContract != address(0));\n', '\n', '        if (ownedContract.owner() != pendingOwnedOwner) {\n', '            ownedContract.transferOwnership(_nextOwner);\n', '            pendingOwnedOwner = _nextOwner;\n', '            // ownedContract = Claimable(address(0));\n', '            // origOwner = address(0);\n', '        } else {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev to confirm the owner of the owned contract has already been transferred.\n', '     *\n', '     */\n', '    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\n', '        require(ownedContract != address(0));\n', '        if (ownedContract.owner() == pendingOwnedOwner) {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', 'contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * withdraw wallet description\n', '     */\n', '    // struct WithdrawWallet {\n', '    //     bytes32 name;\n', '    //     address walletAddr;\n', '    // }\n', '\n', '    /**\n', '     * Deposit data storage\n', '     */\n', '    // struct DepositRepository {\n', '    //     // uint256 balance;\n', '    //     uint256 frozen;\n', '    //     WithdrawWallet[] withdrawWallets;\n', '    //     // mapping (bytes32 => address) withdrawWallets;\n', '    // }\n', '\n', '    // mapping (address => DepositRepository) depositRepos;\n', '    // mapping (address => address) public walletDeposits;\n', '    // mapping (address => bool) public frozenDeposits;\n', '\n', '    ERC20 public tk; // the token will be managed\n', '    IDRCWalletMgrParams public params; // the parameters that the management needs\n', '    IDRCWalletStorage public walletStorage; // the deposits and wallets data stored in a contract\n', '\n', '    event CreateDepositAddress(address indexed _wallet, address _deposit);\n', '    event FrozenTokens(address indexed _deposit, bool _freeze, uint256 _value);\n', '    event ChangeDefaultWallet(address indexed _oldWallet, address _newWallet);\n', '\n', '    /**\n', '         * @dev initialize this contract with token, parameters and storage address\n', '     *\n', '     * @param _token the token address that will be withdraw\n', '     * @param _walletParams the wallet management parameters\n', '         */\n', '    function initialize(address _token, address _walletParams, address _walletStorage) onlyOwner public returns (bool) {\n', '        require(_token != address(0));\n', '        require(_walletParams != address(0));\n', '\n', '        tk = ERC20(_token);\n', '        params = IDRCWalletMgrParams(_walletParams);\n', '        walletStorage = IDRCWalletStorage(_walletStorage);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev create deposit contract address for the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '         */\n', '    function createDepositContract(address _wallet) onlyOwner public returns (address) {\n', '        require(_wallet != address(0));\n', '\n', '        DepositWithdraw deposWithdr = new DepositWithdraw(_wallet); // new contract for deposit\n', '        address _deposit = address(deposWithdr);\n', '        // walletDeposits[_wallet] = _deposit;\n', '        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        // withdrawWalletList.push(WithdrawWallet("default wallet", _wallet));\n', '        // // depositRepos[_deposit].balance = 0;\n', '        // depositRepos[_deposit].frozen = 0;\n', '\n', '        walletStorage.addDeposit(_wallet, _deposit);\n', '\n', '        // deposWithdr.authorize(address(tk), this, 1e27); // give authorization to owner contract\n', '\n', '        emit CreateDepositAddress(_wallet, _deposit);\n', '        return _deposit;\n', '    }\n', '\n', '    /**\n', '         * @dev deposit a value of funds to the deposit address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _increase increase or decrease the value\n', '     * @param _value the deposit funds value\n', '         */\n', '    function doDeposit(address _deposit, bool _increase, uint256 _value) onlyOwner public returns (bool) {\n', '        return (_increase\n', '                ? walletStorage.increaseBalance(_deposit, _value)\n', '                : walletStorage.decreaseBalance(_deposit, _value));\n', '    }\n', '\n', '    /**\n', '         * @dev get deposit contract address by using the default withdraw wallet\n', '     *\n', '     * @param _wallet the binded default withdraw wallet address\n', '         */\n', '    function getDepositAddress(address _wallet) onlyOwner public view returns (address) {\n', '        require(_wallet != address(0));\n', '        // address deposit = walletDeposits[_wallet];\n', '\n', '        // return deposit;\n', '        return walletStorage.walletDeposits(_wallet);\n', '    }\n', '\n', '    /**\n', '         * @dev get deposit balance and frozen amount by using the deposit address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '         */\n', '    function getDepositInfo(address _deposit) onlyOwner public view returns (uint256, uint256) {\n', '        require(_deposit != address(0));\n', '        uint256 _balance = walletStorage.balanceOf(_deposit);\n', '        // uint256 frozenAmount = depositRepos[_deposit].frozen;\n', '        uint256 frozenAmount = walletStorage.frozenAmount(_deposit);\n', '        // depositRepos[_deposit].balance = _balance;\n', '\n', '        return (_balance, frozenAmount);\n', '    }\n', '\n', '    /**\n', '         * @dev get the number of withdraw wallet addresses bindig to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '         */\n', '    function getDepositWithdrawCount(address _deposit) onlyOwner public view returns (uint) {\n', '        require(_deposit != address(0));\n', '\n', '        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        // uint len = withdrawWalletList.length;\n', '        uint len = walletStorage.walletsNumber(_deposit);\n', '\n', '        return len;\n', '    }\n', '\n', '    /**\n', '         * @dev get the withdraw wallet addresses list binding to the deposit contract address\n', '     *\n', '     * @param _deposit the deposit contract address\n', '     * @param _indices the array of indices of the withdraw wallets\n', '         */\n', '    function getDepositWithdrawList(address _deposit, uint[] _indices) onlyOwner public view returns (bytes32[], address[]) {\n', '        require(_indices.length != 0);\n', '\n', '        bytes32[] memory names = new bytes32[](_indices.length);\n', '        address[] memory wallets = new address[](_indices.length);\n', '\n', '        for (uint i = 0; i < _indices.length; i = i.add(1)) {\n', '            // WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[_indices[i]];\n', '            // names[i] = wallet.name;\n', '            // wallets[i] = wallet.walletAddr;\n', '            names[i] = walletStorage.walletName(_deposit, i);\n', '            wallets[i] = walletStorage.wallet(_deposit, i);\n', '        }\n', '\n', '        return (names, wallets);\n', '    }\n', '\n', '    /**\n', '         * @dev change the default withdraw wallet address binding to the deposit contract address\n', '     *\n', '     * @param _oldWallet the previous default withdraw wallet\n', '     * @param _newWallet the new default withdraw wallet\n', '         */\n', '    function changeDefaultWithdraw(address _oldWallet, address _newWallet) onlyOwner public returns (bool) {\n', '        require(_oldWallet != address(0));\n', '        require(_newWallet != address(0));\n', '\n', '        address deposit = walletStorage.walletDeposits(_oldWallet);\n', '        DepositWithdraw deposWithdr = DepositWithdraw(deposit);\n', '        require(deposWithdr.setWithdrawWallet(_newWallet));\n', '\n', '        // WithdrawWallet[] storage withdrawWalletList = depositRepos[deposit].withdrawWallets;\n', '        // withdrawWalletList[0].walletAddr = _newWallet;\n', '        bool res = walletStorage.changeDefaultWallet(_oldWallet, _newWallet);\n', '        emit ChangeDefaultWallet(_oldWallet, _newWallet);\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '         * @dev freeze the tokens in the deposit address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _freeze to freeze or release\n', '     * @param _value the amount of tokens need to be frozen\n', '         */\n', '    function freezeTokens(address _deposit, bool _freeze, uint256 _value) onlyOwner public returns (bool) {\n', '        // require(_deposit != address(0));\n', '\n', '        // frozenDeposits[_deposit] = _freeze;\n', '        // if (_freeze) {\n', '        //     depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.add(_value);\n', '        // } else {\n', '        //     require(_value <= depositRepos[_deposit].frozen);\n', '        //     depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.sub(_value);\n', '        // }\n', '\n', '        bool res = walletStorage.freezeTokens(_deposit, _freeze, _value);\n', '\n', '        emit FrozenTokens(_deposit, _freeze, _value);\n', '        return res;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw the tokens from the deposit address to default wallet with charge fee\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _time the timestamp the withdraw occurs\n', '     * @param _value the amount of tokens need to be frozen\n', '     * @param _check if we will check the value is valid or meet the limit condition\n', '         */\n', '    function withdrawWithFee(address _deposit, uint256 _time, uint256 _value, bool _check) onlyOwner public returns (bool) {\n', '        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        // return withdrawWithFee(_deposit, _time, withdrawWalletList[0].name, withdrawWalletList[0].walletAddr, _value, _check);\n', '        bytes32 defaultWalletName = walletStorage.walletName(_deposit, 0);\n', '        address defaultWallet = walletStorage.wallet(_deposit, 0);\n', '        return withdrawWithFee(_deposit, _time, defaultWalletName, defaultWallet, _value, _check);\n', '    }\n', '\n', '    /**\n', '         * @dev check if the wallet name is not matching the expected wallet address\n', '     *\n', '     * @param _deposit the deposit address\n', '     * @param _name the withdraw wallet name\n', '     * @param _to the withdraw wallet address\n', '         */\n', '    function checkWithdrawAddress(address _deposit, bytes32 _name, address _to) public view returns (bool, bool) {\n', '        // uint len = depositRepos[_deposit].withdrawWallets.length;\n', '        uint len = walletStorage.walletsNumber(_deposit);\n', '        for (uint i = 0; i < len; i = i.add(1)) {\n', '            // WithdrawWallet memory wallet = depositRepos[_deposit].withdrawWallets[i];\n', '            // if (_name == wallet.name) {\n', '            //     return(true, (_to == wallet.walletAddr));\n', '            // }\n', '            // if (_to == wallet.walletAddr) {\n', '            //     return(true, true);\n', '            // }\n', '            bytes32 walletName = walletStorage.walletName(_deposit, i);\n', '            address walletAddr = walletStorage.wallet(_deposit, i);\n', '            if (_name == walletName) {\n', '                return(true, (_to == walletAddr));\n', '            }\n', '            if (_to == walletAddr) {\n', '                return(false, true);\n', '            }\n', '        }\n', '\n', '        return (false, false);\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens from this contract, send tokens to target withdraw wallet\n', '     *\n', '     * @param _deposWithdr the deposit contract that will record withdrawing\n', '     * @param _time the timestamp occur the withdraw record\n', '     * @param _to the address the token will be transfer to\n', '     * @param _value the token transferred value\n', '         */\n', '    function withdrawFromThis(DepositWithdraw _deposWithdr, uint256 _time, address _to, uint256 _value) private returns (bool) {\n', '        uint256 fee = params.chargeFee();\n', '        uint256 realAmount = _value.sub(fee);\n', '        address tokenReturn = params.chargeFeePool();\n', '        if (tokenReturn != address(0) && fee > 0) {\n', '            // require(tk.transfer(tokenReturn, fee));\n', '            require(walletStorage.withdrawToken(tk, tokenReturn, fee));\n', '        }\n', '\n', '        // require (tk.transfer(_to, realAmount));\n', '        require(walletStorage.withdrawToken(tk, _to, realAmount));\n', '        _deposWithdr.recordWithdraw(_time, _to, realAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '         * @dev withdraw tokens, send tokens to target withdraw wallet\n', '     *\n', '     * @param _deposit the deposit address that will be withdraw from\n', '     * @param _time the timestamp occur the withdraw record\n', '         * @param _name the withdraw address alias name to verify\n', '     * @param _to the address the token will be transfer to\n', '     * @param _value the token transferred value\n', '     * @param _check if we will check the value is valid or meet the limit condition\n', '         */\n', '    function withdrawWithFee(address _deposit,\n', '                             uint256 _time,\n', '                             bytes32 _name,\n', '                             address _to,\n', '                             uint256 _value,\n', '                             bool _check) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '        require(_to != address(0));\n', '\n', '        uint256 totalBalance = walletStorage.balanceOf(_deposit);\n', '        uint256 frozen = walletStorage.frozenAmount(_deposit);\n', '        // uint256 available = totalBalance.sub(frozen);\n', '        // require(_value <= available);\n', '        if (_check) {\n', '            require(_value <= totalBalance.sub(frozen));\n', '        }\n', '\n', '        uint256 _balance = tk.balanceOf(_deposit);\n', '\n', '        bool exist;\n', '        bool correct;\n', '        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\n', '        (exist, correct) = checkWithdrawAddress(_deposit, _name, _to);\n', '        if(!exist) {\n', '            // withdrawWalletList.push(WithdrawWallet(_name, _to));\n', '            if (!correct) {\n', '                walletStorage.addWithdraw(_deposit, _name, _to);\n', '            } else {\n', '                walletStorage.changeWalletName(_deposit, _name, _to);\n', '            }\n', '        } else {\n', '            require(correct, "wallet address must be correct with wallet name!");\n', '        }\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        /**\n', "         * if deposit address doesn't have enough tokens to withdraw,\n", '         * then withdraw from this contract. Record this in the independent deposit contract.\n', '         */\n', '        if (_value > _balance) {\n', '            require(deposWithdr.checkWithdrawAmount(address(params), _value, _time));\n', '            if(_balance > 0) {\n', '                require(deposWithdr.withdrawToken(address(tk), address(walletStorage), _balance));\n', '            }\n', '\n', '            require(withdrawFromThis(deposWithdr, _time, _to, _value));\n', '            // return true;\n', '        } else {\n', '            require(deposWithdr.withdrawToken(address(tk), address(params), _time, _to, _value, params.chargeFee(), params.chargeFeePool()));\n', '        }\n', '\n', '        return walletStorage.decreaseBalance(_deposit, _value);\n', '    }\n', '\n', '    /**\n', '         * @dev destory the old depoist contract and take back the tokens\n', '     *\n', '     * @param _deposit the deposit address\n', '         */\n', '    function destroyDepositContract(address _deposit) onlyOwner public returns (bool) {\n', '        require(_deposit != address(0));\n', '\n', '        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\n', '        address[] memory tokens = new address[](1);\n', '        tokens[0] = address(tk);\n', '        deposWithdr.destroy(tokens);\n', '\n', '        return walletStorage.removeDeposit(_deposit);\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}']