['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8aede3e8e7e3f8efe3e4e8e3eff8caede7ebe3e6a4e9e5e7">[email&#160;protected]</a>\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface F2mInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // one time called\n', '    function disableRound0() public;\n', '    function activeBuy() public;\n', '    // Dividends from all sources (DApps, Donate ...)\n', '    function pushDividends() public payable;\n', '    /**\n', '     * Converts all of caller&#39;s dividends to tokens.\n', '     */\n', '    //function reinvest() public;\n', '    //function buy() public payable;\n', '    function buyFor(address _buyer) public payable;\n', '    function sell(uint256 _tokenAmount) public;\n', '    function exit() public;\n', '    function devTeamWithdraw() public returns(uint256);\n', '    function withdrawFor(address sender) public returns(uint256);\n', '    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function setAutoBuy() public;\n', '    /*==========================================\n', '    =            public FUNCTIONS            =\n', '    ==========================================*/\n', '    // function totalEthBalance() public view returns(uint256);\n', '    function ethBalance(address _address) public view returns(uint256);\n', '    function myBalance() public view returns(uint256);\n', '    function myEthBalance() public view returns(uint256);\n', '\n', '    function swapToken() public;\n', '    function setNewToken(address _newTokenAddress) public;\n', '}\n', '\n', 'interface CitizenInterface {\n', ' \n', '    function joinNetwork(address[6] _contract) public;\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function devTeamWithdraw() public;\n', '\n', '    /*----------  WRITE FUNCTIONS  ----------*/\n', '    function updateUsername(string _sNewUsername) public;\n', '    //Sources: Token contract, DApps\n', '    function pushRefIncome(address _sender) public payable;\n', '    function withdrawFor(address _sender) public payable returns(uint256);\n', '    function devTeamReinvest() public returns(uint256);\n', '\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getRefWallet(address _address) public view returns(uint256);\n', '}\n', '\n', 'interface LotteryInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // call one time\n', '    function activeFirstRound() public;\n', '    // Core Functions\n', '    function pushToPot() public payable;\n', '    function finalizeable() public view returns(bool);\n', '    // bounty\n', '    function finalize() public;\n', '    function buy(string _sSalt) public payable;\n', '    function buyFor(string _sSalt, address _sender) public payable;\n', '    //function withdraw() public;\n', '    function withdrawFor(address _sender) public returns(uint256);\n', '\n', '    function getRewardBalance(address _buyer) public view returns(uint256);\n', '    function getTotalPot() public view returns(uint256);\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // included claimed amount\n', '    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurRoundId() public view returns(uint256);\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) public;\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n', '    function cashoutable(address _address) public view returns(bool);\n', '    function isLastRound() public view returns(bool);\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'contract Bank {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public balance;\n', '    mapping(address => uint256) public claimedSum;\n', '    mapping(address => uint256) public donateSum;\n', '    mapping(address => bool) public isMember;\n', '    address[] public member;\n', '\n', '    uint256 public TIME_OUT = 7 * 24 * 60 * 60;\n', '    mapping(address => uint256) public lastClaim;\n', '\n', '    CitizenInterface public citizenContract;\n', '    LotteryInterface public lotteryContract;\n', '    F2mInterface public f2mContract;\n', '    DevTeamInterface public devTeamContract;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // add administrators here\n', '        devTeamContract = DevTeamInterface(_devTeam);\n', '        devTeamContract.setBankAddress(address(this));\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require(address(citizenContract) == 0x0,"already setup");\n', '        f2mContract = F2mInterface(_contract[0]);\n', '        //bankContract = BankInterface(bankAddress);\n', '        citizenContract = CitizenInterface(_contract[2]);\n', '        lotteryContract = LotteryInterface(_contract[3]);\n', '    }\n', '\n', '    // Core functions\n', '\n', '    function pushToBank(address _player)\n', '        public\n', '        payable\n', '    {\n', '        uint256 _amount = msg.value;\n', '        lastClaim[_player] = block.timestamp;\n', '        balance[_player] = _amount.add(balance[_player]);\n', '    }\n', '\n', '    function collectDividends(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = f2mContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectRef(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = citizenContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectReward(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = lotteryContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectIncome(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        //lastClaim[_member] = block.timestamp;\n', '        uint256 collected = collectDividends(_member) + collectRef(_member) + collectReward(_member);\n', '        return collected;\n', '    }\n', '\n', '    function restTime(address _member)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 timeDist = block.timestamp - lastClaim[_member];\n', '        if (timeDist >= TIME_OUT) return 0;\n', '        return TIME_OUT - timeDist;\n', '    }\n', '\n', '    function timeout(address _member)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return lastClaim[_member] > 0 && restTime(_member) == 0;\n', '    }\n', '\n', '    function memberLog()\n', '        private\n', '    {\n', '        address _member = msg.sender;\n', '        lastClaim[_member] = block.timestamp;\n', '        if (isMember[_member]) return;\n', '        member.push(_member);\n', '        isMember[_member] = true;\n', '    }\n', '\n', '    function cashoutable()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return lotteryContract.cashoutable(msg.sender);\n', '    }\n', '\n', '    function cashout()\n', '        public\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _amount = balance[_sender];\n', '        require(_amount > 0, "nothing to cashout");\n', '        balance[_sender] = 0;\n', '        memberLog();\n', '        require(cashoutable() && _amount > 0, "need 1 ticket or wait to new round");\n', '        _sender.transfer(_amount);\n', '    }\n', '\n', '    // ref => devTeam\n', '    // div => div\n', '    // lottery => div\n', '    function checkTimeout(address _member)\n', '        public\n', '    {\n', '        require(timeout(_member), "member still got time to withdraw");\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 _curBalance = balance[_member];\n', '        uint256 _refIncome = collectRef(_member);\n', '        uint256 _divIncome = collectDividends(_member);\n', '        uint256 _rewardIncome = collectReward(_member);\n', '        donateSum[_member] += _refIncome + _divIncome + _rewardIncome;\n', '        balance[_member] = _curBalance;\n', '        f2mContract.pushDividends.value(_divIncome + _rewardIncome)();\n', '        citizenContract.pushRefIncome.value(_refIncome)(0x0);\n', '    }\n', '\n', '    function withdraw() \n', '        public\n', '    {\n', '        address _member = msg.sender;\n', '        collectIncome(_member);\n', '        cashout();\n', '        //lastClaim[_member] = block.timestamp;\n', '    } \n', '\n', '    function lotteryReinvest(string _sSalt, uint256 _amount)\n', '        public\n', '        payable\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _deposit = msg.value;\n', '        uint256 _curBalance = balance[_sender];\n', '        uint256 investAmount;\n', '        uint256 collected = 0;\n', '        if (_deposit == 0) {\n', '            if (_amount > balance[_sender]) \n', '                collected = collectIncome(_sender);\n', '            require(_amount <= _curBalance + collected, "balance not enough");\n', '            investAmount = _amount;//_curBalance + collected;\n', '        } else {\n', '            collected = collectIncome(_sender);\n', '            investAmount = _deposit.add(_curBalance).add(collected);\n', '        }\n', '        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\n', '        lastClaim [_sender] = block.timestamp;\n', '        lotteryContract.buyFor.value(investAmount)(_sSalt, _sender);\n', '    }\n', '\n', '    function tokenReinvest(uint256 _amount) \n', '        public\n', '        payable\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _deposit = msg.value;\n', '        uint256 _curBalance = balance[_sender];\n', '        uint256 investAmount;\n', '        uint256 collected = 0;\n', '        if (_deposit == 0) {\n', '            if (_amount > balance[_sender]) \n', '                collected = collectIncome(_sender);\n', '            require(_amount <= _curBalance + collected, "balance not enough");\n', '            investAmount = _amount;//_curBalance + collected;\n', '        } else {\n', '            collected = collectIncome(_sender);\n', '            investAmount = _deposit.add(_curBalance).add(collected);\n', '        }\n', '        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\n', '        lastClaim [_sender] = block.timestamp;\n', '        f2mContract.buyFor.value(investAmount)(_sender);\n', '    }\n', '\n', '    // Read\n', '    function getDivBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = f2mContract.ethBalance(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getEarlyIncomeBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = lotteryContract.getCurEarlyIncomeByAddress(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getRewardBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = lotteryContract.getRewardBalance(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getRefBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = citizenContract.getRefWallet(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = getUnclaimedBalance(_sender);\n', '        return _sum + balance[_sender];\n', '    }\n', '\n', '    function getUnclaimedBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = getDivBalance(_sender) + getRefBalance(_sender) + getRewardBalance(_sender) + getEarlyIncomeBalance(_sender);\n', '        return _sum;\n', '    }\n', '\n', '    function getClaimedBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balance[_sender];\n', '    }\n', '\n', '    function getTotalMember() \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return member.length;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '*   gibmireinbier\n', '*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n', '*   gibmireinbier@gmail.com\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface F2mInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // one time called\n', '    function disableRound0() public;\n', '    function activeBuy() public;\n', '    // Dividends from all sources (DApps, Donate ...)\n', '    function pushDividends() public payable;\n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    //function reinvest() public;\n', '    //function buy() public payable;\n', '    function buyFor(address _buyer) public payable;\n', '    function sell(uint256 _tokenAmount) public;\n', '    function exit() public;\n', '    function devTeamWithdraw() public returns(uint256);\n', '    function withdrawFor(address sender) public returns(uint256);\n', '    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function setAutoBuy() public;\n', '    /*==========================================\n', '    =            public FUNCTIONS            =\n', '    ==========================================*/\n', '    // function totalEthBalance() public view returns(uint256);\n', '    function ethBalance(address _address) public view returns(uint256);\n', '    function myBalance() public view returns(uint256);\n', '    function myEthBalance() public view returns(uint256);\n', '\n', '    function swapToken() public;\n', '    function setNewToken(address _newTokenAddress) public;\n', '}\n', '\n', 'interface CitizenInterface {\n', ' \n', '    function joinNetwork(address[6] _contract) public;\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    function devTeamWithdraw() public;\n', '\n', '    /*----------  WRITE FUNCTIONS  ----------*/\n', '    function updateUsername(string _sNewUsername) public;\n', '    //Sources: Token contract, DApps\n', '    function pushRefIncome(address _sender) public payable;\n', '    function withdrawFor(address _sender) public payable returns(uint256);\n', '    function devTeamReinvest() public returns(uint256);\n', '\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getRefWallet(address _address) public view returns(uint256);\n', '}\n', '\n', 'interface LotteryInterface {\n', '    function joinNetwork(address[6] _contract) public;\n', '    // call one time\n', '    function activeFirstRound() public;\n', '    // Core Functions\n', '    function pushToPot() public payable;\n', '    function finalizeable() public view returns(bool);\n', '    // bounty\n', '    function finalize() public;\n', '    function buy(string _sSalt) public payable;\n', '    function buyFor(string _sSalt, address _sender) public payable;\n', '    //function withdraw() public;\n', '    function withdrawFor(address _sender) public returns(uint256);\n', '\n', '    function getRewardBalance(address _buyer) public view returns(uint256);\n', '    function getTotalPot() public view returns(uint256);\n', '    // EarlyIncome\n', '    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // included claimed amount\n', '    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n', '    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n', '    function getCurRoundId() public view returns(uint256);\n', '    // set endRound, prepare to upgrade new version\n', '    function setLastRound(uint256 _lastRoundId) public;\n', '    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n', '    function cashoutable(address _address) public view returns(bool);\n', '    function isLastRound() public view returns(bool);\n', '}\n', '\n', 'interface DevTeamInterface {\n', '    function setF2mAddress(address _address) public;\n', '    function setLotteryAddress(address _address) public;\n', '    function setCitizenAddress(address _address) public;\n', '    function setBankAddress(address _address) public;\n', '    function setRewardAddress(address _address) public;\n', '    function setWhitelistAddress(address _address) public;\n', '\n', '    function setupNetwork() public;\n', '}\n', '\n', 'contract Bank {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public balance;\n', '    mapping(address => uint256) public claimedSum;\n', '    mapping(address => uint256) public donateSum;\n', '    mapping(address => bool) public isMember;\n', '    address[] public member;\n', '\n', '    uint256 public TIME_OUT = 7 * 24 * 60 * 60;\n', '    mapping(address => uint256) public lastClaim;\n', '\n', '    CitizenInterface public citizenContract;\n', '    LotteryInterface public lotteryContract;\n', '    F2mInterface public f2mContract;\n', '    DevTeamInterface public devTeamContract;\n', '\n', '    constructor (address _devTeam)\n', '        public\n', '    {\n', '        // add administrators here\n', '        devTeamContract = DevTeamInterface(_devTeam);\n', '        devTeamContract.setBankAddress(address(this));\n', '    }\n', '\n', '    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n', '    function joinNetwork(address[6] _contract)\n', '        public\n', '    {\n', '        require(address(citizenContract) == 0x0,"already setup");\n', '        f2mContract = F2mInterface(_contract[0]);\n', '        //bankContract = BankInterface(bankAddress);\n', '        citizenContract = CitizenInterface(_contract[2]);\n', '        lotteryContract = LotteryInterface(_contract[3]);\n', '    }\n', '\n', '    // Core functions\n', '\n', '    function pushToBank(address _player)\n', '        public\n', '        payable\n', '    {\n', '        uint256 _amount = msg.value;\n', '        lastClaim[_player] = block.timestamp;\n', '        balance[_player] = _amount.add(balance[_player]);\n', '    }\n', '\n', '    function collectDividends(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = f2mContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectRef(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = citizenContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectReward(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 collected = lotteryContract.withdrawFor(_member);\n', '        claimedSum[_member] += collected;\n', '        return collected;\n', '    }\n', '\n', '    function collectIncome(address _member)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(_member != address(devTeamContract), "no right");\n', '        //lastClaim[_member] = block.timestamp;\n', '        uint256 collected = collectDividends(_member) + collectRef(_member) + collectReward(_member);\n', '        return collected;\n', '    }\n', '\n', '    function restTime(address _member)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 timeDist = block.timestamp - lastClaim[_member];\n', '        if (timeDist >= TIME_OUT) return 0;\n', '        return TIME_OUT - timeDist;\n', '    }\n', '\n', '    function timeout(address _member)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return lastClaim[_member] > 0 && restTime(_member) == 0;\n', '    }\n', '\n', '    function memberLog()\n', '        private\n', '    {\n', '        address _member = msg.sender;\n', '        lastClaim[_member] = block.timestamp;\n', '        if (isMember[_member]) return;\n', '        member.push(_member);\n', '        isMember[_member] = true;\n', '    }\n', '\n', '    function cashoutable()\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return lotteryContract.cashoutable(msg.sender);\n', '    }\n', '\n', '    function cashout()\n', '        public\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _amount = balance[_sender];\n', '        require(_amount > 0, "nothing to cashout");\n', '        balance[_sender] = 0;\n', '        memberLog();\n', '        require(cashoutable() && _amount > 0, "need 1 ticket or wait to new round");\n', '        _sender.transfer(_amount);\n', '    }\n', '\n', '    // ref => devTeam\n', '    // div => div\n', '    // lottery => div\n', '    function checkTimeout(address _member)\n', '        public\n', '    {\n', '        require(timeout(_member), "member still got time to withdraw");\n', '        require(_member != address(devTeamContract), "no right");\n', '        uint256 _curBalance = balance[_member];\n', '        uint256 _refIncome = collectRef(_member);\n', '        uint256 _divIncome = collectDividends(_member);\n', '        uint256 _rewardIncome = collectReward(_member);\n', '        donateSum[_member] += _refIncome + _divIncome + _rewardIncome;\n', '        balance[_member] = _curBalance;\n', '        f2mContract.pushDividends.value(_divIncome + _rewardIncome)();\n', '        citizenContract.pushRefIncome.value(_refIncome)(0x0);\n', '    }\n', '\n', '    function withdraw() \n', '        public\n', '    {\n', '        address _member = msg.sender;\n', '        collectIncome(_member);\n', '        cashout();\n', '        //lastClaim[_member] = block.timestamp;\n', '    } \n', '\n', '    function lotteryReinvest(string _sSalt, uint256 _amount)\n', '        public\n', '        payable\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _deposit = msg.value;\n', '        uint256 _curBalance = balance[_sender];\n', '        uint256 investAmount;\n', '        uint256 collected = 0;\n', '        if (_deposit == 0) {\n', '            if (_amount > balance[_sender]) \n', '                collected = collectIncome(_sender);\n', '            require(_amount <= _curBalance + collected, "balance not enough");\n', '            investAmount = _amount;//_curBalance + collected;\n', '        } else {\n', '            collected = collectIncome(_sender);\n', '            investAmount = _deposit.add(_curBalance).add(collected);\n', '        }\n', '        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\n', '        lastClaim [_sender] = block.timestamp;\n', '        lotteryContract.buyFor.value(investAmount)(_sSalt, _sender);\n', '    }\n', '\n', '    function tokenReinvest(uint256 _amount) \n', '        public\n', '        payable\n', '    {\n', '        address _sender = msg.sender;\n', '        uint256 _deposit = msg.value;\n', '        uint256 _curBalance = balance[_sender];\n', '        uint256 investAmount;\n', '        uint256 collected = 0;\n', '        if (_deposit == 0) {\n', '            if (_amount > balance[_sender]) \n', '                collected = collectIncome(_sender);\n', '            require(_amount <= _curBalance + collected, "balance not enough");\n', '            investAmount = _amount;//_curBalance + collected;\n', '        } else {\n', '            collected = collectIncome(_sender);\n', '            investAmount = _deposit.add(_curBalance).add(collected);\n', '        }\n', '        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\n', '        lastClaim [_sender] = block.timestamp;\n', '        f2mContract.buyFor.value(investAmount)(_sender);\n', '    }\n', '\n', '    // Read\n', '    function getDivBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = f2mContract.ethBalance(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getEarlyIncomeBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = lotteryContract.getCurEarlyIncomeByAddress(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getRewardBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = lotteryContract.getRewardBalance(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getRefBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = citizenContract.getRefWallet(_sender);\n', '        return _amount;\n', '    }\n', '\n', '    function getBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = getUnclaimedBalance(_sender);\n', '        return _sum + balance[_sender];\n', '    }\n', '\n', '    function getUnclaimedBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _sum = getDivBalance(_sender) + getRefBalance(_sender) + getRewardBalance(_sender) + getEarlyIncomeBalance(_sender);\n', '        return _sum;\n', '    }\n', '\n', '    function getClaimedBalance(address _sender)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return balance[_sender];\n', '    }\n', '\n', '    function getTotalMember() \n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return member.length;\n', '    }\n', '}']
