['pragma solidity ^0.4.25;\n', '\n', 'interface IERC20 {\n', '  function transfer(address _to, uint256 _amount) external returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\n', '  function balanceOf(address _owner) constant external returns (uint256 balance);\n', '  function approve(address _spender, uint256 _amount) external returns (bool success);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool success);\n', '  function totalSupply() external constant returns (uint);\n', '}\n', '\n', 'interface IPrizeCalculator {\n', '    function calculatePrizeAmount(uint _predictionTotalTokens, uint _winOutputTotalTokens, uint _forecastTokens)\n', '        pure\n', '        external\n', '        returns (uint);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public executor;\n', '    address public superOwner;\n', '  \n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        superOwner = msg.sender;\n', '        owner = msg.sender;\n', '        executor = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlySuperOwner {\n', '        require(msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrSuperOwner {\n', '        require(msg.sender == owner || msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed {\n', '        require(msg.sender == owner || msg.sender == executor || msg.sender == superOwner, "Not allowed");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function transferSuperOwnership(address _newOwner) public onlySuperOwner {\n', '        emit OwnershipTransferred(superOwner, _newOwner);\n', '        superOwner = _newOwner;\n', '    }\n', '\n', '    function transferExecutorOwnership(address _newExecutor) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(executor, _newExecutor);\n', '        executor = _newExecutor;\n', '    }\n', '}\n', '\n', 'contract Pools is Owned {\n', '    using SafeMath for uint;  \n', '\n', '    event Initialize(address _token);\n', '    event PoolAdded(bytes32 _id);\n', '    event PoolDestinationUpdated(bytes32 _id);\n', '    event ContributionAdded(bytes32 _poolId, bytes32 _contributionId);\n', '    event PoolStatusChange(bytes32 _poolId, PoolStatus _oldStatus, PoolStatus _newStatus);\n', '    event Paidout(bytes32 _poolId, bytes32 _contributionId);\n', '    event Withdraw(uint _amount);\n', '    \n', '    struct Pool {  \n', '        uint contributionStartUtc;\n', '        uint contributionEndUtc;\n', '        address destination;\n', '        PoolStatus status;\n', '        uint amountLimit;\n', '        uint amountCollected;\n', '        uint amountDistributing;\n', '        uint paidout;\n', '        address prizeCalculator;\n', '        mapping(bytes32 => Contribution) contributions;\n', '    }\n', '    \n', '    struct Contribution {  \n', '        address owner;\n', '        uint amount;\n', '        uint paidout;\n', '    }\n', '\n', '    struct ContributionIndex {    \n', '        bytes32 poolId;\n', '        bytes32 contributionId;\n', '    }\n', '    \n', '    enum PoolStatus {\n', '        NotSet,       // 0\n', '        Active,       // 1\n', '        Distributing, // 2\n', '        Funding,       // 3&#160;\n', '        Paused,       // 4\n', '        Canceled      // 5 \n', '    }  \n', '\n', '    uint8 public constant version = 1;\n', '    bool public paused = true;\n', '    address public token;\n', '    uint public totalPools;\n', '    \n', '    mapping(bytes32 => Pool) public pools;\n', '    mapping(address => ContributionIndex[]) public walletPools;\n', '\n', '    modifier contractNotPaused() {\n', '        require(paused == false, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier senderIsToken() {\n', '        require(msg.sender == address(token));\n', '        _;\n', '    }\n', '\n', '    function initialize(address _token) external onlyOwnerOrSuperOwner {\n', '        token = _token;\n', '        paused = false;\n', '        emit Initialize(_token);\n', '    }\n', '\n', '    function addPool(bytes32 _id, \n', '            address _destination, \n', '            uint _contributionStartUtc, \n', '            uint _contributionEndUtc, \n', '            uint _amountLimit, \n', '            address _prizeCalculator) \n', '        external \n', '        onlyOwnerOrSuperOwner \n', '        contractNotPaused {\n', '        \n', '        if (pools[_id].status == PoolStatus.NotSet) { // do not increase if update\n', '            totalPools++;\n', '        } \n', '        \n', '        pools[_id].contributionStartUtc = _contributionStartUtc;\n', '        pools[_id].contributionEndUtc = _contributionEndUtc;\n', '        pools[_id].destination = _destination;\n', '        pools[_id].status = PoolStatus.Active;\n', '        pools[_id].amountLimit = _amountLimit;\n', '        pools[_id].prizeCalculator = _prizeCalculator;\n', '        \n', '        emit PoolAdded(_id);\n', '    }\n', '\n', '    function updateDestination(bytes32 _id, \n', '            address _destination) \n', '        external \n', '        onlyOwnerOrSuperOwner \n', '        contractNotPaused {\n', '\n', '        pools[_id].destination = _destination;\n', '\n', '        emit PoolDestinationUpdated(_id);\n', '    }\n', '    \n', '    function setPoolStatus(bytes32 _poolId, PoolStatus _status) public onlyOwnerOrSuperOwner {\n', '        require(pools[_poolId].status != PoolStatus.NotSet, "pool should be initialized");\n', '        emit PoolStatusChange(_poolId,pools[_poolId].status, _status);\n', '        pools[_poolId].status = _status;\n', '    }\n', '    \n', '    // This method will be called for returning money when canceled or set everyone to take rewards by formula\n', '    function setPoolAmountDistributing(bytes32 _poolId, PoolStatus _poolStatus, uint _amountDistributing) external onlyOwnerOrSuperOwner {\n', '        setPoolStatus(_poolId, _poolStatus);\n', '        pools[_poolId].amountDistributing = _amountDistributing;\n', '    }\n', '\n', '    /// Called by token contract after Approval: this.TokenInstance.methods.approveAndCall()\n', '    // _data = poolId(32),contributionId(32)\n', '    function receiveApproval(address _from, uint _amountOfTokens, address _token, bytes _data) \n', '            external \n', '            senderIsToken\n', '            contractNotPaused {    \n', '        require(_amountOfTokens > 0, "amount should be > 0");\n', '        require(_from != address(0), "not valid from");\n', '        require(_data.length == 64, "not valid _data length");\n', '      \n', '        bytes32 poolIdString = bytesToFixedBytes32(_data,0);\n', '        bytes32 contributionIdString = bytesToFixedBytes32(_data,32);\n', '        \n', '        // Validate pool and Contribution\n', '        require(pools[poolIdString].status == PoolStatus.Active, "Status should be active");\n', '        require(pools[poolIdString].contributionStartUtc < now, "Contribution is not started");    \n', '        require(pools[poolIdString].contributionEndUtc > now, "Contribution is ended"); \n', '        require(pools[poolIdString].contributions[contributionIdString].amount == 0, &#39;Contribution duplicated&#39;);\n', '        require(pools[poolIdString].amountLimit == 0 ||\n', '                pools[poolIdString].amountLimit >= pools[poolIdString].amountCollected.add(_amountOfTokens), "Contribution limit reached"); \n', '        \n', '        // Transfer tokens from sender to this contract\n', '        require(IERC20(_token).transferFrom(_from, address(this), _amountOfTokens), "Tokens transfer failed.");\n', '\n', '        walletPools[_from].push(ContributionIndex(poolIdString, contributionIdString));\n', '        pools[poolIdString].amountCollected = pools[poolIdString].amountCollected.add(_amountOfTokens); \n', '        pools[poolIdString].contributions[contributionIdString].owner = _from;\n', '        pools[poolIdString].contributions[contributionIdString].amount = _amountOfTokens;\n', '\n', '        emit ContributionAdded(poolIdString, contributionIdString);\n', '    }\n', '    \n', '    function transferToDestination(bytes32 _poolId) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(token).transfer(pools[_poolId].destination, pools[_poolId].amountCollected));\n', '        setPoolStatus(_poolId,PoolStatus.Funding);\n', '    }\n', '    \n', '    function payout(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\n', '        require(pools[_poolId].status == PoolStatus.Distributing, "Pool should be Distributing");\n', '        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, "Pool should be not empty");\n', '        \n', '        Contribution storage con = pools[_poolId].contributions[_contributionId];\n', '        require(con.paidout == 0, "Contribution already paidout");\n', '        \n', '        IPrizeCalculator calculator = IPrizeCalculator(pools[_poolId].prizeCalculator);\n', '    \n', '        uint winAmount = calculator.calculatePrizeAmount(\n', '            pools[_poolId].amountDistributing,\n', '            pools[_poolId].amountCollected,  \n', '            con.amount\n', '        );\n', '      \n', '        assert(winAmount > 0);\n', '        con.paidout = winAmount;\n', '        pools[_poolId].paidout = pools[_poolId].paidout.add(winAmount);\n', '        assert(IERC20(token).transfer(con.owner, winAmount));\n', '        emit Paidout(_poolId, _contributionId);\n', '    }\n', '\n', '    function refund(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\n', '        require(pools[_poolId].status == PoolStatus.Canceled, "Pool should be canceled");\n', '        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, "Pool should be not empty");\n', '        \n', '        Contribution storage con = pools[_poolId].contributions[_contributionId];\n', '        require(con.paidout == 0, "Contribution already paidout");        \n', '        require(con.amount > 0, "Contribution not valid");   \n', '        require(con.owner != address(0), "Owner not valid"); \n', '\n', '        con.paidout = con.amount;\n', '        pools[_poolId].paidout = pools[_poolId].paidout.add(con.amount);\n', '        assert(IERC20(token).transfer(con.owner, con.amount));\n', '\n', '        emit Paidout(_poolId, _contributionId);\n', '    }\n', '\n', '    //////////\n', '    // Views\n', '    //////////\n', '    function getContribution(bytes32 _poolId, bytes32 _contributionId) public view returns(address, uint, uint) {\n', '        return (pools[_poolId].contributions[_contributionId].owner,\n', '            pools[_poolId].contributions[_contributionId].amount,\n', '            pools[_poolId].contributions[_contributionId].paidout);\n', '    }\n', '\n', '    // ////////\n', '    // Safety Methods\n', '    // ////////\n', '    function () public payable {\n', '        require(false);\n', '    }\n', '\n', '    function withdrawETH() external onlyOwnerOrSuperOwner {\n', '        uint balance = address(this).balance;\n', '        owner.transfer(balance);\n', '        emit Withdraw(balance);\n', '    }\n', '\n', '    function withdrawTokens(uint _amount, address _token) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(_token).transfer(owner, _amount));\n', '        emit Withdraw(_amount);\n', '    }\n', '\n', '    function pause(bool _paused) external onlyOwnerOrSuperOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '    function bytesToFixedBytes32(bytes memory b, uint offset) internal pure returns (bytes32) {\n', '        bytes32 out;\n', '\n', '        for (uint i = 0; i < 32; i++) {\n', '            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n', '        }\n', '        return out;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'interface IERC20 {\n', '  function transfer(address _to, uint256 _amount) external returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\n', '  function balanceOf(address _owner) constant external returns (uint256 balance);\n', '  function approve(address _spender, uint256 _amount) external returns (bool success);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool success);\n', '  function totalSupply() external constant returns (uint);\n', '}\n', '\n', 'interface IPrizeCalculator {\n', '    function calculatePrizeAmount(uint _predictionTotalTokens, uint _winOutputTotalTokens, uint _forecastTokens)\n', '        pure\n', '        external\n', '        returns (uint);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public executor;\n', '    address public superOwner;\n', '  \n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        superOwner = msg.sender;\n', '        owner = msg.sender;\n', '        executor = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlySuperOwner {\n', '        require(msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrSuperOwner {\n', '        require(msg.sender == owner || msg.sender == superOwner, "User is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed {\n', '        require(msg.sender == owner || msg.sender == executor || msg.sender == superOwner, "Not allowed");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function transferSuperOwnership(address _newOwner) public onlySuperOwner {\n', '        emit OwnershipTransferred(superOwner, _newOwner);\n', '        superOwner = _newOwner;\n', '    }\n', '\n', '    function transferExecutorOwnership(address _newExecutor) public onlyOwnerOrSuperOwner {\n', '        emit OwnershipTransferred(executor, _newExecutor);\n', '        executor = _newExecutor;\n', '    }\n', '}\n', '\n', 'contract Pools is Owned {\n', '    using SafeMath for uint;  \n', '\n', '    event Initialize(address _token);\n', '    event PoolAdded(bytes32 _id);\n', '    event PoolDestinationUpdated(bytes32 _id);\n', '    event ContributionAdded(bytes32 _poolId, bytes32 _contributionId);\n', '    event PoolStatusChange(bytes32 _poolId, PoolStatus _oldStatus, PoolStatus _newStatus);\n', '    event Paidout(bytes32 _poolId, bytes32 _contributionId);\n', '    event Withdraw(uint _amount);\n', '    \n', '    struct Pool {  \n', '        uint contributionStartUtc;\n', '        uint contributionEndUtc;\n', '        address destination;\n', '        PoolStatus status;\n', '        uint amountLimit;\n', '        uint amountCollected;\n', '        uint amountDistributing;\n', '        uint paidout;\n', '        address prizeCalculator;\n', '        mapping(bytes32 => Contribution) contributions;\n', '    }\n', '    \n', '    struct Contribution {  \n', '        address owner;\n', '        uint amount;\n', '        uint paidout;\n', '    }\n', '\n', '    struct ContributionIndex {    \n', '        bytes32 poolId;\n', '        bytes32 contributionId;\n', '    }\n', '    \n', '    enum PoolStatus {\n', '        NotSet,       // 0\n', '        Active,       // 1\n', '        Distributing, // 2\n', '        Funding,       // 3\xa0\n', '        Paused,       // 4\n', '        Canceled      // 5 \n', '    }  \n', '\n', '    uint8 public constant version = 1;\n', '    bool public paused = true;\n', '    address public token;\n', '    uint public totalPools;\n', '    \n', '    mapping(bytes32 => Pool) public pools;\n', '    mapping(address => ContributionIndex[]) public walletPools;\n', '\n', '    modifier contractNotPaused() {\n', '        require(paused == false, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    modifier senderIsToken() {\n', '        require(msg.sender == address(token));\n', '        _;\n', '    }\n', '\n', '    function initialize(address _token) external onlyOwnerOrSuperOwner {\n', '        token = _token;\n', '        paused = false;\n', '        emit Initialize(_token);\n', '    }\n', '\n', '    function addPool(bytes32 _id, \n', '            address _destination, \n', '            uint _contributionStartUtc, \n', '            uint _contributionEndUtc, \n', '            uint _amountLimit, \n', '            address _prizeCalculator) \n', '        external \n', '        onlyOwnerOrSuperOwner \n', '        contractNotPaused {\n', '        \n', '        if (pools[_id].status == PoolStatus.NotSet) { // do not increase if update\n', '            totalPools++;\n', '        } \n', '        \n', '        pools[_id].contributionStartUtc = _contributionStartUtc;\n', '        pools[_id].contributionEndUtc = _contributionEndUtc;\n', '        pools[_id].destination = _destination;\n', '        pools[_id].status = PoolStatus.Active;\n', '        pools[_id].amountLimit = _amountLimit;\n', '        pools[_id].prizeCalculator = _prizeCalculator;\n', '        \n', '        emit PoolAdded(_id);\n', '    }\n', '\n', '    function updateDestination(bytes32 _id, \n', '            address _destination) \n', '        external \n', '        onlyOwnerOrSuperOwner \n', '        contractNotPaused {\n', '\n', '        pools[_id].destination = _destination;\n', '\n', '        emit PoolDestinationUpdated(_id);\n', '    }\n', '    \n', '    function setPoolStatus(bytes32 _poolId, PoolStatus _status) public onlyOwnerOrSuperOwner {\n', '        require(pools[_poolId].status != PoolStatus.NotSet, "pool should be initialized");\n', '        emit PoolStatusChange(_poolId,pools[_poolId].status, _status);\n', '        pools[_poolId].status = _status;\n', '    }\n', '    \n', '    // This method will be called for returning money when canceled or set everyone to take rewards by formula\n', '    function setPoolAmountDistributing(bytes32 _poolId, PoolStatus _poolStatus, uint _amountDistributing) external onlyOwnerOrSuperOwner {\n', '        setPoolStatus(_poolId, _poolStatus);\n', '        pools[_poolId].amountDistributing = _amountDistributing;\n', '    }\n', '\n', '    /// Called by token contract after Approval: this.TokenInstance.methods.approveAndCall()\n', '    // _data = poolId(32),contributionId(32)\n', '    function receiveApproval(address _from, uint _amountOfTokens, address _token, bytes _data) \n', '            external \n', '            senderIsToken\n', '            contractNotPaused {    \n', '        require(_amountOfTokens > 0, "amount should be > 0");\n', '        require(_from != address(0), "not valid from");\n', '        require(_data.length == 64, "not valid _data length");\n', '      \n', '        bytes32 poolIdString = bytesToFixedBytes32(_data,0);\n', '        bytes32 contributionIdString = bytesToFixedBytes32(_data,32);\n', '        \n', '        // Validate pool and Contribution\n', '        require(pools[poolIdString].status == PoolStatus.Active, "Status should be active");\n', '        require(pools[poolIdString].contributionStartUtc < now, "Contribution is not started");    \n', '        require(pools[poolIdString].contributionEndUtc > now, "Contribution is ended"); \n', "        require(pools[poolIdString].contributions[contributionIdString].amount == 0, 'Contribution duplicated');\n", '        require(pools[poolIdString].amountLimit == 0 ||\n', '                pools[poolIdString].amountLimit >= pools[poolIdString].amountCollected.add(_amountOfTokens), "Contribution limit reached"); \n', '        \n', '        // Transfer tokens from sender to this contract\n', '        require(IERC20(_token).transferFrom(_from, address(this), _amountOfTokens), "Tokens transfer failed.");\n', '\n', '        walletPools[_from].push(ContributionIndex(poolIdString, contributionIdString));\n', '        pools[poolIdString].amountCollected = pools[poolIdString].amountCollected.add(_amountOfTokens); \n', '        pools[poolIdString].contributions[contributionIdString].owner = _from;\n', '        pools[poolIdString].contributions[contributionIdString].amount = _amountOfTokens;\n', '\n', '        emit ContributionAdded(poolIdString, contributionIdString);\n', '    }\n', '    \n', '    function transferToDestination(bytes32 _poolId) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(token).transfer(pools[_poolId].destination, pools[_poolId].amountCollected));\n', '        setPoolStatus(_poolId,PoolStatus.Funding);\n', '    }\n', '    \n', '    function payout(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\n', '        require(pools[_poolId].status == PoolStatus.Distributing, "Pool should be Distributing");\n', '        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, "Pool should be not empty");\n', '        \n', '        Contribution storage con = pools[_poolId].contributions[_contributionId];\n', '        require(con.paidout == 0, "Contribution already paidout");\n', '        \n', '        IPrizeCalculator calculator = IPrizeCalculator(pools[_poolId].prizeCalculator);\n', '    \n', '        uint winAmount = calculator.calculatePrizeAmount(\n', '            pools[_poolId].amountDistributing,\n', '            pools[_poolId].amountCollected,  \n', '            con.amount\n', '        );\n', '      \n', '        assert(winAmount > 0);\n', '        con.paidout = winAmount;\n', '        pools[_poolId].paidout = pools[_poolId].paidout.add(winAmount);\n', '        assert(IERC20(token).transfer(con.owner, winAmount));\n', '        emit Paidout(_poolId, _contributionId);\n', '    }\n', '\n', '    function refund(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\n', '        require(pools[_poolId].status == PoolStatus.Canceled, "Pool should be canceled");\n', '        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, "Pool should be not empty");\n', '        \n', '        Contribution storage con = pools[_poolId].contributions[_contributionId];\n', '        require(con.paidout == 0, "Contribution already paidout");        \n', '        require(con.amount > 0, "Contribution not valid");   \n', '        require(con.owner != address(0), "Owner not valid"); \n', '\n', '        con.paidout = con.amount;\n', '        pools[_poolId].paidout = pools[_poolId].paidout.add(con.amount);\n', '        assert(IERC20(token).transfer(con.owner, con.amount));\n', '\n', '        emit Paidout(_poolId, _contributionId);\n', '    }\n', '\n', '    //////////\n', '    // Views\n', '    //////////\n', '    function getContribution(bytes32 _poolId, bytes32 _contributionId) public view returns(address, uint, uint) {\n', '        return (pools[_poolId].contributions[_contributionId].owner,\n', '            pools[_poolId].contributions[_contributionId].amount,\n', '            pools[_poolId].contributions[_contributionId].paidout);\n', '    }\n', '\n', '    // ////////\n', '    // Safety Methods\n', '    // ////////\n', '    function () public payable {\n', '        require(false);\n', '    }\n', '\n', '    function withdrawETH() external onlyOwnerOrSuperOwner {\n', '        uint balance = address(this).balance;\n', '        owner.transfer(balance);\n', '        emit Withdraw(balance);\n', '    }\n', '\n', '    function withdrawTokens(uint _amount, address _token) external onlyOwnerOrSuperOwner {\n', '        assert(IERC20(_token).transfer(owner, _amount));\n', '        emit Withdraw(_amount);\n', '    }\n', '\n', '    function pause(bool _paused) external onlyOwnerOrSuperOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '    function bytesToFixedBytes32(bytes memory b, uint offset) internal pure returns (bytes32) {\n', '        bytes32 out;\n', '\n', '        for (uint i = 0; i < 32; i++) {\n', '            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n', '        }\n', '        return out;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}']
