['// File: contracts/interfaces/IERC1620.sol\n', '\n', 'pragma solidity 0.5.9;\n', '\n', '/// @title ERC-1620 Money Streaming Standard\n', '/// @dev See https://github.com/ethereum/eips/issues/1620\n', '\n', 'interface IERC1620 {\n', '\n', '    /// @dev This emits when streams are successfully created and added\n', '    ///  in the mapping object.\n', '    event CreateStream(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        address tokenAddress,\n', '        uint256 startBlock,\n', '        uint256 stopBlock,\n', '        uint256 payment,\n', '        uint256 interval\n', '    );\n', '\n', '    /// @dev This emits when the receiver of a stream withdraws a portion\n', '    ///  or all of their available funds from an ongoing stream, without\n', "    ///  stopping it. Note that we don't emit both the sender and the\n", "    ///  recipient's balance because only the recipient can withdraw\n", '    ///  while the stream is active.\n', '    event WithdrawFromStream(\n', '        uint256 indexed streamId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    /// @dev This emits when a stream is successfully redeemed and\n', '    ///  all involved parties get their share of the available funds.\n', '    event RedeemStream(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 senderAmount,\n', '        uint256 recipientAmount\n', '    );\n', '\n', '    /// @dev This emits when an update is successfully committed by\n', '    ///  one of the involved parties.\n', '    event ConfirmUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed confirmer,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    /// @dev This emits when one of the involved parties revokes\n', '    ///  a proposed update to the stream.\n', '    event RevokeUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed revoker,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    /// @dev This emits when an update (that is, modifications to\n', '    ///  payment rate, starting or stopping block) is successfully\n', '    ///  approved by all involved parties.\n', '    event ExecuteUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    /// @notice Creates a new stream between `msg.sender` and `_recipient`\n', '    /// @dev Throws unless `msg.value` is exactly\n', '    ///  `_payment * ((_stopBlock - _startBlock) / _interval)`.\n', '    ///  Throws if `_startBlock` is not higher than `block.number`.\n', '    ///  Throws if `_stopBlock` is not higher than `_startBlock`.\n', '    ///  Throws if the total streaming duration `_stopBlock - _startBlock`\n', '    ///  is not a multiple of `_interval`.\n', '    /// @param _recipient The stream sender or the payer\n', '    /// @param _recipient The stream recipient or the payee\n', '    /// @param _tokenAddress The token contract address\n', '    /// @param _startBlock The starting time of the stream\n', '    /// @param _stopBlock The stopping time of the stream\n', '    /// @param _payment How much money moves from sender to recipient\n', '    /// @param _interval How often the `payment` moves from sender to recipient\n', '    function createStream(\n', '        address _sender,\n', '        address _recipient,\n', '        address _tokenAddress,\n', '        uint256 _startBlock,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '    external;\n', '\n', '    /// @notice Withdraws all or a fraction of the available funds\n', '    /// @dev If the stream ended and the recipient withdraws the deposit in full,\n', '    ///  the stream object gets deleted after this operation\n', '    ///  to save gas for the user and optimise contract storage.\n', "    ///  Throws if `_streamId` doesn't point to a valid stream.\n", '    ///  Throws if `msg.sender` is not the recipient of the given `streamId`\n', '    /// @param _streamId The stream to withdraw from\n', '    /// @param _funds The amount of money to withdraw\n', '    function withdrawFromStream(\n', '        uint256 _streamId,\n', '        uint256 _funds\n', '    )\n', '    external;\n', '\n', '    /// @notice Redeems the stream by distributing the funds to the sender and the recipient\n', '    /// @dev The stream object gets deleted after this operation\n', '    ///  to save gas for the user and optimise contract storage.\n', "    ///  Throws if `_streamId` doesn't point to a valid stream.\n", '    ///  Throws unless `msg.sender` is either the sender or the recipient\n', '    ///  of the given `streamId`.\n', '    /// @param _streamId The stream to stop\n', '    function redeemStream(\n', '        uint256 _streamId\n', '    )\n', '    external;\n', '\n', "    /// @notice Signals one party's willingness to update the stream\n", "    /// @dev Throws if `_streamId` doesn't point to a valid stream.\n", '    ///  Not executed prior to everyone agreeing to the new terms.\n', '    ///  In terms of validation, it works exactly the same as the `createStream` function.\n', '    /// @param _streamId The stream to update\n', '    /// @param _tokenAddress The token contract address\n', '    /// @param _stopBlock The new stopping time of the stream\n', '    /// @param _payment How much money moves from sender to recipient\n', '    /// @param _interval How often the `payment` moves from sender to recipient\n', '    function confirmUpdate(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '    external;\n', '\n', '    /// @notice Revokes an update proposed by one of the involved parties\n', "    /// @dev Throws if `_streamId` doesn't point to a valid stream. The parameters\n", '    ///  are merely for logging purposes.\n', '    function revokeUpdate(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '    external;\n', '\n', '    /// @notice Returns available funds for the given stream id and address\n', '    /// @dev Streams assigned to the zero address are considered invalid, and\n', '    ///  this function throws for queries about the zero address.\n', '    /// @param _streamId The stream for whom to query the balance\n', '    /// @param _addr The address for whom to query the balance\n', '    /// @return The total funds available to `addr` to withdraw\n', '    function balanceOf(\n', '        uint256 _streamId,\n', '        address _addr\n', '    )\n', '    external\n', '    view\n', '    returns (\n', '        uint256 balance\n', '    );\n', '\n', '    /// @notice Returns the full stream data\n', "    /// @dev Throws if `_streamId` doesn't point to a valid stream.\n", '    /// @param _streamId The stream to return data for\n', '    function getStream(\n', '        uint256 _streamId\n', '    )\n', '    external\n', '    view\n', '    returns (\n', '        address _sender,\n', '        address _recipient,\n', '        address _tokenAddress,\n', '        uint256 _balance,\n', '        uint256 _startBlock,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    );\n', '}\n', '\n', '// File: contracts/zeppelin/IERC20.sol\n', '\n', 'pragma solidity 0.5.9;\n', '\n', '/// @title ERC20 interface\n', '/// @author /// OpenZeppelin Community - <maintainers@openzeppelin.org>\n', '/// @dev see https://eips.ethereum.org/EIPS/eip-20\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/zeppelin/SafeMath.sol\n', '\n', 'pragma solidity 0.5.9;\n', '\n', '/// @title SafeMath\n', '/// @author OpenZeppelin Community - <maintainers@openzeppelin.org>\n', '/// @dev Unsigned math operations with safety checks that revert on error\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/Sablier.sol\n', '\n', 'pragma solidity 0.5.9;\n', '\n', '\n', '\n', '\n', '/// @title Sablier - ERC Money Streaming Implementation\n', '/// @author Paul Berg - <hello@paulrberg.com>\n', '\n', 'contract Sablier is IERC1620 {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Types\n', '     */\n', '    struct Timeframe {\n', '        uint256 start;\n', '        uint256 stop;\n', '    }\n', '\n', '    struct Rate {\n', '        uint256 payment;\n', '        uint256 interval;\n', '    }\n', '\n', '    struct Stream {\n', '        address sender;\n', '        address recipient;\n', '        address tokenAddress;\n', '        Timeframe timeframe;\n', '        Rate rate;\n', '        uint256 balance;\n', '    }\n', '\n', '    /**\n', '     * Storage\n', '     */\n', '    mapping(uint256 => Stream) private streams;\n', '    uint256 private streamNonce;\n', '    mapping(uint256 => mapping(address => bool)) private updates;\n', '\n', '    /**\n', '     * Events\n', '     */\n', '    event CreateStream(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        address tokenAddress,\n', '        uint256 startBlock,\n', '        uint256 stopBlock,\n', '        uint256 payment,\n', '        uint256 interval,\n', '        uint256 deposit\n', '    );\n', '\n', '    event WithdrawFromStream(\n', '        uint256 indexed streamId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    event RedeemStream(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 senderAmount,\n', '        uint256 recipientAmount\n', '    );\n', '\n', '    event ConfirmUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed confirmer,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    event RevokeUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed revoker,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    event ExecuteUpdate(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        address newTokenAddress,\n', '        uint256 newStopBlock,\n', '        uint256 newPayment,\n', '        uint256 newInterval\n', '    );\n', '\n', '    /*\n', '    * Modifiers\n', '    */\n', '    modifier onlyRecipient(uint256 _streamId) {\n', '        require(\n', '            streams[_streamId].recipient == msg.sender,\n', '            "only the stream recipient is allowed to perform this action"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlySenderOrRecipient(uint256 _streamId) {\n', '        require(\n', '            msg.sender == streams[_streamId].sender ||\n', '            msg.sender == streams[_streamId].recipient,\n', '            "only the sender or the recipient of the stream can perform this action"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier streamExists(uint256 _streamId) {\n', '        require(\n', '            streams[_streamId].sender != address(0x0), "stream doesn\'t exist");\n', '        _;\n', '    }\n', '\n', '    modifier updateConfirmed(uint256 _streamId, address _addr) {\n', '        require(\n', '            updates[_streamId][_addr] == true,\n', '            "msg.sender has not confirmed the update"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Functions\n', '     */\n', '    constructor() public {\n', '        streamNonce = 1;\n', '    }\n', '\n', '    function balanceOf(uint256 _streamId, address _addr)\n', '    public\n', '    view\n', '    streamExists(_streamId)\n', '    returns (uint256 balance)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        uint256 deposit = depositOf(_streamId);\n', '        uint256 delta = deltaOf(_streamId);\n', '        uint256 funds = delta.div(stream.rate.interval).mul(stream.rate.payment);\n', '\n', '        if (stream.balance != deposit)\n', '            funds = funds.sub(deposit.sub(stream.balance));\n', '\n', '        if (_addr == stream.recipient) {\n', '            return funds;\n', '        } else if (_addr == stream.sender) {\n', '            return stream.balance.sub(funds);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getStream(uint256 _streamId)\n', '    public\n', '    view\n', '    streamExists(_streamId)\n', '    returns (\n', '        address sender,\n', '        address recipient,\n', '        address tokenAddress,\n', '        uint256 balance,\n', '        uint256 startBlock,\n', '        uint256 stopBlock,\n', '        uint256 payment,\n', '        uint256 interval\n', '    )\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        return (\n', '            stream.sender,\n', '            stream.recipient,\n', '            stream.tokenAddress,\n', '            stream.balance,\n', '            stream.timeframe.start,\n', '            stream.timeframe.stop,\n', '            stream.rate.payment,\n', '            stream.rate.interval\n', '        );\n', '    }\n', '\n', '    function getUpdate(uint256 _streamId, address _addr)\n', '    public\n', '    view\n', '    streamExists(_streamId)\n', '    returns (bool active)\n', '    {\n', '        return updates[_streamId][_addr];\n', '    }\n', '\n', '    function createStream(\n', '        address _sender,\n', '        address _recipient,\n', '        address _tokenAddress,\n', '        uint256 _startBlock,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '        public\n', '    {\n', '        verifyTerms(\n', '            _tokenAddress,\n', '            _startBlock,\n', '            _stopBlock,\n', '            _interval\n', '        );\n', '\n', '        // only ERC20 tokens can be streamed\n', '        uint256 deposit = _stopBlock.sub(_startBlock).div(_interval).mul(_payment);\n', '        IERC20 tokenContract = IERC20(_tokenAddress);\n', '        uint256 allowance = tokenContract.allowance(_sender, address(this));\n', '        require(allowance >= deposit, "contract not allowed to transfer enough tokens");\n', '\n', '        // create and log the stream if the deposit is okay\n', '        streams[streamNonce] = Stream({\n', '            balance : deposit,\n', '            sender : _sender,\n', '            recipient : _recipient,\n', '            tokenAddress : _tokenAddress,\n', '            timeframe : Timeframe(_startBlock, _stopBlock),\n', '            rate : Rate(_payment, _interval)\n', '        });\n', '        emit CreateStream(\n', '            streamNonce,\n', '            _sender,\n', '            _recipient,\n', '            _tokenAddress,\n', '            _startBlock,\n', '            _stopBlock,\n', '            _payment,\n', '            _interval,\n', '            deposit\n', '        );\n', '        streamNonce = streamNonce.add(1);\n', '\n', '        // apply Checks-Effects-Interactions\n', '        require(tokenContract.transferFrom(_sender, address(this), deposit), "initial deposit failed");\n', '    }\n', '\n', '    function withdrawFromStream(\n', '        uint256 _streamId,\n', '        uint256 _amount\n', '    )\n', '    public\n', '    streamExists(_streamId)\n', '    onlyRecipient(_streamId)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        uint256 availableFunds = balanceOf(_streamId, stream.recipient);\n', '        require(availableFunds >= _amount, "not enough funds");\n', '\n', '        streams[_streamId].balance = streams[_streamId].balance.sub(_amount);\n', '        emit WithdrawFromStream(_streamId, stream.recipient, _amount);\n', '\n', '        // saving gas\n', '        if (streams[_streamId].balance == 0) {\n', '            delete streams[_streamId];\n', '            updates[_streamId][stream.sender] = false;\n', '            updates[_streamId][stream.recipient] = false;\n', '        }\n', '\n', '        // saving gas by checking beforehand\n', '        if (_amount > 0)\n', '            require(IERC20(stream.tokenAddress).transfer(stream.recipient, _amount), "erc20 transfer failed");\n', '    }\n', '\n', '    function redeemStream(uint256 _streamId)\n', '    public\n', '    streamExists(_streamId)\n', '    onlySenderOrRecipient(_streamId)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        uint256 senderAmount = balanceOf(_streamId, stream.sender);\n', '        uint256 recipientAmount = balanceOf(_streamId, stream.recipient);\n', '        emit RedeemStream(\n', '            _streamId,\n', '            stream.sender,\n', '            stream.recipient,\n', '            senderAmount,\n', '            recipientAmount\n', '        );\n', '\n', '        // saving gas\n', '        delete streams[_streamId];\n', '        updates[_streamId][stream.sender] = false;\n', '        updates[_streamId][stream.recipient] = false;\n', '\n', '        IERC20 tokenContract = IERC20(stream.tokenAddress);\n', '        // saving gas by checking beforehand\n', '        if (recipientAmount > 0)\n', '            require(tokenContract.transfer(stream.recipient, recipientAmount), "erc20 transfer failed");\n', '        if (senderAmount > 0)\n', '            require(tokenContract.transfer(stream.sender, senderAmount), "erc20 transfer failed");\n', '    }\n', '\n', '    function confirmUpdate(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '    public\n', '    streamExists(_streamId)\n', '    onlySenderOrRecipient(_streamId)\n', '    {\n', '        onlyNewTerms(\n', '            _streamId,\n', '            _tokenAddress,\n', '            _stopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '        verifyTerms(\n', '            _tokenAddress,\n', '            block.number,\n', '            _stopBlock,\n', '            _interval\n', '        );\n', '\n', '        emit ConfirmUpdate(\n', '            _streamId,\n', '            msg.sender,\n', '            _tokenAddress,\n', '            _stopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '        updates[_streamId][msg.sender] = true;\n', '\n', '        executeUpdate(\n', '            _streamId,\n', '            _tokenAddress,\n', '            _stopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '    }\n', '\n', '    function revokeUpdate(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '        public\n', '        updateConfirmed(_streamId, msg.sender)\n', '    {\n', '        emit RevokeUpdate(\n', '            _streamId,\n', '            msg.sender,\n', '            _tokenAddress,\n', '            _stopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '        updates[_streamId][msg.sender] = false;\n', '    }\n', '\n', '    /**\n', '     * Private\n', '     */\n', '    function deltaOf(uint256 _streamId)\n', '    private\n', '    view\n', '    returns (uint256 delta)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        uint256 startBlock = stream.timeframe.start;\n', '        uint256 stopBlock = stream.timeframe.stop;\n', '\n', '        // before the start of the stream\n', '        if (block.number <= startBlock)\n', '            return 0;\n', '\n', '        // during the stream\n', '        if (block.number <= stopBlock)\n', '            return block.number - startBlock;\n', '\n', '        // after the end of the stream\n', '        return stopBlock - startBlock;\n', '    }\n', '\n', '    function depositOf(uint256 _streamId)\n', '    private\n', '    view\n', '    returns (uint256 funds)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        return stream.timeframe.stop\n', '            .sub(stream.timeframe.start)\n', '            .div(stream.rate.interval)\n', '            .mul(stream.rate.payment);\n', '    }\n', '\n', '    function onlyNewTerms(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '    private\n', '    view\n', '    returns (bool valid)\n', '    {\n', '        require(\n', '            streams[_streamId].tokenAddress != _tokenAddress ||\n', '            streams[_streamId].timeframe.stop != _stopBlock ||\n', '            streams[_streamId].rate.payment != _payment ||\n', '            streams[_streamId].rate.interval != _interval,\n', '            "stream has these terms already"\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function verifyTerms(\n', '        address _tokenAddress,\n', '        uint256 _startBlock,\n', '        uint256 _stopBlock,\n', '        uint256 _interval\n', '    )\n', '    private\n', '    view\n', '    returns (bool valid)\n', '    {\n', '        require(\n', '            _tokenAddress != address(0x0),\n', '            "token contract address needs to be provided"\n', '        );\n', '        require(\n', '            _startBlock >= block.number,\n', '            "the start block needs to be higher than the current block number"\n', '        );\n', '        require(\n', '            _stopBlock > _startBlock,\n', '            "the stop block needs to be higher than the start block"\n', '        );\n', '        uint256 delta = _stopBlock - _startBlock;\n', '        require(\n', '            delta >= _interval,\n', '            "the block difference needs to be higher than the payment interval"\n', '        );\n', '        require(\n', '            delta.mod(_interval) == 0,\n', '            "the block difference needs to be a multiple of the payment interval"\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function executeUpdate(\n', '        uint256 _streamId,\n', '        address _tokenAddress,\n', '        uint256 _stopBlock,\n', '        uint256 _payment,\n', '        uint256 _interval\n', '    )\n', '        private\n', '        streamExists(_streamId)\n', '    {\n', '        Stream memory stream = streams[_streamId];\n', '        if (updates[_streamId][stream.sender] == false)\n', '            return;\n', '        if (updates[_streamId][stream.recipient] == false)\n', '            return;\n', '\n', '        // adjust stop block\n', '        uint256 remainder = _stopBlock.sub(block.number).mod(_interval);\n', '        uint256 adjustedStopBlock = _stopBlock.sub(remainder);\n', '        emit ExecuteUpdate(\n', '            _streamId,\n', '            stream.sender,\n', '            stream.recipient,\n', '            _tokenAddress,\n', '            adjustedStopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '        updates[_streamId][stream.sender] = false;\n', '        updates[_streamId][stream.recipient] = false;\n', '\n', '        redeemStream(_streamId);\n', '        createStream(\n', '            stream.sender,\n', '            stream.recipient,\n', '            _tokenAddress,\n', '            block.number,\n', '            adjustedStopBlock,\n', '            _payment,\n', '            _interval\n', '        );\n', '    }\n', '}']