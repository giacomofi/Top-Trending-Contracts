['pragma solidity ^0.5.0;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "Assertion Failed");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "Assertion Failed");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string calldata name) external view returns (address);\n', '}\n', '\n', 'interface MakerCDP {\n', '    function open() external returns (bytes32 cup);\n', '    function join(uint wad) external; // Join PETH\n', '    function give(bytes32 cup, address guy) external;\n', '    function lock(bytes32 cup, uint wad) external;\n', '    function draw(bytes32 cup, uint wad) external;\n', '    function per() external view returns (uint ray);\n', '}\n', '\n', 'interface PriceInterface {\n', '    function peek() external view returns (bytes32, bool);\n', '}\n', '\n', 'interface WETHFace {\n', '    function deposit() external payable;\n', '}\n', '\n', 'interface Swap {\n', '    function dai2eth(uint srcDAI) external returns (uint destETH);\n', '}\n', '\n', 'interface InstaBank {\n', '    function claimCDP(uint cdpNum) external;\n', '    function transferCDPInternal(uint cdpNum, address nextOwner) external;\n', '}\n', '\n', '\n', 'contract Registry {\n', '    address public addressRegistry;\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == getAddress("admin"), "Permission Denied");\n', '        _;\n', '    }\n', '    function getAddress(string memory name) internal view returns (address) {\n', '        AddressRegistry addrReg = AddressRegistry(addressRegistry);\n', '        return addrReg.getAddr(name);\n', '    }\n', '}\n', '\n', '\n', 'contract GlobalVar is Registry {\n', '    using SafeMath for uint;\n', '    using SafeMath for uint256;\n', '\n', '    address public cdpAddr; // SaiTub\n', '    bool public freezed;\n', '\n', '    function getETHRate() public view returns (uint) {\n', '        PriceInterface ethRate = PriceInterface(getAddress("ethfeed"));\n', '        bytes32 ethrate;\n', '        (ethrate, ) = ethRate.peek();\n', '        return uint(ethrate);\n', '    }\n', '\n', '    function approveERC20() public {\n', '        IERC20 wethTkn = IERC20(getAddress("weth"));\n', '        wethTkn.approve(cdpAddr, 2 ** 256 - 1);\n', '        IERC20 pethTkn = IERC20(getAddress("peth"));\n', '        pethTkn.approve(cdpAddr, 2 ** 256 - 1);\n', '        IERC20 mkrTkn = IERC20(getAddress("mkr"));\n', '        mkrTkn.approve(cdpAddr, 2 ** 256 - 1);\n', '        IERC20 daiTkn = IERC20(getAddress("dai"));\n', '        daiTkn.approve(cdpAddr, 2 ** 256 - 1);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract LoopNewCDP is GlobalVar {\n', '    event LevNewCDP(uint cdpNum, address borrower, uint ethLocked, uint daiMinted);\n', '\n', '    function pethPEReth(uint ethNum) public view returns (uint rPETH) {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        rPETH = (ethNum.mul(10 ** 27)).div(loanMaster.per());\n', '    }\n', '\n', '    // useETH = msg.sender + personal ETH used to assist the operation\n', '    function riskNewCDP(uint eth2Lock, uint dai2Mint, bool isCDP2Sender) public payable {\n', '        require(!freezed, "Operation Disabled");\n', '\n', '        uint contractETHBal = address(this).balance - msg.value;\n', '\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        bytes32 cup = loanMaster.open(); // New CDP\n', '\n', '        WETHFace wethTkn = WETHFace(getAddress("weth"));\n', '        wethTkn.deposit.value(eth2Lock)(); // ETH to WETH\n', '        uint pethToLock = pethPEReth(eth2Lock); // PETH : ETH\n', '        loanMaster.join(pethToLock); // WETH to PETH\n', '        loanMaster.lock(cup, pethToLock); // PETH to CDP\n', '\n', '        loanMaster.draw(cup, dai2Mint);\n', '        address dai2ethContract = getAddress("dai2eth");\n', '        IERC20 daiTkn = IERC20(getAddress("dai"));\n', '        daiTkn.transfer(dai2ethContract, dai2Mint); // DAI >>> dai2eth\n', '        Swap resolveSwap = Swap(dai2ethContract);\n', '        resolveSwap.dai2eth(dai2Mint); // DAI >>> ETH\n', '\n', '        uint nowBal = address(this).balance;\n', '        if (nowBal > contractETHBal) {\n', '            msg.sender.transfer(nowBal - contractETHBal);\n', '        }\n', '        require(contractETHBal == address(this).balance, "No Refund of Contract ETH");\n', '\n', '        if (isCDP2Sender) {\n', '            // CDP >>> msg.sender\n', '            loanMaster.give(cup, msg.sender);\n', '        } else {\n', '            // CDP >>> InstaBank\n', '            InstaBank resolveBank = InstaBank(getAddress("bankv2"));\n', '            resolveBank.claimCDP(uint(cup));\n', '            resolveBank.transferCDPInternal(uint(cup), msg.sender);\n', '        }\n', '\n', '        emit LevNewCDP(uint(cup), msg.sender, eth2Lock, dai2Mint);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract LeverageCDP is LoopNewCDP {\n', '    constructor(address rAddr) public {\n', '        addressRegistry = rAddr;\n', '        cdpAddr = getAddress("cdp");\n', '        approveERC20();\n', '    }\n', '\n', '    function() external payable {}\n', '\n', '    function collectETH(uint ethQty) public onlyAdmin {\n', '        msg.sender.transfer(ethQty);\n', '    }\n', '\n', '    function freeze(bool stop) public onlyAdmin {\n', '        freezed = stop;\n', '    }\n', '\n', '}']