['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', 'contract CryptoMiningWarInterface {\n', '\tuint256 public roundNumber;\n', '    uint256 public deadline; \n', '    function addCrystal( address /*_addr*/, uint256 /*_value*/ ) public pure {}\n', '    function isMiningWarContract() external pure returns(bool) {}\n', '}\n', 'contract CrystalAirdropGame {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public administrator;\n', '\t// mini game\n', '    uint256 private ROUND_TIME_MINING_WAR = 86400 * 7;\n', '    uint256 private BONUS_CRYSTAL = 5000000;\n', '    uint256 public TIME_DAY = 24 hours;\n', '\n', '    address public miningWarAddress;\n', '    CryptoMiningWarInterface public MiningWar;\n', '    /** \n', '    * @dev player information\n', '    */\n', '    mapping(address => Player) public players;\n', '    mapping(uint256 => Airdrop) public airdrops;\n', '   \n', '    struct Player {\n', '        uint256 miningWarRound;\n', '        uint256 noJoinAirdrop; \n', '        uint256 lastDayJoin;\n', '    }\n', '    struct Airdrop {\n', '        uint256 day;\n', '        uint256 prizeCrystal;\n', '    }\n', '    event AirdropPrize(\n', '        address playerJoin,\n', '        uint256 crystalBonus,\n', '        uint256 noJoinAirdrop,\n', '        uint256 noDayStartMiningWar\n', '    );\n', '\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        // set interface main contract\n', '        setMiningWarInterface(0x1b002cd1ba79dfad65e8abfbb3a97826e4960fe5);\n', '\n', '        initAirdrop();\n', '    }\n', '    function initAirdrop() private {\n', '        //                    day       prize crystals\n', '        airdrops[0] = Airdrop(1,            5000);   \n', '        airdrops[1] = Airdrop(2,            10000);   \n', '        airdrops[2] = Airdrop(3,            20000);   \n', '        airdrops[3] = Airdrop(4,            40000);   \n', '        airdrops[4] = Airdrop(5,            60000);   \n', '        airdrops[5] = Airdrop(6,            100000);   \n', '        airdrops[6] = Airdrop(7,            200000);   \n', '    }\n', '    /** \n', '    * @dev MainContract used this function to verify game&#39;s contract\n', '    */\n', '    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\n', '    {\n', '    \t_isContractMiniGame = true;\n', '    }\n', '    function isAirdropContract() public pure returns(bool)\n', '    {\n', '        return true;\n', '    }\n', '    function setAirdropPrize(uint256 idx, uint256 value) public \n', '    {\n', '       require( administrator == msg.sender );\n', '       airdrops[idx].prizeCrystal = value; \n', '    }\n', '     function setMiningWarInterface(address _addr) public \n', '    {\n', '        require( administrator == msg.sender );\n', '        \n', '        CryptoMiningWarInterface miningWarInterface = CryptoMiningWarInterface(_addr);\n', '\n', '        require(miningWarInterface.isMiningWarContract() == true);\n', '        \n', '        miningWarAddress = _addr;\n', '        \n', '        MiningWar = miningWarInterface;\n', '    }\n', '\n', '    function setupMiniGame(uint256 /*_miningWarRoundNumber*/, uint256 /*_miningWarDeadline*/ ) public pure\n', '    {\n', '\n', '    }\n', '\n', '    function joinAirdrop() public \n', '    {   \n', '        require(tx.origin == msg.sender);\n', '        require(MiningWar.deadline() > now);\n', '\n', '        Player storage p = players[msg.sender];\n', '        \n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '\n', '        if (noDayEndMiningWar > 7) revert();\n', '\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', ' \n', '        if (p.miningWarRound != miningWarRound) {\n', '            p.noJoinAirdrop = 1;\n', '            p.miningWarRound= miningWarRound;\n', '        } else if (p.lastDayJoin >= noDayStartMiningWar) {\n', '            revert();\n', '        } else {\n', '            p.noJoinAirdrop += 1;\n', '        }\n', '        p.lastDayJoin = noDayStartMiningWar;\n', '\n', '        airdropPrize(msg.sender);\n', '    }\n', '\n', '    function airdropPrize(address _addr) private\n', '    {\n', '       Player memory p = players[_addr];\n', '       \n', '       uint256 prizeCrystal = 0;\n', '       if (p.lastDayJoin > 0 && p.lastDayJoin <= 7)\n', '           prizeCrystal = airdrops[p.lastDayJoin - 1].prizeCrystal;\n', '       if (p.noJoinAirdrop >= 7) \n', '           prizeCrystal = SafeMath.add(prizeCrystal, BONUS_CRYSTAL);  \n', '       if (prizeCrystal != 0)\n', '           MiningWar.addCrystal(_addr, prizeCrystal);\n', '\n', '       emit AirdropPrize(_addr, prizeCrystal, p.noJoinAirdrop, p.lastDayJoin);\n', '    }\n', '    function getData(address _addr) public view returns(uint256 miningWarRound, uint256 noJoinAirdrop, uint256 lastDayJoin, uint256 nextTimeAirdropJoin)\n', '    {\n', '         Player memory p = players[_addr];\n', '\n', '         miningWarRound = p.miningWarRound;\n', '         noJoinAirdrop  = p.noJoinAirdrop;\n', '         lastDayJoin    = p.lastDayJoin;\n', '         nextTimeAirdropJoin = getNextTimeAirdropJoin(_addr);\n', '\n', '        if (miningWarRound != MiningWar.roundNumber()) {\n', '            noJoinAirdrop = 0;\n', '            lastDayJoin   = 0;\n', '        }   \n', '    }\n', '    function getNextCrystalReward(address _addr) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeStartMiningWar  = SafeMath.sub(MiningWar.deadline(), ROUND_TIME_MINING_WAR); \n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', '\n', '        if (noDayStartMiningWar > 7) return 0;\n', '        if (p.lastDayJoin < noDayStartMiningWar) return airdrops[noDayStartMiningWar - 1].prizeCrystal; \n', '        return airdrops[noDayStartMiningWar].prizeCrystal;\n', '    }\n', '    function getNextTimeAirdropJoin(address _addr) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '\n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeStartMiningWar  = SafeMath.sub(MiningWar.deadline(), ROUND_TIME_MINING_WAR); \n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', '\n', '        if (p.miningWarRound != miningWarRound) return 0;\n', '\n', '        if (p.lastDayJoin < noDayStartMiningWar) return 0;\n', '\n', '        return SafeMath.add(SafeMath.mul(noDayStartMiningWar, TIME_DAY), timeStartMiningWar);\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', 'contract CryptoMiningWarInterface {\n', '\tuint256 public roundNumber;\n', '    uint256 public deadline; \n', '    function addCrystal( address /*_addr*/, uint256 /*_value*/ ) public pure {}\n', '    function isMiningWarContract() external pure returns(bool) {}\n', '}\n', 'contract CrystalAirdropGame {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public administrator;\n', '\t// mini game\n', '    uint256 private ROUND_TIME_MINING_WAR = 86400 * 7;\n', '    uint256 private BONUS_CRYSTAL = 5000000;\n', '    uint256 public TIME_DAY = 24 hours;\n', '\n', '    address public miningWarAddress;\n', '    CryptoMiningWarInterface public MiningWar;\n', '    /** \n', '    * @dev player information\n', '    */\n', '    mapping(address => Player) public players;\n', '    mapping(uint256 => Airdrop) public airdrops;\n', '   \n', '    struct Player {\n', '        uint256 miningWarRound;\n', '        uint256 noJoinAirdrop; \n', '        uint256 lastDayJoin;\n', '    }\n', '    struct Airdrop {\n', '        uint256 day;\n', '        uint256 prizeCrystal;\n', '    }\n', '    event AirdropPrize(\n', '        address playerJoin,\n', '        uint256 crystalBonus,\n', '        uint256 noJoinAirdrop,\n', '        uint256 noDayStartMiningWar\n', '    );\n', '\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        // set interface main contract\n', '        setMiningWarInterface(0x1b002cd1ba79dfad65e8abfbb3a97826e4960fe5);\n', '\n', '        initAirdrop();\n', '    }\n', '    function initAirdrop() private {\n', '        //                    day       prize crystals\n', '        airdrops[0] = Airdrop(1,            5000);   \n', '        airdrops[1] = Airdrop(2,            10000);   \n', '        airdrops[2] = Airdrop(3,            20000);   \n', '        airdrops[3] = Airdrop(4,            40000);   \n', '        airdrops[4] = Airdrop(5,            60000);   \n', '        airdrops[5] = Airdrop(6,            100000);   \n', '        airdrops[6] = Airdrop(7,            200000);   \n', '    }\n', '    /** \n', "    * @dev MainContract used this function to verify game's contract\n", '    */\n', '    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\n', '    {\n', '    \t_isContractMiniGame = true;\n', '    }\n', '    function isAirdropContract() public pure returns(bool)\n', '    {\n', '        return true;\n', '    }\n', '    function setAirdropPrize(uint256 idx, uint256 value) public \n', '    {\n', '       require( administrator == msg.sender );\n', '       airdrops[idx].prizeCrystal = value; \n', '    }\n', '     function setMiningWarInterface(address _addr) public \n', '    {\n', '        require( administrator == msg.sender );\n', '        \n', '        CryptoMiningWarInterface miningWarInterface = CryptoMiningWarInterface(_addr);\n', '\n', '        require(miningWarInterface.isMiningWarContract() == true);\n', '        \n', '        miningWarAddress = _addr;\n', '        \n', '        MiningWar = miningWarInterface;\n', '    }\n', '\n', '    function setupMiniGame(uint256 /*_miningWarRoundNumber*/, uint256 /*_miningWarDeadline*/ ) public pure\n', '    {\n', '\n', '    }\n', '\n', '    function joinAirdrop() public \n', '    {   \n', '        require(tx.origin == msg.sender);\n', '        require(MiningWar.deadline() > now);\n', '\n', '        Player storage p = players[msg.sender];\n', '        \n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '\n', '        if (noDayEndMiningWar > 7) revert();\n', '\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', ' \n', '        if (p.miningWarRound != miningWarRound) {\n', '            p.noJoinAirdrop = 1;\n', '            p.miningWarRound= miningWarRound;\n', '        } else if (p.lastDayJoin >= noDayStartMiningWar) {\n', '            revert();\n', '        } else {\n', '            p.noJoinAirdrop += 1;\n', '        }\n', '        p.lastDayJoin = noDayStartMiningWar;\n', '\n', '        airdropPrize(msg.sender);\n', '    }\n', '\n', '    function airdropPrize(address _addr) private\n', '    {\n', '       Player memory p = players[_addr];\n', '       \n', '       uint256 prizeCrystal = 0;\n', '       if (p.lastDayJoin > 0 && p.lastDayJoin <= 7)\n', '           prizeCrystal = airdrops[p.lastDayJoin - 1].prizeCrystal;\n', '       if (p.noJoinAirdrop >= 7) \n', '           prizeCrystal = SafeMath.add(prizeCrystal, BONUS_CRYSTAL);  \n', '       if (prizeCrystal != 0)\n', '           MiningWar.addCrystal(_addr, prizeCrystal);\n', '\n', '       emit AirdropPrize(_addr, prizeCrystal, p.noJoinAirdrop, p.lastDayJoin);\n', '    }\n', '    function getData(address _addr) public view returns(uint256 miningWarRound, uint256 noJoinAirdrop, uint256 lastDayJoin, uint256 nextTimeAirdropJoin)\n', '    {\n', '         Player memory p = players[_addr];\n', '\n', '         miningWarRound = p.miningWarRound;\n', '         noJoinAirdrop  = p.noJoinAirdrop;\n', '         lastDayJoin    = p.lastDayJoin;\n', '         nextTimeAirdropJoin = getNextTimeAirdropJoin(_addr);\n', '\n', '        if (miningWarRound != MiningWar.roundNumber()) {\n', '            noJoinAirdrop = 0;\n', '            lastDayJoin   = 0;\n', '        }   \n', '    }\n', '    function getNextCrystalReward(address _addr) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeStartMiningWar  = SafeMath.sub(MiningWar.deadline(), ROUND_TIME_MINING_WAR); \n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', '\n', '        if (noDayStartMiningWar > 7) return 0;\n', '        if (p.lastDayJoin < noDayStartMiningWar) return airdrops[noDayStartMiningWar - 1].prizeCrystal; \n', '        return airdrops[noDayStartMiningWar].prizeCrystal;\n', '    }\n', '    function getNextTimeAirdropJoin(address _addr) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '\n', '        uint256 miningWarRound      = MiningWar.roundNumber();\n', '        uint256 timeStartMiningWar  = SafeMath.sub(MiningWar.deadline(), ROUND_TIME_MINING_WAR); \n', '        uint256 timeEndMiningWar    = MiningWar.deadline() - now;\n', '        uint256 noDayEndMiningWar   = SafeMath.div(timeEndMiningWar, TIME_DAY);\n', '\n', '        uint256 noDayStartMiningWar = SafeMath.sub(7, noDayEndMiningWar);\n', '\n', '        if (p.miningWarRound != miningWarRound) return 0;\n', '\n', '        if (p.lastDayJoin < noDayStartMiningWar) return 0;\n', '\n', '        return SafeMath.add(SafeMath.mul(noDayStartMiningWar, TIME_DAY), timeStartMiningWar);\n', '    }\n', '}']
