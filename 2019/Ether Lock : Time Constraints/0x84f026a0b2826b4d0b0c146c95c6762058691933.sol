['pragma solidity ^0.4.24;\n', '\n', 'interface CitizenInterface {\n', '    /*----------  READ FUNCTIONS  ----------*/\n', '    function getUsername(address _address) public view returns (string);\n', '    function getRef(address _address) public view returns (address);\n', '}\n', '\n', 'interface F2mInterface {\n', '    function pushDividends() public payable;\n', '}\n', '\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Helper {\n', '    uint256 constant public GAS_COST = 0.002 ether;\n', '    uint256 constant public MAX_BLOCK_DISTANCE = 254;\n', '    uint256 constant public ZOOM = 1000000000;\n', '\n', '    function getKeyBlockNr(uint256 _estKeyBlockNr)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        require(block.number > _estKeyBlockNr, "blockHash not avaiable");\n', '        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\n', '        return _estKeyBlockNr + jump;\n', '    }\n', '\n', '    function getSeed(uint256 _keyBlockNr)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Key Block not mined atm\n', '        if (block.number <= _keyBlockNr) return block.number;\n', '        return uint256(blockhash(_keyBlockNr));\n', '    }\n', '\n', '    function getWinTeam(\n', '        uint256 _seed,\n', '        uint256 _trueAmount,\n', '        uint256 _falseAmount\n', '    )\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 _sum = _trueAmount + _falseAmount;\n', '        if (_sum == 0) return true;\n', '        return (_seed % _sum) < _trueAmount;\n', '    }\n', '\n', '    function getWinningPerWei(\n', '        uint256 _winTeam,\n', '        uint256 _lostTeam\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return _lostTeam * ZOOM / _winTeam;\n', '    }\n', '\n', '    function getMin(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract SimpleDice is Helper{\n', '    using SafeMath for uint256;\n', '\n', '    event Payment(address indexed _winner, uint _amount, bool _success);\n', '\n', '    modifier onlyDevTeam() {\n', '        require(msg.sender == devTeam, "only development team");\n', '        _;\n', '    }\n', '\n', '    modifier betable() {\n', '        uint256 _keyBlock = rounds[curRoundId].keyBlock;\n', '        require(msg.value >= MIN_BET, "betAmount too low");\n', '        require(block.number <= _keyBlock, "round locked");\n', '        _;\n', '    }\n', '\n', '    modifier roundLocked() {\n', '        uint256 _keyBlock = rounds[curRoundId].keyBlock;\n', '        require(block.number > _keyBlock, "still betable");\n', '        _;\n', '    }\n', '\n', '    struct Bet{\n', '        address buyer;\n', '        uint256 amount;\n', '    }\n', '\n', '    struct Round {\n', '        mapping(bool => Bet[]) bets;\n', '        mapping(bool => uint256) betSum;\n', '\n', '        uint256 keyBlock;\n', '        bool finalized;\n', '        bool winTeam;\n', '        uint256 cashoutFrom;\n', '        uint256 winningPerWei; // Zoomed\n', '    }\n', '    \n', '    uint256 constant public TAXED_PERCENT = 95;\n', '    uint256 constant public BLOCK_TIME = 15;\n', '    uint256 constant public DURATION = 300; // 5 min.\n', '    uint256 constant public MIN_BET = 0.05 ether;\n', '    uint256 constant public F2M_PERCENT = 10;\n', '    uint256 constant public MAX_ROUND = 888888888;\n', '\n', '    uint256 public MAX_CASHOUT_PER_BLOCK = 100;\n', '\n', '    address public devTeam;\n', '    F2mInterface public f2mContract;\n', '    uint256 public fund;\n', '\n', '    uint256 public curRoundId;\n', '    mapping(uint256 => Round) public rounds;\n', '    mapping(address => mapping(uint256 => mapping(bool => uint256))) pRoundBetSum;\n', '\n', '    CitizenInterface public citizenContract;\n', '\n', '    constructor(address _devTeam, address _citizen) public {\n', '        devTeam = _devTeam;\n', '        citizenContract = CitizenInterface(_citizen);\n', '        initRound();\n', '    }\n', '\n', '    function devTeamWithdraw()\n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(fund > 0, "nothing to withdraw");\n', '        uint256 _toF2m = fund / 100 * F2M_PERCENT;\n', '        uint256 _toDevTeam = fund - _toF2m;\n', '        fund = 0;\n', '        f2mContract.pushDividends.value(_toF2m)();\n', '        devTeam.transfer(_toDevTeam);\n', '    }\n', '\n', '    function initRound()\n', '        private\n', '    {\n', '        curRoundId++;\n', '        Round memory _round;\n', '        _round.keyBlock = MAX_ROUND; // block.number + 1 + DURATION / BLOCK_TIME;\n', '        rounds[curRoundId] = _round;\n', '    }\n', '\n', '    function finalize()\n', '        private\n', '    {\n', '        uint256 _keyBlock = getKeyBlockNr(rounds[curRoundId].keyBlock);\n', '        uint256 _seed = getSeed(_keyBlock);\n', '        bool _winTeam = _seed % 2 == 0;\n', '        //getWinTeam(_seed, rounds[curRoundId].betSum[true], rounds[curRoundId].betSum[false]);\n', '        rounds[curRoundId].winTeam = _winTeam;\n', '        // winAmount Per Wei zoomed \n', '        rounds[curRoundId].winningPerWei = getWinningPerWei(rounds[curRoundId].betSum[_winTeam], rounds[curRoundId].betSum[!_winTeam]);\n', '        rounds[curRoundId].finalized = true;\n', '        fund = address(this).balance - rounds[curRoundId].betSum[_winTeam] - rounds[curRoundId].betSum[!_winTeam];\n', '    }\n', '\n', '    function payment(\n', '        address _buyer,\n', '        uint256 _winAmount\n', '    ) \n', '        private\n', '    {\n', '        bool success = _buyer.send(_winAmount);\n', '        emit Payment(_buyer, _winAmount, success);\n', '    }\n', '\n', '    function distribute()\n', '        private\n', '    {\n', '        address _buyer;\n', '        uint256 _betAmount;\n', '        uint256 _winAmount;\n', '        uint256 _from = rounds[curRoundId].cashoutFrom;\n', '        bool _winTeam = rounds[curRoundId].winTeam;\n', '        uint256 _teamBets = rounds[curRoundId].bets[_winTeam].length;\n', '        uint256 _to = getMin(_teamBets, _from + MAX_CASHOUT_PER_BLOCK);\n', '        uint256 _perWei = rounds[curRoundId].winningPerWei;\n', '        \n', '        //GAS BURNING \n', '        while (_from < _to) {\n', '            _buyer = rounds[curRoundId].bets[_winTeam][_from].buyer;\n', '            _betAmount = rounds[curRoundId].bets[_winTeam][_from].amount;\n', '            _winAmount = _betAmount / ZOOM * _perWei + _betAmount;\n', '            payment(_buyer, _winAmount);\n', '            _from++;\n', '        }\n', '        rounds[curRoundId].cashoutFrom = _from;\n', '    }\n', '\n', '    function isDistributed()\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        bool _winTeam = rounds[curRoundId].winTeam;\n', '        return (rounds[curRoundId].cashoutFrom == rounds[curRoundId].bets[_winTeam].length);\n', '    }\n', '\n', '    function endRound()\n', '        public\n', '        roundLocked()\n', '    {\n', '        if (!rounds[curRoundId].finalized) finalize();\n', '        distribute();\n', '        if (isDistributed()) initRound();\n', '    }\n', '\n', '    // _team = {true, false}\n', '    function bet(\n', '        bool _team\n', '    )\n', '        public\n', '        payable\n', '        betable()\n', '    {\n', '        // active timer if both Teams got player(s)\n', '        if (rounds[curRoundId].betSum[_team] == 0 && rounds[curRoundId].betSum[!_team] > 0) \n', '            rounds[curRoundId].keyBlock = block.number + 1 + DURATION / BLOCK_TIME;\n', '        address _sender = msg.sender;\n', '        uint256 _betAmount = (msg.value).sub(GAS_COST);\n', '        address _ref = getRef(msg.sender);\n', '        _ref.transfer(_betAmount / 100);\n', '        _betAmount = _betAmount / 100 * TAXED_PERCENT;\n', '        \n', '        Bet memory _bet = Bet(_sender, _betAmount);\n', '        rounds[curRoundId].bets[_team].push(_bet);\n', '        rounds[curRoundId].betSum[_team] += _betAmount;\n', '\n', '        pRoundBetSum[_sender][curRoundId][_team] += _betAmount;\n', '    }\n', '\n', '    // BACKEND FUNCTION\n', '\n', '    function distributeSetting(uint256 _limit)\n', '        public\n', '        onlyDevTeam()\n', '    {\n', '        require(_limit >= 1, "cashout at least for one each tx");\n', '        MAX_CASHOUT_PER_BLOCK = _limit;\n', '    }\n', '\n', '    function setF2mContract(address _address)\n', '        public\n', '    {\n', '        require(address(f2mContract) == 0x0, "already set");\n', '        f2mContract = F2mInterface(_address);\n', '    }\n', '\n', '    // READING FUNCTIONS\n', '\n', '    // if return true\n', '    // Backend : call endRound()\n', '    function isLocked() \n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return rounds[curRoundId].keyBlock <= block.number;\n', '    }\n', '\n', '    function getRef(address _address)\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        address _ref = citizenContract.getRef(_address);\n', '        return _ref;\n', '    }\n', '\n', '    function getUsername(address _address)\n', '        public\n', '        view\n', '        returns (string)\n', '    {\n', '        return citizenContract.getUsername(_address);\n', '    }\n', '\n', '    function getBlockDist()\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        if (rounds[curRoundId].keyBlock == MAX_ROUND) return MAX_ROUND;\n', '        if (rounds[curRoundId].keyBlock <= block.number) return 0;\n', '        return rounds[curRoundId].keyBlock - block.number;\n', '\n', '    }\n', '\n', '    function getRoundResult(uint256 _rId)\n', '        public\n', '        view\n', '        returns(\n', '            uint256, // _trueAmount,\n', '            uint256, // _falseAmount,\n', '            uint256, // _trueBets\n', '            uint256, // _falseBets\n', '            uint256, // curBlock\n', '            uint256, // keyBlock\n', '            bool,\n', '            bool // winTeam\n', '        )\n', '    {\n', '        Round storage _round = rounds[_rId];\n', '        return(\n', '            _round.betSum[true],\n', '            _round.betSum[false],\n', '            _round.bets[true].length,\n', '            _round.bets[false].length,\n', '            block.number,\n', '            _round.keyBlock,\n', '            _round.finalized,\n', '            _round.winTeam\n', '        );\n', '    }\n', '\n', '    function getCurRoundResult()\n', '        public\n', '        view\n', '        returns(\n', '            uint256, // _trueAmount\n', '            uint256, // _falseAmount\n', '            uint256, // _trueBets\n', '            uint256, // _falseBets\n', '            uint256, // curBlock\n', '            uint256, // keyBlock\n', '            bool, // finalized\n', '            bool // winTeam\n', '        )\n', '    {\n', '        Round storage _round = rounds[curRoundId];\n', '        return(\n', '            _round.betSum[true],\n', '            _round.betSum[false],\n', '            _round.bets[true].length,\n', '            _round.bets[false].length,\n', '            block.number,\n', '            _round.keyBlock,\n', '            _round.finalized,\n', '            _round.winTeam\n', '        );\n', '    }\n', '\n', '    function getPRoundBetSum(address _player, uint256 _rId)\n', '        public\n', '        view\n', '        returns(string, uint256[2])\n', '    {\n', '        string memory _username = getUsername(_player);\n', '        return (_username, [pRoundBetSum[_player][_rId][true], pRoundBetSum[_player][_rId][false]]);\n', '    }\n', '\n', '    function getRoundBetById(uint256 _rId, bool _team, uint256 _id)\n', '        public\n', '        view\n', '        returns(address, string, uint256)\n', '    {\n', '        address _address = rounds[_rId].bets[_team][_id].buyer;\n', '        string memory _username = getUsername(_address);\n', '        return (_address, _username, rounds[_rId].bets[_team][_id].amount);\n', '    }\n', '}']