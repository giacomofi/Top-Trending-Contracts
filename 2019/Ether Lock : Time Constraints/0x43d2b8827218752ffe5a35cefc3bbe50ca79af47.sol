['pragma solidity ^0.4.25;\n', '\n', '/*\n', '* CryptoMiningWar - Blockchain-based strategy game\n', '* Author: InspiGames\n', '* Website: https://cryptominingwar.github.io/\n', '*/\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', 'contract CryptoEngineerInterface {\n', '    uint256 public prizePool = 0;\n', '\n', '    function subVirus(address /*_addr*/, uint256 /*_value*/) public {}\n', '    function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public {} \n', '    function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {}\n', '    function isEngineerContract() external pure returns(bool) {}\n', '}\n', 'contract CryptoMiningWarInterface {\n', '    uint256 public deadline; \n', '    function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public {}\n', '    function isMiningWarContract() external pure returns(bool) {}\n', '}\n', 'interface MiniGameInterface {\n', '     function isContractMiniGame() external pure returns( bool _isContractMiniGame );\n', '}\n', 'contract CrystalDeposit {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public administrator;\n', '\t// mini game\n', '    uint256 public HALF_TIME = 48 hours;\n', '    uint256 public MIN_TIME_WITH_DEADLINE = 12 hours;\n', '    uint256 public round = 0;\n', '    CryptoEngineerInterface public Engineer;\n', '    CryptoMiningWarInterface public MiningWar;\n', '    // mining war info\n', '    address miningWarAddress;\n', '    uint256 miningWarDeadline;\n', '    uint256 constant private CRTSTAL_MINING_PERIOD = 86400;\n', '    /** \n', '    * @dev mini game information\n', '    */\n', '    mapping(uint256 => Game) public games;\n', '    /** \n', '    * @dev player information\n', '    */\n', '    mapping(address => Player) public players;\n', '\n', '    mapping(address => bool)   public miniGames;\n', '   \n', '    struct Game {\n', '        uint256 round;\n', '        uint256 crystals;\n', '        uint256 prizePool;\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        bool ended; \n', '    }\n', '    struct Player {\n', '        uint256 currentRound;\n', '        uint256 lastRound;\n', '        uint256 reward;\n', '        uint256 share; // your crystals share in current round \n', '    }\n', '    event EndRound(uint256 round, uint256 crystals, uint256 prizePool, uint256 startTime, uint256 endTime);\n', '    event Deposit(address player, uint256 currentRound, uint256 deposit, uint256 currentShare);\n', '    modifier isAdministrator()\n', '    {\n', '        require(msg.sender == administrator);\n', '        _;\n', '    }\n', '    modifier disableContract()\n', '    {\n', '        require(tx.origin == msg.sender);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        // set interface contract\n', '        setMiningWarInterface(0x1b002cd1ba79dfad65e8abfbb3a97826e4960fe5);\n', '        setEngineerInterface(0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2);\n', '    }\n', '    function () public payable\n', '    {\n', '        \n', '    }\n', '    /** \n', '    * @dev MainContract used this function to verify game&#39;s contract\n', '    */\n', '    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\n', '    {\n', '    \t_isContractMiniGame = true;\n', '    }\n', '    function isDepositContract() public pure returns(bool)\n', '    {\n', '        return true;\n', '    }\n', '    function upgrade(address addr) public isAdministrator\n', '    {\n', '        selfdestruct(addr);\n', '    }\n', '    function setContractsMiniGame( address _addr ) public isAdministrator \n', '    {\n', '        MiniGameInterface MiniGame = MiniGameInterface( _addr );\n', '        if( MiniGame.isContractMiniGame() == false ) { revert(); }\n', '\n', '        miniGames[_addr] = true;\n', '    }\n', '    /**\n', '    * @dev remove mini game contract from main contract\n', '    * @param _addr mini game contract address\n', '    */\n', '    function removeContractMiniGame(address _addr) public isAdministrator\n', '    {\n', '        miniGames[_addr] = false;\n', '    }\n', '    /** \n', '    * @dev Main Contract call this function to setup mini game.\n', '    */\n', '    function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 _miningWarDeadline ) public\n', '    {\n', '        require(msg.sender == miningWarAddress);\n', '        miningWarDeadline = _miningWarDeadline;\n', '    }\n', '    function setMiningWarInterface(address _addr) public isAdministrator\n', '    {\n', '        CryptoMiningWarInterface miningWarInterface = CryptoMiningWarInterface(_addr);\n', '\n', '        require(miningWarInterface.isMiningWarContract() == true);\n', '        \n', '        miningWarAddress = _addr;\n', '        \n', '        MiningWar = miningWarInterface;\n', '    }\n', '    function setEngineerInterface(address _addr) public isAdministrator\n', '    {\n', '        CryptoEngineerInterface engineerInterface = CryptoEngineerInterface(_addr);\n', '        \n', '        require(engineerInterface.isEngineerContract() == true);\n', '\n', '        Engineer = engineerInterface;\n', '    }\n', '    /**\n', '    * @dev start the mini game\n', '    */\n', '     function startGame() public isAdministrator\n', '    {\n', '        // require(miningWarDeadline == 0);\n', '\n', '        miningWarDeadline = MiningWar.deadline();\n', '\n', '        games[round].ended = true;\n', '    \n', '        startRound();\n', '    }\n', '    function startRound() private\n', '    {\n', '        require(games[round].ended == true);\n', '\n', '        uint256 crystalsLastRound = games[round].crystals;\n', '        uint256 prizePoolLastRound= games[round].prizePool; \n', '\n', '        round = round + 1;\n', '\n', '        uint256 startTime = now;\n', '\n', '        if (miningWarDeadline < SafeMath.add(startTime, MIN_TIME_WITH_DEADLINE)) startTime = miningWarDeadline;\n', '\n', '        uint256 endTime = startTime + HALF_TIME;\n', '        // claim 5% of current prizePool as rewards.\n', '        uint256 engineerPrizePool = getEngineerPrizePool();\n', '        \n', '        uint256 prizePool = SafeMath.div(SafeMath.mul(engineerPrizePool, 5),100);\n', '\n', '        Engineer.claimPrizePool(address(this), prizePool);\n', '        \n', '        if (crystalsLastRound == 0) prizePool = SafeMath.add(prizePool, prizePoolLastRound);\n', '\n', '        games[round] = Game(round, 0, prizePool, startTime, endTime, false);\n', '    }\n', '    function endRound() private\n', '    {\n', '        require(games[round].ended == false);\n', '        require(games[round].endTime <= now);\n', '\n', '        Game storage g = games[round];\n', '        g.ended = true;\n', '        \n', '        startRound();\n', '\n', '        emit EndRound(g.round, g.crystals, g.prizePool, g.startTime, g.endTime);\n', '    }\n', '    /**\n', '    * @dev player send crystals to the pot\n', '    */\n', '    function share(uint256 _value) public disableContract\n', '    {\n', '        require(games[round].ended == false);\n', '        require(games[round].startTime <= now);\n', '        require(_value >= 1);\n', '\n', '        MiningWar.subCrystal(msg.sender, _value); \n', '\n', '        if (games[round].endTime <= now) endRound();\n', '        \n', '        updateReward(msg.sender);\n', '        \n', '        Game storage g = games[round];\n', '        uint256 _share = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);\n', '        g.crystals = SafeMath.add(g.crystals, _share);\n', '        Player storage p = players[msg.sender];\n', '        if (p.currentRound == round) {\n', '            p.share = SafeMath.add(p.share, _share);\n', '        } else {\n', '            p.share = _share;\n', '            p.currentRound = round;\n', '        }\n', '\n', '        emit Deposit(msg.sender, p.currentRound, _value, p.share); \n', '    }\n', '    function getCurrentReward(address _addr) public view returns(uint256 _currentReward)\n', '    {\n', '        Player memory p = players[_addr];\n', '        _currentReward = p.reward;\n', '        _currentReward += calculateReward(_addr, p.currentRound);\n', '    }\n', '    function withdrawReward(address _addr) public \n', '    {\n', '        // require(miniGames[msg.sender] == true);\n', '\n', '        if (games[round].endTime <= now) endRound();\n', '        \n', '        updateReward(_addr);\n', '        Player storage p = players[_addr];\n', '        uint256 balance  = p.reward; \n', '        if (address(this).balance >= balance && balance > 0) {\n', '             _addr.transfer(balance);\n', '            // update player\n', '            p.reward = 0;     \n', '        }\n', '    }\n', '    function updateReward(address _addr) private\n', '    {\n', '        Player storage p = players[_addr];\n', '        \n', '        if ( \n', '            games[p.currentRound].ended == true &&\n', '            p.lastRound < p.currentRound\n', '            ) {\n', '            p.reward = SafeMath.add(p.reward, calculateReward(_addr, p.currentRound));\n', '            p.lastRound = p.currentRound;\n', '        }\n', '    }\n', '    function getData(address _addr) \n', '    public\n', '    view\n', '    returns(\n', '        // current game\n', '        uint256 _prizePool,\n', '        uint256 _crystals,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        // player info\n', '        uint256 _reward,\n', '        uint256 _share\n', '    ) {\n', '         (_prizePool, _crystals, _startTime, _endTime) = getCurrentGame();\n', '         (_reward, _share)                 = getPlayerData(_addr);         \n', '    }\n', '      /**\n', '    * @dev calculate reward\n', '    */\n', '    function calculateReward(address _addr, uint256 _round) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '        Game memory g = games[_round];\n', '        if (g.endTime > now) return 0;\n', '        if (g.crystals == 0) return 0;\n', '        if (p.lastRound >= _round) return 0; \n', '        return SafeMath.div(SafeMath.mul(g.prizePool, p.share), g.crystals);\n', '    }\n', '    function getCurrentGame() private view returns(uint256 _prizePool, uint256 _crystals, uint256 _startTime, uint256 _endTime)\n', '    {\n', '        Game memory g = games[round];\n', '        _prizePool = g.prizePool;\n', '        _crystals  = g.crystals;\n', '        _startTime = g.startTime;\n', '        _endTime   = g.endTime;\n', '    }\n', '    function getPlayerData(address _addr) private view returns(uint256 _reward, uint256 _share)\n', '    {\n', '        Player memory p = players[_addr];\n', '        _reward           = p.reward;\n', '        if (p.currentRound == round) _share = players[_addr].share; \n', '        if (p.currentRound != p.lastRound) _reward += calculateReward(_addr, p.currentRound);\n', '    }\n', '    function getEngineerPrizePool() private view returns(uint256)\n', '    {\n', '        return Engineer.prizePool();\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '/*\n', '* CryptoMiningWar - Blockchain-based strategy game\n', '* Author: InspiGames\n', '* Website: https://cryptominingwar.github.io/\n', '*/\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', 'contract CryptoEngineerInterface {\n', '    uint256 public prizePool = 0;\n', '\n', '    function subVirus(address /*_addr*/, uint256 /*_value*/) public {}\n', '    function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public {} \n', '    function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {}\n', '    function isEngineerContract() external pure returns(bool) {}\n', '}\n', 'contract CryptoMiningWarInterface {\n', '    uint256 public deadline; \n', '    function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public {}\n', '    function isMiningWarContract() external pure returns(bool) {}\n', '}\n', 'interface MiniGameInterface {\n', '     function isContractMiniGame() external pure returns( bool _isContractMiniGame );\n', '}\n', 'contract CrystalDeposit {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public administrator;\n', '\t// mini game\n', '    uint256 public HALF_TIME = 48 hours;\n', '    uint256 public MIN_TIME_WITH_DEADLINE = 12 hours;\n', '    uint256 public round = 0;\n', '    CryptoEngineerInterface public Engineer;\n', '    CryptoMiningWarInterface public MiningWar;\n', '    // mining war info\n', '    address miningWarAddress;\n', '    uint256 miningWarDeadline;\n', '    uint256 constant private CRTSTAL_MINING_PERIOD = 86400;\n', '    /** \n', '    * @dev mini game information\n', '    */\n', '    mapping(uint256 => Game) public games;\n', '    /** \n', '    * @dev player information\n', '    */\n', '    mapping(address => Player) public players;\n', '\n', '    mapping(address => bool)   public miniGames;\n', '   \n', '    struct Game {\n', '        uint256 round;\n', '        uint256 crystals;\n', '        uint256 prizePool;\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        bool ended; \n', '    }\n', '    struct Player {\n', '        uint256 currentRound;\n', '        uint256 lastRound;\n', '        uint256 reward;\n', '        uint256 share; // your crystals share in current round \n', '    }\n', '    event EndRound(uint256 round, uint256 crystals, uint256 prizePool, uint256 startTime, uint256 endTime);\n', '    event Deposit(address player, uint256 currentRound, uint256 deposit, uint256 currentShare);\n', '    modifier isAdministrator()\n', '    {\n', '        require(msg.sender == administrator);\n', '        _;\n', '    }\n', '    modifier disableContract()\n', '    {\n', '        require(tx.origin == msg.sender);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        administrator = msg.sender;\n', '        // set interface contract\n', '        setMiningWarInterface(0x1b002cd1ba79dfad65e8abfbb3a97826e4960fe5);\n', '        setEngineerInterface(0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2);\n', '    }\n', '    function () public payable\n', '    {\n', '        \n', '    }\n', '    /** \n', "    * @dev MainContract used this function to verify game's contract\n", '    */\n', '    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\n', '    {\n', '    \t_isContractMiniGame = true;\n', '    }\n', '    function isDepositContract() public pure returns(bool)\n', '    {\n', '        return true;\n', '    }\n', '    function upgrade(address addr) public isAdministrator\n', '    {\n', '        selfdestruct(addr);\n', '    }\n', '    function setContractsMiniGame( address _addr ) public isAdministrator \n', '    {\n', '        MiniGameInterface MiniGame = MiniGameInterface( _addr );\n', '        if( MiniGame.isContractMiniGame() == false ) { revert(); }\n', '\n', '        miniGames[_addr] = true;\n', '    }\n', '    /**\n', '    * @dev remove mini game contract from main contract\n', '    * @param _addr mini game contract address\n', '    */\n', '    function removeContractMiniGame(address _addr) public isAdministrator\n', '    {\n', '        miniGames[_addr] = false;\n', '    }\n', '    /** \n', '    * @dev Main Contract call this function to setup mini game.\n', '    */\n', '    function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 _miningWarDeadline ) public\n', '    {\n', '        require(msg.sender == miningWarAddress);\n', '        miningWarDeadline = _miningWarDeadline;\n', '    }\n', '    function setMiningWarInterface(address _addr) public isAdministrator\n', '    {\n', '        CryptoMiningWarInterface miningWarInterface = CryptoMiningWarInterface(_addr);\n', '\n', '        require(miningWarInterface.isMiningWarContract() == true);\n', '        \n', '        miningWarAddress = _addr;\n', '        \n', '        MiningWar = miningWarInterface;\n', '    }\n', '    function setEngineerInterface(address _addr) public isAdministrator\n', '    {\n', '        CryptoEngineerInterface engineerInterface = CryptoEngineerInterface(_addr);\n', '        \n', '        require(engineerInterface.isEngineerContract() == true);\n', '\n', '        Engineer = engineerInterface;\n', '    }\n', '    /**\n', '    * @dev start the mini game\n', '    */\n', '     function startGame() public isAdministrator\n', '    {\n', '        // require(miningWarDeadline == 0);\n', '\n', '        miningWarDeadline = MiningWar.deadline();\n', '\n', '        games[round].ended = true;\n', '    \n', '        startRound();\n', '    }\n', '    function startRound() private\n', '    {\n', '        require(games[round].ended == true);\n', '\n', '        uint256 crystalsLastRound = games[round].crystals;\n', '        uint256 prizePoolLastRound= games[round].prizePool; \n', '\n', '        round = round + 1;\n', '\n', '        uint256 startTime = now;\n', '\n', '        if (miningWarDeadline < SafeMath.add(startTime, MIN_TIME_WITH_DEADLINE)) startTime = miningWarDeadline;\n', '\n', '        uint256 endTime = startTime + HALF_TIME;\n', '        // claim 5% of current prizePool as rewards.\n', '        uint256 engineerPrizePool = getEngineerPrizePool();\n', '        \n', '        uint256 prizePool = SafeMath.div(SafeMath.mul(engineerPrizePool, 5),100);\n', '\n', '        Engineer.claimPrizePool(address(this), prizePool);\n', '        \n', '        if (crystalsLastRound == 0) prizePool = SafeMath.add(prizePool, prizePoolLastRound);\n', '\n', '        games[round] = Game(round, 0, prizePool, startTime, endTime, false);\n', '    }\n', '    function endRound() private\n', '    {\n', '        require(games[round].ended == false);\n', '        require(games[round].endTime <= now);\n', '\n', '        Game storage g = games[round];\n', '        g.ended = true;\n', '        \n', '        startRound();\n', '\n', '        emit EndRound(g.round, g.crystals, g.prizePool, g.startTime, g.endTime);\n', '    }\n', '    /**\n', '    * @dev player send crystals to the pot\n', '    */\n', '    function share(uint256 _value) public disableContract\n', '    {\n', '        require(games[round].ended == false);\n', '        require(games[round].startTime <= now);\n', '        require(_value >= 1);\n', '\n', '        MiningWar.subCrystal(msg.sender, _value); \n', '\n', '        if (games[round].endTime <= now) endRound();\n', '        \n', '        updateReward(msg.sender);\n', '        \n', '        Game storage g = games[round];\n', '        uint256 _share = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);\n', '        g.crystals = SafeMath.add(g.crystals, _share);\n', '        Player storage p = players[msg.sender];\n', '        if (p.currentRound == round) {\n', '            p.share = SafeMath.add(p.share, _share);\n', '        } else {\n', '            p.share = _share;\n', '            p.currentRound = round;\n', '        }\n', '\n', '        emit Deposit(msg.sender, p.currentRound, _value, p.share); \n', '    }\n', '    function getCurrentReward(address _addr) public view returns(uint256 _currentReward)\n', '    {\n', '        Player memory p = players[_addr];\n', '        _currentReward = p.reward;\n', '        _currentReward += calculateReward(_addr, p.currentRound);\n', '    }\n', '    function withdrawReward(address _addr) public \n', '    {\n', '        // require(miniGames[msg.sender] == true);\n', '\n', '        if (games[round].endTime <= now) endRound();\n', '        \n', '        updateReward(_addr);\n', '        Player storage p = players[_addr];\n', '        uint256 balance  = p.reward; \n', '        if (address(this).balance >= balance && balance > 0) {\n', '             _addr.transfer(balance);\n', '            // update player\n', '            p.reward = 0;     \n', '        }\n', '    }\n', '    function updateReward(address _addr) private\n', '    {\n', '        Player storage p = players[_addr];\n', '        \n', '        if ( \n', '            games[p.currentRound].ended == true &&\n', '            p.lastRound < p.currentRound\n', '            ) {\n', '            p.reward = SafeMath.add(p.reward, calculateReward(_addr, p.currentRound));\n', '            p.lastRound = p.currentRound;\n', '        }\n', '    }\n', '    function getData(address _addr) \n', '    public\n', '    view\n', '    returns(\n', '        // current game\n', '        uint256 _prizePool,\n', '        uint256 _crystals,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        // player info\n', '        uint256 _reward,\n', '        uint256 _share\n', '    ) {\n', '         (_prizePool, _crystals, _startTime, _endTime) = getCurrentGame();\n', '         (_reward, _share)                 = getPlayerData(_addr);         \n', '    }\n', '      /**\n', '    * @dev calculate reward\n', '    */\n', '    function calculateReward(address _addr, uint256 _round) public view returns(uint256)\n', '    {\n', '        Player memory p = players[_addr];\n', '        Game memory g = games[_round];\n', '        if (g.endTime > now) return 0;\n', '        if (g.crystals == 0) return 0;\n', '        if (p.lastRound >= _round) return 0; \n', '        return SafeMath.div(SafeMath.mul(g.prizePool, p.share), g.crystals);\n', '    }\n', '    function getCurrentGame() private view returns(uint256 _prizePool, uint256 _crystals, uint256 _startTime, uint256 _endTime)\n', '    {\n', '        Game memory g = games[round];\n', '        _prizePool = g.prizePool;\n', '        _crystals  = g.crystals;\n', '        _startTime = g.startTime;\n', '        _endTime   = g.endTime;\n', '    }\n', '    function getPlayerData(address _addr) private view returns(uint256 _reward, uint256 _share)\n', '    {\n', '        Player memory p = players[_addr];\n', '        _reward           = p.reward;\n', '        if (p.currentRound == round) _share = players[_addr].share; \n', '        if (p.currentRound != p.lastRound) _reward += calculateReward(_addr, p.currentRound);\n', '    }\n', '    function getEngineerPrizePool() private view returns(uint256)\n', '    {\n', '        return Engineer.prizePool();\n', '    }\n', '}']
