['pragma solidity ^0.5.1;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '    address payable public owner;\n', '    address payable public reclaimablePocket; //**this will hold any of this contract token that is sent to this contract by mistake, and can be claimed back\n', '    address payable public teamWallet;\n', '    constructor(address payable _reclaimablePocket, address payable _teamWallet) public {\n', '        owner = msg.sender;\n', '        reclaimablePocket = _reclaimablePocket;\n', '        teamWallet = _teamWallet;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyTeam {\n', '        require(msg.sender == teamWallet || msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address payable newOwner) onlyOwner public { owner = newOwner; }\n', '    function changeRecPocket(address payable _newRecPocket) onlyTeam public { reclaimablePocket = _newRecPocket;}\n', '    function changeTeamWallet(address payable _newTeamWallet) onlyOwner public { teamWallet = _newTeamWallet;}\n', '}\n', '\n', 'interface ERC20 {\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool); //3rd party transfer\n', '    function approve(address _spender, uint _value) external returns (bool); //set allowance\n', '    function allowance(address _owner, address _spender) external view returns (uint); //get allowance value\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value); //emits approval activities\n', '}\n', 'interface ERC223 {\n', '    function transfer(address _to, uint _value, bytes calldata _data) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', 'interface ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes calldata _data) external; }\n', '\n', 'contract Token is ERC20, ERC223, owned {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    string internal _symbol;\n', '    string internal _name;\n', '    uint256 internal _decimals = 18;\n', '    string public version = "1.0.0";\n', '    uint internal _totalSupply;\n', '    mapping (address => uint) internal _balanceOf;\n', '    mapping (address => mapping (address => uint)) internal _allowances;\n', '\n', '    //Configurables\n', '    uint256 public tokensSold = 0;\n', '    uint256 public remainingTokens;\n', '    //uint256 public teamReserve;\n', '    uint256 public buyPrice;    //eth per Token\n', '    \n', '    constructor(string memory name, string memory symbol, uint totalSupply) public {\n', '        _symbol = symbol;\n', '        _name = name;\n', '        _totalSupply = totalSupply * 10 ** uint256(_decimals);  // Update total supply with the decimal amount\n', '    }\n', '    \n', '    function name() public view returns (string memory) { return _name; }\n', '    function symbol() public view returns (string memory) { return _symbol; }\n', '    function decimals() public view returns (uint256) { return _decimals; }\n', '    function totalSupply() public view returns (uint) { return _totalSupply; }\n', '    function balanceOf(address _addr) public view returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    // To emit direct purchase of token transaction from contract.\n', '    event purchaseInvoice(address indexed _buyer, uint _tokenReceived, uint _weiSent, uint _weiCost, uint _weiReturned );\n', '}\n', '\n', 'contract SiBiCryptToken is Token {\n', '   \n', '    /**\n', '     * @dev enum of current crowd sale state\n', '     **/\n', '     enum Stages {none, icoStart, icoPaused, icoResumed, icoEnd} \n', '     Stages currentStage;\n', '    bool payingDividends;\n', '    uint256 freezeTimeStart;\n', '    uint256 constant freezePeriod = 1 * 1 days;\n', '    \n', '    function balanceOf(address _addr) public view returns (uint) {\n', '        return _balanceOf[_addr];\n', '    }\n', '    \n', '    modifier checkICOStatus(){\n', '        require(currentStage == Stages.icoPaused || currentStage == Stages.icoEnd, "Pls, try again after ICO");\n', '        _;\n', '    }\n', '    modifier isPayingDividends(){\n', '        if(payingDividends && now >= (freezeTimeStart+freezePeriod)){\n', '            payingDividends = false;\n', '        }\n', '        require(!payingDividends, "Dividends is being dispatch, pls try later");\n', '        _;\n', '    }\n', '    function payOutDividends() public onlyOwner returns(bool){\n', '        payingDividends = true;\n', '        freezeTimeStart = now;\n', '        return true;\n', '    }\n', '    event thirdPartyTransfer( address indexed _from, address indexed _to, uint _value, address indexed _sentBy ) ;\n', '    event returnedWei(address indexed _fromContract, address indexed _toSender, uint _value);\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        bytes memory empty ;\n', '        transfer(_to, _value, empty);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes memory _data) public returns (bool) {\n', '        _transfer(msg.sender, _to, _value);\n', '        if(isContract(_to)){\n', '            if(_to == address(this)){\n', '                _transfer(address(this), reclaimablePocket, _value);\n', '            }\n', '            else\n', '            {\n', '                ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                    _contract.tokenFallback(msg.sender, _value, _data);\n', '            }\n', '        }\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    function isContract(address _addr) public view returns (bool) {\n', '        uint codeSize;\n', '        assembly {\n', '            codeSize := extcodesize(_addr)\n', '        }\n', '        return codeSize > 0;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public checkICOStatus returns (bool) {\n', '        require (_value > 0 && _allowances[_from][msg.sender] >= _value, "insufficient allowance");\n', '        _transfer(_from, _to, _value);\n', '        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n', '        emit thirdPartyTransfer(_from, _to, _value, msg.sender);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal checkICOStatus isPayingDividends {\n', '        require(_to != address(0x0), "invalid \'to\' address"); // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_balanceOf[_from] >= _value, "insufficient funds"); // Check if the sender has enough\n', '        require(_balanceOf[_to] + _value > _balanceOf[_to], "overflow err"); // Check for overflows\n', '        uint previousBalances = _balanceOf[_from] + _balanceOf[_to]; // Save this for an assertion in the future\n', '        // Subtract from the sender\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value); \n', '        _balanceOf[_to] = _balanceOf[_to].add(_value); // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(_balanceOf[_from] + _balanceOf[_to] == previousBalances);\n', '    }\n', '    \n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(_balanceOf[msg.sender]>=_value);\n', '        _allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return _allowances[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract SiBiCryptICO is SiBiCryptToken {\n', '    \n', '  \n', '    /**\n', '     * @dev constructor of CrowdsaleToken\n', '     **/\n', '      /* Initializes contract with initial supply tokens and sharesPercent to the creator _owner of the contract */\n', '    constructor(\n', '            string memory tokenName, string memory tokenSymbol, uint256 initialSupply, address payable _reclaimablePocket, address payable _teamWallet \n', '        ) Token(tokenName, tokenSymbol, initialSupply) owned(_reclaimablePocket, _teamWallet) public {\n', '        uint toOwnerWallet = (_totalSupply*40)/100;\n', '        uint toTeam = (_totalSupply*15)/100;\n', '         _balanceOf[msg.sender] += toOwnerWallet;\n', '         _balanceOf[teamWallet] += toTeam;\n', '         emit Transfer(address(this),msg.sender,toOwnerWallet);\n', '        emit Transfer(address(this),teamWallet,toTeam);\n', '         tokensSold += toOwnerWallet.add(toTeam);\n', '         remainingTokens = _totalSupply.sub(tokensSold);\n', '         currentStage = Stages.none;\n', '         payingDividends = false;\n', '    }\n', '    \n', '  \n', '    /// @param newBuyPrice Price users can buy token from the contract\n', '    function setPrices(uint256 newBuyPrice) onlyOwner public {\n', '        buyPrice = newBuyPrice;   //ETH per Token\n', '    }\n', '    /**\n', '     * @dev fallback function to send ether to for Crowd sale\n', '     **/\n', '    function () external payable {\n', '        require(currentStage == Stages.icoStart || currentStage == Stages.icoResumed, "Oops! ICO is not running");\n', '        require(msg.value > 0);\n', '        require(remainingTokens > 0, "Tokens sold out! you may proceed to buy from Token holders");\n', '        \n', '        uint256 weiAmount = msg.value; // Calculate tokens to sell\n', '        uint256 tokens = (weiAmount.div(buyPrice)).mul(1*10**18);\n', '        uint256 returnWei;\n', '        \n', '        if(tokens > remainingTokens){\n', '            uint256 newTokens = remainingTokens;\n', '            uint256 newWei = (newTokens.mul(buyPrice)).div(1*10**18);\n', '            returnWei = weiAmount.sub(newWei);\n', '            weiAmount = newWei;\n', '            tokens = newTokens;\n', '        }\n', '        \n', '        tokensSold = tokensSold.add(tokens); // Increment raised amount\n', '        remainingTokens = remainingTokens.sub(tokens); //decrease remaining token\n', '        if(returnWei > 0){\n', '            msg.sender.transfer(returnWei);\n', '            emit returnedWei(address(this), msg.sender, returnWei);\n', '        }\n', '        \n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].add(tokens);\n', '        emit Transfer(address(this), msg.sender, tokens);\n', '        emit purchaseInvoice(msg.sender, tokens, msg.value, weiAmount, returnWei);\n', '       \n', '        owner.transfer(weiAmount); // Send money for project execution\n', '        if(remainingTokens == 0 ){pauseIco();}\n', '    }\n', '    \n', '    /**\n', '     * @dev startIco starts the public ICO\n', '     **/\n', '    function startIco() public onlyOwner  returns(bool) {\n', '        require(currentStage != Stages.icoEnd, "Oops! ICO has been finalized.");\n', '        require(currentStage == Stages.none, "ICO is running already");\n', '        currentStage = Stages.icoStart;\n', '        return true;\n', '    }\n', '    \n', '    function pauseIco() internal {\n', '        require(currentStage != Stages.icoEnd, "Oops! ICO has been finalized.");\n', '        currentStage = Stages.icoPaused;\n', '        owner.transfer(address(this).balance);\n', '    }\n', '    \n', '    function resumeIco() public onlyOwner returns(bool) {\n', '        require(currentStage == Stages.icoPaused, "call denied");\n', '        currentStage = Stages.icoResumed;\n', '        return true;\n', '    }\n', '    \n', '    function ICO_State() public view returns(string memory) {\n', '        if(currentStage == Stages.none) return "Initializing...";\n', '        if(currentStage == Stages.icoPaused) return "Paused!";\n', '        if(currentStage == Stages.icoEnd) return "ICO Stopped!";\n', '        else return "ICO is running...";\n', '    }\n', '    \n', '\n', '    /**\n', '     * @dev endIco closes down the ICO \n', '     **/\n', '    function endIco() internal {\n', '        currentStage = Stages.icoEnd;\n', '        // Transfer any remaining tokens\n', '        if(remainingTokens > 0){\n', '            _balanceOf[owner] = _balanceOf[owner].add(remainingTokens);\n', '        }\n', '        // transfer any remaining ETH balance in the contract to the owner\n', '        owner.transfer(address(this).balance); \n', '    }\n', '\n', '    /**\n', '     * @dev finalizeIco closes down the ICO and sets needed varriables\n', '     **/\n', '    function finalizeIco() public onlyOwner returns(Stages){\n', '        require(currentStage != Stages.icoEnd );\n', '        if(currentStage == Stages.icoPaused){\n', '            endIco();\n', '            return currentStage;\n', '        }\n', '        else{\n', '            pauseIco();\n', '            return currentStage;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * ******************************************************************************************************************\n', ' * If you find this code useful or helpful, please give a tip @ 0x15f26bA042233BC6e31e961195fFACAC7F63E97E Thanks!***\n', ' * ******************************************************************************************************************\n', '**/']