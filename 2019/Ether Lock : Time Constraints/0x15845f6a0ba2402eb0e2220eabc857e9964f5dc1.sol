['pragma solidity >=0.5.0 <0.6.0;\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract TokenVesting {\n', '    event Released(uint256 amount);\n', '    event Revoked();\n', '    event AddPartner(address _partner);\n', '    event RevokeVoting(bool _revokecable);\n', '    \n', '    address public beneficiary;\n', '    uint256 public times;\n', '    uint256 public releaseStart;\n', '    uint256 public interval;\n', '    \n', '    address public owner;\n', '\n', '    mapping (address => uint256) public released;\n', '    mapping (address => uint256) public revoked;\n', '\n', '    struct RevokeVote{\n', '        address partner;\n', '        bool vote;\n', '    }\n', '\n', '    mapping (address => RevokeVote) partnerRevokeVote;\n', '    \n', '    uint256 public partnerCount = 0;\n', '    uint256 public voteAgreeCount = 0;\n', '    \n', '    constructor(address _beneficiary,  uint256 _times, uint256 _releaseStart, uint256 _interval, address[5] memory _partners) public {\n', '        require(_beneficiary != address(0));\n', '        require(_releaseStart > now);\n', '        require(_times > 0);\n', '        require(_interval > 0);\n', '        \n', '        beneficiary = _beneficiary;\n', '        times = _times;\n', '        releaseStart = _releaseStart;\n', '        interval = _interval;\n', '        \n', '        owner = msg.sender;\n', '        \n', '        for(uint i=0;i<_partners.length;i++){\n', '            addPartner(_partners[i]);\n', '        }\n', '    }\n', '\n', '    function addPartner(address _partner) private {\n', '        require(_partner != address(0));\n', '        if(partnerRevokeVote[_partner].partner != _partner){\n', '            partnerRevokeVote[_partner] = RevokeVote({\n', '                partner : _partner,\n', '                vote : false\n', '            });\n', '            partnerCount++;\n', '        }\n', '        // emit AddPartner(_partner);\n', '    }\n', '\n', '    function revokeVoting(bool _revokecable) public {\n', '        require(isPartners(msg.sender));\n', '        bool revokeVoted = partnerRevokeVote[msg.sender].vote;\n', '        if(revokeVoted != _revokecable){\n', '            if(_revokecable){\n', '                voteAgreeCount++;\n', '            } else {\n', '                voteAgreeCount--;\n', '            }\n', '            partnerRevokeVote[msg.sender].vote = _revokecable;\n', '        }\n', '        emit RevokeVoting(_revokecable);\n', '    }\n', '\n', '    function isPartners(address _voter) private view returns(bool){\n', '        if(partnerRevokeVote[_voter].partner == _voter){\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isRevocable() public view returns(bool) {\n', '        if(voteAgreeCount >= (partnerCount/2)+1){\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function release(ERC20Basic _token) public {\n', '        require(msg.sender == owner || isPartners(msg.sender));\n', '        uint256 _unreleased = releasableAmount(_token);\n', '        require(_unreleased > 0);\n', '        released[address(_token)] = released[address(_token)] + _unreleased;\n', '        _token.transfer(beneficiary, _unreleased);\n', '        emit Released(_unreleased);\n', '    }\n', '\n', '    function revoke(ERC20Basic _token) public {\n', '        require(msg.sender == owner || isPartners(msg.sender));\n', '        require(isRevocable());\n', '        uint256 _balance = _token.balanceOf(address(this));\n', '        revoked[address(_token)] = revoked[address(_token)] + _balance;\n', '        _token.transfer(beneficiary, _balance);\n', '        emit Revoked();\n', '    }\n', '\n', '    function releasableAmount(ERC20Basic _token) public view returns (uint256) {\n', '        uint256 _currentBalance = _token.balanceOf(address(this));\n', '        uint256 _totalBalance = _currentBalance + released[address(_token)];\n', '        uint256 _revoked = revoked[address(_token)];\n', '\n', '        if (now < releaseStart) {\n', '            return 0;\n', '        } else if ((now >= releaseStart + interval * (times-1)) || _revoked > 0) {\n', '            return _currentBalance;\n', '        } else {\n', '            uint256 _count = _totalBalance / times;\n', '            uint256 _currentTimes = (((now - releaseStart) / interval) + 1);\n', '            uint256 _vestedAmount =  _currentTimes * _count;\n', '            return _vestedAmount - released[address(_token)];\n', '        }\n', '    }\n', '}']