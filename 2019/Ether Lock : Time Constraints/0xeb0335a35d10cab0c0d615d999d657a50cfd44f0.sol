['pragma solidity ^0.4.11;\n', 'contract asssderf {\n', '    event Hodl(address indexed hodler, uint indexed amount);\n', '    event Party(address indexed hodler, uint indexed amount);\n', '    mapping (address => uint) public hodlers;\n', '    uint constant partyTime = 1546508000; // 01/03/2019 @ 9:25am (UTC)\n', '    function() payable {\n', '        hodlers[msg.sender] += msg.value;\n', '        Hodl(msg.sender, msg.value);\n', '        \n', '        if (msg.value == 0) {\n', '        \n', '        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n', '        uint value = hodlers[msg.sender];\n', '        hodlers[msg.sender] = 0;\n', '        msg.sender.transfer(value);\n', '        Party(msg.sender, value);    \n', '            \n', '            \n', '        }\n', '        \n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', 'contract asssderf {\n', '    event Hodl(address indexed hodler, uint indexed amount);\n', '    event Party(address indexed hodler, uint indexed amount);\n', '    mapping (address => uint) public hodlers;\n', '    uint constant partyTime = 1546508000; // 01/03/2019 @ 9:25am (UTC)\n', '    function() payable {\n', '        hodlers[msg.sender] += msg.value;\n', '        Hodl(msg.sender, msg.value);\n', '        \n', '        if (msg.value == 0) {\n', '        \n', '        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n', '        uint value = hodlers[msg.sender];\n', '        hodlers[msg.sender] = 0;\n', '        msg.sender.transfer(value);\n', '        Party(msg.sender, value);    \n', '            \n', '            \n', '        }\n', '        \n', '    }\n', '\n', '}']
