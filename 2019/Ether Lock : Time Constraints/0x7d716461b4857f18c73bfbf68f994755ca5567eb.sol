['pragma solidity ^0.4.25;\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '   \n', '}\n', '\n', 'contract Escrow {\n', '  \n', '  event Deposit(uint tokens);\n', '  address dai_0x_address = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; // ContractA Address\n', '  mapping ( address => uint256 ) public balances;\n', '\n', '  function deposit(uint tokens) public returns (bool success){\n', '    // add the deposited tokens into existing balance \n', '    balances[msg.sender]+= tokens;\n', '    // transfer the tokens from the sender to this contract\n', '    ERC20(dai_0x_address).transferFrom(msg.sender, address(this), tokens);\n', '    emit Deposit(tokens);\n', '    return true;\n', '  }\n', '\n', '  function returnTokens() public {\n', '    balances[msg.sender] = 0;\n', '    ERC20(dai_0x_address).transfer(msg.sender, balances[msg.sender]);\n', '  }\n', '\n', '  function withdraw(uint256 tokens) public {\n', '        require(balances[msg.sender] >= tokens);\n', '        ERC20(dai_0x_address).transfer(msg.sender, tokens);\n', '  }\n', '  \n', '  function reallocate(address to, uint256 tokens) internal {\n', '        require(balances[msg.sender] >= tokens, "Insufficient balance.");\n', '        balances[msg.sender] -= tokens;\n', '        balances[to] += tokens;\n', '   }\n', '\n', '}']