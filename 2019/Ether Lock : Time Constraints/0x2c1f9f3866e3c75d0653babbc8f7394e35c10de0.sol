['// Resolver to Wipe & Coll any CDP\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "Assertion Failed");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "Assertion Failed");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string name) external view returns(address);\n', '}\n', '\n', 'interface MakerCDP {\n', '    function join(uint wad) external; // Join PETH\n', '    function lock(bytes32 cup, uint wad) external;\n', '    function wipe(bytes32 cup, uint wad) external;\n', '    function per() external view returns (uint ray);\n', '}\n', '\n', 'interface PriceInterface {\n', '    function peek() external view returns (bytes32, bool);\n', '}\n', '\n', 'interface WETHFace {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', 'interface InstaKyber {\n', '    function executeTrade(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt,\n', '        uint minConversionRate,\n', '        uint maxDestAmt\n', '    ) external payable returns (uint destAmt);\n', '\n', '    function getExpectedPrice(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt\n', '    ) external view returns (uint, uint);\n', '}\n', '\n', '\n', 'contract Registry {\n', '\n', '    address public addressRegistry;\n', '    modifier onlyAdmin() {\n', '        require(\n', '            msg.sender == getAddress("admin"),\n', '            "Permission Denied"\n', '        );\n', '        _;\n', '    }\n', '    \n', '    function getAddress(string name) internal view returns(address) {\n', '        AddressRegistry addrReg = AddressRegistry(addressRegistry);\n', '        return addrReg.getAddr(name);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Helper is Registry {\n', '\n', '    using SafeMath for uint;\n', '    using SafeMath for uint256;\n', '\n', '    address public cdpAddr;\n', '    address public eth;\n', '    address public weth;\n', '    address public peth;\n', '    address public mkr;\n', '    address public dai;\n', '    address public kyber;\n', '\n', '    function pethPEReth(uint ethNum) public view returns (uint rPETH) {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        rPETH = (ethNum.mul(10 ** 27)).div(loanMaster.per());\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Lock is Helper {\n', '\n', '    event LockedETH(uint cdpNum, address lockedBy, uint lockETH, uint lockPETH);\n', '\n', '    function lockETH(uint cdpNum) public payable {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        WETHFace wethTkn = WETHFace(weth);\n', '        wethTkn.deposit.value(msg.value)(); // ETH to WETH\n', '        uint pethToLock = pethPEReth(msg.value);\n', '        loanMaster.join(pethToLock); // WETH to PETH\n', '        loanMaster.lock(bytes32(cdpNum), pethToLock); // PETH to CDP\n', '        emit LockedETH(\n', '            cdpNum, msg.sender, msg.value, pethToLock\n', '        );\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Wipe is Lock {\n', '\n', '    event WipedDAI(uint cdpNum, address wipedBy, uint daiWipe, uint mkrCharged);\n', '\n', '    function wipeDAI(uint cdpNum, uint daiWipe) public payable {\n', '        IERC20 daiTkn = IERC20(dai);\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '\n', '        uint contractMKR = mkrTkn.balanceOf(address(this)); // contract MKR balance before wiping\n', '        daiTkn.transferFrom(msg.sender, address(this), daiWipe); // get DAI to pay the debt\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.wipe(bytes32(cdpNum), daiWipe); // wipe DAI\n', '        uint mkrCharged = contractMKR - mkrTkn.balanceOf(address(this)); // MKR fee = before wiping bal - after wiping bal\n', '\n', '        // claiming paid MKR back\n', '        if (msg.value > 0) { // Interacting with Kyber to swap ETH with MKR\n', '            swapETHMKR(\n', '                mkrCharged, msg.value\n', '            );\n', '        } else { // take MKR directly from address\n', '            mkrTkn.transferFrom(msg.sender, address(this), mkrCharged); // user paying MKR fees\n', '        }\n', '\n', '        emit WipedDAI(\n', '            cdpNum, msg.sender, daiWipe, mkrCharged\n', '        );\n', '    }\n', '\n', '    function swapETHMKR(\n', '        uint mkrCharged,\n', '        uint ethQty\n', '    ) internal \n', '    {\n', '        InstaKyber instak = InstaKyber(kyber);\n', '        uint minRate;\n', '        (, minRate) = instak.getExpectedPrice(eth, mkr, ethQty);\n', '        uint mkrBought = instak.executeTrade.value(ethQty)(\n', '            eth, mkr, ethQty, minRate, mkrCharged\n', '        );\n', '        require(mkrCharged == mkrBought, "ETH not sufficient to cover the MKR fees.");\n', '        if (address(this).balance > 0) {\n', '            msg.sender.transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract ApproveTkn is Wipe {\n', '\n', '    function approveERC20() public {\n', '        IERC20 wethTkn = IERC20(weth);\n', '        wethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 pethTkn = IERC20(peth);\n', '        pethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '        mkrTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 daiTkn = IERC20(dai);\n', '        daiTkn.approve(cdpAddr, 2**256 - 1);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract PublicCDP is ApproveTkn {\n', '\n', '    event MKRCollected(uint amount);\n', '\n', '    constructor(address rAddr) public {\n', '        addressRegistry = rAddr;\n', '        cdpAddr = getAddress("cdp");\n', '        eth = getAddress("eth");\n', '        weth = getAddress("weth");\n', '        peth = getAddress("peth");\n', '        mkr = getAddress("mkr");\n', '        dai = getAddress("dai");\n', '        kyber = getAddress("InstaKyber");\n', '        approveERC20();\n', '    }\n', '\n', '    function () public payable {}\n', '\n', '    // collecting MKR token kept as balance to pay fees\n', '    function collectMKR(uint amount) public onlyAdmin {\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '        mkrTkn.transfer(msg.sender, amount);\n', '        emit MKRCollected(amount);\n', '    }\n', '\n', '}']
['// Resolver to Wipe & Coll any CDP\n', 'pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "Assertion Failed");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "Assertion Failed");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string name) external view returns(address);\n', '}\n', '\n', 'interface MakerCDP {\n', '    function join(uint wad) external; // Join PETH\n', '    function lock(bytes32 cup, uint wad) external;\n', '    function wipe(bytes32 cup, uint wad) external;\n', '    function per() external view returns (uint ray);\n', '}\n', '\n', 'interface PriceInterface {\n', '    function peek() external view returns (bytes32, bool);\n', '}\n', '\n', 'interface WETHFace {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', 'interface InstaKyber {\n', '    function executeTrade(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt,\n', '        uint minConversionRate,\n', '        uint maxDestAmt\n', '    ) external payable returns (uint destAmt);\n', '\n', '    function getExpectedPrice(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt\n', '    ) external view returns (uint, uint);\n', '}\n', '\n', '\n', 'contract Registry {\n', '\n', '    address public addressRegistry;\n', '    modifier onlyAdmin() {\n', '        require(\n', '            msg.sender == getAddress("admin"),\n', '            "Permission Denied"\n', '        );\n', '        _;\n', '    }\n', '    \n', '    function getAddress(string name) internal view returns(address) {\n', '        AddressRegistry addrReg = AddressRegistry(addressRegistry);\n', '        return addrReg.getAddr(name);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Helper is Registry {\n', '\n', '    using SafeMath for uint;\n', '    using SafeMath for uint256;\n', '\n', '    address public cdpAddr;\n', '    address public eth;\n', '    address public weth;\n', '    address public peth;\n', '    address public mkr;\n', '    address public dai;\n', '    address public kyber;\n', '\n', '    function pethPEReth(uint ethNum) public view returns (uint rPETH) {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        rPETH = (ethNum.mul(10 ** 27)).div(loanMaster.per());\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Lock is Helper {\n', '\n', '    event LockedETH(uint cdpNum, address lockedBy, uint lockETH, uint lockPETH);\n', '\n', '    function lockETH(uint cdpNum) public payable {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        WETHFace wethTkn = WETHFace(weth);\n', '        wethTkn.deposit.value(msg.value)(); // ETH to WETH\n', '        uint pethToLock = pethPEReth(msg.value);\n', '        loanMaster.join(pethToLock); // WETH to PETH\n', '        loanMaster.lock(bytes32(cdpNum), pethToLock); // PETH to CDP\n', '        emit LockedETH(\n', '            cdpNum, msg.sender, msg.value, pethToLock\n', '        );\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Wipe is Lock {\n', '\n', '    event WipedDAI(uint cdpNum, address wipedBy, uint daiWipe, uint mkrCharged);\n', '\n', '    function wipeDAI(uint cdpNum, uint daiWipe) public payable {\n', '        IERC20 daiTkn = IERC20(dai);\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '\n', '        uint contractMKR = mkrTkn.balanceOf(address(this)); // contract MKR balance before wiping\n', '        daiTkn.transferFrom(msg.sender, address(this), daiWipe); // get DAI to pay the debt\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.wipe(bytes32(cdpNum), daiWipe); // wipe DAI\n', '        uint mkrCharged = contractMKR - mkrTkn.balanceOf(address(this)); // MKR fee = before wiping bal - after wiping bal\n', '\n', '        // claiming paid MKR back\n', '        if (msg.value > 0) { // Interacting with Kyber to swap ETH with MKR\n', '            swapETHMKR(\n', '                mkrCharged, msg.value\n', '            );\n', '        } else { // take MKR directly from address\n', '            mkrTkn.transferFrom(msg.sender, address(this), mkrCharged); // user paying MKR fees\n', '        }\n', '\n', '        emit WipedDAI(\n', '            cdpNum, msg.sender, daiWipe, mkrCharged\n', '        );\n', '    }\n', '\n', '    function swapETHMKR(\n', '        uint mkrCharged,\n', '        uint ethQty\n', '    ) internal \n', '    {\n', '        InstaKyber instak = InstaKyber(kyber);\n', '        uint minRate;\n', '        (, minRate) = instak.getExpectedPrice(eth, mkr, ethQty);\n', '        uint mkrBought = instak.executeTrade.value(ethQty)(\n', '            eth, mkr, ethQty, minRate, mkrCharged\n', '        );\n', '        require(mkrCharged == mkrBought, "ETH not sufficient to cover the MKR fees.");\n', '        if (address(this).balance > 0) {\n', '            msg.sender.transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract ApproveTkn is Wipe {\n', '\n', '    function approveERC20() public {\n', '        IERC20 wethTkn = IERC20(weth);\n', '        wethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 pethTkn = IERC20(peth);\n', '        pethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '        mkrTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 daiTkn = IERC20(dai);\n', '        daiTkn.approve(cdpAddr, 2**256 - 1);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract PublicCDP is ApproveTkn {\n', '\n', '    event MKRCollected(uint amount);\n', '\n', '    constructor(address rAddr) public {\n', '        addressRegistry = rAddr;\n', '        cdpAddr = getAddress("cdp");\n', '        eth = getAddress("eth");\n', '        weth = getAddress("weth");\n', '        peth = getAddress("peth");\n', '        mkr = getAddress("mkr");\n', '        dai = getAddress("dai");\n', '        kyber = getAddress("InstaKyber");\n', '        approveERC20();\n', '    }\n', '\n', '    function () public payable {}\n', '\n', '    // collecting MKR token kept as balance to pay fees\n', '    function collectMKR(uint amount) public onlyAdmin {\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '        mkrTkn.transfer(msg.sender, amount);\n', '        emit MKRCollected(amount);\n', '    }\n', '\n', '}']
