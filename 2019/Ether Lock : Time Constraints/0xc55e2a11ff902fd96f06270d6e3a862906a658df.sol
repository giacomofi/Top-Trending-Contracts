['pragma solidity ^0.5.7;\n', '\n', 'library MyEtherFundControl {\n', '    using MyEtherFundControl for data;\n', '\n', '    struct data {\n', '        uint min;\n', '        uint max;\n', '\n', '        uint startAt;\n', '        uint maxAmountPerDay;\n', '        mapping(uint => uint) investmentsPerDay;\n', '    }\n', '\n', '    function addInvestment(data storage control, uint amount) internal{\n', '        control.investmentsPerDay[getCurrentDay()] += amount;\n', '    }\n', '\n', '    function getMaxInvestmentToday(data storage control) internal view returns (uint){\n', '        if (control.startAt == 0) {\n', '            return 10000 ether;\n', '        }\n', '\n', '        if (control.startAt > now) {\n', '            return 10000 ether;\n', '        }\n', '\n', '        return control.maxAmountPerDay - control.getTodayInvestment();\n', '    }\n', '\n', '    function getCurrentDay() internal view returns (uint){\n', '        return now / 24 hours;\n', '    }\n', '\n', '    function getTodayInvestment(data storage control) internal view returns (uint){\n', '        return control.investmentsPerDay[getCurrentDay()];\n', '    }\n', '}\n', '\n', '\n', 'contract MyEtherFund {\n', '    using MyEtherFundControl for MyEtherFundControl.data;\n', '\n', '    address public owner;\n', '\n', '    uint constant public MIN_INVEST = 10000000000000000 wei;\n', '\n', '    uint public currentInterest = 3;\n', '\n', '    uint public depositAmount;\n', '\n', '    uint public paidAmount;\n', '\n', '    uint public round = 1;\n', '\n', '    uint public lastPaymentDate;\n', '\n', '    uint public advertisingCommission = 10;\n', '\n', '    uint public devCommission = 5;\n', '\n', '    uint public profitThreshold = 2;\n', '\n', '    address payable public devAddress;\n', '\n', '    address payable public advertiserAddress;\n', '\n', '    // investors addresses\n', '    address[] public addresses;\n', '\n', '    // mapping address to Investor\n', '    mapping(address => Investor) public investors;\n', '\n', '    // currently on restart phase or not?\n', '    bool public pause;\n', '\n', '    struct TopInvestor {\n', '        address payable addr;\n', '        uint deposit;\n', '        uint from;\n', '    }\n', '\n', '    struct Investor{\n', '        uint id;\n', '        uint deposit;\n', '        uint deposits;\n', '        uint paidOut;\n', '        uint date;\n', '        address payable referrer;\n', '    }\n', '\n', '    event Invest(address indexed addr, uint amount, address referrer);\n', '    event Payout(address indexed addr, uint amount, string eventType, address from);\n', '    event NextRoundStarted(uint indexed round, uint date, uint deposit);\n', '    event PerseusUpdate(address addr, string eventType);\n', '\n', '    TopInvestor public top_investor;\n', '    MyEtherFundControl.data private myEtherFundControl;\n', '\n', '    // only contract creator access\n', '    modifier onlyOwner {if (msg.sender == owner) _;}\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        devAddress = msg.sender;\n', '        advertiserAddress = msg.sender;\n', '\n', '        addresses.length = 1;\n', '\n', '        myEtherFundControl.min = 30 ether;\n', '        myEtherFundControl.max = 500 ether;\n', '    }\n', '\n', '    // change advertiser address\n', '    function setAdvertiserAddr(address payable addr) onlyOwner public {\n', '        advertiserAddress = addr;\n', '    }\n', '\n', '    // change owner\n', '    function transferOwnership(address payable addr) onlyOwner public {\n', '        owner = addr;\n', '    }\n', '\n', '    function setMyEtherFundControlStartAt(uint startAt) onlyOwner public {\n', '        myEtherFundControl.startAt = startAt;\n', '    }\n', '\n', '    function getMyEtherFundControlStartAt() public view returns (uint) {\n', '        return myEtherFundControl.startAt;\n', '    }\n', '\n', '    // set max of investments per day. Only devAddress have access to this function\n', '    function setGrowingMaxPerDay(uint maxAmountPerDay) public {\n', '        require(maxAmountPerDay >= myEtherFundControl.min && maxAmountPerDay <= myEtherFundControl.max, "incorrect amount");\n', '        require(msg.sender == devAddress, "Only dev team have access to this function");\n', '        myEtherFundControl.maxAmountPerDay = maxAmountPerDay;\n', '    }\n', '\n', '    // main function, which accept new investments and do dividends payouts\n', '    // if you send 0 ETH to this function, you will receive your dividends\n', '    function() payable external {\n', '\n', '        // ensure that payment not from contract\n', '        if (isContract()) {\n', '            revert();\n', '        }\n', '\n', '        // if contract is on restarting phase - do some work before restart\n', '        if (pause) {\n', '            doRestart();\n', '            msg.sender.transfer(msg.value); // return all money to sender\n', '\n', '            return;\n', '        }\n', '\n', '        if (0 == msg.value) {\n', '            payoutDividends(); // do pay out\n', '            return;\n', '        }\n', '        \n', '\n', '        require(msg.value >= MIN_INVEST, "Too small amount, minimum 0.01 ether");\n', '        Investor storage user = investors[msg.sender];\n', '\n', '        if (user.id == 0) { // if no saved address, save it\n', '            user.id = addresses.push(msg.sender);\n', '            user.date = now;\n', '\n', '            // check referrer\n', '            address payable referrer = bytesToAddress(msg.data);\n', '            if (investors[referrer].deposit > 0 && referrer != msg.sender) {\n', '                user.referrer = referrer;\n', '            }\n', '        } else {\n', '            payoutDividends(); // else pay dividends before reinvest\n', '        }\n', '\n', '        uint investment = min(myEtherFundControl.getMaxInvestmentToday(), msg.value);\n', '        require(investment > 0, "Too much investments today");\n', '\n', '        // update investor\n', '        user.deposit += investment;\n', '        user.deposits += 1;\n', '\n', '        emit Invest(msg.sender, investment, user.referrer);\n', '\n', '        depositAmount += investment;\n', '        lastPaymentDate = now;\n', '\n', '\n', '        if (devAddress.send(investment / 100 * devCommission)) {\n', '            // project fee\n', '        }\n', '\n', '        if (advertiserAddress.send(investment / 100 * advertisingCommission)) {\n', '            // advert fee\n', '        }\n', '\n', '        // referrer commission for all deposits\n', '        uint bonusAmount = investment / 100 * currentInterest;\n', '\n', '        // user have referrer\n', '        if (user.referrer != address(0)) {\n', '            if (user.referrer.send(bonusAmount)) { // pay referrer commission\n', '                emit Payout(user.referrer, bonusAmount, "referral", msg.sender);\n', '            }\n', '\n', '            if (user.deposits == 1) { // only the first deposit cashback\n', '                if (msg.sender.send(bonusAmount)) {\n', '                    emit Payout(msg.sender, bonusAmount, "cash-back", address(0));\n', '                }\n', '            }\n', '        } else if (top_investor.addr != address(0) && top_investor.from + 24 hours > now) {\n', '            if (top_investor.addr.send(bonusAmount)) { // pay bonus to current Perseus\n', '                emit Payout(top_investor.addr, bonusAmount, "perseus", msg.sender);\n', '            }\n', '        }\n', '\n', '        // check and maybe update current interest rate\n', '        considerCurrentInterest();\n', '        // add investment to the myEtherFundControl service\n', '        myEtherFundControl.addInvestment(investment);\n', '        // Perseus has changed? do some checks\n', '        considerTopInvestor(investment);\n', '\n', '        // return excess eth (if myEtherFundControl is active)\n', '        if (msg.value > investment) {\n', '            msg.sender.transfer(msg.value - investment);\n', '        }\n', '    }\n', '\n', '    function getTodayInvestment() view public returns (uint){\n', '        return myEtherFundControl.getTodayInvestment();\n', '    }\n', '\n', '    function getMaximumInvestmentPerDay() view public returns (uint){\n', '        return myEtherFundControl.maxAmountPerDay;\n', '    }\n', '\n', '    function payoutDividends() private {\n', '        require(investors[msg.sender].id > 0, "Investor not found");\n', '        uint amount = getInvestorDividendsAmount(msg.sender);\n', '\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        // save last paid out date\n', '        investors[msg.sender].date = now;\n', '\n', '        // save total paid out for investor\n', '        investors[msg.sender].paidOut += amount;\n', '\n', '        // save total paid out for contract\n', '        paidAmount += amount;\n', '\n', '        uint balance = address(this).balance;\n', '\n', '        // check contract balance, if not enough - do restart\n', '        if (balance < amount) {\n', '            pause = true;\n', '            amount = balance;\n', '        }\n', '\n', '        msg.sender.transfer(amount);\n', '        emit Payout(msg.sender, amount, "payout", address(0));\n', '\n', '        // if investor has reached the limit (x2 profit) - delete him\n', '        if (investors[msg.sender].paidOut >= investors[msg.sender].deposit * profitThreshold) {\n', '            delete investors[msg.sender];\n', '        }\n', '    }\n', '\n', '    // remove all investors and prepare data for the new round!\n', '    function doRestart() private {\n', '        uint txs;\n', '\n', '        for (uint i = addresses.length - 1; i > 0; i--) {\n', '            delete investors[addresses[i]]; // remove investor\n', '            addresses.length -= 1; // decrease addr length\n', '            if (txs++ == 150) { // 150 to prevent gas over use\n', '                return;\n', '            }\n', '        }\n', '\n', '        emit NextRoundStarted(round, now, depositAmount);\n', '        pause = false; // stop pause, play\n', '        round += 1; // increase round number\n', '        depositAmount = 0;\n', '        paidAmount = 0;\n', '        lastPaymentDate = now;\n', '    }\n', '\n', '    function getInvestorCount() public view returns (uint) {\n', '        return addresses.length - 1;\n', '    }\n', '\n', '    function considerCurrentInterest() internal{\n', '        uint interest;\n', '\n', '        // if 4000 ETH - set interest rate for 1%\n', '        if (depositAmount >= 4000 ether) {\n', '            interest = 1;\n', '        } else if (depositAmount >= 1000 ether) { // if 1000 ETH - set interest rate for 2%\n', '            interest = 2;\n', '        } else {\n', '            interest = 3; // base = 3%\n', '        }\n', '\n', '        // if interest has not changed, return\n', '        if (interest >= currentInterest) {\n', '            return;\n', '        }\n', '\n', '        currentInterest = interest;\n', '    }\n', '\n', '    // top investor in 24 hours\n', '    function considerTopInvestor(uint amount) internal {\n', '        // if current dead, delete him\n', '        if (top_investor.addr != address(0) && top_investor.from + 24 hours < now) {\n', '            top_investor.addr = address(0);\n', '            top_investor.deposit = 0;\n', '            emit PerseusUpdate(msg.sender, "expired");\n', '        }\n', '\n', '        // if the investment bigger than current made - change top investor\n', '        if (amount > top_investor.deposit) {\n', '            top_investor = TopInvestor(msg.sender, amount, now);\n', '            emit PerseusUpdate(msg.sender, "change");\n', '        }\n', '    }\n', '    \n', '    function getInvestorDividendsAmount(address addr) public view returns (uint) {\n', '        uint time = now - investors[addr].date;\n', '        return investors[addr].deposit / 100 * currentInterest * time / 1 days;\n', '    }\n', '\n', '    function bytesToAddress(bytes memory bys) private pure returns (address payable addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '\n', '    // check that there is no contract in the middle\n', '    function isContract() internal view returns (bool) {\n', '        return msg.sender != tx.origin;\n', '    }\n', '\n', '    // get min value from a and b\n', '    function min(uint a, uint b) public pure returns (uint) {\n', '        if (a < b) return a;\n', '        else return b;\n', '    }\n', '}']