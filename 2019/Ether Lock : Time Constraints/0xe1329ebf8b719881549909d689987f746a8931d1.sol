['pragma solidity ^0.4.25;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract DateTimeEnabled {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) internal constant returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) internal constant returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) internal constant returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) internal constant returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) internal constant returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) internal constant returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) internal constant returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) internal constant returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) internal constant returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) internal constant returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) internal constant returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal constant returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal constant returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal constant returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '        \n', '        function addDaystoTimeStamp(uint16 _daysToBeAdded) internal  returns(uint){\n', '            return now + DAY_IN_SECONDS*_daysToBeAdded;\n', '        }\n', '\n', '        function addMinutestoTimeStamp(uint8 _minutesToBeAdded) internal  returns(uint){\n', '            return now + MINUTE_IN_SECONDS*_minutesToBeAdded;\n', '        }\n', '\n', '\n', '        function printDatestamp(uint timestamp) internal returns (uint16,uint8,uint8,uint8,uint8,uint8) {\n', '            DateTime memory dt;\n', '            dt = parseTimestamp(timestamp);\n', '            return (dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second);\n', '        }\n', '        \n', '        function currentTimeStamp() internal returns (uint) {\n', '            return now;\n', '        }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() view public returns (uint _totalSupply);\n', '    function balanceOf(address _owner) view public returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) view public returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'contract BaseToken is ERC20 {\n', '    \n', '    address public owner;\n', '    using SafeMath for uint256;\n', '    \n', '    bool public tokenStatus = false;\n', '    \n', '    modifier ownerOnly(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    \n', '    modifier onlyWhenTokenIsOn(){\n', '        require(tokenStatus == true);\n', '        _;\n', '    }\n', '\n', '\n', '    function onOff () ownerOnly external{\n', '        tokenStatus = !tokenStatus;    \n', '    }\n', '\n', '\n', '    /**\n', '       * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }    \n', '    mapping (address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    //Token Details\n', '    string public symbol = "BASE";\n', '    string public name = "Base Token";\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public totalSupply; //will be instantiated in the derived Contracts\n', '    \n', '    function totalSupply() view public returns (uint256 ){\n', '        return totalSupply;\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) view public returns (uint balance){\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(2 * 32) public returns (bool success){\n', '        //_value = _value.mul(1e18);\n', '        require(\n', '            balances[msg.sender]>=_value \n', '            && _value > 0);\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            emit Transfer(msg.sender,_to,_value);\n', '            return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(3 * 32) public returns (bool success){\n', '        //_value = _value.mul(10**decimals);\n', '        require(\n', '            allowed[_from][msg.sender]>= _value\n', '            && balances[_from] >= _value\n', '            && _value >0 \n', '            );\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '            \n', '    }\n', '    \n', '    function approve(address _spender, uint _value) onlyWhenTokenIsOn public returns (bool success){\n', '        //_value = _value.mul(10**decimals);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) view public returns (uint remaining){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract ICO is BaseToken,DateTimeEnabled{\n', '\n', '    uint256 base = 10;\n', '    uint256 multiplier;\n', '\n', '    address ownerMultisig;\n', '\n', '    struct ICOPhase {\n', '        string phaseName;\n', '        uint256 tokensStaged;\n', '        uint256 tokensAllocated;\n', '        uint256 iRate;\n', '        uint256 fRate;\n', '        uint256 intialTime;\n', '        uint256 closingTime;\n', '       // uint256 RATE;\n', '        bool saleOn;\n', '        uint deadline;\n', '    }\n', '\n', '    uint8 public currentICOPhase;\n', '    \n', '    mapping(address=>uint256) public ethContributedBy;\n', '    uint256 public totalEthRaised;\n', '    uint256 public totalTokensSoldTillNow;\n', '\n', '    mapping(uint8=>ICOPhase) public icoPhases;\n', '    uint8 icoPhasesIndex=1;\n', '    \n', '    function getEthContributedBy(address _address) view public returns(uint256){\n', '        return ethContributedBy[_address];\n', '    }\n', '\n', '    function getTotalEthRaised() view public returns(uint256){\n', '        return totalEthRaised;\n', '    }\n', '\n', '    function getTotalTokensSoldTillNow() view public returns(uint256){\n', '        return totalTokensSoldTillNow;\n', '    }\n', '\n', '    \n', '    function addICOPhase(string _phaseName,uint256 _tokensStaged,uint256 _iRate, uint256 _fRate,uint256 _intialTime,uint256 _closingTime) ownerOnly public{\n', '        icoPhases[icoPhasesIndex].phaseName = _phaseName;\n', '        icoPhases[icoPhasesIndex].tokensStaged = _tokensStaged;\n', '        icoPhases[icoPhasesIndex].iRate = _iRate;\n', '        icoPhases[icoPhasesIndex].fRate = _fRate;\n', '        icoPhases[icoPhasesIndex].intialTime = _intialTime;\n', '        icoPhases[icoPhasesIndex].closingTime = _closingTime;\n', '        icoPhases[icoPhasesIndex].tokensAllocated = 0;\n', '        icoPhases[icoPhasesIndex].saleOn = false;\n', '        //icoPhases[icoPhasesIndex].deadline = _deadline;\n', '        icoPhasesIndex++;\n', '    }\n', '\n', '    function toggleSaleStatus() ownerOnly external{\n', '        icoPhases[currentICOPhase].saleOn = !icoPhases[currentICOPhase].saleOn;\n', '    }\n', '    function changefRate(uint256 _fRate) ownerOnly external{\n', '        icoPhases[currentICOPhase].fRate = _fRate;\n', '    }\n', '    function changeCurrentICOPhase(uint8 _newPhase) ownerOnly external{ //Only provided for exception handling in case some faulty phase has been added by the owner using addICOPhase\n', '        currentICOPhase = _newPhase;\n', '    }\n', '\n', '    function changeCurrentPhaseDeadline(uint8 _numdays) ownerOnly external{\n', '        icoPhases[currentICOPhase].closingTime= addDaystoTimeStamp(_numdays); //adds number of days to now and that becomes the new deadline\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) ownerOnly external{\n', '        if (newOwner != address(0)) {\n', '          owner = newOwner;\n', '        }\n', '    }\n', '    \n', '}\n', 'contract MultiRound is ICO{\n', '    function newICORound(uint256 _newSupply) ownerOnly public{//This is different from Stages which means multiple parts of one round\n', '        _newSupply = _newSupply.mul(multiplier);\n', '        balances[owner] = balances[owner].add(_newSupply);\n', '        totalSupply = totalSupply.add(_newSupply);\n', '    }\n', '\n', '    function destroyUnsoldTokens(uint256 _tokens) ownerOnly public{\n', '        _tokens = _tokens.mul(multiplier);\n', '        totalSupply = totalSupply.sub(_tokens);\n', '        balances[owner] = balances[owner].sub(_tokens);\n', '    }\n', '\n', '    \n', '}\n', '\n', 'contract ReferralEnabledToken is BaseToken{\n', '\n', '    \n', '    struct referral {\n', '        address referrer;\n', '        uint8 referrerPerc;// this is the percentage referrer will get in ETH. \n', '        uint8 refereePerc; // this is the discount Refereee will get \n', '    }\n', '\n', '    struct redeemedReferral {\n', '        address referee;\n', '        uint timestamp;\n', '        uint ethContributed;\n', '        uint rewardGained;\n', '    }\n', '    mapping(address=>referral) public referrals;\n', '    \n', '    uint8 public currentReferralRewardPercentage=10;\n', '    uint8 public currentReferralDiscountPercentage=10;\n', '    \n', '    mapping(address=>uint256) public totalEthRewards;\n', '    mapping(address=>mapping(uint16=>redeemedReferral)) referrerRewards;\n', '    mapping(address=>uint16) referrerRewardIndex;\n', '    \n', '    function totalEthRewards(address _address) view public returns(uint256){\n', '        totalEthRewards[_address];\n', '    }\n', '    \n', '    function createReferral(address _referrer, address _referree) public returns (bool) {\n', '        require(_referrer != _referree);\n', '        require (referrals[_referree].referrer == address(0) || referrals[_referree].referrer==msg.sender);\n', '        referrals[_referree].referrer = _referrer;\n', '        referrals[_referree].referrerPerc = currentReferralRewardPercentage;\n', '        referrals[_referree].refereePerc = currentReferralDiscountPercentage;\n', '        return true;\n', '    }\n', '    \n', '    function getReferrerRewards(address _referrer, uint16 _index) view public returns(address,uint,uint,uint){\n', '        redeemedReferral r = referrerRewards[_referrer][_index];\n', '        return(r.referee,r.timestamp,r.ethContributed,r.rewardGained);\n', '    }\n', '    \n', '    function getReferrerIndex(address _referrer) view public returns(uint16) {\n', '        return(referrerRewardIndex[_referrer]);\n', '    }\n', '    \n', '    \n', '    function getReferrerTotalRewards(address _referrer) view public returns(uint){\n', '        return (totalEthRewards[_referrer]);\n', '    }\n', '    \n', '    function getReferral(address _refereeId) constant public returns(address,uint8,uint8) {\n', '        referral memory r = referrals[_refereeId];\n', '        return(r.referrer,r.referrerPerc,r.refereePerc);\n', '    } \n', '\n', '    function changeReferralPerc(uint8 _newPerc) ownerOnly external{\n', '        currentReferralRewardPercentage = _newPerc;\n', '    }\n', '\n', '    function changeRefereePerc(uint8 _newPerc) ownerOnly external{\n', '        currentReferralDiscountPercentage = _newPerc;\n', '    }\n', '}\n', 'contract killable is ICO {\n', '    \n', '    function killContract() ownerOnly external{\n', '        selfdestruct(ownerMultisig);\n', '    }\n', '}\n', '//TODO - ADD Total ETH raised and Record token wise contribution    \n', 'contract RefineMediumToken is ICO,killable,MultiRound,ReferralEnabledToken  {\n', ' //   uint256 intialTime = 1542043381;\n', ' //   uint256 closingTime = 1557681781;\n', '    uint256 constant alloc1perc=50; //TEAM ALLOCATION\n', '    address constant alloc1Acc = 0xF0B50870e5d01FbfE783F6e76994A0BA94d34fe9; //CORETEAM Address (test-TestRPC4)\n', '\n', '    uint256 constant alloc2perc=50;//in percent -- ADVISORS ALLOCATION\n', '    address constant alloc2Acc = 0x3c3daEd0733cDBB26c298443Cec93c48426CC4Bd; //TestRPC5\n', '\n', '    uint256 constant alloc3perc=50;//in percent -- Bounty Allocation\n', '    address constant alloc3Acc = 0xAc5c102B4063615053C29f9B4DC8001D529037Cd; //TestRPC6\n', '\n', '    uint256 constant alloc4perc=50;//in percent -- Reserved LEAVE IT TO ZERO IF NO MORE ALLOCATIONS ARE THERE\n', '    address constant alloc4Acc = 0xf080966E970AC351A9D576846915bBE049Fe98dB; //TestRPC7\n', '\n', '    address constant ownerMultisig = 0xc4010efafaf53be13498efcffa04df931dc1592a; //Test4\n', '    mapping(address=>uint) blockedTill;    \n', '\n', '    constructor() public{\n', '        symbol = "XRM";\n', '        name = "Refine Medium Token";\n', '        decimals = 18;\n', '        multiplier=base**decimals;\n', '\n', '        totalSupply = 300000000*multiplier;//300 mn-- extra 18 zeroes are for the wallets which use decimal variable to show the balance \n', '        owner = msg.sender;\n', '\n', '        balances[owner]=totalSupply;\n', '        currentICOPhase = 1;\n', '        addICOPhase("Private Sale",15000000*multiplier,1550,1550,1558742400,1560556800);\n', '        runAllocations();\n', '    }\n', '\n', '    function runAllocations() ownerOnly public{\n', '        balances[owner]=((1000-(alloc1perc+alloc2perc+alloc3perc+alloc4perc))*totalSupply)/1000;\n', '        \n', '        balances[alloc1Acc]=(alloc1perc*totalSupply)/1000;\n', '        blockedTill[alloc1Acc] = addDaystoTimeStamp(2);\n', '        \n', '        balances[alloc2Acc]=(alloc2perc*totalSupply)/1000;\n', '        blockedTill[alloc2Acc] = addDaystoTimeStamp(2);\n', '        \n', '        balances[alloc3Acc]=(alloc3perc*totalSupply)/1000;\n', '        blockedTill[alloc3Acc] = addDaystoTimeStamp(2);\n', '        \n', '        balances[alloc4Acc]=(alloc4perc*totalSupply)/1000;\n', '        blockedTill[alloc4Acc] = addDaystoTimeStamp(2);\n', '        \n', '    }\n', '\n', '    function showRate(uint256 _epoch) public view returns (uint256){\n', '         ICOPhase storage i = icoPhases[currentICOPhase];\n', '         uint256 epoch = _epoch.sub(i.intialTime);\n', '         uint256 timeRange = i.closingTime.sub(i.intialTime);\n', '         uint256 rateRange = i.iRate.sub(i.fRate);\n', '         return (i.iRate*100000000000).sub((epoch.mul(rateRange)*100000000000).div(timeRange));\n', '    }\n', '    function currentRate() public view returns (uint256){\n', '         ICOPhase storage i = icoPhases[currentICOPhase];\n', '         uint256 epoch = now.sub(i.intialTime);\n', '         uint256 timeRange = i.closingTime.sub(i.intialTime);\n', '         uint256 rateRange = i.iRate.sub(i.fRate);\n', '         return ((i.iRate*100000000000).sub((epoch.mul(rateRange)*100000000000).div(timeRange)))/100000000000;\n', '    }\n', '    function () payable public{\n', '        createTokens();\n', '    }   \n', '\n', '    \n', '    function createTokens() payable public{\n', '        ICOPhase storage i = icoPhases[currentICOPhase]; \n', '        require(msg.value > 0\n', '            && i.saleOn == true);\n', '        \n', '        uint256 totalreferrerPerc = 0;\n', '        \n', '       // uint256 tokens = msg.value.mul((i.RATE*(100+r.refereePerc))/100);\n', '       uint256 tokens =   msg.value.mul((currentRate()*(100+r.refereePerc))/100);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '        i.tokensAllocated = i.tokensAllocated.add(tokens);\n', '        totalTokensSoldTillNow = totalTokensSoldTillNow.add(tokens); \n', '        \n', '        ethContributedBy[msg.sender] = ethContributedBy[msg.sender].add(msg.value);\n', '        totalEthRaised = totalEthRaised.add(msg.value);\n', '        referral storage r = referrals[msg.sender];\n', '        uint8 counter = 1;\n', '        while(r.referrer != 0 && counter <= 2){\n', '                       \n', '            counter = counter + 1;            \n', '            \n', '            uint16 currIndex = referrerRewardIndex[r.referrer] + 1;\n', '            uint rewardGained = (r.referrerPerc*msg.value)/100;\n', '            referrerRewardIndex[r.referrer] = currIndex;\n', '            referrerRewards[r.referrer][currIndex].referee = msg.sender;\n', '            referrerRewards[r.referrer][currIndex].timestamp = now;\n', '            referrerRewards[r.referrer][currIndex].ethContributed = msg.value;\n', '            referrerRewards[r.referrer][currIndex].rewardGained = rewardGained ;\n', '            totalEthRewards[r.referrer] = totalEthRewards[r.referrer].add(rewardGained);\n', '            r.referrer.transfer(rewardGained);\n', '                \n', '            totalreferrerPerc = totalreferrerPerc + r.referrerPerc;\n', '            r = referrals[r.referrer];\n', '            \n', '        }\n', '        ownerMultisig.transfer(((100-totalreferrerPerc)*msg.value)/100);\n', '\n', '        //Token Disbursement\n', '\n', '        \n', '        if(i.tokensAllocated>=i.tokensStaged){\n', '            i.saleOn = !i.saleOn; \n', '            currentICOPhase++;\n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    function transfer(address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(2 * 32) public returns (bool success){\n', '        //_value = _value.mul(1e18);\n', '        require(\n', '            balances[msg.sender]>=_value \n', '            && _value > 0\n', '            && now > blockedTill[msg.sender]\n', '        );\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender,_to,_value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(3 * 32) public returns (bool success){\n', '        //_value = _value.mul(10**decimals);\n', '        require(\n', '            allowed[_from][msg.sender]>= _value\n', '            && balances[_from] >= _value\n', '            && _value >0 \n', '            && now > blockedTill[_from]            \n', '        );\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '            \n', '    }\n', '    event Burn(address indexed _burner, uint _value);\n', '    function burn(uint _value) ownerOnly returns (bool)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0x0), _value);\n', '        return true;\n', '    }\n', '     event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '     bool public mintingFinished = false;\n', '\n', '\n', '     modifier canMint() {\n', '     require(!mintingFinished);\n', '     _;\n', '   }\n', '    function mint(address _to, uint256 _amount) ownerOnly canMint public returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() ownerOnly canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '    \n', '}']