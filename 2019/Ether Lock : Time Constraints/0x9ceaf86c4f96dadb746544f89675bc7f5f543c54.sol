['pragma solidity ^0.5.0;\n', '\n', 'contract owned {\n', '    address owner;\n', '\n', '    modifier onlyowner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '\n', '    }\n', '\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '\n', '}\n', '\n', 'contract ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() view public returns (uint256);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) view public returns (uint256);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) view public returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract BitSwap_5 is  owned{\n', '    ////////////////\n', '    ///// EVENTS /////\n', '    //////////////////\n', '    event DepositForEthReceived(address indexed _from, uint _amount, uint _timestamp);\n', '    event withdrawalSwappedAsset(address indexed _to, uint indexed _symbolIndex, uint _amount, uint _timestamp);\n', '    event DepositForTokenReceived(address indexed _from, uint indexed _symbolIndex, uint _amount, uint _timestamp);\n', '\n', '    using SafeMath for uint256;\n', '    \n', '      //////////////\n', '    // BALANCES //\n', '    //////////////\n', '    mapping (address => mapping (uint256 => uint)) tokenBalanceForAddress;\n', '      struct Contracts {\n', '         address contractAddr;\n', '    }\n', '    mapping (uint => Contracts) public ContractAddresses;\n', '   \n', '\n', '    mapping (address => uint) balanceEthForAddress;\n', '       function depositEther() public payable {\n', '        require(balanceEthForAddress[msg.sender] + msg.value >= balanceEthForAddress[msg.sender]);\n', '        balanceEthForAddress[msg.sender] += msg.value;\n', '        emit DepositForEthReceived(msg.sender, msg.value, now);\n', '    }\n', '    \n', '    \n', '     function addTokenContractAddress(string memory _symbol, address _contract) onlyowner() public{\n', '         \n', '         uint index = getSymbolContract(_symbol);\n', '          require(index > 0);\n', '         ContractAddresses[index] = Contracts(_contract);\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '      function getSymbolContract(string memory _symbol) internal pure returns (uint) {\n', '          uint index = 0;\n', '         if(compareStringsbyBytes(_symbol,"BINS") || compareStringsbyBytes(_symbol,"BIB") || compareStringsbyBytes(_symbol,"DAIX")){\n', '             if(compareStringsbyBytes(_symbol,"BINS")){\n', '               index = 1;\n', '             }else if(compareStringsbyBytes(_symbol,"BIB")){\n', '                index = 2; \n', '             }else if(compareStringsbyBytes(_symbol,"DAIX")){\n', '                index = 3; \n', '             }\n', '             return index;\n', '         }else{\n', '            revert(); \n', '         }\n', '         \n', '        return 0;\n', '    }\n', '\n', '\n', ' function compareStringsbyBytes(string memory s1, string memory s2) public pure returns(bool){\n', '    return keccak256(bytes(s1)) == keccak256(bytes(s2));\n', '}\n', '\n', '    \n', '      function getTokenContractAddress(string memory _a) view public returns(address){\n', '           uint index = getSymbolContract(_a);\n', '           require(index > 0);\n', '          return ContractAddresses[index].contractAddr;\n', '     }\n', '     \n', '        function getTokenSymbolByContractAddress(string memory _a) view public returns(uint256){\n', '          \n', '           uint index = getSymbolContract(_a);\n', '           require(index > 0);\n', '            ERC20Interface token = ERC20Interface(ContractAddresses[index].contractAddr);\n', '\n', '            return token.totalSupply();\n', '     }\n', '     \n', '    \n', '      \n', '      \n', '      function swapAsset(string memory _symbol) public {\n', '           if(compareStringsbyBytes(_symbol,"DAIX")) revert(); \n', '       uint amountDue = 0;\n', '       uint swapFromindex = getSymbolContract(_symbol);\n', '     \n', '      \n', '       require(swapFromindex > 0);\n', '       ERC20Interface swapFrom = ERC20Interface(ContractAddresses[swapFromindex].contractAddr);\n', '  \n', '      // require(swapFrom.approve(address(this), swapFrom.balanceOf(msg.sender)) == true);\n', '        require(ContractAddresses[swapFromindex].contractAddr != address(0));\n', '        \n', '\n', '        require(tokenBalanceForAddress[msg.sender][swapFromindex] + swapFrom.balanceOf(msg.sender) >= tokenBalanceForAddress[msg.sender][swapFromindex]);\n', '       if(compareStringsbyBytes(_symbol,"BINS")){\n', '            amountDue = swapFrom.balanceOf(msg.sender);\n', '        }else if(compareStringsbyBytes(_symbol,"BIB")){\n', '             amountDue = swapFrom.balanceOf(msg.sender) / 200 * 3;\n', '        }\n', '        require(swapFrom.transferFrom(msg.sender, address(this), swapFrom.balanceOf(msg.sender)) == true);\n', '       uint total = amountDue * 0.00000001 ether;\n', '       \n', '      \n', '        tokenBalanceForAddress[msg.sender][swapFromindex] += total;\n', '        emit DepositForTokenReceived(msg.sender, swapFromindex, total, now);\n', '        \n', '      }\n', '      \n', '    function withdrawSwappedAsset(string memory _symbol) public {\n', '        string memory toAssetSymbol = "DAIX";\n', '        uint symbolIndex = getSymbolContract(toAssetSymbol);\n', '        uint withdrawSymbolIndex = getSymbolContract(_symbol);\n', '        uint256 amount = tokenBalanceForAddress[msg.sender][withdrawSymbolIndex];\n', '        require(ContractAddresses[symbolIndex].contractAddr != address(0));\n', '\n', '        ERC20Interface token = ERC20Interface(ContractAddresses[symbolIndex].contractAddr);\n', '\n', '        require(tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] - amount >= 0);\n', '        require(tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] - amount <= tokenBalanceForAddress[msg.sender][withdrawSymbolIndex]);\n', '\n', '        tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] -= amount;\n', '        \n', '        require(token.transfer(msg.sender, amount) == true);\n', '        emit withdrawalSwappedAsset(msg.sender, withdrawSymbolIndex, amount, now);\n', '    }\n', '    \n', '      function getBalance(string memory symbolName) view public returns (uint) {\n', '          uint withdrawSymbolIndex = getSymbolContract(symbolName);\n', '        return tokenBalanceForAddress[msg.sender][withdrawSymbolIndex];\n', '    }\n', '    \n', '    //   function calculate(uint symbolName) view public returns (uint) {\n', '    //     uint total = symbolName * 0.00000001 ether;\n', '    //     return total;\n', '    // }\n', '    \n', '}']