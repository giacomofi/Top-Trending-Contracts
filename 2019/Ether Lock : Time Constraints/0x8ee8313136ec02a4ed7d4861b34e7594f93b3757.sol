['pragma solidity >=0.4.14 <0.6.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        require((value == 0) || (token.allowance(address(this), spender) == 0));\n', '        require(token.approve(spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '}\n', '\n', '\n', '/// @author QuarkChain Eng Team\n', '/// @title A simplified term deposit contract for ERC20 tokens\n', 'contract TermDepositSimplified is WhitelistAdminRole {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event DoDeposit(address indexed depositor, uint256 amount);\n', '    event Withdraw(address indexed depositor, uint256 amount);\n', '    event Drain(address indexed admin);\n', '    event Pause(address indexed admin, bool isPaused);\n', '    event Goodbye(address indexed admin, uint256 amount);\n', '\n', '    uint256 public constant MIN_DEPOSIT = 100 * 1e18;  // => 100 QKC.\n', '    // Pre-defined terms.\n', '    bytes4 public constant TERM_2MO = "2mo";\n', '    bytes4 public constant TERM_4MO = "4mo";\n', '    bytes4 public constant TERM_6MO = "6mo";\n', '\n', '    struct TermDepositInfo {\n', '        uint256 duration;\n', '        uint256 totalReceived;\n', '        mapping (address => Deposit[]) deposits;\n', '    }\n', '\n', '    struct Deposit {\n', '        uint256 amount;\n', '        uint256 depositAt;\n', '        uint256 withdrawAt;\n', '    }\n', '\n', '    mapping (bytes4 => TermDepositInfo) private _termDeposits;\n', '    IERC20 private _token;\n', '    bool   private _isPaused = false;\n', '\n', '    bytes4[] public allTerms = [TERM_2MO, TERM_4MO, TERM_6MO];\n', '\n', '    /// Constructor for the term deposit contract.\n', '    /// @param token ERC20 token addresses for term deposit\n', '    constructor(IERC20 token) public {\n', '        uint256 monthInSec = 2635200;\n', '        _token = token;\n', '\n', '        _termDeposits[TERM_2MO] = TermDepositInfo({\n', '            duration: 2 * monthInSec,\n', '            totalReceived: 0\n', '        });\n', '\n', '        _termDeposits[TERM_4MO] = TermDepositInfo({\n', '            duration: 4 * monthInSec,\n', '            totalReceived: 0\n', '        });\n', '\n', '        _termDeposits[TERM_6MO] = TermDepositInfo({\n', '            duration: 6 * monthInSec,\n', '            totalReceived: 0\n', '        });\n', '    }\n', '\n', '    /// Getter for token address.\n', '    /// @return the token address\n', '    function token() public view returns (IERC20) {\n', '        return _token;\n', '    }\n', '\n', "    /// Return a term deposit's key properties.\n", '    /// @param term the byte representation of terms\n', '    /// @return a list of deposit overview info\n', '    function getTermDepositInfo(bytes4 term) public view returns (uint256[2] memory) {\n', '        TermDepositInfo memory info = _termDeposits[term];\n', '        require(info.duration > 0, "should be a valid term");\n', '        return [\n', '            info.duration,\n', '            info.totalReceived\n', '        ];\n', '    }\n', '\n', '    /// Deposit users tokens into this contract.\n', '    /// @param term the byte representation of terms\n', '    /// @param amount token amount in wei\n', '    function deposit(bytes4 term, uint256 amount) public {\n', '        require(!_isPaused, "deposit not allowed when contract is paused");\n', '        require(amount >= MIN_DEPOSIT, "should have amount >= minimum");\n', '        TermDepositInfo storage info = _termDeposits[term];\n', '        require(info.duration > 0, "should be a valid term");\n', '\n', '        Deposit[] storage deposits = info.deposits[msg.sender];\n', '        deposits.push(Deposit({\n', '            amount: amount,\n', '            depositAt: now,\n', '            withdrawAt: 0\n', '        }));\n', '        info.totalReceived = info.totalReceived.add(amount);\n', '        emit DoDeposit(msg.sender, amount);\n', '\n', '        _token.safeTransferFrom(msg.sender, address(this), amount);\n', '    }\n', '\n', '    /// Calculate amount of tokens a user has deposited.\n', '    /// @param depositor the address of the depositor\n', '    /// @param terms the list of byte representation of terms\n', '    /// @param withdrawable boolean flag for whether to require withdrawable\n', '    /// @return amount of tokens available for withdrawal\n', '    function getDepositAmount(\n', '        address depositor,\n', '        bytes4[] memory terms,\n', '        bool withdrawable\n', '    ) public view returns (uint256[] memory)\n', '    {\n', '        uint256[] memory ret = new uint256[](terms.length);\n', '        for (uint256 i = 0; i < terms.length; i++) {\n', '            TermDepositInfo storage info = _termDeposits[terms[i]];\n', '            require(info.duration > 0, "should be a valid term");\n', '            Deposit[] memory deposits = info.deposits[depositor];\n', '\n', '            uint256 total = 0;\n', '            for (uint256 j = 0; j < deposits.length; j++) {\n', '                uint256 lockUntil = deposits[j].depositAt.add(info.duration);\n', '                if (deposits[j].withdrawAt == 0) {\n', '                    if (!withdrawable || now >= lockUntil) {\n', '                        total = total.add(deposits[j].amount);\n', '                    }\n', '                }\n', '            }\n', '            ret[i] = total;\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    /// Get detailed deposit information of a user.\n', '    /// @param depositor the address of the depositor\n', '    /// @param terms the list of byte representation of terms\n', '    /// @return 1 array for terms, 3 arrays of deposit amounts, deposit / withdrawal timestamps\n', '    function getDepositDetails(\n', '        address depositor,\n', '        bytes4[] memory terms\n', '    ) public view returns (bytes4[] memory, uint256[] memory, uint256[] memory, uint256[] memory)\n', '    {\n', '        Deposit[][] memory depositListByTerms = new Deposit[][](terms.length);\n', '\n', '        // Collect count first because dynamic array in memory is not allowed.\n', '        uint256 totalDepositCount = 0;\n', '        for (uint256 i = 0; i < terms.length; i++) {\n', '            bytes4 term = terms[i];\n', '            TermDepositInfo storage info = _termDeposits[term];\n', '            require(info.duration > 0, "should be a valid term");\n', '            Deposit[] memory deposits = info.deposits[depositor];\n', '            depositListByTerms[i] = deposits;\n', '            totalDepositCount = totalDepositCount.add(deposits.length);\n', '        }\n', '\n', '        bytes4[] memory depositTerms = new bytes4[](totalDepositCount);\n', '        uint256[] memory amounts = new uint256[](totalDepositCount);\n', '        uint256[] memory depositTs = new uint256[](totalDepositCount);\n', '        uint256[] memory withdrawTs = new uint256[](totalDepositCount);\n', '        uint256 retIndex = 0;\n', '        for (uint256 i = 0; i < depositListByTerms.length; i++) {\n', '            Deposit[] memory deposits = depositListByTerms[i];\n', '            for (uint256 j = 0; j < deposits.length; j++) {\n', '                depositTerms[retIndex] = terms[i];\n', '                Deposit memory d = deposits[j];\n', '                amounts[retIndex] = d.amount;\n', '                depositTs[retIndex] = d.depositAt;\n', '                withdrawTs[retIndex] = d.withdrawAt;\n', '                retIndex += 1;\n', '            }\n', '        }\n', '        assert(retIndex == totalDepositCount);\n', '        return (depositTerms, amounts, depositTs, withdrawTs);\n', '    }\n', '\n', "    /// Withdraw a user's tokens plus interest to his/her own address.\n", '    /// @param terms the list of byte representation of terms\n', '    /// @return whether have withdrawn some tokens successfully\n', '    function withdraw(bytes4[] memory terms) public returns (bool) {\n', '        require(!_isPaused, "withdraw not allowed when contract is paused");\n', '\n', '        uint256 total = 0;\n', '        for (uint256 i = 0; i < terms.length; i++) {\n', '            bytes4 term = terms[i];\n', '            TermDepositInfo storage info = _termDeposits[term];\n', '            require(info.duration > 0, "should be a valid term");\n', '            Deposit[] storage deposits = info.deposits[msg.sender];\n', '\n', '            uint256 termTotal = 0;\n', '            for (uint256 j = 0; j < deposits.length; j++) {\n', '                uint256 lockUntil = deposits[j].depositAt.add(info.duration);\n', '                if (deposits[j].withdrawAt == 0 && now >= lockUntil) {\n', '                    termTotal = termTotal.add(deposits[j].amount);\n', '                    deposits[j].withdrawAt = now;\n', '                }\n', '            }\n', '\n', '            info.totalReceived = info.totalReceived.sub(termTotal);\n', '            total = total.add(termTotal);\n', '        }\n', '\n', '        if (total == 0) {\n', '            return false;\n', '        }\n', '        emit Withdraw(msg.sender, total);\n', '        _token.safeTransfer(msg.sender, total);\n', '        return true;\n', '    }\n', '\n', '    /// Return necessary amount of tokens to cover interests and referral bonuses.\n', '    /// @param terms the list of byte representation of terms\n', '    /// @return total deposit\n', '    function calculateTotalPayout(bytes4[] memory terms) public view returns (uint256) {\n', '        // [deposit, interest, bonus].\n', '        uint256 ret;\n', '        for (uint256 i = 0; i < terms.length; i++) {\n', '            TermDepositInfo memory info = _termDeposits[terms[i]];\n', '            require(info.duration > 0, "should be a valid term");\n', '            ret = ret.add(info.totalReceived);\n', '        }\n', '        return ret;\n', '    }\n', '\n', '    /// Leave enough tokens for payout, and drain the surplus.\n', '    /// @dev only admins can call this function\n', '    function drainSurplusTokens() external onlyWhitelistAdmin {\n', '        emit Drain(msg.sender);\n', '\n', '        uint256 neededAmount = calculateTotalPayout(allTerms);\n', '        uint256 currentAmount = _token.balanceOf(address(this));\n', '        if (currentAmount > neededAmount) {\n', '            uint256 surplus = currentAmount.sub(neededAmount);\n', '            _token.safeTransfer(msg.sender, surplus);\n', '        }\n', '    }\n', '\n', '    /// Pause deposit and withdraw\n', '    /// @dev only admins can call this function\n', '    function pause(bool isPaused) external onlyWhitelistAdmin {\n', '        _isPaused = isPaused;\n', '\n', '        emit Pause(msg.sender, _isPaused);\n', '    }\n', '\n', '    /// Drain remaining tokens and destroys the contract to save some space for the network.\n', '    /// @dev only admins can call this function\n', '    function goodbye() external onlyWhitelistAdmin {\n', '        // Make sure is after deposit deadline, and no received tokens.\n', '        for (uint256 i = 0; i < allTerms.length; i++) {\n', '            bytes4 term = allTerms[i];\n', '            TermDepositInfo memory info = _termDeposits[term];\n', '            require(info.totalReceived < 1000 * 1e18, "should have small enough deposits");\n', '        }\n', '        // Transfer remaining tokens.\n', '        uint256 tokenAmount = _token.balanceOf(address(this));\n', '        emit Goodbye(msg.sender, tokenAmount);\n', '        if (tokenAmount > 0) {\n', '            _token.safeTransfer(msg.sender, tokenAmount);\n', '        }\n', '        // Say goodbye.\n', '        selfdestruct(msg.sender);\n', '    }\n', '}']