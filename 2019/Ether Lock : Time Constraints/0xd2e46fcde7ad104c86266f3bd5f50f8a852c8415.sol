['pragma solidity ^0.4.17;\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '    //ERC 20 token\n', '    \n', '    contract BKToken is SafeMath {\n', '        string public constant name = "ButterflyToken";  //Burrerfly Token\n', '        string public constant symbol = "BK"; //BK\n', '        uint public constant decimals = 8;\n', '        uint256 _totalSupply = 7579185859 * 10**decimals;\n', '        address trader = 0x60C8eD2EbD76839a5Ec563D78E6D1f02575660Af;\n', ' \n', '        function setTrader(address _addr) returns (bool success){\n', '            if (msg.sender!=founder) revert();\n', '            trader = _addr;\n', '        }\n', '        \n', '        function totalSupply() constant returns (uint256 supply) {\n', '            return _totalSupply;\n', '        }\n', ' \n', '        function balanceOf(address _owner) constant returns (uint256 balance) {\n', '            return balances[_owner];\n', '        }\n', ' \n', '        function approve(address _spender, uint256 _value) returns (bool success) {\n', '            require((_value == 0)||(allowed[msg.sender][_spender] ==0));\n', '            allowed[msg.sender][_spender] = _value;\n', '            Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', ' \n', '        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '          return allowed[_owner][_spender];\n', '        }\n', '        \n', '        enum DistType{\n', '            Miner,  //98% no lock\n', '            Team,   //0.4% 3 years 36 months\n', '            Private_Placement, //0.1% one year 12 months\n', '            Foundation //1.5% 0.5% no lock and 0.083% one month\n', '        }\n', '        \n', '        mapping(address => uint256) balances;\n', '        mapping(address => uint256) distBalances;\n', '        mapping(address => DistType) public distType;\n', '        mapping(address => mapping (address => uint256)) allowed;\n', '        \n', '        uint public baseStartTime;\n', '        \n', '        address startAddr = 0x1B66B59ABBF0AEB60F30E89607B2AD00000186A0;\n', '        address endAddr = 0x1B66B59ABBF0AEB60F30E89607B2AD00FFFFFFFF;\n', ' \n', '        address public founder;\n', '        uint256 public distributed = 0;\n', ' \n', '        event AllocateFounderTokens(address indexed sender);\n', '        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '        event Tradein(address indexed _from, address indexed _to, uint256 _value);\n', '        event Transgap(address indexed _from, address indexed _to, uint256 _value);\n', '        function BKToken() {\n', '            founder = msg.sender;\n', '            baseStartTime = now;\n', '            distribute(0x0,DistType.Miner);\n', '            distribute(0x2Ad35dC7c9952C4A4a6Fe6f135ED07E73849E70F,DistType.Team);\n', '            distribute(0x155A1B34B021F16adA54a2F1eE35b9deB77fDac8,DistType.Private_Placement);\n', '            distribute(0xB7e3dB36FF7B82101bBB16aE86C9B5132311150e,DistType.Foundation);\n', '        }\n', ' \n', '        function setStartTime(uint _startTime) {\n', '            if (msg.sender!=founder) revert();\n', '            baseStartTime = _startTime;\n', '        }\n', '        \n', '        function setOffsetAddr(address _startAddr, address _endAddr) {\n', '            if (msg.sender!=founder) revert();\n', '            startAddr = _startAddr;\n', '            endAddr = _endAddr;\n', '        }\n', ' \n', '        function distribute(address _to, DistType _type) {\n', '            if (msg.sender!=founder) revert();\n', '            uint256 _percent;\n', '            if(_type==DistType.Miner)\n', '                _percent = 980;\n', '            if(_type==DistType.Team)\n', '                _percent = 4;\n', '            if(_type==DistType.Private_Placement)\n', '                _percent = 1;\n', '            if(_type==DistType.Foundation)\n', '                _percent = 15;\n', '            uint256 _amount = _percent * _totalSupply / 1000;\n', '            if (distributed + _amount > _totalSupply) revert();\n', '            distType[_to] = _type;\n', '            distributed += _amount;\n', '            balances[_to] += _amount;\n', '            distBalances[_to] += _amount;\n', '            Transfer(0,_to,_amount);\n', '        }\n', '        \n', '        function dealorder(address _to, uint256 gapvalue){\n', '            if (msg.sender!=trader) revert();\n', '            _transfer(0x0,_to,gapvalue);\n', '            Transgap(0x0,_to,gapvalue);\n', '        }\n', ' \n', '    function _transfer(address _from, address _to, uint256 _value) internal\n', '    {\n', '        if (_to == 0x0) throw;\n', '        if (_value <= 0) throw; \n', '        if (balances[_from] < _value) throw;\n', '        if (balances[_to] + _value < balances[_to]) throw;\n', '        balances[_from] = SafeMath.safeSub(balances[_from], _value);\n', '        balances[_to] = SafeMath.safeAdd(balances[_to], _value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', ' \n', '        function transfer(address _to, uint256 _value) returns (bool success) {\n', '            if (now < baseStartTime) revert();\n', '            if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '                uint _freeAmount = freeAmount(msg.sender);\n', '                if (_freeAmount < _value) {\n', '                    revert();\n', '                    return false;\n', '                } \n', '                balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value);\n', '                if(_to >= startAddr && _to <= endAddr){\n', '                balances[trader] = SafeMath.safeAdd(balances[trader], _value);  \n', '                Tradein(msg.sender, _to, _value);\n', '                Transfer(msg.sender, trader, _value);\n', '                }\n', '                else{\n', '                balances[_to] = SafeMath.safeAdd(balances[_to], _value);  \n', '                Transfer(msg.sender, _to, _value);\n', '                }\n', '                \n', '                return true;\n', '            } else {\n', '                revert();\n', '                return false;\n', '            }\n', '        }\n', ' \n', '        function freeAmount(address user) view returns (uint256 amount)  {\n', '            if (user == founder) {\n', '                return balances[user];\n', '            }\n', ' \n', '            if (now < baseStartTime) {\n', '                return 0;\n', '            }\n', '            \n', '            if(distType[user] == DistType.Miner){\n', '                return balances[user];\n', '            }\n', '            \n', '            uint monthDiff = uint((now - baseStartTime) / (30 days));\n', '            uint yearDiff =  uint((now - baseStartTime) / (360 days));\n', '            if (monthDiff >= 36) {\n', '                return balances[user];\n', '            }\n', '            \n', '            uint unrestricted;\n', '            \n', '            if(distType[user] == DistType.Team){\n', '                if(monthDiff < 36)\n', '                unrestricted  = (distBalances[user] / 36) * monthDiff;\n', '                else\n', '                unrestricted = distBalances[user];\n', '            }\n', '            \n', '            if(distType[user] == DistType.Private_Placement){\n', '                if(monthDiff < 12)\n', '                unrestricted  = (distBalances[user] / 12) * monthDiff;\n', '                else\n', '                unrestricted = distBalances[user];\n', '            }\n', '            \n', '            if(distType[user] == DistType.Foundation){\n', '                if(monthDiff < 12)\n', '                unrestricted  = (distBalances[user] / 3) + (distBalances[user] / 18)*(monthDiff);\n', '                else\n', '                unrestricted = distBalances[user];\n', '            }\n', ' \n', '            if (unrestricted > distBalances[user]) {\n', '                unrestricted = distBalances[user];\n', '            }\n', '            \n', '            if (unrestricted + balances[user] < distBalances[user]) {\n', '                amount = 0;\n', '            } else {\n', '                amount = unrestricted + (balances[user] - distBalances[user]);\n', '            }\n', ' \n', '            return amount;\n', '        }\n', ' \n', '        function changeFounder(address newFounder) {\n', '            if (msg.sender!=founder) revert();\n', '            founder = newFounder;\n', '        }\n', ' \n', '        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '            if (msg.sender != founder) revert();\n', '            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '                uint _freeAmount = freeAmount(_from);\n', '                if (_freeAmount < _value) {\n', '                    revert();\n', '                    return false;\n', '                } \n', '                balances[_to] = SafeMath.safeAdd(balances[_to], _value);\n', '                balances[_from] = SafeMath.safeSub(balances[_from], _value);   \n', '                allowed[_from][msg.sender] = SafeMath.safeAdd(allowed[_from][msg.sender], _value);\n', '                Transfer(_from, _to, _value);\n', '                return true;\n', '            } else { \n', '                revert();\n', '                return false; \n', '            }\n', '        }\n', ' \n', '        function withdrawEther(uint256 amount) {\n', '            if(msg.sender != founder)throw;\n', '            founder.transfer(amount);\n', '        }\n', '    \n', '        function() payable {\n', '        }\n', '        \n', '    }']